[
  {
    "slug": "posts/blog-opt-1",
    "title": "블로그 최적화 - 1. 메인 페이지 최적화",
    "date": "2024-03-20T01:00:00Z",
    "description": "이분 탐색의 활용에 대해 알아봅니다.",
    "tags": [
      "algorithm"
    ],
    "body": "<h1>블로그 만들기 시리즈</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>제목</th><th>링크</th></tr></thead><tbody><tr><td>1. 기본 세팅</td><td><a href=\"https://witch.work/posts/blog-remake-1\">https://witch.work/posts/blog-remake-1</a></td></tr><tr><td>2. 메인 페이지의 HTML 설계</td><td><a href=\"https://witch.work/posts/blog-remake-2\">https://witch.work/posts/blog-remake-2</a></td></tr><tr><td>3. 글 상세 페이지의 구조 설계</td><td><a href=\"https://witch.work/posts/blog-remake-3\">https://witch.work/posts/blog-remake-3</a></td></tr><tr><td>4. 이미지를 상대 경로로 쓸 수 있도록 하기</td><td><a href=\"https://witch.work/posts/blog-remake-4\">https://witch.work/posts/blog-remake-4</a></td></tr><tr><td>5. 자잘한 페이지 구성 개선과 배포</td><td><a href=\"https://witch.work/posts/blog-remake-5\">https://witch.work/posts/blog-remake-5</a></td></tr><tr><td>6. 페이지 요소의 배치 설계</td><td><a href=\"https://witch.work/posts/blog-remake-6\">https://witch.work/posts/blog-remake-6</a></td></tr><tr><td>7. 메인 페이지 컴포넌트 디자인</td><td><a href=\"https://witch.work/posts/blog-remake-7\">https://witch.work/posts/blog-remake-7</a></td></tr><tr><td>8. 글 목록/내용 페이지 컴포넌트 디자인</td><td><a href=\"https://witch.work/posts/blog-remake-8\">https://witch.work/posts/blog-remake-8</a></td></tr><tr><td>9. 글 썸네일 자동 생성하기</td><td><a href=\"https://witch.work/posts/blog-remake-9\">https://witch.work/posts/blog-remake-9</a></td></tr><tr><td>10. 폰트, 카드 디자인 등의 디자인 개선</td><td><a href=\"https://witch.work/posts/blog-remake-10\">https://witch.work/posts/blog-remake-10</a></td></tr><tr><td>11. 글에 조회수 달기</td><td><a href=\"https://witch.work/posts/blog-remake-11\">https://witch.work/posts/blog-remake-11</a></td></tr><tr><td>12. 페이지 테마와 글 검색 기능</td><td><a href=\"https://witch.work/posts/blog-remake-12\">https://witch.work/posts/blog-remake-12</a></td></tr><tr><td>13. 테마 아이콘과 썸네일 레이아웃 개선 등</td><td><a href=\"https://witch.work/posts/blog-remake-13\">https://witch.work/posts/blog-remake-13</a></td></tr><tr><td>14. 글 분류를 태그 기반으로 변경</td><td><a href=\"https://witch.work/posts/blog-remake-14\">https://witch.work/posts/blog-remake-14</a></td></tr><tr><td>메인 페이지의 연산 최적화</td><td><a href=\"https://witch.work/posts/blog-opt-1\">https://witch.work/posts/blog-opt-1</a></td></tr><tr><td>글 목록 페이지네이션 만들기</td><td><a href=\"https://witch.work/posts/blog-opt-2\">https://witch.work/posts/blog-opt-2</a></td></tr><tr><td>이미지를 CDN에 올리고 placeholder 만들기</td><td><a href=\"https://witch.work/posts/blog-opt-3\">https://witch.work/posts/blog-opt-3</a></td></tr><tr><td>검색 페이지에 무한 스크롤 구현하기</td><td><a href=\"https://witch.work/posts/blog-opt-4\">https://witch.work/posts/blog-opt-4</a></td></tr></tbody></table>\n<h1>0. 개요</h1>\n<p>블로그의 많은 기능이 완성되었다. 하지만 배포한 페이지에 들어가 보면 여전히 페이지가 꽤 느린 것을 알 수 있다. 따라서 이를 최적화하여 누가 봐도 빠른 페이지를 만들어 보는 작업을 시작하려 한다.</p>\n<p>예전에 카카오톡에서 빠른 속도를 위해 서버 기술 혁신을 하는 프로젝트에 붙였던 이름인 <a href=\"https://www.kakaocorp.com/page/detail/9350\">겁나 빠른 황소 프로젝트</a>의 이름을 따서 이 작업을 <code>겁나 빠른 마녀</code>로 명명하였다.</p>\n<h1>1. Lighthouse 검사</h1>\n<p>먼저 웹 페이지의 품질을 검사하는 구글의 유명한 오픈소스 Lighthouse로 내 페이지를 진단해 보았다. <a href=\"https://chrome.google.com/webstore/detail/lighthouse/blipmdconlkpinefehnmjammfjpmpbjk\">크롬 익스텐션</a>을 설치하고 나서 간단하게 진단 보고서를 얻을 수 있었다.</p>\n<p><img src=\"/static/lighthouse-result-first-a62aad48.png\" alt=\"lighthouse 첫번째 결과\"></p>\n<p>대충 접근성과 SEO는 괜찮고(최고다 next-seo!), 성능은 별로이며 Best Practice도 미흡하다. PWA도 아직 멀었다고 한다. 특히 성능과 같은 경우 나머지 요소는 다 괜찮은데 Total blocking time(사용자가 페이지와 상호작용할 수 있기까지 걸리는 시간)이 1220ms로 처참하다. <a href=\"https://developer.chrome.com/docs/lighthouse/performance/lighthouse-total-blocking-time/?utm_source=lighthouse&#x26;utm_medium=lr#how-lighthouse-determines-your-tbt-score\">TBT가 200ms 아래로 내려와야 좋은 점수를 받을 수 있는데</a> 그 6배 이상 걸리는 것이다.</p>\n<p>따라서 성능 최적화를 열심히 하자. 생각나는 대로 최적화한 기록을 순서대로 쓴다. 어떻게 최적화하는지 몰라서 하나하나 찾아가며 했기 때문에 순서는 좀 뒤죽박죽이다.</p>\n<h1>2. getStaticProps로 연산 이동</h1>\n<p>메인 페이지를 보면 지금 <code>Home</code> 컴포넌트 내에서 계속 <code>getSortedPosts</code>를 호출하고 있다. 이 부분은 빌드 이후에 특별히 바뀌는 부분이 아니므로 <code>getStaticProps</code>로 이동시키자. 이렇게 하면 빌드 시에만 호출되기 때문에 빌드 시간이 좀 늘어날 수도 있겠지만, 빌드된 페이지는 빠르게 로딩될 것이다.</p>\n<p>또한 저장된 글들의 정보 중 글 목록 렌더링에 필요한 정보들만 넘기도록 하자.</p>\n<p>일단 <code>src/pages/index.tsx</code>의 <code>Home</code>컴포넌트에서 <code>getSortedPosts</code>를 호출하는 부분을 지우고, <code>src/pages/index.tsx</code>의 <code>getStaticProps</code>를 다음과 같이 수정한다.</p>\n<pre><code class=\"language-tsx\">/* getStaticProps에서 쓰이는 타입 */\ninterface CardProps{\n  title: string;\n  description: string;\n  image?: string;\n  date: string;\n  tags: string[];\n  url: string;\n}\n/* 필요한 요소들만 객체에서 뽑아내는 함수 */\nfunction propsProperty(post: DocumentTypes) {\n  const { title, description, date, tags, url } = post;\n  return { title, description, date, tags, url };\n}\n\nexport const getStaticProps: GetStaticProps = () => {\n  const categoryPostMap: {[key: string]: CardProps[]}={};\n\n  blogCategoryList.forEach((category)=>{\n    categoryPostMap[category.url]=getSortedPosts()\n      .filter((post: DocumentTypes)=>{\n        return post._raw.flattenedPath.split('/')[0]===category.url.split('/').pop();\n      })\n      .slice(0, 3)\n      .map((post: DocumentTypes)=>{\n        return propsProperty(post);\n      });\n  });\n\n  return { props: { categoryPostMap } };\n};\n</code></pre>\n<p>이렇게 하면 <code>{\"카테고리 URL\":[카테고리에 속한 글 목록 상위 3개]}</code>가 담긴 객체가 페이지 컴포넌트의 props로 넘어간다. 이를 이용해서 아까와 똑같이 글 목록을 보여주자.</p>\n<pre><code class=\"language-tsx\">export default function Home({\n  categoryPostMap\n}: InferGetStaticPropsType&#x3C;typeof getStaticProps>) {\n  return (\n    &#x3C;main className={styles.pagewrapper}>\n      &#x3C;div className={styles.container}>\n        &#x3C;Profile />\n        {/* 프로젝트 목록을 만들기 */}\n        &#x3C;ProjectList />\n        &#x3C;article>\n          {/* 카테고리별 글 목록을 만들기 */}\n          {blogCategoryList.map((category) => {\n            const categoryPostList=categoryPostMap[category.url];\n\n            return categoryPostList.length?\n              &#x3C;Category \n                key={category.title} \n                title={category.title} \n                url={category.url} \n                items={categoryPostList}\n              />:null;\n          })}\n        &#x3C;/article>\n      &#x3C;/div>\n    &#x3C;/main>\n  );\n}\n</code></pre>\n<p>이렇게 하고 나니 lighthouse 지표가 매우 좋아졌다. 470ms면 거의 반으로 줄어든 것이다! 빌드 시점에 연산을 미리 해두고, 필요한 정보를 넘기는 게 얼마나 중요한지 알 수 있다.</p>\n<p><img src=\"/static/lighthouse-after-getStaticProps-e78c1eb7.png\" alt=\"lighthouse 두번째 결과\"></p>\n<h1>3. 이미지 최적화 - next/image</h1>\n<p>지금 내 블로그의 가장 큰 문제는 앞서 보았든 로딩이 너무 느리다는 것이다. NextJS에서는 여러 이미지 최적화를 지원하기에 이것부터 해보자.</p>\n<p>일단 Nextjs의 이미지 최적화를 켠다. <code>next.config.js</code>에서 아까 Cloudflare 때문에 꺼놨던 image 최적화를 켜주자. 적어도 메인 페이지에서는 next/image의 <code>Image</code> 컴포넌트만 사용하고 있기 때문에 이게 모두 적용될 것이다.</p>\n<pre><code class=\"language-ts\">const { withContentlayer } = require('next-contentlayer');\n\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  images:{\n    unoptimized:false,\n  },\n  reactStrictMode: false,\n  swcMinify:false,\n};\n\nmodule.exports = (withContentlayer(nextConfig));\n</code></pre>\n<h1>4. 이미지 최적화 - image size</h1>\n<p>lighthouse의 제안을 보면 이미지 사이즈를 잘 설정하라고 하며 <code>next/image</code> 튜토리얼의 <a href=\"https://nextjs.org/docs/pages/api-reference/components/image#sizes\">sizes 항목</a>으로 링크를 걸어 준다.</p>\n<p><code>Image</code> 태그의 sizes 프로퍼티는 렌더링 시 srcset에서 어떤 이미지를 다운로드할지를 결정하며, 또한 <code>next/image</code>에서 어떤 source set을 자동 생성할지를 결정한다.</p>\n<p>sizes를 설정해 주지 않으면 기본 크기를 쓰거나 고정 크기 이미지를 자동으로 생성하는데, 만약 이미지가 실제로 들어갈 크기보다 상당히 큰 크기의 이미지를 생성하게 되어 성능에 안 좋은 영향을 미치게 될 수 있다. 이를 방지하기 위해 sizes를 설정해 주자.</p>\n<p>메인 페이지의 이미지는 프로젝트 소개에 쓰이는 게 전부인데, 이는 <code>src/components/projectCard/image/index.tsx</code>에 정의되어 있다. 여기에 있는 Image 컴포넌트에 sizes를 지정해주자.</p>\n<pre><code class=\"language-tsx\">// src/components/projectCard/image/index.tsx\nfunction ProjectImage({title, image}: {title: string, image: string}) {\n  return (\n    &#x3C;div className={styles.container}>\n      &#x3C;Image\n        className={styles.image}\n        src={image} \n        alt={`${title} 프로젝트 사진`}\n        width={300}\n        height={300}\n        {/* sizes가 추가되었다. */}\n        sizes='(max-width: 768px) 150px, 300px'\n      />\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<p>이렇게 하니까 TBT가 300ms 초반대 정도로 내려왔고, 200ms대를 찍기도 했다. 그리고 생각해 보니 메인 페이지에는 이미지가 하나 더 있다. 바로 내 소개 컴포넌트에 있는 프로필 사진이다. 여기에도 sizes를 지정해주자.</p>\n<pre><code class=\"language-tsx\">// src/components/profile/index.tsx\nfunction Profile() {\n  return (\n    &#x3C;article className={styles.profile}>\n      &#x3C;Image \n        className={styles.image} \n        src={blogConfig.picture} \n        alt={`${blogConfig.name}의 프로필 사진`} \n        width={100}\n        height={100}\n        sizes='100px'\n      />\n      &#x3C;Intro />\n    &#x3C;/article>\n  );\n}\n</code></pre>\n<p>그리고 <code>next.config.js</code> 파일에서 <code>images.imageSizes</code>와 <code>images.deviceSizes</code>를 지정하여 <a href=\"https://nextjs.org/docs/pages/api-reference/components/image#devicesizes\">이미지의 srcset을 지정할 수 있다.</a>이를 이용해서 이미지의 srcset이 지나치게 많아지지 않도록 하자.</p>\n<p>이렇게 하면 이미지에 대한 초기 요청이 들어왔을 때 이미지를 생성하는 시간이 줄어드는 효과가 있다고 한다. <a href=\"https://fe-developers.kakaoent.com/2022/220714-next-image/\">참고</a> 따라서 srcset이 4개만 생기도록 다음과 같이 <code>next.config.js</code>를 편집하였다.</p>\n<pre><code class=\"language-ts\">const { withContentlayer } = require('next-contentlayer');\n\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  images:{\n    unoptimized:false,\n    imageSizes: [64, 384],\n    deviceSizes: [768, 1920],\n  },\n  reactStrictMode: false,\n  swcMinify:false,\n};\n\nmodule.exports = (withContentlayer(nextConfig));\n</code></pre>\n<p>더 정진하여 200ms 아래로 내려보자.</p>\n<h1>5. 안 쓰이는 JS 삭제</h1>\n<p>Lighthouse에서는 <code>Reduce unused JavaScript</code>도 제안한다. 제안 전문은 이렇다.</p>\n<pre><code>Reduce unused JavaScript and defer loading scripts until they are required to decrease bytes consumed by network activity. \n</code></pre>\n<p>대충 사용하지 않는 JS 코드는 좀 삭제하거나 필요할 때까지 로딩을 미루라는 말이다. 무슨 JS 코드가 말썽인지 볼까?</p>\n<p><img src=\"/static/reduce-js-82397868.png\" alt=\"사용하지 않는 JS 코드\"></p>\n<p>누가 봐도 google tag manager가 문제인 것 같다. 따라서 이를 제공하는 컴포넌트인 <code>GoogleAnalytics.tsx</code>를 편집하자. script의 로딩 전략을 <code>lazyOnload</code>로 바꾸면 된다. <a href=\"https://blog.jarrodwatts.com/track-user-behaviour-on-your-website-with-google-analytics-and-nextjs\">이렇게 해도 ga는 잘 작동한다.</a></p>\n<pre><code class=\"language-tsx\">const GoogleAnalytics = () => {\n  if (blogConfig.googleAnalyticsId == null) {\n    return null;\n  }\n  return (\n    &#x3C;>\n      &#x3C;Script\n        src={`https://www.googletagmanager.com/gtag/js?id=${blogConfig.googleAnalyticsId}`}\n        strategy='lazyOnload'\n      />\n      &#x3C;Script id='google-analytics' strategy='lazyOnload'>\n        {`\n          window.dataLayer = window.dataLayer || [];\n          function gtag(){window.dataLayer.push(arguments);}\n          gtag('js', new Date());\n\n          gtag('config', '${blogConfig.googleAnalyticsId}');\n        `}\n      &#x3C;/Script>\n    &#x3C;/>\n  );\n};\n</code></pre>\n<p>별로 시간이 크게 줄어들지는 않는 것 같다. <a href=\"https://stackoverflow.com/questions/69449732/reduce-unused-javascript-from-gtm-script\">그리고 구글 태그매니저는 원래 네트워크 요청을 하므로 실행 시간에 약간 영향을 줄 수밖에 없다.</a></p>\n<p><a href=\"https://all-dev-kang.tistory.com/entry/Next-%EC%9B%B9%ED%8E%98%EC%9D%B4%EC%A7%80%EC%9D%98-%EC%84%B1%EB%8A%A5-%EA%B0%9C%EC%84%A0%EC%9D%84-%ED%95%B4%EB%B3%B4%EC%9E%90-1-featlighthouse\">다만 여기를 보니 익스텐션도 lighthouse 측정에 영향을 주는 것 같다. 시크릿 창에서 해보니 점수가 꽤 높다.</a></p>\n<h1>6. 폰트, 서버리스 최적화</h1>\n<p>그리고 혹시나 해서 canvas를 이용해 썸네일을 만들 때 쓰는 폰트도 더 가벼운 걸 썼다. <a href=\"http://theeluwin.github.io/NotoSansKR-Hestia/\">경량화된 노토 산스 한글 웹폰트</a>에서 Bold 체를 사용하였다. 기존에 쓰던 <code>.otf</code> 파일은 거의 5MB였는데 이건 300KB도 안 된다.</p>\n<p>그리고 <a href=\"https://vercel.com/docs/concepts/functions/serverless-functions/regions#select-a-default-serverless-region\">기본 서버리스 리전</a>을 바꾼다. 인천 리전이 있길래 그곳으로 했다. 이렇게 하면 supabase의 한국 리전과도 가까우니까 api 라우트가 더 빨라질 거라고 기대된다. (기본 리전은 미국 어딘가였다)</p>\n<p>어디가 어디에 영향을 주었는지 완벽히 알아내기는 힘들지만, 이쯤 하니까 대충 200ms대에 TBT가 안정화되었다. 100ms대를 찍기도 했다. 물론 이런 게 원래 그렇듯이 시간이 가끔 널뛰어서 500ms를 찍기도 하고 그랬지만, 그래도 꽤 빨라졌다.</p>\n<p><img src=\"/static/lighthouse-good-result-dd1dea66.png\" alt=\"메인 페이지에서 lighthouse의 좋은 결과\"></p>\n<p>더 줄일 수도 있겠지만 메인 페이지는 충분히 빨라진 것 같고, 또 메인 페이지 외에 글 상세 페이지나 글 목록 페이지 등 불러올 이미지가 많은 곳에서는 여전히 페이지가 느리며 아직 해야 할 것도 많으므로 이 정도만 해두자. Best Practice도 어느 정도는 고쳐야 하고...</p>\n<h1>7. Reduce initial server response time</h1>\n<p>많은 실험이 있었는데, 위와 같이 처음의 서버 응답 시간을 줄이라는 이야기가 많이 나왔다. 이게 나오지 않을 때는 퍼포먼스가 크게 좋아졌지만 이 메시지를 꽤 자주 보게 되었다.</p>\n<p><img src=\"/static/reduce-initial-server-response-time-dbcbbef1.png\" alt=\"reduce-initial-server-response-time\"></p>\n<p>이건 사실 LCP에 영향을 미치게 되는데, 사용자에게 보이는 부분에도 확실히 영향을 미친다? 왜냐? 페이지가 페인트되는 부분이니까...이 부분에 대한 최적화는 한 3번째 글에서 진행할 듯 하다.</p>\n<p>먼저 글목록/글상세페이지에서 할 수 있는 걸 해보자.</p>\n<h1>참고</h1>\n<p>Lighthouse 사용 <a href=\"https://velog.io/@dell_mond/Lighthouse-%EC%82%AC%EC%9A%A9%EB%B2%95\">https://velog.io/@dell_mond/Lighthouse-%EC%82%AC%EC%9A%A9%EB%B2%95</a></p>\n<p>Lighthouse의 결과 지표들 <a href=\"https://medium.com/jung-han/%EB%9D%BC%EC%9D%B4%ED%8A%B8%ED%95%98%EC%9A%B0%EC%8A%A4-%EC%84%B1%EB%8A%A5-%EC%A7%80%ED%91%9C-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0-83df3dc96fb9\">https://medium.com/jung-han/%EB%9D%BC%EC%9D%B4%ED%8A%B8%ED%95%98%EC%9A%B0%EC%8A%A4-%EC%84%B1%EB%8A%A5-%EC%A7%80%ED%91%9C-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0-83df3dc96fb9</a></p>\n<p>네이버의 SEO 문서 <a href=\"https://searchadvisor.naver.com/guide/seo-basic-intro\">https://searchadvisor.naver.com/guide/seo-basic-intro</a></p>\n<p>Next 이미지 최적화하기 <a href=\"https://fe-developers.kakaoent.com/2022/220714-next-image/\">https://fe-developers.kakaoent.com/2022/220714-next-image/</a></p>\n<p>Nextjs Script 태그 <a href=\"https://nextjs.org/docs/app/api-reference/components/script#strategy\">https://nextjs.org/docs/app/api-reference/components/script#strategy</a></p>\n<p>lazyOnload로 로딩해도 gtag는 잘 작동한다. <a href=\"https://blog.jarrodwatts.com/track-user-behaviour-on-your-website-with-google-analytics-and-nextjs\">https://blog.jarrodwatts.com/track-user-behaviour-on-your-website-with-google-analytics-and-nextjs</a></p>\n<p><a href=\"https://all-dev-kang.tistory.com/entry/Next-%EC%9B%B9%ED%8E%98%EC%9D%B4%EC%A7%80%EC%9D%98-%EC%84%B1%EB%8A%A5-%EA%B0%9C%EC%84%A0%EC%9D%84-%ED%95%B4%EB%B3%B4%EC%9E%90-1-featlighthouse\">https://all-dev-kang.tistory.com/entry/Next-%EC%9B%B9%ED%8E%98%EC%9D%B4%EC%A7%80%EC%9D%98-%EC%84%B1%EB%8A%A5-%EA%B0%9C%EC%84%A0%EC%9D%84-%ED%95%B4%EB%B3%B4%EC%9E%90-1-featlighthouse</a></p>\n<p><a href=\"http://theeluwin.github.io/NotoSansKR-Hestia/\">http://theeluwin.github.io/NotoSansKR-Hestia/</a></p>\n<p><a href=\"https://www.oooooroblog.com/posts/62-optimize-images\">https://www.oooooroblog.com/posts/62-optimize-images</a></p>\n<p><a href=\"https://velog.io/@ooooorobo/Lighthouse%EB%A1%9C-Next.js-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%84%B1%EB%8A%A5-%EA%B0%9C%EC%84%A0%ED%95%98%EA%B8%B0#%EB%9D%BC%EC%9D%B4%ED%8A%B8%ED%95%98%EC%9A%B0%EC%8A%A4%EA%B0%80-%EB%8F%8C%EC%A7%80-%EC%95%8A%EC%9D%84-%EB%95%8C\">https://velog.io/@ooooorobo/Lighthouse%EB%A1%9C-Next.js-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%84%B1%EB%8A%A5-%EA%B0%9C%EC%84%A0%ED%95%98%EA%B8%B0#%EB%9D%BC%EC%9D%B4%ED%8A%B8%ED%95%98%EC%9A%B0%EC%8A%A4%EA%B0%80-%EB%8F%8C%EC%A7%80-%EC%95%8A%EC%9D%84-%EB%95%8C</a></p>",
    "permalink": "/blog/posts/blog-opt-1"
  },
  {
    "slug": "posts/blog-refactor-2024-1",
    "title": "블로그 리팩토링 - 1. contentlayer에서 velite로",
    "date": "2024-03-20T01:00:00Z",
    "description": "이분 탐색의 활용에 대해 알아봅니다.",
    "tags": [
      "algorithm"
    ],
    "body": "<p>nextjs 14가 나왔고, 블로그에 쓰였던 라이브러리들도 업데이트가 많이 되었다. 또한 지금 다 파악할 수 없는 여러 가지 이유로 블로그 속도도 많이 느려졌다. 그래서 블로그를 리팩토링 해보기로 했다. 리팩토링을 하고 나서 최적화를 진행할 것이다.</p>\n<h1>to pnpm</h1>\n<p>기존에 yarn classic을 사용하고 있었는데 pnpm으로 전환하였다. 다음 글을 참고했다.</p>\n<p><a href=\"https://medium.com/wantedjobs/yarn-classic%EC%97%90%EC%84%9C-pnpm%EC%9C%BC%EB%A1%9C-%EC%A0%84%ED%99%98%ED%95%98%EA%B8%B0-with-turborepo-7c0c37cb3f9e\">Yarn Classic에서 Pnpm으로 전환하기 with TurboRepo</a></p>\n<h1>1. contentlayer의 대안들</h1>\n<p><code>.md</code> 파일을 변환할 때 contentlayer라는 라이브러리를 사용하였다. <a href=\"https://github.com/contentlayerdev/contentlayer/issues/429\">하지만 이는 더 이상 유지보수되지 않고 있다.</a></p>\n<p>contentlayer의 원래 메인테이너는 Prisma에 관여하고 있고 후원을 받지 않는 개발은 할 수 없는 상태인데 Vercel에서 contentlayer에 대한 후원을 중단했다고 한다. netlify와 협의 중이지만 어떻게 될지 모른다고 한다.</p>\n<p>그래서 대안을 찾아 보기로 했다. 먼저 contentlayer는 제거하였다.</p>\n<pre><code class=\"language-bash\">yarn remove contentlayer next-contentlayer\n</code></pre>\n<h2>1.1. @next/mdx</h2>\n<p><a href=\"https://nextjs.org/docs/app/building-your-application/configuring/mdx\">nextjs 공식 문서에서도 마크다운을 변환하는 방법을 소개하고 있었다.</a> 공식 문서에도 있는 만큼 contentlayer와 같이 갑자기 유지보수가 중단되지 않을 것이다.</p>\n<p>하지만 몇 가지 단점이 있었다.</p>\n<p>먼저 contentlayer에서는 프로젝트 루트의 /posts 경로에서 글을 관리했었는데 모든 글을 app/ 디렉토리에 넣어야 한다. next-mdx-remote를 사용하여 해결할 수 있지만 rsc 지원이 아직 불안정하고 또한 next-mdx-remote는 원격으로 데이터를 가져오기 위한 라이브러리인데 이를 다른 로컬 경로에 있는 파일을 가져오기 위한 라이브러리로 사용하는 것은 좋지 않다.</p>\n<p>또한 원하는 대로 커스터마이징하기 어렵다. contentlayer는 아예 .md 파일 내용을 HTML 형식의 문자열로 만들어 주고 이를 사용자가 가져다가 커스터마이징할 수 있었다. 하지만 <code>@next/mdx</code>는 .md나 .mdx 파일을 하나의 페이지로 만드는 형식이기 때문에 커스텀이 상대적으로 어렵다.</p>\n<p>각 컴포넌트의 스타일링도 CSS를 통해서 쉽게 할 수 있었던 contentlayer와 달리 <code>mdx-components.tsx</code> 파일을 만들어서 커스텀 컴포넌트를 만들어야 한다.</p>\n<p>기존 코드와의 호환성과 유지보수를 위해 다른 대안을 찾아보기로 했다.</p>\n<h2>1.2. marked</h2>\n<p><a href=\"https://blog.itcode.dev/posts/2021/10/28/nextjs-reorganization-4\">블로그 개편기 - 4. marked를 활용한 마크다운 변환기 구현하기</a>에서 사용하고 있는 marked 라이브러리도 방법이었다.</p>\n<p>하지만 이 역시 따로 .md 파일을 HTML로 변환하는 방법을 찾아야 하고, 커스텀 컴포넌트를 만들어야 한다. 잘 사용하고 있던 remark와 rehype 플러그인도 버려야 한다. 기각했다.</p>\n<h2>1.3. velite</h2>\n<p><a href=\"https://github.com/contentlayerdev/contentlayer/issues/429\">contentlayer의 유지보수 이슈</a>를 보면 velite라는 라이브러리의 제작자가 홍보하고 있었다. 스타는 고작 173개짜리 라이브러리다. 당연히 많이 사용되는 라이브러리는 아닌 것 같다.</p>\n<p>하지만 contentlayer에 비해 훨씬 코드가 간단했고 마크다운의 타입 정의도 지원했으며 기존 contentlayer 코드와 호환성도 좋았다. 그래서 이를 사용하기로 했다. 오픈소스 기여를 탐내고 있는 나로서는 이 라이브러리에 기여하면서 쓸 수도 있을 것이다.</p>\n<p>그래서 이 글에서는 기존의 contentlayer를 velite로 대체하는 작업을 진행할 것이다.</p>\n<h1>참고</h1>\n<p><a href=\"https://velog.io/@gomiseki/Next.js%EC%97%90%EC%84%9C-MDX-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%A5%BC-%EC%8A%A4%ED%83%80%EC%9D%BC%EB%A7%81%ED%95%98%EA%B8%B0-%ED%8E%B8%ED%95%98%EA%B2%8C\">Next.js에서 MDX 컴포넌트를 스타일링하기 (편?하게)</a></p>\n<p><a href=\"https://nextjs.org/docs/app/building-your-application/configuring/mdx\">Next.js docs - Markdown and MDX</a></p>\n<p><a href=\"https://medium.com/wantedjobs/yarn-classic%EC%97%90%EC%84%9C-pnpm%EC%9C%BC%EB%A1%9C-%EC%A0%84%ED%99%98%ED%95%98%EA%B8%B0-with-turborepo-7c0c37cb3f9e\">Yarn Classic에서 Pnpm으로 전환하기 with TurboRepo</a></p>",
    "permalink": "/blog/posts/blog-refactor-2024-1"
  }
]