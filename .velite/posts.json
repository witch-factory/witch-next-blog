[
  {
    "slug": "blog-opt-1",
    "title": "블로그 최적화 - 1. 메인 페이지 최적화",
    "date": "2024-03-20T01:00:00Z",
    "description": "이분 탐색의 활용에 대해 알아봅니다.",
    "tags": [
      "algorithm"
    ],
    "html": "<h1>0. 개요</h1>\n<p>블로그의 많은 기능이 완성되었다. 하지만 배포한 페이지에 들어가 보면 여전히 페이지가 꽤 느린 것을 알 수 있다. 따라서 이를 최적화하여 누가 봐도 빠른 페이지를 만들어 보는 작업을 시작하려 한다.</p>\n<p>예전에 카카오톡에서 빠른 속도를 위해 서버 기술 혁신을 하는 프로젝트에 붙였던 이름인 <a href=\"https://www.kakaocorp.com/page/detail/9350\">겁나 빠른 황소 프로젝트</a>의 이름을 따서 이 작업을 <code>겁나 빠른 마녀</code>로 명명하였다.</p>\n<h1>1. Lighthouse 검사</h1>\n<p>먼저 웹 페이지의 품질을 검사하는 구글의 유명한 오픈소스 Lighthouse로 내 페이지를 진단해 보았다. <a href=\"https://chrome.google.com/webstore/detail/lighthouse/blipmdconlkpinefehnmjammfjpmpbjk\">크롬 익스텐션</a>을 설치하고 나서 간단하게 진단 보고서를 얻을 수 있었다.</p>\n<p><img src=\"/static/lighthouse-result-first-a62aad48.png\" alt=\"lighthouse 첫번째 결과\"></p>\n<p>대충 접근성과 SEO는 괜찮고(최고다 next-seo!), 성능은 별로이며 Best Practice도 미흡하다. PWA도 아직 멀었다고 한다. 특히 성능과 같은 경우 나머지 요소는 다 괜찮은데 Total blocking time(사용자가 페이지와 상호작용할 수 있기까지 걸리는 시간)이 1220ms로 처참하다. <a href=\"https://developer.chrome.com/docs/lighthouse/performance/lighthouse-total-blocking-time/?utm_source=lighthouse&#x26;utm_medium=lr#how-lighthouse-determines-your-tbt-score\">TBT가 200ms 아래로 내려와야 좋은 점수를 받을 수 있는데</a> 그 6배 이상 걸리는 것이다.</p>\n<p>따라서 성능 최적화를 열심히 하자. 생각나는 대로 최적화한 기록을 순서대로 쓴다. 어떻게 최적화하는지 몰라서 하나하나 찾아가며 했기 때문에 순서는 좀 뒤죽박죽이다.</p>\n<p><img src=\"/static/lighthouse-good-result-dd1dea66.png\" alt=\"테스트 이미지\"></p>\n<h1>2. getStaticProps로 연산 이동</h1>\n<p>메인 페이지를 보면 지금 <code>Home</code> 컴포넌트 내에서 계속 <code>getSortedPosts</code>를 호출하고 있다. 이 부분은 빌드 이후에 특별히 바뀌는 부분이 아니므로 <code>getStaticProps</code>로 이동시키자. 이렇게 하면 빌드 시에만 호출되기 때문에 빌드 시간이 좀 늘어날 수도 있겠지만, 빌드된 페이지는 빠르게 로딩될 것이다.</p>\n<p>또한 저장된 글들의 정보 중 글 목록 렌더링에 필요한 정보들만 넘기도록 하자.</p>\n<p><img src=\"/static/reduce-js-82397868.png\" alt=\"테스트 이미지 2\"></p>\n<p>일단 <code>src/pages/index.tsx</code>의 <code>Home</code>컴포넌트에서 <code>getSortedPosts</code>를 호출하는 부분을 지우고, <code>src/pages/index.tsx</code>의 <code>getStaticProps</code>를 다음과 같이 수정한다.</p>",
    "excerpt": "0. 개요\n블로그의 많은 기능이 완성되었다. 하지만 배포한 페이지에 들어가 보면 여전히 페이지가 꽤 느린 것을 알 수 있다. 따라서 이를 최적화하여 누가 봐도 빠른 페이지를 만들어 보는 작업을 시작하려 한다.\n예전에 카카오톡에서 빠른 속도를 위해 서버 기술 혁신을 하는 프로젝트에 붙였던 이름인 겁나 빠른 황소 프로젝트의 이름을 따서 이 작업을 겁나 빠른 마녀로 명명하였다.\n1. Lighthouse 검사\n먼저 웹 페이지의 품질을 검사하는 구글의 유명한 오픈소스 L",
    "headingTree": [
      {
        "title": "0. 개요",
        "url": "#0-개요",
        "items": []
      },
      {
        "title": "1. Lighthouse 검사",
        "url": "#1-lighthouse-검사",
        "items": []
      },
      {
        "title": "2. getStaticProps로 연산 이동",
        "url": "#2-getstaticprops로-연산-이동",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 29
    },
    "url": "/posts/blog-opt-1",
    "thumbnail": {
      "local": "/static/lighthouse-result-first-a62aad48.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-lighthouse-result-first-a62aad48-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAj0lEQVR4nGP4////548fXr948h8MTp89e/rs2f///zP8+ft36bwpnXVFv/78+f//PxMzW0VFFUji/v2Hs2fNau7sOXT0zP///+sbmqA6Tpw6deP2re/fv//////2ndunz5598/bt8+cvGFYsX5qdkQaxYOXaVVOmToEoYtiwacOqFUu/f//+Dgz+/P0LYQAAYcJ2Ol9Vb4wAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "blog-refactor-2024-1",
    "title": "블로그 리팩토링 - 1. contentlayer에서 velite로",
    "date": "2024-03-20T01:00:00Z",
    "description": "이분 탐색의 활용에 대해 알아봅니다.",
    "tags": [
      "algorithm"
    ],
    "html": "<p>nextjs 14가 나왔고, 블로그에 쓰였던 라이브러리들도 업데이트가 많이 되었다. 또한 지금 다 파악할 수 없는 여러 가지 이유로 블로그 속도도 많이 느려졌다. 그래서 블로그를 리팩토링 해보기로 했다. 리팩토링을 하고 나서 최적화를 진행할 것이다.</p>\n<h1>to pnpm</h1>\n<p>기존에 yarn classic을 사용하고 있었는데 pnpm으로 전환하였다. 다음 글을 참고했다.</p>\n<p><a href=\"https://medium.com/wantedjobs/yarn-classic%EC%97%90%EC%84%9C-pnpm%EC%9C%BC%EB%A1%9C-%EC%A0%84%ED%99%98%ED%95%98%EA%B8%B0-with-turborepo-7c0c37cb3f9e\">Yarn Classic에서 Pnpm으로 전환하기 with TurboRepo</a></p>\n<h1>1. contentlayer의 대안들</h1>\n<p><code>.md</code> 파일을 변환할 때 contentlayer라는 라이브러리를 사용하였다. <a href=\"https://github.com/contentlayerdev/contentlayer/issues/429\">하지만 이는 더 이상 유지보수되지 않고 있다.</a></p>\n<p>contentlayer의 원래 메인테이너는 Prisma에 관여하고 있고 후원을 받지 않는 개발은 할 수 없는 상태인데 Vercel에서 contentlayer에 대한 후원을 중단했다고 한다. netlify와 협의 중이지만 어떻게 될지 모른다고 한다.</p>\n<p>그래서 대안을 찾아 보기로 했다. 먼저 contentlayer는 제거하였다.</p>\n<pre><code class=\"language-bash\">yarn remove contentlayer next-contentlayer\n</code></pre>\n<h2>1.1. @next/mdx</h2>\n<p><a href=\"https://nextjs.org/docs/app/building-your-application/configuring/mdx\">nextjs 공식 문서에서도 마크다운을 변환하는 방법을 소개하고 있었다.</a> 공식 문서에도 있는 만큼 contentlayer와 같이 갑자기 유지보수가 중단되지 않을 것이다.</p>\n<p>하지만 몇 가지 단점이 있었다.</p>\n<p>먼저 contentlayer에서는 프로젝트 루트의 /posts 경로에서 글을 관리했었는데 모든 글을 app/ 디렉토리에 넣어야 한다. next-mdx-remote를 사용하여 해결할 수 있지만 rsc 지원이 아직 불안정하고 또한 next-mdx-remote는 원격으로 데이터를 가져오기 위한 라이브러리인데 이를 다른 로컬 경로에 있는 파일을 가져오기 위한 라이브러리로 사용하는 것은 좋지 않다.</p>\n<p>또한 원하는 대로 커스터마이징하기 어렵다. contentlayer는 아예 .md 파일 내용을 HTML 형식의 문자열로 만들어 주고 이를 사용자가 가져다가 커스터마이징할 수 있었다. 하지만 <code>@next/mdx</code>는 .md나 .mdx 파일을 하나의 페이지로 만드는 형식이기 때문에 커스텀이 상대적으로 어렵다.</p>\n<p>각 컴포넌트의 스타일링도 CSS를 통해서 쉽게 할 수 있었던 contentlayer와 달리 <code>mdx-components.tsx</code> 파일을 만들어서 커스텀 컴포넌트를 만들어야 한다.</p>\n<p>기존 코드와의 호환성과 유지보수를 위해 다른 대안을 찾아보기로 했다.</p>\n<h2>1.2. marked</h2>\n<p><a href=\"https://blog.itcode.dev/posts/2021/10/28/nextjs-reorganization-4\">블로그 개편기 - 4. marked를 활용한 마크다운 변환기 구현하기</a>에서 사용하고 있는 marked 라이브러리도 방법이었다.</p>\n<p>하지만 이 역시 따로 .md 파일을 HTML로 변환하는 방법을 찾아야 하고, 커스텀 컴포넌트를 만들어야 한다. 잘 사용하고 있던 remark와 rehype 플러그인도 버려야 한다. 기각했다.</p>\n<h2>1.3. velite</h2>\n<p><a href=\"https://github.com/contentlayerdev/contentlayer/issues/429\">contentlayer의 유지보수 이슈</a>를 보면 velite라는 라이브러리의 제작자가 홍보하고 있었다. 스타는 고작 173개짜리 라이브러리다. 당연히 많이 사용되는 라이브러리는 아닌 것 같다.</p>\n<p>하지만 contentlayer에 비해 훨씬 코드가 간단했고 마크다운의 타입 정의도 지원했으며 기존 contentlayer 코드와 호환성도 좋았다. 그래서 이를 사용하기로 했다. 오픈소스 기여를 탐내고 있는 나로서는 이 라이브러리에 기여하면서 쓸 수도 있을 것이다.</p>\n<p>그래서 이 글에서는 기존의 contentlayer를 velite로 대체하는 작업을 진행할 것이다.</p>\n<h1>2. 설치와 기본 설정</h1>\n<p><a href=\"https://velite.js.org/\">velite 공식 문서</a>를 참고하였다.</p>\n<pre><code class=\"language-bash\">pnpm add velite -D\n</code></pre>\n<p>현재 contentlayer의 변환 문서 형식</p>\n<pre><code class=\"language-json\">{\n  \"title\": \"C-through - 1. Implicit int rule\",\n  \"description\": \"C언어의 implicit int rule에 대하여\",\n  \"date\": \"2022-01-09T00:00:00.000Z\",\n  \"tags\": [\n    \"language\"\n  ],\n  \"body\": {\n    \"raw\": \"글의 내용 그대로\",\n    \"html\": \"글 내용을 변환한 HTML 형식 문자열\"\n  },\n  \"_id\": \"c-through-1/index.md\",\n  \"_raw\": {\n    \"sourceFilePath\": \"c-through-1/index.md\",\n    \"sourceFileName\": \"index.md\",\n    \"sourceFileDir\": \"c-through-1\",\n    \"contentType\": \"markdown\",\n    \"flattenedPath\": \"c-through-1\",\n    \"headingTree\": [\n      {\n        \"data\": {\n          \"hProperties\": {\n            \"title\": \"1. C-through\",\n            \"id\": \"1.-C-through\"\n          }\n        },\n        \"depth\": 1,\n        \"children\": []\n      },\n      {\n        \"data\": {\n          \"hProperties\": {\n            \"title\": \"2. \\\"Implicit int\\\" rule\",\n            \"id\": \"2.-\\\"Implicit-int\\\"-rule\"\n          }\n        },\n        \"depth\": 1,\n        \"children\": []\n      },\n      {\n        \"data\": {\n          \"hProperties\": {\n            \"title\": \"3. 참고\",\n            \"id\": \"3.-참고\"\n          }\n        },\n        \"depth\": 1,\n        \"children\": []\n      }\n    ],\n    \"thumbnail\": {\n      \"local\": \"/thumbnails/c-through-1-index-md-thumbnail.png\",\n      \"cloudinary\": \"https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/thumbnails-c-through-1-index-md-thumbnail-png\",\n      \"blurURL\": \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAgUlEQVR4nGNYvXp1SkpKenq6t7f30qVLd+7c+R8MGHp7e6WlpdXU1Dg4OLKysl69evX792+QREtLi5yc3MWLF69evXrjxg2IcpDEnj27m5ubjhw58uXLl99gAJWYM2dxaGhYYmLi0qVLr169+v//f6hREVG5be19O3fuQBb9//8/ALhkZ3yrHgJ0AAAAAElFTkSuQmCC\"\n    }\n  },\n  \"type\": \"Post\",\n  \"url\": \"/posts/c-through-1\"\n}\n</code></pre>\n<h1>참고</h1>\n<p><a href=\"https://velog.io/@gomiseki/Next.js%EC%97%90%EC%84%9C-MDX-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%A5%BC-%EC%8A%A4%ED%83%80%EC%9D%BC%EB%A7%81%ED%95%98%EA%B8%B0-%ED%8E%B8%ED%95%98%EA%B2%8C\">Next.js에서 MDX 컴포넌트를 스타일링하기 (편?하게)</a></p>\n<p><a href=\"https://nextjs.org/docs/app/building-your-application/configuring/mdx\">Next.js docs - Markdown and MDX</a></p>\n<p><a href=\"https://medium.com/wantedjobs/yarn-classic%EC%97%90%EC%84%9C-pnpm%EC%9C%BC%EB%A1%9C-%EC%A0%84%ED%99%98%ED%95%98%EA%B8%B0-with-turborepo-7c0c37cb3f9e\">Yarn Classic에서 Pnpm으로 전환하기 with TurboRepo</a></p>",
    "excerpt": "nextjs 14가 나왔고, 블로그에 쓰였던 라이브러리들도 업데이트가 많이 되었다. 또한 지금 다 파악할 수 없는 여러 가지 이유로 블로그 속도도 많이 느려졌다. 그래서 블로그를 리팩토링 해보기로 했다. 리팩토링을 하고 나서 최적화를 진행할 것이다.\nto pnpm\n기존에 yarn classic을 사용하고 있었는데 pnpm으로 전환하였다. 다음 글을 참고했다.\nYarn Classic에서 Pnpm으로 전환하기 with TurboRepo\n1. contentlayer의",
    "headingTree": [
      {
        "title": "to pnpm",
        "url": "#to-pnpm",
        "items": []
      },
      {
        "title": "1. contentlayer의 대안들",
        "url": "#1-contentlayer의-대안들",
        "items": [
          {
            "title": "1.1. @next/mdx",
            "url": "#11-nextmdx",
            "items": []
          },
          {
            "title": "1.2. marked",
            "url": "#12-marked",
            "items": []
          },
          {
            "title": "1.3. velite",
            "url": "#13-velite",
            "items": []
          }
        ]
      },
      {
        "title": "2. 설치와 기본 설정",
        "url": "#2-설치와-기본-설정",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 234
    },
    "url": "/posts/blog-refactor-2024-1",
    "thumbnail": {
      "local": "/thumbnails/blog-refactor-2024-1-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-blog-refactor-2024-1-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAk0lEQVR4nGNITEy0srKaMmWKnp6+srJyVlbWtm3bfvz4wVBbW2toaOjt7W1iYqKmpi4mJmZubv7q1SuGKVOmyMnJ8fDwtLS0XLx48dSpU1evXgXpOHz4UFVV1aZNm+7fv//5y5f/MMAwd9788PDwrq6u2bNnT5w48QtMjmHJ8tWLlyxdvXr11atX//////v3b4gEALbNWcNZ3oE5AAAAAElFTkSuQmCC"
    }
  }
]