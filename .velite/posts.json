[
  {
    "slug": "binary-search",
    "title": "이분 탐색 알고리즘의 활용",
    "date": "2023-09-25T01:00:00Z",
    "description": "이분 탐색의 활용에 대해 알아봅니다.",
    "tags": [
      "algorithm"
    ],
    "html": "<p><a href=\"https://solved.ac/profile/city\">city</a>입니다. 알고리즘을 그럭저럭 오래 해왔는데, 이분 탐색의 원리를 어떻게 이해하는지에 그리고 활용 문제를 접근하는 방식에 대해서 누군가가 물어봐서 써본 글입니다.</p>\n<p>기초적인 부분에 대해서는 생략된 부분도 많습니다. 때문에 <a href=\"https://blog.naver.com/kks227/220777333252\">kks227님의 블로그 글</a>과 같은 좋은 참고자료들이 많으니 같이 보면 좋을 것 같습니다.</p>\n<p>글에 사용한 그림들은 <a href=\"https://excalidraw.com/\">excalidraw</a>를 사용하여 직접 그렸습니다.</p>\n<h1>1. 이분 탐색의 기초</h1>\n<p>이분 탐색은 기본적으로 정렬된 원소들 사이에서 특정 원소를 찾는 알고리즘입니다.</p>\n<h2>1.1. 코드</h2>\n<p>정렬된 <code>arr</code>배열에서 <code>target</code>값을 찾는 코드라면 대략 다음과 같은 코드로 짤 수 있습니다. C++ 기준입니다. 물론 다른 언어라도 논리는 똑같습니다.</p>\n<pre><code class=\"language-cpp\">while(low&#x3C;=high) {\n  int mid = (low+high)/2;\n  if(arr[mid]==target) {\n    return mid;\n  } else if(arr[mid]>target) {\n    high = mid-1;\n  } else {\n    low = mid+1;\n  }\n}\n</code></pre>\n<h2>1.2. 원리</h2>\n<p>이것의 핵심 아이디어는 우리가 찾는 값이 존재할 수 있는 탐색 구간을 반씩 줄여 나간다는 것입니다.</p>\n<p>처음 탐색을 시작할 때를 생각해 봅시다. <code>arr</code>의 크기가 n이라면 우리가 찾는 값이 있을 수 있는 구간은 <code>arr[0]</code>부터 <code>arr[n-1]</code>까지입니다. 그리고 위의 알고리즘대로라면 <code>arr[(n-1)/2]</code>와 <code>target</code>을 비교하게 될 것입니다.</p>\n<p>그런데 배열이 정렬되어 있다는 것을 생각해 볼 때, 배열의 모든 값은 <code>arr[mid]</code>와의 비교를 통해 다음과 같은 두 구간으로 나눌 수 있습니다.</p>\n<p>(그럼 <code>mid</code>인덱스는 어느 쪽 구간에 속하는지 의문이 들 수 있습니다. 일단 넘어가도 되는 부분이긴 한데 위와 같은 닫힌 구간 구현에서는 둘 중 어디에도 속하지 않고, 이후에 볼 반열림 구간 <code>[s,e)</code>로 구현할 시에는 오른쪽 부분에 속하게 됩니다.)</p>\n<p><img src=\"/static/search-start-78fd3a72.png\" alt=\"search-start\"></p>\n<p>그럼 우리는 찾는 값 <code>target</code>이 <code>arr[mid]</code>보다 작은지 큰지만 비교하면 <code>target</code>이 존재할 수 있는 구간을 반으로 줄일 수 있습니다. <code>target</code>이 <code>arr[mid]</code>보다 작다면 <code>mid</code>인덱스보다 작은 인덱스에 존재할 것이고 크다면 <code>mid</code>인덱스보다 큰 인덱스에 존재할 것이기 때문입니다.</p>\n<p>만약 <code>target==arr[mid]</code>라면 우리는 <code>target</code>을 찾은 것이므로 바로 <code>mid</code>를 리턴하면 되고요.</p>\n<p>정렬된 배열에서는 이런 식으로 <code>target</code>이 존재할 수 있는 구간을 반씩 줄여 나가면서 탐색할 수 있습니다. 그래서 시간복잡도 <code>O(logN)</code>만에 배열에서 값을 찾을 수 있다는 게 이분 탐색의 핵심 아이디어입니다.</p>\n<p>즉 늘 다음과 같은 상황에서 탐색을 진행하게 됩니다.</p>\n<p><img src=\"/static/searching-0cc10faa.png\" alt=\"이분탐색 과정의 묘사\"></p>\n<p>그럼 탐색 구간을 구체적으로 어떻게 좁히느냐? 위의 이분탐색 코드는 설명한 두 가지 경우에 따라 low를 조절하거나 high를 조절해서 탐색 구간을 좁혀 나갑니다.</p>\n<p>만약 <code>target</code>이 <code>arr[mid]</code>보다 작다면 <code>target</code>을 찾기 위해 <code>arr[mid]</code>의 왼쪽 구간을 탐색해야 하므로 탐색 구간의 상한인 <code>high</code>를 줄이고, <code>target</code>이 <code>arr[mid]</code>보다 크다면 <code>arr[mid]</code>의 오른쪽 구간을 탐색해야 하므로 탐색 구간의 하한인 <code>low</code>를 늘려줍니다.</p>\n<p>이를 반복하다 보면 언젠가는 <code>target</code>을 찾게 되거나 탐색 구간이 더 이상 없어서 <code>target</code>을 찾지 못하게 됩니다.</p>\n<h1>2. 원리의 확장</h1>\n<h2>2.1. 파라메트릭 서치의 아이디어</h2>\n<p>하지만 이렇게 배열에서 단순히 하나의 원소를 빠르게 찾아야 하는 경우는 너무 한정적입니다. 실생활이나 문제풀이에서도 이렇게 단순한 경우는 거의 없습니다.</p>\n<p>이 아이디어를 좀더 확장해서 활용하기 위해 주목할 것은 우리가 배열이 정렬되어 있다는 것을 활용해서 <code>mid</code>인덱스를 기준으로 한쪽에는 <code>target</code>이 있고, 한쪽에는 <code>target</code>이 없다'라는 것을 알 수 있었고 그로 인해 탐색 공간을 반씩 줄여 나갈 수 있었다는 것입니다.</p>\n<p>이 말을 반대로 말하면 탐색 구간을 어떤 기준으로 반씩 줄여 가며 무언가를 찾을 수 있는 작업이라면 이분 탐색을 생각해 볼 수 있다는 이야기입니다. 여기서 파라메트릭 서치의 아이디어가 나옵니다.</p>\n<p>가령 <code>arr</code>배열의 0번부터 n-1번 인덱스 중 <code>target</code>을 찾는 것이 아니라 <code>target</code>보다 큰 첫번째 원소의 인덱스를 찾는 문제라고 해봅시다. 이는 원소에 대한 탐색 자체보다 좀 더 넓은 범위를 커버하는 문제입니다.</p>\n<p>우리는 그럼 <code>arr</code>이 두 부분으로 나누어져 있다고 생각할 수 있습니다.</p>\n<p><img src=\"/static/possible-line-6c6c50c3.png\" alt=\"possible-line\"></p>\n<p>그럼 우리는 <code>arr</code>의 어떤 특정 값이 <code>target</code>보다 작은지 큰지만 판정하면 우린 해당 값이 우리가 찾는 '<code>target</code>보다 큰 첫번째 원소의 인덱스'보다 왼쪽에 있는지 오른쪽에 있는지를 알 수 있습니다.</p>\n<p>이를 이용하면 우리는 경계를 찾아야 하는 탐색 구간을 반씩 줄여 나갈 수 있고 따라서 이분탐색의 아이디어로 문제를 풀 수 있습니다.</p>\n<pre><code>이렇게 문제를 푸는 방식을 파라메트릭 서치, 즉 매개 변수 탐색이라고도 합니다. 최적화 문제를 결정 문제로 바꿔 푸는 거라고 멋지게 말할 수도 있지만 그 말이 원리만큼 중요하다고 생각하지는 않습니다.\n</code></pre>\n<h2>2.2. 파라메트릭 서치</h2>\n<p>이를 좀더 일반화해 보겠습니다. 우리는 구간 <code>[low, high]</code>에 대해서 생각합니다. 그리고 어떤 결정 문제가 있어서 어떤 특정 자연수 <code>x</code>($low \\le x \\le high$)에 대해서 <code>x</code>보다 작거나 같은 자연수들에서는 true이고, <code>x</code>보다 큰 자연수들에서는 false라고 해봅시다. 우리는 이 <code>x</code>를 구하고자 합니다.</p>\n<p><img src=\"/static/first-situation-71fdfe47.png\" alt=\"현재 상황\"></p>\n<p>그럼 우리는 우리는 <code>mid=(low+high)/2</code>에 대해 <code>check</code>이 true인지를 기반으로 우리가 구해야 할 값이 <code>mid</code>보다 작은지 큰지를 판단할 수 있습니다.</p>\n<p>만약 <code>mid</code>에서 <code>check</code>가 false라고 해봅시다. 그러면 다음과 같은 상황일 것입니다.</p>\n<p><img src=\"/static/impossible-in-mid-3da16803.png\" alt=\"mid에서 불가능\"></p>\n<p>그럼 그림만 보아도, 우리는 <code>x</code>가 <code>mid</code>보다 작은 쪽에 있다는 것을 알 수 있습니다. 만약 반대로 <code>mid</code>에서 <code>check</code>가 true라면 <code>x</code>는 <code>mid</code>보다 큰 쪽에 있을 것입니다. 이를 이용해 탐색 구간을 업데이트해 나갑니다. 다음 섹션에서 더 자세히 보겠습니다.</p>\n<h2>2.3. 코드와 함께 자세히 보기</h2>\n<p>코드와 함께 보면 다음과 같습니다. 나올 수 있는 자연수의 하한을 low, 상한을 high라고 하면, 경계선을 찾는 코드는 대강 이럴 것입니다. <code>check(i)==true</code>인 구간의 상한 <code>x</code>를 찾습니다.</p>\n<pre><code class=\"language-cpp\">while(low&#x3C;=high){\n  int mid = (low+high)/2;\n  // A가 mid에서 가능하다\n  if(check(mid)){\n    low = mid+1;\n  }else{\n    high = mid-1;\n  }\n}\nreturn high;\n</code></pre>\n<p>A가 <code>mid</code>에서 가능하다면 즉 <code>check(mid)</code>가 true라면 <code>x</code>는 <code>mid</code>의 오른쪽에 있을 것입니다. 다음과 같은 상황인 거죠.</p>\n<p><img src=\"/static/update-low-68303423.png\" alt=\"update-low\"></p>\n<p>따라서 오른쪽 구간의 탐색을 위해 low를 mid+1로 업데이트해주는 것입니다. 그러고 나면 다음 탐색 구간은 반으로 줄게 됩니다.</p>\n<p>반대로 <code>check</code>가 <code>mid</code>에서 false라면 <code>x</code>는 <code>mid</code>의 왼쪽에 있을 수밖에 없습니다. 다음과 같은 상황에서만 <code>mid</code>에서 <code>check</code>가 false일 수 있기 때문입니다.</p>\n<p><img src=\"/static/update-high-791ac494.png\" alt=\"update-high\"></p>\n<p>따라서 왼쪽 구간의 탐색을 위해 high를 mid-1로 업데이트해주는 것입니다.</p>\n<p>이를 반복하다 보면 x를 찾을 수 있습니다!</p>\n<h1>3. 더 깊이 이해하기</h1>\n<p>이분탐색에 대한 자료는 워낙 많기 때문에 이 정도 이해는 사실 꽤 많은 분들이 하고 계십니다. 하지만 가장 헷갈리는 부분은 이런 거라고 생각합니다. 이로 인해 답에 1차이가 나는 등의 문제를 <code>off by one</code>이라고도 하는 것 같습니다.</p>\n<pre><code>while(low&#x3C;=high) vs while(low&#x3C;high)\nlow 출력 vs high 출력\n(lower와 upper, l과 r, s와 e등의 다른 변수명을 쓰는 분들도 있지만 가리키는 건 어차피 똑같으니 low, high로 하겠습니다)\n</code></pre>\n<p>많은 분들이 그렇듯이 저도 알고리즘을 처음 시작한 지 몇 달 안 되어 이분 탐색을 배웠지만 이런 것들을 잘 이해하기까지는 1년도 넘게 걸린 것 같습니다.</p>\n<p>따라서 먼저 제가 사용하는 방식에서 저런 부분들을 어떻게 다루는지 설명하도록 하겠습니다. 그리고 다음 글에서는 다른 방식도 소개해 보도록 하겠습니다.</p>\n<h2>3.1. 구현 이해하기</h2>\n<p>문제 조건에 따라 조금씩 달라지지만 어떤 문제 <code>check</code>가 true인 구간의 최댓값 혹은 최솟값을 찾는 파라메트릭 서치에 제가 흔히 쓰는 코드는 다음과 같습니다. 위에 쓴 것과 같습니다.</p>\n<pre><code class=\"language-cpp\">while(low&#x3C;=high){\n  int mid=(low+high)/2;\n  if(check(mid)){\n    low=mid+1;\n  }\n  else{\n    high=mid-1;\n  }\n}\n</code></pre>\n<p>그럼 이 <code>while</code>문은 어느 시점에 종료될까요? <code>while</code>은 <code>low &#x3C;= high</code>일 때 body를 실행하니까 <code>while</code>이 종료되었다는 것은 <code>low > high</code>가 되었다는 뜻일 겁니다.</p>\n<p>그리고 탐색 구간의 길이는 계속 작아져서 결국 1이 되었을 테니 <code>low > high</code>일 때 둘의 차이는 1이 될 것입니다.</p>\n<p>다음 그림의 상황은 <code>low == high+1</code>이 되어 <code>while</code>이 종료된 상황입니다.</p>\n<p><img src=\"/static/end-of-search-072124e5.png\" alt=\"end-of-search\"></p>\n<p>즉 탐색이 종료된 시점에서 <code>high</code>는 <code>check(i)==true</code>인 구간의 상한을, <code>low</code>는 <code>check(i)==true</code>인 구간의 하한을 나타내게 됩니다.</p>\n<h2>3.2. 문제로 생각해보기</h2>\n<p>유명한 파라메트릭 서치 문제인 <a href=\"https://www.acmicpc.net/problem/1654\">1654번 랜선 자르기</a>를 봅시다.</p>\n<p>특정 경계 수보다 작거나 같으면 문제의 조건을 만족시킬 수 있고 크면 문제 조건을 만족시킬 수 없습니다. K개의 랜선들을 같은 길이로 잘라서 N개의 랜선을 만들어야 하고 그럴 수 있는 최대 랜선 길이를 구해야 한다는 문제 조건을 생각해 보면 당연합니다.</p>\n<p>만약 K개의 랜선을 각각 X 길이로 잘라서 N개의 랜선을 만드는 것이 <code>가능</code>하다면 X보다 작은 길이로도 그것이 가능하고, K개의 랜선을 Y 길이로 잘라서 N개의 랜선을 만드는 것이 <code>불가능</code>하다면 Y보다 큰 길이로도 그것이 불가능하기 때문입니다.</p>\n<p>만약 어떤 길이 L이 있어서 우리가 길이 L의 랜선을 N개 만들어서 문제 조건을 만족시킬 수 있다고 합시다. 그러면 L보다 작은 길이의 랜선을 N개 만드는 건 굳이 수학적 증명이 없이도 가능하다는 걸 쉽게 깨달을 수 있습니다. N개보다 많이 만드는 것도 N개를 만드는 것에 포함된다는 문제 조건이 있기 때문에~</p>\n<p>그러므로 이 문제는 경계선을 나타내는 자연수보다 작거나 같으면 가능, 크면 불가능인 상황이고 그 '가능한 구간'의 최댓값을 찾는 문제입니다.</p>\n<p>즉 이 문제와 같은 경우 가능한 구간의 상한인 <code>high</code>를 출력하면 되는 문제입니다(심지어 문제 설명에도 '최댓값을 구하라'고 친절하게 말해 줍니다).</p>\n<p><img src=\"/static/end-of-search-072124e5.png\" alt=\"end-of-search\"></p>\n<p>즉 입력을 제외한 랜선 자르기 문제에서 이분 탐색 부분만 따로 떼어서 적어보면 다음과 같습니다. <code>high</code>를 출력하면 됩니다.</p>\n<pre><code class=\"language-cpp\">while(low&#x3C;=high){\n    ll mid=(low+high)/2;\n    if(check(mid)){\n        low=mid+1;\n    }\n    else{\n        high=mid-1;\n    }\n}\ncout&#x3C;&#x3C;high&#x3C;&#x3C;\"\\n\";\n</code></pre>\n<p>반면 <a href=\"https://www.acmicpc.net/problem/1072\">1072번 게임</a>과 같은 문제에서는 <code>게임을 최소 몇 번 더 해야 Z가 변하는지</code> 즉 가능한 구간의 최솟값을 찾는 문제이므로 <code>low</code>를 출력해야 합니다.</p>\n<h2>3.3. 여담</h2>\n<p>이렇게 구간을 줄여나가는 아이디어를 통해서 할 수 있는 게 정말 많습니다. 구간합의 홀짝성이 달라지는 것을 이용해서 이분탐색을 한다든지, 아예 구간을 3개로 나눠서 극점을 찾는 삼분 탐색을 한다든지 아니면 자연수 대신 실수도 어쨌든 정렬되어 있다고 생각할 수 있으므로 이를 이분탐색한다든지 등등...</p>\n<p>또한 가능 여부를 따지는 부분도 중요하지만 위에서는 그냥 check함수로 퉁쳤습니다. 이것도 사실 문제를 풀 때 엄청 어려운 포인트가 될 수도 있습니다. <a href=\"https://www.acmicpc.net/problem/1637\">1637번 날카로운 눈</a>같은 문제를 보면서 이분탐색을 바로 떠올리기는 쉽지 않고 판정 방식을 떠올리기도 쉽지 않습니다. 이런 부분들도 나중에 기회가 되면 쓰도록 하겠습니다.</p>\n<h2>3.4. 다른 구현 한 가지</h2>\n<p>다른 구현들에 대해서는 본격적으로 다음 글에서 다룰 것입니다. 하지만 간단한 바리에이션 하나를 여기서 소개합니다.</p>\n<p>구간을 따지는 방식을 바꾸는 것은 아니고, 정답이 될 수 있는 값을 계속 업데이트하는 것입니다. 다음과 같이 말입니다.</p>\n<pre><code class=\"language-cpp\">ll ans=min_value;\nwhile(low&#x3C;=high){\n    ll mid=(low+high)/2;\n    if(check(mid)){\n        low=mid+1;\n        ans=max(ans, mid);\n    }\n    else{\n        high=mid-1;\n    }\n}\ncout&#x3C;&#x3C;ans&#x3C;&#x3C;\"\\n\";\n</code></pre>\n<p>이렇게 하면 무조건 가능 구간의 상한이 <code>ans</code>에 들어갑니다. 이분탐색 하는 동안 가능 구간의 상한 값이 <code>ans</code>에 한 번은 들어갈 수밖에 없고 이는 들어가는 값 중 최댓값이기 때문입니다.</p>\n<p>구간의 가능성이 반대라면 적당히 <code>ans=min(ans, mid)</code>으로 바꾸고 위치도 변경하면 됩니다. 원리를 생각하면 쉽게 할 수 있습니다. 이렇게 이분탐색을 다루는 분들도 몇 분 보았고 구간이 줄어드는 원리 이해에 도움이 된다고 생각해서 이 글에 소개합니다.</p>\n<h1>4. 정리</h1>\n<p>이분 탐색을 활용해서 문제를 풀 때의 핵심은 '한쪽 구간은 뭔가가 되고, 한쪽 구간은 안 된다. 따라서 어떤 한 값의 가능 여부를 알면 그 값을 기준으로 어떤 구간을 탐색할지 결정할 수 있다.'라는 것입니다.</p>\n<p>그렇게 탐색 구간을 줄여가다 보면 결국 경계선을 찾을 수 있는데요. 이때 경계선을 찾는 while문이 언제 종료되는지를 따져 보면 우리는 high와 low중 어떤 값이 필요한지를 알 수 있습니다. 닫힌 구간으로 구현하건 반열린 구간으로 구현하건 마찬가지입니다.</p>\n<p>우리가 어떤 가능성을 따지고 있는지, 그리고 while문이 어떤 조건일 때 종료될지를 생각하며 이분 탐색에 접근합시다.</p>\n<p>그리고 반대로, 어떤 값을 경계로 어떤 기준의 가능/불가능 여부가 바뀐다면(x보다 작거나 같은 값에 대해서는 문제 조건이 가능한데, x보다 크면 안 되고 이때의 x값을 찾아라~하는 식, 혹은 문제를 잘 생각해 보면 그런 문제로 환원시킬 수 있는 문제)이분 탐색을 한번 생각해 봅시다.</p>\n<p><img src=\"/static/final-description-04d2fb9f.png\" alt=\"final\"></p>\n<h1>참고</h1>\n<p><a href=\"https://codeforces.com/blog/entry/96699\">https://codeforces.com/blog/entry/96699</a></p>",
    "excerpt": "city입니다. 알고리즘을 그럭저럭 오래 해왔는데, 이분 탐색의 원리를 어떻게 이해하는지에 그리고 활용 문제를 접근하는 방식에 대해서 누군가가 물어봐서 써본 글입니다.\n기초적인 부분에 대해서는 생략된 부분도 많습니다. 때문에 kks227님의 블로그 글과 같은 좋은 참고자료들이 많으니 같이 보면 좋을 것 같습니다.\n글에 사용한 그림들은 excalidraw를 사용하여 직접 그렸습니다.\n1. 이분 탐색의 기초\n이분 탐색은 기본적으로 정렬된 원소들 사이에서 특정 원소를",
    "headingTree": [
      {
        "title": "1. 이분 탐색의 기초",
        "url": "#1-이분-탐색의-기초",
        "items": [
          {
            "title": "1.1. 코드",
            "url": "#11-코드",
            "items": []
          },
          {
            "title": "1.2. 원리",
            "url": "#12-원리",
            "items": []
          }
        ]
      },
      {
        "title": "2. 원리의 확장",
        "url": "#2-원리의-확장",
        "items": [
          {
            "title": "2.1. 파라메트릭 서치의 아이디어",
            "url": "#21-파라메트릭-서치의-아이디어",
            "items": []
          },
          {
            "title": "2.2. 파라메트릭 서치",
            "url": "#22-파라메트릭-서치",
            "items": []
          },
          {
            "title": "2.3. 코드와 함께 자세히 보기",
            "url": "#23-코드와-함께-자세히-보기",
            "items": []
          }
        ]
      },
      {
        "title": "3. 더 깊이 이해하기",
        "url": "#3-더-깊이-이해하기",
        "items": [
          {
            "title": "3.1. 구현 이해하기",
            "url": "#31-구현-이해하기",
            "items": []
          },
          {
            "title": "3.2. 문제로 생각해보기",
            "url": "#32-문제로-생각해보기",
            "items": []
          },
          {
            "title": "3.3. 여담",
            "url": "#33-여담",
            "items": []
          },
          {
            "title": "3.4. 다른 구현 한 가지",
            "url": "#34-다른-구현-한-가지",
            "items": []
          }
        ]
      },
      {
        "title": "4. 정리",
        "url": "#4-정리",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 304
    },
    "url": "/posts/binary-search",
    "thumbnail": {
      "local": "/static/search-start-78fd3a72.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-search-start-78fd3a72-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAIAAAA8r+mnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAaElEQVR4nGP4DwZ37txJTU1ds2bNq1evICIMx48fX7p0aV1dbQUY5Bfkr1mz5t7duwzz589nYGCsqKh4+fLFyRMn1NTUbWxsL125wvDx46cfP35u232wfeKs6fOXvv/w8dmLl/cfPQUANEJClcr+/7EAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "binary-search-next-step",
    "title": "이분 탐색 알고리즘 심화",
    "date": "2023-10-08T04:00:00Z",
    "description": "이분 탐색에 대하여 더 깊이 알아봅니다.",
    "tags": [
      "algorithm"
    ],
    "html": "<h1>이분 탐색의 중요성?</h1>\n<blockquote>\n<p>뻘글을 쓰고 싶은 기분이다. 이 글을 너무 진지하게 받지는 말기를 바란다.</p>\n<p>내가 들어 보았지만 알지 못하는 알고리즘들(내가 들어보지도 못한 것들은 또 얼마나 많을지)</p>\n<ul>\n<li>리-차오 세그먼트 트리</li>\n<li>세그먼트 트리 비츠</li>\n<li><code>O(n)/O(1)</code> range max query</li>\n<li>treap을 제외한 자가 균형 트리</li>\n<li>링크 컷 트리</li>\n<li>웨이블릿 트리</li>\n<li>머지 소트 트리</li>\n<li>바이노미얼 힙</li>\n<li>피보나치 힙</li>\n<li>(그 외에 웬만한 건 비교도 안 될 수많은 고인물 알고리즘들 이하생략)</li>\n</ul>\n<p>만약 당신이 이 중 적어도 3개 이상을 알고 있는데 codeforces 레이팅이 red가 아니라면 당신은 뭔가 잘못하고 있는 것이다. 쓸모없는 알고리즘 배우기를 멈추고 가서 문제를 좀 풀고, 이분 탐색을 어떻게 하는지 배워라.</p>\n<p>출처 : 2021년의 <a href=\"https://codeforces.com/blog/entry/92248\">Um_nik이 쓴 글</a>(Um_nik은 2017년부터 안정적인 Legendary Grandmaster였다)</p>\n</blockquote>\n<h1>시작</h1>\n<p><a href=\"https://solved.ac/profile/city\">city</a>입니다. 알고리즘을 그럭저럭 오래 해왔는데, 이분 탐색의 원리를 어떻게 이해하는지에 그리고 활용 문제를 접근하는 방식에 대해서 누군가가 물어봐서 써본 <a href=\"https://witch.work/posts/binary-search\">이분 탐색 알고리즘의 활용</a>의 후속작입니다.</p>\n<p>이 글에서는 이분 탐색의 구현 방식과 파고들 수 있는 부분들에 대해서 좀 더 많이 알아보고 그것을 통해서 이분 탐색의 작동 방식을 더 잘 이해하는 것을 목표로 합니다.</p>\n<p>글에 사용한 그림들은 <a href=\"https://excalidraw.com/\">excalidraw</a>를 사용하여 직접 그렸습니다.</p>\n<h1>0. 배경</h1>\n<p>내가 이분탐색을 처음 제대로 이해할 수 있게 된 건 <code>while(low&#x3C;=high)</code>로 구현했을 때 <code>low</code>와 <code>high</code>가 어떤 값을 가리키는지를 이해하고 나서였다. 이 그림과 비슷한 그림을 <a href=\"https://blog.yuni.dev/\">Yun</a>님이 보여주셨을 때였다. 이분 탐색 짬을 좀 먹은 사람이라면 이 그림만 봐도 뭔가 감이 올 거라 생각한다.</p>\n<p><img src=\"/static/end-of-search-103edffa.png\" alt=\"탐색이 끝났을 때\"></p>\n<p>하지만 이후 <code>while(low&#x3C;high)</code>혹은 <code>while(low!=high)</code> 등 여러 다른 방식으로 이분 탐색을 구현하시는 분들도 많다는 걸 알게 되었다. 이외에도 몇 가지 다른 구현 방식들이 더 있으며 또한 이러한 접근 방식 자체를 다르게 응용할 수 있다는 것도 배웠다.</p>\n<p>나도 다른 많은 사람들이 그렇듯이 알고리즘을 시작한 지 몇 달 안되어 이분탐색을 배웠고 개념 자체는 어려울 게 없으니 금방 깨우쳤다고 생각했다. 하지만 이분 탐색을 잘 사용할 수 있게 되고 또 더 깊은 이해를 얻기까지는 시간이 꽤 걸렸고 이건 지금도 현재진행형이다. 아직 한참 부족한 사람이지만 그 흔적을 여기 적는다.</p>\n<h1>1. 문제 정의</h1>\n<p><a href=\"https://witch.work/posts/binary-search\">이분 탐색 알고리즘의 활용</a>에서 사용했던 문제 정의를 다시 사용하겠다. 이분 탐색의 기본을 다루는 글이 아니므로 적당히 적는다. <a href=\"https://www.acmicpc.net/problem/1654\">BOJ 1654번 랜선 자르기</a>와 같은 상황이다.</p>\n<p>우리는 구간 <code>[low, high]</code>에 대해서 생각한다. 그리고 <code>check(number)</code> 함수로 나타내어질 수 있는 문제가 있어서 어떤 특정 자연수 <code>x</code>($low \\le x \\le high$)에 대해서 <code>x</code>보다 작거나 같은 자연수 <code>k</code>에 대해서는 <code>check(k)</code>가 true이고, <code>x</code>보다 큰 자연수들에서는 false이다. 우리는 이때 <code>check</code>의 결과가 나누어지는 경계 <code>x</code>를 구하고자 한다.</p>\n<p>내가 이 문제를 해결할 때 보통 쓰는 코드는 다음과 같다. 이 경우 <code>check</code>의 결과가 true가 되는 최댓값을 구하는 코드이다. 설명은 다음 절에서 하겠다.</p>\n<pre><code class=\"language-cpp\">while (low &#x3C;= high) {\n  int mid = (low + high) / 2;\n  // mid에서 check 함수가 true면 더 큰 값에서 탐색\n  if (check(mid)) {\n    low = mid + 1;\n  } else {\n    high = mid - 1;\n  }\n}\nreturn high;\n</code></pre>\n<h1>2. 여러가지 구현 - 구간의 차이</h1>\n<p>이분 탐색은 결국 정해진 구간 내에서 어떤 조건의 값을 찾을 때 구간을 반씩 줄여 나가면서 찾는 것이 핵심이다. 이때 탐색 구간을 어떤 식으로 경계짓느냐에 따라서 구현에 차이가 난다. 이는 언제 탐색을 종료할지, 그리고 다음 탐색구간을 정할 때 어떤 값을 사용할지에 영향을 미친다.</p>\n<p>현재 널리 쓰이고 있는 구간 정의 방식은 탐색구간의 하한이 <code>low</code>이고 상한이 <code>high</code>라고 할 때 닫힌 구간 <code>[low, high]</code>, 반열린 구간 <code>[low, high)</code>, 열린 구간 <code>(low, high)</code>정도로 알고 있는데 이들을 설명하도록 하겠다. 이들은 모두 다른 탐색 종료 조건과 다른 <code>low</code>, <code>high</code>업데이트를 요구한다.</p>\n<h2>2.1. 닫힌 구간 탐색</h2>\n<p>앞에서 본 코드의 구현이다. 내가 일반적으로 쓰는 방식이다.</p>\n<pre><code class=\"language-cpp\">while (low &#x3C;= high) {\n  int mid = (low + high) / 2;\n  // mid에서 check 함수가 true면 더 큰 값에서 탐색\n  if (check(mid)) {\n    low = mid + 1;\n  } else {\n    high = mid - 1;\n  }\n}\nreturn high;\n</code></pre>\n<p>이 코드는 어떤 구간을 탐색하고, 어떤 구간으로 향할까?</p>\n<p>이 코드의 목표와 작동 방식은 다음과 같다.</p>\n<p>처음 탐색을 시작한 자연수 범위가 <code>[start_low, start_high]</code>라고 하자. 그러면 탐색 종료시 <code>[start_low, high]</code>가 <code>check</code>가 true인 구간이 되고 <code>[low, start_high]</code>는 <code>check</code>가 false인 구간이 되도록 하는 것이 목표이다. 여기서 <code>low==high+1</code>이다.</p>\n<p><code>check(mid)</code>가 true라면 <code>low</code>가 <code>check</code>결과가 <code>false</code>인 닫힌 구간의 하한이 되기 위해서는 적어도 <code>mid</code>보다는 커야 한다는 것이고 따라서 <code>mid+1</code>로 업데이트해준다. <code>check(mid)</code>가 false인 경우도 마찬가지다.</p>\n<p>모든 탐색 구간이 닫힌 구간이라고 생각하면 구간의 업데이트를 이해할 수 있다.</p>\n<h2>2.2. 반열린 구간 탐색</h2>\n<p>다른 구현방식은 다음과 같다. 이는 탐색 구간을 반열린 구간 <code>[low, high)</code>로 따진다.</p>\n<pre><code class=\"language-cpp\">while (low &#x3C; high) {\n  int mid = (low + high) / 2;\n  // A가 mid에서 가능하다\n  if (check(mid)) {\n    low = mid + 1;\n  } else {\n    high = mid;\n  }\n}\n</code></pre>\n<p>이 코드는 어떤 구간을 탐색하고, 어떤 구간으로 향할까?</p>\n<p>이 코드가 목표와 작동 방식은 다음과 같다.</p>\n<p>처음 탐색을 시작한 자연수 범위가 <code>[start_low, start_high)</code>라고 하자. 그러면 탐색 종료시 <code>[start_low, high)</code>가 <code>check</code>가 true인 구간이 되고 <code>[low, start_high)</code>는 <code>check</code>가 false인 구간이 되도록 하는 것이 목표이다. 여기서 <code>low==high</code>이다.</p>\n<p>이 상태를 달성하기 위해서 <code>[low, high)</code>에 우리가 찾는 경계값이 있다고 했을 때 <code>mid</code>에서 <code>check</code>이 true이면 <code>[mid+1, high)</code>로, 불가능하면 <code>[low, mid)</code>로 탐색 구간을 줄여나간다.</p>\n<p>위와 달리 반열린 구간으로 따지기에 <code>low</code>는 <code>mid+1</code>로, <code>high</code>는 <code>mid</code>로 업데이트해준다.</p>\n<p>이 값을 생각하는 논리는 위에서와 같다. 위에서와 다른 <code>high</code>업데이트를 봐보자. <code>check(mid)</code>가 false일 경우 <code>high</code>는 <code>check</code>가 true인 구간의 상한이 되기 위해 적어도 <code>mid</code>를 구간에 포함하지 않아야 한다. 따라서 <code>[start_low, mid)</code>로 업데이트해주기 위해 <code>high=mid</code>로 만들어 주는 것이다.</p>\n<p>구간의 목표를 달성하기 위해 어떤 행동을 취해야 하는지가 핵심이다.</p>\n<p>아무튼 탐색 종료 시 <code>low</code>, <code>high</code>가 모두 <code>check</code>의 참/거짓을 가르는 경계에 위치하게 된다. <code>high</code>는 <code>check</code>가 true인 반열린 구간의 상한을, <code>low</code>는 <code>check</code>가 false인 반열린 구간의 하한을 가리킨다.</p>\n<p>즉 닫힌 구간으로 탐색할 시에는 <code>low</code>혹은 <code>high</code> 둘 중 하나가 정답이 되었다면, 이렇게 반열린 구간으로 탐색할 시 탐색 종료 시점에서 <code>low==high</code>이므로 문제 조건에 따라 <code>low</code> 혹은 <code>low-1</code>(물론 <code>high</code>나 <code>high-1</code>도 상관없다)를 출력해 줘야 한다. 이렇게 <code>low</code>인지 <code>high</code>인지를 신경쓰지 않아도 된다는 사실이 이 구현 방식의 장점이라고 생각한다.</p>\n<p>이런 반열린 구간 방식을 <code>while(low!=high)</code>와 같이 구현하는 분들도 있는데, 너무 작은 바리에이션이라서 설명할 필요는 없다고 본다.</p>\n<h2>2.3. 열린 구간 탐색</h2>\n<p>이 역시 내가 쓰는 방식은 아니지만 다음과 같이 할 수도 있다. <a href=\"https://www.acmicpc.net/user/jinhan814\">jinhan814님</a>이 쓰시는 구현으로 알고 있다. 이것도 상당히 유명한 편인 구현인데 기억하지 못하고 있다가 어떤 분이 피드백을 주셔서 추가하였다.</p>\n<p>이 역시 지금까지 계속 보았던, 어떤 경계값 이하 구간에서는 <code>check</code>이 true이고 초과에서는 false일 때 <code>check</code>이 true인 상한을 구해야 하는 문제라고 할 때 그 답은 <code>low</code>혹은 <code>high-1</code>(두 값은 같다)로 나타난다.</p>\n<pre><code class=\"language-cpp\">// 열린 구간으로 원래 탐색구간을 전부 포괄하기 위한 처리\nlow--;\nhigh++;\nwhile (low + 1 &#x3C; high) {\n  int mid = (low + high) / 2;\n  if (check(mid)) {\n    low = mid;\n  } else {\n    high = mid;\n  }\n}\n</code></pre>\n<p>이 구현의 목표도 위에서와 구간의 경계 표시만 바뀌었을 뿐 같다. 처음 탐색을 시작한 자연수 범위가 <code>(start_low, start_high)</code>라고 할 때 탐색 종료시 <code>(start_low, high)</code>가 <code>check</code>가 true인 구간이 되고 <code>(low, start_high)</code>는 <code>check</code>가 false인 구간이 되도록 하는 것이 목표이다. 여기서 <code>low+1==high</code>이다.</p>\n<p>그러면 만약 <code>check(mid)</code>가 true라고 했을 때, <code>(low, start_high)</code>가 <code>check</code>이 false인 구간이 되기 위해서는 최소한 <code>low</code>가 <code>mid</code>이상이어야 한다. 그러니 <code>low=mid</code>로 업데이트한다.</p>\n<p>반대로 <code>check(mid)</code>가 false라면 <code>high</code>는 <code>check</code>가 true인 열린 구간의 상한이 되어야 하는데 그러려면 적어도 <code>mid</code>이하여야 한다. 그러니 <code>high=mid</code>로 업데이트한다.</p>\n<p>그리고 이렇게 탐색이 끝나고 나면 우리는 <code>check</code>이 true인 구간의 상한을 구하고자 했으므로 <code>high-1</code>을 구하면 된다. 그런데 탐색의 종료 조건을 보았을 때 <code>low==high-1</code>이므로 <code>low</code>를 출력해도 된다.</p>\n<p>이 구현의 장점은 좀더 직관적으로 <code>low</code>와 <code>high</code>중 출력할 값을 정할 수 있다는 부분이다. 물론 우리는</p>\n<p>이 구현의 장점은 <code>low</code>보다 <code>high</code>가 늘 크다는 조건이 만족되고 따라서 좀더 직관적으로 <code>low</code>와 <code>high</code>중 출력할 값을 정할 수 있다는 부분이다.</p>\n<p>우리는 <code>(start_low, high)</code>와 <code>(low, start_high)</code>로 <code>check</code>이 true, false인 구간을 정의하기는 했지만 구간이 자연수로 이루어졌다는 점을 생각할 때 이는 <code>check</code>이 true인 구간이 <code>(start_low, low]</code>이고 false인 구간은 <code>[high, start_high)</code>라고 할 수도 있다.</p>\n<p>즉 <code>check</code>이 true인, 상대적으로 작은 수로 이뤄진 구간의 상한은 <code>low</code>, <code>check</code>이 false인, 상대적으로 큰 수로 이뤄진 구간의 하한은 <code>high</code>가 된다. 그러니 생각하기에 따라 좀더 직관적으로 우리가 구해야 할 값이 무엇인지를 알 수 있다.</p>\n<h3>2.3.1. 주의할 부분</h3>\n<p>이 구현을 개인적으로 쓰지는 않기 때문에 체감해 보지는 못했지만, <code>low</code>와 <code>high</code>가 항상 정답 범위를 나타낼 수 있도록 하는 것에 주의해야 한다고 한다. 열린 구간으로 구현하기에 처음 탐색 범위도 <code>(low, high)</code>인데 따라서 진짜 탐색하게 되는 범위는 <code>[low + 1, high - 1]</code>이기 때문이다.</p>\n<p>이런 부분을 커버하기 위해 위의 구현에서 <code>low--</code>와 <code>high++</code>를 해주는 것이다.</p>\n<pre><code class=\"language-cpp\">// 구현 다시보기\n// 열린 구간으로 원래 탐색구간을 전부 포괄하기 위한 처리\nlow--;\nhigh++;\nwhile (low + 1 &#x3C; high) {\n  int mid = (low + high) / 2;\n  if (check(mid)) {\n    low = mid;\n  } else {\n    high = mid;\n  }\n}\n</code></pre>\n<h2>2.4. 우열?</h2>\n<p>어떤 방식을 쓰는 게 더 좋을까? 딱히 정해진 건 없다. 일반적으로 각자가 처음 이해한 방식대로 쭉 간다. 통계적으로 따졌을 때 어느 방식이 좀 더 많이 쓰이고 있을 수는 있겠지만, 두 구현 모두 많은 고인물들이 각각 애용하고 있다.</p>\n<p>위에서 본 다른 구현들, 그리고 또다른 마이너한 구현들 또한 애용하고 있는 고수들이 다 있다. 고인물들이니까 다른 방식의 구현을 이해하지 못할 리는 없다. 하지만 뉴비 때부터 손과 머리에 익은 방식을 두고 굳이 바꿀 건 없으니 그냥 계속 쓰고 있는 것이다. 이 글을 보시는 분들도 그렇게 한번 이해한 구현으로 쭉 가면 된다.</p>\n<p>나는 개인적으로 닫힌 구간으로 뭔가를 따지는 게 대부분의 경우 더 직관적이라고 생각하지만, 가령 n 길이의 배열에서 뭔가를 찾는다면 탐색 구간의 인덱스를 <code>[0, n-1]</code>로 표현하는 것보다는 <code>[0, n)</code>으로 표현하는 게 더 직관적이라고 생각한다. 어떤 구간을 쓰는지에 장단이 있는 것이다.</p>\n<p>결국 이런 걸로 아무도 싸우지 않기 때문에 그냥 스스로가 더 편한 방식으로 쓰면 된다. 가령 세그먼트 트리 같은 자료구조는 닫힌 구간으로 구현하는 사람이 더 많은 게 명백하다고 보이는데, 아무도 반열린 구간으로 구현하는 사람에게 뭐라 하는 것을 보지 못했다.</p>\n<p>따라서 이 글을 읽어 보고, 많은 참고자료도 보고 많은 문제를 풀어 보면서 스스로가 가장 잘 이해할 수 있는 방식대로 짜면 된다.</p>\n<h1>3. 여러가지 구현 - 방식의 차이</h1>\n<h2>3.1. binary jumping</h2>\n<p><a href=\"https://www.acmicpc.net/blog/view/109#comment-588\">jinhan814님이 BOJ에 쓰신 글에 달린 dohoon님의 댓글</a>에 적힌 구현이다. 지인들에 의하면 앳코더에 있는 의문의 인도인들(최강의 프로그래머)의 코드에서 가끔 볼 수 있는 방식이라고 한다.</p>\n<pre><code class=\"language-cpp\">int cur = low - 1;\nfor (int step = high - low + 1; step >= 1; step /= 2) {\n  while (cur + step &#x3C;= high &#x26;&#x26; check(cur + step)) {\n    cur += step;\n  }\n}\n</code></pre>\n<p>이 코드는 <code>cur</code>가 우리가 찾는, <code>check</code>이 true가 되는 구간의 상한이 되도록 한다. 이는 탐색 구간을 줄여 나가는 게 아니라 <code>cur</code>가 <code>check</code>이 true라는 조건을 만족할 때까지 늘려 나가는 방식이다.</p>\n<p>이 접근 방식은 다음과 같다. <code>cur</code>의 초기값 <code>low-1</code>과 우리가 찾는 정답과의 차이 <code>x</code>가 있을 것이다. 다르게 말하면 <code>cur+x</code>가 정답이 되도록 하는 수 <code>x</code>가 존재한다. 우리가 찾는 수는 <code>[low, high]</code>에 존재함이 보장되므로 이는 당연하다.</p>\n<p>그러면 우리는 <code>cur+x</code>를 찾기 위해 최대한도로 늘릴 수 있는 <code>step</code>부터 시작해서 <code>cur</code>을 늘려 나가면서 <code>check</code>이 true가 되는지 확인해 보면 된다. 만약 <code>check</code>이 <code>cur+step</code>에서 true라면 <code>cur</code>을 더 늘려 보면 되고 아니라면 <code>cur</code>을 늘리지 않고 <code>step</code>을 좀 줄여보면 된다. 이때 <code>step</code>은 2로 나눠 가면서 줄인다.</p>\n<p>이를 반복하다 보면 <code>cur</code>은 <code>check</code>이 true인 최대 상한에 도달할 것이라는 아이디어다.</p>\n<p>그러면 우리가 탐색하고 있는 구간의 <code>check</code>결과가 <code>[F, F, ..., F, T, ..., T]</code>와 같이 이루어져 있고 여기서 <code>F</code>로 이루어진 구간의 인덱스 상한을 찾는 문제라면 어떻게 할까? 그러면 위 코드의 <code>if</code>문만 <code>check</code>이 false인지 확인하는 것으로 바꾸면 된다.</p>\n<p>간단하죠?</p>\n<pre><code class=\"language-cpp\">int cur = low - 1;\nfor (int step = high - low + 1; step >= 1; step /= 2) {\n  // !check(cur + step)으로 바꿨다.\n  while (cur + step &#x3C;= high &#x26;&#x26; !check(cur + step)) {\n    cur += step;\n  }\n}\n</code></pre>\n<p>처음에 <code>step</code> 한 번을 가면 <code>high</code>가 되도록 만들기 위해 <code>step</code>의 초기값을 <code>high-low+1</code>로 잡았지만 어차피 <code>step</code>이 줄어들고 그때마다 가능한 만큼 나아가는 방식이기 때문에 <code>step</code>초기값은 <code>high</code>로 잡아도 상관없다. 다음과 같이 말이다.</p>\n<pre><code class=\"language-cpp\">int cur = low - 1;\nfor (int step = high; step >= 1; step /= 2) {\n  while (cur + step &#x3C;= high &#x26;&#x26; check(cur + step)) {\n    cur += step;\n  }\n}\n</code></pre>\n<p>이렇게 하면 <code>for</code>문은 계속 <code>step</code>만 변화시켜 가면서 같은 일을 반복하게 되고 이는 컴파일러가 loop unrolling 최적화를 할 수 있도록 하여 성능이 더 높아지는 경우도 있다고 한다. <a href=\"https://codeforces.com/blog/entry/96699\">캐싱 같은 걸 더 잘할 수 있도록 아예 <code>step</code>을 2의 제곱수 형태로 고정한 다음과 같은 코드의 경우 벤치마크 결과 시간이 약 25% 줄었다.</a></p>\n<pre><code class=\"language-cpp\">if (low > high) {\n  return high + 1;\n}\nhigh++;\nint step = (1) &#x3C;&#x3C; log(high - low);\nlow--;\nif (check(low + step)) {\n  low = high - step;\n}\nfor (step >>= 1; step >= 1; step >>= 1) {\n  if (check(low + step)) {\n    low += step;\n  }\n}\nreturn low + 1;\n</code></pre>\n<p>이런 binary jumping의 아이디어는 펜윅 트리나 LCA등 다른 고급 알고리즘에서도 사용되기 때문에 알아두면 좋다.</p>\n<h2>3.2. 재귀</h2>\n<p>이분 탐색을 재귀로 구현하는 방식도 있다. 자료구조 수업 같은 데에서 한번쯤 다들 보았을 거라 생각한다.</p>\n<pre><code class=\"language-cpp\">int binary_search(int arr[], int n, int target) {\n  int mid = n / 2;\n  if (arr[mid] == target) {\n    return mid;\n  } else if (arr[mid] > target) {\n    return binary_search(arr, mid, target);\n  } else {\n    return binary_search(arr + mid + 1, n - mid - 1, target);\n  }\n}\n</code></pre>\n<p>재귀를 잘 쓰는 사람이라면 이를 파라메트릭 서치로 쉽게 변형할 수 있을 것이다. 다음은 반열린 구간 탐색으로 구현한 코드이다. 다만 실제로 이렇게 파라메트릭 서치를 구현하는 사람은 난 지금까지 보지 못하기는 했다. 재귀가 일반적으로 반복문 구현에 비해 느리기도 하고 반복문 코드도 그렇게 비직관적인 코드가 아니라서 그렇다고 생각한다.</p>\n<pre><code class=\"language-cpp\">int binary_search(int low, int high) {\n  if (low == high) {\n    return low;\n  }\n  int mid = (low + high) / 2;\n  if (check(mid)) {\n    return binary_search(mid + 1, high);\n  } else {\n    return binary_search(low, mid);\n  }\n}\n</code></pre>\n<h1>4. 알아도 좋고 몰라도 좋은 이야기</h1>\n<h2>4.1. <code>mid=low+(high-low)/2</code>로 정의하기</h2>\n<p>많은 구현에서 대부분 <code>mid</code>는 다음과 같은 식으로 정의된다.</p>\n<pre><code class=\"language-c\">int mid = (low+high)/2;\n</code></pre>\n<p>하지만 이렇게 <code>mid</code>를 정의할 수도 있다. <a href=\"https://www.topcoder.com/thrive/articles/Binary+Search\">Topcoder의 이분 탐색 튜토리얼</a>등에서 이렇게 쓰고 있다.</p>\n<pre><code class=\"language-c\">int mid = low + (high - low) / 2;\n</code></pre>\n<p>이는 2가지 목적이 있다. 하나는 오버플로우 방지이다. 만약 <code>high</code>가 최대 $2^{62}$같은 큰 수라면(당연히 이럴 때 <code>low</code>, <code>high</code>등은 long long으로 선언되어 있을 것이다) 이분 탐색 과정에서 <code>(low + high) / 2</code>를 계산하다가 오버플로우가 발생할 수 있다. 이럴 때를 대비해서 <code>low + (high - low) / 2</code>로 정의해 주는 것이다.</p>\n<p>또 하나의 이유는 <code>low+high</code>가 음수일 경우를 대비한 것이다. 이분 탐색에서 우리가 <code>/2</code>를 취할 때는 보통 round down되기를 원한다. <code>5 / 2</code>는 2가 되는 식으로 말이다. 이는 정수 나눗셈이 있는 일반적인 언어들이라면 양수에 대해서는 보통 이렇게 동작한다.</p>\n<p>하지만 음수에 대해서는 어떨까? <code>-5 / 2</code>는 round down되면 <code>-3</code>이 되어야 한다. 하지만 <code>-5 / 2</code>는 C++등 많은 언어들에서 <code>-2</code>가 된다.</p>\n<p>따라서 <code>mid</code>의 정의를 <code>low + (high - low) / 2</code> 로 바꿔서 <code>/2</code>가 늘 round down되도록 만들어 준 것이 바로 위의 변경점이다.</p>\n<p><a href=\"https://en.cppreference.com/w/cpp/numeric/midpoint\">C++에서는 <code>std::midpoint</code>라는 라이브러리 함수를 제공하기도 한다. 여기의 구현이 바로 위에서 본 <code>low + (high - low) / 2</code>와 사실상 같다.</a></p>\n<p>물론 대부분의 경우 이분 탐색 문제의 범위는 양수이고 <code>high</code>를 long long 자료형에 <code>2e18</code>정도로 잡아 주면 충분히 모든 범위를 커버한다. 문제에서 나오는 수 범위가 보통 <code>1e18</code>정도가 끝이기 때문이다. 따라서 이런 식으로 <code>mid</code>를 정의하는 사람을 많이 보지는 못했다.</p>\n<h2>4.2. 실수 이분 탐색 팁</h2>\n<p><a href=\"https://solved.ac/profile/Lawali\">Lawali</a>님과 <a href=\"https://solved.ac/profile/yungoon\">YunGoon</a>님의 피드백으로 추가하였다.</p>\n<p>자연수 범위에서뿐 아니라 실수 범위에서도 이분탐색을 할 수 있다. 이를테면 해가 있는 단조 함수 형태 방정식의 근을 최대한 정확하게 찾는다든지 말이다. 이때는 <code>low</code>와 <code>high</code>, <code>mid</code>까지도 <code>double</code>형으로 선언하고 위에서와 비슷하게 이분 탐색을 하면 된다.</p>\n<p>그런데 실수 자료형을 비교할 때는 자료형의 한계상 정확한 비교가 불가능하기 때문에 <code>low</code>와 <code>high</code>의 차이가 충분히 작은지를 확인하는 방식으로 이분 탐색을 종료할 때가 많다. 보통 이 제한을 <code>1e-9</code>정도로 두고 <code>eps</code>(엡실론을 뜻함)변수로 나타낸다.</p>\n<pre><code class=\"language-cpp\">double low = 0, high = 1e9;\ndouble eps = 1e-9;\nwhile (high - low > eps) {\n  double mid = (low + high) / 2;\n  if (check(mid)) {\n    low = mid;\n  } else {\n    high = mid;\n  }\n}\n</code></pre>\n<p>그런데 이렇게 하면 정밀도의 문제 상 영원히 <code>high - low</code>가 <code>eps</code>보다 작아지지 않는 경우가 생겨서 무한 루프로 인한 시간초과가 날 수 있다.</p>\n<p>따라서 일정 횟수 동안만 이분 탐색을 수행하는 방식으로 구현하는 것이 좋고 일반적으로 200번 정도의 반복이면 충분하다고 한다.</p>\n<pre><code class=\"language-cpp\">double low = 0, high = 1e9;\ndouble eps = 1e-9;\nfor (int iter = 0; iter &#x3C; 200 &#x26;&#x26; high - low > eps; iter++) {\n  double mid = (low + high) / 2;\n  if (check(mid)) {\n    low = mid;\n  } else {\n    high = mid;\n  }\n}\n</code></pre>\n<h2>4.3. 캐시 최적화</h2>\n<p>우리가 보통 파라메트릭 서치를 할 때는 진짜 메모리에 저장된 배열에서 하기보다는 특정 수에 대해 어떤 동작이 가능한지를 따진다. 따라서 모든 이분 탐색에 응용할 수는 없지만 몇몇 경우 <a href=\"https://en.algorithmica.org/hpc/data-structures/binary-search/\">캐시 최적화를 할 수 있는 방법에 대한 아티클이 있었다.</a> 이 컨셉을 간단히만 소개하니 관심이 있는 사람은 원문을 참고하면 되겠다.</p>\n<p>이 글을 여기까지 읽을 정도의 고인물이라면 C++의 <code>lower_bound</code>를 사용한 적 있을 거라고 생각한다. 주어진 배열에서 특정 값 이상인 값이 처음 나오는 위치를 찾아 반환하는 함수이다.</p>\n<p>이 함수는 다음과 같은 논리로 구현되어 있다.</p>\n<pre><code class=\"language-cpp\">int lower_bound(int arr[], int n, int target) {\n  int low = 0, high = n;\n  while (low &#x3C; high) {\n    int mid = (low + high) / 2;\n    if (arr[mid] &#x3C; target) {\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n  return high;\n}\n</code></pre>\n<p>물론 실제로는 인덱스가 아니라 반복자를 반환하며 다양한 자료형 지원을 위해 템플릿으로 구현되어 있다는 차이가 있지만 그것이 여기서 크게 중요한 건 아니다.</p>\n<p>그런데 컴파일러는 코드를 실행하면서 캐싱을 수행하는데 이때 공간적 지역성과 시간적 지역성이 고려된다. 이 개념에 대해서는 따로 다루지는 않겠다. 하지만 위 코드를 보면 <code>mid</code>가 계속 큰 간격으로 변하고 쓰였던 <code>mid</code>가 다시 쓰이는 일도 없다.</p>\n<p>이를 개선하는 방법은 세그먼트 트리 등의 구조에서 어떻게 자료를 나타내는지에서 아이디어를 얻을 수 있다. 세그먼트 트리에서는 루트 노드를 0 혹은 1번 인덱스로 나타내고, <code>k</code>번 노드의 자식은 <code>2*k</code>, <code>2*k+1</code>번 인덱스로 나타낸다. 이런 형태...뭔가 이분 탐색에서 자주 쓰이는 형태 같지 않은가? 2로 나누기만 하면 되는 그런 형태.</p>\n<p>따라서 우리는 배열의 각 인덱스를 다음과 같이 재배치하려고 한다. 이런 전처리로 이뤄지는 이분탐색을 원문에서는 가계도 표현 방식을 정립한 <code>Michaël Eytzinger</code>의 이름을 따서 아이칭거 형태, 그리고 아이칭거 이분탐색이라고 칭하고 있다.</p>\n<p><img src=\"/static/array-changed-da720ec3.png\" alt=\"재배치된 배열 인덱스\"></p>\n<p>이런 형태로 재배열된 배열을 새로 만드는 함수는 다음과 같다. 재귀를 이용하기에 느려 보이지만 실제로는 모든 메모리 읽기가 연속 인덱스에 대해서 이루어지기 때문에 캐시의 공간적 지역성을 잘 활용할 수 있는 매우 빠른 코드라고 한다.</p>\n<pre><code class=\"language-cpp\">const int MAX_N = 1e5;\nint a[MAX_N], b[MAX_N+1];\n\nint eytzinger(int i = 0, int k = 1) {\n    if (k &#x3C;= n) {\n        i = eytzinger(i, 2 * k);\n        b[k] = a[i++];\n        i = eytzinger(i, 2 * k + 1);\n    }\n    return i;\n}\n</code></pre>\n<p>이렇게 재배치한 배열을 기반으로 <code>x</code>보다 크거나 같은 값이 등장하는 첫번째 인덱스를 반환하는 <code>lower_bound</code>함수는 다음과 같다. 이렇게 하면 접근하는 인덱스가 이전보다 훨씬 서로 가까워지므로 캐시의 공간적 지역성을 잘 활용할 수 있다.</p>\n<pre><code class=\"language-cpp\">int search(int x) {\n    int k = 1;\n    while (k &#x3C;= n) {\n        if (b[k] >= x)\n            k = 2 * k;\n        else\n            k = 2 * k + 1;\n    }\n    k >>= __builtin_ffs(~k);\n    return b[k];\n}\n</code></pre>\n<p>또한 <code>if</code>문이 들어간 코드에 대해서 컴파일러는 분기 예측을 수행하는데 이것이 실패 시 오히려 추가적인 사이클이 들어가게 된다. 따라서 분기가 없는 다음과 같은 코드로 바꿔보자.</p>\n<pre><code class=\"language-cpp\">int search(int x) {\n    int k = 1;\n    while (k &#x3C;= n) {\n        k = 2 * k + (b[k] &#x3C; x);\n    }\n    k >>= __builtin_ffs(~k);\n    return b[k];\n}\n</code></pre>\n<p>이렇게 하면 <code>if</code>문이 없어지고 분기 예측에 따른 추가적인 사이클도 없어지므로 더 빠른 코드가 된다. 그런데, 대규모 배열에서는 오히려 이 코드가 느려질 때도 있다! 이유는 <code>if</code>문에 들어 있는 값들에 대해서 컴파일러가 prefetch를 할 때가 있고 이것이 속도를 올려 준다고 한다.</p>\n<p><code>__builtin_prefetch</code>함수를 사용해서 분기 없이도 prefetch를 수행할 수 있다.</p>\n<pre><code class=\"language-cpp\">int search(int x) {\n    int k = 1;\n    while (k &#x3C;= n) {\n        __builtin_prefetch(&#x26;b[2 * k + (b[k] &#x3C; x)]);\n        k = 2 * k + (b[k] &#x3C; x);\n    }\n    k >>= __builtin_ffs(~k);\n    return b[k];\n}\n</code></pre>\n<p>이런 식으로 이분 탐색을 수행할 경우 대규모 배열에서 매우 빠른 속도를 경험할 수 있다고 한다. 참고자료를 보면 벤치마크 사진도 볼 수 있다.</p>\n<p>참고자료\n<a href=\"https://algorithmica.org/en/eytzinger\">https://algorithmica.org/en/eytzinger</a></p>\n<p><a href=\"https://en.algorithmica.org/hpc/data-structures/binary-search/\">https://en.algorithmica.org/hpc/data-structures/binary-search/</a></p>\n<h1>5. 추가 정보</h1>\n<p>이분 탐색과 관련된 몇 가지 추가적인 알고리즘들을 소개한다. 나도 아주 기본적인 이해 정도만 하고 있는 부분이기도 하고 이분 탐색 자체를 깊이 이해하는 목적과는 멀리 떨어져 있다고 생각되어 직관에 도움될 만하다고 생각하는 정말 간단한 컨셉의 소개만 한다.</p>\n<h2>5.1. 삼분 탐색(Ternary Search)</h2>\n<p>볼록 함수에서 극값 혹은 최대, 최솟값을 찾을 때 사용할 수 있는 알고리즘이다.</p>\n<p>이분 탐색 같은 경우 결정 문제의 결과가 <code>[T, T, T,..., T, F, ..., F]</code>로 결정되는 구간에서 T로 결정되는 구간의 최댓값을 결정하는 느낌이었다. 이를 다음과 같은 단조 증가(단조 감소도 상관없습니다)함수와 x축의 교점 좌표를 찾는 문제로 생각해 볼 수 있다.</p>\n<p><img src=\"/static/inc-graph-ex-0ac3ba1f.png\" alt=\"증가하는 그래프의 예시\"></p>\n<p>그러면 <code>f(low)</code>와 <code>f(high)</code>의 부호가 다르다면 <code>[low, high]</code>내에 근이 있다는 것이 보장될 것이고 이분 탐색으로 해당 근을 찾을 수 있다. <code>f(x) &#x3C; 0</code>인가? 라는 결정 문제로 환원하면 파라메트릭 서치로 생각할 수도 있다.</p>\n<p>비슷한 일을 볼록 함수(유니모달 함수)에 적용한 것이 삼분 탐색이다. 다음과 같은 볼록 함수에서 극값을 찾는 것이다.</p>\n<p><img src=\"/static/convex-graph-b67df172.png\" alt=\"볼록 그래프 예시\"></p>\n<p>극값이 있는 특정 구간을 알고 있다고 하면 해당 구간의 양 끝점과 삼분점 2개의 대소비교를 통해서 극값이 있을 가능성이 있는 구간을 2/3으로 줄일 수 있다는 아이디어다. 구간을 2개로만 나누지 않아도 쓸모가 있다는 예시 정도로 생각하면 좋을 것 같다.</p>\n<p>삼분 탐색이 더 궁금하신 분들은 kks227님의 글을 참고하면 좋다.\n<a href=\"https://blog.naver.com/kks227/221432986308\">https://blog.naver.com/kks227/221432986308</a></p>\n<h3>5.1.1. 다르게 구간 나누기</h3>\n<p>삼분 탐색은 결국 이러한 탐색 방법의 핵심이, 무언가를 찾기 위해 구간을 줄여 나가는데 이때 구간을 일정 비율씩 줄여서 시간복잡도를 $logN$단위로 나오도록 하는 데에 있다는 것을 보여준다.</p>\n<p>만약 이런 바리에이션에 관심이 있는 고인물이 있다면 <a href=\"https://codeforces.com/blog/entry/76182\">An alternative and very interesting approach on binary search</a>를 참고해도 좋겠다. 기존의 1:1이나 1:2 비율이 아니라 1:D 비율로 나누어서 시간복잡도를 조절한다. 해당 글에서 예시로 든 문제의 시간복잡도가 $\\mathcal{O}(n \\cdot m \\log_{D+1}(10^{18}) + n \\cdot \\log_{\\frac{D+1}{D}}(10^{18}))$이기 때문라고 한다.</p>\n<h2>5.2. 병렬 이분 탐색</h2>\n<p>일반적인 이분 탐색을 확장하여, 이분 탐색으로 풀 수 있는 쿼리를 한번에 여러 개 진행하는 병렬 이분 탐색이라는 기법도 있다.</p>\n<p>우리가 위에서 본 결정 문제는 그냥 <code>check</code>함수라고 하고 넘어갔지만 사실 이를 판단하는 데 꽤 큰 시간복잡도가 드는 경우가 많다. <a href=\"https://www.acmicpc.net/problem/1300\">BOJ 1300번 K번째 수 문제 같은 경우 mid보다 작거나 같은 수가 K개를 넘는지 결정하는 것이 check함수고 이는 꽤 연산량이 많다.</a> 따라서 이를 결정하는 데 드는 시간을 <code>f(N)</code>이라고 하자.</p>\n<p>그러면 한 번의 이분탐색을 진행해서 어떤 값을 찾는 데 걸리는 시간은 <code>f(N)logN</code>이 될 것이다. 그러면 이런 쿼리가 <code>Q</code>개 주어진다면 어떨까? 그러면 일반적인 이분 탐색으로는 <code>Qf(N)logN</code>이 걸릴 것이다.</p>\n<p>하지만 만약 어떤 처리를 통해서, 우리가 거치게 될 모든 결정 문제 스텝들에 대한 결과를 <code>f(N)logN</code>시간복잡도로 계산해 놓는다면 어떨까? 그러면 이후에는 그냥 이분 탐색을 진행하는 것만으로도 <code>QlogN</code>만에 모든 쿼리를 처리할 수 있을 것이다.</p>\n<p>즉 <code>f(N)</code>이 걸리는 작업을 <code>logN</code>단위 번 하고, 이분탐색을 <code>Q</code>번 진행하여 총 <code>(f(N) + Q)logN</code>시간복잡도로 문제를 해결하게 된다.</p>\n<p>하지만 그냥 이분 탐색과는 상당한 간극이 있고 내게도 익숙한 기법이 아니기 때문에 관심이 있으신 분들은 <a href=\"https://blog.naver.com/kks227/221410398513\">kks227님의 글</a>이나 <a href=\"https://justicehui.github.io/hard-algorithm/2020/02/24/pbs/\">나정휘 님의 글</a>을 참고하시면 더 많은 정보를 얻을 수 있다.</p>\n<h2>5.3. 세그먼트 트리의 이분 탐색</h2>\n<p><a href=\"https://www.acmicpc.net/problem/2243\">BOJ 2243번 사탕상자</a>와 같은 문제에서 사용되는 아이디어이다. 세그먼트 트리는 주어지는 쿼리에 대해 노드의 양쪽 자식들에 대해서 연산을 재귀적으로 수행하도록 하는데 이를 <code>check</code>함수의 결과에 따라서 어느 쪽 자식에 어떤 연산을 수행할지 정하는 걸로 약간 수정하는 것이다.</p>\n<p>세그먼트 트리에 각 수의 등장 빈도가 저장되어 있다고 했을 때 K번째 수를 찾는 함수는 다음과 같이 짜여진다. <code>cur</code>노드는 <code>[s, e]</code>를 커버하고 만약 현재 탐색하고 있는 구간의 왼쪽에 있는 수의 등장 빈도의 합이 <code>k</code>보다 크거나 같다면 왼쪽 자식 노드로 이동해 탐색하고 아니라면 오른쪽 자식으로 이동한다.</p>\n<pre><code class=\"language-cpp\">int kth(int cur, int s, int e, int k){\n    //kth 수를 리턴\n    if(s==e){return s;}\n    int mid=(s+e)/2;\n    if(k&#x3C;=tree[cur*2]){\n        return kth(cur*2, s, mid, k);\n    }\n    else{\n        return kth(cur*2+1, mid+1, e, k-tree[cur*2]);\n    }\n}\n</code></pre>\n<h1>참고</h1>\n<p>이분탐색 실수없이 짜기\n<a href=\"https://blog.fiene.dev/2023/01/16/binary-search.html\">https://blog.fiene.dev/2023/01/16/binary-search.html</a></p>\n<p>jinhan814님의 이분 탐색(Binary Search) 헷갈리지 않게 구현하기 <a href=\"https://www.acmicpc.net/blog/view/109\">https://www.acmicpc.net/blog/view/109</a></p>\n<p>jinhan814님의 이분탐색 블로그 글 <a href=\"https://blog.naver.com/jinhan814/222607789392\">https://blog.naver.com/jinhan814/222607789392</a></p>\n<p><code>[Tutorial]</code> Binary search and other \"halving\" methods <a href=\"https://codeforces.com/blog/entry/96699\">https://codeforces.com/blog/entry/96699</a></p>\n<p>topcoder의 binary search 글 <a href=\"https://www.topcoder.com/thrive/articles/Binary+Search\">https://www.topcoder.com/thrive/articles/Binary+Search</a></p>",
    "excerpt": "이분 탐색의 중요성?\n\n뻘글을 쓰고 싶은 기분이다. 이 글을 너무 진지하게 받지는 말기를 바란다.\n내가 들어 보았지만 알지 못하는 알고리즘들(내가 들어보지도 못한 것들은 또 얼마나 많을지)\n\n리-차오 세그먼트 트리\n세그먼트 트리 비츠\nO(n)/O(1) range max query\ntreap을 제외한 자가 균형 트리\n링크 컷 트리\n웨이블릿 트리\n머지 소트 트리\n바이노미얼 힙\n피보나치 힙\n(그 외에 웬만한 건 비교도 안 될 수많은 고인물 알고리즘들 이하생략)\n\n만약",
    "headingTree": [
      {
        "title": "이분 탐색의 중요성?",
        "url": "#이분-탐색의-중요성",
        "items": []
      },
      {
        "title": "시작",
        "url": "#시작",
        "items": []
      },
      {
        "title": "0. 배경",
        "url": "#0-배경",
        "items": []
      },
      {
        "title": "1. 문제 정의",
        "url": "#1-문제-정의",
        "items": []
      },
      {
        "title": "2. 여러가지 구현 - 구간의 차이",
        "url": "#2-여러가지-구현---구간의-차이",
        "items": [
          {
            "title": "2.1. 닫힌 구간 탐색",
            "url": "#21-닫힌-구간-탐색",
            "items": []
          },
          {
            "title": "2.2. 반열린 구간 탐색",
            "url": "#22-반열린-구간-탐색",
            "items": []
          },
          {
            "title": "2.3. 열린 구간 탐색",
            "url": "#23-열린-구간-탐색",
            "items": [
              {
                "title": "2.3.1. 주의할 부분",
                "url": "#231-주의할-부분",
                "items": []
              }
            ]
          },
          {
            "title": "2.4. 우열?",
            "url": "#24-우열",
            "items": []
          }
        ]
      },
      {
        "title": "3. 여러가지 구현 - 방식의 차이",
        "url": "#3-여러가지-구현---방식의-차이",
        "items": [
          {
            "title": "3.1. binary jumping",
            "url": "#31-binary-jumping",
            "items": []
          },
          {
            "title": "3.2. 재귀",
            "url": "#32-재귀",
            "items": []
          }
        ]
      },
      {
        "title": "4. 알아도 좋고 몰라도 좋은 이야기",
        "url": "#4-알아도-좋고-몰라도-좋은-이야기",
        "items": [
          {
            "title": "4.1. mid=low+(high-low)/2로 정의하기",
            "url": "#41-midlowhigh-low2로-정의하기",
            "items": []
          },
          {
            "title": "4.2. 실수 이분 탐색 팁",
            "url": "#42-실수-이분-탐색-팁",
            "items": []
          },
          {
            "title": "4.3. 캐시 최적화",
            "url": "#43-캐시-최적화",
            "items": []
          }
        ]
      },
      {
        "title": "5. 추가 정보",
        "url": "#5-추가-정보",
        "items": [
          {
            "title": "5.1. 삼분 탐색(Ternary Search)",
            "url": "#51-삼분-탐색ternary-search",
            "items": [
              {
                "title": "5.1.1. 다르게 구간 나누기",
                "url": "#511-다르게-구간-나누기",
                "items": []
              }
            ]
          },
          {
            "title": "5.2. 병렬 이분 탐색",
            "url": "#52-병렬-이분-탐색",
            "items": []
          },
          {
            "title": "5.3. 세그먼트 트리의 이분 탐색",
            "url": "#53-세그먼트-트리의-이분-탐색",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 4,
      "wordCount": 1013
    },
    "url": "/posts/binary-search-next-step",
    "thumbnail": {
      "local": "/static/end-of-search-103edffa.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-end-of-search-103edffa-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAADCAIAAAAhqtkfAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAU0lEQVR4nGMor2qMjc9saem1tPXYtmPvp08fz507d/v2HYYly5ZZWlvn5hVs3rJl7YaNU6ZMkZSUtLOzYwgKCoqNjdXW1p4yZcr///8/f/78DAwAwXEpP8TIkCIAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "blog-adding-view-count",
    "title": "블로그에 조회수 추가하기",
    "date": "2023-04-12T00:00:00Z",
    "description": "조회수를 블로그에 표시해 보기",
    "tags": [
      "blog",
      "web"
    ],
    "html": "<h1>1. 서론</h1>\n<p>블로그 조회수가 적게 나오는 것 같지는 않다. cloudflare의 분석에 의하면 하루 평균적으로 100명 정도는 오는 것 같았다. 그래서 한번 블로그에 조회수 카운터를 만들어 보기로 했다.</p>\n<p>수많은 삽질이 있었다. <a href=\"https://github.com/fienestar\">fienestar</a>님의 도움으로 결국 간단한 방법으로 조회수를 추가할 수 있었는데 그 방법을 먼저 쓴 후 삽질의 기록을 뒤에 쓰도록 하겠다.</p>\n<p>busuanzi라는 중국 서비스가 있는데 이를 이용하면 페이지와 블로그 조회수를 쉽게 추가할 수 있다.</p>\n<h1>2. busuanzi 사용</h1>\n<p><a href=\"https://fienestar.github.io/blog/2020/05/24/busuanzi%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EC%A0%95%EC%A0%81%EC%9D%B8-%ED%8E%98%EC%9D%B4%EC%A7%80%EC%97%90-%EC%8A%A4%ED%83%80%EC%9D%BC-%EB%B3%80%EA%B2%BD%EC%9D%B4-%EA%B0%80%EB%8A%A5%ED%95%9C-%EC%A1%B0%ED%9A%8C%EC%88%98-%EC%B6%94%EA%B0%80%ED%95%98%EA%B8%B0/\">fienestar님의 가이드</a>를 따라하면 된다. 단 내 블로그에 맞게 하기 위한 몇 가지 수정이 필요하다.</p>\n<p>먼저 다음 코드를 사이트의 head 혹은 body에 추가해야 한다.</p>\n<pre><code class=\"language-html\">&#x3C;script async src = \"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\">&#x3C;/script>\n</code></pre>\n<p>내 블로그에는 <code>Seo</code>라는 컴포넌트가 있고 이는 블로그의 모든 페이지에 삽입된다. 그리고 이 <code>Seo</code> 컴포넌트는 react-helmet의 Helmet 컴포넌트로 이루어져 있는데 이 Helmet 컴포넌트는 head 태그에 들어가는 내용을 관리한다.</p>\n<p>따라서 Helmet 컴포넌트 사이에 저 코드를 추가해 주면 된다.</p>\n<pre><code class=\"language-tsx\">&#x3C;Helmet\n// SEO를 위한 메타 정보들이 들어가 있다.\n// 여기서는 중요하지 않으므로 생략\n>\n  &#x3C;script async src = '//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js'>&#x3C;/script>\n&#x3C;/Helmet>\n</code></pre>\n<h2>2.1. 사이트 조회수와 방문자 수</h2>\n<p>사이트 조회수와 방문자 수는 다음 코드를 통해 추가할 수 있다. span에 붙은 id가 중요하다.</p>\n<pre><code class=\"language-html\">&#x3C;section style={{height:'20px'}}>\n  조회수 &#x3C;span id = 'busuanzi_value_site_pv' >&#x3C;/span> 회 &#x3C;br />\n  방문자 &#x3C;span id = 'busuanzi_value_site_uv' >&#x3C;/span> 명\n&#x3C;/section>\n</code></pre>\n<p>위 코드를 블로그의 페이지에 추가하면 된다. 내 블로그의 경우 메인 페이지를 나타내는 BlogIndex 컴포넌트에서 내 프로필 바로 아래에 추가했다.</p>\n<p>이 조회수 표시를 위한 삽질을 하면서 블로그를 재구성해야겠다는 생각을 많이 했기 때문에 지금 굳이 스타일링을 하지는 않았다.</p>\n<h2>2.2. 페이지 조회수</h2>\n<p>단일 페이지의 조회수는 다음 코드로 추가한다.</p>\n<pre><code class=\"language-html\">&#x3C;span id=\"busuanzi_value_page_pv\">&#x3C;/span>\n</code></pre>\n<p>이를 글 제목 아래에 적당히 추가하였다.</p>\n<p>다른 삽질의 기록들은 아래에 적어두었다. 후에 블로그를 갈아엎을 때 이 지식을 쓰게 되길 바란다.</p>\n<h1>1. 블로그를 구글 애널리틱스에 추가</h1>\n<p><a href=\"https://ha-young.github.io/2020/gatsby/Add-Google-Analytics/\">블로그를 Google Analytics에 추가</a>글을 따라하였다.</p>\n<h2>1.1. 계정 생성</h2>\n<p>구글 애널리틱스 계정을 새로 생성하자.</p>\n<p><img src=\"/static/create-account-de20c939.png\" alt=\"create-account\"></p>\n<p>그리고 웹사이트 속성도 설정한다.</p>\n<p><img src=\"/static/attr-setting-d3741890.png\" alt=\"attr-set\"></p>\n<p>비즈니스 정보도 적당히 설정한 후 약관 등에 동의하고 계정 생성을 마친다.</p>\n<h2>1.2. 데이터 스트림과 태그 추가</h2>\n<p>그 다음 데이터 스트림 메뉴에 들어가서 페이지의 데이터 스트림을 추가해 주자.</p>\n<p><img src=\"/static/create-data-stream-bced1711.png\" alt=\"data-stream\"></p>\n<p>어..그런데 다음과 같은 경고가 뜬다. 데이터 수집이 활성화되지 않았다고 한다.</p>\n<p><img src=\"/static/site-no-data-b2e65df8.png\" alt=\"site-no-data\"></p>\n<p>앞에서 획득한 측정 ID를 등록해 줘야 하기 때문이다. <code>gatsby-plugin-google-gtag</code>를 설치하자.</p>\n<pre><code>npm install gatsby-plugin-google-gtag\n</code></pre>\n<p>이렇게 하고 내 블로그의 gatsby-config.ts에 들어가 보니 이미 구글 애널리틱스와 관련된 항목이 있었다.</p>\n<pre><code class=\"language-ts\">{\n  resolve: 'gatsby-plugin-google-analytics',\n  options: {\n    trackingId: siteMetadata.googleAnalytics,\n    head: true,\n    anonymize: true,\n    defer: true,\n  },\n},\n</code></pre>\n<p>gatsby-plugin-google-gtag의 옛날 버전이다. 그러나 우리는 이를 gtag로 바꿨으므로 거기에 맞게 내용을 바꿔주자.</p>\n<pre><code class=\"language-ts\">{\n  resolve: \"gatsby-plugin-google-gtag\",\n  options: {\n    trackingIds: [siteMetadata.googleAnalytics],\n    gtagConfig: {\n      anonymize_ip: true,\n    },\n    pluginConfig: {\n      head: true,\n    },\n  },\n},\n</code></pre>\n<p>그리고 아까 데이터 스트림을 추가하고 얻은 측정 ID를 <code>siteMetadata</code>에 추가한다. 나 같은 경우 blog-config.ts에 있었다. 그런데 이런 siteMetadata를 사용하지 않는다면 그냥 문자열로 추가해도 된다.</p>\n<h2>1.3. 삽질</h2>\n<p><img src=\"/static/node-version-error-577e64e3.png\" alt=\"node-version\"></p>\n<p>하지만 문제가 발생했다. <code>gatsby-plugin-google-gtag</code> 는 node 18 이상을 요구한다. cloudflare는 node 17까지밖에 지원을 안 한다. <a href=\"https://community.cloudflare.com/t/support-node-18-in-pages-or-allow-config/414797/4\">node 18을 cloudflare에서 쓰는 걸 베타테스트 중</a>이라고 하는데 어떻게 될지 모르겠다..</p>\n<p>어쩔 수 없이, analytics.js가 2023년 9월까지는 지원한다고 하니 울며 겨자먹기로 이걸 쓰기로 했다. 다시 gatsby-config.ts를 원래대로 돌리자..</p>\n<pre><code class=\"language-ts\">{\n  resolve: 'gatsby-plugin-google-analytics',\n  options: {\n    trackingId: siteMetadata.googleAnalytics,\n    head: true,\n    anonymize: true,\n    defer: true,\n  },\n},\n</code></pre>\n<p>그리고 빌드에 오류를 발생시키는 <code>gatsby-plugin-google-gtag</code>를 삭제하자.</p>\n<pre><code>yarn remove gatsby-plugin-google-gtag\n</code></pre>\n<p>하지만 여전히 잘 되지 않는다. 왜일까? 찾아보니 확실한지는 모르겠지만 GA4 이후로 새로 만든 계정이라면 gtag를 써야만 구글 애널리틱스에 등록이 된다고 한다. node 18 이상은 애초에 cloudflare를 사용하지 않는데..</p>\n<p>그런데 내가 본 글들은 다 <code>gatsby-plugin-google-gtag</code>를 잘 사용했다. 뭐지? 생각해 보니 gtag가 언제나 node 18을 사용하지는 않았을 것이다. 저 사람들이 사용할 때는 node의 더 낮은 버전을 요구했을 것이다. 그럼 나는 <code>gatsby-plugin-google-gtag</code>의 더 낮은 버전을 사용하면 되는 것이다!</p>\n<h2>1.4. 다시, Google Analytics 태그 추가</h2>\n<p><code>gatsby-plugin-google-gtag</code>의 이전 버전을 설치해 보자. 찾아보니 <code>gatsby-plugin-google-gtag</code>의 최신 버전은 5.8.0인데 4.25.0과 3.15.0도 다운로드 수가 만만치 않았다. 안전하게 제일 예전 버전으로 다운받자 싶어서 3.15.0을 받기로 했다.</p>\n<pre><code>npm install gatsby-plugin-google-gtag@3.15.0\n</code></pre>\n<p>그리고 기존에 있던 낡은 라이브러리는 삭제하자.</p>\n<pre><code>npm uninstall gatsby-plugin-google-analytics\n</code></pre>\n<p>그리고 gatsby-config.ts에서 <code>gatsby-plugin-google-analytics</code>에 관한 내용이 있었던 부분을 다음과 같이 수정하자.</p>\n<p>혹시 몰라서 gtag플러그인 정보를 plugins 배열 최상단에 위치시켰다. 누군가가 구글 애널리틱스 플러그인이 최상단에 있어야 태그 추가가 잘 된다고 했기 때문이다.</p>\n<pre><code class=\"language-ts\">{\n  resolve: \"gatsby-plugin-google-gtag\",\n  options: {\n    trackingIds: [siteMetadata.googleAnalytics],\n    gtagConfig: {\n      anonymize_ip: true,\n    },\n    pluginConfig: {\n      head: true,\n    },\n  },\n},\n</code></pre>\n<p>이제 다시 빌드해 보면 성공한다. 그리고 조금 기다리자 애널리틱스 페이지에도 다음과 같은 창이 떴다!</p>\n<p><img src=\"/static/site-analysis-started-8404a222.png\" alt=\"analytics-started\"></p>\n<p>아아..드디어..</p>\n<h1>2. 조회수 가져오는 API 사용하기</h1>\n<p>구글 애널리틱스 API를 사용하여 게시글 조회수를 알아내도록 하자. <a href=\"https://blog.yeppyshiba.com/article/adding-view-count-in-gatsby/\">이 글</a>을 따라해 보았다.</p>\n<h2>2.1 API 권한 설정</h2>\n<p>먼저 <a href=\"https://developers.google.com/analytics/devguides/reporting/data/v1/quickstart-client-libraries\">API 활성화</a>를 하자.</p>\n<p>그러면 프로젝트 이름을 입력하는 창이 뜨는데 입력과 약관 동의 후 다음으로 넘어간다. 그러면 private key들이 담긴 json 파일을 받을 수 있다.</p>\n<p><img src=\"/static/enable-analytics-api-ab9cbd0c.png\" alt=\"enable-api\"></p>\n<p><img src=\"/static/download-credentials-77812028.png\" alt=\"download-credentials\"></p>\n<p>다운받은 json 파일을 열어서 <code>client_email</code>항목을 보자. 그리고 구글 애널리틱스 설정 화면에서 왼쪽 아래의 톱니바퀴를 누르고 속성 > 속성 액세스 관리 탭에 들어간다.</p>\n<p>그리고 <code>client_email</code>의 이메일을 추가하고 권한을 뷰어로 설정한다.</p>\n<p><img src=\"/static/api-access-4c351572.png\" alt=\"api-access\"></p>\n<p>TODO.</p>\n<h1>4. 다른 방법, DB 사용하기</h1>\n<p>구글 애널리틱스를 조회수에 사용할 경우 애드블럭 등의 이유로 약 <a href=\"https://leerob.io/blog/real-time-post-views\">10% 정도의 조회수가 누락된다고 한다.</a> 특히 기술 관련 블로그일 경우 더 그렇다고 한다. 아마 기술적인 내용을 읽는 사람들은 대부분 애드블럭을 써서 그런 듯 하다.</p>\n<p>따라서 firebase의 DB를 이용하는 방법이 있어서 이를 사용하려 했다. 처음엔 <a href=\"https://leerob.io/blog/real-time-post-views\">이 글</a>을 보고 따라하려 했으나 이 글은 Nextjs를 사용하며 api route 환경을 필요로 한다.</p>\n<p>그래서 더 조사하던 중 누군가가 <a href=\"https://dev.to/flashblaze/displaying-real-time-views-using-react-gatsby-and-firebase-283f\">gatsby에서, 클라이언트 조작만으로 조회수를 얻는 법</a>에 관한 글을 써주어서 이를 사용하였다.</p>\n<h1>5. firebase 세팅</h1>\n<h2>5.1. firebase 프로젝트 생성</h2>\n<p>firebase에 로그인하고 콘솔로 이동한다. 나는 구글 계정으로 로그인했다. 그리고 상단 메뉴에 '콘솔로 이동'을 눌러 콘솔로 이동한다.</p>\n<p>그러면 프로젝트를 만들 수 있는 화면이 나오는데 당연히 프로젝트를 만들러 이동하자.</p>\n<p><img src=\"/static/create-firebase-project1-2276238e.png\" alt=\"create-project\"></p>\n<p>난 <code>witch-work-views</code>라는 프로젝트를 만들었다. 그리고 구글 애널리틱스를 달 수도 있는데 나는 이전에 만들어 둔 계정이 있어서 그냥 달았다.</p>\n<h2>5.2. DB 설정</h2>\n<p>이제 조회수를 관리할 DB를 만들자. 좌측 메뉴에서 빌드 > Realtime Database를 클릭한다.</p>\n<p><img src=\"/static/realtime-database-menu-481f00b0.png\" alt=\"realtime-database-menu\"></p>\n<p>데이터베이스 만들기 클릭. 위치는 그냥 미국으로 하자. 그리고 보안 규칙은 테스트 모드에서 시작하기를 선택한다.</p>\n<p><img src=\"/static/db-test-mode-793e6d16.png\" alt=\"db-test-mode\"></p>\n<p>그러면 실시간 데이터베이스가 만들어진다.</p>\n<p>그 다음 왼쪽 메뉴의 톱니바퀴를 누르고 '프로젝트 설정'을 선택한다.</p>\n<p><img src=\"/static/project-setting-menu-c03f780d.png\" alt=\"project-settingmenu\"></p>\n<p>그리고 스크롤을 좀 아래로 내리면 '내 앱'이라는 메뉴가 있고 프로젝트에 앱이 없다는 말이 써 있다. 플랫폼을 선택해서 프로젝트를 새로 만들 수 있는데 웹앱을 선택하자. HTML 태그처럼 보이는 걸 택하면 된다.</p>\n<p><img src=\"/static/create-web-app-56b8e942.png\" alt=\"create-web-app\"></p>\n<p>그러면 앱을 만드는 창이 뜨는데 이름을 입력하자. 그리고 firebase 호스팅 설정은 체크하지 않고 넘어가자. 나는 앱 이름을 <code>witch-work-views-app</code>으로 했다.</p>\n<p>아래와 같은 상태에서 '앱 등록'을 누른다.</p>\n<p><img src=\"/static/create-app-name-240c6f58.png\" alt=\"create-app-name\"></p>\n<p>그 다음 Firebase SDK 추가 단계는 뭐 건드리지 말고 그냥 '콘솔로 이동'을 선택했다.</p>\n<p>그리고 다시 아까 만들었던 Realtime Database로 돌아가서 '규칙' 메뉴를 선택한다. 현재는 다음과 같이 되어 있다. read, write 둘 다 2023년 5월 12일 전까지 true로 설정되어 있는 것이다.</p>\n<p><img src=\"/static/previous-db-rule-09644ac2.png\" alt=\"prev-db-rule\"></p>\n<p>이 rule을 다음과 같이 변경한다.</p>\n<pre><code class=\"language-json\">{\n  \"rules\": {\n        \"views\": {\n          \"$page\": {\n                \".read\": true,\n                \".write\": true,\n                \".validate\": \"newData.isNumber()\"\n        }\n      }\n   }\n}\n</code></pre>\n<p>이렇게 하면 모든 사용자가 <code>views</code>라는 DB의 모든 페이지에 대한 조회수를 읽고 쓸 수 있게 된다.</p>\n<h1>6. gatsby 설정</h1>\n<p>먼저 firebase와 gatsby-plugin-firebase를 설치한다.</p>\n<pre><code>npm install firebase gatsby-plugin-firebase\n</code></pre>\n<p>gatsby-config.ts에 다음과 같은 내용을 추가한다. <a href=\"https://www.gatsbyjs.com/plugins/gatsby-plugin-firebase/?=firebase\">공식 문서</a>에서 복붙하면 된다.</p>\n<pre><code class=\"language-typescript\">{\n  resolve: \"gatsby-plugin-firebase\",\n  options: {\n    credentials: {\n      apiKey: \"&#x3C;YOUR_FIREBASE_API_KEY>\",\n      authDomain: \"&#x3C;YOUR_FIREBASE_AUTH_DOMAIN>\",\n      databaseURL: \"&#x3C;YOUR_FIREBASE_DATABASE_URL>\",\n      projectId: \"&#x3C;YOUR_FIREBASE_PROJECT_ID>\",\n      storageBucket: \"&#x3C;YOUR_FIREBASE_STORAGE_BUCKET>\",\n      messagingSenderId: \"&#x3C;YOUR_FIREBASE_MESSAGING_SENDER_ID>\",\n      appId: \"&#x3C;YOUR_FIREBASE_APP_ID>\"\n    }\n  }\n}\n</code></pre>\n<p>또한 우리가 실시간 데이터베이스를 사용하기 때문에 <code>import 'firebase/database</code>를 gatsby-browser.ts와 gatsby-ssr.tsx에 추가한다.</p>\n<p>그 다음 firebase console로 이동하여 프로젝트 설정으로 이동한다. 그리고 스크롤을 내리면 내 앱의 firebaseConfig를 볼 수 있다.</p>\n<p><img src=\"/static/firebase-config-cbdddb6c.png\" alt=\"firebase-config\"></p>\n<p>.env를 만들고 위의 config 값들을 하나하나 넣는다. 그리고 dotenv 설치.</p>\n<pre><code>npm install dotenv\n</code></pre>\n<h1>참고</h1>\n<p><a href=\"https://www.gatsbyjs.com/plugins/gatsby-plugin-google-gtag/\">https://www.gatsbyjs.com/plugins/gatsby-plugin-google-gtag/</a></p>\n<p><a href=\"https://ha-young.github.io/2020/gatsby/Add-Google-Analytics/\">https://ha-young.github.io/2020/gatsby/Add-Google-Analytics/</a></p>\n<p><a href=\"https://leerob.io/blog/real-time-post-views\">https://leerob.io/blog/real-time-post-views</a></p>\n<p><a href=\"https://dev.to/flashblaze/displaying-real-time-views-using-react-gatsby-and-firebase-283f\">https://dev.to/flashblaze/displaying-real-time-views-using-react-gatsby-and-firebase-283f</a></p>\n<p><a href=\"https://www.gatsbyjs.com/plugins/gatsby-plugin-firebase/?=firebase\">https://www.gatsbyjs.com/plugins/gatsby-plugin-firebase/?=firebase</a></p>\n<p><a href=\"https://www.daleseo.com/js-dotenv/\">https://www.daleseo.com/js-dotenv/</a></p>",
    "excerpt": "1. 서론\n블로그 조회수가 적게 나오는 것 같지는 않다. cloudflare의 분석에 의하면 하루 평균적으로 100명 정도는 오는 것 같았다. 그래서 한번 블로그에 조회수 카운터를 만들어 보기로 했다.\n수많은 삽질이 있었다. fienestar님의 도움으로 결국 간단한 방법으로 조회수를 추가할 수 있었는데 그 방법을 먼저 쓴 후 삽질의 기록을 뒤에 쓰도록 하겠다.\nbusuanzi라는 중국 서비스가 있는데 이를 이용하면 페이지와 블로그 조회수를 쉽게 추가할 수 있다",
    "headingTree": [
      {
        "title": "1. 서론",
        "url": "#1-서론",
        "items": []
      },
      {
        "title": "2. busuanzi 사용",
        "url": "#2-busuanzi-사용",
        "items": [
          {
            "title": "2.1. 사이트 조회수와 방문자 수",
            "url": "#21-사이트-조회수와-방문자-수",
            "items": []
          },
          {
            "title": "2.2. 페이지 조회수",
            "url": "#22-페이지-조회수",
            "items": []
          }
        ]
      },
      {
        "title": "1. 블로그를 구글 애널리틱스에 추가",
        "url": "#1-블로그를-구글-애널리틱스에-추가",
        "items": [
          {
            "title": "1.1. 계정 생성",
            "url": "#11-계정-생성",
            "items": []
          },
          {
            "title": "1.2. 데이터 스트림과 태그 추가",
            "url": "#12-데이터-스트림과-태그-추가",
            "items": []
          },
          {
            "title": "1.3. 삽질",
            "url": "#13-삽질",
            "items": []
          },
          {
            "title": "1.4. 다시, Google Analytics 태그 추가",
            "url": "#14-다시-google-analytics-태그-추가",
            "items": []
          }
        ]
      },
      {
        "title": "2. 조회수 가져오는 API 사용하기",
        "url": "#2-조회수-가져오는-api-사용하기",
        "items": [
          {
            "title": "2.1 API 권한 설정",
            "url": "#21-api-권한-설정",
            "items": []
          }
        ]
      },
      {
        "title": "4. 다른 방법, DB 사용하기",
        "url": "#4-다른-방법-db-사용하기",
        "items": []
      },
      {
        "title": "5. firebase 세팅",
        "url": "#5-firebase-세팅",
        "items": [
          {
            "title": "5.1. firebase 프로젝트 생성",
            "url": "#51-firebase-프로젝트-생성",
            "items": []
          },
          {
            "title": "5.2. DB 설정",
            "url": "#52-db-설정",
            "items": []
          }
        ]
      },
      {
        "title": "6. gatsby 설정",
        "url": "#6-gatsby-설정",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 2,
      "wordCount": 416
    },
    "url": "/posts/blog-adding-view-count",
    "thumbnail": {
      "local": "/static/create-account-de20c939.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-create-account-de20c939-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAIAAAA8r+mnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAYElEQVR4nGOYO2/BkSNHnz9/8ezZs9u378ARw/Xr16dMmXLr1q1nz579+/f3PwwwPHv2bMqU6fsOHDh9+vTz5y8gop8/f2b4/PmzlY2tuISEtraOsYlZSEionZ3d7DlzAFMSRl+N8W4HAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "blog-fix20230808",
    "title": "블로그 수리의 기록 - 조회수 연동, 새로운 요소 최적화",
    "date": "2023-08-08T00:00:00Z",
    "description": "밤은 짧아 돌아 블로그야",
    "tags": [
      "blog"
    ],
    "html": "<h1>블로그 만들기 시리즈</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>제목</th><th>링크</th></tr></thead><tbody><tr><td>1. 기본 세팅</td><td><a href=\"https://witch.work/posts/blog-remake-1\">https://witch.work/posts/blog-remake-1</a></td></tr><tr><td>2. 메인 페이지의 HTML 설계</td><td><a href=\"https://witch.work/posts/blog-remake-2\">https://witch.work/posts/blog-remake-2</a></td></tr><tr><td>3. 글 상세 페이지의 구조 설계</td><td><a href=\"https://witch.work/posts/blog-remake-3\">https://witch.work/posts/blog-remake-3</a></td></tr><tr><td>4. 이미지를 상대 경로로 쓸 수 있도록 하기</td><td><a href=\"https://witch.work/posts/blog-remake-4\">https://witch.work/posts/blog-remake-4</a></td></tr><tr><td>5. 자잘한 페이지 구성 개선과 배포</td><td><a href=\"https://witch.work/posts/blog-remake-5\">https://witch.work/posts/blog-remake-5</a></td></tr><tr><td>6. 페이지 요소의 배치 설계</td><td><a href=\"https://witch.work/posts/blog-remake-6\">https://witch.work/posts/blog-remake-6</a></td></tr><tr><td>7. 메인 페이지 컴포넌트 디자인</td><td><a href=\"https://witch.work/posts/blog-remake-7\">https://witch.work/posts/blog-remake-7</a></td></tr><tr><td>8. 글 목록/내용 페이지 컴포넌트 디자인</td><td><a href=\"https://witch.work/posts/blog-remake-8\">https://witch.work/posts/blog-remake-8</a></td></tr><tr><td>9. 글 썸네일 자동 생성하기</td><td><a href=\"https://witch.work/posts/blog-remake-9\">https://witch.work/posts/blog-remake-9</a></td></tr><tr><td>10. 폰트, 카드 디자인 등의 디자인 개선</td><td><a href=\"https://witch.work/posts/blog-remake-10\">https://witch.work/posts/blog-remake-10</a></td></tr><tr><td>11. 글에 조회수 달기</td><td><a href=\"https://witch.work/posts/blog-remake-11\">https://witch.work/posts/blog-remake-11</a></td></tr><tr><td>12. 페이지 테마와 글 검색 기능</td><td><a href=\"https://witch.work/posts/blog-remake-12\">https://witch.work/posts/blog-remake-12</a></td></tr><tr><td>13. 테마 아이콘과 썸네일 레이아웃 개선 등</td><td><a href=\"https://witch.work/posts/blog-remake-13\">https://witch.work/posts/blog-remake-13</a></td></tr><tr><td>14. 글 분류를 태그 기반으로 변경</td><td><a href=\"https://witch.work/posts/blog-remake-14\">https://witch.work/posts/blog-remake-14</a></td></tr><tr><td>메인 페이지의 연산 최적화</td><td><a href=\"https://witch.work/posts/blog-opt-1\">https://witch.work/posts/blog-opt-1</a></td></tr><tr><td>글 목록 페이지네이션 만들기</td><td><a href=\"https://witch.work/posts/blog-opt-2\">https://witch.work/posts/blog-opt-2</a></td></tr><tr><td>이미지를 CDN에 올리고 placeholder 만들기</td><td><a href=\"https://witch.work/posts/blog-opt-3\">https://witch.work/posts/blog-opt-3</a></td></tr><tr><td>검색 페이지에 무한 스크롤 구현하기</td><td><a href=\"https://witch.work/posts/blog-opt-4\">https://witch.work/posts/blog-opt-4</a></td></tr></tbody></table>\n<h1>1. 문제 발생</h1>\n<p>블로그를 보다가 조회수 부분을 유심히 보니 뭔가 이상했다. 현재 DB에 저장되고 있는 조회수가 하나로 묶여서 저장되고 있는 것 같았다. 그래서 supabase에 가서 테이블을 보니 웬 <code>undefined</code>값에 조회수가 모두 수신되고 있었다.</p>\n<p>그리고 썸네일을 CDN에 업로드하는 데에도 오류가 발생하고 있었다. 하지만 현재 CDN으로 사용하고 있는 cloudinary의 무료 플랜은 업로드에 대해 상당히 빡빡하므로 한번한번 고치기가 쉽지 않았다. 그래서 일단 로컬에 모든 썸네일을 저장해 놓는 걸로 대체한 후 다른 작업들을 먼저 진행하였다. 이 글에서 이 부분도 한번 고쳐 보도록 하겠다.</p>\n<h1>2. 조회수 카운터 오류</h1>\n<p>확인 결과 <code>ViewCounter</code>에서는 문제가 없었다. 이 조회수를 쓰는 곳은 글 상세 페이지였는데 여기서는 slug를 만들어서 <code>ViewCounter</code>컴포넌트에 props로 넘겨주었고 해당 컴포넌트에서는 그 props로 받은 slug를 기반으로 DB 키를 만들었다.</p>\n<p>문제는 slug를 만드는 코드가 다음과 같았다는 것이다.</p>\n<pre><code class=\"language-tsx\">const slug=post._raw.flattenedPath.split('/')[1];\n</code></pre>\n<p>이는 <code>post._raw.flattenedPath</code>가 <code>[category]/[slug]</code>형식이었을 때의 잔재이다. 현재는 post의 <code>flattenedPath</code>가 slug만 가리키도록 수정되었다. 따라서 이를 수정해 주기만 하면 된다.</p>\n<pre><code class=\"language-tsx\">const slug=post._raw.flattenedPath;\n</code></pre>\n<h1>3. 썸네일 업로드 오류</h1>\n<p>이상한 것은 Vercel에서는 <code>yarn run build</code>를 했을 때 이 cloudinary 업로드가 잘 진행되는데 로컬에서는 이게 잘 안되는 것이다. 대략 이런 오류 메시지가 발생했다.</p>\n<pre><code class=\"language-bash\">\"binary-search/index.md\": UnexpectedMarkdownError: Must supply api_key\n</code></pre>\n<p>그래서 환경변수를 한번 출력해 보았더니 역시나, 로컬에서는 환경변수를 제대로 인식하지 못하고 있었다. 분명 <code>.env.local</code>에 잘 넣어 줬는데 말이다.</p>\n<p>이는 나중에 홈서버로 블로그를 배포하는 과정에서 해결하였다. <a href=\"https://witch.work/posts/blog-home-server-3\">홈 서버로 블로그 배포하기 3번 글을 참고하자.</a></p>\n<h1>4. 최적화</h1>\n<p>그런데 이제 보니 블로그가 상당히 느려졌다. Lighthouse로 점수를 측정해 보니 70점대로 떨어졌다.</p>\n<p><img src=\"/static/current-lighthouse-score-11e04252.png\" alt=\"현재 Lighthouse 점수\"></p>\n<p>분명 한때는 점수가 90점대 후반이었는데...물론 Lighthouse점수가 전부는 아니지만 실제로 체감상 느려지기도 했다.</p>\n<p>이미지가 문제일 수도 있겠지만 모바일에서의 글 목록 페이지와 같은 경우는 이미지가 없는데도 불구하고 느려졌다. 나머지는 여전히 괜찮은 편인데, 사용자가 컨텐츠를 보기까지 걸리는 시간인 Total blocking time이 너무 길어진 게 문제다. 원인을 분석해보자.</p>\n<p>빌드 과정을 다 들여다볼 수는 없으니 하나하나 실험해 가면서 고통스러운 최적화를 진행해야 했다. 무언가 더 나은 방법을 아시는 분이 있다면 꼭 알려주시길.</p>\n<h2>4.1. 원인 분석</h2>\n<p>Vercel에서는 내가 지금까지 배포했던 사이트들을 모두 보존해 놓고 있다. 이게 영원히 보존되는 건지는 모르겠지만 블로그 성능이 떨어진지는 얼마 되지 않았으므로 추적에는 충분하다. 이런 수많은 로그 중 어딘가에 성능을 떨어뜨린 변화가 숨어 있을 것이다.</p>\n<p><img src=\"/static/vercel-log-4be5a2c4.png\" alt=\"vercel 배포 로그\"></p>\n<p>며칠 전 태그 기반으로 블로그 페이지들을 개편하기 전의 페이지를 적당히 찍어서 메인페이지의 Lighthouse 점수를 찍어 보니 여기서는 100점이 나왔다. 그리고 최근 페이지는 당연히 낮은 점수다.</p>\n<p>이제 <a href=\"https://witch.work/posts/binary-search\">로그들을 이분탐색해서 어디서부터 성능이 떨어졌는지 찾겠다.</a> 알고리즘은 부끄럽지만 도움이 된다. 어느 시점부터 total blocking time이 높아지는지 찾아보자.</p>\n<p>추적해본 결과 뭔가 <code>tagFilter</code> 컴포넌트가 들어가면서 문제가 생긴 것 같다. 그럼 어떤 게 문제가 된 걸까? 처음에는 이 컴포넌트에 쓰이는 <code>tagList</code>배열을 만드는 과정이 문제인 줄 알았다. 이 배열이 매번 새로 만들어지면서 글 목록을 훑게 되고 거기서 성능 저하가 발생하는 거라고 생각한 것이다.</p>\n<pre><code class=\"language-ts\">// 문제로 추정했던 코드\nexport const tagList: string[]=['All', ...getAllPostTags(),];\n</code></pre>\n<p>하지만 이를 당장 어떻게 고쳐야 성능 저하가 안 될지는 생각나지 않았다. 나중에 알고 보니 이게 정말 문제인 건 맞았고 이후 섹션에서 어떻게 고친지 소개할 것이다.</p>\n<p>그럼 <code>tagFilter</code>가 문제인 것은 맞을까? 내 사이트이기에 마음대로 해볼 수 있는 것은 이럴 때 해당 컴포넌트를 아예 없애 볼 수도 있다는 것이다. 한번 모든 페이지에서 <code>tagFilter</code>를 삭제해 보고 다시 Lighthouse 점수를 찍어보자.</p>\n<p><img src=\"/static/lighthouse-without-tagfilter-540b9143.png\" alt=\"태그 필터가 없을 때의 lighthouse 점수\"></p>\n<p><code>tagFilter</code> 네 이놈! 하지만 이 컴포넌트는 말이 태그필터지 사실 각 태그별 분류 페이지로 가는 링크를 모아 놓은 컴포넌트일 뿐이다. 내부 요소들도 빌드 시에 완벽하게 생성할 수 있기 때문에 <code>tagFilter</code> 컴포넌트의 존재 자체가 성능을 저하시킬 리는 없다.</p>\n<h2>4.2. 개발자 도구와 함께 분석</h2>\n<p>그럼 정말로 문제는 무엇일까? 디버깅 방법이 컴포넌트 뺐다꼈다만 있는 건 아니니까 여러 시도를 해보자. 먼저 태그 필터를 다시 사이트에 장착하고 lighthouse 측정을 해보자.</p>\n<p>Lighthouse 점수 탭에 들어가 보면 친절하게 진단을 알려준다.</p>\n<p><img src=\"/static/lighthouse-diagnostics-096951bb.png\" alt=\"lighthouse 진단 결과\"></p>\n<p>여기서 Reduce initial server response time은 lighthouse 점수가 잘 뜰 때에도 가끔씩은 길게 나오던 부분이다. 게다가 지금 서버는 Vercel에서 돌아가고 있지 않은가? 홈서버라도 돌리지 않는 이상 이 속도를 올릴 방법은 없다. 또한 태그 필터와도 전혀 관련없다.</p>\n<p>그리고 Reduce unused JavaScript에서 지적하고 있는 코드는 구글 태그 매니저의 코드이다. 따라서 이 opportunities 부분에서는 문제될 만한 게 없다.</p>\n<p>lighthouse의 진단에서는 Minimize main-thread work 그리고 Reduce JavaScript execution time 이라는 진단을 내리고 있는데 main-thread work에 대한 분석을 보면 스크립트 분석, 파싱, 컴파일이 차지하는 시간이 대부분이다. 따라서 Javascript 실행 시간이 핵심 문제다.</p>\n<p>그래서 실행되고 있는 청크 파일을 봤더니 어디선가 문제가 생겼는지 <code>allDocument</code>에 들어가 있을 내용이 <code>TagFilter</code>컴포넌트가 들어 있는 페이지의 JS 파일에 모두 들어가 있었다. 시간을 들여 코드의 구조를 조금이나마 분석해 보니 심지어 실용적으로 쓰이는 코드도 아니었다.</p>\n<p>현실적으로 nextjs의 빌드 로직을 모두 알 수 없으니, 하나하나 <code>tagFilter</code>관련 코드들을 실험해 보면서 어떻게 되는지 보았다. nextJS에서 계속 빌드를 돌려가면서 찾아보았다.</p>\n<h2>4.3. 다양한 시도</h2>\n<p><a href=\"https://stackoverflow.com/questions/74293043/how-can-i-stop-next-js-from-loading-other-chunks-from-another-page\">next/link의 링크는 링크 URL을 프리페칭한다는 이야기가 있어서 그걸 의심해보았으나 아니었다. 아예 링크 컴포넌트를 빼도 TagFilter 컴포넌트의 포함은 성능에 영향을 미쳤다.</a></p>\n<p>또한 모든 글들의 태그를 추출하는 <code>getAllPostTags</code>함수도 의심해 보았으나 해당 함수는 태그 필터 컴포넌트 이외의 다른 곳에서도 이미 잘 쓰이고 있고 전혀 성능 저하를 일으키지 않았다. 그리고 이 함수 대신 정적으로 태그 리스트를 생성해 주어도 성능 저하는 마찬가지였다.</p>\n<p><a href=\"https://yceffort.kr/2021/07/deep-dive-to-export\">그럼 아예 tagList 배열을 새로운 파일에 넣어 주면 어떨까? export된 변수는 참조처럼 동작하기 때문에 매번 import할 때마다 새로 만들어지지는 않을 것이다.</a></p>\n<pre><code class=\"language-ts\">// src/utils/postTagArray.ts 와 같이 만들어 보는 것이다.\nexport const tagList: string[]=['All', ...getAllPostTags(),];\n</code></pre>\n<p>하지만 이렇게 해도 소용없었다. 좀더 시간을 들여 고민해 보았다.</p>\n<h2>4.4. 해결</h2>\n<p>이런 생각은 어떨까? <a href=\"https://witch.work/posts/import-and-require\">ESM은 빌드 시점에 정적으로 모듈 그래프를 구성한다.</a> 그러면 위와 같이 <code>tagList</code>를 참조하는 쪽에서는 <code>getAllPostTags()</code>의 존재도 모듈 그래프를 통해 알게 된다. 그리고 <code>getAllPostTags()</code>에서는 전체 글을 불러오는 <code>getSortedPosts()</code>함수를 사용한다.</p>\n<pre><code class=\"language-ts\">// src/utils/postTags.ts - 원리는 같지만 약간 수정되었다.\nexport const getAllPostTags = (): string[] => {\n  const allTags=new Set&#x3C;string>(getSortedPosts().map((post: DocumentTypes)=>post.tags).flat());\n  return Array.from(allTags);\n};\n</code></pre>\n<p>그러면 최대한 정적으로 모든 것을 해결하려고 하는 듯한 nextJS 번들러는 이렇게 콜 체인에 들어 있는 모든 함수들의 결과를 같이 번들링해서 매번 호출하는 대신 그 결과를 언제든 쓸 수 있도록 할 수 있도록 하지 않을까?</p>\n<p>이걸 약간이나마 검증해 보기 위해 새로운 파일을 만들어서 <code>tagList</code>에 <code>getAllPostTags</code>를 사용하지 않고 태그들을 직접 넣었더니 성능의 저하가 일어나지 않는 것을 확인할 수 있었다.</p>\n<p>그럼 어떻게 해야 할까? 일단 태그 필터는 죄가 없는 것을 확인했으니 원상복구한다. <a href=\"https://witch.work/posts/blog-remake-14#5.2.-%ED%83%9C%EA%B7%B8%EB%A5%BC-%ED%86%B5%ED%95%9C-%ED%95%84%ED%84%B0%EB%A7%81\">이전에 태그 필터를 만들 때 썼던 글에 코드가 남아 있다.</a>(물론 github에서 가져올 수도 있는데 귀찮으니까...)</p>\n<p>그리고 이런 태그 리스트는 어디에 따로 넣어 놓는 게 아니라 <code>getStaticProps</code>에서 그냥 정적으로 만들어 주도록 한다.</p>\n<pre><code class=\"language-tsx\">export const getStaticProps: GetStaticProps = async () => {\n  /* 앞부분 코드 생략. 대충 페이지에 맞는 포스트 가져오는 코드 */\n\n  const allTags=['All', ...getAllPostTags()];\n\n  return {\n    props: {\n      allTags,\n      pagePosts:pagePostsWithThumbnail,\n      totalPostNumber,\n      currentPage:FIRST_PAGE,\n    },\n    revalidate: 60 * 60 * 24, // &#x3C;--- ISR cache: once a day\n  };\n};\n</code></pre>\n<p>이때 이전 글에서 만들었던 <code>makeTagURL</code>함수의 경우에도 그대로 <code>postTags.ts</code>에 놔두면 이 함수를 <code>TagFilter</code>컴포넌트의 props로 쓰는 순간 <code>postTags.ts</code>에 같이 들어 있는 <code>getAllPostTags</code>로 인해 <code>getSortedPosts</code>의 결과가 같이 번들링되기 때문에 <code>src/utils/makeTagURL.ts</code>에 별도로 분리한다.</p>\n<pre><code class=\"language-ts\">// src/utils/makeTagURL.ts\nexport const makeTagURL = (tag: string): string=>{\n  if (tag==='All') {\n    return '/posts/all';\n  }\n  else {\n    return `/posts/tag/${tag}`;\n  }\n};\n</code></pre>\n<p>코드 스플리팅을 손으로 해주는 최적화라니...뭔가 좀더 좋은 방법이 있겠지만...지금의 나는 이게 한계다.</p>\n<p>아무튼 이렇게 하고 이렇게 만들어진 태그 필터를 각 페이지에 적용하면 된다.</p>\n<pre><code class=\"language-tsx\">&#x3C;TagFilter\n  tags={allTags}\n  selectedTag={'All'}\n  makeTagURL={makeTagURL}\n/>\n</code></pre>\n<p>이 상태에서 배포하고 나서 Lighthouse로 성능을 체크해 보니, 태그 필터를 적용하기 전과 같이 빠른 사이트로 돌아온 것을 볼 수 있었다.</p>\n<p><img src=\"/static/lighthouse-opt-result-0b178bd1.png\" alt=\"최적화 결과\"></p>\n<h1>5. 작은 이미지 최적화</h1>\n<p>아직 우리가 할 수 있는 게 있다. 이미지 캐싱이 안 되어 있는 시크릿 창으로 페이지를 들어가서 lighthouse 검사를 하게 되면 Cumulative Layout Shift 즉 사용자가 보는 레이아웃이 얼마나 바뀌는지를 측정하는 지표가 좀 높게 나온다. 이 지표가 높으면 사용자가 불편함을 느끼고 브라우저 성능도 떨어진다.</p>\n<p>특히 내 블로그에 처음 오는 사람 같은 경우에 이 부분이 치명적이다. CDN에서 받아 오니까 그렇게 느리지는 않을 거라 생각하지만 사이트는 빠르면 빠를수록 좋다.</p>\n<p><img src=\"/static/high-layout-shift-01d147b2.png\" alt=\"high layout shift\"></p>\n<p>여기에 대해 할 수 있는 건 이전에 했던 blur image 제공이 가장 적절하다고 생각된다. 이미지 크기를 <code>next/image</code>의 width, height props를 이용해 사전에 전달하는 방법도 있겠지만 프로젝트 이미지의 aspect ratio를 그대로 보여주는 것이 지금 페이지의 디자인이기 때문에 크기를 하나하나 전달하는 것보다는 blur image를 보여주는 게 편의상으로도, UI에도 좋을 것이다.</p>\n<p>따라서 기존에 만들어져 있던 <code>getBase64ImageUrl</code>함수를 이용해서 다음과 같이 간단하게 프로젝트 이미지의 blurURL을 생성했다.</p>\n<pre><code class=\"language-tsx\">for (const project of projectList) {\n  console.log(project);\n  if (project.image.blurURL) {continue;}\n  project.image.blurURL=await getBase64ImageUrl(project.image.cloudinary);\n}\n</code></pre>\n<p>그리고 이미지에 쓸 blurURL을 함께 전달해 주기 위해 프로젝트 이미지를 보여주는 <code>projectImage</code> 컴포넌트가 이미지를 받는 타입을 변경한다.</p>\n<pre><code class=\"language-tsx\">// src/components/projectCard/image/index.tsx\ninterface ImageSrc{\n  local: string;\n  cloudinary: string;\n  blurURL?: string;\n}\n\nfunction ProjectImage({title, image}: {title: string, image: ImageSrc}) {\n  return (\n    &#x3C;div className={styles.container}>\n      &#x3C;Image\n        className={styles.image}\n        src={image[blogConfig.imageStorage]} \n        alt={`${title} 프로젝트 사진`}\n        width={300}\n        height={300}\n        sizes='(max-width: 768px) 150px, 300px'\n        placeholder={image.blurURL ? 'blur' : 'empty'}\n        blurDataURL={image.blurURL}\n      />\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<p>이렇게 하자 Lighthouse로 측정시 Cumulative Layout Shift가 0.1미만 그러니까 0.07~0.09 정도로 떨어졌다. 물론 trace 등을 보고 렌더링되는 과정을 보니 CDN이 너무 빨라서 그런지 blurURL이 생기기가 무섭게 이미지가 바로 로딩되기 때문에 blurURL 제공으로 인한 layout shift가 엄청나게 커 보이지는 않는다.</p>\n<p>그래도 티끌 모아 태산이라고, 언젠가 이런 게 모여 아주 빠른 블로그를 만들리라 생각하며 작은 최적화를 해보았다.</p>\n<h1>참고</h1>\n<p>next-bundle-analyzer <a href=\"https://velog.io/@leehyunho2001/nextbundle-analyze\">https://velog.io/@leehyunho2001/nextbundle-analyze</a></p>",
    "excerpt": "블로그 만들기 시리즈\n|제목|링크|\n|---|---|\n|1. 기본 세팅|https://witch.work/posts/blog-remake-1|\n|2. 메인 페이지의 HTML 설계|https://witch.work/posts/blog-remake-2|\n|3. 글 상세 페이지의 구조 설계|https://witch.work/posts/blog-remake-3|\n|4. 이미지를 상대 경로로 쓸 수 있도록 하기|https://witch.work/posts/blog-rem",
    "headingTree": [
      {
        "title": "블로그 만들기 시리즈",
        "url": "#블로그-만들기-시리즈",
        "items": []
      },
      {
        "title": "1. 문제 발생",
        "url": "#1-문제-발생",
        "items": []
      },
      {
        "title": "2. 조회수 카운터 오류",
        "url": "#2-조회수-카운터-오류",
        "items": []
      },
      {
        "title": "3. 썸네일 업로드 오류",
        "url": "#3-썸네일-업로드-오류",
        "items": []
      },
      {
        "title": "4. 최적화",
        "url": "#4-최적화",
        "items": [
          {
            "title": "4.1. 원인 분석",
            "url": "#41-원인-분석",
            "items": []
          },
          {
            "title": "4.2. 개발자 도구와 함께 분석",
            "url": "#42-개발자-도구와-함께-분석",
            "items": []
          },
          {
            "title": "4.3. 다양한 시도",
            "url": "#43-다양한-시도",
            "items": []
          },
          {
            "title": "4.4. 해결",
            "url": "#44-해결",
            "items": []
          }
        ]
      },
      {
        "title": "5. 작은 이미지 최적화",
        "url": "#5-작은-이미지-최적화",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 2,
      "wordCount": 450
    },
    "url": "/posts/blog-fix20230808",
    "thumbnail": {
      "local": "/static/current-lighthouse-score-11e04252.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-current-lighthouse-score-11e04252-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAHCAIAAAC6O5sJAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAqUlEQVR4nGP4////gd07dPVUGXgY+JWlrFztlixe8v//f4b///8/fvRo/brVixctWrdu3eFDhy9fuvzu3TuQxPQpE21Ndb79+PH//39Zccm8zCyQjrPnLnJycjMwMHj4hv3//9/R1m5y/0SQxKnTp/fvP/D////37z+8e/f2HgwwnDhxXEVZ6cnjJ////8/IzYqJjf0PBgwHD+zXVlOFcNasX7tz106IBAD3CnMM3bwgNgAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "blog-cloudflare-proxy",
    "title": "블로그 개선 - Bandwidth 절감",
    "date": "2023-02-09T06:00:00Z",
    "description": "Cloudflare를 이용한 Bandwidth 절감",
    "tags": [
      "blog",
      "web"
    ],
    "html": "<h1>1. Bandwidth 한도 초과</h1>\n<p>현재 이 블로그는 Vercel을 통해 정적 페이지로 배포되어 있다. 그런데 최근에 내 블로그가 자원을 너무 많이 쓰고 있다는 메일이 오고 있다.</p>\n<p><img src=\"/static/vercel_mail-1acc7e09.png\" alt=\"vercel_mail\"></p>\n<p>내 블로그에서 자원을 많이 쓰고 있다고? 싶어서 dashboard에 들어갔다.</p>\n<p>내 블로그 프로젝트에서 Bandwidth를 확인해보니 109GB정도나 되는 데이터를 주고받고 있었다.</p>\n<p><img src=\"/static/bandwidth-86cf6498.png\" alt=\"bandwidth\"></p>\n<p>bandwidth는 내가 배포한 사이트가 주고받은 데이터의 양을 뜻한다. <a href=\"https://vercel.com/docs/concepts/limits/usage#bandwidth\">출처</a> 내 블로그 bandwidth의 대부분은 outgoing이었는데 이는 내 사이트가 유저에게 보낸 데이터의 양을 뜻한다. 하루에 약 3기가의 데이터가 사용자들에게 전달되고 있었다.</p>\n<p>그리고 하루에 약 13,000~15,000개의 요청이 사이트에 전달되고 있었다. 블로그를 나름 열심히 한다고 했지만 이 정도의 요청을 받을 곳은 아닌데, 뭔가 문제가 있는 듯 했다.</p>\n<p><img src=\"/static/vercel_request-d93dd5bd.png\" alt=\"request\"></p>\n<p>하지만 로그도 볼 수 없고 뭐 할 수 있는 게 없어서 일단 bandwidth를 줄인 다음 구글 애널리틱스를 달아서 이후의 분석을 진행하려고 한다.</p>\n<p><a href=\"https://medium.com/@capJavert/save-bandwidth-on-vercel-with-cloudflare-462bec444865\">이 글</a>을 참고하여 bandwidth를 줄여보자.</p>\n<h1>2. 문제</h1>\n<p>위에서 Request를 보면 무려 95.6%가 캐싱된 요청이고 4.4%가 캐시되지 않은 요청이다.</p>\n<p>이 캐시는 <a href=\"https://vercel.com/docs/concepts/edge-network/overview#caching\">Vercel Edge Network</a>라는 곳에서 관리하는데 배포된 내 사이트와 인터넷 사이에 있다. CDN이라고 생각하면 된다.</p>\n<p>그리고 이 Edge Network는 캐싱 역할도 하여 만약 유저가 요청한 데이터가 Edge에 저장되어 있다면 바로 전달해주고, 저장되어 있지 않다면 내 사이트로 요청을 보내고 받은 데이터를 Edge에 저장한다.</p>\n<p>아무튼 내 블로그에 오는 요청 중 95.6%가 Vercel Edge Network에 저장되어 있는데, 문제는 Vercel이 캐싱된 요청이든 캐싱되지 않은 요청이든 무조건 Bandwidth에 포함시킨다는 것이다.</p>\n<h1>3. Cloudfare를 프록시로 사용하기</h1>\n<p>그런데 Cloudflare에서는 더 관대한 프리티어를 제공하고 있었다. 사실상 Bandwidth 제한이 없으며 특별히 이슈가 발생할 정도의 트래픽이 발생하면 연락이 온다고 한다. <a href=\"https://community.cloudflare.com/t/cdn-bandwidth-limits/300965/3\">20TB정도 사용해도 연락이 안 올 거라고 한다.</a></p>\n<p>따라서 Vercel 배포의 프록시로 cloudflare를 사용하기로 했다. <a href=\"https://developers.cloudflare.com/fundamentals/get-started/setup/\">튜토리얼 페이지</a>에서 모든 것을 친절하게 알려주고 있었다.</p>\n<h2>3.1. 회원가입</h2>\n<p><a href=\"https://dash.cloudflare.com/sign-up\">회원가입 페이지</a>에서 회원가입을 하자.</p>\n<h2>3.2. 사이트 추가하기</h2>\n<p>나는 witch.work 도메인을 가지고 있다. 먼저 이 도메인의 네임서버를 cloudfare로 바꿔준다. <a href=\"https://developers.cloudflare.com/fundamentals/get-started/setup/add-site/\">여기</a>서 시키는 대로 했다.</p>\n<p>먼저 dashboard에서 사이트를 추가한다.</p>\n<p><img src=\"/static/dashboard-a4fa90e7.png\" alt=\"dashboard\"></p>\n<p>Add site를 누르고 내 페이지의 루트 도메인(나같은 경우 witch.work)를 입력한다. 그리고 plan을 고르라고 하는데 나는 돈이 없으므로 Free를 선택했다.</p>\n<p>그러면 자동으로 Cloudfare가 내 도메인의 DNS 레코드를 검사한다. 대충 루트 도메인과 서브도메인이 다 나오면 continue한다. 수동으로 DNS 레코드를 더해 줘야 할 때도 있다는데 나는 잘 되어서 그냥 했다.</p>\n<h2>3.3. 네임서버 변경</h2>\n<p>나는 goDaddy에서 도메인을 구입해서 사용하고 있으므로 goDaddy에서 네임서버를 변경해 주었다.</p>\n<p><img src=\"/static/godaddy_mypage-54a5d6e1.png\" alt=\"goDaddymy\"></p>\n<p>여기서 DNS에 들어가서 스크롤을 내리면 네임서버를 변경할 수 있다. cloudflare에서 제공하는 네임서버를 입력하고 저장한다.</p>\n<p>시간이 좀 걸린다. 한 15분 정도 기다리자 내 사이트가 cloudflare Free plan에 잘 들어갔다는 메일이 왔다.</p>\n<p>그 다음 <a href=\"https://vercel.com/guides/using-cloudflare-with-vercel#with-proxy\">여기</a>에서 시키는 대로, cloudflare dashboard에서 SSL/TLS 설정에 들어가서 overview에서 ssl/tls encryption을 full로 바꿔준다.</p>\n<p>내가 본 글에서는 캐시 설정까지 하는데, 이 캐시 설정은 그새 Cloudflare에서 유료 제공으로 바뀌었다..따라서 프록시만 설정했다. 이게 Bandwidth 줄이기에 도움이 되는지는 추적관찰 예정이다.</p>\n<h1>참고</h1>\n<p><a href=\"https://vercel.com/guides/lower-usage#bandwidth-usage\">https://vercel.com/guides/lower-usage#bandwidth-usage</a></p>\n<p><a href=\"https://vercel.com/guides/using-cloudflare-with-vercel#with-proxy\">https://vercel.com/guides/using-cloudflare-with-vercel#with-proxy</a></p>\n<p><a href=\"https://medium.com/@capJavert/save-bandwidth-on-vercel-with-cloudflare-462bec444865\">https://medium.com/@capJavert/save-bandwidth-on-vercel-with-cloudflare-462bec444865</a></p>",
    "excerpt": "1. Bandwidth 한도 초과\n현재 이 블로그는 Vercel을 통해 정적 페이지로 배포되어 있다. 그런데 최근에 내 블로그가 자원을 너무 많이 쓰고 있다는 메일이 오고 있다.\n\n내 블로그에서 자원을 많이 쓰고 있다고? 싶어서 dashboard에 들어갔다.\n내 블로그 프로젝트에서 Bandwidth를 확인해보니 109GB정도나 되는 데이터를 주고받고 있었다.\n\nbandwidth는 내가 배포한 사이트가 주고받은 데이터의 양을 뜻한다. 출처 내 블로그 bandwid",
    "headingTree": [
      {
        "title": "1. Bandwidth 한도 초과",
        "url": "#1-bandwidth-한도-초과",
        "items": []
      },
      {
        "title": "2. 문제",
        "url": "#2-문제",
        "items": []
      },
      {
        "title": "3. Cloudfare를 프록시로 사용하기",
        "url": "#3-cloudfare를-프록시로-사용하기",
        "items": [
          {
            "title": "3.1. 회원가입",
            "url": "#31-회원가입",
            "items": []
          },
          {
            "title": "3.2. 사이트 추가하기",
            "url": "#32-사이트-추가하기",
            "items": []
          },
          {
            "title": "3.3. 네임서버 변경",
            "url": "#33-네임서버-변경",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 91
    },
    "url": "/posts/blog-cloudflare-proxy",
    "thumbnail": {
      "local": "/static/vercel_mail-1acc7e09.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-vercel_mail-1acc7e09-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAIAAABLbSncAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAtUlEQVR4nGP4////t2/f/v//HxYWZmlpCecy/AeDtrY2bW1tCQmJtrY2sNx3hrdg8A0G3r59C1HKUFZWxsDA4OHh4eDgYGlpaWVl7erudfnyFYa+vj4jM+uYuCRTE1N3d3dfP/+o2IRHjx8zzJ8/Pz4+obqmurS0uK6uLi8vr7S0+PmzZyAdujo6U6ZOmz57Xk9vX11dXU1t7ZMnT0ASEhISFpaWQaGRNbV1GRkZeXl5ly5dAgBZmG71aCnLEgAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "blog-home-server",
    "title": "홈 서버로 블로그 배포하기 - proxmox, pfsense 초기세팅",
    "date": "2023-09-18T04:00:00Z",
    "description": "홈 서버를 세팅해보자",
    "tags": [
      "blog"
    ],
    "html": "<blockquote>\n<p>서버 구축은 처음이고 저보다 조금 먼저 서버를 구축한 <a href=\"https://vulcan.site/\">불칸</a>님의 많은 도움을 받아가며 만들어진 글이라 많이 부족할 수 있습니다. 틀린 부분이 있다면 댓글로 알려주시면 감사하겠습니다.</p>\n</blockquote>\n<blockquote>\n<p>이 글을 보고 홈서버를 세팅하려는 분이 계실지도 모르겠습니다. 제가 알고 있는 부분의 지식은 많은 생략이 있었기 때문에 네트워크에 대한 기본적인 지식은 가지고 있어야 어느 정도 이해하며 글을 읽으실 수 있을 것이라고 알려드립니다.</p>\n</blockquote>\n<h1>1. 시작</h1>\n<p>이 블로그는 원래 Vercel로 배포되고 있었다. 그런데 직접 홈서버를 세팅해서 블로그를 배포하고 있는 <a href=\"https://vulcan.site/\">불칸</a>님과 교류하다 보니 나도 직접 서버를 세팅해서 블로그를 배포해 보고 싶다는 생각을 하게 되었다.</p>\n<p>그러다가 마침 괜찮은 가성비 서버를 추천받아서 홈 서버를 세팅해 보았다. 개인 서버를 먼저 구축한 사람이 도와주려고 기다리고 있는데 이런 기회를 놓칠 수는 없다. 그렇게 빈털터리가 되었다.</p>\n<p>아무튼 그 과정을 블로그에 작성할 것인데 이를 위해 구매한 물품들은 다음과 같다.</p>\n<p><a href=\"https://ko.aliexpress.com/item/1005005892722060.html?spm=a2g0o.order_list.order_list_main.5.1818140fxGKlvQ&#x26;gatewayAdapt=glo2kor\">인텔의 N100 i226-V(알리익스프레스 링크)</a>를 알리익스프레스에서 약 17만원에 구매하였다.</p>\n<p><img src=\"/static/n100i226v-ceb19602.webp\" alt=\"N100 i226-v 이미지\"></p>\n<p><a href=\"https://www.coupang.com/vp/products/6091702345?vendorItemId=73680480457&#x26;sourceType=MyCoupang_my_orders_list_product_title&#x26;isAddedCart=\">SK하이닉스 GOLD P31 NVMe SSD 1TB(쿠팡 링크)</a>를 약 10만원에 쿠팡에서 구매하였다.</p>\n<p><a href=\"https://prod.danawa.com/info/?pcode=17666249\">삼성전자 노트북 DDR5-4800 (16GB)</a>를 다나와 최저가비교에서 약 5만원에 구매하였다. 당시 최저가인 곳에서 사서 어디서 샀는지는 잘 기억나지 않는다. 흔한 모델이니까 어디서든 구매하면 될 거라고 생각한다.</p>\n<p>어쨌든 중국에서 먼 길을 온 서버가 도착했다. 드라이버로 하판을 떼고 해당 부품들을 장착해 주었다.</p>\n<p><img src=\"/static/server-internal-f1832351.jpeg\" alt=\"서버 내부\"></p>\n<p>또 집의 공유기가 너무 오래된 모델이라 그런지 DHCP 설정을 끌 수 없는 등의 문제가 있었다. 그래서 iptime 유무선 공유기, 정확히는 <a href=\"https://www.coupang.com/vp/products/7414788638?itemId=19220386254&#x26;vendorItemId=86771481707&#x26;q=iptime+%EA%B3%B5%EC%9C%A0%EA%B8%B0&#x26;itemsCount=36&#x26;searchId=2fdb4a1230f247e896ce44948cd8e58a&#x26;rank=0&#x26;isAddedCart=\">ipTIME A2003NS-MU(쿠팡 링크)</a>을 구매하였다. 이건 동봉된 설명서를 보니 iptime 설치 도우미 앱이 있어서 간단히 설치할 수 있었다.</p>\n<h1>2. proxmox 설치</h1>\n<p>proxmox와 pfsense 기반으로 서버를 세팅할 것이다. 먼저 proxmox를 설치하자.</p>\n<h2>2.1. proxmox란?</h2>\n<p>서버는 보통 ubuntu를 기반으로 한다. 따라서 웹 서버만 쓴다면 우분투만 사용해도 된다. 라즈베리 파이에 우분투를 깔아서 돌아가고 있는 간단한 웹 서버들도 꽤 많다. 가령 <a href=\"https://blog.yuni.dev/\">Yun님의 블로그</a>라거나.</p>\n<p>하지만 그렇게 하면 웹 서버를 돌리는 것 외에 아무것도 하지 못하게 된다. 만약 내가 블로그를 돌리면서 마인크래프트나 팩토리오 서버도 열고 싶다면? 우분투만 깔려 있다면 어렵다.</p>\n<p>그럴 때 사용할 수 있는 선택지 중 가장 대표적인 건 virtualbox같은 가상 머신을 사용하는 것이다. 호스트 OS에 하이퍼바이저를 올리고 그 위에 여러 개의 게스트 OS를 올리는 식이다. 이렇게 하면 하나의 OS에서 여러 개의 운영체제를 올릴 수 있다.</p>\n<p>보통은 컴퓨터가 1대이고 그걸 서버만을 위해서 돌릴 수 없기 때문에, 컴퓨터 하나에서 여러 개의 운영체제를 돌리기 위해서는 가상 머신은 꽤 합리적인 선택이다. 하지만 호스트 OS위에 하이퍼바이저가 올라가고 그 위에 또 게스트 OS가 올라가는 것이기 때문에 당연히 최적화에는 그렇게 좋지 않다.</p>\n<p>이런 가상 머신과 흔히 비교되는 게 도커인데 이는 소프트웨어를 컨테이너로 패키징해서 독립된 프로세스에서 실행시키고, 이 프로세스가 호스트OS의 커널 자원을 나눠 쓸 수 있도록 한다.</p>\n<p>호스트 OS의 커널 자원을 사용하므로 하이퍼바이저 기반의 가상 머신을 사용하는 것보다 효율적이다. 하지만 결국 커널은 호스트OS 기반이기 때문에 완전히 다른 운영체제 커널을 사용할 수는 없다.</p>\n<p><img src=\"/static/vm-and-docker-6aac3cde.jpeg\" alt=\"vm과 도커\"></p>\n<p>이 proxmox는 그런 부분을 해결해 준다. 근본은 이런 생각이다.</p>\n<pre><code>가상화만을 목적으로 한다면, 호스트OS와 가상화를 위한 하이퍼바이저를 같이 돌리면 안 될까?\n</code></pre>\n<p>이런 생각을 실현한 게 proxmox이다. proxmox는 베어메탈 형식으로 하드웨어 바로 위에서 구동되며 호스트 OS의 커널을 일정 부분 격리하여 새로운 OS를 위한 공간을 만든다. proxmox를 사용해 보면 실제로 이런 공간을 얼마나 할당할지도 직접 지정할 수 있다.</p>\n<p>위의 VM 구조를 나타낸 사진에서 하이퍼바이저 층을 거의 없앤 것이라고 볼 수 있겠다. 그래서 가상 머신을 돌리는데 있어서 더 효율적이고 도커에 비해 진짜 다른 OS의 커널을 이용해 서버를 돌릴 수 있다는 이점이 있다. 또한 proxmox는 웹 UI도 제공하며 이를 통해 가상 머신을 관리할 수 있다.</p>\n<p>이 분야의 초보가 들은 대로 간략히 써본 것이라 더 자세한 이야기는 <a href=\"https://it-svr.com/proxmox-ve-opeunsoseu-gasanghwa-osran-mueosinga/\">Proxmox VE: 오픈소스 가상화 OS란 무엇인가</a>를 참고하면 볼 수 있다. 그리고 <a href=\"https://www.redhat.com/ko/topics/virtualization/what-is-a-hypervisor\">레드햇의 하이퍼바이저 설명 문서</a>도 볼 만 하다.</p>\n<h2>2.2. USB 굽기</h2>\n<p><a href=\"https://www.proxmox.com/en/downloads\">proxmox 공식 다운로드 페이지</a>에서 iso 파일을 다운로드 받는다. 그러고 나면 설치 USB를 만들어 주어야 한다. 문구점에서 흔하게 파는 Sandisk USB가 있어서 사용했다.</p>\n<p>참고로 이 작업을 하기 전에 USB를 포맷해 줘야 한다. <a href=\"https://100sang.net/143\">맥 OS에서 USB를 포맷하는 법</a>을 따라했다.</p>\n<p>그리고 USB를 구우려고 했는데, 나는 맥os라서 iso 파일을 USB로 바로 구울 수 없다. 다행히 이를 간단히 처리해 주는 balenaEtcher라는 프로그램이 있었다. 이를 사용하면 USB를 간단히 proxmox 부팅 USB로 만들 수 있다.</p>\n<p><a href=\"https://tttap.tistory.com/223\">맥 USB .iso, .img 이미지 부팅 설치 파일 만들기</a>를 참고하여 USB를 만들었다.</p>\n<h2>2.3. proxmox 설치</h2>\n<p>usb를 만들었으면 서버에 설치하자. USB를 서버에 꽂고 부팅시켜 주면 proxmox 설치 화면이 나온다. 어차피 이렇게 한번 설치하고 실행시키고 나면 모니터를 쓸 일은 거의 없기 때문에, 나는 집에 안 쓰는 모니터를 잠시 연결하여 설치를 진행했다.</p>\n<p>설치는 매우 간단하다. <a href=\"https://nad4.tistory.com/entry/Proxmox-%EC%84%A4%EC%B9%98-%EB%B0%8F-%EC%B4%88%EA%B8%B0-%ED%95%84%EC%88%98-%EC%84%A4%EC%A0%95\">이를 잘 설명해둔 블로그를 보고 그대로 따라하였다.</a></p>\n<p>이렇게 설치하고 나면 proxmox가 설치된다. 이제 proxmox를 사용할 수 있다.</p>\n<p>설치가 끝나면 proxmox의 웹 UI에 접속할 수 있다. 참고로 기본 계정명은 <code>root</code>이고 비밀번호는 설치할 때 설정한 것이다. 기본 계정명을 몰라서 처음에 고생을 많이 했다.</p>\n<h3>2.3.1. 트러블슈팅</h3>\n<p>그런데 문제가 발생했다. 분명 <code>192.168.219.154:8006</code>으로 들어가면 proxmox 웹 UI가 뜬다고 해서 들어갔는데 들어가지지 않았다.</p>\n<p>알고 보니 내가 기존에 쓰던 공유기의 DHCP는 <code>192.168.219.1</code> 게이트웨이 기반으로 IP가 할당되었는데 새로 산 iptime 공유기는 <code>192.168.0.1</code>게이트웨이에서 IP가 동적 할당되었다.</p>\n<p>따라서 이렇게 동적 할당되는 주소를 바꿔 줘야 한다.</p>\n<pre><code class=\"language-bash\">nano etc/network/interfaces\n</code></pre>\n<p>그러면 잘 찾아보면 address, gateway라고 되어 있는 부분이 있다. 이를 편집하자.</p>\n<pre><code class=\"language-bash\">auto vmbr0\niface vmbr0 inet static\n        address 192.168.219.154/24 -> 192.168.0.3/24 로 수정\n        gateway 192.168.219.1 -> 192.168.0.1 로 수정\n        bridge-ports enp1s0\n        bridge-stp off\n        bridge-fd 0\n# 이하 생략\n</code></pre>\n<p>그리고 다음 명령어를 입력한다.</p>\n<pre><code class=\"language-bash\">service networking restart\nreboot\n</code></pre>\n<p>그러면 커맨드 그대로 네트워킹이 재시작되고 서버가 리부트된다. 이렇게 해도 서버 화면 상단에 뜨는 ip는 안 바뀔 수 있다. 나도 그랬다. 그러면 상단에 뜨는 ip는 무시하고 <code>ip a</code>를 입력해서 나오는 ip(나 같은 경우 <code>192.168.0.3:8006</code>이었다)로 접속하면 로그인을 하라는 창이 뜬다.</p>\n<p><img src=\"/static/proxmox-login-284fc198.png\" alt=\"proxmox 로그인 창\"></p>\n<p>여기서도 username은 <code>root</code>(물론 변경할 수는 있지만 기본 이름이 이렇다), password는 설정한 것을 입력하면 된다. 그러면 <code>You do not have a valid subscription for this server</code>라면서 구독이 없다는 메시지가 뜨는데 유료 구독은 필수가 아니므로 무시하고 <code>OK</code>를 누른다.</p>\n<p><img src=\"/static/proxmox-ui-first-9779d6ed.png\" alt=\"proxmox 웹 UI\"></p>\n<h1>3. proxmox 웹 UI 가이드</h1>\n<p>각 메뉴에 대해 아주 간단히만 적어놓는다.</p>\n<h2>3.1. 맨 왼쪽 메뉴</h2>\n<p><img src=\"/static/left-menu-3c43966a.png\" alt=\"맨 왼쪽 메뉴\"></p>\n<p>왼쪽 메뉴를 보면 Datacenter와 그 아래 witch라는 게 있다.</p>\n<p>하드웨어와 관련된 부분은 Datacenter에 있고 여기서 모든 노드들을 전체적으로 볼 수 있다. 그 아래 있는 것은 데이터센터에 연관된 노드들이다.</p>\n<p>그 아래 보이는 witch는 내가 생성한 노드 이름이다. 만약 노드를 더 생성할 시 그 아래에 모든 노드 이름이 생길 것이다.</p>\n<h2>3.2. Datacenter 메뉴</h2>\n<p>여기는 하드웨어와 관련된 설정들이 있는 곳이다.</p>\n<p><img src=\"/static/datacenter-menu-835667cc.png\" alt=\"Datacenter 메뉴\"></p>\n<p>search에서는 node(여기서는 내 서버)와 하드웨어에 관련된 정보들을 볼 수 있다. 서버가 더 있다면 여기서 모든 서버들의 정보를 볼 수 있다.</p>\n<p>summary에서는 하드, 메모리 사용량과 같은 정보를 간략히 제공한다.</p>\n<p>Notes는 메모 같은 느낌인데 쓸 일 없다고 알고 있다.</p>\n<p>cluster, ceph는 클러스터링 같은 걸 할 때 쓴다고 하는데 나는 서버가 하나이기 때문에 쓸 일이 없다. 그리고 ceph 메뉴에 들어가면 ceph가 설치되어 있지 않다고 하며 설치하라고 하는 메시지가 뜨는데 여기서 설치하면 매우 귀찮은 설정들이 (강제로)기다리고 있으므로 사용할 게 아니라면 절대 누르지 말라는 조언이 있었다.</p>\n<p>options는 말 그대로 옵션 창. storage는 저장 장치를 관리하는 곳이다. 여기서 보이는 local-lvm은 가상 머신을 의미한다. 하드 용량은 local, local-lvm에서 알아서 잘 조절하니까 그렇게 신경쓰지 않아도 된다.</p>\n<p>backup은 백업 관련 설정이다. proxmox는 컨테이너 정보 백업 등 좋은 백업 기능들을 제공하기에 이를 사용하면 좋다. 하루에 한번씩 자동으로 백업을 뜨는 등의 설정도 가능하다고 한다.</p>\n<p>replication은 서버가 2대 이상이면 사용 가능한 기능이고 permission은 말 그대로 권한 설정이다.</p>\n<p>HA는 high availability의 약자로 고가용성을 의미한다. 서버가 2대 이상일 때 사용 가능하다.</p>\n<p>ACME는 ACME SSL 인증서 관련 기능이다.</p>\n<p>여기의 Firewall은 외부에서 proxmox 서버로 접속할 때가 아니라 가상 머신들 간의 방화벽 설정을 하는 곳이다.</p>\n<p>metric server는 Grafana와 같은 모니터링 툴 같은 걸 쓸 때 사용하는 기능인데 나는 사용할 일이 지금은 없다.</p>\n<h2>3.3. node(witch) 메뉴</h2>\n<p>왼쪽 메뉴에서 <code>Datacenter</code>아래에는 내 서버 노드가 위치하고 있다. 여기서도 몇 가지 설정을 할 수 있다.</p>\n<p><img src=\"/static/witch-node-menu-86ecb331.png\" alt=\"witch node 메뉴\"></p>\n<p>여기에서도 search, summary, notes는 Datacenter 메뉴와 같다. summary에서 노드의 정보를 좀더 자세히 볼 수 있다는 정도?</p>\n<p>또한 shell에서는 서버 노드 내부의 shell을 다룰 수 있다.</p>\n<p>system 메뉴에서는 다양한 설정을 할 수 있는데 Network 메뉴 외에는 디폴트 설정에서 건들 게 별로 없다.</p>\n<p>Updates에서는 패키지 업데이트가 가능하고, Firewall에서는 node 내부 통신에서의 firewall 설정을 할 수 있다.</p>\n<p>Disks 메뉴에서는 node 내부의 디스크를 관리할 수 있고 하드 디스크의 상태를 알려준다. 그런데 여기 보면 <code>S.M.A.R.T.</code>라는 항목이 있다. 이는 <a href=\"https://ko.wikipedia.org/wiki/S.M.A.R.T.\">자가 진단, 분석, 보고 기술</a>인데 이게 PASSED가 아니면 정말 큰일난 거니까 당장 백업해야 한다. 이때 끄지 말고 백업부터 해야 한다. 또한 LVM도 오류가 있으면 큰일이니 백업해야 한다. 보통 오류가 누적된 거라서...</p>\n<p>그리고 여기서도 Ceph, replication은 클러스터링할 게 아니고 서버도 1대라서 사용하지 않는다.</p>\n<h1>4. proxmox 설정</h1>\n<p>proxmox 설정을 시작한다. 노드 메뉴에서 System - Network 설정으로 들어간다. 그러면 다음과 같은 화면이 뜰 것이다.</p>\n<p><img src=\"/static/network-start-b76e29af.png\" alt=\"network 첫 진입\"></p>\n<p><code>enp1s0</code>과 같은 이름들이 보이는데 이는 실제 네트워크 디바이스에 있는 이더넷 포트를 뜻한다. 나는 이더넷 포트가 4개 있어서 <code>enp1s0</code>, <code>enp2s0</code>, <code>enp3s0</code>, <code>enp4s0</code>이 보인다.</p>\n<p>그리고 상단에 Create 버튼을 눌러서 리눅스 브릿지를 생성한다. 자동으로 <code>vmbr0</code>이라는 이름이 붙는다. 리눅스 브릿지는 하나의 물리 포트를 여러 개로 나눠 줄 수 있는 역할을 하며 리눅스 브릿지로 들어오는 패킷들을 어떤 물리적인 랜선 포트로 보낼지 결정한다.</p>\n<p>처음 만드는 브릿지인 <code>vmbr0</code>은 proxmox에 할당해 줄 것이므로 proxmox에 사용할 내부 IP를 할당해 준다. 그리고 여기에 쓸 이더넷 포트에 연결해 준다. 나는 첫번째 포트인 <code>enp1s0</code>을 proxmox에 할당할 것이다.</p>\n<p><img src=\"/static/make-bridge-d3a2ba38.png\" alt=\"브릿지 만들기\"></p>\n<p>물론 내가 가진 장치에는 이더넷 포트가 4개나 있으므로 굳이 리눅스 브릿지를 쓸 필요는 없다. 하지만 이렇게 리눅스 브릿지를 만들어 주면 이더넷 포트를 여러 컨테이너가 나눠 쓸 수 있다는 장점이 있고 추후에 팩토리오 서버라도 몇 개 운영할지 모르므로 이렇게 해주자.</p>\n<p>또한 만들 때 MTU도 설정할 수 있는데 이는 NAS 같은 걸 구축할 때 건드릴 수도 있지만 여기서는 그냥 기본값으로 놓아도 된다.</p>\n<p>이외에도 각각 WAN, LAN을 위한 브릿지 2개를 더 만들고 각각 다른 이더넷 포트에 연결해준다. 그러면 다음과 같은 화면이 된다. 이때 <code>vmbr1</code>, <code>vmbr2</code>를 만들 때는 VLAN aware에 체크해준다.</p>\n<p>그러면 다음과 같은 화면이 된다.</p>\n<p><img src=\"/static/network-final-6d688670.png\" alt=\"브릿지 만든 이후\"></p>\n<h2>4.2. pfsense 설치</h2>\n<p>pfsense는 적당히 홈페이지에서 내려받아서 설치하면 된다. <a href=\"https://www.pfsense.org/download/\">pfsense 공식 홈페이지</a>에서 내려받을 수 있다.</p>\n<p>그리고 다시 proxmox 화면으로 가면 VM을 새로 만들 수 있다. node 이름을 오른쪽 클릭 후 <code>Create VM</code>을 누르면 된다.</p>\n<p><img src=\"/static/create-vm-5c36ab80.png\" alt=\"create vm\"></p>\n<p>그러면 적당한 ID(나는 100으로 했다)와 이름을 입력하고 <code>OS</code> 항목에서 아까 내려받은 pfsense iso 파일을 업로드하면 된다. 나는 VM 이름부터 pfsense로 지었다.</p>\n<p>나머지는 그냥 디폴트로 놓고 진행하면 된다.</p>\n<p>VM이 세팅되고 나면 노드의 하단 메뉴에 <code>내가 설정한 ID(내가 설정한 이름)</code>으로 VM이 만들어진 것을 볼 수 있다. 거기에 들어가서 Console 메뉴를 누르면 콘솔을 시작할 수 있다.</p>\n<p><img src=\"/static/vm-console-start-35f8c9e7.png\" alt=\"vm console\"></p>\n<h2>4.3. interface IP</h2>\n<p>인터페이스 IP를 지정해야 한다. 콘솔에 나온 옵션에 보면 <code>2) Set interface(s) IP address</code>라는 항목이 있다. 따라서 콘솔에서 2를 누르자.</p>\n<p>그러면 WAN, LAN 중 어떤 걸 할당할 것인지 물어본다. 2를 눌러 LAN을 선택하면 다음과 같은 창이 뜬다.</p>\n<p><img src=\"/static/vm-console-lan-ip-879e1aab.png\" alt=\"vm 콘솔\"></p>\n<p>IPv4 주소는 DHCP 설정을 하지 않고 직접 설정해 준다. 난 <code>192.168.0.5</code>로 설정했지만 다르게 해도 상관없다. IPv6 같은 경우 DHCP로 설정해 준다.</p>\n<p>그리고 client address range를 정하라고 하는데 적당히 내가 고정으로 사용할 것 같은 범위를 빼고 지정해 주면 된다. 나는 적당히 <code>192.168.0.32</code>부터 <code>192.168.0.250</code>까지 지정해 주었다.</p>\n<p><img src=\"/static/vm-console-lan-ip2-5c260c47.png\" alt=\"콘솔 IP 지정 2번째\"></p>\n<p>그리고 HTTPS만 사용하고 싶기 때문에 Do you want to revert to HTTP as the webConfigurator protocol? [y|n]에서 n을 눌러 HTTPS만 사용하도록 설정해 준다.</p>\n<p>그러면 다음과 같이 LAN IP 설정이 완료된다.</p>\n<p><img src=\"/static/lan-ip-done-35f8c9e7.png\" alt=\"LAN IP 지정 완료\"></p>\n<p>이제 pfsense 페이지로 접속할 때는 <code>192.168.0.5</code>로 접속할 수 있게 되었다. HTTPS로 접속해 주어야 함에 주의하자.</p>\n<h3>4.3.1. start at boot</h3>\n<p>그리고 매우 중요하게 설정해 줘야 하는 것이 있다. pfsense VM에 들어가서 왼쪽 메뉴를 보면 Options라는 항목이 있다. 거기 들어가서 보면 Start at boot라는 항목이 있는데 이를 체크해 주어야 한다.</p>\n<p><img src=\"/static/start-at-boot-08ac2fb0.png\" alt=\"start at boot 설정\"></p>\n<p>이건 서버 재부팅 시 해당 VM을 자동으로 켜주는 설정이다. 이걸 해야 하는 이유는 나중에 VPN으로 이 서버에 접속해서 설정할 일이 꽤 있을 수 있기 때문이다. 늘 서버가 있는 곳까지 가서 내부망에 접속한 후 서버를 다뤄야 한다면 매우 귀찮은 일일 테니까.</p>\n<p>그런데 VPN으로 서버를 다루다가 서버를 재부팅할 일이 생기면? 그때 pfsense가 다시 켜지지 않는다면 사실상 직접 가서 pfsense VM을 다시 켜줄 때까지 서버의 역할을 제대로 하지 못할 것이므로 문제가 된다. 따라서 해당 옵션을 켜주는게 편의상 매우 중요하다.</p>\n<h1>5. iptime 설정</h1>\n<p>이제 iptime의 설정과 연결을 좀 바꿔서 원래 iptime이 하던 기능들을 pfsense에서 하도록 바꾸어야 한다.</p>\n<h2>5.1. 목적</h2>\n<p>기존에는 외부에서 접속했을 때 iptime이 받아서 내부로 연결해 주는 역할을 했다. 하지만 이제는 pfsense가 받아서 내부로 연결해 주는 역할을 할 것이다.</p>\n<p>원래는 공유기가 하던 역할인 layer 4 스위치 역할을 pfsense가 대신하게 되고 DHCP 기능까지도 pfsense에서 할 것이다. 이제 시작할 설정을 완료하면 iptime은 그냥 와이파이만 뿌려주는 역할이 된다.</p>\n<p><img src=\"/static/what-pfsense-for-cbb2f047.png\" alt=\"pfsense 전후\"></p>\n<h2>5.2. 설정</h2>\n<p>iptime의 경우 <code>192.168.0.1</code>로 접속하면 공유기 설정을 할 수 있다. 다른 공유기의 경우는 다른 내부 ip 주소가 공유기를 위해 할당되어 있을 것이다. 하지만 해야 할 작업은 똑같다.</p>\n<p>여기서 관리 도구에 들어간 후 DHCP 설정을 끈다. 고급 설정 - 네트워크 관리 - DHCP 서버 설정에서 DHCP 서버 동작을 중지하고 적용을 눌러야 한다. 적용을 누르는 걸 잊으면 안된다!</p>\n<p><img src=\"/static/iptime-config-1-c2dad1d4.png\" alt=\"설정 창\"></p>\n<p>그리고 고급 설정 - 네트워크 관리 - 내부 네트워크 설정에서 허브/AP모드 내부 게이트웨이를 체크한다. 이 역시 적용을 눌러야 한다.</p>\n<p><img src=\"/static/iptime-config-2-d562ffb9.png\" alt=\"설정창 2\"></p>\n<p>랜선을 바꿔 끼우자. 1번째 이더넷 포트는 proxmox에 할당한 거고 proxmox도 결국 내부망이니까 공유기랑 연결해 준다. 2번째 이더넷 포트는 WAN에 사용하므로 집에 있던 외부 인터넷 선을 연결해 주었다. 그리고 3번 이더넷 포트는 LAN에 사용하므로 역시 공유기에 연결해 준다.</p>\n<p>주의할 점은 WAN에 사용하는 이더넷 포트에 연결된 리눅스 브릿지는 1개뿐이여야 한다는 것이다. 1개가 아니어도 막 당장 문제가 터지지는 않는다는데 절대 좋지는 않다고 한다.</p>\n<p>나는 이더넷 포트가 4개 있는 장치를 사용하고 있고 웬만한 다른 장치들도 홈 서버에 사용할 엄두를 낼 정도면 이더넷 포트가 2개는 달려 있으므로 하나를 WAN, 하나를 LAN으로 사용하면 되기 때문에 WAN 포트에 다른 브릿지를 할당해 줄 필요는 거의 없다.</p>\n<p>그리고 위에서 2개의 연결은 공유기랑 서버를 연결하고 있는데 여기서 공유기에 랜선을 꽂을 때 WAN 포트에 꽂으면 안된다. WAN 포트는 보통 색이 다르거나 다른 그림이 그려져 있는 등 표시가 있으니 그 부분을 피해서 LAN 선을 꽂자.</p>\n<p><img src=\"/static/server-iptime-connection-4f5be4a3.jpeg\" alt=\"서버-공유기 연결\"></p>\n<p>사진의 공유기에 선이 꽂혀 있지 않은 2개의 포트 중 노란색으로 칠해져 있는 것이 WAN 포트이다. 만약 공유기를 외부망과의 연결에 사용한다면 저 포트에 외부 인터넷 선을 연결했어야 하지만, 여기서는 아무것도 연결되어 있지 않은 것을 볼 수 있다.</p>\n<h1>6. pfsense</h1>\n<p><code>192.168.0.5</code>로 접속하면 pfsense 페이지가 나온다. 다음과 같은 로그인 페이지가 뜰 것이다.</p>\n<p><img src=\"/static/pfsense-main-1257dba3.png\" alt=\"pfsense 로그인 화면\"></p>\n<p>기본적으로 계정명은 <code>admin</code>이고 비밀번호는 <code>pfsense</code>이다. 나중에 바꿔 줘야 하지만 지금은 일단 로그인한다. 초기 접속이라면 'Welcome to pfsense software!' 같은 메시지와 함께 초기 설정을 진행하게 된다.</p>\n<p>초기 설정은 <a href=\"https://www.2cpu.co.kr/lec/4139\">2cpu에 올라온 글</a>을 참고하면 된다. 중간에 기본 비밀번호를 바꾸는 것도 진행된다. 이 글과 내가 진행한 게 다른 부분은 나는 secondary DNS를 <code>8.8.8.8</code>(구글 DNS)로 했다는 것 정도이다.</p>\n<p>여기까지 하면 pfsense 대시보드에 진입할 수 있다. 이건 약간의 설정을 마친 상태이다. 여기서 확인할 만한 건 System Information의 version이 최신인지 정도만 확인하면 된다.</p>\n<p><img src=\"/static/pfsense-dashboard-c0a23ed6.png\" alt=\"pfsense 대시보드 사진\"></p>\n<h2>6.1. 패키지 설치와 VPN</h2>\n<p>상단 메뉴의 System - Package Manager부터 들어간다. 거기서 Available Packages로 진입하면 설치 가능한 패키지들을 검색할 수 있는데 acme, haproxy, openVPN client export를 설치한다.</p>\n<p><img src=\"/static/package-installed-1ca3c2c8.png\" alt=\"설치된 패키지들\"></p>\n<p>그리고 VPN 설정을 위해 상단 메뉴에서 VPN - OpenVPN으로 들어간다. 그곳에서 Wizards 메뉴를 클릭하면 쉽게 OpenVPN 서버를 만들 수 있다. 그리고 VPN - OpenVPN - Client Export로 들어가서 아래로 스크롤을 내리면 OpenVPN 클라이언트 설정 파일을 내려받을 수 있다.</p>\n<p><img src=\"/static/openvpn-client-export-5c85f488.png\" alt=\"openvpn 클라이언트 파일 다운\"></p>\n<p>여기서 Inline Configurations의 Most Clients를 선택하면 핸드폰이나 노트북 어디서나 해당 VPN을 이용할 수 있는 <code>.ovpn</code> 설정 파일을 다운받을 수 있다. 이를 이용하면 VPN을 사용할 수 있다.</p>\n<p>사용은 다음과 같다. 나는 맥 노트북에서 해보았다. 물론 서버가 있는 네트워크와 다른 네트워크 환경에서 실험했다.</p>\n<p><a href=\"https://openvpn.net/client-connect-vpn-for-mac-os/\">OpenVPN Connect for macOS</a>페이지에서 macOS용 OpenVPN 클라이언트를 내려받아 설치한다. 설치가 끝나면 앱을 실행한 후 UPLOAD FILE 메뉴에서 아까 다운받은 설정 파일을 업로드한다(메일 등으로 보내 놓으면 된다). 그리고 아까 설정한 pfsense 아이디를 통해서 로그인하면 VPN에 접속된다.</p>\n<p><img src=\"/static/vpn-with-dashboard-7dd6d434.png\" alt=\"openvpn 클라이언트\"></p>\n<p>이 상태에서 <code>192.168.0.5</code>에 접속하면 아까 보았던 pfsense 페이지에 접속할 수 있다.</p>\n<p>openVPN은 스마트폰 앱도 있는데 앱을 통해서도 비슷하게 파일 업로드를 통하면 스마트폰으로도 pfsense나 proxmox 설정이 가능하다.</p>\n<p>초기 세팅은 어느 정도 된 것 같으니 다음 글에서는 블로그를 배포해보도록 하겠다.</p>\n<h1>참고</h1>\n<p>맥 OS에서 USB를 포맷하는 법 <a href=\"https://100sang.net/143\">https://100sang.net/143</a></p>\n<p>맥 USB .iso, .img 이미지 부팅 설치 파일 만들기 <a href=\"https://tttap.tistory.com/223\">https://tttap.tistory.com/223</a></p>\n<p>proxmox란 무엇인가\n<a href=\"https://it-svr.com/proxmox-ve-opeunsoseu-gasanghwa-osran-mueosinga/\">https://it-svr.com/proxmox-ve-opeunsoseu-gasanghwa-osran-mueosinga/</a></p>\n<p>pfsense 설치\n<a href=\"https://www.2cpu.co.kr/lec/4139\">https://www.2cpu.co.kr/lec/4139</a></p>",
    "excerpt": "\n서버 구축은 처음이고 저보다 조금 먼저 서버를 구축한 불칸님의 많은 도움을 받아가며 만들어진 글이라 많이 부족할 수 있습니다. 틀린 부분이 있다면 댓글로 알려주시면 감사하겠습니다.\n\n\n이 글을 보고 홈서버를 세팅하려는 분이 계실지도 모르겠습니다. 제가 알고 있는 부분의 지식은 많은 생략이 있었기 때문에 네트워크에 대한 기본적인 지식은 가지고 있어야 어느 정도 이해하며 글을 읽으실 수 있을 것이라고 알려드립니다.\n\n1. 시작\n이 블로그는 원래 Vercel로 배포",
    "headingTree": [
      {
        "title": "1. 시작",
        "url": "#1-시작",
        "items": []
      },
      {
        "title": "2. proxmox 설치",
        "url": "#2-proxmox-설치",
        "items": [
          {
            "title": "2.1. proxmox란?",
            "url": "#21-proxmox란",
            "items": []
          },
          {
            "title": "2.2. USB 굽기",
            "url": "#22-usb-굽기",
            "items": []
          },
          {
            "title": "2.3. proxmox 설치",
            "url": "#23-proxmox-설치",
            "items": [
              {
                "title": "2.3.1. 트러블슈팅",
                "url": "#231-트러블슈팅",
                "items": []
              }
            ]
          }
        ]
      },
      {
        "title": "3. proxmox 웹 UI 가이드",
        "url": "#3-proxmox-웹-ui-가이드",
        "items": [
          {
            "title": "3.1. 맨 왼쪽 메뉴",
            "url": "#31-맨-왼쪽-메뉴",
            "items": []
          },
          {
            "title": "3.2. Datacenter 메뉴",
            "url": "#32-datacenter-메뉴",
            "items": []
          },
          {
            "title": "3.3. node(witch) 메뉴",
            "url": "#33-nodewitch-메뉴",
            "items": []
          }
        ]
      },
      {
        "title": "4. proxmox 설정",
        "url": "#4-proxmox-설정",
        "items": [
          {
            "title": "4.2. pfsense 설치",
            "url": "#42-pfsense-설치",
            "items": []
          },
          {
            "title": "4.3. interface IP",
            "url": "#43-interface-ip",
            "items": [
              {
                "title": "4.3.1. start at boot",
                "url": "#431-start-at-boot",
                "items": []
              }
            ]
          }
        ]
      },
      {
        "title": "5. iptime 설정",
        "url": "#5-iptime-설정",
        "items": [
          {
            "title": "5.1. 목적",
            "url": "#51-목적",
            "items": []
          },
          {
            "title": "5.2. 설정",
            "url": "#52-설정",
            "items": []
          }
        ]
      },
      {
        "title": "6. pfsense",
        "url": "#6-pfsense",
        "items": [
          {
            "title": "6.1. 패키지 설치와 VPN",
            "url": "#61-패키지-설치와-vpn",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 2,
      "wordCount": 414
    },
    "url": "/posts/blog-home-server",
    "thumbnail": {
      "local": "/static/n100i226v-ceb19602.webp",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-n100i226v-ceb19602-webp",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAIAAABLbSncAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAnUlEQVR4nG2OsQ2DMBBFjyYSioIEHY7bwAjUoWaVUCB5BYeKEUDeyK5dsETcYHMXGZoUedVvvt4DRPTehxD2fUfEcxAR0D8QEdZ1VUpJKYdh6LpOCGGtjY9pmgAgSZIsy6pHxUrGOZ/nGay1dV2naXpnrChyxsvr7TKO7+gwxjRN07bPvn8tatFaf5yDs8E5t23brz8+8ICIwsGZ+wUaN4gSD/OmCAAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "blog-home-server-2",
    "title": "홈 서버로 블로그 배포하기 - 블로그 올리기",
    "date": "2023-10-03T01:00:00Z",
    "description": "블로그를 홈 서버에 올려보자",
    "tags": [
      "blog"
    ],
    "html": "<blockquote>\n<p>서버 구축은 처음이고 저보다 조금 먼저 서버를 구축한 <a href=\"https://vulcan.site/\">불칸</a>님의 많은 도움을 받아가며 만들어진 글이라 많이 부족할 수 있습니다. 틀리거나 보충해야 할 부분이 있다면 댓글로 알려주시면 감사하겠습니다.</p>\n</blockquote>\n<blockquote>\n<p>이 글을 보고 홈서버를 세팅하려는 분이 계실지도 모르겠습니다. 제가 알고 있는 부분의 지식은 많은 생략이 있었기 때문에 네트워크에 대한 아주 기본적인 지식은 가지고 있어야 읽을 수 있습니다.</p>\n</blockquote>\n<p><a href=\"https://witch.work/posts/blog-home-server\">홈 서버 만들기 - 초기 세팅, proxmox, pfsense</a>에서 이어지는 글입니다.</p>\n<h1>1. 기초 설정</h1>\n<h2>1.1. 컨테이너 만들기</h2>\n<p>LXC 컨테이너를 만드는 작업은 <a href=\"https://velog.io/@kisuk623/Proxmox-%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0\">나만의 홈서버 구축하기 - 1</a>글을 참고하였습니다.</p>\n<p>나는 이 홈서버를 산 목적이 애초에 블로그를 배포하기 위한 것이었으므로 proxmox에서 컨테이너를 만들어주자. 위의 링크를 참고하면 된다.</p>\n<p>ID는 적당히 1001로 하고 이름은 <code>blog</code>로 지었다. 템플릿 OS는 Ubuntu 20.04로 선택했다. 참고로 CT를 만들 때 <code>General</code>항목에서 <code>unprivileged container</code>라는 체크박스가 있는데 이는 절대 해제하면 안된다. 커널과 컨테이너를 분리해서 보안성을 높여주는 기능이다.</p>\n<p>나머지는 디폴트로 놓고 진행해도 된다. 다만 나는 컨테이너에 좀 더 많은 성능을 할당해주고 싶어서 코어 4개, 메모리 4GB로 설정했다. 이는 나중에 수정할 수 있으므로 크게 신경쓰지 않아도 된다. 단, 이를 늘릴 수는 있어도 줄이는 건 절대 쉽지 않다고 하니 주의하자.</p>\n<h2>1.2. 컨테이너 설정</h2>\n<p>해당 컨테이너에 접속해서 Console 메뉴에서 start 후 아까 입력한 아이디와 비밀번호를 입력하면 콘솔이 띄워진다. 이제 이 컨테이너에 필요한 패키지들을 설치해주자.</p>\n<pre><code class=\"language-bash\">sudo apt-get update\nsudo apt-get install git\nsudo apt install nginx\n</code></pre>\n<p>블로그는 nextjs로 되어 있으므로 clone해우면 된다.</p>\n<pre><code class=\"language-bash\">git clone MY_BLOG_URL\ncd MY_BLOG_DIR\nyarn\nsudo n lts # nodejs 버전을 lts로 설정\nsudo n prune  \n</code></pre>\n<p>여기서 2가지 선택지가 갈린다. 하나는 static export로 빌드하여 배포하는 것이고 하나는 Nodejs의 프로세스 매니저인 pm2를 사용하여 nextjs 서버를 백그라운드 프로세스에 열어 놓고 특정 포트 번호로 접속할 시 해당 nextjs 서버로 연결해주는 것이다.</p>\n<p><img src=\"/static/static-vs-pm2-68a1801d.png\" alt=\"static export vs pm2\"></p>\n<p>나는 pm2를 사용하는 걸로 선택했다.</p>\n<p>여기서 WAN IP 트래픽을 빌드 결과물 혹은 내부망의 특정 포트로 포트포워딩하는 방식도 여러 가지 선택할 수 있는데 나는 HAProxy를 이용했다. 다른 방식들도 있는데 일단 쭉 배포를 설명한 이후에 간단히 소개하겠다.</p>\n<h1>2. pm2로 서버 실행</h1>\n<p>말 그대로 process manager인 pm2를 이용해서 배포에 쓰일 페이지를 백그라운드 프로세스에 띄워놓고 특정 포트로 접속할 시 해당 프로세스로 연결해주는 방식이다. 이 섹션에서는 일단 해당 페이지를 띄우는 걸 해보도록 하겠다.</p>\n<h2>2.1. 무엇을 할 것인가</h2>\n<p>위에서 <code>output: 'export'</code> 설정을 한 걸 되돌리고 다시 proxmox 콘솔에서 <code>yarn run build</code>를 해보자.</p>\n<p>그리고 <code>yarn start</code>를 한 후 <code>blog 컨테이너의 내부 ip주소:start된 포트번호</code>에 접속해보자. 나같은 경우에는 <code>192.168.0.33:3000</code>이었다.</p>\n<p>블로그가 빌드된 페이지가 잘 로딩되는 것을 볼 수 있다. 만약 외부 도메인을 해당 주소의 해당 포트에 연결한다면, 외부 도메인 접속 시 이 페이지가 뜰 것이다.</p>\n<p>그럼 pm2는 무엇을 하느냐? 우리가 <code>yarn start</code>를 하면 이 페이지가 뜨는데 지금은 이렇게 하면 콘솔 창에서 <code>yarn start</code>의 결과가 뜨고 다른 콘솔 입력을 받을 수 없다. node가 싱글스레드라서 그렇다.</p>\n<p>우리는 pm2를 이용하여 이 <code>yarn start</code>를 백그라운드 프로세스로 넘길 것이다.</p>\n<p><a href=\"https://engineering.linecorp.com/ko/blog/pm2-nodejs\">이렇게 하는 것의 이점 하나는 무중단 배포가 가능하다는 것이다.</a></p>\n<h2>2.2. pm2 설정</h2>\n<p>pm2를 설치하자. (만약 뭔가 안된다면 sudo를 붙여서 해보자)</p>\n<pre><code class=\"language-bash\">sudo yarn global add pm2\n</code></pre>\n<p>이렇게 하면 pm2가 <code>blog</code>라는 이름의 프로세스를 시작하고 그 프로세스에서 <code>yarn start</code>를 한다.</p>\n<pre><code class=\"language-bash\">pm2 start yarn --name \"blog\" -- start\n</code></pre>\n<p>이렇게 하면 백그라운드에서 <code>yarn start</code>가 실행된다. 그래서 콘솔 창에는 아무것도 뜨지 않는데 <code>192.168.0.33:3000</code>으로 향하면 페이지는 실행되고 있다.</p>\n<p><code>pm2 status</code>를 입력하면 현재 pm2가 관리하고 있는 프로세스들의 상태를 볼 수 있다. <code>pm2 stop blog</code>를 입력하면 <code>blog</code>라는 이름의 프로세스를 종료할 수 있고 <code>pm2 delete blog</code>를 입력하면 <code>blog</code>라는 이름의 프로세스를 삭제할 수 있다. 수많은 다른 기능들이 있지만 일단 당장 필요한 것들만 하자.</p>\n<pre><code class=\"language-bash\"># pm2 status 입력시 보이는 것\nwitch@blog:~/witch-next-blog$ pm2 status\n┌──┬───────┬─────┬───┬───────┬─────┬─────────┐\n│id│name   │mode │↺  │status │cpu  │memory   │\n├──┼───────┼─────┼───┼───────┼─────┼─────────┤\n│0 │blog   │fork │0  │online │0%   │81.4mb   │\n└──┴───────┴─────┴───┴───────┴─────┴─────────┘\n</code></pre>\n<p>pm2를 시스템 리부트 시 자동으로 실행하고 현재의 프로세스를 재현하도록 하자. 먼저 다음 명령어를 입력한다.</p>\n<pre><code class=\"language-bash\">pm2 startup\n</code></pre>\n<p>그럼 다음과 같은 메시지가 뜬다. 여기서 witch는 내가 만든 유저 이름이다.</p>\n<pre><code class=\"language-bash\">[PM2] Init System found: systemd\n[PM2] To setup the Startup Script, copy/paste the following command:\nsudo env PATH=$PATH:/usr/local/bin /usr/local/share/.config/yarn/global/node_modules/pm2/bin/pm2 startup systemd -u witch --hp /home/witch\n</code></pre>\n<p>하라는 대로 <code>sudo~</code>로 시작하는 명령어를 복붙해 실행해준다. 그러면 메시지들이 쭉 뜨는데 마지막에 보면 <code>Freeze a process list on reboot via: pm2 save</code>라고 뜬다. 우리가 원하는 것이므로 <code>pm2 save</code>를 입력해준다.</p>\n<pre><code class=\"language-bash\">pm2 save\n</code></pre>\n<p>앞으로의 배포 작업은 이 pm2를 이용해서 시작된 프로세스로 진행할 것이다.</p>\n<h3>2.2.1. 추가작업</h3>\n<p>3000번 포트는 너무 많이 쓰이기 때문에 <code>yarn start</code>를 할 때 쓰이는 포트를 바꿔주자. 나는 3141로 바꿨다. 그냥 원주율의 첫 4자리라서 그렇고 8080이나 <a href=\"https://developers.cloudflare.com/fundamentals/reference/network-ports/\">Cloudflare의 프록시에서 지원하는 포트 중 하나로 해도 좋겠다.</a></p>\n<p><code>package.json</code>의 <code>scripts</code>에서 <code>start</code>를 다음과 같이 바꿔주자.</p>\n<pre><code class=\"language-json\">  \"scripts\": {\n    // ...\n    \"start\": \"next start -p 3141\",\n    // ...\n  },\n</code></pre>\n<p>이를 git에 push하고 나서 proxmox 콘솔에서 pm2를 재시작해주자. 이후에 모든 배포 프로세스가 끝나고 나서도 페이지 수정사항이 있을 시 다음과 같은 커맨드를 실행해 주면 된다.</p>\n<pre><code class=\"language-bash\">git pull origin main\nyarn run build\npm2 restart blog\n</code></pre>\n<p>그러면 이제는 <code>192.168.0.33:3141</code>에서 빌드된 페이지가 보인다.</p>\n<h1>3. 외부 접속 설정</h1>\n<p><a href=\"https://www.linkedin.com/pulse/configuring-pfsense-firewall-haproxy-maximum-security-goldhammer/\">이 섹션은 이 글을 대부분 참고하여 작성하였다.</a></p>\n<p>하지만 내부망에서만 이렇게 보여서야 별 의미가 없다. 외부망에서도 이 페이지로 접속할 수 있도록 해주자.</p>\n<p>나는 haproxy를 써서 이 작업을 진행할 것이다. <code>blog.witch.work</code>로 접속했을 때 HTTPS를 통해서 방금 내부망에 띄운 저 페이지로 갈 수 있도록 설정해주자. acme와 haproxy를 같이 이용하면 HTTPS 설정까지 쉽게 할 수 있다. nginx에서 하나하나 설정해 주는 것보다 편하다.(물론 IP 주소를 통한 접속에 대해서 HTTPS 설정을 하고 싶으면 nginx를 써야 한다)</p>\n<p>나는 cloudflare에서 도메인을 관리하고 있고, haproxy에서는 cloudflare와 연동해서 설정할 수 있는 기능을 매우 잘 제공한다. 따라서 이를 사용한다. 다만 아직 실제 블로그 배포를 하기에는 해결해야 할 여러 문제가 있기 때문에 예전에 만들어둔 서브도메인을 통해서 실험하도록 하겠다.</p>\n<p><a href=\"https://witch.work/posts/cloudflare-make-subdomain\">cloudflare에서 서브도메인을 만드는 것에 대해서는 이전에 쓴 글을 참고할 수 있다.</a></p>\n<h2>3.1. Cloudflare 설정</h2>\n<p>Cloudflare에 접속하여 내 도메인에 접속한다. 그러면 도메인에 연결된 DNS들이 나오는데 우리는 여기서 <code>blog</code>서브도메인을 사용할 것이다. 따라서 도메인 리스트에서 <code>blog</code>를 선택해 편집하자.</p>\n<p><img src=\"/static/cloudflare-domain-list-798510ae.png\" alt=\"Cloudflare 도메인 리스트\"></p>\n<p>프록시를 끄고 Target을 <code>1.1.1.1</code>로 바꾼다. 이는 haproxy에서 cloudflare와 연동하면서 알아서 바꿔줄 것이다.</p>\n<p><img src=\"/static/cloudflare-target-change-e06d5ce8.png\" alt=\"target 변경\"></p>\n<blockquote>\n<p>만약 자동으로 변경되지 않는다면 cloudflare에서 DNS IP를 내가 가진 WAN IP로 수동으로 다시 설정해주면 된다.</p>\n</blockquote>\n<h2>3.2. acme 세팅</h2>\n<p>pfsense에서 System - Advanced - Admin Access에서 TCP Port는 기본적으로 443으로 되어 있을 텐데 이를 다른 포트로 적당히 바꿔준다. 나는 12443으로 했다.</p>\n<p>이렇게 바꿔주고 나면 pfsense 접속을 위해 12443 포트를 사용하게 된다. 원래는 <code>192.168.0.5</code>로 접속해서 pfsense를 사용했는데 <code>192.168.0.5:12443</code>으로 접속하는 것이다.</p>\n<p>그리고 System - Package Manager - Available Packages에서 acme와 HAProxy를 설치한다. 나는 이전 글에서 했으니 생략한다.</p>\n<p>Services - Acme Certificates - General settings에서 Cron entry를 체크하면 자동으로 인증서가 갱신되게 할 수도 있다. 원하면 체크하자.</p>\n<p>그 다음 Services - Acme Certificates - Account keys에 들어가서 add를 누르고 account key를 생성하자. 적당히 이름과 설명을 입력하고 이메일을 입력한다. 그리고 <code>Create Account Key</code>를 누르면 account key가 생성된다. <code>Register ACME account key</code>를 누르면 이 key가 등록된다.</p>\n<p><img src=\"/static/new-account-key-c547a0d3.png\" alt=\"acme account key 생성\"></p>\n<p>그다음 Services - Acme Certificates - Certificates에 들어가서 add를 누르고 이름과 설명을 적당히 입력하고 Acme Account는 방금 만든 것을 선택한다.</p>\n<p>Private key는 384-bit ECDSA로 설정하고 OCSP Must Staple은 체크해준다.</p>\n<p><img src=\"/static/acme-certificate-be3402a4.png\" alt=\"acme certificate 생성\"></p>\n<p>Domain SAN list를 설정해 줘야 한다. <code>+ Add</code>를 클릭하고 method는 <code>DNS - Cloudflare</code>로 선택한다.\n나는 <code>witch.work</code>와 <code>*.witch.work</code>를 추가했다. 이렇게 하면 witch.work와 모든 서브도메인에 대한 인증서가 추가된다.</p>\n<p><img src=\"/static/add-certificate-c3243e1f.png\" alt=\"인증서 추가\"></p>\n<p>입력해야 할 Key가 많은데 Cloudflare API Keys는 Cloudflare에서 My profile에 들어간 후 왼쪽 메뉴의 API Tokens - Global API Key에서 찾을 수 있다. Email은 cloudflare에 등록한 이메일을 입력하면 된다.</p>\n<p>Token은 API Token인데 역시 Cloudflare에서 My profile에 들어간 후 왼쪽 메뉴의 API Tokens - Create Token에서 만들 수 있다. 여기서는 <code>Edit zone DNS</code>를 체크해준다. 이 토큰은 한번 만들면 Cloudflare에서는 다시 볼 수 없으므로 한번 복사해서 잘 입력해두자. 하지만 한번 이렇게 잘 입력해 두면 pfsense에서 다시 볼 수 있으므로 굳이 어디 따로 저장해 둘 필요는 없다.</p>\n<p>Account ID, Zone ID는 도메인 메뉴에 들어가서 우측 메뉴의 스크롤을 내리면 Quick Actions, Domain Registration, Active Subscriptions, Support Resourcesd 아래에 API라는 메뉴가 있는데 거기에서 둘 다 찾을 수 있다. 그걸 복붙해서 입력하면 된다.</p>\n<p>그리고 Actions list에서 다음과 같은 커맨드를 추가하자. 이는 인증서 갱신 시에 자동으로 haproxy를 재시작해서 새 인증서가 적용되도록 하는 것이다.</p>\n<p><img src=\"/static/certificate-actions-list-0a24b7f9.png\" alt=\"인증서 actions list\"></p>\n<p>이렇게 하고 저장한 후 메뉴에서 <code>Issue/Renew</code>를 클릭하면 뭔가 로딩되다가 초록색 알림 창에 많은 텍스트가 뜨는데 <code>Reload success</code>가 알림창 마지막에 나오면 성공이다.</p>\n<p>이러면 <code>*.witch.work</code>에 해당하는 도메인 중 Cloudflare에서 DNS를 pfsense 쪽으로 연결해준 도메인들에 대해서 인증서가 사용된다.</p>\n<p><code>Issue/Renew</code>클릭시 다음과 같은 메시지가 뜰 수도 있는데 너무 많이 인증서를 요청해서 그런 것이다. 이때 메시지를 잘 읽어보면 언제 이후에 다시 시도하라는 말이 있는데 그렇게 하면 된다.</p>\n<pre><code>An unexpected error occurred:\nThere were too many requests of a given type :: Error creating new order :: too many certificates (5) already issued for this exact set of domains in the last 168 hours: &#x3C;my-domain>: see https://letsencrypt.org/docs/rate-limits/\n</code></pre>\n<h2>3.3. HAProxy 설정</h2>\n<h3>3.3.1. Settings</h3>\n<p>이제 HAProxy를 설정해주자. Services - HAProxy - Settings에 들어가서 Global parameters에서 <code>Enable HAProxy</code>를 체크해주자.</p>\n<p>그리고 Logging에서 Remote Syslog host를 <code>/var/run/log</code>로 한다. 안해도 큰 상관은 없다.</p>\n<p>Max SSL Diffie-Hellman size는 2048로 되어 있을 텐데 이를 4096으로 바꾼다. SSL/TLS Compatibility Mode는 Intermediate로 설정한다.</p>\n<h3>3.3.2. Backend</h3>\n<p>Services - HAProxy - Backend에 들어가서 Add를 누르고 다음과 같이 이름을 적당히 지어준다.</p>\n<p>Server list에는 앞으로 우리가 외부와 연결할 모든 서버들을 추가하면 된다. 여기서는 내가 연결할 내부 포트 IP와 포트번호(3141)를 적어주었다. 여기서 SSL 암호화를 안하더라도 내부 트래픽이 암호화되지 않을 뿐 여전히 프론트엔드 서버는 HTTPS이므로 상관없다.</p>\n<p><img src=\"/static/haproxy-backend-372d12c4.png\" alt=\"backend 설정\"></p>\n<p>health check는 딱히 안해도 잘 된다. 이렇게 하고 저장하자.</p>\n<h3>3.3.3. Frontend</h3>\n<p>Services - HAProxy - Frontend에 들어가자. 먼저 http를 https로 리다이렉션하는 규칙을 설정해주자. <code>Add</code>를 누르고 다음과 같이 이름과 설명을 적당히 적어 준다. 그다음 external address 포트를 80으로 적어주고 offloading SSL을 체크 해제한다. Type은 <code>http / https(offloading)</code>로 설정한다.</p>\n<p><img src=\"/static/haproxy-front-http-to-https-cfc12abf.png\" alt=\"설정\"></p>\n<p>다른 프론트엔드 리스너를 하나 만들자. 이 리스너는 443포트로 들어온 https 트래픽을 핸들링하고 <a href=\"https://minholee93.tistory.com/entry/SSL-offloading-%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C\">SSL 오프로딩</a>을 한다.</p>\n<p>그러니 이는 포트를 443으로 지정하고 SSL 오프로딩을 체크한 후 Type은 <code>http / https(offloading)</code>로 설정한다. 역시 이름과 설명은 적당히.</p>\n<p><img src=\"/static/haproxy-front-rule-443-c15f73f6.png\" alt=\"https 설정\"></p>\n<p>Access Control List를 설정해줄 차례다. 어떤 도메인으로 들어오는지에 따라서 다른 서버로 연결해주기 위함이다.</p>\n<p>우리가 해야 하는 건 <code>blog.witch.work</code>로 들어오는 트래픽을 방금 만든 <code>my-backend</code> 서버로 연결해주는 것이다.</p>\n<p>Access Control list의 name과 Actions의 Condition acl names이 같은 것끼리 연결된다는 것에 주의해서 해당 섹션을 다음과 같이 설정해주자. <code>cs.witch.work</code>는 내가 이전에 설정한 것이니 무시하면 된다.</p>\n<p><img src=\"/static/haproxy-acl-1f1b9e39.png\" alt=\"acl\"></p>\n<p>그렇게 설정 후 아래로 내려보면 Advanced settings 항목이 있는데 여기의 <code>Advanced pass thru</code>부분에 다음과 같은 값을 입력해준다. 응답 헤더를 추가해 주는 것이다.</p>\n<pre><code>http-response set-header strict-transport-security \"max-age=31536000;includeSubDomains;preload;\"\n</code></pre>\n<p>그다음 SSL Offloading에서는 Certificate을 아까 만든 acme 인증서로 추가하고 Add ACL for certificate Subject Alternative Names를 체크 후 Additional certificate을 추가한다. 이는 위의 certificate에서 추가한 것과 같은 인증서를 추가하면 된다.</p>\n<p>Advanced ssl options에는 보안 강화를 위해 다음 문구를 작성한다.</p>\n<pre><code>curves secp384r1:secp521r1 ciphers ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES256-GCM-SHA384 ciphersuites TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256\n</code></pre>\n<p>여기까지 설정하면 ssl offloading 설정이 완료된다.</p>\n<p><img src=\"/static/haproxy-ssl-offloading-ec4038ff.png\" alt=\"ssl offloading 설정\"></p>\n<h2>3.4. rules 설정</h2>\n<p>이제 트래픽을 받을 규칙을 설정해 줘야 한다.</p>\n<p>firewall - rules - WAN에 들어가서 rule을 추가하자.</p>\n<p>이제 HTTP, HTTPS 요청을 받을 규칙을 만들어 줘야 한다. 원래 pfsense firewall은 외부에서 오는 모든 트래픽을 막는다. 이를 오버라이드해서 외부에서 오는 트래픽을 받을 수 있도록 하는 것이다. HTTP를 위한 80포트 규칙, HTTPS를 위한 443포트 규칙을 만들어주자.</p>\n<p>Interface는 WAN으로 하고 프로토콜은 TCP/UDP로 한다.(TCP로 해도 별 상관은 없다) 그 다음 Destination을 <code>This firewall(self)</code>로 설정하고 포트번호는 http rule인지 https rule인지에 따라 80 혹은 443으로 한다. 설명은 <code>allow for http</code>, <code>allow for https</code>로 적었다. 예를 들어 allow for https의 경우 다음과 같이 설정하면 된다.</p>\n<p><img src=\"/static/firewall-rule-https-19b3385e.png\" alt=\"allow for https\"></p>\n<p>그러면 다음과 같이 규칙들이 생성되게 된다.</p>\n<p><img src=\"/static/firewall-all-rules-5dba21f8.png\" alt=\"firewall 규칙들\"></p>\n<blockquote>\n<p>만약 잘 안되면 Destination을 <code>WAN address</code>로 설정해보자.</p>\n</blockquote>\n<p>외부에서 pfsense가 트래픽을 받을 규칙도 설정해 줄 수 있다. 이는 pfsense가 트래픽을 받을 규칙이므로 Destination은 WAN address, 포트번호는 아까 만들었던 12443으로 한다. 설명은 <code>allow for pfsense ports</code>로 적었다. 다만 이렇게 하면 <code>WAN IP:12443</code>으로 나의 pfsense에 접속할 수 있게 되는 거라서 그렇게 좋지는 않다.</p>\n<p>다음과 같이 rule이 만들어진다. 설정을 변경한 부분은 빨갛게 표시하였다.</p>\n<p><img src=\"/static/firewall-rule-wan-bae2006e.png\" alt=\"wan rule\"></p>\n<p>여기까지 거치면 사용자가 내 도메인 <code>blog.witch.work</code>에 접속시 맨 처음 <code>yarn start</code>로 pm2에서 실행한 페이지로 도달하게 되는데 그 과정은 다음과 같다.</p>\n<p><img src=\"/static/how-my-domain-works-8c8458e7.png\" alt=\"사용자가 어떻게 내 도메인 컨텐츠에 도달하는가\"></p>\n<h2>3.5. ssllab 테스트</h2>\n<p><a href=\"https://www.ssllabs.com/ssltest/index.html\">ssllabs에서는 웹서버의 ssl 설정을 테스트하고 점수를 매겨준다.</a> 위처럼 설정한 사이트의 경우 A+를 받을 수 있다.</p>\n<p><img src=\"/static/ssllab-test-5b5b3682.png\" alt=\"ssllab 테스트 결과\"></p>\n<p>또한 <a href=\"https://blog.witch.work/\">해당 페이지 링크</a>에도 잘 접속되는 것을 볼 수 있었다.</p>\n<h2>3.6. 만약 안되면?</h2>\n<p>만약 안되면 pfsense를 한번 껐다 켜 보자. 나는 그러니까 해결된 문제들이 많았다.</p>\n<p>pfsense에서 diagnotics - reboot에서 할 수 있다.</p>\n<p><img src=\"/static/pfsense-reboot-da85ccf4.png\" alt=\"reboot 화면\"></p>\n<h1>4. HTTP2 설정</h1>\n<p>haproxy는 기본적으로 HTTP1.1이다. 따라서 lighthouse 진단을 하게 되면 HTTP2를 쓰는 게 좋다는 진단을 내려준다.</p>\n<p>Services - HAproxy - Frontend에서 내가 사용하는 Frontend Rule을 찾는다. 그리고 해당 rule의 <code>SSL Offloading</code>항목에 보면 Advanced certificate specific ssl options라는 곳이 있는데 거기 다음과 같은 문구를 입력하면 HAProxy가 HTTP2로 설정된다.</p>\n<pre><code>alpn h2,http/1.1 ciphers EECDH+aRSA+AES:TLSv1+kRSA+AES:TLSv1+kRSA+3DES ecdhe secp256k1\n</code></pre>\n<h1>5. 번외 - 다른 방법들</h1>\n<h2>5.1. static export 배포</h2>\n<p>위에서는 pm2를 이용해 백그라운드 프로세스에서 <code>yarn start</code>를 실행시키고 사용자가 해당 서버에 접속하도록 했다. 하지만 static export 형식으로 페이지를 빌드하여 사용자가 그렇게 빌드된 결과물 즉 <code>index.html</code>을 보도록 하는 것도 가능하다.</p>\n<p>아까 클론한 블로그 폴더에서 <code>yarn run build</code>를 입력하면 빌드가 된다.</p>\n<pre><code class=\"language-bash\">yarn run build\n</code></pre>\n<p>이때 nextjs의 기본 빌드 경로는 <code>.next</code>인데 <a href=\"https://nextjs.org/docs/pages/building-your-application/deploying/static-exports\">static export</a>로 배포할 것이므로 빌드 형식을 따로 지정해 줘야 한다.</p>\n<p><code>next.config.js</code>의 <code>nextConfig</code>에서 <code>output: 'export'</code> 프로퍼티를 추가해 주면 된다.</p>\n<pre><code class=\"language-js\">// next.config.js\n// nextjs 공식 문서에서 가져왔다.\nconst nextConfig = {\n  output: 'export',\n \n  // Optional: Change links `/me` -> `/me/` and emit `/me.html` -> `/me/index.html`\n  // trailingSlash: true,\n \n  // Optional: Prevent automatic `/me` -> `/me/`, instead preserve `href`\n  // skipTrailingSlashRedirect: true,\n \n  // Optional: Change the output directory `out` -> `dist`\n  // distDir: 'dist',\n}\n</code></pre>\n<p>이렇게 하면 <code>yarn run build</code>를 했을 때 <code>.next</code>가 아닌 <code>out</code> 폴더가 생성된다(물론 이것도 <code>distDir</code>프로퍼티로 바꿀 수 있다). 어쨌든 이렇게 빌드가 static export된 폴더를 nginx에 연결해주면 된다. 이를 위해서는 nginx 설정 파일을 좀 만져주자.</p>\n<pre><code class=\"language-bash\">sudo nano /etc/nginx/sites-available/static.site\n</code></pre>\n<p>그리고 다음과 같이 작성해주자. 나는 빌드 파일 경로를 따로 바꿔주지 않았으므로 빌드폴더 경로는 <code>블로그_폴더_경로/out</code>이다. 그리고 git에는 안 올라가 있을 <code>.env</code>파일도 넣어주는 걸 잊지 말자.</p>\n<pre><code class=\"language-bash\">server {\n  listen PORT_NUMBER;\n  server_name 0.0.0.0;\n  charset utf-8;\n\n  location / {\n    root 빌드파일_경로;\n    index index.html index.htm;\n    try_files $uri $uri.html $uri/ =404;\n  }\n}\n</code></pre>\n<p>그리고 심볼릭 링크를 연결해 준 후 nginx 테스트, 성공시 리로드한다.</p>\n<pre><code class=\"language-bash\">sudo ln -s /etc/nginx/sites-available/static.site /etc/nginx/sites-enabled/\nsudo nginx -t\nsudo service nginx reload\n</code></pre>\n<p>이제 <code>ip a</code>로 입력하면 나오는 내부망 ip + 포트번호로 접속하면 블로그가 뜬다. 외부망 접속도 해야 하지만 일단은 블로그를 띄우는 데 성공한 것이다.</p>\n<p><img src=\"/static/blog-first-nginx-8e6f76a1.png\" alt=\"첫번째 블로그 올린결과\"></p>\n<p>이렇게 띄운 nextjs 페이지를 보면 이미지가 나와있지 않다. 이는 Nextjs의 이미지 컴포넌트가 static export에서 제대로 작동하지 않기 때문이다. 이를 해결하기 위해서는 따로 이미지 로더를 지정해 주어야 한다. 이는 공식 문서에 잘 설명되어 있으므로 링크로 대체한다.</p>\n<p><a href=\"https://nextjs.org/docs/pages/building-your-application/deploying/static-exports#image-optimization\">static export - Image Optimization</a></p>\n<h2>5.2. 다른 포트포워딩 방법들</h2>\n<p>위에서는 HAProxy에서 외부의 특정 포트로 들어온 요청을 내부의 포트로 연결해 주었다. 그런데 pfsense에서도, nginx에서도 비슷한 일을 할 수 있어 방법을 간단히만 적어둔다. 대강 해본 것이라 완전히 잘 작동하지는 않을 수도 있다.</p>\n<h3>5.2.1. pfsense에서 포트포워딩</h3>\n<p><a href=\"https://svrforum.com/svr/27343\">pfsense에서 포트포워딩하는 방법에 대한 서버포럼 글이 있어 이를 참고하였다.</a></p>\n<p>먼저 pfsense에 접속해서 상단 메뉴의 <code>Interfaces</code> -> <code>WAN</code> 를 클릭한다. 그리고 제일 하단으로 내려가서 <code>Block private networks and loopback addresses</code>를 체크 해제한다.</p>\n<p>그다음에는 <code>Firewall</code> -> <code>NAT</code> -> <code>Port Forward</code>를 클릭한다. <code>Add(위쪽 방향 화살표)</code>를 눌러서 다음과 같이 입력한다.</p>\n<p>이 포트포워딩의 목적이 WAN 주소의 특정 포트로 들어오는 접속을 내부 IP의 특정 포트로 연결해 주기 위한 것이므로 이 부분만 설정해 주면 된다. 나는 WAN IP의 8080 포트로 들어오는 접속을 내부 IP의 3141 포트로(내부 IP의 다른 포트를 사용하고 있다면 해당 포트로) 연결해 줄 것이다.</p>\n<p><img src=\"/static/pfsense-port-forwarding-24cd6bd0.png\" alt=\"pfsense 포트포워딩 설정화면\"></p>\n<p>이를 설정하고 적용 후 WAN IP의 8080포트로 접속하면 아까 만들어진 블로그 페이지가 뜨게 된다.</p>\n<h3>5.2.2. nginx 포트포워딩</h3>\n<p>nginx에서도 포트포워딩 설정을 해줄 수 있다. 여기서 쓰이지는 않겠지만.</p>\n<pre><code class=\"language-bash\">sudo nano /etc/nginx/sites-available/static.site\n</code></pre>\n<p>해당 파일을 다음과 같이 변경한다. 모든 IP에서 오는 8080 포트로 들어오는 접속을 내부망의 3141 포트로 연결해주는 것이다. 내 배포 방식에서는 HAProxy가 해당 역할을 해줄 것이므로 큰 의미는 없다.</p>\n<pre><code class=\"language-bash\">server {\n    listen 8080;\n    server_name _;\n\n    location / {\n        proxy_pass http://localhost:3141;\n        proxy_set_header Host $host;\n        proxy_http_version 1.1;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection 'upgrade';\n        proxy_cache_bypass $http_upgrade;\n    }\n\n    charset utf-8;\n}\n</code></pre>\n<h2>5.2.3. 트러블슈팅 - 내 컴퓨터에서만 접속이 안된다</h2>\n<p>그런데 문제가 생겼다. 다른 사람이 접속했을 때나 내 핸드폰 데이터, 아무튼 내가 배포하고 있는 서버 네트워크가 아닌 다른 네트워크에서는 접속이 잘 되는데 내 서버 네트워크, 그러니까 서버와 같은 IP를 쓰는 네트워크에서는 접속이 안된다.</p>\n<p>해결법은 내 IP로 접속할 때에 대한 설정을 해주면 된다. 이는 System - Advanced - Firewall &#x26; NAT에서 Network Address Translation에서 할 수 있다. 먼저 <code>NAT Reflection mode for port forwards</code>을 pure NAT로 바꾼다. 나는 원래 disabled로 되어 있었다.</p>\n<p>이를 활성화하면 NAT 규칙만 사용하여 포트포워딩을 하게 되는데 여기 서버가 클라이언트와 동일한 서브넷에 있는 경우에 대한 옵션을 더 설정할 수 있다. 좀더 아래로 내리면 나오는 <code>Enable automatic outbound NAT for Reflection</code>을 체크하면 된다.</p>\n<p><img src=\"/static/firewall-nat-setting-0c0587cb.png\" alt=\"firewall &#x26; nat 설정\"></p>\n<p><a href=\"https://docs.netgate.com/pfsense/en/latest/nat/reflection.html\">이 옵션들에 대한 더 자세한 설명은 공식 문서를 참고할 수 있다.</a></p>\n<h1>다음 글</h1>\n<p>아직 빌드도 자동이 아니고 방화벽 설정과 최적화 같은 것도 안되어 있어서 다음 섹션에서는 그런 부분들을 해결해보도록 하겠다.</p>\n<ul>\n<li>방화벽 설정</li>\n<li>빌드 자동화</li>\n<li>standalone 배포 등 최적화</li>\n</ul>\n<h1>참고</h1>\n<p>gatsby로 블로그 만들기 (<a href=\"https://vulcan.site/blog-gatsby/\">https://vulcan.site/blog-gatsby/</a>)</p>\n<p>나만의 홈서버 구축하기 - 1 <a href=\"https://velog.io/@kisuk623/Proxmox-%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0\">https://velog.io/@kisuk623/Proxmox-%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0</a></p>\n<p>Pfsense에서 포트포워딩(NAT)하기 <a href=\"https://svrforum.com/svr/27343\">https://svrforum.com/svr/27343</a></p>\n<p>Nginx를 이용하여 https 적용하는 법 <a href=\"https://gist.github.com/woorim960/dda0bc85599f61a025bb8ac471dfaf7a\">https://gist.github.com/woorim960/dda0bc85599f61a025bb8ac471dfaf7a</a></p>\n<p>Configuring pfSense firewall and HAProxy for maximum security rating at SSLLabs\n<a href=\"https://www.linkedin.com/pulse/configuring-pfsense-firewall-haproxy-maximum-security-goldhammer/\">https://www.linkedin.com/pulse/configuring-pfsense-firewall-haproxy-maximum-security-goldhammer/</a></p>\n<p>Installing HAProxy on pfSense with SSL access to web server <a href=\"https://gainanov.pro/eng-blog/linux/installing-haproxy-pfsense/\">https://gainanov.pro/eng-blog/linux/installing-haproxy-pfsense/</a></p>\n<p>SSL 오프로딩 <a href=\"https://minholee93.tistory.com/entry/SSL-offloading-%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C\">https://minholee93.tistory.com/entry/SSL-offloading-%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C</a></p>\n<p>How to Deploy a Next.js app to a Custom Server - NOT Vercel! (Full Beginner Tutorial) <a href=\"https://www.youtube.com/watch?app=desktop&#x26;v=HIb4Ucs_foQ\">https://www.youtube.com/watch?app=desktop&#x26;v=HIb4Ucs_foQ</a></p>\n<p>PM2를 활용한 Node.js 무중단 서비스하기 <a href=\"https://engineering.linecorp.com/ko/blog/pm2-nodejs\">https://engineering.linecorp.com/ko/blog/pm2-nodejs</a></p>\n<p><a href=\"https://www.lesstif.com/javascript/pm2-system-rebooting-125305469.html\">https://www.lesstif.com/javascript/pm2-system-rebooting-125305469.html</a></p>\n<p>Setup a Next.js project with PM2, Nginx and Yarn on Ubuntu 18.04 <a href=\"https://www.willandskill.se/en/articles/setup-a-next-js-project-with-pm2-nginx-and-yarn-on-ubuntu-18-04\">https://www.willandskill.se/en/articles/setup-a-next-js-project-with-pm2-nginx-and-yarn-on-ubuntu-18-04</a></p>\n<p>pfSense 와 함께 인터넷 사용하기\n<a href=\"https://blog.skylightqp.kr/292\">https://blog.skylightqp.kr/292</a></p>\n<p>cloudflare network port <a href=\"https://developers.cloudflare.com/fundamentals/reference/network-ports/\">https://developers.cloudflare.com/fundamentals/reference/network-ports/</a></p>\n<p>Lawrence Systems -\nHow To Guide For HAProxy and Let's Encrypt on pfSense: Detailed Steps for Setting Up Reverse Proxy <a href=\"https://www.youtube.com/watch?v=bU85dgHSb2E\">https://www.youtube.com/watch?v=bU85dgHSb2E</a></p>\n<p>How to activate HTTP2 on pfsense haproxy <a href=\"https://techoverflow.net/2020/12/29/how-to-activate-http2-on-pfsense-haproxy/\">https://techoverflow.net/2020/12/29/how-to-activate-http2-on-pfsense-haproxy/</a></p>",
    "excerpt": "\n서버 구축은 처음이고 저보다 조금 먼저 서버를 구축한 불칸님의 많은 도움을 받아가며 만들어진 글이라 많이 부족할 수 있습니다. 틀리거나 보충해야 할 부분이 있다면 댓글로 알려주시면 감사하겠습니다.\n\n\n이 글을 보고 홈서버를 세팅하려는 분이 계실지도 모르겠습니다. 제가 알고 있는 부분의 지식은 많은 생략이 있었기 때문에 네트워크에 대한 아주 기본적인 지식은 가지고 있어야 읽을 수 있습니다.\n\n홈 서버 만들기 - 초기 세팅, proxmox, pfsense에서 이어",
    "headingTree": [
      {
        "title": "1. 기초 설정",
        "url": "#1-기초-설정",
        "items": [
          {
            "title": "1.1. 컨테이너 만들기",
            "url": "#11-컨테이너-만들기",
            "items": []
          },
          {
            "title": "1.2. 컨테이너 설정",
            "url": "#12-컨테이너-설정",
            "items": []
          }
        ]
      },
      {
        "title": "2. pm2로 서버 실행",
        "url": "#2-pm2로-서버-실행",
        "items": [
          {
            "title": "2.1. 무엇을 할 것인가",
            "url": "#21-무엇을-할-것인가",
            "items": []
          },
          {
            "title": "2.2. pm2 설정",
            "url": "#22-pm2-설정",
            "items": [
              {
                "title": "2.2.1. 추가작업",
                "url": "#221-추가작업",
                "items": []
              }
            ]
          }
        ]
      },
      {
        "title": "3. 외부 접속 설정",
        "url": "#3-외부-접속-설정",
        "items": [
          {
            "title": "3.1. Cloudflare 설정",
            "url": "#31-cloudflare-설정",
            "items": []
          },
          {
            "title": "3.2. acme 세팅",
            "url": "#32-acme-세팅",
            "items": []
          },
          {
            "title": "3.3. HAProxy 설정",
            "url": "#33-haproxy-설정",
            "items": [
              {
                "title": "3.3.1. Settings",
                "url": "#331-settings",
                "items": []
              },
              {
                "title": "3.3.2. Backend",
                "url": "#332-backend",
                "items": []
              },
              {
                "title": "3.3.3. Frontend",
                "url": "#333-frontend",
                "items": []
              }
            ]
          },
          {
            "title": "3.4. rules 설정",
            "url": "#34-rules-설정",
            "items": []
          },
          {
            "title": "3.5. ssllab 테스트",
            "url": "#35-ssllab-테스트",
            "items": []
          },
          {
            "title": "3.6. 만약 안되면?",
            "url": "#36-만약-안되면",
            "items": []
          }
        ]
      },
      {
        "title": "4. HTTP2 설정",
        "url": "#4-http2-설정",
        "items": []
      },
      {
        "title": "5. 번외 - 다른 방법들",
        "url": "#5-번외---다른-방법들",
        "items": [
          {
            "title": "5.1. static export 배포",
            "url": "#51-static-export-배포",
            "items": []
          },
          {
            "title": "5.2. 다른 포트포워딩 방법들",
            "url": "#52-다른-포트포워딩-방법들",
            "items": [
              {
                "title": "5.2.1. pfsense에서 포트포워딩",
                "url": "#521-pfsense에서-포트포워딩",
                "items": []
              },
              {
                "title": "5.2.2. nginx 포트포워딩",
                "url": "#522-nginx-포트포워딩",
                "items": []
              }
            ]
          },
          {
            "title": "5.2.3. 트러블슈팅 - 내 컴퓨터에서만 접속이 안된다",
            "url": "#523-트러블슈팅---내-컴퓨터에서만-접속이-안된다",
            "items": []
          }
        ]
      },
      {
        "title": "다음 글",
        "url": "#다음-글",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 4,
      "wordCount": 1148
    },
    "url": "/posts/blog-home-server-2",
    "thumbnail": {
      "local": "/static/static-vs-pm2-68a1801d.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-static-vs-pm2-68a1801d-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAbElEQVR4nC2MoREFIQxErw6qiKQMJJI6sKkhGksPWDQ2PhYdvX/u8lftmze7D764e+99zhkI4AFwv4jIOSe6u/+FmYnIWsvM3P1dMHM8BKsqEZVSnr13ay1c9Fqrqr6CiJgZwBgjpZRzvvf+ALqYa8UeAJh3AAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "blog-home-server-3",
    "title": "홈 서버로 블로그 배포하기 - 더 좋은 배포를 향하여",
    "date": "2023-10-03T04:00:00Z",
    "description": "방화벽 설정, 자동 배포",
    "tags": [
      "blog"
    ],
    "html": "<blockquote>\n<p>서버 구축은 처음이고 저보다 조금 먼저 서버를 구축한 불칸님의 많은 도움을 받아가며 만들어진 글이라 많이 부족할 수 있습니다. 틀리거나 보충해야 할 부분이 있다면 댓글로 알려주시면 감사하겠습니다.</p>\n</blockquote>\n<p><a href=\"https://witch.work/posts/blog-home-server-2\">홈 서버로 블로그 배포하기 - 블로그 올리기</a>에서 이어지는 글입니다.</p>\n<h1>1. DDOS 막기</h1>\n<p>현재 <code>blog.witch.work</code>에서는 내 블로그가 돌아가고 있다. 다음과 같은 과정을 거쳐서 말이다.</p>\n<p><img src=\"/static/how-my-domain-works-8c8458e7.png\" alt=\"내 도메인 접속 구조\"></p>\n<p>하지만 여기에 누군가가 DDOS 공격을 하면 내 작은 용량의 서버는 무너질 것이다. 그래서 방화벽을 설정해주기로 했다.</p>\n<p><a href=\"https://blog.dalso.org/home-server/firewall/3358\">이 분야에서 국내의 굉장한 네임드 중 한 분인 달소님이 Pfsense방화벽 Dos,Ddos 막기. 라는 글을 이미 작성해 두셔서 거의 그대로 따라했다.</a></p>\n<h2>1.1. 필터링</h2>\n<p>하나의 소스 IP에서 초당 10회 이상 연결될 시 IP가 블락되도록 설정한다. <a href=\"https://m.blog.naver.com/brickbot/220416019291\">land attack</a>에서는 소스 ip가 제각각 이기 때문에 별 효력은 없다고 하지만 다른 공격 막는데는 유용하다고 한다.</p>\n<p>pfsense의 Firewall > Rules > WAN에서 외부 접속을 담당하는 443포트 rule을 편집하자.(이전 글을 보면, HAProxy에서 외부 접속은 모두 443포트에서 처리하도록 해놓았다)</p>\n<p><img src=\"/static/pfsense-interface-rule-8416d809.png\" alt=\"pfsense-rule\"></p>\n<p>아래로 내리면 Extra Options가 있는데 거기서 Advanced Options를 설정하자. Display Advanced를 누르면 설정창이 나타난다. <code>Max. src. conn. Rate</code>와 <code>Max. src. conn. Rates</code> 에서 초당 몇 개의 커넥션이 가능한지 설정할 수 있다. 나는 20으로 설정했다.</p>\n<p><img src=\"/static/max-src-conn-rate-efc445c6.png\" alt=\"max rate 설정\"></p>\n<h2>1.2. SYN Proxy 설정</h2>\n<p>SYN Proxy는 SYN Flood 공격을 막기 위한 방법이다. SYN Flood 공격은 TCP 3-way handshake 과정에서 SYN 패킷을 계속 보내서 서버의 자원을 고갈시키는 공격이다.</p>\n<p>SYN Proxy는 먼저 방화벽이 클라이언트와 3-way handshake를 하고 정상적으로 커넥션을 맺게 되었을 때 커넥션 정보를 서버에 전달하는 방식이다.</p>\n<p>이렇게 하면 서버는 정상적인 커넥션에 대한 정보만 받게 되기 때문에 SYN Flood 공격을 막을 수 있다.</p>\n<p>이 또한 Firewall > Rules > WAN에서 443포트 rule을 수정하는 것으로 할 수 있다.</p>\n<p><img src=\"/static/pfsense-interface-rule-8416d809.png\" alt=\"pfsense-rule\"></p>\n<p>아까처럼 Extra Options - Advanced Options를 설정하자. <code>State Type</code>을 <code>SYN Proxy</code>로 설정하면 된다.</p>\n<p><img src=\"/static/syn-proxy-dff331fa.png\" alt=\"syn proxy 설정\"></p>\n<p>이렇게 하고 Save - Apply Changes를 누르면 설정이 적용된다. SYN Proxy는 TCP 룰에 대해서만 적용된다.(애초에 3-way handshake에 기반한 것이니까) 따라서 룰을 TCP로 바꾸었다.</p>\n<h2>1.3. SYN 쿠키 사용</h2>\n<p>SYN 패킷에 대한 응답으로 SYN-ACK 패킷에 특별한 쿠키 값을 담아 보내는 것이다. 이 SYN-ACK 패킷에 대한 ACK가 올 경우 쿠키 값을 검증하여 제대로 된 값인 경우 연결을 형성한다.</p>\n<p>연결 수립에 필요한 정보들을 Cookie를 통해 보냄으로써 SYN Backlog Queue를 사용하지 않고 따라서 SYN Backlog Queue를 꽉 채우는 SYN Flood 공격을 막을 수 있다.</p>\n<p>System > Advanced - System Tunables에서 <code>net.inet.tcp.syncookies</code> 값을 1로 설정하면 된다. 나는 기본적으로 되어 있었다.</p>\n<p><img src=\"/static/syn-cookie-rule-76383f44.png\" alt=\"syn cookie 설정\"></p>\n<h1>2. 자동 배포</h1>\n<p>현재 <code>blog.witch.work</code>에 배포되어 있는 내 블로그는 git에 내가 뭔가 코드 업데이트를 하고 나면 내가 직접 서버에 접속해서 다음과 같은 커맨드로 업데이트해야 한다.</p>\n<pre><code class=\"language-bash\">git pull origin main\nyarn run build\npm2 restart blog\n</code></pre>\n<p>이를 자동화하고 싶은데 자료가 정말 없었다. 일단 어떻게 해야 하는지 생각을 해보자.</p>\n<h2>2.1. 구상</h2>\n<p>이런 자동 배포를 하기 위한 가장 간단한 툴은 내가 알기로 Github action이다. Github action은 Github에서 제공하는 CI/CD 툴이다. 따라서 이걸 사용하자. 어차피 무슨 툴이든 초보인 건 마찬가지니까...</p>\n<p>그러면 github에 push 이벤트가 발생했을 때 ssh로 내 proxmox 컨테이너에 접속해서 위의 스크립트를 실행하면 되겠다. 해당 컨테이너 내부에 <code>deploy.sh</code>같은 폴더를 만들어 놓아도 좋을 테고 말이다.</p>\n<h2>2.2. ssh 접속하기</h2>\n<p>ssh 접속을 위해서는 계정을 만들어야 한다. 물론 <code>/etc/ssh/sshd_config</code>에서 <code>PermitRootLogin</code>을 <code>yes</code>로 바꾸면 root로 접속할 수 있지만 보안상 좋지 않다. 따라서 새 계정을 만들자.</p>\n<pre><code class=\"language-bash\">sudo adduser 내_아이디\nsudo passwd 내_아이디\n-> 비밀번호 입력\n</code></pre>\n<p>이렇게 하고 내부망 ip로 접속해 보자. <code>ssh 내_아이디@내부망ip</code>로 접속하면 비밀번호를 치고 내 블로그 컨테이너에 들어갈 수 있었다.</p>\n<p>이제 외부 ip 접속 허용을 할 것이다. 그런데 그전에 ssh 서버 설정 파일을 만져주자. ssh는 기본적으로 22번 포트에서 접속하는데 이는 너무 흔하니까 다른 포트번호를 사용해 줄 것이다. nano로 설정 파일을 열자.</p>\n<pre><code class=\"language-bash\">sudo nano /etc/ssh/sshd_config\n</code></pre>\n<p>위 커맨드로 ssh 설정파일을 열어보면 <code>#Port 22</code>라고 되어 있는 부분이 있다. 이 부분을 <code>Port 내가_쓸_포트번호</code>로 바꿔주자. 그 다음 변경한 설정을 적용하기 위해 서버 데몬을 재시작하자.</p>\n<pre><code class=\"language-bash\">sudo systemctl restart sshd\n</code></pre>\n<p>그럼 이제 <code>ssh 내_아이디@내부망ip -p 내가_쓸_포트번호</code>로 접속해야 내 블로그 컨테이너로 갈 수 있다.</p>\n<p>외부 ip 접속을 위해서는 포트포워딩을 해줘야 한다. 현재 포트포워딩은 pfsense에서 하고 있으므로 pfsense firewall 부분을 설정해 주자.</p>\n<p>Firewall - NAT - Port Forward에서 Add를 눌러 새로운 포트포워딩을 만들어 주자. 말 그대로 외부 IP의 특정 포트를 내부 IP의 특정 포트로 포워딩 해주면 된다.</p>\n<p><img src=\"/static/ssh-portforwarding-06c5b6fe.png\" alt=\"ssh 포트포워딩\"></p>\n<p>이렇게 하고 apply 해주면 외부 ip의 특정 포트에 ssh로 접속하면 내 블로그 컨테이너로 연결된다.</p>\n<p>그런데 현재 pfsense firewall에서는 해당 포트를 막고 있을 것이다. 따라서 이를 허용해 주어야 한다.</p>\n<p>Firewall - Rules - WAN에서 Add를 눌러 새로운 룰을 만들어 주자. 아래와 같이 설정하면 된다. 모든 소스에서 22443 포트로 들어오는 요청을 허용한다.</p>\n<p><img src=\"/static/ssh-firewall-rule-37d09afd.png\" alt=\"ssh firewall\"></p>\n<p>이제 다음과 같은 커맨드를 통해 내 컨테이너로 접속할 수 있다.</p>\n<pre><code class=\"language-bash\">ssh 내_아이디@내_외부ip -p 내가_포트포워딩해준_포트번호\n</code></pre>\n<p>만약 <code>Connection refused</code>가 뜨면 ssh 서비스가 서버에서 실행되고 있는지 한번 확인해보자. 안되고 있다면 시작해 주면 된다.</p>\n<pre><code class=\"language-bash\">sudo service ssh start\n</code></pre>\n<p>여기서 뭔가 꼬이면 이후에 github action에서 i/o timeout 으로 인한 실패를 겪게 되므로 잘 해두자.</p>\n<h2>2.3. Github Actions</h2>\n<p>이를 Github Actions로 자동화해보자. Github Actions는 <code>.github/workflows</code> 폴더에 <code>.yml</code> 파일을 만들어서 사용한다. 나는 <code>main.yml</code>이라는 이름으로 만들었다.</p>\n<p><a href=\"https://github.com/appleboy/ssh-action\">당연히 이미 누가 이를 위한 <code>ssh-action</code>이라는 라이브러리를 만들어 놓았다. 따라서 이를 사용한다.</a></p>\n<p>해당 라이브러리에서 제공하는 예시를 보면 다음과 같다. timeout과 script만 약간 고쳤다.</p>\n<pre><code class=\"language-yml\">name: CICD\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: executing remote ssh commands using password\n      uses: appleboy/ssh-action@v1.0.0\n      with:\n        host: ${{ secrets.HOST }}\n        username: ${{ secrets.USERNAME }}\n        password: ${{ secrets.PASSWORD }}\n        port: ${{ secrets.PORT }}\n        timeout: 60s\n        script: |\n          whoami\n          echo \"cicd\"\n</code></pre>\n<p><code>secrets</code>는 Github에서 제공하는 비밀 정보를 저장하는 공간이다. 이를 통해 Github Actions에서도 비밀 정보를 사용할 수 있다. 따라서 이를 설정해 주자.</p>\n<p>github 레포지토리 - Settings - Secrets and variables에서 <code>New repository secret</code>버튼으로 새로운 비밀 정보를 추가해 줄 수 있다. 내가 사용한 비밀 정보는 다음과 같다.</p>\n<pre><code>HOST: 내_외부ip\nUSERNAME: 내_아이디\nPASSWORD: 내_비밀번호\nPORT: 내가_포트포워딩해준_포트번호\n</code></pre>\n<p><img src=\"/static/github-secrets-331a73fc.png\" alt=\"github secrets\"></p>\n<h2>2.4. SSH key로 접속 설정</h2>\n<p>하지만 잠깐! 이렇게 하면 내 비밀번호를 알고 있는 사람은 내 컨테이너에 아주 쉽게 접속할 수 있게 된다. 물론 어차피 github에도 로컬에도 모든 파일이 다 있으니 누가 내 비밀번호를 알아서 컨테이너 자료를 싹 날린다 해도 큰 타격은 없지만 그래도 보안을 강화해보자.</p>\n<p>ssh key를 통해서만 ssh로 컨테이너에 접속할 수 있게 하고 github actions에서도 ssh key를 통해 접속하게 하자.</p>\n<p><a href=\"https://github.com/appleboy/ssh-action#setting-up-a-ssh-key\">ssh-actions 라이브러리에서는 이를 위한 가이드도 아주 잘 제공하고 있다. 그러니 이를 따라하자.</a></p>\n<p><a href=\"https://bug41.tistory.com/entry/Github-Github-Actions-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94%EB%B2%95-SSH-%EC%97%B0%EA%B2%B0\">이에 관련된 티스토리 글도 도움이 된다.</a></p>\n<p>먼저 rsa 키를 만드는 커맨드를 실행하자. 이때 라이브러리 가이드를 보면 다음과 같은 문장이 있다. 이는 원격(나 같은 경우엔 proxmox) 환경이 아니라 로컬, 그러니까 나 같은 경우 맥북 환경에서 실행해야 한다는 뜻이다.</p>\n<pre><code>The best practice is create the SSH Keys on local machine not remote machine.\n</code></pre>\n<p>아무튼 이 커맨드를 맥 터미널에서 실행하자.</p>\n<p>다음 커맨드에서 내 github 이메일을 입력하는 건 그냥 내가 알아보기 위함이니 안 해도 큰 상관은 없다. 아무튼 다음 커맨드를 실행하면 <code>~/.ssh/id_rsa</code>와 <code>~/.ssh/id_rsa.pub</code>가 생성된다.</p>\n<pre><code class=\"language-bash\">ssh-keygen -t rsa -b 4096 -C \"내_github_이메일\"\n</code></pre>\n<p>참고로 <code>-t</code>는 암호 타입, <code>-b</code>는 비트 수, <code>-C</code>는 주석(주석이라 하는 게 맞을지 모르겠지만 원문은 comment)이다.</p>\n<p>이제 이 중 공개키 내용을 서버의 인증키 목록에 넣어주자.</p>\n<pre><code class=\"language-bash\">cat .ssh/id_rsa.pub | ssh [내_id]@[내_컨테이너_ip] -p [포트번호] 'cat >> .ssh/authorized_keys'\n</code></pre>\n<p>이제 github에 내 개인 키를 <code>secret</code>에 등록해 줘야 한다.</p>\n<p>위에서 했던 것과 같이 github 레포지토리 - Settings - Secrets and variables에서 <code>New repository secret</code>버튼으로 새로운 비밀 정보를 추가해 주자. <code>KEY</code>라는 이름으로 등록하자.</p>\n<p>내 개인 키의 내용을 그대로 붙여넣으면 된다. 이는 <code>pbcopy</code> 명령어를 이용할 수 있다. 다음 명령어를 맥에서 실행하면 내 개인 키가 클립보드에 복사된다.</p>\n<pre><code class=\"language-bash\">pbcopy &#x3C; ~/.ssh/id_rsa\n</code></pre>\n<p>그다음 <code>main.yml</code>을 다음과 같이 수정한다. password 대신 key를 사용하도록 하자.</p>\n<pre><code class=\"language-yml\">name: CICD\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: executing remote ssh commands using password\n      uses: appleboy/ssh-action@v1.0.0\n      with:\n        host: ${{ secrets.HOST }}\n        username: ${{ secrets.USERNAME }}\n        # 이 부분만 수정하면 된다\n        key: ${{ secrets.KEY }}\n        port: ${{ secrets.PORT }}\n        timeout: 60s\n        script: |\n          whoami\n          echo \"cicd\"\n</code></pre>\n<h3>2.4.1. ssh key 로만 접속 가능하게 설정</h3>\n<p>아예 password를 통한 접속을 막아 버릴 수도 있다. ssh 데몬 설정파일에 들어가자.</p>\n<pre><code class=\"language-bash\">sudo nano /etc/ssh/sshd_config\n</code></pre>\n<p>거기서 훑어보면 다음과 같은 부분이 있다. 기본적으로 주석처리가 되어 있을 것이다. 이는 password로 접속하는 것을 허용할지를 설정하는 부분인데 디폴트 값이 yes이므로 우리는 비밀번호를 통해서 ssh 접속을 할 수 있었던 것이다.</p>\n<p>이를 주석처리 해제하고 <code>no</code>로 바꿔주자.</p>\n<pre><code class=\"language-bash\"># To disable tunneled clear text passwords, change to no here!\nPasswordAuthentication no \n</code></pre>\n<p>그리고 ssh 데몬을 재시작하자.</p>\n<pre><code class=\"language-bash\">sudo systemctl restart sshd\n</code></pre>\n<p>이렇게 하고 나면 패스워드를 통해 ssh에 접속하려고 할 시 <code>Permission denied (publickey).</code>라는 메시지가 뜨면서 접속이 거부되게 된다. 단 우리가 설정한 github action은 잘 작동한다. KEY를 넣어 줬기 때문이다.</p>\n<p>이제 github action 스크립트로 원래 실행하려고 했던 커맨드를 실행해보자.</p>\n<h2>2.5. 쉘스크립트 작성</h2>\n<p>먼저 내 블로그가 배포되고 있는 컨테이너에 위에서 작성한 스크립트를 넣어주자. 나는 <code>/home/witch/build.sh</code>에 넣었다.</p>\n<pre><code class=\"language-bash\">cd witch-next-blog\necho \"in my blog page\"\n\ngit pull origin main\necho \"recent job pull done\"\n\nyarn run build\necho \"yarn build done\"\n\npm2 restart blog\necho \"process restart done\"\n</code></pre>\n<p><code>bash build.sh</code>를 실행하면 위 커맨드가 실행되는 것을 볼 수 있다. 이제 github action의 ssh 접속 후 스크립트에서 이를 실행하면 된다.</p>\n<pre><code class=\"language-bash\">    steps:\n    - name: executing remote ssh commands using password\n      uses: appleboy/ssh-action@v1.0.0\n      with:\n        host: ${{ secrets.HOST }}\n        username: ${{ secrets.USERNAME }}\n        key: ${{ secrets.KEY }}\n        port: ${{ secrets.PORT }}\n        timeout: 60s\n        script: |\n          whoami\n          echo \"cicd\"\n          # 이 커맨드 추가\n          bash build.sh\n</code></pre>\n<h1>3. 트러블슈팅 - 환경 변수 문제</h1>\n<h2>3.1. 문제 개요</h2>\n<p>그런데 이렇게 하고 나서 <code>bash build.sh</code>를 실행하면 문제가 생긴다. 사실 원래부터 있던 문제였는데 지금까지 덮어 왔던 것 뿐이다...<code>contentlayer build</code>에서 다음과 같은 에러가 발생한다. 마크다운 파일을 제대로 변환할 수 없다는 것이다.</p>\n<pre><code class=\"language-bash\">Error: Found 184 problems in 184 documents.\n\n └── Encountered unexpected errors while processing of 184 documents. This is possibly a bug in Contentlayer. Please open an issue.\n\n     • \"binary-search/index.md\": UnexpectedMarkdownError: Must supply api_key\n     # api_key를 찾을 수 없다는 위와 같은 에러들...\n\nerror Command failed with exit code 1.\n</code></pre>\n<p>그럼 지금까지는 어떻게 해결해 왔는가? <code>yarn dev</code>를 먼저 하고, contentlayer의 document 생성을 완료한 후 다시 <code>yarn run build</code>를 해주면 잘 돌아갔었다. 하지만 github action에서 쉘 파일을 실행하는 방식에서 이 방식을 쓰기 힘들다. 따라서 본격적으로 원인을 추적해 보기로 했다.</p>\n<h2>3.2. 원인 추적</h2>\n<p>위에서는 contentlayer error일 수도 있다면서 이슈를 올리라고 했는데, 사실 그럴 가능성은 상당히 낮다. 따라서 왜 이 에러가 발생했는지 일단 내 프로그램에서 원인을 찾아보기로 했다.</p>\n<p>먼저, 위에서 나온 <code>api_key</code>라는 건 어디서 사용되고 있는 걸까? 몇 달 전 <a href=\"https://witch.work/posts/blog-remake-9\">글의 썸네일을 자동으로 생성해서 넣어 주는 remark 플러그인</a>을 작성했었다. 그리고 <a href=\"https://witch.work/posts/blog-opt-3\">이 썸네일을 cloudinary CDN에 자동으로 업로드하는 최적화를 진행했었다.</a></p>\n<p><code>api_key</code>는 이 cloudinary 자동 업로드에 쓰이는 부분이었다. <code>src/utils/cloudinary.ts</code>에 다음과 같이 설정 객체가 있었다.</p>\n<pre><code class=\"language-ts\">// src/utils/cloudinary.ts\nimport { v2 as cloudinary } from 'cloudinary';\n\ncloudinary.config({\n  cloud_name: process.env.NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME,\n  api_key: process.env.CLOUDINARY_API_KEY,\n  api_secret: process.env.CLOUDINARY_API_SECRET,\n  secure: true,\n});\n\nexport default cloudinary;\n</code></pre>\n<p>그러니까, 빌드 시점에 contentlayer에서는 <code>.md</code>파일들을 JSON으로 변환하는데 그때 사용하는 remark plugin 중 내가 직접 만든 파일인 <code>make-thumbnail.mjs</code>가 있었고 거기서 <code>process.env.CLOUDINARY_API_KEY</code> 환경 변수를 사용한다. 이 환경 변수를 찾지 못해서 에러가 발생한 것이다.</p>\n<p>그런데 어떻게 <code>yarn dev</code>커맨드에서는 잘 변환했을까? <code>yarn dev</code> 커맨드를 쳤을 때 메시지를 한번 보자.</p>\n<pre><code class=\"language-bash\">me@me-ui-MacBookAir nextjs-blog % yarn dev\nyarn run v1.22.19\n$ yarn run copyimages\n$ node ./src/bin/pre-build.mjs\n$ next dev\n- info Loaded env from /Users/kimsunghyun/Desktop/nextjs-blog/.env.local\n- ready started server on [::]:3000, url: http://localhost:3000\n- event compiled client and server successfully in 933 ms (20 modules)\n- wait compiling...\nContentlayer config change detected. Updating type definitions and data...\n- event compiled client and server successfully in 146 ms (20 modules)\n- info Loaded env from /Users/kimsunghyun/Desktop/nextjs-blog/.env.local\n- info Loaded env from /Users/kimsunghyun/Desktop/nextjs-blog/.env.local\nGenerated 184 documents in .contentlayer\n</code></pre>\n<p><a href=\"https://nextjs.org/docs/app/building-your-application/configuring/environment-variables\"><code>nextjs</code>에서는 알아서 <code>.env</code> 계열 파일들을 로드해서 사용할 수 있게 해준다.</a> 위에서도 <code>info Loaded env ...</code>하는 메시지를 통해 이를 확인할 수 있다.</p>\n<p>그럼 <code>yarn dev</code>를 한 이후 <code>yarn run build</code>를 했을 때, 그러니까 빌드가 정상적으로 될 때는 어떨까? 다음과 같은 메시지를 확인할 수 있다.</p>\n<pre><code class=\"language-bash\">me@me-ui-MacBookAir nextjs-blog % yarn run build\nyarn run v1.22.19\n$ yarn run copyimages\n$ node ./src/bin/pre-build.mjs\n$ contentlayer build &#x26;&#x26; next build\nGenerated 184 documents in .contentlayer\n- info Loaded env from /Users/kimsunghyun/Desktop/nextjs-blog/.env.local\nGenerated 184 documents in .contentlayer\n- info Creating an optimized production build\n- info Compiled successfully\n# 이하 생략\n</code></pre>\n<p>메시지를 잘 관찰해 보면 <code>yarn dev</code>에서는 먼저 <code>.env.local</code>을 로딩하고 contentlayer의 문서 변환을 진행하는 것을 알 수 있다. 따라서 <code>yarn dev</code>에서는 contentlayer 작업 시점에 <code>api_key</code>같은 환경 변수들이 다 있으므로 썸네일 cloudinary 업로드가 잘되고 <code>yarn run build</code>에서는 contentlayer 작업 시점에 환경 변수들이 아직 로딩되지 않았으므로 에러가 발생하는 것이다.</p>\n<blockquote>\n<p>썸네일 제작 외에 다른 작업에서는 환경 변수를 사용하지 않으므로 <code>contentlayer.config.js</code>의 <code>remarkPlugins</code>에서 <code>makeThumbnail</code>을 제거하면 빌드가 잘 되었다.</p>\n</blockquote>\n<p><code>yarn dev</code>와 <code>yarn run build</code>의 차이와 문제 상황을 요약하면 다음과 같다.</p>\n<p><img src=\"/static/yarn-dev-and-yarn-build-7b301173.png\" alt=\"문제 상황\"></p>\n<p>따라서 문제 해결은, <code>contentlayer build</code>이전에 환경 변수들을 로딩해 주면 된다. 참고로 Vercel 배포에서는 이런 문제가 없었는데 vercel의 빌드 커맨드의 경우 미리 환경 변수들을 로딩해 줘서 이런 문제가 없는 것 같다.</p>\n<h2>3.3. 문제 해결...</h2>\n<p>nextjs의 자동 환경 변수 로딩을 좀 더 빨리 할 수 있는지를 알아보았지만 그건 시간이 없어서 일단은 <code>contentlayer build</code> 이전에 환경 변수들을 로딩해 주는 방식으로 문제를 해결했다.</p>\n<p><a href=\"https://www.daleseo.com/js-node-process-env/\">유닉스 계열인 MacOS에서는 <code>export</code>명령어를 이용해서 환경 변수를 설정할 수 있다.</a> 따라서 <code>build.sh</code>에 다음과 같이 추가해 주었다. <code>환경변수_값</code>부분은 내가 사용하는 환경 변수들의 값이다. 로컬에 있는 <code>.env.local</code>의 값들을 복붙해 주었다.</p>\n<pre><code class=\"language-bash\">cd witch-next-blog\necho \"in my blog page\"\n\ngit pull origin main\necho \"recent job pull done\"\n\nexport NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME=환경변수_값\nexport CLOUDINARY_API_KEY=환경변수_값\nexport CLOUDINARY_API_SECRET=환경변수_값\nexport CLOUDINARY_URL=환경변수_값\necho \"environment variable setting\"\n\nyarn run build\necho \"yarn build done\"\n\npm2 restart blog\necho \"process restart done\"\n</code></pre>\n<p>그리고 github action을 위한 파일 <code>.github/workflows/main.yml</code>을 다음과 같이 수정했다. <code>script</code>부분에 <code>bash build.sh</code>를 추가해 주고 타임아웃을 좀 더 넉넉히 주었다.</p>\n<pre><code class=\"language-yml\">name: CICD\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: executing remote ssh commands using password\n      uses: appleboy/ssh-action@v1.0.0\n      with:\n        host: ${{ secrets.HOST }}\n        username: ${{ secrets.USERNAME }}\n        key: ${{ secrets.KEY }}\n        port: ${{ secrets.PORT }}\n        timeout: 180s\n        script: |\n          whoami\n          echo \"cicd\"\n          bash build.sh\n</code></pre>\n<p>이렇게 한 후 main 브랜치에 푸시하자 github action이 잘 작동하고 <code>yarn run build</code>와 배포도 잘 작동하는 것을 확인할 수 있었다.</p>\n<h1>참고</h1>\n<p>Pfsense방화벽 Dos,Ddos 막기 <a href=\"https://blog.dalso.org/home-server/firewall/3358\">https://blog.dalso.org/home-server/firewall/3358</a></p>\n<p>SYN Proxy <a href=\"https://yunseoks.tistory.com/41\">https://yunseoks.tistory.com/41</a></p>\n<p>Syn Cookie <a href=\"https://itwiki.kr/w/Syn_Cookie\">https://itwiki.kr/w/Syn_Cookie</a></p>\n<p>Ubuntu 22.04 ssh 접속 허용(활성화), 포트 설정, 접속 방법 <a href=\"https://osg.kr/archives/1269\">https://osg.kr/archives/1269</a></p>\n<p>Github Actions, 외부 서버에 SSH로 접속해서 커맨드 실행하기\n<a href=\"https://velog.io/@sweetchip/Github-Actions-%EC%99%B8%EB%B6%80-%EC%84%9C%EB%B2%84%EC%97%90-SSH%EB%A1%9C-%EC%A0%91%EC%86%8D%ED%95%B4%EC%84%9C-%EC%BB%A4%EB%A7%A8%EB%93%9C-%EC%8B%A4%ED%96%89%ED%95%98%EA%B8%B0\">https://velog.io/@sweetchip/Github-Actions-%EC%99%B8%EB%B6%80-%EC%84%9C%EB%B2%84%EC%97%90-SSH%EB%A1%9C-%EC%A0%91%EC%86%8D%ED%95%B4%EC%84%9C-%EC%BB%A4%EB%A7%A8%EB%93%9C-%EC%8B%A4%ED%96%89%ED%95%98%EA%B8%B0</a></p>\n<p>GitHub Actions 시작하기 <a href=\"https://velog.io/@jeongs/GitHub-Actions-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0\">https://velog.io/@jeongs/GitHub-Actions-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0</a></p>\n<p>[Github] Github Actions 사용하는법 , SSH 연결\n<a href=\"https://bug41.tistory.com/entry/Github-Github-Actions-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94%EB%B2%95-SSH-%EC%97%B0%EA%B2%B0\">https://bug41.tistory.com/entry/Github-Github-Actions-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94%EB%B2%95-SSH-%EC%97%B0%EA%B2%B0</a></p>\n<p>Disable password authentication for SSH <a href=\"https://stackoverflow.com/questions/20898384/disable-password-authentication-for-ssh\">https://stackoverflow.com/questions/20898384/disable-password-authentication-for-ssh</a></p>\n<p>Node.js에서 환경 변수 다루기 (process.env) <a href=\"https://www.daleseo.com/js-node-process-env/\">https://www.daleseo.com/js-node-process-env/</a></p>\n<p>nextjs - Environment Variables 문서 <a href=\"https://nextjs.org/docs/app/building-your-application/configuring/environment-variables\">https://nextjs.org/docs/app/building-your-application/configuring/environment-variables</a></p>",
    "excerpt": "\n서버 구축은 처음이고 저보다 조금 먼저 서버를 구축한 불칸님의 많은 도움을 받아가며 만들어진 글이라 많이 부족할 수 있습니다. 틀리거나 보충해야 할 부분이 있다면 댓글로 알려주시면 감사하겠습니다.\n\n홈 서버로 블로그 배포하기 - 블로그 올리기에서 이어지는 글입니다.\n1. DDOS 막기\n현재 blog.witch.work에서는 내 블로그가 돌아가고 있다. 다음과 같은 과정을 거쳐서 말이다.\n\n하지만 여기에 누군가가 DDOS 공격을 하면 내 작은 용량의 서버는 무너",
    "headingTree": [
      {
        "title": "1. DDOS 막기",
        "url": "#1-ddos-막기",
        "items": [
          {
            "title": "1.1. 필터링",
            "url": "#11-필터링",
            "items": []
          },
          {
            "title": "1.2. SYN Proxy 설정",
            "url": "#12-syn-proxy-설정",
            "items": []
          },
          {
            "title": "1.3. SYN 쿠키 사용",
            "url": "#13-syn-쿠키-사용",
            "items": []
          }
        ]
      },
      {
        "title": "2. 자동 배포",
        "url": "#2-자동-배포",
        "items": [
          {
            "title": "2.1. 구상",
            "url": "#21-구상",
            "items": []
          },
          {
            "title": "2.2. ssh 접속하기",
            "url": "#22-ssh-접속하기",
            "items": []
          },
          {
            "title": "2.3. Github Actions",
            "url": "#23-github-actions",
            "items": []
          },
          {
            "title": "2.4. SSH key로 접속 설정",
            "url": "#24-ssh-key로-접속-설정",
            "items": [
              {
                "title": "2.4.1. ssh key 로만 접속 가능하게 설정",
                "url": "#241-ssh-key-로만-접속-가능하게-설정",
                "items": []
              }
            ]
          },
          {
            "title": "2.5. 쉘스크립트 작성",
            "url": "#25-쉘스크립트-작성",
            "items": []
          }
        ]
      },
      {
        "title": "3. 트러블슈팅 - 환경 변수 문제",
        "url": "#3-트러블슈팅---환경-변수-문제",
        "items": [
          {
            "title": "3.1. 문제 개요",
            "url": "#31-문제-개요",
            "items": []
          },
          {
            "title": "3.2. 원인 추적",
            "url": "#32-원인-추적",
            "items": []
          },
          {
            "title": "3.3. 문제 해결...",
            "url": "#33-문제-해결",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 4,
      "wordCount": 1121
    },
    "url": "/posts/blog-home-server-3",
    "thumbnail": {
      "local": "/static/how-my-domain-works-8c8458e7.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-how-my-domain-works-8c8458e7-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAh0lEQVR4nD3JMQ6CMBQA0F6iF8LTlBGnf4peQoITg5sxdFJ3E/onZTH8VGMLg6Vs38Sgb30CAIwxUspNWSIiABARM4vuS2vdWouISuWX1u72RvDPoWlWWQYAIYR775Z4x3i9dVW1LYo1EaU0L5FSGoaRmeu6fjgXp+kf8/PlfQhK5cfT2YfxA+N0c2vxllRMAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "blog-new-view-counter",
    "title": "블로그 고치기 - 블로그에 조회수 달기",
    "date": "2024-02-18T00:00:00Z",
    "description": "없어졌던 블로그의 조회수 카운터를 다시 달아주자",
    "tags": [
      "front",
      "blog"
    ],
    "html": "<h1>시작</h1>\n<p>이전에 블로그를 만들면서 <a href=\"https://witch.work/posts/blog-remake-11\">블로그 만들기 - 11. 글 조회수 달기</a>에서 조회수 카운터를 달았던 바 있다. 하지만 수많은 오류 등으로 인해 슬쩍 없애 버렸었다. 이를 다시 만들어 주도록 하겠다.</p>\n<p><a href=\"https://upstash.com/blog/nextjs13-approuter-view-counter\">Adding a View Counter to your Next.js Blog</a>라는 글을 참고하였다.</p>\n<p><a href=\"https://upstash.com/\">upstash Redis</a>가 하루에 10000회의 무료 사용량이 있고 NoSQL이라 key-value 기반이므로 조회수 카운터에 적합하다고 보았다. 또한 upstash 공식 블로그 글이라 신뢰도가 높다고 판단하였다.</p>\n<h1>1. 기본 설정</h1>\n<p>먼저 upstash 로그인을 하고(나는 구글 로그인을 썼다) <a href=\"https://console.upstash.com/\">upstash 콘솔</a>에서 새로운 데이터베이스를 만들어 주자. 이름은 <code>witch-blog-view-counter</code>로 하고 리전은 가장 가까울 것 같은 일본 리전으로 선택하였다.</p>\n<p>트래픽 SSL 암호화와 max size를 초과하는 요청을 거부하는 설정이 있길래 켜두었다.</p>\n<p><img src=\"/static/create-db-94ac9147.png\" alt=\"db 생성하기\"></p>\n<p>그리고 DB 대시보드에 나오는 REST 연결 정보 중 <code>.env</code>항목을 <code>.env.local</code>에 추가해 주자.</p>\n<pre><code class=\"language-env\">UPSTASH_REDIS_REST_URL=...\nUPSTASH_REDIS_REST_TOKEN=...\n</code></pre>\n<p>그리고 redis 패키지를 설치하자. 이걸로 기본적인 준비는 끝났다.</p>\n<pre><code class=\"language-bash\">yarn add @upstash/redis\n</code></pre>\n<h1>2. 조회수 증가 로직</h1>\n<p>라우트 핸들러를 만들어서 조회수를 증가시키는 로직을 만들자. <code>app/viewcount/route.ts</code>를 만들어서 <code>/viewcount</code>에서 post 요청을 받도록 한다.</p>\n<p><code>Redis.fromEnv()</code>는 환경 변수에서 <code>UPSTASH_REDIS_REST_URL</code>, <code>UPSTASH_REDIS_REST_TOKEN</code>을 자동으로 읽어와서 Redis 인스턴스를 만들어 준다.</p>\n<p>request body에서 <code>slug</code>를 받아서 <code>pageviews:projects:${slug}</code> 키의 값을 1 증가시킨다. <code>incr</code>은 키가 없을 경우 0으로 초기화하고 1을 더해주는 동작을 한다.</p>\n<pre><code class=\"language-ts\">// app/viewcount/route.ts\nimport { Redis } from '@upstash/redis';\nimport { NextRequest, NextResponse } from 'next/server';\n\nconst redis = Redis.fromEnv();\n\nexport async function POST(request: NextRequest): Promise&#x3C;NextResponse> {\n  const body = await request.json();\n  const slug = body.slug as string | undefined;\n\n  // body에 slug가 없을 경우\n  if (!slug) {\n    return new NextResponse('Slug not found', { status: 400 });\n  }\n\n  await redis.incr(['pageviews', 'projects', slug].join(':'));\n  return new NextResponse(null, { status: 202 });\n}\n</code></pre>\n<h2>2.1. 중복 방지</h2>\n<p>그런데 지금의 조회수 증가 로직은 중복 요청에 대한 처리가 없다. 이를 해결하기 위해 유저의 IP 주소를 기준으로 중복 요청을 막아주자.</p>\n<p>이는 <code>request.ip</code> 혹은 <code>X-Fowarded-For</code> 헤더를 이용하여 구현할 수 있다. 이를 사용자가 변조할 수 있는 건 맞는데 조회수 카운터를 아주 정확하게 관리하려고 하는 것은 아니므로 이 정도로도 충분하다.</p>\n<p>다만 IP 주소를 그대로 저장하면 보안 문제가 있을 수 있다고 하므로 해싱하여 저장하자. 이를 위해 <code>crypto</code> 패키지를 사용하자. ip의 해시값은 다음과 같이 만들 수 있다.</p>\n<pre><code class=\"language-ts\">const ip = request.ip ?? request.headers.get('X-Forwarded-For');\n\nif (ip) {\n  // Hash the IP and turn it into a hex string\n  const buf = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(ip));\n  const hash = Array.from(new Uint8Array(buf))\n    .map((b) => b.toString(16).padStart(2, '0'))\n    .join('');\n\n  // ...\n}\n</code></pre>\n<p>그리고 <code>deduplicate:</code>로 시작하는 키를 만들고 값을 true로 설정하는 <code>set</code>요청을 보내자. 또한 키가 <code>60*60</code>초 즉 1시간 동안 유지되며 키가 만료되었을 시에만 값을 쓰도록 하자. 이는 <code>NX</code>와 expire time을 나타내는 <code>EX</code> 옵션을 사용하여 구현할 수 있다.</p>\n<p>또한 만약 ip 중복이 아니거나 ip가 없을 경우에만 조회수를 증가시키도록 하자. 이를 전부 구현한 <code>POST</code> 핸들러는 다음과 같다.</p>\n<pre><code class=\"language-ts\">export async function POST(request: NextRequest): Promise&#x3C;NextResponse> {\n  const body = await request.json();\n  const slug = body.slug as string | undefined;\n\n  if (!slug) {\n    return new NextResponse('Slug not found', { status: 400 });\n  }\n\n  const ip = request.ip ?? request.headers.get('X-Forwarded-For');\n\n  if (ip) {\n  // Hash the IP and turn it into a hex string\n    const buf = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(ip));\n    const hash = Array.from(new Uint8Array(buf))\n      .map((b) => b.toString(16).padStart(2, '0'))\n      .join('');\n\n    const isNewView = await redis.set(['deduplicate', hash, slug].join(':'), true, {\n      nx: true,\n      ex: 60 * 60,\n    });\n    if (!isNewView) {\n      return new NextResponse(null, { status: 202 });\n    }\n  }\n\n  await redis.incr(['pageviews', 'projects', slug].join(':'));\n\n  return new NextResponse(null, { status: 202 });\n}\n</code></pre>\n<h2>2.2. 조회수 증가 컴포넌트</h2>\n<p>조회수를 증가시키는 작업을 하는 컴포넌트를 만들자. <code>ViewReporter</code> 라는 컴포넌트에서 props로 <code>slug</code>를 받아서 작업할 것이다. <code>useEffect</code> 훅을 사용하므로 클라이언트 컴포넌트로 만들어 줘야 하고, 특별히 렌더링할 것이 없으므로 <code>null</code>을 반환하도록 하자.</p>\n<pre><code class=\"language-tsx\">// components/ViewReporter.tsx\n'use client';\n\nimport { useEffect } from 'react';\n\nfunction ViewReporter({ slug }: {slug: string}) {\n  useEffect(() => {\n    fetch('/viewcount', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({ slug }),\n    });\n  }, [slug]);\n\n  return null;\n}\n\nexport default ViewReporter;\n</code></pre>\n<h1>3. 조회수 카운터 적용</h1>\n<p>그럼 조회수는 어디서, 무엇에 대하여 체크해야 할까? 일단 홈 페이지에서는 전체 방문자 수를 보여주고 각 글에 대해서는 조회수를 보여주도록 하겠다.</p>\n<h2>3.1. 전체 방문 수</h2>\n<p>블로그의 전체 방문자 수를 집계하려면 nextjs의 루트 레이아웃에 <code>ViewReporter</code>를 적용하면 된다. slug는 적당히 <code>witch-blog:total-views</code>로 했다.</p>\n<pre><code class=\"language-tsx\">// app/layout.tsx\nexport const totalViewSlug = 'witch-blog:total-views';\n\nexport default async function RootLayout({\n  // Layouts must accept a children prop.\n  // This will be populated with nested layouts or pages\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  // await generateRssFeed();\n\n  return (\n    &#x3C;html lang='en' style={{ colorScheme:'dark' }} suppressHydrationWarning>\n      &#x3C;body>\n          &#x3C;ViewReporter slug={totalViewSlug} />\n          {/* ...생략... */}\n      &#x3C;/body>\n    &#x3C;/html>\n  );\n}\n</code></pre>\n<h2>3.2. 전체 방문 수 보여주기</h2>\n<p>전체 방문 수를 보여주기 위한 단순한 컴포넌트를 만든다. <code>ViewCounter</code>라는 컴포넌트이다.</p>\n<pre><code class=\"language-tsx\">function ViewCounter({ view }: {view: number}) {\n  return (\n    &#x3C;p className={styles.counter}>전체 방문: {view}회&#x3C;/p>\n  );\n}\n</code></pre>\n<p>그리고 홈페이지에서는 전체 방문자 수에 해당하는 slug의 조회수 값을 가져와서 보여주도록 하자. 이때 라우트 캐시의 revalidate 시간도 60초로 설정해주자.</p>\n<pre><code class=\"language-tsx\">const redis = Redis.fromEnv();\n\n// cache revalidate time\nexport const revalidate = 60;\n\nasync function Home() {\n  const totalViews = await redis.get&#x3C;number>(['pageviews', 'projects', totalViewSlug].join(':')) ?? 0;\n  return (\n    &#x3C;>\n      &#x3C;ViewCounter view={totalViews} />\n      {/* ...생략... */}\n    &#x3C;/>\n  );\n}\n</code></pre>\n<h2>3.3. 글 조회수</h2>\n<p>현재 블로그의 글 내용을 보여주는 컴포넌트는 <code>app/posts/[slug]/page.tsx</code>에 있으므로 여기에서 <code>[slug]</code>에 대한 조회수를 늘려주고 또한 보여주면 된다.</p>\n<pre><code class=\"language-tsx\">type Props={\n  params: {slug: string}\n};\n\nconst redis = Redis.fromEnv();\n\nexport const revalidate = 60;\n\nasync function PostPage({ params }: Props) {\n  // 기타 블로그 로직 생략 \n\n  const slug = params.slug;\n\n  const totalViews = await redis.get&#x3C;number>(['pageviews', 'projects', slug].join(':')) ?? 1;\n  \n  return (\n    &#x3C;>\n      &#x3C;ViewReporter slug={slug} />\n      &#x3C;ViewCounter view={totalViews} />\n      {/* ...생략... */}\n    &#x3C;/>\n  );\n}\n\nexport default PostPage;\n</code></pre>\n<p>블로그 글의 인기순 정렬이나 조회수가 높은 글을 보여주는 등 조회수를 통한 기능을 이후 추가할 수도 있을 것이다. DB 기준의 조회수가 좀더 쌓이면 고려해 보려고 한다.</p>\n<h1>참고</h1>\n<p><a href=\"https://upstash.com/blog/nextjs13-approuter-view-counter\">Adding a View Counter to your Next.js Blog</a></p>\n<p><a href=\"https://nextjs.org/docs/app/building-your-application/routing/route-handlers\">Nextjs Route Handlers 공식 문서</a></p>\n<p><a href=\"https://nextjs.org/docs/app/api-reference/functions/next-request\">NextRequest 공식 문서</a></p>\n<p><a href=\"https://solidw.github.io/posts/how-to-make-blog-views-count\">한 땀 한 땀 블로그 만들기 - 조회수 세기</a></p>\n<p><a href=\"https://upstash.com/docs/redis/quickstarts/nextjs13\">upstash 공식 문서 - Quickstarts nextjs 13</a></p>\n<p><a href=\"https://github.com/upstash/upstash-redis\">upstash-redis README</a></p>\n<p><a href=\"https://redis.io/commands/incr/\">redis incr</a></p>\n<p><a href=\"https://redis.io/commands/set/\">redis set</a></p>",
    "excerpt": "시작\n이전에 블로그를 만들면서 블로그 만들기 - 11. 글 조회수 달기에서 조회수 카운터를 달았던 바 있다. 하지만 수많은 오류 등으로 인해 슬쩍 없애 버렸었다. 이를 다시 만들어 주도록 하겠다.\nAdding a View Counter to your Next.js Blog라는 글을 참고하였다.\nupstash Redis가 하루에 10000회의 무료 사용량이 있고 NoSQL이라 key-value 기반이므로 조회수 카운터에 적합하다고 보았다. 또한 upstash 공식",
    "headingTree": [
      {
        "title": "시작",
        "url": "#시작",
        "items": []
      },
      {
        "title": "1. 기본 설정",
        "url": "#1-기본-설정",
        "items": []
      },
      {
        "title": "2. 조회수 증가 로직",
        "url": "#2-조회수-증가-로직",
        "items": [
          {
            "title": "2.1. 중복 방지",
            "url": "#21-중복-방지",
            "items": []
          },
          {
            "title": "2.2. 조회수 증가 컴포넌트",
            "url": "#22-조회수-증가-컴포넌트",
            "items": []
          }
        ]
      },
      {
        "title": "3. 조회수 카운터 적용",
        "url": "#3-조회수-카운터-적용",
        "items": [
          {
            "title": "3.1. 전체 방문 수",
            "url": "#31-전체-방문-수",
            "items": []
          },
          {
            "title": "3.2. 전체 방문 수 보여주기",
            "url": "#32-전체-방문-수-보여주기",
            "items": []
          },
          {
            "title": "3.3. 글 조회수",
            "url": "#33-글-조회수",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 2,
      "wordCount": 511
    },
    "url": "/posts/blog-new-view-counter",
    "thumbnail": {
      "local": "/static/create-db-94ac9147.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-create-db-94ac9147-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAoUlEQVR4nAGWAGn/AAwNDZCOj9TT09bX1tjY2Ofo55ydnAgICAAZGBiMnZbk9u/8+/z7+/v///+2trYICAgAHRscfpWO0ebe+ff49fb1////sLKyDA0NABcXF6Gho+rn6erq6vLy8v///7SyswwNDAAXFhatsa/////7/Pv+/f70/f2YraURDA8AFxcXRkZGYGBgRVBNR1BNSVFOKzo1ESIcTTVTLjlKWHAAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "blog-move-to-cloudflare",
    "title": "블로그를 Cloudflare Pages로 옮기기",
    "date": "2023-04-11T00:00:00Z",
    "description": "늘어난 Bandwidth 감당을 위해 cloudflare pages로 블로그를 옮기기",
    "tags": [
      "blog",
      "web",
      "tip"
    ],
    "html": "<p><a href=\"https://www.witch.work/blog-lower-bandwidth/\">이 글</a>에서 블로그의 bandwidth를 감당하기 위해 proxy를 설정한 과정을 기록하였다. 하지만 이런 노력에도 불구하고 cloudflare proxy를 통해 들어오는 접속은 많지 않았고 vercel의 bandwidth는 늘어나기만 했다.</p>\n<p>최근에는 계속 bandwidth가 늘어날 시 내 free plan 계정이 차단될 수 있다는 이메일을 받았다.</p>\n<p><img src=\"/static/vercel-limit-exceed-a3795cf7.png\" alt=\"limit-exceeded\"></p>\n<p>대체 어디서 이렇게 접속을 많이 하는 걸까 의문이 들지만 일단 bandwidth를 감당하는 게 먼저이므로 블로그를 cloudflare pages로 옮기기로 결정하였다.</p>\n<h1>1. Cloudflare Page 배포</h1>\n<p><a href=\"https://developers.cloudflare.com/pages/get-started/\">Cloudflare get started</a>를 보면 cloudflare page를 통해 어떻게 내 사이트를 배포하는지 나와 있다.</p>\n<p>vercel과 같이 cloudflare pages도 Github, GitLab과 연동할 수 있다. 내 블로그는 github에 올라가 있으므로 이걸 연결하면 된다.</p>\n<p>cloudflare dashboard에 가서 좌측 메뉴 > Pages > Create a project > Connect to Git를 클릭하면 github과 연동할 수 있다.</p>\n<p><img src=\"/static/create-project-efc97edf.png\" alt=\"create-project\"></p>\n<p><img src=\"/static/connect-to-github-a7f4aa60.png\" alt=\"connect-to-git\"></p>\n<p>그리고 github의 repository중 내 블로그 레포지토리를 선택하면 된다. 잘 선택하고 나면 다음과 같은 화면이 뜨는데 스크롤을 내려서 Begin setup을 클릭하자.</p>\n<p><img src=\"/static/select-repo-baa2b70c.png\" alt=\"select-repo\"></p>\n<p>그 다음에는 빌드 세팅을 해야 한다. project name은 배포하고자 하는 프로젝트 이름을 뭘로 할 것인지 원하는 것으로 설정한다. 도메인에 들어가게 되는 이름이다. 그리고 배포할 브랜치도 선택한다. 나는 vercel에서 배포하던 것 그대로 했다.</p>\n<p><img src=\"/static/project-name-set-f90b2786.png\" alt=\"project-name\"></p>\n<p>내 블로그는 gatsby 기반이므로 빌드 세팅에서 gatsby 프리셋을 선택하면 빌드 커맨드와 output directory를 자동으로 설정해준다.</p>\n<p><img src=\"/static/build-settings-4c9c0f96.png\" alt=\"build-setting\"></p>\n<p>이렇게 하고 다음으로 넘어가면 배포가 진행된다.</p>\n<h2>1.1. 오류 해결</h2>\n<p>그런데 프로젝트 빌드 과정에서 패키지를 설치하면서 에러가 발생한다. 에러 메시지는 다음과 같다.</p>\n<p><img src=\"/static/node-error-log-72781dbf.png\" alt=\"node-error\"></p>\n<p>읽어 보면 type-fest라는 라이브러리가 node의 12.20 버전 이상을 요구하는데 cloudflare에서 빌드할 땐 12.18.0을 사용하기 때문에 빌드에 실패한다고 한다.</p>\n<p><a href=\"https://nodejs.org/ko/download\">노드 최신 LTS 버전</a>이 지금 18.15.0인데 12.18.0을 사용한다니..<a href=\"https://developers.cloudflare.com/pages/platform/build-configuration/\">cloudflare bulid configuration</a>을 확인해 보니 cloudflare의 빌드 환경은 기본적으로 12.18.0을 사용한다고 한다. 하지만 <code>NODE_VERSION</code>환경 변수를 통해 이 버전을 변경할 수 있다.</p>\n<p>프로젝트 화면에 들어가서 방금 배포한 <code>witch-work</code>프로젝트를 선택하고 settings에 들어간다. 그러면 메뉴에서 <code>Environment variables</code>에 들어갈 수 있다.</p>\n<p>거기서 Add variable을 클릭하고 변수명에 <code>NODE_VERSION</code>를 입력하고 <code>17.9.1</code>을 입력하면 된다. cloudflare에서 node 17.x버전까지는 모두 지원하기 때문이다.</p>\n<p>그러면 다음과 같이 추가된다.</p>\n<p><img src=\"/static/node_version_env-f7aff7f4.png\" alt=\"env\"></p>\n<p>이렇게 node 버전을 올려 준 결과 다음과 같이 빌드가 성공적으로 완료되고 배포도 잘 되는 것을 확인할 수 있었다.</p>\n<p><img src=\"/static/build-complete-21f4e184.png\" alt=\"build-complete\"></p>\n<p><a href=\"https://witch-work.pages.dev/\">witch-work.pages.dev</a>도메인으로 배포되었다.</p>\n<h1>2. 커스텀 도메인 연결</h1>\n<p>vercel로 배포된 블로그에도 원래 <code>witch.work</code> 도메인이 연결되어 있었다. 이를 cloudflare쪽으로 옮겨보자.</p>\n<p>먼저 cloudflare dashboard로 들어간다. 그리고 좌측 메뉴에서 Pages 선택 -> 내가 배포한 프로젝트(나는 witch-work) 선택 -> 상단 메뉴의 Custom domains 선택</p>\n<p><img src=\"/static/custom-domain-pos-5e965660.png\" alt=\"custom-domain\"></p>\n<p>그러면 다음과 같은 화면이 나오는데 Set up a custom domain을 클릭하자.</p>\n<p><img src=\"/static/setup-custom-domain-e9bab466.png\" alt=\"setup-custom-domain\"></p>\n<p>내가 가진 도메인을 입력하라고 해서 <code>witch.work</code>를 입력하고 다음으로 넘어간다. 그러면 알아서 DNS 레코드 설정을 바꾸어 준다.</p>\n<p><img src=\"/static/dns-record-setup-13d13fde.png\" alt=\"dns-record-setup\"></p>\n<h1>3. apex domain 설정(네임서버 바꾸기)</h1>\n<p>그런데 apex domain 즉 서브도메인이 붙지 않은 도메인으로 배포할 시 더 해줘야 할 작업이 있다고 한다.</p>\n<p>지금은 딱히 내 사이트에서 실용적으로 사용하는 서브도메인이 없지만, 일단 <code>/about</code>페이지도 만들어져는 있고 언젠가 쓸 수도 있으니 이를 설정하자.</p>\n<p>cloudflare 문서에 의하면 내 사이트를 cloudflare zone에 추가하고 네임서버 설정을 해줘야 한다고 한다.</p>\n<p>cloudflare에서 내 사이트의 DNS 레코드를 관리할 수 있도록 하는 것이다. 내 사이트로의 접속 요청을 cloudflare에서 받아서 DNS 역할을 해주도록 하는 것이다.</p>\n<h2>3.1. 시작하기 전에</h2>\n<p>도메인 네임서버 업데이트 전에 다음과 같은 준비가 필요하다.</p>\n<p>도메인을 보유하고 있어야 한다. 나는 <code>witch.work</code>를 godaddy에서 구입해서 가지고 있다.</p>\n<p>Cloudflare 계정이 필요한데 당연히 있다.</p>\n<p>그리고 <a href=\"https://www.cloudflare.com/ko-kr/dns/dnssec/how-dnssec-works/\">DNSSEC</a>이 비활성화되어 있어야 한다. 나같은 경우 <a href=\"https://ph.godaddy.com/help/add-a-ds-record-23865\">GoDaddy - Add a DS record</a>를 따라함으로써 확인할 수 있었다.</p>\n<p><img src=\"/static/no-dnssec-0fcd4e25.png\" alt=\"no-dnssec\"></p>\n<p>DS 레코드고 뭐고 아무것도 없는 듯 하니 DNSSEC는 비활성화되어 있다고 생각했다. 모든 준비는 이미 끝나 있었다..</p>\n<h2>3.2. Cloudflare에 사이트 추가</h2>\n<p>cloudflare에 사이트를 추가하려면 cloudflare 내부에 새 도메인을 생성하고 그 도메인을 활성화하기 위한 절차들을 밟아야 한다.</p>\n<p>난 이미 <a href=\"https://witch.work/blog-lower-bandwidth/#32-%EC%82%AC%EC%9D%B4%ED%8A%B8-%EC%B6%94%EA%B0%80%ED%95%98%EA%B8%B0\">이전 글</a>에서 이를 한 바 있다. 따라서 사이트는 잘 추가되어 있다.</p>\n<h2>3.3. DNS 레코드 확인하기</h2>\n<p>cloudflare 네임서버를 사용하기 시작하면 cloudflare가 내 사이트의 주요한 DNS 제공자가 될 것이다. 그 말은 cloudflare의 내 DNS 레코드가 정확해야 내 도메인이 잘 작동할 거라는 뜻이다.</p>\n<p>이전에 cloudflare에 내 사이트를 추가할 때 cloudflare가 자동으로 DNS 레코드를 추가해줬다. 그게 잘 되었는지 확인해 보자.</p>\n<p>cloudflare dashboard에서 내 사이트(<code>witch.work</code>)를 선택하고 좌측 메뉴에서 DNS 선택 -> DNS Records 선택</p>\n<p>나는 이전에 cloudflare를 처음 사용할 때 확인하긴 했기 때문에, 여전히 잘 추가되어 있었다. <code>witch.work</code>가 <code>witch-work.pages.dev</code>로 연결되는 것도 잘 확인할 수 있었다.</p>\n<p>그리고 원래는 apex domain에 CNAME 레코드는 쓸 수 없는데 cloudflare에서는 <a href=\"https://developers.cloudflare.com/dns/cname-flattening/\">CNAME flattening</a>을 사용하기 때문에 CNAME 레코드를 추가해도 잘 동작한다.</p>\n<p>DNS 쿼리가 도착하면 cloudflare에서 CNAME 레코드를 주는 대신 해당 CNAME이 가리키는 IP 주소를 찾아서 CNAME 레코드 대신 IP 주소를 반환해주는 원리라고 한다.</p>\n<h1>4. www 서브도메인 추가</h1>\n<p><a href=\"http://www.witch.work\">www.witch.work</a> 로도 내 블로그에 접속할 수 있도록 해보자. vercel에서는 가능했는데 여기서는 아직 안된다.</p>\n<p>CNAME 레코드를 하나 더 추가하면 된다. Name은 내가 원하는 서브도메인으로, 그리고 Content는 cloudflare에서 배포한 내 페이지 주소, 즉 <code>witch-work.pages.dev</code>로 설정하면 된다.</p>\n<p><img src=\"/static/dns-manage-e96a080f.png\" alt=\"dns-manage\"></p>\n<p>Name이 그냥 www로 표시되는 것을 볼 수 있는데 이는 내 사이트가 이미 cloudflare zone에서 관리되고 있기 때문에 www 이후에 자동으로 CNAME 레코드가 추가되기 때문이다.</p>\n<h2>4.1. 522 error 해결</h2>\n<p>이렇게 하고 나니 <a href=\"http://www.witch.work\">www.witch.work</a> 로 접속하면 522 error가 뜬다. 참고로 이렇게 서브도메인을 추가해 주기 전에는 <a href=\"http://www.witch.work\">www.witch.work</a> 접속시 404 error가 떴다.</p>\n<p><img src=\"/static/522-error-9a15ba33.png\" alt=\"522-error\"></p>\n<p>다행히 바로 아래에 해결법이 있었다.</p>\n<pre><code>To ensure a custom domain is added successfully, you must go through the Add a custom domain process described above. Manually adding a custom CNAME record pointing to your Cloudflare Pages site - without first associating the domain (or subdomains) in the Cloudflare Pages dashboard - will result in your domain failing to resolve at the CNAME record address, and display a 522 error\n</code></pre>\n<p>요약해보면, 먼저 Cloudflare Page Dashboard에서 내 cloudflare page와 서브도메인을 연결해 주는 작업을 하기 전에 CNAME 레코드를 추가하면 522 error가 뜬다는 것이다.</p>\n<p>따라서 내 dashboard로 이동한 후 좌측 메뉴에서 Pages 선택 -> 내 사이트 선택 -> 메뉴에서 Custom Domains 선택 -> Set up a custom domain에서 <code>www.witch.work</code> 추가의 과정을 거치자.</p>\n<p>그러면 Custom domains 메뉴에 다음과 같이 2개의 도메인이 표시된다.</p>\n<p><img src=\"/static/added-subdomain-1c42227c.png\" alt=\"added-subdomain\"></p>\n<p>둘 다 Active가 되고 난 후 <a href=\"http://www.witch.work%EC%97%90\">www.witch.work에</a> 접속하면 정상적으로 내 블로그로 접속된다.</p>\n<h1>5. 끝</h1>\n<p>이제 vercel에서 기존 도메인을 삭제하면 된다.</p>\n<h1>참고</h1>\n<p><a href=\"https://developers.cloudflare.com/pages/migrations/migrating-from-vercel/\">https://developers.cloudflare.com/pages/migrations/migrating-from-vercel/</a></p>\n<p><a href=\"https://developers.cloudflare.com/pages/get-started/\">https://developers.cloudflare.com/pages/get-started/</a></p>\n<p><a href=\"https://developers.cloudflare.com/pages/platform/custom-domains/\">https://developers.cloudflare.com/pages/platform/custom-domains/</a></p>\n<p><a href=\"https://dev.dwer.kr/2020/04/zone-apex-root-domain-naked-domain.html\">https://dev.dwer.kr/2020/04/zone-apex-root-domain-naked-domain.html</a></p>\n<p><a href=\"https://developers.cloudflare.com/dns/zone-setups/full-setup/setup/\">https://developers.cloudflare.com/dns/zone-setups/full-setup/setup/</a></p>\n<p><a href=\"https://ph.godaddy.com/help/add-a-ds-record-23865\">https://ph.godaddy.com/help/add-a-ds-record-23865</a></p>\n<p><a href=\"https://www.cloudflare.com/ko-kr/learning/dns/dns-security/\">https://www.cloudflare.com/ko-kr/learning/dns/dns-security/</a></p>",
    "excerpt": "이 글에서 블로그의 bandwidth를 감당하기 위해 proxy를 설정한 과정을 기록하였다. 하지만 이런 노력에도 불구하고 cloudflare proxy를 통해 들어오는 접속은 많지 않았고 vercel의 bandwidth는 늘어나기만 했다.\n최근에는 계속 bandwidth가 늘어날 시 내 free plan 계정이 차단될 수 있다는 이메일을 받았다.\n\n대체 어디서 이렇게 접속을 많이 하는 걸까 의문이 들지만 일단 bandwidth를 감당하는 게 먼저이므로 블로그를",
    "headingTree": [
      {
        "title": "1. Cloudflare Page 배포",
        "url": "#1-cloudflare-page-배포",
        "items": [
          {
            "title": "1.1. 오류 해결",
            "url": "#11-오류-해결",
            "items": []
          }
        ]
      },
      {
        "title": "2. 커스텀 도메인 연결",
        "url": "#2-커스텀-도메인-연결",
        "items": []
      },
      {
        "title": "3. apex domain 설정(네임서버 바꾸기)",
        "url": "#3-apex-domain-설정네임서버-바꾸기",
        "items": [
          {
            "title": "3.1. 시작하기 전에",
            "url": "#31-시작하기-전에",
            "items": []
          },
          {
            "title": "3.2. Cloudflare에 사이트 추가",
            "url": "#32-cloudflare에-사이트-추가",
            "items": []
          },
          {
            "title": "3.3. DNS 레코드 확인하기",
            "url": "#33-dns-레코드-확인하기",
            "items": []
          }
        ]
      },
      {
        "title": "4. www 서브도메인 추가",
        "url": "#4-www-서브도메인-추가",
        "items": [
          {
            "title": "4.1. 522 error 해결",
            "url": "#41-522-error-해결",
            "items": []
          }
        ]
      },
      {
        "title": "5. 끝",
        "url": "#5-끝",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 336
    },
    "url": "/posts/blog-move-to-cloudflare",
    "thumbnail": {
      "local": "/static/vercel-limit-exceed-a3795cf7.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-vercel-limit-exceed-a3795cf7-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAfUlEQVR4nC2NzQoCIRSFjZje/zmmN3DfD4EbFyYYTY6Vi+RuBhK5yQmzszzf+TgCQK0VQEopxgiAmQGI3pZStNZKqZxznzZARN77EMLjFyJqBjOb88UY45yb/e3+fC3vJjVwnSZr7f5w2h2V9zPz5w8AbMdxGDZitZZS9v8vPu1/VaczdKcAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "blog-opt-1",
    "title": "블로그 최적화 - 1. 메인 페이지 최적화",
    "date": "2024-03-20T01:00:00Z",
    "description": "이분 탐색의 활용에 대해 알아봅니다.",
    "tags": [
      "algorithm"
    ],
    "html": "<h1>0. 개요</h1>\n<p>블로그의 많은 기능이 완성되었다. 하지만 배포한 페이지에 들어가 보면 여전히 페이지가 꽤 느린 것을 알 수 있다. 따라서 이를 최적화하여 누가 봐도 빠른 페이지를 만들어 보는 작업을 시작하려 한다.</p>\n<p>예전에 카카오톡에서 빠른 속도를 위해 서버 기술 혁신을 하는 프로젝트에 붙였던 이름인 <a href=\"https://www.kakaocorp.com/page/detail/9350\">겁나 빠른 황소 프로젝트</a>의 이름을 따서 이 작업을 <code>겁나 빠른 마녀</code>로 명명하였다.</p>\n<h1>1. Lighthouse 검사</h1>\n<p>먼저 웹 페이지의 품질을 검사하는 구글의 유명한 오픈소스 Lighthouse로 내 페이지를 진단해 보았다. <a href=\"https://chrome.google.com/webstore/detail/lighthouse/blipmdconlkpinefehnmjammfjpmpbjk\">크롬 익스텐션</a>을 설치하고 나서 간단하게 진단 보고서를 얻을 수 있었다.</p>\n<p><img src=\"/static/lighthouse-result-first-a62aad48.png\" alt=\"lighthouse 첫번째 결과\"></p>\n<p>대충 접근성과 SEO는 괜찮고(최고다 next-seo!), 성능은 별로이며 Best Practice도 미흡하다. PWA도 아직 멀었다고 한다. 특히 성능과 같은 경우 나머지 요소는 다 괜찮은데 Total blocking time(사용자가 페이지와 상호작용할 수 있기까지 걸리는 시간)이 1220ms로 처참하다. <a href=\"https://developer.chrome.com/docs/lighthouse/performance/lighthouse-total-blocking-time/?utm_source=lighthouse&#x26;utm_medium=lr#how-lighthouse-determines-your-tbt-score\">TBT가 200ms 아래로 내려와야 좋은 점수를 받을 수 있는데</a> 그 6배 이상 걸리는 것이다.</p>\n<p>따라서 성능 최적화를 열심히 하자. 생각나는 대로 최적화한 기록을 순서대로 쓴다. 어떻게 최적화하는지 몰라서 하나하나 찾아가며 했기 때문에 순서는 좀 뒤죽박죽이다.</p>\n<p><img src=\"/static/lighthouse-good-result-dd1dea66.png\" alt=\"테스트 이미지\"></p>\n<h1>2. getStaticProps로 연산 이동</h1>\n<p>메인 페이지를 보면 지금 <code>Home</code> 컴포넌트 내에서 계속 <code>getSortedPosts</code>를 호출하고 있다. 이 부분은 빌드 이후에 특별히 바뀌는 부분이 아니므로 <code>getStaticProps</code>로 이동시키자. 이렇게 하면 빌드 시에만 호출되기 때문에 빌드 시간이 좀 늘어날 수도 있겠지만, 빌드된 페이지는 빠르게 로딩될 것이다.</p>\n<p>또한 저장된 글들의 정보 중 글 목록 렌더링에 필요한 정보들만 넘기도록 하자.</p>\n<p><img src=\"/static/reduce-js-82397868.png\" alt=\"테스트 이미지 2\"></p>\n<p>일단 <code>src/pages/index.tsx</code>의 <code>Home</code>컴포넌트에서 <code>getSortedPosts</code>를 호출하는 부분을 지우고, <code>src/pages/index.tsx</code>의 <code>getStaticProps</code>를 다음과 같이 수정한다.</p>",
    "excerpt": "0. 개요\n블로그의 많은 기능이 완성되었다. 하지만 배포한 페이지에 들어가 보면 여전히 페이지가 꽤 느린 것을 알 수 있다. 따라서 이를 최적화하여 누가 봐도 빠른 페이지를 만들어 보는 작업을 시작하려 한다.\n예전에 카카오톡에서 빠른 속도를 위해 서버 기술 혁신을 하는 프로젝트에 붙였던 이름인 겁나 빠른 황소 프로젝트의 이름을 따서 이 작업을 겁나 빠른 마녀로 명명하였다.\n1. Lighthouse 검사\n먼저 웹 페이지의 품질을 검사하는 구글의 유명한 오픈소스 L",
    "headingTree": [
      {
        "title": "0. 개요",
        "url": "#0-개요",
        "items": []
      },
      {
        "title": "1. Lighthouse 검사",
        "url": "#1-lighthouse-검사",
        "items": []
      },
      {
        "title": "2. getStaticProps로 연산 이동",
        "url": "#2-getstaticprops로-연산-이동",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 29
    },
    "url": "/posts/blog-opt-1",
    "thumbnail": {
      "local": "/static/lighthouse-result-first-a62aad48.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-lighthouse-result-first-a62aad48-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAj0lEQVR4nGP4////548fXr948h8MTp89e/rs2f///zP8+ft36bwpnXVFv/78+f//PxMzW0VFFUji/v2Hs2fNau7sOXT0zP///+sbmqA6Tpw6deP2re/fv//////2ndunz5598/bt8+cvGFYsX5qdkQaxYOXaVVOmToEoYtiwacOqFUu/f//+Dgz+/P0LYQAAYcJ2Ol9Vb4wAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "blog-opt-2",
    "title": "블로그 최적화 - 2. 글 목록 페이지 최적화",
    "date": "2023-06-11T00:00:00Z",
    "description": "겁나 빠른 마녀 : 블로그 최적화 그 두번째",
    "tags": [
      "blog",
      "web"
    ],
    "html": "<h1>블로그 만들기 시리즈</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>제목</th><th>링크</th></tr></thead><tbody><tr><td>1. 기본 세팅</td><td><a href=\"https://witch.work/posts/blog-remake-1\">https://witch.work/posts/blog-remake-1</a></td></tr><tr><td>2. 메인 페이지의 HTML 설계</td><td><a href=\"https://witch.work/posts/blog-remake-2\">https://witch.work/posts/blog-remake-2</a></td></tr><tr><td>3. 글 상세 페이지의 구조 설계</td><td><a href=\"https://witch.work/posts/blog-remake-3\">https://witch.work/posts/blog-remake-3</a></td></tr><tr><td>4. 이미지를 상대 경로로 쓸 수 있도록 하기</td><td><a href=\"https://witch.work/posts/blog-remake-4\">https://witch.work/posts/blog-remake-4</a></td></tr><tr><td>5. 자잘한 페이지 구성 개선과 배포</td><td><a href=\"https://witch.work/posts/blog-remake-5\">https://witch.work/posts/blog-remake-5</a></td></tr><tr><td>6. 페이지 요소의 배치 설계</td><td><a href=\"https://witch.work/posts/blog-remake-6\">https://witch.work/posts/blog-remake-6</a></td></tr><tr><td>7. 메인 페이지 컴포넌트 디자인</td><td><a href=\"https://witch.work/posts/blog-remake-7\">https://witch.work/posts/blog-remake-7</a></td></tr><tr><td>8. 글 목록/내용 페이지 컴포넌트 디자인</td><td><a href=\"https://witch.work/posts/blog-remake-8\">https://witch.work/posts/blog-remake-8</a></td></tr><tr><td>9. 글 썸네일 자동 생성하기</td><td><a href=\"https://witch.work/posts/blog-remake-9\">https://witch.work/posts/blog-remake-9</a></td></tr><tr><td>10. 폰트, 카드 디자인 등의 디자인 개선</td><td><a href=\"https://witch.work/posts/blog-remake-10\">https://witch.work/posts/blog-remake-10</a></td></tr><tr><td>11. 글에 조회수 달기</td><td><a href=\"https://witch.work/posts/blog-remake-11\">https://witch.work/posts/blog-remake-11</a></td></tr><tr><td>12. 페이지 테마와 글 검색 기능</td><td><a href=\"https://witch.work/posts/blog-remake-12\">https://witch.work/posts/blog-remake-12</a></td></tr><tr><td>13. 테마 아이콘과 썸네일 레이아웃 개선 등</td><td><a href=\"https://witch.work/posts/blog-remake-13\">https://witch.work/posts/blog-remake-13</a></td></tr><tr><td>14. 글 분류를 태그 기반으로 변경</td><td><a href=\"https://witch.work/posts/blog-remake-14\">https://witch.work/posts/blog-remake-14</a></td></tr><tr><td>메인 페이지의 연산 최적화</td><td><a href=\"https://witch.work/posts/blog-opt-1\">https://witch.work/posts/blog-opt-1</a></td></tr><tr><td>글 목록 페이지네이션 만들기</td><td><a href=\"https://witch.work/posts/blog-opt-2\">https://witch.work/posts/blog-opt-2</a></td></tr><tr><td>이미지를 CDN에 올리고 placeholder 만들기</td><td><a href=\"https://witch.work/posts/blog-opt-3\">https://witch.work/posts/blog-opt-3</a></td></tr><tr><td>검색 페이지에 무한 스크롤 구현하기</td><td><a href=\"https://witch.work/posts/blog-opt-4\">https://witch.work/posts/blog-opt-4</a></td></tr></tbody></table>\n<h1>1. 페이지네이션으로 DOM 트리 줄이기</h1>\n<p>가장 글이 많은 개발 카테고리의 글 목록 페이지를 lighthouse로 조회해 보자.</p>\n<p><img src=\"/static/category-page-lighthouse-59d42238.png\" alt=\"category-page-lighthouse\"></p>\n<p>처참하다. lighthouse의 조언들을 되는대로 적용해 보자.</p>\n<p>글 목록 페이지에는 DOM 사이즈를 줄이라는 조언이 있었다. DOM에 1620개나 되는 요소들이 있다고 한다. 자식이 110개나 있는 요소도 있고. 이런 식으로 DOM 크기가 너무 크고 child 노드도 많으면 메모리 사용량이 늘고 스타일 계신이 너무 길어지며 레이아웃 리플로우(문서 내 요소의 위치를 계산되는 프로세스)도 오래 걸리게 된다.</p>\n<p>안 그래도 글 목록 페이지의 길어진 스크롤이 불편하던 참이었다. Vercel 템플릿에서 <a href=\"https://vercel.com/templates/next.js/pagination-with-ssg\">SSG 페이지네이션</a>코드가 공개되어 있길래 이를 사용해 보았다.</p>\n<p>먼저 동적 라우트를 사용해야 하기 때문에 동적 라우트 폴더를 새로 만들자. <code>pages/posts/[category]</code> 내에 동적 라우트가 있어야 하는데 여기에는 이미 <code>[category]/[slug]</code> 라는 동적 라우트가 있다. 따라서 <code>pages/posts/[category]/page/[page]/index.tsx</code>로 동적 라우트를 새로 만들었다.</p>\n<p>이렇게 하면 <code>/posts/category/page/2(페이지번호)</code> 이런 식으로 페이지네이션을 할 수 있다. <a href=\"https://stackoverflow.com/questions/59790906/nextjs-how-to-handle-multiple-dynamic-routes-at-the-root\">동적 라우트를 2개 쓰는 것도 가능은 하지만 좋은 패턴이 아니라고 한다.</a></p>\n<h1>2. Vercel Pagination Template 분석</h1>\n<p>Vercel template에서 어떻게 페이지네이션을 구현했는지 분석하였다. 실제 템플릿은 <a href=\"https://vercel.com/templates/next.js/pagination-with-ssg\">pagination-with-ssg template</a>에서 확인할 수 있다.</p>\n<p>이 템플릿은 페이지별로 상품의 목록을 보여주는 페이지네이션을 구현한 것이다. 이 템플릿의 핵심 로직을 나름대로 분석하면 다음과 같다.</p>\n<p><img src=\"/static/vercel-pagination-template-65f3de91.png\" alt=\"vercel-pagination-template\"></p>\n<p>이를 내 블로그의 현재 구조에 맞게 적절히 변경하여 구성해 보자.</p>\n<p><code>PaginationPage</code>컴포넌트</p>\n<h1>3. CategoryPagination 컴포넌트</h1>\n<p>기존에 쓰던 카테고리 페이지의 컨텐츠 부분을 따와서 <code>CategoryPagination</code> 컴포넌트를 만들었다. 템플릿의 PaginationPage 컴포넌트의 props에 현재 카테고리까지 props로 받아 오도록 했고 단순히 이를 보여주는 기능만 일단 구현했다.</p>\n<pre><code class=\"language-tsx\">// src/components/categoryPagenation/index.tsx\nimport Card from '../card';\n\nimport styles from './styles.module.css';\n\nexport interface PostMetaData{\n  title: string;\n  description: string;\n  image?: string;\n  date: string;\n  tags: string[];\n  url: string;\n}\n\ninterface Props{\n  totalItemNumber: number;\n  category: string;\n  currentPage: number;\n  postList: PostMetaData[];\n  perPage: number;\n}\n\nfunction CategoryPagination(props: Props) {\n  const {category, currentPage, postList}=props;\n  return (\n    &#x3C;>\n      &#x3C;h1 className={styles.title}>\n        {`${category} 주제 ${currentPage} 페이지`}\n      &#x3C;/h1>\n      &#x3C;ul className={styles.list}>\n        {postList.map((post: PostMetaData) =>{\n          return (\n            &#x3C;li key={post.url}>\n              &#x3C;Card {...post} />\n            &#x3C;/li>\n          );\n        })}\n      &#x3C;/ul>\n    &#x3C;/>\n  );\n}\n\nexport default CategoryPagenation;\n</code></pre>\n<p>그러면 <code>src/pages/posts/[category]/index.tsx</code> 페이지의 컴포넌트 구조는 <code>CategoryPagenation</code>를 사용하여 다음과 같이 바뀐다.</p>\n<pre><code class=\"language-tsx\">// src/pages/posts/[category]/index.tsx\n/* 페이지당 몇 개의 글이 보이는가 */\nexport const ITEMS_PER_PAGE=10;\n\nfunction PostListPage({\n  category, categoryURL, postList,\n}: InferGetStaticPropsType&#x3C;typeof getStaticProps>) {\n  /* SEOInfo 객체 정보 생략 */\n  return (\n    &#x3C;>\n      &#x3C;NextSeo {...SEOInfo} />\n      &#x3C;PageContainer>\n        &#x3C;CategoryPagination \n          category={category}\n          currentPage={1}\n          postList={postList}\n          totalItemNumber={postList.length}\n          perPage={ITEMS_PER_PAGE}\n        />\n      &#x3C;/PageContainer>\n    &#x3C;/>\n  );\n}\n</code></pre>\n<p>postList는 <code>getStaticProps</code>에서 잘 계산하여 props로 넘겨주어, 각 페이지별로 특정 개수의 글들만 목록에 보이도록 해야 한다.</p>\n<p>다만 그전에 먼저 필요한 컴포넌트들을 모두 구현하자.</p>\n<h1>4. 페이지네이션 컴포넌트</h1>\n<p>페이지네이션 컴포넌트란 다음과 같이 현재 페이지 위치와 링크를 통한 페이지 이동을 하게 해주는 컴포넌트다.</p>\n<p><img src=\"/static/pagination-example-57253753.png\" alt=\"pagination-example\"></p>\n<p>이 컴포넌트를 만들기 위해 <code>src/components/categoryPagination/pagination/index.tsx</code>를 만들고 작성하자.</p>\n<p>inc부터 length 길이의 배열을 만들어서 리턴하는 <code>getPages</code> 함수를 정의한다.</p>\n<pre><code class=\"language-tsx\">// inc부터 시작해서 length만큼의 숫자 배열을 반환하는 함수\nfunction getPages(length: number, inc: number = 1) {\n  return Array.from({ length }, (_, i) => i + inc);\n}\n</code></pre>\n<p>페이지네이션에 표시할 숫자와 문자열들의 배열을 리턴하는 <code>getPaginationArray</code>함수도 정의한다. currentPage의 값에 따라서 전체 페이지 중 적절한 페이지 번호들을 담은 배열을 리턴한다. 이때 중간에 <code>dotts</code> 변수를 이용해서 생략 표시도 넣는다.</p>\n<pre><code class=\"language-tsx\">function getPaginationArray(\n  totalItemNumber: number,\n  currentPage: number,\n  perPage: number\n) {\n  /* JS의 정수 나눗셈은 소숫점을 버리지 않음에 주의 */\n  const totalPages=parseInt((totalItemNumber/perPage).toString()) + (totalItemNumber%perPage?1:0);\n  if (totalPages&#x3C;=7) {\n    return getPages(totalPages);\n  }\n  if (currentPage&#x3C;=4) {\n    return [1, 2, 3, 4, 5, dotts, totalPages-1 ,totalPages];\n  }\n  if (currentPage>=totalPages-3) {\n    return [1, dotts, ...getPages(6, totalPages - 5)];\n  }\n\n  return [1, \n    dotts,\n    ...getPages(5, currentPage - 2),\n    dotts, \n    totalPages\n  ];\n}\n</code></pre>\n<p>이를 이용해서 페이지네이션을 보여주는 컴포넌트도 만든다. 페이지 번호의 경우 링크를 걸고, 현재 페이지와 같은 번호라면 강조 표시를 해준다.</p>\n<pre><code class=\"language-tsx\">// src/components/categoryPagination/pagination/index.tsx\nfunction Pagination({\n  totalItemNumber,\n  currentPage,\n  renderPageLink,\n  perPage = 10,\n}: PaginationProps) {\n  const pageArray=getPaginationArray(totalItemNumber, currentPage, perPage);\n  return (\n    &#x3C;div>\n      {pageArray.map((pageNumber, i) =>\n        pageNumber === dotts ? (\n          &#x3C;span key={i}>\n            {pageNumber}\n          &#x3C;/span>\n        ) : (\n          &#x3C;Link\n            key={i}\n            href={renderPageLink(pageNumber as number)}\n          >\n            {pageNumber}\n          &#x3C;/Link>\n        )\n      )}\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<p>그럼 간단하게 스타일링도 해볼까. <code>src/components/categoryPagination/pagination/styles.module.css</code>를 만들고 다음과 같이 작성한다.</p>\n<pre><code class=\"language-css\">// src/components/categoryPagination/pagination/styles.module.css\n.container{\n  margin:1.5rem auto;\n  display: flex;\n  flex-direction: row;\n  justify-content: center;\n  align-items: center;\n}\n\n.item{\n  padding: 0.5rem 1rem;\n  border-radius: 0.25rem;\n  font-weight: 600;\n}\n\n.item:hover{\n  background: var(--gray3);\n}\n\n.selected{\n  padding: 0.5rem 1rem;\n  border-radius: 0.25rem;\n  font-weight: 600;\n  background: var(--indigo1);\n  color: var(--indigo8);\n}\n\n.selected:hover{\n  background: var(--indigo5);\n  color: var(--white);\n}\n</code></pre>\n<p>그리고 className을 Pagination 컴포넌트 내에 부여한다.</p>\n<pre><code class=\"language-tsx\">// src/components/categoryPagination/pagination/index.tsx\nfunction Pagination({\n  totalItemNumber,\n  currentPage,\n  renderPageLink,\n  perPage = 10,\n}: PaginationProps) {\n  const pageArray=getPaginationArray(totalItemNumber, currentPage, perPage);\n  return (\n    &#x3C;div className={styles.container}>\n      {pageArray.map((pageNumber, i) =>\n        pageNumber === dotts ? (\n          &#x3C;span key={i} className={styles.item}>\n            {pageNumber}\n          &#x3C;/span>\n        ) : (\n          &#x3C;Link\n            key={i}\n            href={renderPageLink(pageNumber as number)}\n            className={currentPage === pageNumber ? styles.selected : styles.item}\n          >\n            {pageNumber}\n          &#x3C;/Link>\n        )\n      )}\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<p>그러면 이 페이지네이션을 어디에 배치해야 할까?</p>\n<p>페이지네이션에 대응하는 다른 컨텐츠 전략인 무한 스크롤에 비해서 나는 페이지네이션을 택했다. 그리고 이것의 가장 큰 의미는 사용자에게 자신이 페이지를 제어하고 있다는 감각을 주는 것이라고 생각한다.</p>\n<p>무한 스크롤에 비해서 마지막 페이지가 어딘지도 알 수 있고, 그 페이지에 비해 자신이 어느 지점에 있는 글을 보고 있는지도 짐작할 수 있기 때문이다.</p>\n<p>이러한 감각을 극대화하기 위해서는 페이지네이션이 게시판의 맨 위에 배치되어 있는 게 가장 적절하다고 생각된다.</p>\n<p>그래서 <code>CategoryPagination</code> 컴포넌트를 다음과 같이 수정하여 페이지네이션 컴포넌트가 카테고리 제목 바로 아래에 보이도록 했다. 사용자가 게시판에 들어오자마자 자신이 제어한다는 감각을 가질 수 있도록 하기 위해서이다.</p>\n<pre><code class=\"language-tsx\">function CategoryPagination(props: Props) {\n  const {totalItemNumber, category, currentPage, postList, perPage}=props;\n  const categoryURL=blogCategoryList.find((c: {title: string, url: string})=>\n    c.title===category)?.url.split('/').pop() as string;\n  return (\n    &#x3C;>\n      &#x3C;h1 className={styles.title}>\n        {`${category} 주제 ${currentPage} 페이지`}\n      &#x3C;/h1>\n      {/* 카테고리 제목 바로 아래에 페이지네이션 배치 */}\n      &#x3C;Pagination\n        totalItemNumber={totalItemNumber}\n        currentPage={currentPage}\n        renderPageLink={(page: number) => `/posts/${categoryURL}/page/${page}`}\n        perPage={perPage}\n      />\n      &#x3C;ul className={styles.list}>\n        {postList.map((post: PostMetaData) =>{\n          return (\n            &#x3C;li key={post.url}>\n              &#x3C;Card {...post} />\n            &#x3C;/li>\n          );\n        })}\n      &#x3C;/ul>\n    &#x3C;/>\n  );\n}\n</code></pre>\n<h1>5. 개별 페이지 만들기</h1>\n<p>이제 <code>src/pages/posts/[category]/page/[page]/index.tsx</code>를 작성하여 개별 페이지의 내용을 구현하자.</p>\n<p>개별 페이지를 구현하기 위해선 뭐가 필요할까? 일단 해당 페이지의 글을 가져와야 한다. 이는 이전에 글을 가져오는 데에 쓰던 <code>getSortedPosts</code>함수를 쓸 수도 있다.</p>\n<p>하지만 여기서는 우리가 지금 해야 하는 작업 즉 특정 카테고리의 특정 페이지의 글을 가져오는 로직을 새로운 함수로 만들자. <code>src/utils/post.ts</code>에 <code>getCategoryPosts</code> 함수를 만들었다.</p>\n<p>category와 현재 페이지 그리고 페이지당 몇 개의 글이 들어가는지를 인수로 받는 함수이다. 그러면 함수 내에선 <code>getSortedPosts</code>의 결과에서 먼저 인수로 받은 category에 해당하는 글만 뽑아낸다. 그다음은 <code>currentPage</code>와 <code>postsPerPage</code>를 이용해서 현재 페이지에 해당하는 글 목록만 슬라이싱해서 배열로 가져온다.</p>\n<p>이때 pagePosts뿐 아니라 totalPostNumber 즉 해당 카테고리에 속한 글의 개수도 리턴하는 것을 볼 수 있다. 이는 이후 페이지네이션 컴포넌트(페이지를 이동하는 데 쓰이는 컴포넌트)를 구현하는 데에 쓰일 것이다.</p>\n<pre><code class=\"language-ts\">interface PageInfo{\n  category: string;\n  currentPage: number;\n  postsPerPage: number;\n}\n\nexport const getCategoryPosts = (info: PageInfo) => {\n  const { category, currentPage, postsPerPage } = info;\n  const allDocumentsInCategory = getSortedPosts().filter((post: DocumentTypes)=>\n    post._raw.flattenedPath.startsWith(category));\n\n  const pagenatedPosts= allDocumentsInCategory.slice(\n    (currentPage-1)*postsPerPage, \n    currentPage*postsPerPage\n  );\n\n  return {pagePosts:pagenatedPosts, totalPostNumber: allDocumentsInCategory.length};\n};\n</code></pre>\n<p>그럼 이제 개별 페이지에서는 이 함수를 사용해서 맞는 카테고리의 해당 페이지에 필요한 글을 가져온 후 보여주기만 하면 된다.</p>\n<p>페이지당 몇 개의 글 Card를 보여줄지를 정하는 변수를 정의하자.</p>\n<pre><code class=\"language-tsx\">// src/pages/posts/[category]/page/[page]/index.tsx\n/* 페이지당 몇 개의 글이 보이는가 */\nexport const ITEMS_PER_PAGE=10;\n</code></pre>\n<p><code>getStaticPaths</code>를 작성해보자. 여기서는 각 카테고리별로 필요한 페이지들의 경로를 생성해서 <code>paths</code>로 리턴해 주면 된다. 다음과 같이 작성한다.</p>\n<pre><code class=\"language-tsx\">// src/pages/posts/[category]/page/[page]/index.tsx\nexport const getStaticPaths: GetStaticPaths = async () => {\n  const paths=[];\n  for (const category of blogCategoryList) {\n    const categoryURL=category.url.split('/').pop();\n    for (let i=1;i&#x3C;=5;i++) {\n      paths.push(`/posts/${categoryURL}/page/${i}`);\n    }\n  }\n  return {\n    paths,\n    // Block the request for non-generated pages and cache them in the background\n    fallback: 'blocking',\n  };\n};\n</code></pre>\n<p><code>blogCategoryList</code>에 있는 모든 카테고리들에 대해서 <code>/posts/[카테고리]/page/[페이지번호]</code>에 해당하는 URL 경로를 생성해주고 있다. 그런데 코드를 보면 페이지 번호를 1부터 5까지만 생성한다. 만약 글이 50개(정확히는 <code>5*ITEMS_PER_PAGE</code>개)를 넘어가면 다음 페이지는 어떻게 들어갈까?</p>\n<p>이를 위해서 <code>getStaticPaths</code>리턴 객체의 fallback을 <code>blocking</code>으로 설정했다. 이렇게 하면 <a href=\"https://nextjs.org/docs/pages/building-your-application/data-fetching/incremental-static-regeneration\">Incremental Static Regeneration</a>으로 페이지가 렌더링된다.</p>\n<p>이 ISR 로직은 다음과 같다. <code>getStaticPaths</code>에서 생성되지 않은 페이지가 처음으로 요청되면 일단 서버사이드 렌더링을 한 후 이를 캐싱하고 백그라운드에서 새로운 페이지를 생성한다. 그리고 해당 페이지에 대한 다음 요청부터는 정적 페이지로 제공한다. 따라서 사이트를 빌드한 후에도 정적 페이지가 새로 생성되도록 할 수 있게 된다.</p>\n<p>5페이지를 넘어가면 아무래도 사용자가 해당 페이지를 요청할 확률이 적어지므로 적절한 조치라고 할 수 있겠다.</p>\n<p><code>getStaticProps</code>를 작성해보자. params로 받을 수 있는 정보는 category와 page인데 각 페이지에 몇 개의 글이 들어가는지는 이미 상수로 정의해 놓았으므로 이를 이용하면 페이지를 위한 정보를 모두 받아올 수 있다.</p>\n<p><code>getCategoryPosts</code>를 이용해서 페이지의 글을 모두 받아오고, map을 이용해서 PostMetaData의 image에 <code>post._raw.thumbnail</code>을 대응시킨다. 이렇게 만든 객체 배열을 리턴값으로 넘긴다.</p>\n<p>이때 만약 페이지 정보에 해당하는 글이 없으면 404 페이지를 띄워줘야 하고 1페이지에 대한 요청은 <code>/posts/[category]</code>로 리다이렉트 시켜줘야 한다. 같은 내용에 대한 2가지 라우트를 막기 위함이다.</p>\n<pre><code class=\"language-tsx\">export const getStaticProps: GetStaticProps = async ({\n  params,\n}: GetStaticPropsContext) => {\n  const page: number = Number(params?.page) || 1;\n  const {pagePosts, totalPostNumber} = await getCategoryPosts({\n    category:params?.category as string, \n    currentPage:page,\n    postsPerPage:ITEMS_PER_PAGE\n  });\n\n  const pagePostsWithThumbnail=pagePosts.map((post: DocumentTypes) => {\n    const { title, description, date, tags, url } = post;\n    const metadata={title, description, date, tags, url};\n    return 'thumbnail' in post._raw ? \n      ({...metadata, image: post._raw.thumbnail} as PostMetaData) :\n      metadata;\n  });\n\n  const {title:category, url:categoryURL}=blogCategoryList.find((c: {title: string, url: string})=>\n    c.url.split('/').pop()===params?.category) as {title: string, url: string};\n\n  if (!pagePostsWithThumbnail.length) {\n    return {\n      notFound: true,\n    };\n  }\n  \n  if (page===1) {\n    return {\n      redirect: {\n        destination: `/posts/${params?.category}`,\n        permanent: false,\n      },\n    };\n  }\n\n  return {\n    props: {\n      category,\n      categoryURL,\n      pagePosts:pagePostsWithThumbnail,\n      totalPostNumber,\n      currentPage:page,\n    },\n    revalidate: 60 * 60 * 24, // &#x3C;--- ISR cache: once a day\n  };\n};\n</code></pre>\n<p>이렇게 하니까 배포시 에러가 뜬다. 다 비슷한 에러인데 그중 하나를 가져오면 다음과 같다.</p>\n<pre><code>Error: `redirect` can not be returned from getStaticProps during prerendering (/posts/cs/page/1)\n</code></pre>\n<p>페이지가 프리렌더링될 때 redirect를 리턴할 수 없다는 에러다. 빌드 시에 페이지를 구성하면서 <code>getStaticProps</code>에서 리턴한 값이 페이지 컴포넌트의 props로 들어가는데 이때 redirect를 리턴하면 페이지 구성에 문제가 생기는 것 같다.</p>\n<p>우리의 목적은 사실 1페이지에 대한 요청을 <code>/posts/[category]</code>로 리다이렉트 시키는 것이다. 이를 위해서는 그냥 <code>getStaticPaths</code>에서 1페이지에 대한 경로를 생성하지 않으면 된다.</p>\n<p><code>getStaticPaths</code>를 다음과 같이 수정하자.</p>\n<pre><code class=\"language-tsx\">export const getStaticPaths: GetStaticPaths = async () => {\n  const paths=[];\n  for (const category of blogCategoryList) {\n    const categoryURL=category.url;\n    for (let i=0;i&#x3C;5;i++) {\n      paths.push(`${categoryURL}/page/${i+2}`);\n    }\n  }\n  return {\n    paths,\n    // Block the request for non-generated pages and cache them in the background\n    fallback: 'blocking',\n  };\n};\n</code></pre>\n<p>이제 빌드가 잘 되고 페이지 URL로 접근해 보면 페이지에도 잘 들어가진다. 이를 각 카테고리별 첫 페이지에도 적용한다. <code>src/pages/posts/[category]/index.tsx</code>를 편집.</p>\n<pre><code class=\"language-tsx\">// src/pages/posts/[category]/index.tsx\n/* import 문들 생략 */\nfunction PostListPage({\n  category,\n  categoryURL,\n  pagePosts,\n  totalPostNumber,\n  currentPage,\n}: InferGetStaticPropsType&#x3C;typeof getStaticProps>) {\n  /* SEO config 생략 */\n  return (\n    &#x3C;>\n      &#x3C;NextSeo {...SEOInfo} />\n      &#x3C;PageContainer>\n        &#x3C;CategoryPagination \n          category={category}\n          categoryURL={categoryURL}\n          currentPage={currentPage}\n          postList={pagePosts}\n          totalItemNumber={totalPostNumber}\n          perPage={ITEMS_PER_PAGE}\n        />\n      &#x3C;/PageContainer>\n    &#x3C;/>\n  );\n}\n\nexport default PostListPage;\n\nexport const getStaticPaths: GetStaticPaths=()=>{\n  const paths=blogCategoryList.map((category)=>{\n    return {\n      params: {\n        category:category.url.split('/').pop(),\n      },\n    };\n  });\n  return {\n    paths,\n    fallback: false,\n  };\n};\n\nconst FIRST_PAGE=1;\n\nexport const getStaticProps: GetStaticProps = async ({params}) => {\n  const {pagePosts, totalPostNumber} = await getCategoryPosts({\n    category:params?.category as string,\n    currentPage:FIRST_PAGE,\n    postsPerPage:ITEMS_PER_PAGE\n  });\n\n  const pagePostsWithThumbnail=pagePosts.map((post: DocumentTypes) => {\n    const { title, description, date, tags, url } = post;\n    const metadata={title, description, date, tags, url};\n    return 'thumbnail' in post._raw ? \n      ({...metadata, image: post._raw.thumbnail} as PostMetaData) :\n      metadata;\n  });\n\n  const {title:category, url:categoryURL}=blogCategoryList.find((c: {title: string, url: string})=>\n    c.url.split('/').pop()===params?.category) as {title: string, url: string};\n\n  return {\n    props: {\n      category,\n      categoryURL,\n      pagePosts:pagePostsWithThumbnail,\n      totalPostNumber,\n      currentPage:FIRST_PAGE,\n    },\n    revalidate: 60 * 60 * 24, // &#x3C;--- ISR cache: once a day\n  };\n};\n</code></pre>\n<p>이렇게 페이지네이션을 적용하자 글 목록 페이지 로딩이 꽤 빨라졌다.</p>\n<p><img src=\"/static/lighthouse-after-pagination-710fe85a.png\" alt=\"lighthouse-after-pagination\"></p>\n<p>다음 글에서는 전반적인 이미지 최적화를 해보자.</p>\n<h1>참고</h1>\n<p><a href=\"https://uxplanet.org/ux-infinite-scrolling-vs-pagination-1030d29376f1\">https://uxplanet.org/ux-infinite-scrolling-vs-pagination-1030d29376f1</a></p>\n<p>브라우저 리플로우 최소화 <a href=\"https://developers.google.com/speed/docs/insights/browser-reflow?utm_source=lighthouse&#x26;utm_medium=lr&#x26;hl=ko\">https://developers.google.com/speed/docs/insights/browser-reflow?utm_source=lighthouse&#x26;utm_medium=lr&#x26;hl=ko</a></p>\n<p><a href=\"https://vercel.com/templates/next.js/pagination-with-ssg\">https://vercel.com/templates/next.js/pagination-with-ssg</a></p>\n<p><a href=\"https://nextjs.org/docs/pages/api-reference/functions/get-static-paths#fallback-blocking\">https://nextjs.org/docs/pages/api-reference/functions/get-static-paths#fallback-blocking</a></p>\n<p>Incremental Static Regeneration\n<a href=\"https://nextjs.org/docs/pages/building-your-application/data-fetching/incremental-static-regeneration\">https://nextjs.org/docs/pages/building-your-application/data-fetching/incremental-static-regeneration</a></p>\n<p>tag manager 잘 쓰기 <a href=\"https://stackoverflow.com/questions/75521259/how-to-solve-reduce-the-impact-of-third-party-code-third-party-code-blocked-t\">https://stackoverflow.com/questions/75521259/how-to-solve-reduce-the-impact-of-third-party-code-third-party-code-blocked-t</a></p>\n<p><a href=\"https://web.dev/tag-best-practices/\">https://web.dev/tag-best-practices/</a></p>\n<p>이미지 로딩이 느린 이슈 <a href=\"https://github.com/vercel/next.js/discussions/21294#discussioncomment-4479278\">https://github.com/vercel/next.js/discussions/21294#discussioncomment-4479278</a></p>\n<p><a href=\"https://junheedot.tistory.com/entry/Next-Image-load-super-slow\">https://junheedot.tistory.com/entry/Next-Image-load-super-slow</a></p>\n<p><a href=\"https://nextjs.org/docs/messages/sharp-missing-in-production\">https://nextjs.org/docs/messages/sharp-missing-in-production</a></p>\n<p>vercel edge function <a href=\"https://vercel.com/docs/concepts/functions/edge-functions\">https://vercel.com/docs/concepts/functions/edge-functions</a></p>",
    "excerpt": "블로그 만들기 시리즈\n|제목|링크|\n|---|---|\n|1. 기본 세팅|https://witch.work/posts/blog-remake-1|\n|2. 메인 페이지의 HTML 설계|https://witch.work/posts/blog-remake-2|\n|3. 글 상세 페이지의 구조 설계|https://witch.work/posts/blog-remake-3|\n|4. 이미지를 상대 경로로 쓸 수 있도록 하기|https://witch.work/posts/blog-rem",
    "headingTree": [
      {
        "title": "블로그 만들기 시리즈",
        "url": "#블로그-만들기-시리즈",
        "items": []
      },
      {
        "title": "1. 페이지네이션으로 DOM 트리 줄이기",
        "url": "#1-페이지네이션으로-dom-트리-줄이기",
        "items": []
      },
      {
        "title": "2. Vercel Pagination Template 분석",
        "url": "#2-vercel-pagination-template-분석",
        "items": []
      },
      {
        "title": "3. CategoryPagination 컴포넌트",
        "url": "#3-categorypagination-컴포넌트",
        "items": []
      },
      {
        "title": "4. 페이지네이션 컴포넌트",
        "url": "#4-페이지네이션-컴포넌트",
        "items": []
      },
      {
        "title": "5. 개별 페이지 만들기",
        "url": "#5-개별-페이지-만들기",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 5,
      "wordCount": 1219
    },
    "url": "/posts/blog-opt-2",
    "thumbnail": {
      "local": "/static/category-page-lighthouse-59d42238.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-category-page-lighthouse-59d42238-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAFCAIAAAD38zoCAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAfklEQVR4nGP4////0YO7ls6b8h8MKioqdu7c+f//f4anT5/bW5spKsidPHvh////ra2tbW1tIIkjR4/1T5g4Z+HiK1dv/P//f8qUqdu2bQNJzJo9Mzc3+////7///Kmorpg0adLHjx8fP37M0NzcaGtlDpHYsnXzoSOHIJYBAIXrWTxuB0UvAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "blog-opt-3",
    "title": "블로그 최적화 - 3. 이미지 최적화",
    "date": "2023-06-11T03:00:00Z",
    "description": "겁나 빠른 마녀 : 블로그 최적화 그 세번째",
    "tags": [
      "blog",
      "web"
    ],
    "html": "<h1>블로그 만들기 시리즈</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>제목</th><th>링크</th></tr></thead><tbody><tr><td>1. 기본 세팅</td><td><a href=\"https://witch.work/posts/blog-remake-1\">https://witch.work/posts/blog-remake-1</a></td></tr><tr><td>2. 메인 페이지의 HTML 설계</td><td><a href=\"https://witch.work/posts/blog-remake-2\">https://witch.work/posts/blog-remake-2</a></td></tr><tr><td>3. 글 상세 페이지의 구조 설계</td><td><a href=\"https://witch.work/posts/blog-remake-3\">https://witch.work/posts/blog-remake-3</a></td></tr><tr><td>4. 이미지를 상대 경로로 쓸 수 있도록 하기</td><td><a href=\"https://witch.work/posts/blog-remake-4\">https://witch.work/posts/blog-remake-4</a></td></tr><tr><td>5. 자잘한 페이지 구성 개선과 배포</td><td><a href=\"https://witch.work/posts/blog-remake-5\">https://witch.work/posts/blog-remake-5</a></td></tr><tr><td>6. 페이지 요소의 배치 설계</td><td><a href=\"https://witch.work/posts/blog-remake-6\">https://witch.work/posts/blog-remake-6</a></td></tr><tr><td>7. 메인 페이지 컴포넌트 디자인</td><td><a href=\"https://witch.work/posts/blog-remake-7\">https://witch.work/posts/blog-remake-7</a></td></tr><tr><td>8. 글 목록/내용 페이지 컴포넌트 디자인</td><td><a href=\"https://witch.work/posts/blog-remake-8\">https://witch.work/posts/blog-remake-8</a></td></tr><tr><td>9. 글 썸네일 자동 생성하기</td><td><a href=\"https://witch.work/posts/blog-remake-9\">https://witch.work/posts/blog-remake-9</a></td></tr><tr><td>10. 폰트, 카드 디자인 등의 디자인 개선</td><td><a href=\"https://witch.work/posts/blog-remake-10\">https://witch.work/posts/blog-remake-10</a></td></tr><tr><td>11. 글에 조회수 달기</td><td><a href=\"https://witch.work/posts/blog-remake-11\">https://witch.work/posts/blog-remake-11</a></td></tr><tr><td>12. 페이지 테마와 글 검색 기능</td><td><a href=\"https://witch.work/posts/blog-remake-12\">https://witch.work/posts/blog-remake-12</a></td></tr><tr><td>13. 테마 아이콘과 썸네일 레이아웃 개선 등</td><td><a href=\"https://witch.work/posts/blog-remake-13\">https://witch.work/posts/blog-remake-13</a></td></tr><tr><td>14. 글 분류를 태그 기반으로 변경</td><td><a href=\"https://witch.work/posts/blog-remake-14\">https://witch.work/posts/blog-remake-14</a></td></tr><tr><td>메인 페이지의 연산 최적화</td><td><a href=\"https://witch.work/posts/blog-opt-1\">https://witch.work/posts/blog-opt-1</a></td></tr><tr><td>글 목록 페이지네이션 만들기</td><td><a href=\"https://witch.work/posts/blog-opt-2\">https://witch.work/posts/blog-opt-2</a></td></tr><tr><td>이미지를 CDN에 올리고 placeholder 만들기</td><td><a href=\"https://witch.work/posts/blog-opt-3\">https://witch.work/posts/blog-opt-3</a></td></tr><tr><td>검색 페이지에 무한 스크롤 구현하기</td><td><a href=\"https://witch.work/posts/blog-opt-4\">https://witch.work/posts/blog-opt-4</a></td></tr></tbody></table>\n<h1>1. 이미지 최적화</h1>\n<p>이미지를 전반적으로 최적화하는 글이다.\n일단 글 목록 페이지에 대한 lighthouse의 제안과 진단을 볼까? 음...점수는 처참하지만 천릿길도 한 걸음부터니까, 할 수 있는 걸 하자.</p>\n<p><img src=\"/static/category-page-diagnostics-ff52ee73.png\" alt=\"category-page-diagnostics\"></p>\n<p>아까처럼 이미지에 적당한 크기를 주라고 한다. Card 컴포넌트에서 Image 태그에 sizes를 지정하자.</p>\n<pre><code class=\"language-jsx\">function Card(props: Props) {\n/* 생략 */\n  &#x3C;Image \n    className={styles.image} \n    src={image} \n    alt={`${image} 사진`} \n    width={200} \n    height={200}\n    sizes='100px'\n  />\n/* 생략 */\n}\n</code></pre>\n<p>그리고 이미지의 <code>minimumCacheTTL</code> 도 30일로 설정한다. <code>next.config.js</code>에서 설정할 수 있다.</p>\n<pre><code class=\"language-js\">const nextConfig = {\n  images:{\n    unoptimized:false,\n    imageSizes: [64, 384],\n    deviceSizes: [768, 1920],\n    domains: ['res.cloudinary.com'],\n    minimumCacheTTL: 60*60*24*30,\n  },\n  reactStrictMode: false,\n  swcMinify:true,\n};\n</code></pre>\n<p>개발자 도구 Network 탭을 켜고 이미지가 있는 블로그 페이지를 열어서 받은 이미지의 응답 헤더를 까보면 <code>Cache-Control:public, max-age=0, must-revalidate</code>이라는 항목이 있다.</p>\n<p><code>minimumCacheTTL</code>을 설정하면 이 <code>Cache-Control</code>헤더의 <code>max-age</code>가 설정한 값으로 바뀐다. 나 같은 경우 2592000으로 바뀌었다.</p>\n<p>캐시를 의도적으로 삭제하기는 힘들기 때문에 낮게 유지하는 게 좋다고 하지만, 블로그에 쓰이는 이미지야 24시간에 한 번 캐시 갱신이면 충분하다고 생각한다. 이미지 업데이트 같은 걸 할 일이 있다고 한다면 24시간에 한 번 적용이면 충분하지.</p>\n<h1>2. Cloudinary 사용해보기</h1>\n<p>마침 매우 도움이 되는 글을 찾았다. <a href=\"https://vercel.com/blog/building-a-fast-animated-image-gallery-with-next-js\">매우 많은 이미지를 서빙하는 갤러리를 NextJS로 만드는 글</a>이 Vercel에서 공식으로 올라와 있었다!</p>\n<p>이 블로그에서는 cloudinary를 이용해서 이미지를 서빙했다고 한다. 한번 이걸 써보자.</p>\n<p>먼저 <a href=\"https://cloudinary.com/\">cloudinary</a>에 가입하자. 나는 구글로 가입했다. 그러면 마이페이지에 다음과 같은 화면이 나온다.</p>\n<p><img src=\"/static/cloudinary-after-login-9c1ce598.png\" alt=\"after-login\"></p>\n<p>여기의 좌측 메뉴에서 Media Library로 들어가면 Asset을 올릴 수 있다. 구글 드라이브와 거의 똑같은 UI라서 드래그 앤 드롭으로 이미지 등을 올리면 된다.</p>\n<p>예를 들어서 나는 samples 폴더에 내 프로필 사진을 올렸었는데 그러면 다음과 같은 URL을 얻을 수 있다. 사진에 마우스 커서를 올리면 URL을 복사할 수 있는 버튼이 있더라. <a href=\"https://cloudinary.com/documentation/transformation_reference\">URL의 구조는 공식 문서를 참고했다.</a></p>\n<pre><code>https://res.cloudinary.com/&#x3C;cloud_name>/&#x3C;asset_type>/&#x3C;delivery_type>/&#x3C;transformations>/&#x3C;version>/&#x3C;public_id_full_path>.&#x3C;extension>\n\nhttps://res.cloudinary.com/내 cloud name/asset 타입(image등)/어떻게 전송되었는지/버전/폴더명/witch_xjp39k.jpg\n</code></pre>\n<p>이런 걸 API를 이용해서 불러오려면 먼저 <code>.env.local</code>에 API 키를 설정하자. 이 키들은 Setting의 Access Keys 메뉴에서 가져올 수 있다.</p>\n<pre><code>NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME=replace\nCLOUDINARY_API_KEY=replace\nCLOUDINARY_API_SECRET=replace\n</code></pre>\n<p><code>next.config.js</code>에 다음과 같이 설정을 추가하여 <code>res.cloudinary.com</code>에서 이미지를 가져올 수 있게 허용한다.</p>\n<pre><code class=\"language-js\">/* nextConfig만 편집 */\nconst nextConfig = {\n  images:{\n    unoptimized:false,\n    imageSizes: [64, 384],\n    deviceSizes: [768, 1920],\n    /* 도메인에 cloudinary 추가 */\n    domains: ['res.cloudinary.com'],\n  },\n  reactStrictMode: false,\n  swcMinify:true,\n};\n</code></pre>\n<p>이제 이미지 URL을 이용해서 다음과 같이 이미지를 가져와볼 수 있다.</p>\n<pre><code class=\"language-jsx\">&#x3C;Image\n  src={`https://res.cloudinary.com/${process.env.NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME}/image/upload/v1686541466/samples/witch_xjp39k.jpg`}\n  alt='프로필 사진'\n  width={300}\n  height={300}\n/>\n</code></pre>\n<p>이를 Vercel에서도 쓸 수 있게 위의 환경변수들을 Vercel에서도 추가한다. 현재 환경 변수들은 다음과 같은 것들이 있다.</p>\n<p><img src=\"/static/vercel-env-var-a8c9394b.png\" alt=\"vercel 환경 변수들\"></p>\n<h1>3. 이미지 서빙 시스템 설계</h1>\n<p>기존에는 모든 이미지를 다 웹사이트 빌드 시에 같이 넣어 주었다. 그런데 이제는 cloudinary를 사용할 것이다. 하지만 그럼 기존에 쓰던 이미지 저장 방식은 아예 버려야 할까?</p>\n<p>그럴 수도 있겠지만 이미지 저장 방식을 바꿀 때 새로운 방식밖에 쓸 수 없도록 바꾸는 게 좋지는 않다고 생각한다. cloudinary를 무제한으로 쓸 수 있는 것도 아니기에 언젠가 기존의 저장 방식으로 돌아와야 할 수도 있다. 그리고 또다른 클라우드 저장소를 사용하게 될 수도 있다.</p>\n<p>이런 걱정을 하는 이유는 물론 돈이다. 나는 프리티어나 아주 저렴한 요금제밖에 쓸 수 없는데 cloudinary의 유료정책은 꽤 비싸니까...</p>\n<p><img src=\"/static/no-money-76352cc5.webp\" alt=\"돈이 없어\"></p>\n<p>따라서 <code>blog-config.ts</code>의 <code>blogConfig</code>에 이미지를 어디에 저장할지도 택할 수 있게 하자. 기본값은 <code>local</code>이다.</p>\n<p><code>blogConfig.imageStorage</code> 값이 <code>local</code>이면 <code>public/images</code>에 저장하고, <code>cloudinary</code>면 cloudinary에 저장하도록 하고 이미지 URL은 2가지로 저장하여 사용자가 설정하는 <code>blogConfig.imageStorage</code>에 따라서 불러오도록 하자.</p>\n<pre><code class=\"language-ts\">interface BlogConfigType {\n  name: string;\n  title: string;\n  description: string;\n  picture: string;\n  url: string;\n  social: {\n    Github: string;\n    BOJ: string;\n  };\n  comment: {\n      type: 'giscus';\n      repo: string;\n      repoId: string;\n      category: string;\n      categoryId: string;\n      lang?: 'ko' | 'en'; // defaults to 'en'\n      lazy?: boolean;\n    };\n    /* 이미지 저장소를 선택할 수 있도록 타입 지정 */\n  imageStorage: 'local' | 'cloudinary'; // defaults to 'local'\n  thumbnail: string;\n  googleAnalyticsId?: string; // gtag id\n}\n</code></pre>\n<h1>4. 메인 페이지 이미지 최적화</h1>\n<p>메인 페이지에 있는 이미지는 내 프로필의 것을 뺀다면 고작 4개뿐이다. 프로젝트들의 이미지들이다. 그리고 이는 동적으로 생성되는 게 아니기 때문에 바꾸기도 쉽다. Cloudinary에 업로드한 후 각 이미지를 쓰는 태그의 src를 바꿔주면 된다.</p>\n<p>먼저 <code>blog-project.ts</code>에서 프로젝트의 저장 시 image URL 타입을 local, cloudinary 두 URL 모두가 담길 수 있도록 변경하자.</p>\n<pre><code class=\"language-ts\">// blog-project.ts\nexport interface projectType {\n  title: string;\n  description: string;\n  image: {\n    local: string;\n    cloudinary: string;\n  };\n  url: {\n    title: string;\n    link: string;\n  }[];\n  techStack: string[];\n}\n</code></pre>\n<p>그리고 cloudinary media library에서 <code>/blog</code> 폴더를 생성한다.</p>\n<p><img src=\"/static/new-blog-folder-c4226917.png\" alt=\"블로그 폴더 생성\"></p>\n<p>이렇게 생성한 폴더에 프로젝트 사진들(<code>/public/project</code>에 있던 그 이미지들)을 업로드한다. 그러면 URL이 생기는데 이를 <code>projectList</code>의 프로젝트 이미지에 넣어주자.</p>\n<p>전체 URL을 넣어 놓으면 cloudinary cloud name이 노출되어서 문제가 있지 않을까 생각했는데 <a href=\"https://cloudinary.com/documentation/how_to_integrate_cloudinary\">cloudinary 공식 사이트의 글</a>을 보니 cloud name과 API key는 노출되어도 상관없다고 한다.</p>\n<p>API secret만 노출되지 않도록 잘 숨기면 된다고 한다. 따라서 <code>blog-project.ts</code>에서는 cloudinary URL을 다음과 같이 저장하자.</p>\n<pre><code class=\"language-ts\">const projectList: projectType[] = [\n  {\n    title: 'Witch-Work',\n    description: '직접 제작한 개인 블로그',\n    image:{\n      local:'/witch.jpeg',\n      cloudinary:'https://res.cloudinary.com/desigzbvj/image/upload/v1686565864/blog/witch_t17vcr.jpg'\n    },\n    /* URL, techStack 속성 생략 */\n  },\n  /* 나머지 프로젝트 객체 생략 */\n];\n</code></pre>\n<p>프로젝트를 보여주는 <code>ProjectCard</code> 컴포넌트에서는 <code>blogConfig.imageStorage</code>에 따라서 다른 이미지 URL을 사용하도록 하자.</p>\n<pre><code class=\"language-tsx\">// src/components/projectCard/index.tsx\nfunction ProjectCard({project}: {project: projectType}) {\n  return (\n    &#x3C;Link className={styles.wrapper} href={project.url[0].link} target='_blank'>\n      &#x3C;article className={styles.container} >\n        &#x3C;div className={styles.titlebox}>\n          &#x3C;ProjectTitle title={project.title} />\n        &#x3C;/div>\n        &#x3C;div className={styles.imagebox}>\n          &#x3C;ProjectImage title={project.title} image={project.image[blogConfig.imageStorage]} />\n        &#x3C;/div>\n        &#x3C;div className={styles.introbox}>\n          &#x3C;ProjectIntro project={project} />\n        &#x3C;/div>\n      &#x3C;/article>\n    &#x3C;/Link>\n  );\n}\n</code></pre>\n<h1>5. 글 썸네일 이미지 최적화</h1>\n<p>현재 글 썸네일 같은 경우 <code>src/plugins/make-thumbnail.mjs</code>에서 생성하여 변환 파일의 <code>data._raw.thumbnail</code>에 파일 경로를 넣어주고 있다. 따라서 기존의 파일 경로를 <code>thumbnail.local</code>로 바꾸고 <code>thumbnail.cloudinary</code>를 추가하자.</p>\n<p>그러기 위해서는 썸네일 생성과 함께 이미지 업로드가 먼저 되어야 한다. <code>make-thumbnail.mjs</code>의 기존 코드에서 이미지 생성까지는 이미 잘 하고 있으므로 cloudinary에 업로드하는 코드만 추가하면 된다. <code>makeThumbnail</code>함수를 수정하자.</p>\n<p><code>thumbnail.local</code>에 저장되어 있는 이미지를 cloudinary에 업로드하고 <code>thumbnail.cloudinary</code>에 URL을 저장하자. upload API 문서의 응답을 보면 응답의 <code>secure_url</code>에 이미지 URL이 담겨있다는 걸 알 수 있다. 이걸 썸네일 URL로 지정하자. 그냥 url도 있지만 그건 <code>http</code> 주소라서 그걸 쓰면 보안 경고가 뜰 것이다.</p>\n<pre><code class=\"language-js\">export default function makeThumbnail() {\n  return async function(tree, file) {\n    const images=extractImgSrc(tree);\n    if (images.length>0) {\n      file.data.rawDocumentData.thumbnail={\n        local: images[0],\n      };\n    }\n    else {\n      const title=file.value.split('\\n')[1].replace('title: ', '');\n      const {headingTree, sourceFilePath}=file.data.rawDocumentData;\n      const b=await createThumbnailFromText(title, headingTree, sourceFilePath);\n      file.data.rawDocumentData.thumbnail={\n        local: b,\n      };\n    }\n    /* 이 시점엔 썸네일이 하나씩은 있다 */\n    const results=await cloudinary.v2.uploader\n      .upload(\n        join(__dirname, 'public', file.data.rawDocumentData.thumbnail.local),{\n          folder: 'blog/thumbnails',\n          use_filename: true,\n        }\n      );\n    file.data.rawDocumentData.thumbnail.cloudinary=results.secure_url;\n  };\n}\n</code></pre>\n<p>그리고 이렇게 받아온 thumbnail 중 <code>blog-config.ts</code>에서 지정하고 있는 <code>imageStorage</code>를 사용하도록 하기 위해 <code>Card</code>컴포넌트를 수정한다. <code>CardProps</code> 함수도 수정하고 비슷한 타입을 쓰는 모든 부분을 수정한다.</p>\n<pre><code class=\"language-tsx\">// src/components/card/index.tsx\nexport interface CardProps{\n  title: string;\n  description: string;\n  thumbnail?: {\n    local: string;\n    cloudinary: string;\n  }\n  date: string;\n  tags: string[];\n  url: string;\n}\n\nfunction Card(props: CardProps) {\n  const { title, description, thumbnail, date, tags, url } = props;\n  return (\n    &#x3C;Link className={styles.link} href={url}>\n      &#x3C;article className={styles.container}>\n        {thumbnail ?\n          &#x3C;div>\n            &#x3C;Image \n              className={styles.image} \n              src={thumbnail[blogConfig.imageStorage]} \n              alt={`${title} 사진`} \n              width={200} \n              height={200}\n              sizes='100px'\n            />\n          &#x3C;/div>\n          :\n          null\n        }\n        &#x3C;Intro title={title} description={description} date={date} tags={tags} />\n      &#x3C;/article>\n    &#x3C;/Link>\n  );\n}\n</code></pre>\n<p>이렇게 thumbnail의 주소를 <code>blogConfig.imageStorage</code>에 따라서 다르게 가져오도록 수정해야 했던 코드의 다른 부분들은 <a href=\"https://github.com/witch-factory/witch-next-blog/commit/192c4a7adc8604b6a15ccfd7f1f309a149b2893b\">당시의 커밋 내역</a>에서 확인할 수 있다.</p>\n<h1>6. 이미지 중복 제거, 최적화</h1>\n<p>그런데 문제가 있다. <code>run dev</code>를 할 때마다 혹은 빌드할 때마다 <code>makeThumbnail</code>이 계속 실행되어서 이미지가 계속 올라간다는 것이다.</p>\n<p>이는 업로드 시 public ID를 주고, overwrite(같은 ID가 있을 때 덮어쓸지)를 false로 지정하면 된다.</p>\n<p><code>makeThumbnail</code>의 <code>upload</code> API 호출 부분을 다음과 같이 수정하자.</p>\n<pre><code class=\"language-js\">export default function makeThumbnail() {\n  return async function(tree, file) {\n    const images=extractImgSrc(tree);\n    if (images.length>0) {\n      file.data.rawDocumentData.thumbnail={\n        local: images[0],\n      };\n    }\n    else {\n      const title=file.value.split('\\n')[1].replace('title: ', '');\n      const {headingTree, sourceFilePath}=file.data.rawDocumentData;\n      const b=await createThumbnailFromText(title, headingTree, sourceFilePath);\n      file.data.rawDocumentData.thumbnail={\n        local: b,\n      };\n    }\n    /* 이 시점엔 썸네일이 하나씩은 있다 */\n    const results=await cloudinary.v2.uploader\n      .upload(\n        join(__dirname, 'public', file.data.rawDocumentData.thumbnail.local),{\n          public_id: file.data.rawDocumentData.thumbnail.local.replace('/','').replaceAll('/', '-').replaceAll('.','-'),\n          folder: 'blog/thumbnails',\n          overwrite:false,\n        }\n      );\n    file.data.rawDocumentData.thumbnail.cloudinary=\n      `https://res.cloudinary.com/${process.env.NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME}/image/upload/c_scale,w_300,f_auto/${results.public_id}`;\n  };\n}\n</code></pre>\n<p>위를 보면 이미지를 300px로 줄여서 가져오고, 자동으로 파일 양식을 최적화도 하도록 하는 것을 볼 수 있다. URL의 <code>c_scale,w_300,f_auto</code>이 부분이 그 역할을 수행한다.</p>\n<p>같은 작업을 프로젝트 이미지에도 해준다. 다음과 같은 형식으로 <code>blog-project.ts</code>의 배열을 수정하자.</p>\n<pre><code class=\"language-ts\">// blog-project.ts\nconst projectList: projectType[] = [\n  {\n    title: 'Witch-Work',\n    description: '직접 제작한 개인 블로그',\n    image:{\n      local:'/witch.jpeg',\n      /* 중간에 c_scale,w_400,f_auto이 들어간 걸 확인할 수 있다. 이 양식은 공식 변환 API 문서를 참고했다. */\n      cloudinary:'https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_400,f_auto/v1686565864/blog/witch_t17vcr.jpg'\n    },\n    url: [\n      {\n        title: 'URL',\n        link:'https://witch.work/'\n      },\n      {\n        title: 'Github',\n        link:'https://github.com/witch-factory/witch-next-blog'\n      },\n    ],\n    techStack: ['Next.js', 'React', 'TypeScript']\n  },\n]\n</code></pre>\n<h1>7. blur 이미지 제공</h1>\n<p>사진을 보내오는 서버가 아무리 빨라도 사실 용량이 작은 사진을 쓰는 것만큼 빨라질 수는 없다. 따라서 이미지 로딩 시점에 사용할 사진을 준비하자.</p>\n<p>cloudinary URL을 받아서 해당 이미지의 blur 이미지를 만들어주는 함수를 만들자. 이 함수는 <code>src/utils/generateBlurPlaceholder.ts</code>에 추가하자.</p>\n<p>그전에 <code>imagemin</code>이라는 라이브러리를 설치하자. 이 라이브러리는 이미지를 최적화해주는 라이브러리다. <code>imagemin-jpegtran</code>도. 그리고 여기에 필요한 타입 라이브러리도 설치한다.</p>\n<pre><code class=\"language-bash\">npm install imagemin imagemin-jpegtran\nnpm install --save @types/imagemin\nnpm install --save @types/imagemin-jpegtran\n</code></pre>\n<p>cloudinary URL의 이미지를 16px짜리 jpg로 받아서 <code>imagemin</code> 라이브러리를 이용해 축소한 후 base64로 인코딩하여 반환한다.</p>\n<pre><code class=\"language-js\">// src/utils/generateBlurPlaceholder.ts\nimport imagemin from 'imagemin';\nimport imageminJpegtran from 'imagemin-jpegtran';\n\nexport default async function getBase64ImageUrl(imageUrl: string) {\n  const response= await fetch(imageUrl.replace('w_300,f_auto', 'w_16,f_jpg'));\n  const buffer= await response.arrayBuffer();\n  const minified = await imagemin.buffer(Buffer.from(buffer), {\n    plugins: [imageminJpegtran()],\n  });\n  const blurURL = `data:image/jpeg;base64,${Buffer.from(minified).toString('base64')}`;\n  return blurURL;\n}\n</code></pre>\n<p>그리고 <code>makeThumbnail</code> 함수에서 위 함수를 이용해 썸네일의 blurURL을 생성해준다.</p>\n<pre><code class=\"language-js\">// src/plugins/make-thumbnail.mjs\nexport default function makeThumbnail() {\n  return async function(tree, file) {\n\n    /* canvas를 이용한 썸네일 생성, cloudinary 업로드하는 부분은 생략*/\n\n    file.data.rawDocumentData.thumbnail.cloudinary=\n      `https://res.cloudinary.com/${process.env.NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME}/image/upload/c_scale,w_300,f_auto/${results.public_id}`;\n\n    /* blurURL을 만드는 이 부분이 추가되었다 */\n    file.data.rawDocumentData.thumbnail.blurURL=await getBase64ImageUrl(file.data.rawDocumentData.thumbnail.cloudinary);\n  };\n}\n</code></pre>\n<p>썸네일을 보여주는 <code>Card</code> 컴포넌트에서도 이 blur placeholder를 사용하도록 해준다.</p>\n<pre><code class=\"language-tsx\">export interface CardProps{\n  title: string;\n  description: string;\n  thumbnail?: {\n    local: string;\n    cloudinary: string;\n    blurURL?: string;\n  }\n  date: string;\n  tags: string[];\n  url: string;\n}\n\nfunction Card(props: CardProps) {\n  const { title, description, thumbnail, date, tags, url } = props;\n  return (\n    &#x3C;Link className={styles.link} href={url}>\n      &#x3C;article className={styles.container}>\n        {thumbnail ?\n          &#x3C;div>\n            &#x3C;Image \n              className={styles.image} \n              style={{ transform: 'translate3d(0, 0, 0)' }}\n              src={thumbnail[blogConfig.imageStorage]} \n              alt={`${title} 사진`} \n              width={200} \n              height={200}\n              sizes='200px'\n              placeholder={'blurURL' in thumbnail ? 'blur' : 'empty'}\n              blurDataURL={thumbnail.blurURL}\n            />\n          &#x3C;/div>\n          :\n          null\n        }\n        &#x3C;Intro title={title} description={description} date={date} tags={tags} />\n      &#x3C;/article>\n    &#x3C;/Link>\n  );\n}\n</code></pre>\n<p>이미지를 불러올 때 블러 처리된 이미지가 잠시 보이는 것을 확인할 수 있을 것이다.</p>\n<p>그리고 <code>Image</code> 컴포넌트에 <code>style={{ transform: 'translate3d(0, 0, 0)' }}</code> 속성이 추가된 것을 볼 수 있다. 이건 요소를 옮기는 CSS인데 <code>(0,0,0)</code> 벡터만큼 평행이동한다는 뜻이므로 사실 아무 위치 변화가 없다.</p>\n<p>이런 의미없어 보이는 CSS를 쓴 이유는 이렇게 하면 일부 기기에서 해당 요소 렌더링 시 GPU를 사용하도록 해주기 때문이다. 특히 사파리에서 GPU 렌더링은 유용하다.</p>\n<p>내 블로그에는 큰 필요가 없었지만 다른 트릭들도 <a href=\"https://vercel.com/blog/building-a-fast-animated-image-gallery-with-next-js\">nextjs 이미지 갤러리 구축기</a>에 여럿 소개되어 있다.</p>\n<h1>참고</h1>\n<p>nextJS로 엄청 빠른 사진 갤러리 만드는 글 <a href=\"https://vercel.com/blog/building-a-fast-animated-image-gallery-with-next-js\">https://vercel.com/blog/building-a-fast-animated-image-gallery-with-next-js</a></p>\n<p>NextJS의 이미지 최적화 문서 <a href=\"https://nextjs.org/docs/pages/building-your-application/optimizing/images\">https://nextjs.org/docs/pages/building-your-application/optimizing/images</a></p>\n<p>이미지 업로드 API 공식문서 <a href=\"https://cloudinary.com/documentation/image_upload_api_reference#upload\">https://cloudinary.com/documentation/image_upload_api_reference#upload</a></p>\n<p>각종 이미지 최적화 기법이 담긴 글 <a href=\"https://junheedot.tistory.com/entry/Next-Image-load-super-slow\">https://junheedot.tistory.com/entry/Next-Image-load-super-slow</a></p>\n<p>위의 이미지 최적화에서 쓴 minimumCacheTTL에 관한 문서 <a href=\"https://nextjs.org/docs/pages/api-reference/components/image#minimumcachettl\">https://nextjs.org/docs/pages/api-reference/components/image#minimumcachettl</a></p>\n<p>loglocket의 nextjs 이미지 최적화에 관한 글 <a href=\"https://blog.logrocket.com/next-js-automatic-image-optimization-next-image/\">https://blog.logrocket.com/next-js-automatic-image-optimization-next-image/</a></p>\n<p>webp 자동 변환하여 갖고오기 <a href=\"https://cloudinary.com/guides/front-end-development/webp-format-technology-pros-cons-and-alternatives\">https://cloudinary.com/guides/front-end-development/webp-format-technology-pros-cons-and-alternatives</a></p>\n<p>cloudinary 이미지 변환 공식 문서 <a href=\"https://cloudinary.com/documentation/transformation_reference\">https://cloudinary.com/documentation/transformation_reference</a></p>\n<p>이미지 중복 피하기 <a href=\"https://support.cloudinary.com/hc/en-us/community/posts/5126315761682-Best-way-to-avoid-duplicated-files-\">https://support.cloudinary.com/hc/en-us/community/posts/5126315761682-Best-way-to-avoid-duplicated-files-</a></p>\n<p>cloudinary에서 중복 체크 api도 제공하긴 한다. <a href=\"https://cloudinary.com/blog/how_to_automatically_identify_similar_images_using_phash\">https://cloudinary.com/blog/how_to_automatically_identify_similar_images_using_phash</a></p>\n<p>nextjs 이미지 로더 <a href=\"https://nextjs.org/docs/app/api-reference/next-config-js/images#example-loader-configuration\">https://nextjs.org/docs/app/api-reference/next-config-js/images#example-loader-configuration</a></p>",
    "excerpt": "블로그 만들기 시리즈\n|제목|링크|\n|---|---|\n|1. 기본 세팅|https://witch.work/posts/blog-remake-1|\n|2. 메인 페이지의 HTML 설계|https://witch.work/posts/blog-remake-2|\n|3. 글 상세 페이지의 구조 설계|https://witch.work/posts/blog-remake-3|\n|4. 이미지를 상대 경로로 쓸 수 있도록 하기|https://witch.work/posts/blog-rem",
    "headingTree": [
      {
        "title": "블로그 만들기 시리즈",
        "url": "#블로그-만들기-시리즈",
        "items": []
      },
      {
        "title": "1. 이미지 최적화",
        "url": "#1-이미지-최적화",
        "items": []
      },
      {
        "title": "2. Cloudinary 사용해보기",
        "url": "#2-cloudinary-사용해보기",
        "items": []
      },
      {
        "title": "3. 이미지 서빙 시스템 설계",
        "url": "#3-이미지-서빙-시스템-설계",
        "items": []
      },
      {
        "title": "4. 메인 페이지 이미지 최적화",
        "url": "#4-메인-페이지-이미지-최적화",
        "items": []
      },
      {
        "title": "5. 글 썸네일 이미지 최적화",
        "url": "#5-글-썸네일-이미지-최적화",
        "items": []
      },
      {
        "title": "6. 이미지 중복 제거, 최적화",
        "url": "#6-이미지-중복-제거-최적화",
        "items": []
      },
      {
        "title": "7. blur 이미지 제공",
        "url": "#7-blur-이미지-제공",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 5,
      "wordCount": 1257
    },
    "url": "/posts/blog-opt-3",
    "thumbnail": {
      "local": "/static/category-page-diagnostics-ff52ee73.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-category-page-diagnostics-ff52ee73-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAnUlEQVR4nBXJsQqCUBQAUMf8M/fqM9zyByLoBxx1MvBdLOLpC3EzJ3EIS5CGurReTCK52mh41qMJ4QMAEfX98Ho8EymjQ3BOU00If2VZeZ6XtzpLs7Io6uvl3TTazvMc1z1Jea8qZv52HRExs7bdrGe6vlzMkzhGxE/b/oZhCgAwDMM0Tcd1EZGZx3GcQill2zYA7IPgGCoZRohIRH9a6GqvST7PZQAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "blog-opt-4",
    "title": "블로그 최적화 - 4. 검색 페이지 무한 스크롤, 아이콘 소스 최적화",
    "date": "2023-06-11T04:00:00Z",
    "description": "겁나 빠른 마녀 : 블로그 최적화 그 네번째",
    "tags": [
      "blog",
      "web"
    ],
    "html": "<h1>블로그 만들기 시리즈</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>제목</th><th>링크</th></tr></thead><tbody><tr><td>1. 기본 세팅</td><td><a href=\"https://witch.work/posts/blog-remake-1\">https://witch.work/posts/blog-remake-1</a></td></tr><tr><td>2. 메인 페이지의 HTML 설계</td><td><a href=\"https://witch.work/posts/blog-remake-2\">https://witch.work/posts/blog-remake-2</a></td></tr><tr><td>3. 글 상세 페이지의 구조 설계</td><td><a href=\"https://witch.work/posts/blog-remake-3\">https://witch.work/posts/blog-remake-3</a></td></tr><tr><td>4. 이미지를 상대 경로로 쓸 수 있도록 하기</td><td><a href=\"https://witch.work/posts/blog-remake-4\">https://witch.work/posts/blog-remake-4</a></td></tr><tr><td>5. 자잘한 페이지 구성 개선과 배포</td><td><a href=\"https://witch.work/posts/blog-remake-5\">https://witch.work/posts/blog-remake-5</a></td></tr><tr><td>6. 페이지 요소의 배치 설계</td><td><a href=\"https://witch.work/posts/blog-remake-6\">https://witch.work/posts/blog-remake-6</a></td></tr><tr><td>7. 메인 페이지 컴포넌트 디자인</td><td><a href=\"https://witch.work/posts/blog-remake-7\">https://witch.work/posts/blog-remake-7</a></td></tr><tr><td>8. 글 목록/내용 페이지 컴포넌트 디자인</td><td><a href=\"https://witch.work/posts/blog-remake-8\">https://witch.work/posts/blog-remake-8</a></td></tr><tr><td>9. 글 썸네일 자동 생성하기</td><td><a href=\"https://witch.work/posts/blog-remake-9\">https://witch.work/posts/blog-remake-9</a></td></tr><tr><td>10. 폰트, 카드 디자인 등의 디자인 개선</td><td><a href=\"https://witch.work/posts/blog-remake-10\">https://witch.work/posts/blog-remake-10</a></td></tr><tr><td>11. 글에 조회수 달기</td><td><a href=\"https://witch.work/posts/blog-remake-11\">https://witch.work/posts/blog-remake-11</a></td></tr><tr><td>12. 페이지 테마와 글 검색 기능</td><td><a href=\"https://witch.work/posts/blog-remake-12\">https://witch.work/posts/blog-remake-12</a></td></tr><tr><td>13. 테마 아이콘과 썸네일 레이아웃 개선 등</td><td><a href=\"https://witch.work/posts/blog-remake-13\">https://witch.work/posts/blog-remake-13</a></td></tr><tr><td>14. 글 분류를 태그 기반으로 변경</td><td><a href=\"https://witch.work/posts/blog-remake-14\">https://witch.work/posts/blog-remake-14</a></td></tr><tr><td>메인 페이지의 연산 최적화</td><td><a href=\"https://witch.work/posts/blog-opt-1\">https://witch.work/posts/blog-opt-1</a></td></tr><tr><td>글 목록 페이지네이션 만들기</td><td><a href=\"https://witch.work/posts/blog-opt-2\">https://witch.work/posts/blog-opt-2</a></td></tr><tr><td>이미지를 CDN에 올리고 placeholder 만들기</td><td><a href=\"https://witch.work/posts/blog-opt-3\">https://witch.work/posts/blog-opt-3</a></td></tr><tr><td>검색 페이지에 무한 스크롤 구현하기</td><td><a href=\"https://witch.work/posts/blog-opt-4\">https://witch.work/posts/blog-opt-4</a></td></tr></tbody></table>\n<h1>1. 검색 페이지 최적화</h1>\n<p>검색 페이지는 현재 너무 많은 DOM 트리 요소를 가지고 있다. 따라서 무한 스크롤을 이용해서 초기 로딩되는 요소를 줄여보자.</p>\n<p>그럼 무한 스크롤을 어떻게 구현해야 할까? 다음과 같은 방식을 생각할 수 있다. 만약 보여줄 글이 100개가 있다면, 처음에는 10개만 보여주고 스크롤이 일정 부분 이상 내려가게 되면 글을 10개 더 보여준다.</p>\n<p>또 스크롤이 더 내려가면 10개를 더 보여주고 하는 식으로 100개가 될 때까지 스크롤이 내려간 정도에 따라서 글들을 점진적으로 로딩하는 것이다.</p>\n<p>스크롤 감지를 위해서는 Intersection Observer API를 사용하면 된다. 빈 요소를 하나 맨 아래에 만든 다음 해당 요소가 뷰포트에서 관측될 때 글을 로딩하는 것이다.</p>\n<h2>1.1. 커스텀 훅 useIntersectionObserver</h2>\n<p>React 컴포넌트의 ref와 Intersection Observer options를 받아서 해당 ref와 뷰포트가 교차되는지 관찰하는 커스텀 훅을 <code>src/utils</code>에 작성하자.</p>\n<p>요소가 변할 때마다 Intersection Observer를 새로 만들어서 관찰하고, 해당 요소가 사라질 때는 관찰을 멈추는, 그리고 그 결과를 반환하는 훅이다.</p>\n<pre><code class=\"language-ts\">// src/utils/useIntersectionObserver.ts\nimport { RefObject, useState, useEffect, useRef } from 'react';\n\nfunction useIntersectionObserver(\n  elementRef: RefObject&#x3C;Element | null>,\n  options: IntersectionObserverInit={}\n) {\n  const [element, setElement] = useState&#x3C;Element | null>(null);\n  const [isIntersecting, setIsIntersecting] = useState(false);\n  const observer= useRef&#x3C;IntersectionObserver | null>(null);\n\n  useEffect(() => {\n    setElement(elementRef.current);\n  }, [elementRef]);\n\n  useEffect(() => {\n    if (!element) {return;}\n    observer.current?.disconnect();\n\n    observer.current = new IntersectionObserver(([entry]) => {\n      setIsIntersecting(entry.isIntersecting);\n    }, {...options});\n    observer.current?.observe(element);\n\n    return () => {\n      observer.current?.disconnect();\n    };\n  }, [element, options]);\n\n  return isIntersecting;\n}\n\nexport {useIntersectionObserver};\n</code></pre>\n<h2>1.2. 무한 스크롤 구현</h2>\n<p>이번에는 리액트 컴포넌트의 ref와 콜백 함수를 받아서, ref가 뷰포트에 들어오는 순간 콜백을 실행하도록 하는 훅을 만들자.</p>\n<p>threshold는 intersection observer API의 옵션으로 ref와 뷰포트(사실 어디와의 교차를 감지할 것인지는 API에서 설정할 수 있는 값이지만, 기본값이 뷰포트이기 때문에 여기서는 따로 설정해 주지 않았다)가 얼마나 겹칠 때 교차되었다고 판단할 것인지를 결정하는 값이다.</p>\n<p>여기선 <code>0.0</code>으로 설정했는데, 이는 ref가 뷰포트에 단 1px라도 감지되는 순간 교차 판정을 내리도록 한다는 것이다.</p>\n<pre><code class=\"language-ts\">// src/utils/useInfiniteScroll.ts\nimport { MutableRefObject, useEffect } from 'react';\n\nimport { useIntersectionObserver } from '@/utils/useIntersectionObserver';\n\nfunction useInfiniteScroll (\n  ref: MutableRefObject&#x3C;Element | null>,\n  callback: () => void\n) {\n  /* 뷰포트와 ref의 intersection observe */\n  const shouldLoadMore = useIntersectionObserver(ref, { threshold: 0.0 });\n\n  useEffect(() => {\n    if (shouldLoadMore) {\n      callback();\n    }\n  }, [shouldLoadMore, callback]);\n};\n\nexport { useInfiniteScroll };\n</code></pre>\n<h2>1.3. 적용</h2>\n<p>그리고 이를 적용하자. <code>src/pages/posts/index.tsx</code>에서 <code>useInfiniteScroll</code> 훅을 이용해서 무한 스크롤을 구현하면 된다.</p>\n<p>맨 밑에 빈 div를 만들고, 뷰포트에 해당 요소가 들어오면 보여지는 페이지를 늘려 주는 동작을 한다.</p>\n<pre><code class=\"language-tsx\">// src/pages/posts/index.tsx\nfunction PostSearchPage({\n  category, postList,\n}: InferGetStaticPropsType&#x3C;typeof getStaticProps>) {\n  const [searchKeyword, debouncedKeyword, setSearchKeyword]=useSearchKeyword();\n  const [filteredPostList, setFilteredPostList]=useState&#x3C;CardProps[]>(postList);\n  const [page, setPage]=useState&#x3C;number>(1);\n\n  const infiniteScrollRef=useRef&#x3C;HTMLDivElement>(null);\n  const totalPage=Math.ceil(filteredPostList.length/ITEMS_PER_PAGE);\n\n  const onKeywordChange = useCallback((event: ChangeEvent&#x3C;HTMLInputElement>) => {\n    setSearchKeyword(event.target.value);\n  }, [setSearchKeyword]);\n\n  useEffect(() => {\n    setFilteredPostList(filterPostsByKeyword(postList, debouncedKeyword));\n  }, [debouncedKeyword]);\n\n  /* 이번 수정의 핵심 로직이다. 스크롤이 infiniteScrollRef 컴포넌트와 교차시\n  보여주는 글의 인덱스를 늘려주는 콜백 실행 */\n  useInfiniteScroll(infiniteScrollRef, useCallback(()=>{\n    if (page&#x3C;totalPage) {\n      setPage(prev=>prev+1);\n    }\n  }, [page, totalPage]));\n\n  return (\n    &#x3C;PageContainer>\n      &#x3C;h2 className={styles.title}>{`${category} 검색`}&#x3C;/h2>\n      &#x3C;SearchConsole \n        value={searchKeyword}\n        onChange={onKeywordChange}\n      />\n      &#x3C;ul className={styles.list}>\n        {filteredPostList.slice(0, ITEMS_PER_PAGE * page).map((post: CardProps) => \n          &#x3C;li key={post.url}>\n            &#x3C;Card {...post} />\n          &#x3C;/li>\n        )}\n      &#x3C;/ul>\n      &#x3C;div ref={infiniteScrollRef} />\n    &#x3C;/PageContainer>\n  );\n}\n</code></pre>\n<h2>1.4. 뒤로가기 문제 해결</h2>\n<p>검색 페이지에 진입한 뒤에 뒤로가기를 누르거나, 검색 페이지에서 아무것도 입력하지 않은 상태에서 카드 링크를 통해 글로 이동한 후 뒤로가기를 누르면 이전 페이지로 바로 이동하지 않는 문제가 있었다.</p>\n<p><code>useSearchKeyword</code> 함수에서 발생한 문제였는데 <code>debouncedKeyword</code>를 <code>parsed.search</code> 즉 쿼리스트링에 있는 현재 검색어와 비교해서 새로운 페이지를 히스토리에 추가하는 로직이 있었다.</p>\n<p>그런데 검색어가 아무것도 없는 상태에서는 <code>parsed.search</code>가 없기에 <code>debouncedKeyword===parsed.search</code> 비교문을 넘어가고 히스토리에 해당 페이지가 추가된다. 따라서 검색어가 없는 상태에서 뒤로가기를 누르면 이전 페이지로 바로 이동하지 않는 것이다.</p>\n<p>따라서 <code>parsed.search</code>가 없을 경우 빈 문자열과 비교하도록 하는 로직으로 수정했다. 이렇게 하면 검색어가 없는 상태에서 뒤로가기를 눌렀을 때 이전 페이지로 바로 이동한다.</p>\n<pre><code class=\"language-ts\">// src/utils/useSearchKeyword.ts\nfunction useSearchKeyword(): [string, string, (s: string) => void] {\n  const [keyword, setKeyword] = useState('');\n  const debouncedKeyword = useDebounce(keyword, 300);\n\n  /* onPopState 함수 생략 */\n  /* popstate 관련 useEffect 생략 */\n\n  useEffect(() => {\n    const parsed = queryString.parse(location.search);\n    /* 이 부분에서 parsed.search가 없을 경우 빈 문자열과 비교하는 것을 추가했다. */\n    if (debouncedKeyword===(parsed.search ?? '')) return;\n\n    parsed.search = debouncedKeyword;\n\n    const nextURL=queryString.stringifyUrl({\n      url: location.pathname,\n      query: parsed,\n    }, {\n      skipEmptyString: true,\n      skipNull: true,\n    });\n\n    history.pushState(parsed, '', nextURL);\n  }, [debouncedKeyword]);\n\n  return [keyword, debouncedKeyword, setKeyword];\n}\n</code></pre>\n<h1>2. 아이콘 소스 base64로 변경</h1>\n<p>헤더에 있는 아이콘들의 로딩과 모드에 따른 전환이 느리다는 생각이 든다. 따라서 이를 base64 인코딩 기반으로 바꿔보자.</p>\n<p>기존에 쓰던 아이콘들의 base64 인코딩이 문자열 변수 형태로 정의된 파일 <code>src/utils/iconsURL.ts</code>를 만들자.</p>\n<pre><code class=\"language-ts\">const searchIcon='data:image/png;base64, 어쩌고저쩌고';\nconst searchIconDark='data:image/png;base64, 어쩌고저쩌고';\nconst searchIconPink='data:image/png;base64, 어쩌고저쩌고';\n\nconst hamburgerIcon='data:image/png;base64, 어쩌고저쩌고';\nconst hamburgerIconDark='data:image/png;base64, 어쩌고저쩌고';\nconst hamburgerIconPink='data:image/png;base64, 어쩌고저쩌고';\n\nconst cancelIcon='data:image/png;base64, 어쩌고저쩌고';\nconst cancelIconPink='data:image/png;base64, 어쩌고저쩌고';\n\nconst linkIcon='data:image/png;base64, 어쩌고저쩌고';\nconst linkIconDark='data:image/png;base64, 어쩌고저쩌고';\nconst linkIconPink='data:image/png;base64, 어쩌고저쩌고';\n\nexport {\n  searchIcon,\n  searchIconDark,\n  searchIconPink,\n\n  hamburgerIcon,\n  hamburgerIconDark,\n  hamburgerIconPink,\n\n  cancelIcon,\n  cancelIconDark,\n  cancelIconPink,\n\n  linkIcon,\n  linkIconDark,\n  linkIconPink,\n};\n</code></pre>\n<p>그리고 아이콘들의 src를 결정하는 객체에서 이 변수들을 import해서 사용한다. 이렇게 하면 이미지를 브라우저에서 캐싱할 수 없게 되지만 대신 매우 빠른 속도로 이미지를 서빙할 수 있다.</p>\n<pre><code class=\"language-ts\">// src/components/header/menu/toggler/index.tsx\nconst hamburgerIconMap: {[key: string]: string} = {\n  'light':hamburgerIcon,\n  'dark':hamburgerIconDark,\n  'pink':hamburgerIconPink,\n};\n\nconst cancelIconMap: {[key: string]: string} = {\n  'light':cancelIcon,\n  'dark':cancelIconDark,\n  'pink':cancelIconPink,\n};\n</code></pre>\n<p>검색 아이콘도 똑같이 base64 문자열로 src를 변경한다.</p>\n<pre><code class=\"language-tsx\">// src/components/header/search/index.tsx\nimport { searchIcon, searchIconDark, searchIconPink } from '@/utils/iconsURL';\n\nconst searchIconMap: {[key: string]: string}={\n  'light':searchIcon,\n  'dark':searchIconDark,\n  'pink':searchIconPink,\n};\n</code></pre>\n<h1>참고</h1>\n<p>intersection observer API <a href=\"https://developer.mozilla.org/ko/docs/Web/API/Intersection_Observer_API\">https://developer.mozilla.org/ko/docs/Web/API/Intersection_Observer_API</a></p>\n<p><a href=\"https://www.bucketplace.com/post/2020-09-10-%EC%98%A4%EB%8A%98%EC%9D%98%EC%A7%91-%EB%82%B4-%EB%AC%B4%ED%95%9C%EC%8A%A4%ED%81%AC%EB%A1%A4-%EA%B0%9C%EB%B0%9C%EA%B8%B0/\">https://www.bucketplace.com/post/2020-09-10-%EC%98%A4%EB%8A%98%EC%9D%98%EC%A7%91-%EB%82%B4-%EB%AC%B4%ED%95%9C%EC%8A%A4%ED%81%AC%EB%A1%A4-%EA%B0%9C%EB%B0%9C%EA%B8%B0/</a></p>",
    "excerpt": "블로그 만들기 시리즈\n|제목|링크|\n|---|---|\n|1. 기본 세팅|https://witch.work/posts/blog-remake-1|\n|2. 메인 페이지의 HTML 설계|https://witch.work/posts/blog-remake-2|\n|3. 글 상세 페이지의 구조 설계|https://witch.work/posts/blog-remake-3|\n|4. 이미지를 상대 경로로 쓸 수 있도록 하기|https://witch.work/posts/blog-rem",
    "headingTree": [
      {
        "title": "블로그 만들기 시리즈",
        "url": "#블로그-만들기-시리즈",
        "items": []
      },
      {
        "title": "1. 검색 페이지 최적화",
        "url": "#1-검색-페이지-최적화",
        "items": [
          {
            "title": "1.1. 커스텀 훅 useIntersectionObserver",
            "url": "#11-커스텀-훅-useintersectionobserver",
            "items": []
          },
          {
            "title": "1.2. 무한 스크롤 구현",
            "url": "#12-무한-스크롤-구현",
            "items": []
          },
          {
            "title": "1.3. 적용",
            "url": "#13-적용",
            "items": []
          },
          {
            "title": "1.4. 뒤로가기 문제 해결",
            "url": "#14-뒤로가기-문제-해결",
            "items": []
          }
        ]
      },
      {
        "title": "2. 아이콘 소스 base64로 변경",
        "url": "#2-아이콘-소스-base64로-변경",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 2,
      "wordCount": 628
    },
    "url": "/posts/blog-opt-4",
    "thumbnail": {
      "local": "/thumbnails/blog-opt-4-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-blog-opt-4-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAkklEQVR4nE3JMQrDIBQAUJ1zjDoGPIGQSQR3p8yZnISAq+AZWsHJVWjoki65gifwEM6Cwy/t1Lc+tG0bY8x7TyldluU4DmutlBJxzqdpWtf1RogxhnM+zzMhBMUYtdZCCIxxCKGUcl1XrRWllLTWzrl931trADDGAAB0fwSllDHGWtt7Hz/fyM9Xzvl9nrVW+PMBHrlTLDVpVMwAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "blog-refactor-2024-1",
    "title": "블로그 리팩토링 - 1. contentlayer에서 velite로",
    "date": "2024-03-20T01:00:00Z",
    "description": "이분 탐색의 활용에 대해 알아봅니다.",
    "tags": [
      "algorithm"
    ],
    "html": "<p>nextjs 14가 나왔고, 블로그에 쓰였던 라이브러리들도 업데이트가 많이 되었다. 또한 지금 다 파악할 수 없는 여러 가지 이유로 블로그 속도도 많이 느려졌다. 그래서 블로그를 리팩토링 해보기로 했다. 리팩토링을 하고 나서 최적화를 진행할 것이다.</p>\n<h1>to pnpm</h1>\n<p>기존에 yarn classic을 사용하고 있었는데 pnpm으로 전환하였다. 다음 글을 참고했다.</p>\n<p><a href=\"https://medium.com/wantedjobs/yarn-classic%EC%97%90%EC%84%9C-pnpm%EC%9C%BC%EB%A1%9C-%EC%A0%84%ED%99%98%ED%95%98%EA%B8%B0-with-turborepo-7c0c37cb3f9e\">Yarn Classic에서 Pnpm으로 전환하기 with TurboRepo</a></p>\n<h1>1. contentlayer의 대안들</h1>\n<p><code>.md</code> 파일을 변환할 때 contentlayer라는 라이브러리를 사용하였다. <a href=\"https://github.com/contentlayerdev/contentlayer/issues/429\">하지만 이는 더 이상 유지보수되지 않고 있다.</a></p>\n<p>contentlayer의 원래 메인테이너는 Prisma에 관여하고 있고 후원을 받지 않는 개발은 할 수 없는 상태인데 Vercel에서 contentlayer에 대한 후원을 중단했다고 한다. netlify와 협의 중이지만 어떻게 될지 모른다고 한다.</p>\n<p>그래서 대안을 찾아 보기로 했다. 먼저 contentlayer는 제거하였다.</p>\n<pre><code class=\"language-bash\">yarn remove contentlayer next-contentlayer\n</code></pre>\n<h2>1.1. @next/mdx</h2>\n<p><a href=\"https://nextjs.org/docs/app/building-your-application/configuring/mdx\">nextjs 공식 문서에서도 마크다운을 변환하는 방법을 소개하고 있었다.</a> 공식 문서에도 있는 만큼 contentlayer와 같이 갑자기 유지보수가 중단되지 않을 것이다.</p>\n<p>하지만 몇 가지 단점이 있었다.</p>\n<p>먼저 contentlayer에서는 프로젝트 루트의 /posts 경로에서 글을 관리했었는데 모든 글을 app/ 디렉토리에 넣어야 한다. next-mdx-remote를 사용하여 해결할 수 있지만 rsc 지원이 아직 불안정하고 또한 next-mdx-remote는 원격으로 데이터를 가져오기 위한 라이브러리인데 이를 다른 로컬 경로에 있는 파일을 가져오기 위한 라이브러리로 사용하는 것은 좋지 않다.</p>\n<p>또한 원하는 대로 커스터마이징하기 어렵다. contentlayer는 아예 .md 파일 내용을 HTML 형식의 문자열로 만들어 주고 이를 사용자가 가져다가 커스터마이징할 수 있었다. 하지만 <code>@next/mdx</code>는 .md나 .mdx 파일을 하나의 페이지로 만드는 형식이기 때문에 커스텀이 상대적으로 어렵다.</p>\n<p>각 컴포넌트의 스타일링도 CSS를 통해서 쉽게 할 수 있었던 contentlayer와 달리 <code>mdx-components.tsx</code> 파일을 만들어서 커스텀 컴포넌트를 만들어야 한다.</p>\n<p>기존 코드와의 호환성과 유지보수를 위해 다른 대안을 찾아보기로 했다.</p>\n<h2>1.2. marked</h2>\n<p><a href=\"https://blog.itcode.dev/posts/2021/10/28/nextjs-reorganization-4\">블로그 개편기 - 4. marked를 활용한 마크다운 변환기 구현하기</a>에서 사용하고 있는 marked 라이브러리도 방법이었다.</p>\n<p>하지만 이 역시 따로 .md 파일을 HTML로 변환하는 방법을 찾아야 하고, 커스텀 컴포넌트를 만들어야 한다. 잘 사용하고 있던 remark와 rehype 플러그인도 버려야 한다. 기각했다.</p>\n<h2>1.3. velite</h2>\n<p><a href=\"https://github.com/contentlayerdev/contentlayer/issues/429\">contentlayer의 유지보수 이슈</a>를 보면 velite라는 라이브러리의 제작자가 홍보하고 있었다. 스타는 고작 173개짜리 라이브러리다. 당연히 많이 사용되는 라이브러리는 아닌 것 같다.</p>\n<p>하지만 contentlayer에 비해 훨씬 코드가 간단했고 마크다운의 타입 정의도 지원했으며 기존 contentlayer 코드와 호환성도 좋았다. 그래서 이를 사용하기로 했다. 오픈소스 기여를 탐내고 있는 나로서는 이 라이브러리에 기여하면서 쓸 수도 있을 것이다.</p>\n<p>그래서 이 글에서는 기존의 contentlayer를 velite로 대체하는 작업을 진행할 것이다.</p>\n<h1>2. 설치와 기본 설정</h1>\n<p><a href=\"https://velite.js.org/\">velite 공식 문서</a>를 참고하였다.</p>\n<pre><code class=\"language-bash\">pnpm add velite -D\n</code></pre>\n<p>현재 contentlayer의 변환 문서 형식</p>\n<pre><code class=\"language-json\">{\n  \"title\": \"C-through - 1. Implicit int rule\",\n  \"description\": \"C언어의 implicit int rule에 대하여\",\n  \"date\": \"2022-01-09T00:00:00.000Z\",\n  \"tags\": [\n    \"language\"\n  ],\n  \"body\": {\n    \"raw\": \"글의 내용 그대로\",\n    \"html\": \"글 내용을 변환한 HTML 형식 문자열\"\n  },\n  \"_id\": \"c-through-1/index.md\",\n  \"_raw\": {\n    \"sourceFilePath\": \"c-through-1/index.md\",\n    \"sourceFileName\": \"index.md\",\n    \"sourceFileDir\": \"c-through-1\",\n    \"contentType\": \"markdown\",\n    \"flattenedPath\": \"c-through-1\",\n    \"headingTree\": [\n      {\n        \"data\": {\n          \"hProperties\": {\n            \"title\": \"1. C-through\",\n            \"id\": \"1.-C-through\"\n          }\n        },\n        \"depth\": 1,\n        \"children\": []\n      },\n      {\n        \"data\": {\n          \"hProperties\": {\n            \"title\": \"2. \\\"Implicit int\\\" rule\",\n            \"id\": \"2.-\\\"Implicit-int\\\"-rule\"\n          }\n        },\n        \"depth\": 1,\n        \"children\": []\n      },\n      {\n        \"data\": {\n          \"hProperties\": {\n            \"title\": \"3. 참고\",\n            \"id\": \"3.-참고\"\n          }\n        },\n        \"depth\": 1,\n        \"children\": []\n      }\n    ],\n    \"thumbnail\": {\n      \"local\": \"/thumbnails/c-through-1-index-md-thumbnail.png\",\n      \"cloudinary\": \"https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/thumbnails-c-through-1-index-md-thumbnail-png\",\n      \"blurURL\": \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAgUlEQVR4nGNYvXp1SkpKenq6t7f30qVLd+7c+R8MGHp7e6WlpdXU1Dg4OLKysl69evX792+QREtLi5yc3MWLF69evXrjxg2IcpDEnj27m5ubjhw58uXLl99gAJWYM2dxaGhYYmLi0qVLr169+v//f6hREVG5be19O3fuQBb9//8/ALhkZ3yrHgJ0AAAAAElFTkSuQmCC\"\n    }\n  },\n  \"type\": \"Post\",\n  \"url\": \"/posts/c-through-1\"\n}\n</code></pre>\n<h1>참고</h1>\n<p><a href=\"https://velog.io/@gomiseki/Next.js%EC%97%90%EC%84%9C-MDX-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%A5%BC-%EC%8A%A4%ED%83%80%EC%9D%BC%EB%A7%81%ED%95%98%EA%B8%B0-%ED%8E%B8%ED%95%98%EA%B2%8C\">Next.js에서 MDX 컴포넌트를 스타일링하기 (편?하게)</a></p>\n<p><a href=\"https://nextjs.org/docs/app/building-your-application/configuring/mdx\">Next.js docs - Markdown and MDX</a></p>\n<p><a href=\"https://medium.com/wantedjobs/yarn-classic%EC%97%90%EC%84%9C-pnpm%EC%9C%BC%EB%A1%9C-%EC%A0%84%ED%99%98%ED%95%98%EA%B8%B0-with-turborepo-7c0c37cb3f9e\">Yarn Classic에서 Pnpm으로 전환하기 with TurboRepo</a></p>",
    "excerpt": "nextjs 14가 나왔고, 블로그에 쓰였던 라이브러리들도 업데이트가 많이 되었다. 또한 지금 다 파악할 수 없는 여러 가지 이유로 블로그 속도도 많이 느려졌다. 그래서 블로그를 리팩토링 해보기로 했다. 리팩토링을 하고 나서 최적화를 진행할 것이다.\nto pnpm\n기존에 yarn classic을 사용하고 있었는데 pnpm으로 전환하였다. 다음 글을 참고했다.\nYarn Classic에서 Pnpm으로 전환하기 with TurboRepo\n1. contentlayer의",
    "headingTree": [
      {
        "title": "to pnpm",
        "url": "#to-pnpm",
        "items": []
      },
      {
        "title": "1. contentlayer의 대안들",
        "url": "#1-contentlayer의-대안들",
        "items": [
          {
            "title": "1.1. @next/mdx",
            "url": "#11-nextmdx",
            "items": []
          },
          {
            "title": "1.2. marked",
            "url": "#12-marked",
            "items": []
          },
          {
            "title": "1.3. velite",
            "url": "#13-velite",
            "items": []
          }
        ]
      },
      {
        "title": "2. 설치와 기본 설정",
        "url": "#2-설치와-기본-설정",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 234
    },
    "url": "/posts/blog-refactor-2024-1",
    "thumbnail": {
      "local": "/thumbnails/blog-refactor-2024-1-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-blog-refactor-2024-1-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAk0lEQVR4nGNITEy0srKaMmWKnp6+srJyVlbWtm3bfvz4wVBbW2toaOjt7W1iYqKmpi4mJmZubv7q1SuGKVOmyMnJ8fDwtLS0XLx48dSpU1evXgXpOHz4UFVV1aZNm+7fv//5y5f/MMAwd9788PDwrq6u2bNnT5w48QtMjmHJ8tWLlyxdvXr11atX//////v3b4gEALbNWcNZ3oE5AAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "blog-remake-1",
    "title": "블로그 만들기 - 1. 기본 세팅",
    "date": "2023-05-19T01:00:00Z",
    "description": "블로그를 새로 만드는 일의 시작",
    "tags": [
      "blog",
      "web"
    ],
    "html": "<h1>블로그 만들기 시리즈</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>제목</th><th>링크</th></tr></thead><tbody><tr><td>1. 기본 세팅</td><td><a href=\"https://witch.work/posts/blog-remake-1\">https://witch.work/posts/blog-remake-1</a></td></tr><tr><td>2. 메인 페이지의 HTML 설계</td><td><a href=\"https://witch.work/posts/blog-remake-2\">https://witch.work/posts/blog-remake-2</a></td></tr><tr><td>3. 글 상세 페이지의 구조 설계</td><td><a href=\"https://witch.work/posts/blog-remake-3\">https://witch.work/posts/blog-remake-3</a></td></tr><tr><td>4. 이미지를 상대 경로로 쓸 수 있도록 하기</td><td><a href=\"https://witch.work/posts/blog-remake-4\">https://witch.work/posts/blog-remake-4</a></td></tr><tr><td>5. 자잘한 페이지 구성 개선과 배포</td><td><a href=\"https://witch.work/posts/blog-remake-5\">https://witch.work/posts/blog-remake-5</a></td></tr><tr><td>6. 페이지 요소의 배치 설계</td><td><a href=\"https://witch.work/posts/blog-remake-6\">https://witch.work/posts/blog-remake-6</a></td></tr><tr><td>7. 메인 페이지 컴포넌트 디자인</td><td><a href=\"https://witch.work/posts/blog-remake-7\">https://witch.work/posts/blog-remake-7</a></td></tr><tr><td>8. 글 목록/내용 페이지 컴포넌트 디자인</td><td><a href=\"https://witch.work/posts/blog-remake-8\">https://witch.work/posts/blog-remake-8</a></td></tr><tr><td>9. 글 썸네일 자동 생성하기</td><td><a href=\"https://witch.work/posts/blog-remake-9\">https://witch.work/posts/blog-remake-9</a></td></tr><tr><td>10. 폰트, 카드 디자인 등의 디자인 개선</td><td><a href=\"https://witch.work/posts/blog-remake-10\">https://witch.work/posts/blog-remake-10</a></td></tr><tr><td>11. 글에 조회수 달기</td><td><a href=\"https://witch.work/posts/blog-remake-11\">https://witch.work/posts/blog-remake-11</a></td></tr><tr><td>12. 페이지 테마와 글 검색 기능</td><td><a href=\"https://witch.work/posts/blog-remake-12\">https://witch.work/posts/blog-remake-12</a></td></tr><tr><td>13. 테마 아이콘과 썸네일 레이아웃 개선 등</td><td><a href=\"https://witch.work/posts/blog-remake-13\">https://witch.work/posts/blog-remake-13</a></td></tr><tr><td>14. 글 분류를 태그 기반으로 변경</td><td><a href=\"https://witch.work/posts/blog-remake-14\">https://witch.work/posts/blog-remake-14</a></td></tr><tr><td>메인 페이지의 연산 최적화</td><td><a href=\"https://witch.work/posts/blog-opt-1\">https://witch.work/posts/blog-opt-1</a></td></tr><tr><td>글 목록 페이지네이션 만들기</td><td><a href=\"https://witch.work/posts/blog-opt-2\">https://witch.work/posts/blog-opt-2</a></td></tr><tr><td>이미지를 CDN에 올리고 placeholder 만들기</td><td><a href=\"https://witch.work/posts/blog-opt-3\">https://witch.work/posts/blog-opt-3</a></td></tr><tr><td>검색 페이지에 무한 스크롤 구현하기</td><td><a href=\"https://witch.work/posts/blog-opt-4\">https://witch.work/posts/blog-opt-4</a></td></tr></tbody></table>\n<h1>1. 시작</h1>\n<p>여기 있는 그림은 짤이 아니라면 <a href=\"https://excalidraw.com/\">excalidraw</a>로 그려졌다.</p>\n<p><img src=\"/static/self-made-d7bf3411.jpeg\" alt=\"self-made\"></p>\n<p>2023년 5월 19일 시점, 내가 쓰고 있는 블로그는 <a href=\"https://xo.dev/\">이창희</a>님이 만든 gatsby-starter-lavender 블로그 테마에 기초해 있다.</p>\n<p>하지만 이 블로그는 내가 원하는 기능을 모두 갖추고 있지는 않다. 또한 나는 Gatsby를 잘 모르기 때문에 이를 손수 추가하는 데에도 한계가 있었다. 따라서 마침 배우려고 하고 있던 NextJS의 튜토리얼이 블로그 만들기임에 착안해서 이참에 내 블로그를 만들어 보기로 했다.</p>\n<p>NextJS 튜토리얼에서는 <a href=\"https://next-learn-starter.vercel.app/\">이런 블로그</a>를 만드는 튜토리얼을 제공한다. 이미 내가 따라해 보기도 했다.</p>\n<p>하지만 나는 원하는 기능이 있기 때문에 몇 가지를 추가한 것을 만들어 보도록 하겠다. 레이아웃은 <a href=\"https://github.com/blurfx/ambienxo\">ambienxo</a>와 내 기존 블로그 테마 등을 참고하였다. 그리고 NextJS 튜토리얼에 보면 NextJS의 장점 같은 것들도 길게길게 써놓았는데, 그런 건 여기에 옮기지 않는다. 블로그 만드는 데 코드 스플리팅을 굳이 자세히 쓸 건 없으니..</p>\n<p>그리고 블로그를 제작하며 무언가를 결정할 때 꼭 이유를 설명할 수 있도록 노력하였다. 그럴 수 없는 것들도 분명 나올 것이다. 가령 나는 디자이너가 아니기 때문에 '이 레이아웃이 깔끔해 보이는 이유'를 근본적으로 설명하기는 힘들 것이다. 하지만 개발 쪽에서의 문제에 대해, 가령 '왜 이 라이브러리를 사용했죠?' 라는 질문이 들어왔을 때 그 이유가 단순히 찾아봤더니 그게 나와서, 따위가 되지는 않는 것을 목표로 작업하였다.</p>\n<h1>2. 레이아웃</h1>\n<p>홈 페이지는 이렇게 되면 좋겠다.</p>\n<p><img src=\"/static/new-home-layout-e5ed565a.png\" alt=\"home-layout\"></p>\n<p>그리고 글을 보는 영역은 다음과 같아졌으면 한다.</p>\n<p><img src=\"/static/new-article-layout-bde5393a.png\" alt=\"article-layout\"></p>\n<p>물론 이는 해보면서 조금씩 바뀔 가능성이 높다.</p>\n<h1>3. 시작</h1>\n<p>Node는 깔려 있다고 가정하고, 먼저 NextJS 앱을 생성하자.</p>\n<pre><code>npx create-next-app@latest\n</code></pre>\n<p>이렇게 하면 몇 가지 질문이 나오는데 난 Typescript를 사용할 것이다. 그리고 Tailwind는 사용하지 않을 것이다. 소마에서 프로젝트 하면서 너무 데여서...일단은 그냥 제공하는 CSS Modules를 사용할 것 같다.</p>\n<p>또한 App router가 새로 나왔다고 하는데 아직은 버그가 많다고 해서 App router를 사용할 거냐는 질문에는 No를 택했다. 기존의 Page router를 사용하도록 하겠다.</p>\n<p>이렇게 앱을 만든 후 해당 폴더로 이동하여 <code>npm run dev</code>를 실행하면 앱이 실행된다.</p>\n<h1>4. eslint, prettier</h1>\n<p>eslint는 아까 앱을 세팅할 때 깔리도록 설정했으므로, prettier와 eslint 연동 플러그인을 깐다. prettier와 충돌이 생기는 규칙을 끄고, eslint에 prettier 포매터 규칙을 추가해 주는 플러그인이다.</p>\n<pre><code>npm i -D prettier\nnpm i -D eslint-config-prettier eslint-plugin-prettier\n</code></pre>\n<p>그다음 eslint를 vscode의 기본 포매터로 설정한 후 저장할 때마다 포맷팅이 되도록 설정한다. setting의 format on save를 true로 설정하고 default formatter를 eslint로 설정하면 된다.</p>\n<p><code>.prettierrc</code>는 간단한 정보만 설정하자. 어차피 eslint에서 같은 내용을 설정할 것이기 때문이다.</p>\n<pre><code>{\n  \"trailingComma\": \"all\",\n  \"tabWidth\": 2,\n  \"semi\": true,\n  \"singleQuote\": true,\n  \"jsxSingleQuote\": true\n}\n</code></pre>\n<p>나는 TS를 쓸 거니까 해당 eslint 플러그인 설치</p>\n<pre><code>npm i -D @typescript-eslint/parser @typescript-eslint/eslint-plugin\n</code></pre>\n<p>그리고 쓰이지 않는 import를 지우는 eslint 플러그인도 설치</p>\n<pre><code>npm i -D eslint-plugin-unused-imports\n</code></pre>\n<p>이제 eslintrc 설정을 해보자. 기본으로 되어있는 <code>.eslintrc.json</code>은 다음과 같이 되어있다.</p>\n<pre><code class=\"language-js\">{\n  \"extends\": [\"next/core-web-vitals\"]\n}\n</code></pre>\n<p>먼저 여기 우리가 설치한 플러그인과 추천 설정을 좀 추가해 주자.</p>\n<pre><code class=\"language-json\">{\n  \"plugins\": [\"@typescript-eslint\", \"unused-imports\"],\n  \"extends\": [\"next\", \"next/core-web-vitals\", \"prettier\"],\n}\n</code></pre>\n<p>그 다음에는 rules를 설정해서 린터 규칙만 만들면 된다. 여기서 인덴트 규칙 등을 설정해야 자동 수정이 된다. ruls를 다음과 같이 추가하자.</p>\n<p>줄의 최대 길이 제한은 끄고, 들여쓰기는 2칸으로, import는 적절히 정렬되도록 한다. 또한 예약 키워드들 간에는 띄어쓰기를 넣게 하고 따옴표는 작은따옴표를 쓴다. 파일 이름은 <code>.tsx</code>만 허용한다. 또한 콘솔 출력을 사용하지 못하게 하고 쉐도잉 변수를 쓸 수 없게 하며 세미콜론을 강제하는 등 여러 규칙들을 지정했다. 편해 보이는 걸 끌어왔지만 만약 코드를 짜다 더 필요한 게 생기면 추가 혹은 삭제할 것이다.</p>\n<pre><code class=\"language-json\">\"rules\": {\n  \"no-unused-vars\": \"off\",\n  \"max-len\":\"off\",\n  \"indent\":[\n    \"error\",\n    2\n  ],\n  \"import/order\": [\n    \"error\",\n    {\n      \"alphabetize\": {\n        \"order\": \"asc\",\n        \"caseInsensitive\": true\n      },\n      \"groups\": [\n        \"builtin\",\n        \"external\",\n        [\n          \"parent\",\n          \"internal\"\n        ],\n        \"sibling\",\n        [\n          \"unknown\",\n          \"index\",\n          \"object\"\n        ]\n      ],\n      \"pathGroups\": [\n        {\n          \"pattern\": \"~/**\",\n          \"group\": \"internal\"\n        }\n      ],\n      \"newlines-between\": \"always\"\n    }\n  ],\n  \"jsx-quotes\": [\n    \"error\",\n    \"prefer-single\"\n  ],\n  \"keyword-spacing\": \"error\",\n  \"quotes\": [\n    \"error\",\n    \"single\",\n    {\n      \"avoidEscape\": true\n    }\n  ],\n  \"react/jsx-filename-extension\": [\n    \"warn\",\n    {\n      \"extensions\": [\n        \".tsx\"\n      ]\n    }\n  ],\n  \"no-console\": [\n    \"error\",\n    {\n      \"allow\": [\n        \"warn\",\n        \"error\"\n      ]\n    }\n  ],\n  \"react/no-unescaped-entities\": \"warn\",\n  \"react/jsx-props-no-spreading\": \"off\",\n  \"react/require-default-props\": \"off\",\n  \"semi\": \"off\",\n  \"space-before-blocks\": \"error\",\n  \"no-shadow\": \"off\",\n  \"@typescript-eslint/no-shadow\": [\n    \"error\"\n  ],\n  \"@typescript-eslint/explicit-function-return-type\": \"off\",\n  \"@typescript-eslint/no-explicit-any\": \"error\",\n  \"@typescript-eslint/no-unused-vars\": \"error\",\n  \"@typescript-eslint/semi\": [\n    \"error\"\n  ],\n  \"@typescript-eslint/type-annotation-spacing\": [\n    \"error\",\n    {\n      \"before\": false,\n      \"after\": true,\n      \"overrides\": {\n        \"colon\": {\n          \"before\": false,\n          \"after\": true\n        },\n        \"arrow\": {\n          \"before\": true,\n          \"after\": true\n        }\n      }\n    }\n  ]\n}\n</code></pre>\n<p>코드 짜는 데 핵심적인 내용은 아니니 이정도만 하고 넘어가자.</p>\n<h1>5. 페이지 라우터 만들기</h1>\n<p>내가 생각하기에 지금 블로그에 필요한 페이지는 다음과 같다.</p>\n<ol>\n<li>메인 페이지</li>\n<li>글 목록 페이지</li>\n<li>내 소개 페이지</li>\n<li>글 페이지</li>\n</ol>\n<p>여기서 글 페이지는 개별 글마다 동적 라우터를 생성해 줘야 하기 때문에 일단 넘어가자. 나머지 페이지의 라우터를 만들어 주자.</p>\n<p>NextJS는 pages 폴더 내에서 export된 컴포넌트들이다. 예를 들어서 <code>pages/posts/index.tsx</code>에서 export된 컴포넌트는 <code>/posts</code> 경로로 접근할 수 있다.</p>\n<p>따라서 pages 폴더 내에 <code>posts</code>, <code>about</code> 폴더를 만들고 각각 <code>index.tsx</code>를 만들어 주자. 그리고 각각의 컴포넌트에는 간단한 내용을 넣어주자.</p>\n<p>예를 들어 이런 것이다.</p>\n<pre><code class=\"language-tsx\">// src/pages/about/index.tsx\nfunction AboutPage() {\n  return &#x3C;h1>내 소개 페이지&#x3C;/h1>;\n}\n\nexport default AboutPage;\n</code></pre>\n<p>이제 대강 기초 세팅이 끝난 것 같다. 다음 글에서 HTML로 기본적인 사이트 구조를 잡도록 하자.</p>\n<h1>참고</h1>\n<p><a href=\"https://velog.io/@rmaomina/prettier-eslint-settings\">https://velog.io/@rmaomina/prettier-eslint-settings</a></p>\n<p><a href=\"https://www.daleseo.com/eslint-config/\">https://www.daleseo.com/eslint-config/</a></p>",
    "excerpt": "블로그 만들기 시리즈\n|제목|링크|\n|---|---|\n|1. 기본 세팅|https://witch.work/posts/blog-remake-1|\n|2. 메인 페이지의 HTML 설계|https://witch.work/posts/blog-remake-2|\n|3. 글 상세 페이지의 구조 설계|https://witch.work/posts/blog-remake-3|\n|4. 이미지를 상대 경로로 쓸 수 있도록 하기|https://witch.work/posts/blog-rem",
    "headingTree": [
      {
        "title": "블로그 만들기 시리즈",
        "url": "#블로그-만들기-시리즈",
        "items": []
      },
      {
        "title": "1. 시작",
        "url": "#1-시작",
        "items": []
      },
      {
        "title": "2. 레이아웃",
        "url": "#2-레이아웃",
        "items": []
      },
      {
        "title": "3. 시작",
        "url": "#3-시작",
        "items": []
      },
      {
        "title": "4. eslint, prettier",
        "url": "#4-eslint-prettier",
        "items": []
      },
      {
        "title": "5. 페이지 라우터 만들기",
        "url": "#5-페이지-라우터-만들기",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 2,
      "wordCount": 404
    },
    "url": "/posts/blog-remake-1",
    "thumbnail": {
      "local": "/static/self-made-d7bf3411.jpeg",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-self-made-d7bf3411-jpeg",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAADCAIAAAAhqtkfAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAVklEQVR4nAFLALT/ALy0rsG4tMe9traspJ+Wi6idkr6zqriwpwD/+fS1qKC0ppmuoJO9saDXyruuoJPKwrcAu62nlod4HQAAIRkINi4gdWlceW1fkIV8/CsqL6d9DWAAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "blog-remake-10",
    "title": "블로그 만들기 - 10. 폰트, 프로젝트 소개, 태그",
    "date": "2023-06-01T00:00:00Z",
    "description": "폰트 변경과 프로젝트 소개 카드 세부디자인",
    "tags": [
      "blog",
      "web"
    ],
    "html": "<h1>블로그 만들기 시리즈</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>제목</th><th>링크</th></tr></thead><tbody><tr><td>1. 기본 세팅</td><td><a href=\"https://witch.work/posts/blog-remake-1\">https://witch.work/posts/blog-remake-1</a></td></tr><tr><td>2. 메인 페이지의 HTML 설계</td><td><a href=\"https://witch.work/posts/blog-remake-2\">https://witch.work/posts/blog-remake-2</a></td></tr><tr><td>3. 글 상세 페이지의 구조 설계</td><td><a href=\"https://witch.work/posts/blog-remake-3\">https://witch.work/posts/blog-remake-3</a></td></tr><tr><td>4. 이미지를 상대 경로로 쓸 수 있도록 하기</td><td><a href=\"https://witch.work/posts/blog-remake-4\">https://witch.work/posts/blog-remake-4</a></td></tr><tr><td>5. 자잘한 페이지 구성 개선과 배포</td><td><a href=\"https://witch.work/posts/blog-remake-5\">https://witch.work/posts/blog-remake-5</a></td></tr><tr><td>6. 페이지 요소의 배치 설계</td><td><a href=\"https://witch.work/posts/blog-remake-6\">https://witch.work/posts/blog-remake-6</a></td></tr><tr><td>7. 메인 페이지 컴포넌트 디자인</td><td><a href=\"https://witch.work/posts/blog-remake-7\">https://witch.work/posts/blog-remake-7</a></td></tr><tr><td>8. 글 목록/내용 페이지 컴포넌트 디자인</td><td><a href=\"https://witch.work/posts/blog-remake-8\">https://witch.work/posts/blog-remake-8</a></td></tr><tr><td>9. 글 썸네일 자동 생성하기</td><td><a href=\"https://witch.work/posts/blog-remake-9\">https://witch.work/posts/blog-remake-9</a></td></tr><tr><td>10. 폰트, 카드 디자인 등의 디자인 개선</td><td><a href=\"https://witch.work/posts/blog-remake-10\">https://witch.work/posts/blog-remake-10</a></td></tr><tr><td>11. 글에 조회수 달기</td><td><a href=\"https://witch.work/posts/blog-remake-11\">https://witch.work/posts/blog-remake-11</a></td></tr><tr><td>12. 페이지 테마와 글 검색 기능</td><td><a href=\"https://witch.work/posts/blog-remake-12\">https://witch.work/posts/blog-remake-12</a></td></tr><tr><td>13. 테마 아이콘과 썸네일 레이아웃 개선 등</td><td><a href=\"https://witch.work/posts/blog-remake-13\">https://witch.work/posts/blog-remake-13</a></td></tr><tr><td>14. 글 분류를 태그 기반으로 변경</td><td><a href=\"https://witch.work/posts/blog-remake-14\">https://witch.work/posts/blog-remake-14</a></td></tr><tr><td>메인 페이지의 연산 최적화</td><td><a href=\"https://witch.work/posts/blog-opt-1\">https://witch.work/posts/blog-opt-1</a></td></tr><tr><td>글 목록 페이지네이션 만들기</td><td><a href=\"https://witch.work/posts/blog-opt-2\">https://witch.work/posts/blog-opt-2</a></td></tr><tr><td>이미지를 CDN에 올리고 placeholder 만들기</td><td><a href=\"https://witch.work/posts/blog-opt-3\">https://witch.work/posts/blog-opt-3</a></td></tr><tr><td>검색 페이지에 무한 스크롤 구현하기</td><td><a href=\"https://witch.work/posts/blog-opt-4\">https://witch.work/posts/blog-opt-4</a></td></tr></tbody></table>\n<h1>1. 글 내용 중 코드의 폰트 변경</h1>\n<p>prism에서 쓰는 세팅 일부를 가져왔다. <code>/src/pages/[category]/[slug]/content.module.css</code>를 편집.</p>\n<pre><code class=\"language-css\">.content :is(pre,code){\n  //font-family:monospace, Pretendard, apple-system, system-ui, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif;\n  font-family: 'Fira Code', Menlo, Monaco, Consolas, \"Andale Mono\", \"Ubuntu Mono\", \"Courier New\", monospace;\n  direction: ltr;\n  text-align: left;\n  white-space: pre;\n  word-spacing: normal;\n  word-break: normal;\n  line-height: 1.5;\n  -moz-tab-size: 4;\n  -o-tab-size: 4;\n  tab-size: 4;\n  -webkit-hyphens: none;\n  -moz-hyphens: none;\n  -ms-hyphens: none;\n  hyphens: none;\n  /* 점 병합에 관한 옵션 */\n  font-variant-ligatures: none;\n  font-size:1rem;\n  overflow:auto;\n}\n</code></pre>\n<h1>2. 프로젝트 카드 디자인</h1>\n<p>현재 프로젝트 카드 디자인과 배열은 다음과 같다. 화면이 넓을 땐 2열로 그리고 좁을 땐 1열로 배열된다.</p>\n<p><img src=\"/static/project-old-layout-57b9330d.png\" alt=\"project-old-layout\"></p>\n<p>모바일에서는 다음과 같이 보인다.</p>\n<p><img src=\"/static/project-old-layout-mobile-5837ea92.png\" alt=\"project-old-layout-mobile\"></p>\n<p>여기에는 몇 가지 문제가 있다.</p>\n<ol>\n<li>프로젝트 이미지 크기와 텍스트박스의 크기가 맞지 않다.</li>\n<li>카드를 누르면 직관적으로 프로젝트 페이지로 넘어가는 게 아니라 링크 버튼이 따로 있다.</li>\n<li>단순한 격자로 배열되어 별로 재미가 없다.(물론 모바일에서는 상관없다)</li>\n</ol>\n<p>레퍼런스로 쓸 만한 페이지를 여럿 찾아보았다. 그러다가 러쉬의 메인 페이지에서 괜찮아 보이는 배치를 발견했다.</p>\n<p><img src=\"/static/lush-card-layout-84c57b32.png\" alt=\"lush-card-layout\">\n출처 : <a href=\"https://www.lush.co.kr/\">러쉬 공식 사이트</a></p>\n<p>카드 자체를 링크로 만들었고(뜯어보면 카드 전체가 링크인 건 아니지만 크게 상관은 없다), 적당히 서로 다른 높이의 이미지를 사용하여 시각적인 변형을 주었다. 또한 한 줄로 배치되었다.</p>\n<p>이를 한번 따라해보자. 단 화면이 넓을 때만. 화면이 좁을 경우 저런 식으로 가로 한 줄 배치가 가시성을 떨어뜨리는 것 같았다.</p>\n<h2>2.1. 카드를 링크로 만들기</h2>\n<p>배치 같은 경우 모바일과 PC가 다르게 이루어질 것이므로 두 부분에 공통되는 특성부터 변경하자. 먼저 카드 자체를 링크로 만드는 작업을 하자.</p>\n<p>먼저 기존 링크를 없앤다. 그냥 링크 리스트 부분을 없애고 링크블럭+기술스택블럭을 묶은 div를 없애준다.</p>\n<pre><code class=\"language-tsx\">// src/components/projectList/project/intro/index.tsx\nfunction ProjectIntro({project}: {project: projectType}) {\n  return (\n    &#x3C;div className={styles.intro}>\n      &#x3C;div>\n        &#x3C;h3 className={styles.title}>{project.title}&#x3C;/h3>\n        &#x3C;p className={styles.description}>{project.description}&#x3C;/p>\n      &#x3C;/div>\n      &#x3C;ul className={styles.list}>\n        {project.techStack.map((tech) =>\n          &#x3C;li key={tech} className={styles.tech}>{tech}&#x3C;/li>\n        )}\n      &#x3C;/ul>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<p>그리고 <code>Project</code>컴포넌트를 링크로 만들어서 카드 전체를 링크화하자. <code>project.url</code>에 들어 있는 첫번째 링크를 쓴다.</p>\n<pre><code class=\"language-tsx\">function Project({project}: {project: projectType}) {\n  return (\n    &#x3C;Link className={styles.wrapper} href={project.url[0].link} target='_blank'>\n      &#x3C;article className={styles.container} > \n        &#x3C;div className={styles.imagebox}>\n          &#x3C;Image\n            className={styles.image}\n            src={project.image} \n            alt={project.title}\n            width={200}\n            height={200}\n          />\n        &#x3C;/div>\n        &#x3C;ProjectIntro project={project} />\n      &#x3C;/article>\n    &#x3C;/Link>\n  );\n}\n</code></pre>\n<h2>2.2. 프로젝트 배치 변경</h2>\n<p>projectList의 배치는 기존에 화면이 넓을 땐 2열로 배치되었다. 이를 그냥 가로 한 줄로 배치되도록 하자. <code>/src/components/projectList/styles.module.css</code>에서 미디어 쿼리, 그중에서도 열 수를 지정하는 부분만 편집하면 된다.</p>\n<pre><code class=\"language-css\">// /src/components/projectList/styles.module.css\n@media (min-width: 768px) {\n  .list{\n    display:grid;\n    /* 이 부분의 열 수를 2에서 4로 변경 */\n    grid-template-columns:repeat(4,1fr);\n    grid-auto-rows:1fr;\n    row-gap:1rem;\n    column-gap:1rem;\n  }\n\n  .toggle{\n    display:none;\n  }\n}\n</code></pre>\n<h2>2.3. 프로젝트 소개 레이아웃 변경</h2>\n<p>그리고 러쉬 공식 페이지를 참고하여 다음과 같은 개별 프로젝트 카드 레이아웃을 생각했다. <code>project</code> 컴포넌트 설계도 변경하였다.</p>\n<p><img src=\"/static/project-card-layout-36ebb8b2.png\" alt=\"project card layout\"></p>\n<p>일단 project 컴포넌트를 폴더로 분리하자. <code>src/components/projectList/project</code> 폴더를 <code>src/components/</code>로 이동한다. 그리고 폴더명을 <code>projectCard</code>로 변경한 후 내부에 <code>intro</code> 폴더 외에 <code>image</code>, <code>title</code> 폴더를 새로 생성한다. 각각의 내부에도 index.tsx와 styles.module.css를 만드는 것도 하자.</p>\n<p>일단 서로 분리된 각 요소들부터 만들고 나서 전체 <code>projectCard</code> 레이아웃을 만들자. 가장 쉬운 <code>title</code>부터. 그냥 h3 태그 하나만 쓰면 된다.</p>\n<pre><code class=\"language-tsx\">// src/components/projectCard/title/index.tsx\nimport styles from './styles.module.css';\n\nfunction Title({title}: {title: string}) {\n  return (\n    &#x3C;h3 className={styles.title}>{title}&#x3C;/h3>\n  );\n}\n\nexport default Title;\n</code></pre>\n<p>스타일도 그냥 margin만 없애주면 된다.</p>\n<pre><code class=\"language-css\">// src/components/projectCard/title/styles.module.css\n.title{\n  margin: 0;\n}\n</code></pre>\n<p>이제는 intro를 편집하자. 기술 스택 블록 디자인 같은 건 딱히 바꿀 것 없다. 구조도 똑같다.</p>\n<pre><code class=\"language-tsx\">function ProjectIntro({project}: {project: projectType}) {\n  return (\n    &#x3C;div className={styles.intro}>\n      &#x3C;p className={styles.description}>{project.description}&#x3C;/p>\n      &#x3C;ul className={styles.list}>\n        {project.techStack.map((tech) =>\n          &#x3C;li key={tech} className={styles.tech}>{tech}&#x3C;/li>\n        )}\n      &#x3C;/ul>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<p>그냥 카드 자체가 링크가 되면서 쓰이지 않게 된 <code>link</code> 클래스를 삭제해 주고, 화면너비가 좁을 땐 설명 영역과 기술스택 영역이 <code>space-between</code>으로 배치되게 하고 넓을 땐 붙어서 배치되도록 한다. 기술 스택 블록 디자인은 눈길을 좀 덜 끌도록 연한 색으로 바꿔주었다.</p>\n<pre><code class=\"language-css\">// src/components/projectCard/intro/styles.module.css\n.intro{\n  display:flex;\n  flex-direction: column;\n  justify-content: space-between;\n  height:100%;\n}\n\n.description{\n  margin: 0;\n  margin-top:5px;\n  width:100%;\n}\n\n.list{\n  display: flex;\n  flex-direction: row;\n  flex-wrap: wrap;\n  gap: 6px;\n  list-style: none;\n  padding: 0;\n  margin-top:5px;\n}\n\n.tech{\n  padding: 1.5px 3px;\n  border-radius: 5px;\n  background-color: var(--indigo0);\n  color:var(--indigo6);\n  font-size: 0.8rem;\n}\n\n@media (min-width:768px){\n  .intro{\n    justify-content: flex-start;\n    height:100%;\n  }\n}\n</code></pre>\n<p>이미지 컴포넌트도 분리하자. 이때 <code>next/Image</code>를 사용할 텐데, next에서 제공하는 <code>Image</code>태그는 일단 width, height를 지정한 후 다시 CSS 스타일링으로 크기를 바꾸는 것도 지원한다. 이를 이용하자.</p>\n<p>컴포넌트 구조는 다음과 같이. 이미지 소스와 alt 텍스트에 쓰일 프로젝트 제목을 받아서 컨테이너에 넣은 단순한 구조다. 그리고 width, height는 어차피 CSS로 지정할 것이므로 <code>Image</code>태그에는 300x300으로 고정한다.</p>\n<pre><code class=\"language-tsx\">import Image from 'next/image';\n\nimport styles from './styles.module.css';\n\nfunction ProjectImage({title, image}: {title: string, image: string}) {\n  return (\n    &#x3C;div className={styles.container}>\n      &#x3C;Image\n        className={styles.image}\n        src={image} \n        alt={`${title} 프로젝트 사진`}\n        width={300}\n        height={300}\n      />\n    &#x3C;/div>\n  );\n}\n\nexport default ProjectImage;\n</code></pre>\n<p>그리고 화면 너비가 작을 땐 이미지를 정사각형으로 보이게 하고 화면 너비가 커지면 <code>aspect-ratio:auto</code>를 통해서 이미지의 원래 비율로 보이도록 한다.</p>\n<pre><code class=\"language-css\">// src/components/projectCard/image/styles.module.css\n.image{\n  margin:0;\n  object-fit: fill;\n  width:120px;\n  height:100%;\n  aspect-ratio: 1/1;\n}\n\n.container{\n  display: block;\n  position: relative;\n}\n\n@media (min-width: 768px) {\n  .container{\n    display: block;\n    position: relative;\n    width:100%;\n  }\n\n  .image{\n    display: block;\n    margin:0;\n    object-fit: contain;\n    width:100%;\n    height:auto;\n    aspect-ratio: auto;\n  }\n}\n</code></pre>\n<p>그리고 <code>projectCard</code>를 작성하자. 아까 계획했던 레이아웃을 그대로 따라서 작성하면 된다.</p>\n<pre><code class=\"language-tsx\">// src/components/projectCard/index.tsx\nfunction Project({project}: {project: projectType}) {\n  return (\n    &#x3C;Link className={styles.wrapper} href={project.url[0].link} target='_blank'>\n      &#x3C;article className={styles.container} >\n        &#x3C;div className={styles.titlebox}>\n          &#x3C;ProjectTitle title={project.title} />\n        &#x3C;/div>\n        &#x3C;div className={styles.imagebox}>\n          &#x3C;ProjectImage title={project.title} image={project.image} />\n        &#x3C;/div>\n        &#x3C;div className={styles.introbox}>\n          &#x3C;ProjectIntro project={project} />\n        &#x3C;/div>\n      &#x3C;/article>\n    &#x3C;/Link>\n  );\n}\n</code></pre>\n<p>grid display를 이용해서 딱딱 행, 열을 정해주면 된다.</p>\n<pre><code class=\"language-css\">// src/components/projectCard/styles.module.css\n.wrapper{\n  display:block;\n}\n\n.container{\n  display: grid;\n  grid-template-columns: min-content max-content;\n  grid-template-rows: 25px;\n  column-gap:1rem;\n  box-sizing: border-box;\n  /*padding:15px 15px 15px 0;  */\n  height:120px;\n  max-height:150px;\n}\n\n.container:hover{\n  background-color: var(--gray1);\n  border-radius: 1rem;\n  /*padding:10px;*/\n  color:var(--indigo6);\n}\n\n.titlebox{\n  grid-column: 2 / 3;\n  grid-row: 1 / 2;\n  height:100%;\n}\n\n.imagebox{\n  grid-column: 1 / 2;\n  grid-row: 1 / 3;\n}\n\n.introbox{\n  grid-column: 2 / 3;\n  grid-row: 2 / 3;\n}\n\n@media (min-width: 768px) {\n  .container{\n    flex-direction: column;\n    grid-template-columns: 1fr;\n    grid-template-rows: 35px min-content;\n    min-height:18rem;\n  }\n\n  .titlebox{\n    grid-column: 1 / 2;\n    grid-row: 1 / 2;\n    height:100%;\n  }\n\n  .imagebox{\n    grid-column: 1 / 2;\n    grid-row: 2 / 3;\n  }\n\n  .introbox{\n    grid-column: 1 / 2;\n    grid-row: 3 / 4;\n  }\n}\n</code></pre>\n<p>그리고 hover시에 회색 배경이 되는 걸 없애주고, 그림자가 생기면서 이미지가 약간 떠오르는 듯한 효과를 주자. <code>box-shadow</code>속성과 margin, padding, transition을 적절히 이용하면 된다.</p>\n<pre><code class=\"language-css\">// src/components/projectCard/styles.module.css\n.wrapper{\n  display:block;\n  width:100%;\n  height:100%;\n}\n\n.container{\n  display: grid;\n  grid-template-columns: min-content;\n  grid-template-rows: 25px;\n  column-gap:1rem;\n  /*padding:15px 15px 15px 0;  */\n  height:100%;\n}\n\n.container:hover{\n  color:var(--indigo6);\n}\n\n/* 컨테이너 호버 시 이미지 박스 그림자 표현 */\n.container:hover .imagebox{\n  margin-top: -3px;\n  padding-bottom:3px;\n  box-shadow: 3px 3px 5px var(--gray6);\n  transition: all 0.3s ease-out\n}\n\n.titlebox{\n  grid-column: 2 / 3;\n  grid-row: 1 / 2;\n  height:100%;\n}\n\n.imagebox{\n  grid-column: 1 / 2;\n  grid-row: 1 / 3;\n  border-radius: 0.5rem;\n  height:100%;\n}\n\n.introbox{\n  grid-column: 2 / 3;\n  grid-row: 2 / 3;\n}\n\n@media (min-width: 768px) {\n  .container{\n    flex-direction: column;\n    grid-template-columns: 1fr;\n    grid-template-rows: min-content min-content;\n  }\n\n  .titlebox{\n    grid-column: 1 / 2;\n    grid-row: 1 / 2;\n    height:100%;\n  }\n\n  .imagebox{\n    grid-column: 1 / 2;\n    grid-row: 2 / 3;\n  }\n\n  .introbox{\n    grid-column: 1 / 2;\n    grid-row: 3 / 4;\n  }\n}\n</code></pre>\n<p>그리고 모바일 환경에서 맨 위에 위치한 프로젝트 소개의 사진이 <code>margin-top:-3px</code>로 떠오를 때 프로젝트 소개가 접힌 상태에서는 <code>overflow:hidden</code> 옵션이 적용되어 사진이 잘리는 문제가 있었다.</p>\n<p>이는 container 호버 시 imagebox에 padding도 추가해 주는 것으로 해결.</p>\n<h1>3. 태그 색상</h1>\n<p>현재 메인페이지에서 글을 약간씩 보여줄 때 태그를 보여주고 있는데 이 태그 블럭의 개별 색상이 너무 진하다 보니 눈을 지나치게 끈다. 이 배경을 좀더 연한 색으로 바꾸고 글자도 어울리는 진한 남색으로 변경.</p>\n<pre><code class=\"language-css\">// src/components/card/intro/styles.module.css\n.tag{\n  background-color:var(--indigo1);\n  color:var(--indigo7);\n  border-radius:5px;\n  font-size:0.8rem;\n  margin:0;\n  margin-bottom:5px;\n  padding:3px 8px;\n}\n</code></pre>\n<h1>4. h3 태그 높이 문제</h1>\n<p>프로젝트 제목에 h3 태그를 사용하고 있었는데, 한글을 썼을 때와 영어를 썼을 때 h3 태그의 높이가 달라졌다. 1.25rem으로 h3 태그를 썼을 때 한글의 경우 높이가 25.5px였으나 영어로만 썼을 경우 23.5px가 되었다.</p>\n<p>따라서 projectCard/title에 쓰이는 h3 태그의 폰트를 Pretendard대신 Roboto를 쓰도록 바꿨다. 이렇게 하니 높이가 24px로 고정되었다.</p>\n<pre><code class=\"language-css\">// src/components/projectCard/title/styles.module.css\n.title{\n  margin: 0;\n  font-family: 'Roboto', sans-serif;\n}\n\n@media (min-width: 768px) {\n  .title {\n    margin-bottom:10px;\n  }\n}\n</code></pre>\n<h1>참고</h1>\n<p>러쉬 공식 홈페이지 <a href=\"https://www.lush.co.kr/\">https://www.lush.co.kr/</a></p>\n<p>이제 <code>&#x3C;a></code> 태그로 블록 요소를 감쌀 수 있다. 단 내부에 버튼이나 다른 링크 등 상호작용 태그가 없어야 한다. <a href=\"https://stackoverflow.com/questions/1827965/is-putting-a-div-inside-an-anchor-ever-correct/1828032#1828032\">https://stackoverflow.com/questions/1827965/is-putting-a-div-inside-an-anchor-ever-correct/1828032#1828032</a></p>\n<p><a href=\"https://stackoverflow.com/questions/38367002/make-entire-article-tag-a-link\">https://stackoverflow.com/questions/38367002/make-entire-article-tag-a-link</a></p>\n<p>nextJS Image 태그 <a href=\"https://nextjs.org/docs/app/api-reference/components/image#fill\">https://nextjs.org/docs/app/api-reference/components/image#fill</a></p>\n<p><a href=\"https://stackoverflow.com/questions/20959600/height-100-on-flexbox-column-child\">https://stackoverflow.com/questions/20959600/height-100-on-flexbox-column-child</a></p>\n<p><a href=\"https://stackoverflow.com/questions/65169431/how-to-set-the-next-image-component-to-100-height\">https://stackoverflow.com/questions/65169431/how-to-set-the-next-image-component-to-100-height</a></p>",
    "excerpt": "블로그 만들기 시리즈\n|제목|링크|\n|---|---|\n|1. 기본 세팅|https://witch.work/posts/blog-remake-1|\n|2. 메인 페이지의 HTML 설계|https://witch.work/posts/blog-remake-2|\n|3. 글 상세 페이지의 구조 설계|https://witch.work/posts/blog-remake-3|\n|4. 이미지를 상대 경로로 쓸 수 있도록 하기|https://witch.work/posts/blog-rem",
    "headingTree": [
      {
        "title": "블로그 만들기 시리즈",
        "url": "#블로그-만들기-시리즈",
        "items": []
      },
      {
        "title": "1. 글 내용 중 코드의 폰트 변경",
        "url": "#1-글-내용-중-코드의-폰트-변경",
        "items": []
      },
      {
        "title": "2. 프로젝트 카드 디자인",
        "url": "#2-프로젝트-카드-디자인",
        "items": [
          {
            "title": "2.1. 카드를 링크로 만들기",
            "url": "#21-카드를-링크로-만들기",
            "items": []
          },
          {
            "title": "2.2. 프로젝트 배치 변경",
            "url": "#22-프로젝트-배치-변경",
            "items": []
          },
          {
            "title": "2.3. 프로젝트 소개 레이아웃 변경",
            "url": "#23-프로젝트-소개-레이아웃-변경",
            "items": []
          }
        ]
      },
      {
        "title": "3. 태그 색상",
        "url": "#3-태그-색상",
        "items": []
      },
      {
        "title": "4. h3 태그 높이 문제",
        "url": "#4-h3-태그-높이-문제",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 4,
      "wordCount": 1015
    },
    "url": "/posts/blog-remake-10",
    "thumbnail": {
      "local": "/static/project-old-layout-57b9330d.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-project-old-layout-57b9330d-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAADCAIAAAAhqtkfAAAACXBIWXMAAAsTAAALEwEAmpwYAAAATklEQVR4nGNgYOWds2D5y5dv/v////79h+XL1+7ate////8Mi+fOqG2ceursjf///3/59mPtpiOnz14HSTy6dmrhks2PHj36+fPnfyQAAPlKOvCMdN6DAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "blog-remake-11",
    "title": "블로그 만들기 - 11. 글 조회수 달기",
    "date": "2023-06-04T00:00:00Z",
    "description": "글의 조회수를 카운팅하기 위한 장렬한 전투 기록",
    "tags": [
      "blog",
      "web"
    ],
    "html": "<h1>블로그 만들기 시리즈</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>제목</th><th>링크</th></tr></thead><tbody><tr><td>1. 기본 세팅</td><td><a href=\"https://witch.work/posts/blog-remake-1\">https://witch.work/posts/blog-remake-1</a></td></tr><tr><td>2. 메인 페이지의 HTML 설계</td><td><a href=\"https://witch.work/posts/blog-remake-2\">https://witch.work/posts/blog-remake-2</a></td></tr><tr><td>3. 글 상세 페이지의 구조 설계</td><td><a href=\"https://witch.work/posts/blog-remake-3\">https://witch.work/posts/blog-remake-3</a></td></tr><tr><td>4. 이미지를 상대 경로로 쓸 수 있도록 하기</td><td><a href=\"https://witch.work/posts/blog-remake-4\">https://witch.work/posts/blog-remake-4</a></td></tr><tr><td>5. 자잘한 페이지 구성 개선과 배포</td><td><a href=\"https://witch.work/posts/blog-remake-5\">https://witch.work/posts/blog-remake-5</a></td></tr><tr><td>6. 페이지 요소의 배치 설계</td><td><a href=\"https://witch.work/posts/blog-remake-6\">https://witch.work/posts/blog-remake-6</a></td></tr><tr><td>7. 메인 페이지 컴포넌트 디자인</td><td><a href=\"https://witch.work/posts/blog-remake-7\">https://witch.work/posts/blog-remake-7</a></td></tr><tr><td>8. 글 목록/내용 페이지 컴포넌트 디자인</td><td><a href=\"https://witch.work/posts/blog-remake-8\">https://witch.work/posts/blog-remake-8</a></td></tr><tr><td>9. 글 썸네일 자동 생성하기</td><td><a href=\"https://witch.work/posts/blog-remake-9\">https://witch.work/posts/blog-remake-9</a></td></tr><tr><td>10. 폰트, 카드 디자인 등의 디자인 개선</td><td><a href=\"https://witch.work/posts/blog-remake-10\">https://witch.work/posts/blog-remake-10</a></td></tr><tr><td>11. 글에 조회수 달기</td><td><a href=\"https://witch.work/posts/blog-remake-11\">https://witch.work/posts/blog-remake-11</a></td></tr><tr><td>12. 페이지 테마와 글 검색 기능</td><td><a href=\"https://witch.work/posts/blog-remake-12\">https://witch.work/posts/blog-remake-12</a></td></tr><tr><td>13. 테마 아이콘과 썸네일 레이아웃 개선 등</td><td><a href=\"https://witch.work/posts/blog-remake-13\">https://witch.work/posts/blog-remake-13</a></td></tr><tr><td>14. 글 분류를 태그 기반으로 변경</td><td><a href=\"https://witch.work/posts/blog-remake-14\">https://witch.work/posts/blog-remake-14</a></td></tr><tr><td>메인 페이지의 연산 최적화</td><td><a href=\"https://witch.work/posts/blog-opt-1\">https://witch.work/posts/blog-opt-1</a></td></tr><tr><td>글 목록 페이지네이션 만들기</td><td><a href=\"https://witch.work/posts/blog-opt-2\">https://witch.work/posts/blog-opt-2</a></td></tr><tr><td>이미지를 CDN에 올리고 placeholder 만들기</td><td><a href=\"https://witch.work/posts/blog-opt-3\">https://witch.work/posts/blog-opt-3</a></td></tr><tr><td>검색 페이지에 무한 스크롤 구현하기</td><td><a href=\"https://witch.work/posts/blog-opt-4\">https://witch.work/posts/blog-opt-4</a></td></tr></tbody></table>\n<p>이 글은 내 새로운 블로그에 조회수를 다는 과정이다. 정보 전달을 위해 <a href=\"https://witch.work/blog-adding-view-count/\">이전 블로그에 조회수를 달다가 만 과정</a>에서 몇 가지를 복붙했다.</p>\n<p>사실 vercel에서 했더라면 훨씬 더 편하게 모든 걸 했을 텐데, cloudflare에서 하려다 보니 너무나 힘들게 돌아왔다. 결국은 다시 Vercel로 배포하게 되었다.</p>\n<p>수많은 삽질과 실패가 있었는데, 만약 NextJS앱을 Cloudflare Pages로 배포하면서 조회수를 달고자 하는 사람이 있다면...Cloudflare Pages에서 NodeJS 런타임을 지원하거나 edge runtime에서 swr을 제대로 지원하길 바라자.</p>\n<p>하지만 이슈들을 살펴보면 전자는 아예 가망이 없어 보이고(Vercel에서 빌드한 결과를 가져와서 cloudflare에서 자체적으로 돌리는 것 같은데 기반하는 기술이 다르다고 하더라) 후자도 특별히 계획에 있는 것 같지 않다. 혹시 성공한 사람이 있다면 제발 알려주면 좋겠다.</p>\n<h1>1. 글 옮기기</h1>\n<p>일단 글들을 전부 새 블로그로도 옮겼다. 옮기고 나니 빌드에 더 오랜 시간이 걸렸다.</p>\n<h1>2. busuanzi</h1>\n<p>busuanzi라는 중국 서비스가 있는데 이를 이용하면 페이지와 블로그 조회수를 제일 쉽게 추가할 수 있다. 이 부분은 <a href=\"https://witch.work/blog-adding-view-count/\">예전에 내가 쓴 글</a>에서 복붙했다.</p>\n<p><a href=\"https://fienestar.github.io/blog/2020/05/24/busuanzi%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EC%A0%95%EC%A0%81%EC%9D%B8-%ED%8E%98%EC%9D%B4%EC%A7%80%EC%97%90-%EC%8A%A4%ED%83%80%EC%9D%BC-%EB%B3%80%EA%B2%BD%EC%9D%B4-%EA%B0%80%EB%8A%A5%ED%95%9C-%EC%A1%B0%ED%9A%8C%EC%88%98-%EC%B6%94%EA%B0%80%ED%95%98%EA%B8%B0/\">fienestar님의 가이드</a>를 따라하면 된다. 단 내 블로그에 맞게 하기 위한 몇 가지 수정이 필요하다.</p>\n<p>먼저 다음 코드를 사이트의 head 혹은 body에 추가해야 한다.</p>\n<pre><code class=\"language-html\">&#x3C;script async src = \"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\">&#x3C;/script>\n</code></pre>\n<p>내 블로그에는 <code>Seo</code>라는 컴포넌트가 있고 이는 블로그의 모든 페이지에 삽입된다. 그리고 이 <code>Seo</code> 컴포넌트는 react-helmet의 Helmet 컴포넌트로 이루어져 있는데 이 Helmet 컴포넌트는 head 태그에 들어가는 내용을 관리한다. (추가 : 아마 nextjs에선 Head 컴포넌트에 <code>Script</code> 태그를 통해 추가해 줘야 할 듯 싶다)</p>\n<p>따라서 Helmet 컴포넌트 사이에 저 코드를 추가해 주면 된다.</p>\n<pre><code class=\"language-tsx\">&#x3C;Helmet\n// SEO를 위한 메타 정보들이 들어가 있다.\n// 여기서는 중요하지 않으므로 생략\n>\n  &#x3C;script async src = '//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js'>&#x3C;/script>\n&#x3C;/Helmet>\n</code></pre>\n<h2>2.1. 사이트 조회수와 방문자 수</h2>\n<p>사이트 조회수와 방문자 수는 다음 코드를 통해 추가할 수 있다. span에 붙은 id가 중요하다.</p>\n<pre><code class=\"language-html\">&#x3C;section style={{height:'20px'}}>\n  조회수 &#x3C;span id = 'busuanzi_value_site_pv' >&#x3C;/span> 회 &#x3C;br />\n  방문자 &#x3C;span id = 'busuanzi_value_site_uv' >&#x3C;/span> 명\n&#x3C;/section>\n</code></pre>\n<p>위 코드를 블로그의 페이지에 추가하면 된다. 내 블로그의 경우 메인 페이지를 나타내는 BlogIndex 컴포넌트에서 내 프로필 바로 아래에 추가했다.</p>\n<p>이 조회수 표시를 위한 삽질을 하면서 블로그를 재구성해야겠다는 생각을 많이 했기 때문에 지금 굳이 스타일링을 하지는 않았다.</p>\n<h2>2.2. 페이지 조회수</h2>\n<p>단일 페이지의 조회수는 다음 코드로 추가한다.</p>\n<pre><code class=\"language-html\">&#x3C;span id=\"busuanzi_value_page_pv\">&#x3C;/span>\n</code></pre>\n<p>이를 글 제목 아래에 적당히 추가하였다.</p>\n<p>다른 삽질의 기록들은 아래에 적어두었다. 후에 블로그를 갈아엎을 때 이 지식을 쓰게 되길 바란다.</p>\n<p>그리고 생각보다 빨리, 2달 만에 이 글을 다시 쓰게 되었다. 이번엔 nextjs이기 때문에 다시 쓴다.</p>\n<h1>3. google analytics - 등록</h1>\n<h2>3.1. 계정 생성</h2>\n<p>구글 애널리틱스 계정을 새로 생성하자.</p>\n<p><img src=\"/static/create-account-de20c939.png\" alt=\"create-account\"></p>\n<p>그리고 웹사이트 속성도 설정한다.</p>\n<p><img src=\"/static/attr-setting-d3741890.png\" alt=\"attr-set\"></p>\n<p>비즈니스 정보도 적당히 설정한 후 약관 등에 동의하고 계정 생성을 마친다.</p>\n<h2>3.2. 블로그 이전하기</h2>\n<p>그리고 이제 내 블로그도 꼴이 좀 갖춰졌으니 내가 가지고 있는 <code>witch.work</code> 도메인이 새로 만든 블로그로 연결되도록 하자.</p>\n<p>지금은 내가 gatsby로 만들었던 블로그 페이지에 연결되어 있다.</p>\n<p>다음과 같이 cloudflare pages 메뉴에 들어간다.</p>\n<p><img src=\"/static/cloudflare-pages-93583b2b.png\" alt=\"cloudflare-pages\"></p>\n<p>그리고 기존에 쓰던 프로젝트에 들어간 후 <code>사용자 설정 도메인</code>메뉴에서 <code>witch.work</code> 도메인을 삭제한다.</p>\n<p><code>witch-next-blog</code>에서 사용자 설정 도메인에 <code>witch.work</code>추가.</p>\n<p><img src=\"/static/next-blog-custom-domain-2c635746.png\" alt=\"next-blog-custom-domain\"></p>\n<h2>3.3. 데이터 스트림과 태그 추가</h2>\n<p>그 다음 데이터 스트림 메뉴에 들어가서 페이지의 데이터 스트림을 추가해 주자.</p>\n<p><img src=\"/static/create-data-stream-bced1711.png\" alt=\"data-stream\"></p>\n<p>어..그런데 다음과 같은 경고가 뜬다. 데이터 수집이 활성화되지 않았다고 한다.</p>\n<p><img src=\"/static/site-no-data-b2e65df8.png\" alt=\"site-no-data\"></p>\n<h2>3.4. 추적 코드 설정</h2>\n<p>데이터 수집 활성화를 위해선 앞에서 획득한 측정 ID를 등록해 줘야 한다. GA 추적 코드를 설정하자. 여기서는 프론트의 왕 <a href=\"https://xo.dev/\">이창희</a>에게 그리고 <a href=\"https://mnxmnz.github.io/nextjs/google-analytics/\">김민지님의 블로그</a>에서 도움을 받았다.</p>\n<p><code>blog-config.ts</code>에 구글 애널리틱스 ID를 추가해 주자. 다음과 같이 작성해 준다. GA 추적 코드는 구글 애널리틱스에 들어가면 알 수 있는 <code>G-</code>로 시작하는 그 코드다.</p>\n<p>딱히 이게 git에 올라간다고 해서 보안상 문제가 있는 건 아니라서 이 파일에 작성해 줘도 상관없다.</p>\n<pre><code class=\"language-ts\">// blog-config.ts\nconst blogConfig: BlogConfigType = {\n  name:'김성현(Sung Hyun Kim)',\n  title:'Witch-Work',\n  description:\n    '대단한 뜻을 품고 사는 사람은 아닙니다. ' +\n    '그저 멋진 사람들이 내는 빛을 따라가다 보니 여기까지 왔고, ' +\n    '앞으로도 그렇게 살 수 있었으면 좋겠다고 생각하는 사람입니다. ' +\n    '이곳에 찾아오신 당신과도 함께할 수 있어 영광입니다.',\n  picture:'/witch.jpeg',\n  url:'https://witch-next-blog.vercel.app',\n  social: {\n    Github: 'https://github.com/witch-factory',\n    BOJ: 'https://www.acmicpc.net/user/city'\n  },\n  thumbnail: '/witch.jpeg',\n  /* 이 부분에 있는 걸 자신의 GA 추적 코드로 */\n  googleAnalyticsId:'G-XXXXXXXXXX'\n};\n</code></pre>\n<p>그리고 이걸 이용해 ga 추적을 하는 스크립트 컴포넌트를 만들어 준다. <a href=\"https://github.com/blurfx/ambienxo\">ambienxo</a>에서 적당히 가져온다.</p>\n<p>ga 추적 코드를 삽입해 주는 스크립트 코드를 <code>next/script</code>로 래핑한 것에 불과하다. <code>src/componenets/GoogleAnalytics.tsx</code>를 만들고 다음과 같이 작성해 준다.</p>\n<pre><code class=\"language-tsx\">// src/componenets/GoogleAnalytics.tsx\nimport Script from 'next/script';\n\nimport blogConfig from '../../blog-config';\n\nconst GoogleAnalytics = () => {\n  if (blogConfig.googleAnalyticsId == null) {\n    return null;\n  }\n  return (\n    &#x3C;>\n      &#x3C;Script\n        src={`https://www.googletagmanager.com/gtag/js?id=${blogConfig.googleAnalyticsId}`}\n        strategy='afterInteractive'\n      />\n      &#x3C;Script id='google-analytics' strategy='afterInteractive'>\n        {`\n          window.dataLayer = window.dataLayer || [];\n          function gtag(){window.dataLayer.push(arguments);}\n          gtag('js', new Date());\n\n          gtag('config', '${blogConfig.googleAnalyticsId}');\n        `}\n      &#x3C;/Script>\n    &#x3C;/>\n  );\n};\n\nexport default GoogleAnalytics;\n</code></pre>\n<p>그리고 <code>_app.tsx</code>에 이 컴포넌트를 추가해 준다. 모든 페이지에 적용되어야 하므로 <code>_app.tsx</code>이 괜찮은 선택이다.</p>\n<pre><code class=\"language-tsx\">// _app.tsx\nexport default function App({ Component, pageProps }: AppProps) {\n  return (\n    &#x3C;>\n      &#x3C;Head>\n        &#x3C;meta name='viewport' content='width=device-width, initial-scale=1' />\n        &#x3C;link rel='manifest' href='/site.webmanifest' />\n      &#x3C;/Head>\n      &#x3C;DefaultSeo {...SEOConfig} />\n      &#x3C;Header navList={blogCategoryList} />\n      &#x3C;Component {...pageProps} />\n      &#x3C;Footer />\n      {/* 여기에 추가 */}\n      &#x3C;GoogleAnalytics />\n    &#x3C;/>\n  );\n}\n</code></pre>\n<p>이걸 이용해서 조회수를 달고 싶은 사람들은 <a href=\"https://arturocampos.dev/blog/nextjs-with-google-analytics\">이 글</a>을 참고해 보자. 나는 Cloudflare환경 때문에 실패했지만..</p>\n<h1>4. firebaseDB 사용해서 조회수 측정 시도</h1>\n<p><a href=\"https://leerob.io/blog/real-time-post-views\">NextJS와 파이어베이스로 실시간 블로그 조회수 측정하기</a>를 하는 글, 그리고 <a href=\"https://www.pankajtanwar.in/blog/how-i-built-a-real-time-blog-view-counter-with-nextjs-and-firebase\">비슷한 다른 글</a>을 참고해서 DB를 사용해서도 조회수를 측정하려고 해보았다.</p>\n<p>특히, 구글 애널리틱스를 조회수에 사용할 경우 애드블럭 등의 이유로 약 <a href=\"https://leerob.io/blog/real-time-post-views\">10% 정도의 조회수가 누락된다고 한다.</a> 특히 기술 관련 블로그일 경우 더 그렇다고 한다. 아마 기술적인 내용을 읽는 사람들은 대부분 애드블럭을 써서 그런 듯 하다.</p>\n<h2>4.1. firebase 프로젝트 생성</h2>\n<p>firebase에 로그인하고 콘솔로 이동한다. 나는 구글 계정으로 로그인했다. 그리고 상단 메뉴에 '콘솔로 이동'을 눌러 콘솔로 이동한다.</p>\n<p>그러면 프로젝트를 만들 수 있는 화면이 나오는데 당연히 프로젝트를 만들러 이동하자.</p>\n<p><img src=\"/static/create-firebase-project1-2276238e.png\" alt=\"create-project\"></p>\n<p>난 <code>witch-blog-views</code>라는 프로젝트를 만들었다. 그리고 구글 애널리틱스를 달 수도 있는데 나는 이전에 만들어 둔 계정이 있어서 그냥 달았다.</p>\n<h2>4.2. DB 생성</h2>\n<p>프로젝트가 만들어지면 DB를 생성하자. 좌측 메뉴의 빌드 카테고리에서 <code>Realtime Database</code>를 선택한다.</p>\n<p><img src=\"/static/make-realtime-db-9f190ec2.png\" alt=\"make-db\"></p>\n<p>그리고 나오는 페이지에서 <code>데이터베이스 만들기</code>를 누른다. 대충 미국에 있는 DB 선택 후 테스트 모드로 시작.</p>\n<p>그리고 좌측 상단 메뉴의 '프로젝트 개요'의 옆에 있는 톱니바퀴를 누르면 프로젝트 설정 페이지로 이동 가능하다. 그리고 <code>서비스 계정</code> 탭으로 이동한다.</p>\n<p>거기서 <code>새 비공개 키 생성</code> 버튼을 누르고 나오는 json 파일을 잘 보관해 두자.</p>\n<p><img src=\"/static/create-key-626796ab.png\" alt=\"create-key\"></p>\n<h2>4.3. DB 연결</h2>\n<p>이제 DB를 연결한다. firebase-admin 설치</p>\n<pre><code class=\"language-bash\">npm i firebase-admin\n</code></pre>\n<p>그리고 <code>.env.local</code> 파일을 생성하고 이를 <code>.gitignore</code>에 추가한 후 다음과 같이 작성.</p>\n<pre><code class=\"language-env\">NEXT_PUBLIC_FIREBASE_PROJECT_ID=replace-me\nFIREBASE_CLIENT_EMAIL=replace-me\nFIREBASE_PRIVATE_KEY=\"replace-me\"\n</code></pre>\n<p>이는 아까 다운받은 json 파일에서 비슷한 이름의 키워드를 찾아서 값을 붙여넣으면 된다. <code>PRIVATE_KEY</code> 값에는 <code>\"</code>를 붙여줘야 한다.</p>\n<p>그다음 <code>src/lib/firebase.js</code>를 만들고 다음과 같이 작성한다. 앱을 초기화하고 연결을 만드는 코드다.</p>\n<pre><code class=\"language-js\">import * as admin from 'firebase-admin';\n \nif (!admin.apps.length) {\n  admin.initializeApp({\n    credential: admin.credential.cert({\n      projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,\n      clientEmail: process.env.FIREBASE_CLIENT_EMAIL,\n      privateKey: process.env.FIREBASE_PRIVATE_KEY.replace(/\\\\n/g, '\\n'),\n    }),\n  });\n}\n \nconst db = admin.firestore();\n \nexport { db };\n</code></pre>\n<p>이제 DB와의 연결을 만들었으니 특정 HTTP 요청마다 DB에 접근해서 view를 늘려 주는 함수를 API 라우트에 만들어 줘야 한다. <a href=\"https://www.pankajtanwar.in/blog/how-i-built-a-real-time-blog-view-counter-with-nextjs-and-firebase\">여기</a>에서 가져왔다. <code>api/views/[slug].js</code>를 만들고 다음과 같이 작성한다.</p>\n<pre><code class=\"language-js\">import db from '@/lib/firebase'\n\nexport default async (req, res) => {\n  // increment the views\n  if (req.method === 'POST') {\n    const ref = db.ref('views').child(req.query.slug)\n    const { snapshot } = await ref.transaction((currentViews) => {\n      if (currentViews === null) {\n        return 1\n      }\n      return currentViews + 1\n    })\n\n    return res.status(200).json({\n      total: snapshot.val(),\n    })\n  }\n\n  // fetch the views\n  if (req.method === 'GET') {\n    const snapshot = await db.ref('views').child(req.query.slug).once('value')\n    const views = snapshot.val()\n\n    return res.status(200).json({ total: views })\n  }\n}\n</code></pre>\n<p>이렇게 하고 <code>npm run dev</code>로 개발 모드 실행 후 <code>http://localhost:3000/api/views/this-is-blog-slug</code>와 같이 <code>/api/views/글제목</code>주소로 post 요청을 보낼 시 firebase realtime DB에서 view가 늘어나는 것을 확인할 수 있다. 나는 post 요청에 postman을 사용했는데 다른 걸 사용해도 상관없다.</p>\n<h2>4.4. Cloudflare 환경 문제</h2>\n<p>위처럼 하고 cloudflare 빌드를 해보자. 참고로 로컬 환경에서도 cloudflare에서 하는 것처럼 돌려볼 수 있는데 커맨드는 다음과 같다.</p>\n<pre><code class=\"language-bash\">npx @cloudflare/next-on-pages\n# 다른 터미널에서 다음 커맨드를 실행하면 로컬호스트에서 빌드된 결과가 실행된다.\nnpx wrangler pages dev .vercel/output/static --compatibility-flag=nodejs_compat\n</code></pre>\n<p>아무튼 이렇게 빌드해 보면 바로 에러가 뜬다.</p>\n<pre><code class=\"language-bash\">The following functions were not configured to run with the Edge Runtime:\n⚡️ \t\t- api/views/[slug].func\n</code></pre>\n<p>이 뒤에도 쭉 에러가 뜨는데 대충 런타임을 엣지로 설정하라는 소리다. 왜냐? <a href=\"https://developers.cloudflare.com/pages/framework-guides/deploy-a-nextjs-site/#2-configure-the-application-to-use-the-edge-runtime\">NextJS의 SSR은 기본적으로 Nodejs 런타임을 사용하는 데 Cloudflare Page에서는 이를 지원하지 않기 때문이다.</a></p>\n<p>그래서 다음 문장을 <code>api/views/[slug].js</code>에 추가해 준다.</p>\n<pre><code class=\"language-js\">export const runtime = 'edge';\n</code></pre>\n<p>이렇게 하니 이제는 이런 에러가 뜬다.</p>\n<pre><code class=\"language-bash\">Dynamic Code Evaluation (e. g. 'eval', 'new Function', 'WebAssembly.compile') not allowed in Edge Runtime\n</code></pre>\n<p>대충 엣지 런타임에서는 지원 안 되는 뭔가를 쓰고 있다는 것 같다. <a href=\"https://github.com/firebase/firebase-admin-node/issues/2069\">관련된 github 이슈</a>도 있었는데, <code>firebase-admin</code>은 full Nodejs 런타임을 요구하며 이것은 Cloudflare worker에서 현재 지원하지 않는다는 말이 있었다.</p>\n<p>이를 해결하기 위한 <a href=\"https://github.com/awinogrodzki/next-firebase-auth-edge\">패키지가 이미 나와 있지만</a>너무 하기 힘들어서 포기했다.</p>\n<p>만약 이걸 이용해서 조회수를 달고 싶은 사람이 있다면 <a href=\"https://www.pankajtanwar.in/blog/how-i-built-a-real-time-blog-view-counter-with-nextjs-and-firebase\">참고 글</a>을 따라해서 SWR로 데이터를 페칭하여 조회수를 보여주는 컴포넌트를 만들어 주면 된다. 하지만 이번에도 이렇게 Cloudflare가 발목을 잡아서, 새로운 시도를 한다.</p>\n<h1>5. supabase로 조회수 측정하기</h1>\n<p>firebase를 대체하는 오픈소스인 supabase를 사용해 보기로 했다. 이는 Edge function도 지원한다고 한다.</p>\n<h2>5.1. 조회수 카운터 설계</h2>\n<p>상당히 많은 길을 돌아왔는데, 조회수 카운터에 뭐가 필요할지를 생각해 보자. DB를 이용해서 페이지의 조회수를 측정한다고 할 때, 조회수 카운터의 기능은 다음과 같다.</p>\n<ol>\n<li>페이지가 로드될 때 서버리스 DB에서 페이지의 조회수를 불러와서 보여준다.</li>\n<li>페이지가 로드될 때 페이지에 해당하는 조회수 카운터를 DB에서 1 늘린다.</li>\n</ol>\n<p>이 과정은 글 제목마다 따로 해줘야 한다. 따라서 DB의 각 엔티티는 글 제목(사실 글 제목은 한글로 작성되어 있으므로, 편의상 글이 담긴 폴더명이 될 것이다)과 해당 글의 조회수를 담고 있으며 제목은 PK로 작동하도록 하는 게 좋겠다.</p>\n<p>그리고 DB와의 통신은 Nextjs에서 제공하는 api 라우트를 사용할 것이고 api 라우트 정보를 받아오기 위해서는 SWR 라이브러리를 쓸 것이다. <a href=\"https://swr.vercel.app/ko/docs/with-nextjs\">SWR을 Next.js와 함께 사용하는 방법</a>을 참고하면 될 것 같다.</p>\n<p>api 라우트에서는 DB에서 정보를 받아올 것이다.</p>\n<p><img src=\"/static/supabase-logic-fe59e570.png\" alt=\"supabase 통신 논리\"></p>\n<p>이대로 한번 구성해 보자. DB는 사실 직접 편집이 가능하기 때문에(supabase DB는 웹에서 쉽게 편집하는 것도 가능하다)  내가 쓴 특정 글 조회수를 직접 10억으로 설정한다든지 할 수도 있기에 정확한 측정과는 거리가 멀다고 할 수도 있다. 하지만 어차피 그걸 변조할 수 있는 것도 나뿐이고 측정하고 있다는 사실 자체가 중요하기에 이 정도면 충분하다고 생각한다.</p>\n<h2>5.2. supabase 프로젝트 생성</h2>\n<p>supabase 프로젝트부터 생성하자. <a href=\"https://supabase.com/\">supabase</a>페이지에 접속해서 github으로 로그인한 후 새 프로젝트를 생성한다. <a href=\"https://supabase.com/docs/guides/getting-started/quickstarts/nextjs\">공식 문서</a>에서 nextJS에서 쓰는 과정을 친절히 설명해 준다.</p>\n<p><a href=\"https://app.supabase.com/projects\">프로젝트 페이지</a>에서 새 프로젝트를 생성한다. <a href=\"https://supabase.com/pricing\">가격정책</a>을 보니 대충 파이어베이스보다 무료 정책이 좋아 보인다. 이것도 vercel에 비해 cloudflare Page 배포가 혜자인 것과 비슷한 느낌이... 아무튼 정보를 입력하고 프로젝트를 생성한다. 리전은 한국 리전이 있길래 그걸로 했다.</p>\n<p><img src=\"/static/create-supabase-project-c54adacc.png\" alt=\"supabase 프로젝트 생성\"></p>\n<p>이제 테이블을 만들자. <a href=\"https://app.supabase.com/project/_/sql\">SQL 에디터</a>에서 프로젝트를 선택하고 Create table을 누른 후 다음과 같이 SQL을 입력해 <code>views</code> 테이블을 생성한다. 글 제목을 뜻하는 slug를 PK로 설정하였고 정수형 view_count와 조회수 생성 시점을 뜻하는 timestamp를 넣어주었다.</p>\n<p>view_count에 쓰인 int4는 supabase의 4바이트 정수형이다. int2를 쓰면 32,767까지 저장되는 2바이트 정수형이 된다. 다만 나는 언젠가 내 글들이 2^15번은 넘게 조회되길 바라는 마음으로 int4를 썼다. 설마 21억번 넘게 조회되는 블로그가 되진 않겠지?</p>\n<pre><code class=\"language-sql\">create table views (\n  slug text primary key,\n  created_at timestamp with time zone default timezone('utc'::text, now()) not null,\n  view_count int4\n);\n</code></pre>\n<p>그리고 다음과 같은 SQL문을 실행시켜서 조회수를 1 늘리는 함수를 추가한다. 요즘은 SQL에서 함수도 넣을 수 있다.</p>\n<pre><code class=\"language-sql\">create function increment (slug_text text)\nreturns void as\n$$\nupdate views\nset view_count = view_count + 1\nwhere slug = slug_text;\n$$\nlanguage sql volatile;\n</code></pre>\n<p>그리고 브라우저에서 supabase를 조작할 수 있게 하는 supabase/js 설치.</p>\n<pre><code class=\"language-bash\">npm install @supabase/supabase-js\n</code></pre>\n<p><code>.env.local</code>에는 다음과 같은 내용을 작성하자. <code>replace-me</code>의 자리에는 나의 프로젝트URL과 anonkey를 넣어준다. 프로젝트명과 anonkey는 <a href=\"https://app.supabase.com/project/_/settings/api\">여기</a>에서 확인할 수 있다.</p>\n<pre><code class=\"language-env\">SUPABASE_URL=replace-me\nSUPABASE_KEY=replace-me\n</code></pre>\n<p>그다음 <code>src/lib/supabaseClient.js</code>를 만들고 다음과 같이 작성한다.</p>\n<pre><code class=\"language-js\">import { createClient } from '@supabase/supabase-js'\n\nexport const supabase = createClient(\n  process.env.SUPABASE_URL,\n  process.env.SUPABASE_KEY\n);\n</code></pre>\n<p>그리고 이를 <code>cloudflare Pages</code>에서도 환경 변수로 추가해 준다. Workers 및 Pages 메뉴에서 내가 만든 프로젝트를 선택하고 <code>설정-환경 변수</code> 메뉴에서 위에서 설정한 <code>SUPABASE_URL</code> 과 <code>SUPABASE_KEY</code>를 추가해 준다.</p>\n<p><img src=\"/static/cloudflare-env-8278cff6.png\" alt=\"cloudflare에서 환경 변수 설정\"></p>\n<h2>5.3. 조회수 가져오기</h2>\n<p>조회수를 가져오는 api 라우트를 만들어 보자. <code>api/views/[slug].js</code>를 만든다든지 하면 좋겠지만 Cloudflare Page 배포 환경에선 그런 거 없다.</p>\n<p>Cloudflare Pages에서는 서버 컴포넌트들에 대해서 edge runtime밖에 지원하지 않는데 <a href=\"https://nextjs.org/docs/pages/building-your-application/routing/api-routes#edge-api-routes\">이렇게 되면 모든 api 라우트는 페이지가 아니라 API 엔드포인트로 취급되게 되기 때문이다.</a> 그러므로 동적 api 라우트는 안된다. 어쨌든 api 라우트에서 데이터를 받아 와야 하는 건 맞으니까 한번 방법을 찾아보자.</p>\n<p>Cloudflare 배포환경으로 빌드해보는 다음 커맨드로 차근차근 시험하며 하나씩 해본다.</p>\n<pre><code class=\"language-bash\"># cloudflare Pages 빌드환경으로 실험하는 커맨드\nnpx @cloudflare/next-on-pages\nnpx wrangler pages dev .vercel/output/static --compatibility-flag=nodejs_compat\n</code></pre>\n<p><code>src/lib/supabaseClient.js</code>에 정의된 supabase 객체를 이용해서 조회수를 가져오는 함수를 만들어주자. 공식 문서를 보면서 겨우 만들었다. 이렇게 하면 <code>views</code> 테이블에서 <code>view_count</code>컬럼만 가져오고 그중에서 <code>slug</code> 컬럼 값이 함수 인수로 받은 <code>slug</code>와 같은 row만 가져오며 <code>single</code>함수를 이용해서 리턴값을 객체 배열 대신 단일 객체로 가져오도록 한다.</p>\n<p><code>slug</code>가 PK이므로 애초에 <code>.eq('slug', slug)</code>절에서부터 리턴되는 row는 없거나 하나뿐이게 되고 <code>single</code>의 사용은 적절하다.</p>\n<pre><code class=\"language-js\">// src/lib/supabaseClient.js\nexport async function getViewCount(slug) {\n  const {data, error}=await supabase.from('views').select('view_count').eq('slug', slug).single();\n  return data;\n}\n</code></pre>\n<p>그런데 앞서 언급했다시피 edge runtime에는 동적 api 라우트를 쓸 수 없다. 그러면 slug를 어떻게 넘길까? get 요청이기 때문에, 쿼리스트링으로 넘기도록 하자. slug는 별로 보안상 중요한 정보가 아니기 때문에 이렇게 넘겨도 괜찮을 것이다.</p>\n<p>그러면 <code>api/view/index.ts</code>를 만들고 다음과 같이 작성한다.</p>\n<pre><code class=\"language-ts\">// edge 런타임에 작동\nexport const runtime = 'edge';\n\nimport type { NextRequest } from 'next/server';\n\nimport { getViewCount } from '../../../lib/supabaseClient';\n\nexport default async function handler(\n  req: NextRequest,\n) {\n  /* 쿼리스트링에서 slug를 뽑아낸다.\n  따라서 쿼리스트링은 ?slug=my-post-slug와 같이 작성되어야 한다. */\n  const { searchParams } = new URL(req.url);\n  const slug = searchParams.get('slug');\n  /* 쿼리스트링에 slug가 없을 시 */\n  if (!slug) {\n    return new Response(\n      'invalid slug in query string',\n      {\n        status: 400,\n        headers: {\n          'content-type': 'application/json',\n        },\n      }\n    );\n  }\n  /* 쿼리스트링의 slug를 기반으로 view_count가 들어 있는 객체를 가져온다.\n  리턴값은 만약 slug에 해당하는 row가 있을 경우 {view_count : 조회수(숫자)} 와 같다. */\n  const data = await getViewCount(slug);\n\n  return new Response(\n    data?.view_count || 0,\n    {\n      status: 200,\n      headers: {\n        'content-type': 'application/json',\n      },\n    }\n  );\n}\n</code></pre>\n<p>이 함수를 어떻게 실험하냐고? 나는 <code>/about</code> 라우트에서 실험했다. 대충 이런 컴포넌트를 만들어 가면서...</p>\n<pre><code class=\"language-tsx\">function View({slug}: {slug: string}) {\n  const {data}=useSWR(`/api/view?slug=${slug}`);\n  return &#x3C;div>{`조회수 ${JSON.stringify(data)}회`}&#x3C;/div>;\n}\n</code></pre>\n<p>그냥 만들어 가는 중간 과정이므로 자세한 설명은 생략하겠다. 적당히 안 쓰는 라우트 하나에서 실험해 가며 만드는 것이다. useSWR과 nextjs를 함께 쓰는 방법은 <a href=\"https://swr.vercel.app/ko/docs/with-nextjs\">여기</a>에서 참고.</p>\n<h2>5.4. 조회수 가져오기 - 에러 상황 해결</h2>\n<p>그런데 만약 어떤 글의 조회수가 아직 없는 상태에서 새로운 사용자가 접속해서 DB에 조회수를 요청한다면? 그러면 DB에 slug에 해당하는 row가 없으므로 문제가 생길 것이다. 실제로 에러가 발생하며 이 경우 data는 null이 반환된다. 이를 해결해 줘야 한다.</p>\n<p>따라서 특정 함수를 만들어서, <code>getViewCount</code>를 시도하고 error가 row가 없어서 발생하는 경우에는 해당 slug에 대한 조회수 row를 넣어 주는 것으로 하자.</p>\n<p>data, error를 동시에 반환하도록 하고 error가 row가 없어서 발생하는 경우에는 해당 slug에 대한 조회수 row를 넣어 주는 것으로 하자. 에러 형식은 실험한 결과 다음과 비슷한 형식으로 반환된다.</p>\n<pre><code>{\n  code: 'PGRST116',\n  details: 'Results contain 0 rows, application/vnd.pgrst.object+json requires 1 row',\n  hint: null,\n  message: 'JSON object requested, multiple (or no) rows returned'\n}\n</code></pre>\n<p>따라서 <code>error.detail</code>에 <code>\"0 rows\"</code> 가 포함되어 있는 경우를 해당 slug에 조회수가 아직 없는 것으로 간주하고 나머지 상황들도 적절히 처리해 주는 <code>fetchViewCount</code> 함수를 만들자.</p>\n<p>일단 <code>getViewCount</code>를 다음과 같이 수정한다. data, error를 둘 다 반환한다.</p>\n<pre><code class=\"language-ts\">// src/lib/supabaseClient.js\nasync function getViewCount(slug) {\n  const {data, error}=await supabase\n    .from('views')\n    .select('view_count')\n    .eq('slug', slug)\n    .single();\n\n  return {data, error};\n}\n</code></pre>\n<p>그리고 인수 slug를 받아서 해당 slug에 대해 1의 조회수 정보를 만들어 주는 <code>registerViewCount</code>함수를 만든다.</p>\n<pre><code class=\"language-ts\">// src/lib/supabaseClient.js\nexport async function registerViewCount(slug) {\n  await supabase\n    .from('views')\n    .insert({slug, view_count:1});\n}\n</code></pre>\n<p>이것들을 모두 이용한 <code>fetchViewCount</code> 함수를 작성한다.</p>\n<pre><code class=\"language-ts\">// src/lib/supabaseClient.js\n// slug를 받아서 해당 slug row의 view_count 반환\nexport async function fetchViewCount(slug) {\n  const {data, error}=await getViewCount(slug);\n  \n  // 만약 slug와 같은 제목을 가진 row가 없다면 추가한 후 다시 getViewCount\n  if (error) {\n    if (error.details.includes('0 rows')) {\n      /* 새로운 row 삽입 */\n      await registerViewCount(slug);\n      const {data:newData, error:newError}=await getViewCount(slug);\n      if (newError) {\n        /* 그래도 에러 발생 */\n        return {data:null, error:newError};\n      }\n      else {\n        return {data:newData, error:null};\n      }\n    }\n    else {\n      /* 0 row가 아닌 에러 발생 */\n      return {data:null, error};\n    }\n  }\n  return {data, error};\n}\n</code></pre>\n<p>이걸 <code>api/view/index.ts</code>에 적용해 준다.</p>\n<pre><code class=\"language-ts\">// api/view/index.ts\nimport { fetchViewCount } from '../../../lib/supabaseClient';\n\nexport default async function handler(\n  req: NextRequest,\n) {\n  const { searchParams } = new URL(req.url);\n  const slug = searchParams.get('slug');\n  if (!slug) {\n    return new Response(\n      'invalid slug in query string',\n      {\n        status: 400,\n        headers: {\n          'content-type': 'application/json',\n        },\n      }\n    );\n  }\n  // fetchViewCount로 변경\n  const {data, error} = await fetchViewCount(slug);\n\n  if (error) {\n    return new Response(\n      null,\n      {\n        status: 500,\n        headers: {\n          'content-type': 'application/json',\n        },\n      }\n    );\n  }\n\n  return new Response(\n    data?.view_count || 0,\n    {\n      status: 200,\n      headers: {\n        'content-type': 'application/json',\n      },\n    }\n  );\n}\n</code></pre>\n<p>이제 <code>src/pages/posts/[category]/[slug]/index.tsx</code>에서 조회수를 가져오는 컴포넌트를 만들어 보자. 이 컴포넌트는 <code>useSWR</code>을 이용해서 만들 것이다.</p>\n<p><code>api/view</code>에 적당히 쿼리스트링을 넣어서 fetch하면 된다.</p>\n<pre><code class=\"language-tsx\">// src/pages/posts/[category]/[slug]/index.tsx\nfunction ViewCounter({slug}: {slug: string}) {\n  const {data}=useSWR(`/api/view?slug=${slug}`);\n  return &#x3C;div>{`조회수 ${data}회`}&#x3C;/div>;\n}\n</code></pre>\n<p>그리고 모든 SWR 훅에 초기값으로 프리페칭될 데이터를 넘겨주기 위해 SWRConfig의 fallback 옵션을 사용한다. <code>getStaticProps</code>를 다음과 같이 변경한다.</p>\n<pre><code class=\"language-tsx\">// src/pages/posts/[category]/[slug]/index.tsx\nexport const getStaticProps: GetStaticProps= async ({params})=>{\n  const post = getSortedPosts().find(\n    (p: DocumentTypes) => {\n      const temp=p._raw.flattenedPath.split('/');\n      return temp[0] === params?.category &#x26;&#x26; temp[1] === params?.slug;\n    }\n  )!;\n\n  const {data}=await fetchViewCount(params?.slug);\n  const fallback={\n    [`/api/view?slug=${params?.slug}`]: data?.view_count,\n  };\n\n  return {\n    props: {\n      post,\n      fallback\n    },\n  };\n};\n</code></pre>\n<p><code>ViewCounter</code>컴포넌트에서 쓸 fallback이므로 해당 컴포넌트가 쓰일 때 <code>SWRConfig</code>를 감싸 주면 된다.</p>\n<pre><code class=\"language-tsx\">const slug=post._raw.flattenedPath.split('/')[1];\n// 생략\n&#x3C;SWRConfig value={{fallback}}>\n  &#x3C;ViewCounter slug={slug} />\n&#x3C;/SWRConfig>\n</code></pre>\n<p>이렇게 되면 <code>ViewCounter</code>에서 쓰이는 SWR 훅은 초기값으로 <code>await fetchViewCount(params?.slug);</code>의 결과에서 뽑아낸 view_count를 쓰게 된다. 그리고 useSWR훅이 요청을 보내는 api 라우트에서도 data로 view_count를 보낸다. 따라서 언제나 <code>ViewCounter</code>에서는 useSWR의 리턴값으로 조회수(숫자)를 받게 되고 이를 이용해서 조회수를 보여주게 된다.</p>\n<h2>5.5. 조회수 집계</h2>\n<p>위처럼 하면 어느 글에 들어가든 무조건 조회수 1이 뜨게 된다. 하지만 아직 할 게 남았다. 사용자의 게시글 조회에 따라 조회수를 늘려 줘야 한다. 이는 <code>ViewCounter</code>의 useEffect에서 처리하자. <code>ViewCounter</code> 컴포넌트를 분리하는 것부터 시작하자.</p>\n<p><code>src/components/viewCounter/index.tsx</code>를 만들고 다음과 같이 작성한다. 아까의 <code>ViewCounter</code>컴포넌트를 그대로 가져왔다.</p>\n<pre><code class=\"language-tsx\">import useSWR from 'swr';\n\nfunction ViewCounter({slug}: {slug: string}) {\n  const {data:view_count}=useSWR(`/api/view?slug=${slug}`);\n  return &#x3C;div>{`조회수 ${view_count}회`}&#x3C;/div>;\n}\n\nexport default ViewCounter;\n</code></pre>\n<p>slug에 대해 조회수를 1 늘려주는 함수를 <code>src/lib/supabaseClient.js</code>에 추가한다. 아까전에 만들었던 increment SQL 함수를 이용하면 된다. 이때 Postgres 함수를 이용하는 방법은 <a href=\"https://supabase.com/docs/reference/javascript/rpc\"><code>supabase.rpc</code>를 이용하면 된다.</a></p>\n<pre><code class=\"language-ts\">export async function updateViewCount(slug) {\n  await supabase.rpc('increment', {slug_text:slug});\n}\n</code></pre>\n<p>이를 api 라우트에서도 추가하여 <code>api/view/index.ts</code>를 다음과 같이 수정한다. 만약 요청의 method가 post일 경우 <code>updateViewCount</code>를 실행하는 것이다.</p>\n<pre><code class=\"language-ts\">export default async function handler(\n  req: NextRequest,\n) {\n  /* 생략 */\n  const {data, error} = await fetchViewCount(slug);\n  /* post 요청일 때 조회수 카운트 1 증가시키기 */\n  if (req.method === 'POST') {\n    await updateViewCount(slug);\n  }\n\n  /* 생략 */\n}\n</code></pre>\n<p><code>ViewCounter</code>는 다음과 같이 수정하여 컴포넌트가 렌더링되는 시점에 <code>/api/views?쿼리스트링</code>으로 post 요청을 보내도록 하여 조회수를 늘려 준다. 페이지가 렌더링될 때 <code>ViewCounter</code>가 렌더링되면서 useEffect에 의해 조회수 증가 요청을 서버로 보내게 되는 원리이다.</p>\n<pre><code class=\"language-tsx\">import { useEffect } from 'react';\nimport useSWR from 'swr';\n\nfunction ViewCounter({slug}: {slug: string}) {\n  const {data:view_count}=useSWR(`/api/view?slug=${slug}`);\n\n  useEffect(() => {\n    fetch(`/api/view?slug=${slug}`, {\n      method: 'POST',\n    });\n  }, [slug]);\n\n  return &#x3C;div>{`조회수 ${view_count}회`}&#x3C;/div>;\n}\n\nexport default ViewCounter;\n</code></pre>\n<p>이렇게 하면 조회수가 늘어나지만 왠지 조회수가 2씩 늘어나는 문제가 있었다. 잘 보니 react strict mode가 활성화되어 있었다. 이게 활성화되어 있으면 각 컴포넌트가 2번씩 렌더링되게 되는데, 우리는 updateViewCount를 <code>ViewCounter</code>렌더링 시점에 실행시켰으므로 조회수도 2번 늘어나게 되는 것이다.</p>\n<p><code>next.config.js</code>에서 react strict mode를 비활성화하자. 사실 <a href=\"https://github.com/cloudflare/next-on-pages/blob/main/docs/supported.md\">Cloudflare Pages의 Nextjs 빌드에서는 react strict mode를 아직 지원하지 않으므로</a> 당장은 상관없지만 그냥 해주자.</p>\n<pre><code class=\"language-js\">const { withContentlayer } = require('next-contentlayer');\n\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  images:{\n    unoptimized:true,\n  },\n  reactStrictMode: false,\n  swcMinify:false,\n};\n\nmodule.exports = (withContentlayer(nextConfig));\n</code></pre>\n<h2>5.6. Cloudflare에서 Vercel로 다시...</h2>\n<p>이 상태로 배포했더니 조회수는 잘 나온다. 하지만 조회수가 실시간으로 변경되지 않는다. 왜 그럴까? 봤더니 <code>getStaticProps</code>에서 받아온 fallback까지는 잘 쓰이는데, 그 이후 SWR의 갱신 요청이 이루어지지 않았다(개발자 도구의 네트워크 탭을 보고 알았다).</p>\n<p>하지만 또 보니 <code>ViewCounter</code>의 useEffect에서 가는 요청은 잘 가고 있었다. SWR이 Cloudflare환경에선 잘 안되나 보다. Cloudflare 또 너냐! <a href=\"https://community.cloudflare.com/t/support-for-stale-while-revalidate/496788/9\">SWR 지원에 대한 얘기가 cloudflare 커뮤니티에서도 이미 있었다.</a> <a href=\"https://aws.amazon.com/ko/about-aws/whats-new/2023/05/amazon-cloudfront-stale-while-revalidate-stale-if-error-cache-control-directives/\">CloudFront에서조차 최근 SWR 지원을 시작했는데...</a></p>\n<p>이 문제를 해결하기 위해서 정말 많은 시간을 소모했다. useEffect에서 해보기도 하고 수많은 이슈를 찾아보기도 하고 다른 데이터 페칭을 써보기도 하고...하지만 결국 Cloudflare에서는 edge runtime에서 실시간성을 띄는 어떤 것을 하는 게 거의 불가능한 것 같다.</p>\n<p>그래서 다시 vercel로 배포한 후 최대한 bandwidth를 최적화해보기로 했다. 나보다 훨씬 더 조회수가 많은 블로그도 bandwidth가 고작 3기가 정도밖에 안 나오는데 내가 100기가가 넘는 bandwidth를 갖는다는 건 애초에 뭔가 이상했다. 아무튼 vercel로 가자.</p>\n<h1>6. Vercel로 재배포</h1>\n<h2>6.1. supabase key 등록</h2>\n<p>이왕 supabase를 쓰기로 했으니 이걸 계속 쓰자. firebase보다 편하기도 하고 무료 지원도 빵빵하니까(특히 Realtime Database 허용 개수가 2배다)</p>\n<p>vercel의 프로젝트에서 Setting-Environment Variables 에 가서 환경 변수로 위에서 만든 <code>SUPABASE_URL</code>과 <code>SUPABASE_KEY</code>를 추가해 준다.</p>\n<p><img src=\"/static/vercel-env-6c788102.png\" alt=\"vercel 환경변수 등록\"></p>\n<h2>6.2. 파일 재작성</h2>\n<p><code>src/lib/supabaseClient.js</code>는 당장 변경할 필요는 없다.</p>\n<p><code>api/view/index.ts</code>를 다음과 같이 변경한다. Response 객체 말고 NextApiResponse를 쓸 수 있게 되었으므로 좀 더 간결해졌다. 또한 <code>updateViewCount</code>는 사실 <code>fetchViewCount</code>와 별개로 진행되어도 되므로 await을 떼주었다.</p>\n<pre><code class=\"language-ts\">// src/pages/api/view/index.ts\nimport { NextApiRequest, NextApiResponse } from 'next';\n\nimport { fetchViewCount, updateViewCount } from '../../../lib/supabaseClient';\n\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse\n) {\n  const slug = req.query?.slug?.toString();\n\n  if (!slug) {\n    return res.status(400).json({error: 'invalid slug in query string'});\n  }\n  \n  if (req.method === 'POST') {\n    await updateViewCount(slug);\n  }\n\n  const {data, error} = await fetchViewCount(slug);\n  \n  if (error) {\n    return res.status(500).json({error});\n  }\n  return res.status(200).json({view_count:data?.view_count || 0});\n}\n</code></pre>\n<p><code>ViewCounter</code> 컴포넌트는 다음과 같이.</p>\n<pre><code class=\"language-tsx\">// src/components/viewCounter/index.tsx\nimport { useEffect } from 'react';\nimport useSWR from 'swr';\n\nimport styles from './styles.module.css';\n\nconst fetcher = async (input: RequestInfo) => {\n  const res: Response = await fetch(input);\n  return await res.json();\n};\n\nfunction ViewCounter({slug}: {slug: string}) {\n  const {data}=useSWR(`/api/view/${slug}`, fetcher);\n  \n  useEffect(() => {\n    fetch(`/api/view/${slug}`, {\n      method: 'POST',\n    });\n  }, [slug]);\n\n  return (\n    &#x3C;div className={styles.counter}>\n      {`조회수 ${data?.view_count??'---'}회`}\n    &#x3C;/div>\n  );\n}\n\nexport default ViewCounter;\n</code></pre>\n<p>이렇게 하면 각 글의 상세 페이지에서 글 조회수가 잘 보이는 걸 확인할 수 있다.</p>\n<h1>7. ViewCounter 스타일</h1>\n<p>viewCounter를 적당히 스타일링한다. 일단 font-size는 1.25rem으로 변경. 이건 간단하니까 생략.</p>\n<p>그리고 날짜와 같은 선상에 있게 한 후 날짜와 조회수 사이에 얇은 회색 선을 넣어주자.</p>\n<p><code>src/pages/posts/[category]/[slug]/index.tsx</code>의 컴포넌트 중 ViewCounter 주변을 다음과 같이 구조화한다.</p>\n<pre><code class=\"language-tsx\">// src/pages/posts/[category]/[slug]/index.tsx\n&#x3C;div className={styles.infoContainer}>\n  &#x3C;time className={styles.time} dateTime={toISODate(dateObj)}>\n    {formatDate(dateObj)}\n  &#x3C;/time>\n  &#x3C;div className={styles.line}>&#x3C;/div>\n  &#x3C;ViewCounter slug={slug} />\n&#x3C;/div>\n</code></pre>\n<p>그리고 각각의 스타일링은 다음과 같이.</p>\n<pre><code class=\"language-css\">// src/pages/posts/[category]/[slug]/styles.module.css\n.infoContainer{\n  display:grid;\n  grid-template-columns:auto 1fr auto;\n  margin-bottom:0.5rem;\n}\n\n.line{\n  margin:auto 0.5rem;\n  border:1px solid var(--gray1);\n  height:0;\n}\n</code></pre>\n<p>이렇게 하니까 조회수가 날짜와 같은 선상에 있게 되었다. 그리고 실시간으로 잘 나온다. fallback을 안 줘야 실시간으로 잘 작동하는 것 같다.</p>\n<h1>참고</h1>\n<p><a href=\"https://curryyou.tistory.com/508\">https://curryyou.tistory.com/508</a></p>\n<p><a href=\"https://mnxmnz.github.io/nextjs/google-analytics/\">https://mnxmnz.github.io/nextjs/google-analytics/</a></p>\n<p><a href=\"https://ha-young.github.io/2020/gatsby/Add-Google-Analytics/\">https://ha-young.github.io/2020/gatsby/Add-Google-Analytics/</a></p>\n<p><code>_document.js</code> <a href=\"https://nextjs.org/docs/pages/building-your-application/routing/custom-document\">https://nextjs.org/docs/pages/building-your-application/routing/custom-document</a></p>\n<p><code>_app.js</code> <a href=\"https://nextjs.org/docs/pages/building-your-application/routing/custom-app\">https://nextjs.org/docs/pages/building-your-application/routing/custom-app</a></p>\n<p><a href=\"https://dev.to/ahmedmohmd/difference-between-appjs-and-documentjs-files-in-nextjs-3ah2\">https://dev.to/ahmedmohmd/difference-between-appjs-and-documentjs-files-in-nextjs-3ah2</a></p>\n<p>GA로 조회수 붙이기 <a href=\"https://arturocampos.dev/blog/nextjs-with-google-analytics\">https://arturocampos.dev/blog/nextjs-with-google-analytics</a></p>\n<p><a href=\"https://nextjs.org/docs/messages/next-script-for-ga\">https://nextjs.org/docs/messages/next-script-for-ga</a></p>\n<p><a href=\"https://mariestarck.com/add-google-analytics-to-your-next-js-application-in-5-easy-steps/\">https://mariestarck.com/add-google-analytics-to-your-next-js-application-in-5-easy-steps/</a></p>\n<p><a href=\"https://leerob.io/blog/real-time-post-views\">https://leerob.io/blog/real-time-post-views</a></p>\n<p><a href=\"https://bepyan.github.io/blog/nextjs-blog/5-google-analytics\">https://bepyan.github.io/blog/nextjs-blog/5-google-analytics</a></p>\n<p><a href=\"https://andresrodriguez.dev/blog/count-blog-post-views-with-firebase\">https://andresrodriguez.dev/blog/count-blog-post-views-with-firebase</a></p>\n<p><a href=\"https://nextjs.org/docs/pages/building-your-application/routing/api-routes\">https://nextjs.org/docs/pages/building-your-application/routing/api-routes</a></p>\n<p>supabase로 조회수 측정\n<a href=\"https://dev.to/100lvlmaster/adding-view-count-to-your-nextjs-blog-55lj\">https://dev.to/100lvlmaster/adding-view-count-to-your-nextjs-blog-55lj</a></p>\n<p>SWR과 nextjs 같이 쓰기\n<a href=\"https://swr.vercel.app/ko/docs/with-nextjs\">https://swr.vercel.app/ko/docs/with-nextjs</a></p>\n<p>supabase 공식문서의 함수들 <a href=\"https://supabase.com/docs/reference/javascript/introduction\">https://supabase.com/docs/reference/javascript/introduction</a></p>\n<p>supabase에서는 에러가 throw되는 대신 그냥 리턴된다. <a href=\"https://supabase.com/blog/improved-dx\">https://supabase.com/blog/improved-dx</a></p>\n<p><a href=\"https://codebycorey.com/blog/page-views-nextjs-supabase\">https://codebycorey.com/blog/page-views-nextjs-supabase</a></p>",
    "excerpt": "블로그 만들기 시리즈\n|제목|링크|\n|---|---|\n|1. 기본 세팅|https://witch.work/posts/blog-remake-1|\n|2. 메인 페이지의 HTML 설계|https://witch.work/posts/blog-remake-2|\n|3. 글 상세 페이지의 구조 설계|https://witch.work/posts/blog-remake-3|\n|4. 이미지를 상대 경로로 쓸 수 있도록 하기|https://witch.work/posts/blog-rem",
    "headingTree": [
      {
        "title": "블로그 만들기 시리즈",
        "url": "#블로그-만들기-시리즈",
        "items": []
      },
      {
        "title": "1. 글 옮기기",
        "url": "#1-글-옮기기",
        "items": []
      },
      {
        "title": "2. busuanzi",
        "url": "#2-busuanzi",
        "items": [
          {
            "title": "2.1. 사이트 조회수와 방문자 수",
            "url": "#21-사이트-조회수와-방문자-수",
            "items": []
          },
          {
            "title": "2.2. 페이지 조회수",
            "url": "#22-페이지-조회수",
            "items": []
          }
        ]
      },
      {
        "title": "3. google analytics - 등록",
        "url": "#3-google-analytics---등록",
        "items": [
          {
            "title": "3.1. 계정 생성",
            "url": "#31-계정-생성",
            "items": []
          },
          {
            "title": "3.2. 블로그 이전하기",
            "url": "#32-블로그-이전하기",
            "items": []
          },
          {
            "title": "3.3. 데이터 스트림과 태그 추가",
            "url": "#33-데이터-스트림과-태그-추가",
            "items": []
          },
          {
            "title": "3.4. 추적 코드 설정",
            "url": "#34-추적-코드-설정",
            "items": []
          }
        ]
      },
      {
        "title": "4. firebaseDB 사용해서 조회수 측정 시도",
        "url": "#4-firebasedb-사용해서-조회수-측정-시도",
        "items": [
          {
            "title": "4.1. firebase 프로젝트 생성",
            "url": "#41-firebase-프로젝트-생성",
            "items": []
          },
          {
            "title": "4.2. DB 생성",
            "url": "#42-db-생성",
            "items": []
          },
          {
            "title": "4.3. DB 연결",
            "url": "#43-db-연결",
            "items": []
          },
          {
            "title": "4.4. Cloudflare 환경 문제",
            "url": "#44-cloudflare-환경-문제",
            "items": []
          }
        ]
      },
      {
        "title": "5. supabase로 조회수 측정하기",
        "url": "#5-supabase로-조회수-측정하기",
        "items": [
          {
            "title": "5.1. 조회수 카운터 설계",
            "url": "#51-조회수-카운터-설계",
            "items": []
          },
          {
            "title": "5.2. supabase 프로젝트 생성",
            "url": "#52-supabase-프로젝트-생성",
            "items": []
          },
          {
            "title": "5.3. 조회수 가져오기",
            "url": "#53-조회수-가져오기",
            "items": []
          },
          {
            "title": "5.4. 조회수 가져오기 - 에러 상황 해결",
            "url": "#54-조회수-가져오기---에러-상황-해결",
            "items": []
          },
          {
            "title": "5.5. 조회수 집계",
            "url": "#55-조회수-집계",
            "items": []
          },
          {
            "title": "5.6. Cloudflare에서 Vercel로 다시...",
            "url": "#56-cloudflare에서-vercel로-다시",
            "items": []
          }
        ]
      },
      {
        "title": "6. Vercel로 재배포",
        "url": "#6-vercel로-재배포",
        "items": [
          {
            "title": "6.1. supabase key 등록",
            "url": "#61-supabase-key-등록",
            "items": []
          },
          {
            "title": "6.2. 파일 재작성",
            "url": "#62-파일-재작성",
            "items": []
          }
        ]
      },
      {
        "title": "7. ViewCounter 스타일",
        "url": "#7-viewcounter-스타일",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 7,
      "wordCount": 1957
    },
    "url": "/posts/blog-remake-11",
    "thumbnail": {
      "local": "/static/create-account-de20c939.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-create-account-de20c939-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAIAAAA8r+mnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAYElEQVR4nGOYO2/BkSNHnz9/8ezZs9u378ARw/Xr16dMmXLr1q1nz579+/f3PwwwPHv2bMqU6fsOHDh9+vTz5y8gop8/f2b4/PmzlY2tuISEtraOsYlZSEionZ3d7DlzAFMSRl+N8W4HAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "blog-remake-12",
    "title": "블로그 만들기 - 12. 페이지 테마, 댓글, 검색",
    "date": "2023-06-09T00:00:00Z",
    "description": "댓글 기능과 다크 테마를 달고 검색 기능을 구현하자",
    "tags": [
      "blog",
      "web"
    ],
    "html": "<h1>블로그 만들기 시리즈</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>제목</th><th>링크</th></tr></thead><tbody><tr><td>1. 기본 세팅</td><td><a href=\"https://witch.work/posts/blog-remake-1\">https://witch.work/posts/blog-remake-1</a></td></tr><tr><td>2. 메인 페이지의 HTML 설계</td><td><a href=\"https://witch.work/posts/blog-remake-2\">https://witch.work/posts/blog-remake-2</a></td></tr><tr><td>3. 글 상세 페이지의 구조 설계</td><td><a href=\"https://witch.work/posts/blog-remake-3\">https://witch.work/posts/blog-remake-3</a></td></tr><tr><td>4. 이미지를 상대 경로로 쓸 수 있도록 하기</td><td><a href=\"https://witch.work/posts/blog-remake-4\">https://witch.work/posts/blog-remake-4</a></td></tr><tr><td>5. 자잘한 페이지 구성 개선과 배포</td><td><a href=\"https://witch.work/posts/blog-remake-5\">https://witch.work/posts/blog-remake-5</a></td></tr><tr><td>6. 페이지 요소의 배치 설계</td><td><a href=\"https://witch.work/posts/blog-remake-6\">https://witch.work/posts/blog-remake-6</a></td></tr><tr><td>7. 메인 페이지 컴포넌트 디자인</td><td><a href=\"https://witch.work/posts/blog-remake-7\">https://witch.work/posts/blog-remake-7</a></td></tr><tr><td>8. 글 목록/내용 페이지 컴포넌트 디자인</td><td><a href=\"https://witch.work/posts/blog-remake-8\">https://witch.work/posts/blog-remake-8</a></td></tr><tr><td>9. 글 썸네일 자동 생성하기</td><td><a href=\"https://witch.work/posts/blog-remake-9\">https://witch.work/posts/blog-remake-9</a></td></tr><tr><td>10. 폰트, 카드 디자인 등의 디자인 개선</td><td><a href=\"https://witch.work/posts/blog-remake-10\">https://witch.work/posts/blog-remake-10</a></td></tr><tr><td>11. 글에 조회수 달기</td><td><a href=\"https://witch.work/posts/blog-remake-11\">https://witch.work/posts/blog-remake-11</a></td></tr><tr><td>12. 페이지 테마와 글 검색 기능</td><td><a href=\"https://witch.work/posts/blog-remake-12\">https://witch.work/posts/blog-remake-12</a></td></tr><tr><td>13. 테마 아이콘과 썸네일 레이아웃 개선 등</td><td><a href=\"https://witch.work/posts/blog-remake-13\">https://witch.work/posts/blog-remake-13</a></td></tr><tr><td>14. 글 분류를 태그 기반으로 변경</td><td><a href=\"https://witch.work/posts/blog-remake-14\">https://witch.work/posts/blog-remake-14</a></td></tr><tr><td>메인 페이지의 연산 최적화</td><td><a href=\"https://witch.work/posts/blog-opt-1\">https://witch.work/posts/blog-opt-1</a></td></tr><tr><td>글 목록 페이지네이션 만들기</td><td><a href=\"https://witch.work/posts/blog-opt-2\">https://witch.work/posts/blog-opt-2</a></td></tr><tr><td>이미지를 CDN에 올리고 placeholder 만들기</td><td><a href=\"https://witch.work/posts/blog-opt-3\">https://witch.work/posts/blog-opt-3</a></td></tr><tr><td>검색 페이지에 무한 스크롤 구현하기</td><td><a href=\"https://witch.work/posts/blog-opt-4\">https://witch.work/posts/blog-opt-4</a></td></tr></tbody></table>\n<h1>1. 페이지 테마(특히 다크모드)</h1>\n<p>긴 최적화의 강을 건너왔다. 내 블로그는 좀더 좋아졌을까? 좋아졌으면 좋겠다...아무튼 이제 기능 구현으로 다시 돌아가보자. 무엇이 남았는가? 당장은 페이지 테마, 댓글 기능, 검색 기능 정도가 생각이 난다. 일단 개발자의 친구 다크 모드를 구현해 보자.</p>\n<h2>1.1. 라이브러리 설치</h2>\n<p>페이지 테마를 쉽게 구현할 수 있도록 해주는 <a href=\"https://github.com/pacocoursey/next-themes\">next-themes</a>라이브러리를 사용했다. 먼저 설치한다. 30KB 정도밖에 안 되는 작은 라이브러리다.</p>\n<pre><code class=\"language-bash\">npm install next-themes\n</code></pre>\n<p>이 라이브러리에서 제공하는 <code>ThemeProvider</code> 컴포넌트로 <code>_app.tsx</code>의 모든 페이지 컴포넌트를 감싸주자. Head나 SEO 컴포넌트는 굳이 감싸줄 필요가 없다.</p>\n<pre><code class=\"language-tsx\">// src/pages/_app.tsx\nexport default function App({ Component, pageProps }: AppProps) {\n  /* Google Analytics 이벤트 발생 코드 생략 */\n  \n  return (\n    &#x3C;>\n      &#x3C;Head>\n        &#x3C;meta name='viewport' content='width=device-width, initial-scale=1' />\n        &#x3C;link rel='manifest' href='/site.webmanifest' />\n      &#x3C;/Head>\n      &#x3C;DefaultSeo {...SEOConfig} />\n      &#x3C;ThemeProvider>\n        &#x3C;Header navList={blogCategoryList} />\n        &#x3C;Component {...pageProps} />\n        &#x3C;Footer />\n      &#x3C;/ThemeProvider>\n      &#x3C;GoogleAnalytics />\n    &#x3C;/>\n  );\n}\n</code></pre>\n<h2>1.2. 토글 버튼 구현</h2>\n<p>그리고 라이트-다크모드 토글 버튼을 구현해보자. 먼저 버튼에 들어갈 그림을 그려보자. 이미지를 찾기도 귀찮기 때문에 <a href=\"https://excalidraw.com/\">excalidraw</a>에서 허접하게 그렸다.</p>\n<p><img src=\"/static/light-mode-05260881.svg\" alt=\"라이트모드 그림\"></p>\n<p><img src=\"/static/dark-mode-233c546b.svg\" alt=\"다크모드 그림\"></p>\n<p>토글 버튼은 헤더에 들어갈 것이므로 <code>src/components/header/themeChanger</code>에 작성하자. 해당 폴더를 만들고 index.tsx와 styles.module.css 생성.</p>\n<p>그리고 <a href=\"https://github.com/pacocoursey/next-themes\">next-themes github README</a>를 참고하여 themeChanger를 작성했다. 기본 system theme이 나오는 걸 회피하기 위해 그냥 <code>theme</code> 대신 <code>resolvedTheme</code>을 사용했다.</p>\n<pre><code class=\"language-tsx\">// src/components/header/themeChanger/index.tsx\nimport Image from 'next/image';\nimport { useTheme } from 'next-themes';\nimport { useEffect, useState } from 'react';\n\nimport styles from './styles.module.css';\n\nfunction ThemeIcon({isDark}: {isDark: boolean}) {\n  if (!isDark) {\n    return (\n      &#x3C;Image \n        src='/light-mode.svg'\n        alt='라이트모드 아이콘'\n        width={50}\n        height={40}\n      />\n    );\n  }\n  else {\n    return (\n      &#x3C;Image \n        src='/dark-mode.svg'\n        alt='다크모드 아이콘'\n        width={50}\n        height={40}\n      />\n    );\n  }\n}\n\nconst ThemeChanger = () => {\n  const [mounted, setMounted]=useState&#x3C;boolean>(false);\n  const { resolvedTheme, setTheme } = useTheme();\n\n  useEffect(() => {\n    setMounted(true);\n  }, []);\n\n  if (!mounted) {\n    return null;\n  }\n\n  const isDark = resolvedTheme === 'dark';\n  const toggleTheme = () => setTheme(isDark ? 'light' : 'dark');\n\n  return (\n    &#x3C;button \n      onClick={toggleTheme}\n      className={styles.button}\n      aria-label='theme toggle button'\n      aria-pressed={isDark}\n    >\n      &#x3C;ThemeIcon isDark={isDark} />\n    &#x3C;/button>\n  );\n};\n\nexport default ThemeChanger;\n</code></pre>\n<p>토글버튼 스타일링은 당장 중요한 건 아니라고 생각되어 간단히 이 정도만 했다.</p>\n<pre><code class=\"language-css\">// src/components/header/themeChanger/styles.module.css\n.button{\n  margin:0;\n  padding:0;\n  border:none;\n  background:none;\n}\n</code></pre>\n<p>그리고 이를 헤더 버튼에 넣어주었다.</p>\n<pre><code class=\"language-tsx\">// src/components/header/index.tsx\nfunction Header({\n  navList\n}: {\n  navList: PropsItem[];\n}) {\n  return (\n    &#x3C;header className={styles.header}>\n      &#x3C;nav className={styles.nav}>\n        &#x3C;div className={styles.container}>\n          &#x3C;HomeButton />\n          &#x3C;div className={styles.wrapper}>\n            &#x3C;ThemeChanger />\n            &#x3C;Menu navList={navList} />\n          &#x3C;/div>\n\n        &#x3C;/div>\n      &#x3C;/nav>\n    &#x3C;/header>\n  );\n}\n</code></pre>\n<h2>1.3. 색상 정리</h2>\n<p>이제 다크모드를 위해 global.css에서 각종 색상을 바꿔 정의하자. 이때 <code>:root</code>에 정의된 색상들은 기본 테마 색상이고 <code>[data-theme='dark']</code>에 정의된 색상은 다크테마 색상으로 들어간다. font나 레이아웃 같은 건 굳이 바꿀 필요가 없으니 넘어가자.</p>\n<p>그럼 지금 색상들은 어떻게 쓰이고 있을까? 블로그의 모든 색상들은 변수로 정의된 값들만 사용하고 있다. 이 사용처를 한번 싹 정리하고 합칠 건 합쳐서 사용하는 색을 최소화한 후 다크모드에 해당하는 색상들을 정의하자.</p>\n<p>여기 쓰이지 않은 변수명들은 어디에도 사용되지 않은 색상의 번호이다.</p>\n<p>white</p>\n<ul>\n<li>페이지네이션에서 현재 위치한 페이지 번호에 호버 시 텍스트 색상</li>\n<li>헤더와 드롭다운 메뉴의 색상</li>\n</ul>\n<p>gray1</p>\n<ul>\n<li>Card 컴포넌트 hover 시의 background</li>\n<li>메인 페이지 자기소개 background</li>\n<li>글 상세 페이지의 코드 블럭 background</li>\n<li>글 상세 페이지에서 날짜-조회수 사이의 선 색</li>\n</ul>\n<p>gray2</p>\n<ul>\n<li>footer background</li>\n<li>헤더의 버튼/링크 hover 시의 background</li>\n</ul>\n<p>gray3</p>\n<ul>\n<li>헤더의 border</li>\n</ul>\n<p>gray5</p>\n<ul>\n<li>글 상세 페이지의 heading 밑에 달리는 border</li>\n</ul>\n<p>gray6</p>\n<ul>\n<li>footer text color</li>\n<li>projectCard 컴포넌트의 그림자</li>\n</ul>\n<p>gray7</p>\n<ul>\n<li>Table of Content의 글자색</li>\n<li>글 상세 페이지의 blockquote 글자색</li>\n</ul>\n<p>indigo0</p>\n<ul>\n<li>프로젝트 소개의 기술 스택의 background</li>\n<li>글 상세 페이지에서 작은 코드 블럭의 background</li>\n</ul>\n<p>indigo1</p>\n<ul>\n<li>글 정보 중 태그를 보여주는 컴포넌트의 background</li>\n<li>페이지네이션에서 선택된 페이지 번호의 background</li>\n<li>프로젝트 소개 펼쳐보기 버튼의 background</li>\n<li>toc에서 현재 위치한 목차의 background</li>\n</ul>\n<p>indigo2</p>\n<ul>\n<li>프로젝트 소개 펼쳐보기 버튼의 hover background</li>\n<li>toc에서 현재 위치한 목차 hover시 background</li>\n</ul>\n<p>indigo5</p>\n<ul>\n<li>페이지네이션에서 선택된 페이지 번호 hover시 background\n(잘못된 선택이었다고 생각하지만 호버시 매우 진해지도록 디자인했었다)</li>\n</ul>\n<p>indigo6</p>\n<ul>\n<li>about 페이지의 링크 색상</li>\n<li>toc의 링크 호버 시 텍스트 색상</li>\n<li>프로젝트의 기술 스택을 나타내는 블록의 텍스트 색상</li>\n<li>프로젝트 카드 호버시 텍스트 색상</li>\n<li>메인 페이지 자기소개 컴포넌트의 링크 텍스트 색상</li>\n<li>글 카드 호버 시 텍스트 색상</li>\n</ul>\n<p>indigo7</p>\n<ul>\n<li>글 카드의 태그 컴포넌트의 텍스트 색상(이는 indigo6으로)</li>\n<li>글 상세 내용 페이지에서 내용 중 링크의 텍스트/밑줄 색상</li>\n</ul>\n<p>indigo8</p>\n<ul>\n<li>페이지네이션 컴포넌트에서 선택되어 있는 페이지의 텍스트 색상</li>\n<li>프로젝트 소개 펼쳐보기 버튼 텍스트 색상</li>\n<li>toc에서 현재 위치한 목차의 텍스트 색상</li>\n<li>글 상세 페이지에서 글 태그 컴포넌트의 텍스트 색상(통일 필요...)</li>\n</ul>\n<p>indigo9</p>\n<ul>\n<li>글 상세 내용 페이지에서 작은 코드 블럭의 텍스트 색상</li>\n</ul>\n<p>이들을 용도에 따라 통합하고 정리한다.</p>\n<pre><code>white -> bgColor\n\ngray1 -> bgGray\ngray2 -> bgGrayHover\ngray3 -> headerBorderColor\ngray5 -> borderGray\ngray6 -> shadowGray\ngray7 -> textGray(footer 텍스트도 이 색으로)\n\nindigo0 -> codeBlockBgColor\nindigo1 -> bgIndigo\nindigo2 -> bgIndigoHover\nindigo5 -> 용도 삭제후 indigo2로 표현\nindigo6 -> textLightIndigo\nindigo7 -> linkColor\nindigo8 -> textIndigo\nindigo9 -> codeBlockTextColor\n</code></pre>\n<p>따라서 <code>src/styles/globals.css</code>의 <code>:root</code>에 다음과 같은 CSS 변수들을 추가한다.</p>\n<pre><code class=\"language-css\">// src/styles/globals.css\n// :root 중간에 추가\n  --bgColor: #ffffff;\n  --bgGray: #f1f3f5;\n  --bgGrayHover: #e9ecef;\n  --headerBorderColor: #dee2e6;\n  --borderGray: #adb5bd;\n  --shadowGray:#868e96;\n  --textGray:#495057;\n\n  --codeBlockBgColor:#edf2ff;\n  --bgIndigo:#dbe4ff;\n  --bgIndigoHover:#bac8ff;\n  --textLightIndigo:#4c6ef5;\n  --linkColor:#4263eb;\n  --textIndigo:#3b5bdb;\n  --codeBlockTextColor:#364fc7;\n</code></pre>\n<p>그리고 기존에 grayX, indigoX들이 쓰이던 곳을 다 검색해서 위 변수들로 바꿔준다. <code>Ctrl + Shift + F</code>와 함께하면 노가다 작업일 뿐이다.</p>\n<p>이제 다크모드에 해당하는 색상들을 <code>[data-theme='dark']</code>에 정의한다. 태그의 indigo 색상은 <a href=\"https://www.color-hex.com/color-palette/2793\">color-hex의 Indigo palette 2 Color Palette</a>에서 가져왔다.</p>\n<p>각각의 색상을 정할 때는 기존 색과의 유사도보다는 가독성과, 원래 컴포넌트의 목적을 생각했다. 예를 들어서 태그나 기술 스택을 담는 블럭의 색은 너무 눈길을 끄는 게 좋지 않다고 생각하여, 눈길을 너무 끌지 않도록 배경과 매우 비슷한 느낌의 색을 택했다.</p>\n<pre><code class=\"language-css\">// src/styles/globals.css\n[data-theme='dark'] {\n  --bgColor: #212529;\n  --textColor: #ececec;\n\n  --bgGray: #343a40;\n  --bgGrayHover:#343a40;\n  --headerBorderColor:#495057;\n  --borderGray: #868e96;\n  --shadowGray:#868e96;\n  --textGray:#ced4da;\n\n  --codeBlockBgColor:#343a40;\n  --codeBlockTextColor:#edf2ff;\n  --bgIndigo:#002395;\n  --bgIndigoHover:#2b4aaf;\n  --textIndigo:#edf2ff;\n  --textLightIndigo:#748ffc;\n  --linkColor:#91a7ff;\n}\n</code></pre>\n<p>그리고 html, body의 폰트 색상과 배경 색상도 CSS 변수를 이용해서 정하도록 했다.</p>\n<pre><code class=\"language-css\">// src/styles/globals.css\nhtml, body {\n  min-height:100vh;\n  scroll-behavior: smooth;\n  background-color:var(--bgColor);\n  color:var(--textColor);\n}\n</code></pre>\n<h2>1.4. 코드 테마 변경</h2>\n<p>그런데 문제는 다크 모드로 바꿔도 코드가 여전히 라이트 테마의 색상으로 나온다는 것이다. 이는 <code>contentlayer.config.js</code>에서 rehype 플러그인이 코드를 변경할 때 옵션을 주면 된다.</p>\n<pre><code class=\"language-js\">const rehypePrettyCodeOptions = {\n  theme: {\n    light: 'github-light',\n    dark: 'github-dark',\n  },\n};\n\nexport default makeSource({\n  contentDirPath: 'posts',\n  documentTypes: [MDXPost, Post],\n  markdown: {\n    remarkPlugins: [remarkGfm, changeImageSrc, headingTree, makeThumbnail],\n    rehypePlugins: [[rehypePrettyCode, rehypePrettyCodeOptions]],\n  },\n  mdx: {\n    remarkPlugins: [remarkGfm, changeImageSrc, headingTree, makeThumbnail],\n    rehypePlugins: [[rehypePrettyCode, rehypePrettyCodeOptions], highlight],\n  },\n});\n</code></pre>\n<p>그런데 이렇게 하면 글의 코드 블럭이 2개씩 보이게 된다. 하나는 라이트 테마, 하나는 다크 테마로.</p>\n<p>이를 막기 위해서는 현재 <code>data-theme</code>과 다른 테마를 가지고 있는 pre 태그들을 DOM에서 제외시키면 된다. 다음 코드를 <code>src/styles/globals.css</code>에 추가하자.</p>\n<pre><code class=\"language-css\">[data-theme='dark'] pre[data-theme='light']{\n  display:none;\n}\n\n[data-theme='light'] pre[data-theme='dark']{\n  display:none;\n}\n/* 시스템의 테마를 따라가도록 한다 */\n@media (prefers-color-scheme: dark){\n  html {\n    data-theme:dark;\n  }\n}\n</code></pre>\n<h1>2. 커스텀 테마 만들기</h1>\n<p>나는 vscode에서 <a href=\"https://marketplace.visualstudio.com/items?itemName=mgwg.light-pink-theme\">Light Pink Theme</a>이라는 별로 인기 없는 테마를 쓰고 있다. 그러나 인기없는 이 테마라도, 블로그에 비슷하게 적용한다면 흔한 라이트/다크 테마보다는 신선하지 않을까?</p>\n<p>코드 블럭까지 커스텀하려면 길고 험한 여정이 예상되지만 한번 해보자. 색상은 <a href=\"https://yeun.github.io/open-color/#pink\">Open Color의 Pink</a>, <a href=\"https://github.com/saadeghi/daisyui/blob/master/src/theming/themes.js\">DaisyUI의 Valentine theme Color</a>그리고 <a href=\"https://github.com/mgwg/light-pink-theme/blob/master/themes/Light%20Pink-color-theme.json\">Light Pink Theme의 color JSON</a>에서 체리피킹했다.</p>\n<h2>2.1. 색상 전환 버튼 만들기</h2>\n<p>이는 실험적 기능이므로 일단 footer에 만들자. footer에 색상 전환 버튼을 넣어둔다.</p>\n<pre><code class=\"language-tsx\">// src/components/footer/index.tsx\nfunction Footer() {\n  const { setTheme } = useTheme();\n\n  const pinkTheme = () => {\n    setTheme('pink');\n  };\n\n  return (\n    &#x3C;footer className={styles.footer}>\n      &#x3C;div className={styles.container}>\n        &#x3C;div className={styles.inner}>\n          &#x3C;p className={styles.copyright}>\n          © {blogConfig.name}, Built with\n            &#x3C;Link href='https://github.com/witch-factory/witch-next-blog' target='_blank'> witch-next-blog&#x3C;/Link>, \n          2023\n          &#x3C;/p>\n          &#x3C;Link href='https://github.com/witch-factory' className={styles.github}>\n            &#x3C;Image src='/github-mark.png' alt='Github' width={32} height={32} />\n          &#x3C;/Link>\n          &#x3C;div className={styles.theme}>\n            &#x3C;p>Experimental Color Theme Changer&#x3C;/p>\n            &#x3C;button \n              className={styles.pinkTheme}\n              onClick={pinkTheme}\n            >&#x3C;/button>\n          &#x3C;/div>\n        &#x3C;/div>\n      &#x3C;/div>\n    &#x3C;/footer>\n  );\n}\n</code></pre>\n<p>그리고 footer의 스타일을 추가한다.</p>\n<pre><code class=\"language-css\">/* src/components/footer/styles.module.css */\n.theme{\n  padding-botton:20px;\n}\n\n.pinkTheme{\n  height:40px;\n  width:40px;\n  background-color:var(--pink);\n  border:none;\n  border-radius:50%;\n}\n</code></pre>\n<h2>2.2. 테마 추가</h2>\n<p>ThemeProvider에도 <code>pink</code> 테마를 추가해야 한다.</p>\n<pre><code class=\"language-tsx\">// src/pages/_app.tsx\nexport default function App({ Component, pageProps }: AppProps) {\n  /* Google Analytics 이벤트 발생 코드 생략 */\n  return (\n    &#x3C;>\n      &#x3C;Head>\n        &#x3C;meta name='viewport' content='width=device-width, initial-scale=1' />\n        &#x3C;link rel='manifest' href='/site.webmanifest' />\n      &#x3C;/Head>\n      &#x3C;DefaultSeo {...SEOConfig} />\n      {/* attribute(data-theme)가  테마에 따라 value로 바뀐다.*/}\n      &#x3C;ThemeProvider\n        defaultTheme='system'\n        enableSystem={true}\n        value={{ dark: 'dark', light: 'light', pink: 'pink' }}\n        themes={['dark', 'light', 'pink']}\n      >\n        &#x3C;Header navList={blogCategoryList} />\n        &#x3C;Component {...pageProps} />\n        &#x3C;Footer />\n      &#x3C;/ThemeProvider>\n      &#x3C;GoogleAnalytics />\n    &#x3C;/>\n  );\n}\n</code></pre>\n<p>그리고 <code>globals.css</code>에 색상 변수값들을 추가한다.</p>\n<pre><code class=\"language-css\">// src/styles/globals.css\n[data-theme='pink'] {\n  --bgColor: #f5f0f3;\n  --textColor: #632c3b;\n\n  --bgGray: #f5e3ef;\n  --bgGrayHover:#f5e3ef;\n  --headerBorderColor:#ffdeeb;\n  --borderGray: #af4670;\n  --shadowGray:#868e96;\n  --textGray:#d6336c;\n  \n  --codeBlockBgColor:#ffdeeb;\n  --codeBlockTextColor:#a61e4d;\n  --bgIndigo:#ffdeeb;\n  --bgIndigoHover:#fcc2d7;\n  --textIndigo:#c2255c;\n  --textLightIndigo:#f06595;\n  --linkColor:#d6336c;\n}\n</code></pre>\n<p><code>contentlayer.config.js</code>에서 rehype 플러그인이 코드를 변경할 때도 pink 테마에 대한 옵션을 준다.</p>\n<pre><code class=\"language-js\">// contentlayer.config.js\nconst rehypePrettyCodeOptions = {\n  theme: {\n    light: 'github-light',\n    pink: 'light-plus',\n    dark: 'github-dark',\n  },\n};\n</code></pre>\n<p>그리고 현재 <code>data-theme</code>과 다른 테마를 가지고 있는 pre 태그들을 DOM에서 제외시키는 CSS도 추가한다. 아까와 달리 <code>:not</code> 유사 클래스를 사용하자.</p>\n<pre><code class=\"language-css\">// src/styles/globals.css\n[data-theme='dark'] pre:not([data-theme='dark']){\n  display:none;\n}\n\n[data-theme='light'] pre:not([data-theme='light']){\n  display:none;\n}\n\n[data-theme='pink'] pre:not([data-theme='pink']){\n  display:none;\n}\n</code></pre>\n<p>이제 footer에 있는 <code>Experimental Color Theme Changer</code>아래의 핑크색 동그라미를 누르면 핑크 테마가 적용된다.</p>\n<p>추후에 다른 테마도 적용시켜서 여러 테마를 쓸 수 있도록 하고 싶다.</p>\n<p>하지만 어차피 CSS 변수의 색들과 코드 테마만 정의해 주면 다른 거의 모든 것들을 라이브러리에서 알아서 한다. 따라서 테마는 색에 대한 영감만 있다면 명륜진사갈비처럼 무한으로 만들 수 있으니 이건 다른 기능들을 좀 더 달고 나서 나중에 하자.</p>\n<h1>3. 댓글 기능</h1>\n<p>댓글 기능도 만들어 보자. giscus라는 라이브러리에서 해당 기능을 제공한다.</p>\n<p>github App으로 <a href=\"https://github.com/apps/giscus\">giscus</a>를 설치하자. 나는 내 블로그 레포지토리에만 설치하였다. 그리고 블로그 레포지토리의 Setting에 들어가서 <a href=\"https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/enabling-or-disabling-github-discussions-for-a-repository\">discussion을 활성화한다.</a></p>\n<p>그다음에는 <a href=\"https://giscus.app/ko\">공식 문서 가이드</a>를 따라서 하면서 적절히 내 블로그에 맞게 고치자.</p>\n<h2>3.1. giscus 정보 config</h2>\n<p>giscus에서 제공된 정보들을 blog-config.ts에 추가.</p>\n<pre><code class=\"language-ts\">interface BlogConfigType {\n  name: string;\n  title: string;\n  description: string;\n  picture: string;\n  url: string;\n  social: {\n    Github: string;\n    BOJ: string;\n  };\n  comment: {\n      type: 'giscus';\n      repo: string;\n      repoId: string;\n      category: string;\n      categoryId: string;\n      lang?: 'ko' | 'en'; // defaults to 'en'\n      lazy?: boolean;\n    };\n  thumbnail: string;\n  googleAnalyticsId?: string; // gtag id\n}\n\nconst blogConfig: BlogConfigType = {\n  name:'김성현(Sung Hyun Kim)',\n  title:'Witch-Work',\n  description:\n    '대단한 뜻을 품고 사는 사람은 아닙니다. ' +\n    '그저 멋진 사람들이 내는 빛을 따라가다 보니 여기까지 왔고, ' +\n    '앞으로도 그렇게 살 수 있었으면 좋겠다고 생각하는 사람입니다. ' +\n    '이곳에 찾아오신 당신과도 함께할 수 있어 영광입니다.',\n  picture:'/witch.jpeg',\n  url:'https://witch.work',\n  social: {\n    Github: 'https://github.com/witch-factory',\n    BOJ: 'https://www.acmicpc.net/user/city'\n  },\n  /* comment 객체를 추가한다. */\n  comment: {\n    type: 'giscus',\n    repo: 'witch-factory/witch-next-blog',\n    repoId: 'R_kgDOJnEDaQ',\n    category: 'General',\n    categoryId: 'DIC_kwDOJnEDac4CXFDt',\n  },\n  thumbnail: '/witch.jpeg',\n  googleAnalyticsId:'G-HBQKJEYL1K'\n};\n</code></pre>\n<h2>3.2. giscus 컴포넌트</h2>\n<p>댓글을 보여줄 컴포넌트를 만들자. <code>src/components/giscus/</code>폴더를 생성 후 늘 그랬듯 index.tsx를 생성한다.</p>\n<p>giscus로 메시지를 보낼 일이 많으므로 해당 동작의 함수를 만든다.</p>\n<pre><code class=\"language-tsx\">const sendMessage = (message: Record&#x3C;string, unknown>) => {\n  const iframe: HTMLIFrameElement | null = document.querySelector(\n    'iframe.giscus-frame',\n  );\n  iframe?.contentWindow?.postMessage({ giscus: message }, 'https://giscus.app');\n};\n</code></pre>\n<p>그리고 리턴되는 div 컴포넌트가 렌더링되는 시점에 useEffect를 사용하여 script 태그를 자식으로 심어서 iframe이 div 컴포넌트 안에 렌더링되도록 하는 방식으로 Giscus 컴포넌트를 구현한다.</p>\n<p>또한 테마가 바뀔 때와 페이지가 이동할 때 해당 메시지를 <code>sendMessage</code>함수를 통해 iframe으로 보내서 갱신해준다.</p>\n<pre><code class=\"language-tsx\">// src/components/giscus/index.tsx\nfunction Giscus() {\n  const ref=createRef&#x3C;HTMLDivElement>();\n  const { resolvedTheme } = useTheme();\n  const theme = resolvedTheme ?? 'dark';\n  const router = useRouter();\n\n  useEffect(() => {\n    const script = document.createElement('script');\n    if (blogConfig.comment?.type !== 'giscus') {\n      return;\n    }\n    const config = {\n      'data-repo': blogConfig.comment.repo,\n      'data-repo-id': blogConfig.comment.repoId,\n      'data-category': blogConfig.comment.category,\n      'data-category-id': blogConfig.comment.categoryId,\n      'data-mapping': 'pathname',\n      'data-strict': '0',\n      'data-reactions-enabled': '1',\n      'data-emit-metadata': '0',\n      'data-input-position': 'bottom',\n      'data-theme': theme,\n      'data-lang': blogConfig.comment.lang ?? 'en',\n      'data-loading': blogConfig.comment.lazy ? 'lazy' : undefined,\n      src: 'https://giscus.app/client.js',\n      crossOrigin: 'anonymous',\n      async: true,\n    };\n\n    Object.entries(config).forEach(([key, value]) => {\n      script.setAttribute(key, `${value}`);\n    });\n    /* 혹시 있을 자식들을 제거 */\n    ref.current?.childNodes.forEach((children) => {\n      ref.current?.removeChild(children);\n    });\n\n    ref.current?.appendChild(script);\n\n    return () => {\n      ref.current?.childNodes.forEach((children) => {\n        ref.current?.removeChild(children);\n      });\n    };\n  }, []);\n\n  useEffect(() => {\n    sendMessage({\n      setConfig: {\n        theme: theme,\n      },\n    });\n  }, [theme]);\n\n  useEffect(() => {\n    sendMessage({ setConfig: { term: router.asPath } });\n  }, [router.asPath]);\n\n  if (blogConfig.comment?.type !== 'giscus') {\n    return null;\n  }\n  return (\n    &#x3C;div className='giscus' ref={ref} />\n  );\n}\n</code></pre>\n<p>이걸 <code>src/pages/posts/[category]/[slug]/index.tsx</code>에 추가해준다. 하는 김에 글의 메타 정보를 나타내는 부분도 컴포넌트로 묶어주도록 하자.</p>\n<pre><code class=\"language-tsx\">// src/pages/posts/[category]/[slug]/index.tsx\ninterface PostMatter{\n  title: string;\n  date: string;\n  SWRfallback: {[key: string]: number};\n  slug: string;\n  tagList: string[];\n}\n\nfunction PostMatter(props: PostMatter) {\n  const {title, date, SWRfallback, slug, tagList}=props;\n  const dateObj=new Date(date);\n  return (\n    &#x3C;>\n      &#x3C;h1 className={styles.title}>{title}&#x3C;/h1>\n      &#x3C;div className={styles.infoContainer}>\n        &#x3C;time className={styles.time} dateTime={toISODate(dateObj)}>\n          {formatDate(dateObj)}\n        &#x3C;/time>\n        &#x3C;div className={styles.line}>&#x3C;/div>\n        &#x3C;SWRConfig value={SWRfallback}>\n          &#x3C;ViewCounter slug={slug} />\n        &#x3C;/SWRConfig>\n      &#x3C;/div>\n      &#x3C;ul className={styles.tagList}>\n        {tagList.map((tag: string)=>\n          &#x3C;li key={tag} className={styles.tag}>{tag}&#x3C;/li>\n        )}\n      &#x3C;/ul>\n    &#x3C;/>\n  );\n}\n\nfunction PostPage({\n  post, fallback\n}: InferGetStaticPropsType&#x3C;typeof getStaticProps>) {\n  /* SEO 정보 생략 */\n  const slug=post._raw.flattenedPath.split('/')[1];\n\n  return (\n    &#x3C;main className={styles.page}>\n      &#x3C;NextSeo {...SEOInfo} />\n      &#x3C;article className={styles.container}>\n        &#x3C;PostMatter \n          title={post.title}\n          date={post.date}\n          SWRfallback={fallback}\n          slug={slug}\n          tagList={post.tags}\n        />\n        &#x3C;TableOfContents nodes={post._raw.headingTree} />\n        {'code' in post.body?\n          &#x3C;div className={contentStyles.content}>\n            &#x3C;MDXComponent code={post.body.code}/>\n          &#x3C;/div>\n          :\n          &#x3C;div\n            className={contentStyles.content} \n            dangerouslySetInnerHTML={{ __html: post.body.html }} \n          />\n        }\n      &#x3C;/article>\n      {blogConfig.comment?.type === 'giscus'?&#x3C;Giscus />:null}\n    &#x3C;/main>\n  );\n}\n</code></pre>\n<p>각 장의 상세 페이지에 댓글이 잘 달리는 것을 확인할 수 있다.</p>\n<h1>4. 검색 기능</h1>\n<p>검색 기능을 하는 페이지를 구현하자. 검색은 다음과 같이 구현될 것이다.</p>\n<ol>\n<li>검색을 위해 전체 글을 보여주는 페이지를 만든다.</li>\n<li>마크다운 파일이 변환될 때 파일의 메타데이터를 수집한다.(remark 플러그인 활용)</li>\n<li>해당 메타데이터를 통해 검색을 수행한다.</li>\n<li>그렇게 나온 객체들만 카드 객체를 통해 화면에 보여준다.</li>\n</ol>\n<h2>4.1. 검색 페이지 만들기</h2>\n<p>일단 전체 글을 보여주는 페이지를 만들자. 예전에 남겨놓은 <code>src/pages/posts/index.tsx</code>가 유용하게 쓰일 때가 왔다.</p>\n<pre><code class=\"language-tsx\">import {\n  GetStaticProps,\n  InferGetStaticPropsType,\n} from 'next';\nimport { useRouter } from 'next/router';\n\nimport Card from '@/components/card';\nimport PageContainer from '@/components/pageContainer';\nimport { getSortedPosts } from '@/utils/post';\nimport { DocumentTypes } from 'contentlayer/generated';\n\nimport styles from './styles.module.css';\n\ninterface PostMetaData{\n  title: string;\n  description: string;\n  date: string;\n  tags: string[];\n  url: string;\n}\n\nfunction AllPostListPage({\n  category, postList,\n}: InferGetStaticPropsType&#x3C;typeof getStaticProps>) {\n  return (\n    &#x3C;PageContainer>\n      &#x3C;h2 className={styles.title}>{`${category} 검색`}&#x3C;/h2>\n      &#x3C;ul className={styles.list}>\n        {postList.map((post: PostMetaData) => \n          &#x3C;li key={post.url}>\n            &#x3C;Card {...post} />\n          &#x3C;/li>\n        )}\n      &#x3C;/ul>\n    &#x3C;/PageContainer>\n  );\n}\n\nexport default AllPostListPage;\n\nexport const getStaticProps: GetStaticProps = () => {\n  const postList = getSortedPosts().map((post: DocumentTypes) => ({\n    title: post.title,\n    description: post.description,\n    date: post.date,\n    tags: post.tags,\n    url: post.url,\n  }));\n  return { props: { category:'전체 글', postList } };\n};\n</code></pre>\n<p>그리고 간단한 검색 창을 만들자. <code>src/components/searchConsole/</code>폴더를 만들고 index.tsx와 styles.module.css를 만든다.</p>\n<pre><code class=\"language-tsx\">// src/components/searchConsole/index.tsx\nimport styles from './styles.module.css';\n\nfunction SearchConsole() {\n  return (\n    &#x3C;input\n      className={styles.input}\n      placeholder='검색어를 입력하세요'\n    />\n  );\n}\n\nexport default SearchConsole;\n</code></pre>\n<p>input의 스타일은 간단히 이 정도로 했다.</p>\n<pre><code class=\"language-css\">// src/components/searchConsole/styles.module.css\n.input{\n  width: 100%;\n  height: 2.5rem;\n  border: 1px solid var(--borderGray);\n  border-radius: 0.25rem;\n\n  margin:1rem 0;\n  padding:0.5rem 0.75rem;\n\n  color: var(--textGray);\n  font-size: 1rem;\n  background-color: var(--bgColor);\n\n  appearance: none;\n}\n</code></pre>\n<h2>4.2. 검색 기능</h2>\n<p>검색 기능의 본질은 어떤 검색어를 사용자가 입력하면 그 검색어를 기반으로 필터링한 결과를 보여주는 것이다. 따라서 검색어 데이터를 <code>src/pages/posts/index.tsx</code>의 <code>AllPostListPage</code>컴포넌트에서 가지고 있고 이를 기반으로 글들의 필터링을 하도록 하자.</p>\n<p>일단 <code>PostMetaData</code> 타입 배열을 기반으로 제목, 글 설명을 검색어 기반으로 필터링하는 함수를 만들자. <code>src/pages/posts/filterPosts.ts</code>를 작성한다.</p>\n<p>모든 키워드는 소문자로 취급하도록 한다.</p>\n<pre><code class=\"language-ts\">// src/pages/utils/filterPosts.ts\nimport { PostMetaData } from '@/components/categoryPagination';\n\nfunction filterPostsByKeyword(posts: PostMetaData[], keyword: string) {\n  if (keyword==='') return posts;\n  return posts.filter((post: PostMetaData) => {\n    const titleMatched = post.title.toLocaleLowerCase().includes(keyword.toLocaleLowerCase());\n    const descriptionMatched = post.description.toLocaleLowerCase().includes(keyword.toLocaleLowerCase());\n    return titleMatched || descriptionMatched;\n  });\n}\n\nexport default filterPostsByKeyword;\n</code></pre>\n<p>그리고 <code>SearchConsole</code> 컴포넌트가 가지고 있는 Input 값을 기반으로 검색어를 필터링하도록 하자. <code>src/components/searchConsole/index.tsx</code>를 다음과 같이 수정한다.</p>\n<p>input이 검색어 값과 현재 검색어 상태를 가지고 있을 수 있도록 props로 넘겨주는 것이다.</p>\n<pre><code class=\"language-tsx\">import { ChangeEvent } from 'react';\n\nimport styles from './styles.module.css';\n\ninterface Props{\n  value: string;\n  onChange: (event: ChangeEvent&#x3C;HTMLInputElement>) => void;\n}\n\nfunction SearchConsole(props: Props) {\n  const {value, onChange}=props;\n\n  return (\n    &#x3C;input\n      className={styles.input}\n      placeholder='검색어를 입력하세요'\n      value={value}\n      onChange={onChange}\n    />\n  );\n}\n\nexport default SearchConsole;\n</code></pre>\n<p>이를 <code>src/pages/posts/index.tsx</code>에서 사용하도록 하자. <code>searchKeyword</code> state를 만들고 <code>SearchConsole</code> 컴포넌트에 넘겨줄 <code>onKeywordChange</code>함수도 작성한다.</p>\n<pre><code class=\"language-tsx\">// src/pages/posts/index.tsx\nfunction PostSearchPage({\n  category, postList,\n}: InferGetStaticPropsType&#x3C;typeof getStaticProps>) {\n  const [searchKeyword, setSearchKeyword]=useState('');\n\n  const onKeywordChange = useCallback((event: ChangeEvent&#x3C;HTMLInputElement>) => {\n    setSearchKeyword(event.target.value);\n  }, []);\n\n  const filteredPostList = filterPostsByKeyword(postList, searchKeyword);\n\n  return (\n    &#x3C;PageContainer>\n      &#x3C;h2 className={styles.title}>{`${category} 검색`}&#x3C;/h2>\n      &#x3C;SearchConsole \n        value={searchKeyword}\n        onChange={onKeywordChange}\n      />\n      &#x3C;ul className={styles.list}>\n        {filteredPostList.map((post: PostMetaData) => \n          &#x3C;li key={post.url}>\n            &#x3C;Card {...post} />\n          &#x3C;/li>\n        )}\n      &#x3C;/ul>\n    &#x3C;/PageContainer>\n  );\n}\n</code></pre>\n<p>이렇게 하면 검색어를 입력할 때마다 <code>searchKeyword</code> state가 변경되면서 컴포넌트가 다시 렌더링되게 되고, 따라서 <code>filteredPostList</code>가 변경되어서 필터링된 결과를 보여주게 된다.</p>\n<h2>4.3. 디바운싱으로 검색 최적화</h2>\n<p>지금은 검색창의 텍스트가 바뀔 때마다 <code>PostSearchPage</code>, 즉 거의 전체 페이지가 리렌더링되도록 하고 있는데 이는 꽤 부하가 큰 작업이다. 따라서 디바운싱을 이용해서 검색창의 텍스트가 바뀔 때마다 리렌더링되는 것을 방지하도록 하자.</p>\n<p>300ms동안 입력이 없으면 검색어 입력이 완료되었거나 사용자가 잠시 멈춘 것으로 간주하고 그때 요청을 보내도록 하자. 이는 <code>searchKeyword</code> state를 커스텀 훅으로 관리함으로써 달성할 수 있다.</p>\n<p>먼저 특정 value에 대한 디바운싱 값을 쓰게 해주는 <code>useDebounce</code> 커스텀 훅을 만들자.</p>\n<pre><code class=\"language-tsx\">// src/pages/utils/useSearchKeyword.ts\nfunction useDebounce(value: string, delay: number) {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n\n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n\n    return () => clearTimeout(handler);\n  }, [value, delay]);\n\n  return debouncedValue;\n}\n</code></pre>\n<p>그다음 <code>useSearchKeyword</code>을 만들어서 검색어와 검색어의 세터, 그리고 검색어의 디바운스 값을 리턴하도록 하자. 그런데 그전에 검색어를 주소에서도 쿼리스트링으로 가지고 있게 하자. 검색 결과를 다른 사람에게 공유하고 싶을 수도 있지 않은가?</p>\n<p>가령 settimeout에 대해 검색한 결과를 <code>https://witch.work/?search=settimeout</code>와 같은 주소로 공유할 수 있다면 좋을 것이다. 이 기능을 <code>useSearchKeyword</code> 커스텀 훅 내부에 구현하자.</p>\n<p>뒤로가기를 하면 언제나 검색 초기로 돌아가도록 하기 위해 <code>onpopstate</code> 이벤트를 활용하였고 쿼리스트링 처리는 <code>debouncedKeyword</code>가 바뀔 때마다 이루어지도록 하였다. 쿼리스트링 업데이트를 위해서는 <a href=\"https://www.npmjs.com/package/query-string\">query-string</a>을 사용하였다.</p>\n<pre><code class=\"language-ts\">// src/pages/utils/useSearchKeyword.ts\nfunction useSearchKeyword(): [string, string, (s: string) => void] {\n  const [keyword, setKeyword] = useState('');\n  const debouncedKeyword = useDebounce(keyword, 300);\n\n  const onPopState = () => {\n    const parsed = queryString.parse(location.search);\n    setKeyword(parsed.keyword?.toString() || '');\n  };\n  \n  useEffect(() => {\n    const parsed = queryString.parse(location.search);\n    const {search}=parsed;\n    if (search) {\n      setKeyword(search.toString());\n    }\n    window.addEventListener('popstate', onPopState);\n\n    return () => {\n      window.removeEventListener('popstate', onPopState);\n    };\n  }, []);\n\n  useEffect(() => {\n    const parsed = queryString.parse(location.search);\n\n    if (debouncedKeyword===parsed.search) return;\n\n    parsed.search = debouncedKeyword;\n\n    const nextURL=queryString.stringifyUrl({\n      url: location.pathname,\n      query: parsed,\n    }, {\n      skipEmptyString: true,\n      skipNull: true,\n    });\n\n    history.pushState(parsed, '', nextURL);\n  }, [debouncedKeyword]);\n\n  return [keyword, debouncedKeyword, setKeyword];\n}\n</code></pre>\n<p><code>useSearchKeyword</code>을 <code>src/pages/posts/index.tsx</code>에서 사용하여 검색되도록 하자. 이때 검색어 필터링은 부하를 줄이기 위해 debouncedKeyword를 기반으로 한다.</p>\n<pre><code class=\"language-tsx\">// src/pages/posts/index.tsx\nfunction PostSearchPage({\n  category, postList,\n}: InferGetStaticPropsType&#x3C;typeof getStaticProps>) {\n  const [searchKeyword, debouncedKeyword, setSearchKeyword]=useSearchKeyword();\n\n  const onKeywordChange = useCallback((event: ChangeEvent&#x3C;HTMLInputElement>) => {\n    setSearchKeyword(event.target.value);\n  }, [setSearchKeyword]);\n\n  /* searchKeyword가 바뀔 때마다 컴포넌트가 리렌더링되지만\n  검색 결과는 debouncedKeyword 기반으로 바뀌도록 한다 */\n  const filteredPostList = filterPostsByKeyword(postList, debouncedKeyword);\n\n  return (\n    &#x3C;PageContainer>\n      &#x3C;h2 className={styles.title}>{`${category} 검색`}&#x3C;/h2>\n      &#x3C;SearchConsole \n        value={searchKeyword}\n        onChange={onKeywordChange}\n      />\n      &#x3C;ul className={styles.list}>\n        {filteredPostList.map((post: PostMetaData) => \n          &#x3C;li key={post.url}>\n            &#x3C;Card {...post} />\n          &#x3C;/li>\n        )}\n      &#x3C;/ul>\n    &#x3C;/PageContainer>\n  );\n}\n</code></pre>\n<h2>4.4. 검색 페이지 라우팅</h2>\n<p>이는 현재 <code>/posts</code>라우트에서 가능하다. 이 페이지를 헤더에서 접근할 수 있도록 하자. <a href=\"https://icons8.com/icon/set/search/ios-filled\">icons8에서 받은 ios의 검색 아이콘</a>을 사용하였다.</p>\n<p><code>src/components/header/search</code> 폴더를 만들고 내부에 다음과 같이 <code>Search</code> 컴포넌트를 작성한다.</p>\n<pre><code class=\"language-tsx\">// src/components/header/seacrh/index.tsx\n/* import 생략 */\nconst searchIcon: {[key: string]: string}={\n  'light':'/icons/icons8-search.svg',\n  'dark':'/icons/icons8-search-dark.svg',\n  'pink':'/icons/icons8-search-pink.svg',\n};\n\nconst Search = () => {\n  const { theme } = useTheme();\n\n  return (\n    &#x3C;Link href='/posts' className={styles.search}>\n      &#x3C;Image \n        src={searchIcon[theme || 'light']} \n        alt='Search' \n        width={32} \n        height={50} \n        priority\n      />\n    &#x3C;/Link> \n  );\n};\n\nexport default Search;\n</code></pre>\n<p>search 스타일은 이렇게.</p>\n<pre><code class=\"language-css\">// src/components/header/search/styles.module.css\n.search{\n  width:40px;\n  height:100%;\n  display:flex;\n  flex-direction:row;\n  justify-content:flex-end;\n  align-items:center;\n}\n</code></pre>\n<p>이를 헤더에 추가해준다. 이때 클라이언트 사이드 렌더링을 해서 테마에 맞는 아이콘을 쓰도록 하기 위해 dynamic import 사용.</p>\n<pre><code class=\"language-tsx\">/* src/components/header/index.tsx */\nconst Search = dynamic(() => import('./search'), { ssr: false });\n\ninterface PropsItem{\n  title: string;\n  url: string;\n}\n\nfunction Header({\n  navList\n}: {\n  navList: PropsItem[];\n}) {\n  return (\n    &#x3C;header className={styles.header}>\n      &#x3C;nav className={styles.nav}>\n        &#x3C;div className={styles.container}>\n          &#x3C;HomeButton />\n          &#x3C;div className={styles.wrapper}>\n            &#x3C;ThemeChanger />\n            &#x3C;Menu navList={navList} />\n            &#x3C;Search />\n          &#x3C;/div>\n        &#x3C;/div>\n      &#x3C;/nav>\n    &#x3C;/header>\n  );\n}\n</code></pre>\n<h1>참고</h1>\n<p><a href=\"https://bepyan.github.io/blog/nextjs-blog/6-comments\">https://bepyan.github.io/blog/nextjs-blog/6-comments</a></p>\n<p><a href=\"https://giscus.app/ko\">https://giscus.app/ko</a></p>\n<p><a href=\"https://github.com/pacocoursey/next-themes\">https://github.com/pacocoursey/next-themes</a></p>\n<p><a href=\"https://colorate.azurewebsites.net/Color/002395\">https://colorate.azurewebsites.net/Color/002395</a></p>\n<p>각종 색들의 팔레트 <a href=\"https://yeun.github.io/open-color/\">https://yeun.github.io/open-color/</a></p>\n<p><a href=\"https://bepyan.github.io/blog/nextjs-blog/6-comments\">https://bepyan.github.io/blog/nextjs-blog/6-comments</a></p>\n<p>daisyUI의 색들 <a href=\"https://github.com/saadeghi/daisyui/blob/master/src/theming/themes.js\">https://github.com/saadeghi/daisyui/blob/master/src/theming/themes.js</a></p>\n<p>daisyUI color 2 <a href=\"https://unpkg.com/browse/daisyui@2.0.9/src/colors/themes.js\">https://unpkg.com/browse/daisyui@2.0.9/src/colors/themes.js</a></p>\n<p>shiki의 가능한 코드 테마 <a href=\"https://github.com/shikijs/shiki/tree/main/packages/shiki/themes\">https://github.com/shikijs/shiki/tree/main/packages/shiki/themes</a></p>\n<p>vscode light pink theme의 컬러셋 <a href=\"https://github.com/mgwg/light-pink-theme/blob/master/themes/Light%20Pink-color-theme.json\">https://github.com/mgwg/light-pink-theme/blob/master/themes/Light%20Pink-color-theme.json</a></p>\n<p>next-themes 공식 문서 <a href=\"https://github.com/pacocoursey/next-themes\">https://github.com/pacocoursey/next-themes</a></p>\n<p>검색 구현하기 <a href=\"https://medium.com/frontendweb/build-the-search-functionality-in-a-static-blog-with-next-js-and-markdown-33ebc5a2214e\">https://medium.com/frontendweb/build-the-search-functionality-in-a-static-blog-with-next-js-and-markdown-33ebc5a2214e</a></p>\n<p>디바운싱 <a href=\"https://www.zerocho.com/category/JavaScript/post/59a8e9cb15ac0000182794fa\">https://www.zerocho.com/category/JavaScript/post/59a8e9cb15ac0000182794fa</a></p>\n<p>query-string <a href=\"https://www.npmjs.com/package/query-string\">https://www.npmjs.com/package/query-string</a></p>\n<p><a href=\"https://taero.blog/posts/debouncing-with-react\">https://taero.blog/posts/debouncing-with-react</a></p>\n<p><a href=\"https://dev.to/franklin030601/how-to-create-a-search-engine-with-debounce-effect-4hef#8\">https://dev.to/franklin030601/how-to-create-a-search-engine-with-debounce-effect-4hef#8</a></p>\n<p><a href=\"https://github.com/vercel/next.js/issues/10608\">https://github.com/vercel/next.js/issues/10608</a></p>",
    "excerpt": "블로그 만들기 시리즈\n|제목|링크|\n|---|---|\n|1. 기본 세팅|https://witch.work/posts/blog-remake-1|\n|2. 메인 페이지의 HTML 설계|https://witch.work/posts/blog-remake-2|\n|3. 글 상세 페이지의 구조 설계|https://witch.work/posts/blog-remake-3|\n|4. 이미지를 상대 경로로 쓸 수 있도록 하기|https://witch.work/posts/blog-rem",
    "headingTree": [
      {
        "title": "블로그 만들기 시리즈",
        "url": "#블로그-만들기-시리즈",
        "items": []
      },
      {
        "title": "1. 페이지 테마(특히 다크모드)",
        "url": "#1-페이지-테마특히-다크모드",
        "items": [
          {
            "title": "1.1. 라이브러리 설치",
            "url": "#11-라이브러리-설치",
            "items": []
          },
          {
            "title": "1.2. 토글 버튼 구현",
            "url": "#12-토글-버튼-구현",
            "items": []
          },
          {
            "title": "1.3. 색상 정리",
            "url": "#13-색상-정리",
            "items": []
          },
          {
            "title": "1.4. 코드 테마 변경",
            "url": "#14-코드-테마-변경",
            "items": []
          }
        ]
      },
      {
        "title": "2. 커스텀 테마 만들기",
        "url": "#2-커스텀-테마-만들기",
        "items": [
          {
            "title": "2.1. 색상 전환 버튼 만들기",
            "url": "#21-색상-전환-버튼-만들기",
            "items": []
          },
          {
            "title": "2.2. 테마 추가",
            "url": "#22-테마-추가",
            "items": []
          }
        ]
      },
      {
        "title": "3. 댓글 기능",
        "url": "#3-댓글-기능",
        "items": [
          {
            "title": "3.1. giscus 정보 config",
            "url": "#31-giscus-정보-config",
            "items": []
          },
          {
            "title": "3.2. giscus 컴포넌트",
            "url": "#32-giscus-컴포넌트",
            "items": []
          }
        ]
      },
      {
        "title": "4. 검색 기능",
        "url": "#4-검색-기능",
        "items": [
          {
            "title": "4.1. 검색 페이지 만들기",
            "url": "#41-검색-페이지-만들기",
            "items": []
          },
          {
            "title": "4.2. 검색 기능",
            "url": "#42-검색-기능",
            "items": []
          },
          {
            "title": "4.3. 디바운싱으로 검색 최적화",
            "url": "#43-디바운싱으로-검색-최적화",
            "items": []
          },
          {
            "title": "4.4. 검색 페이지 라우팅",
            "url": "#44-검색-페이지-라우팅",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 9,
      "wordCount": 2306
    },
    "url": "/posts/blog-remake-12",
    "thumbnail": {
      "local": "/static/light-mode-05260881.svg",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-light-mode-05260881-svg",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAICAYAAAA1BOUGAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA0klEQVR4nGP4////v+OH9vy7c+vav/Ur5/9bOm/KP5DY37+//zH8/////84tq/5XFSb9XzS7739zZeb/wrQwkPB/hp6Wyv9L5035P7Gz+L+mHMP/1BiH/7Mnt//ftWXNf4aLZ0/8Xzx30n9rQz6wpKE6A1g3SJwBpKKlOve/q43UfxUxhv+WBlz/c5MDwKaBJTesWvg/PdYFrCvQXfN/YXrE/zu3rv0HOwjkmJkTW/73tZb/v3D66P/+tqr/Xz5/Akv+u3rlAtj51YXJYC+B2CAMAHSinG11H0LzAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "blog-remake-14",
    "title": "블로그 만들기 - 14. 태그를 이용한 글 분류",
    "date": "2023-08-07T00:00:00Z",
    "description": "태그를 이용해서 글을 분류하도록 페이지를 재구축하자",
    "tags": [
      "blog"
    ],
    "html": "<h1>블로그 만들기 시리즈</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>제목</th><th>링크</th></tr></thead><tbody><tr><td>1. 기본 세팅</td><td><a href=\"https://witch.work/posts/blog-remake-1\">https://witch.work/posts/blog-remake-1</a></td></tr><tr><td>2. 메인 페이지의 HTML 설계</td><td><a href=\"https://witch.work/posts/blog-remake-2\">https://witch.work/posts/blog-remake-2</a></td></tr><tr><td>3. 글 상세 페이지의 구조 설계</td><td><a href=\"https://witch.work/posts/blog-remake-3\">https://witch.work/posts/blog-remake-3</a></td></tr><tr><td>4. 이미지를 상대 경로로 쓸 수 있도록 하기</td><td><a href=\"https://witch.work/posts/blog-remake-4\">https://witch.work/posts/blog-remake-4</a></td></tr><tr><td>5. 자잘한 페이지 구성 개선과 배포</td><td><a href=\"https://witch.work/posts/blog-remake-5\">https://witch.work/posts/blog-remake-5</a></td></tr><tr><td>6. 페이지 요소의 배치 설계</td><td><a href=\"https://witch.work/posts/blog-remake-6\">https://witch.work/posts/blog-remake-6</a></td></tr><tr><td>7. 메인 페이지 컴포넌트 디자인</td><td><a href=\"https://witch.work/posts/blog-remake-7\">https://witch.work/posts/blog-remake-7</a></td></tr><tr><td>8. 글 목록/내용 페이지 컴포넌트 디자인</td><td><a href=\"https://witch.work/posts/blog-remake-8\">https://witch.work/posts/blog-remake-8</a></td></tr><tr><td>9. 글 썸네일 자동 생성하기</td><td><a href=\"https://witch.work/posts/blog-remake-9\">https://witch.work/posts/blog-remake-9</a></td></tr><tr><td>10. 폰트, 카드 디자인 등의 디자인 개선</td><td><a href=\"https://witch.work/posts/blog-remake-10\">https://witch.work/posts/blog-remake-10</a></td></tr><tr><td>11. 글에 조회수 달기</td><td><a href=\"https://witch.work/posts/blog-remake-11\">https://witch.work/posts/blog-remake-11</a></td></tr><tr><td>12. 페이지 테마와 글 검색 기능</td><td><a href=\"https://witch.work/posts/blog-remake-12\">https://witch.work/posts/blog-remake-12</a></td></tr><tr><td>13. 테마 아이콘과 썸네일 레이아웃 개선 등</td><td><a href=\"https://witch.work/posts/blog-remake-13\">https://witch.work/posts/blog-remake-13</a></td></tr><tr><td>14. 글 분류를 태그 기반으로 변경</td><td><a href=\"https://witch.work/posts/blog-remake-14\">https://witch.work/posts/blog-remake-14</a></td></tr><tr><td>메인 페이지의 연산 최적화</td><td><a href=\"https://witch.work/posts/blog-opt-1\">https://witch.work/posts/blog-opt-1</a></td></tr><tr><td>글 목록 페이지네이션 만들기</td><td><a href=\"https://witch.work/posts/blog-opt-2\">https://witch.work/posts/blog-opt-2</a></td></tr><tr><td>이미지를 CDN에 올리고 placeholder 만들기</td><td><a href=\"https://witch.work/posts/blog-opt-3\">https://witch.work/posts/blog-opt-3</a></td></tr><tr><td>검색 페이지에 무한 스크롤 구현하기</td><td><a href=\"https://witch.work/posts/blog-opt-4\">https://witch.work/posts/blog-opt-4</a></td></tr></tbody></table>\n<h1>1. 왜 태그를 이용해 분류하게 되었는가</h1>\n<p>지금까지 기록했던 할 일들은 이런 것들이 있었다. 블로그 이미지 최적화, 소개 페이지 삽입, 게시판 제목에 링크달기, 글 썸네일 넣기, 글 목록 페이지네이션, 다크 모드, 글 시간순 정렬, 조회수 달기, TOC 자동 생성, 댓글 기능, 검색 기능, 태그 필터링, SEO 정도.</p>\n<p>이 중 태그 필터링 정도를 빼면 모두 완료한 상태이다. 태그 필터링은 검색 기능이 있는 이상 당장 필요하지는 않을 것 같다고 생각해서 미루었었다.</p>\n<p>하지만 글이 늘어나면서 내가 기존에 생각했던 CS, 개발, 기타 카테고리만으로는 글을 분류하기가 점점 어려워졌다. 개발 카테고리가 비대했던 건 어느 정도 예상했던 일이지만 이 정도로 커질 줄은 몰랐다.</p>\n<p>따라서 좀 더 글을 주제별로 분류한다고 생각되는 태그로 글들을 분류하기로 했다. 기존에도 글에 태그를 달아야 했으므로 모든 글에 이미 태그가 있었고 이를 이용하면 된다.</p>\n<h1>2. 구상</h1>\n<p>그런데 이 태그를 통한 글의 분류라는 게 막상 하려고 보니까 생각보다 할 게 많은 작업이었다.</p>\n<p>단순히 글 목록 페이지에서 글을 태그별로 볼 수 있도록 하는 거였다면 쉬웠겠지만 그 정도가 아니었기 때문이다. 그것에 맞게 사이트 구조와 몇몇 컴포넌트를 바꾸는 작업이 선행되어야 했다.</p>\n<p>현재 전체 태그는 약 15개 정도 존재하고, 예전에 붙여 놓았던 잡스러운 태그들을 제거하고 나면 10개 정도 될 것이다. 늘어날 것을 아주 넉넉히 고려해도 두 자릿수 정도에서 놀지 않을까 생각한다.</p>\n<p>하지만 지금도 10개를 넘어가는 글의 태그를 헤더에 모두 표시하면서 가시성을 챙기는 건 불가능에 가까운 일이다.</p>\n<p>따라서 현재의 폴더 기반으로 글을 분류하고 보여주고 있는데 이를 태그 기반으로 모두 바꾸는 것을 궁극적인 목적으로 하고 사이트가 어떻게 바뀌어야 할지 구상해 보았다.</p>\n<p>이렇게 할 시 내가 태그를 좀 신경써서 써야 하는 것은 여전하지만 원하면 태그를 쉽게 새로 만들기만 하면 된다는 점에서 더 유연해진다고 생각한다.</p>\n<p>지금은 메인 페이지에서 폴더별로 글을 분류하고 폴더마다 있는 글들을 시간순으로 정렬해서 보여주고 있다. 이를 현재 글이 들어 있는 폴더를 기반으로 하는 게 아니라 태그를 기반으로 하는 것으로 바꿔야 한다. 전체 구상은 다음과 같이 해보았다.</p>\n<p><img src=\"/static/page-structure-898b0338.png\" alt=\"블로그 개편 구조\"></p>\n<h2>2.1. 폐기된 구상</h2>\n<p>처음에는 검색 페이지와 태그 필터링 페이지를 합쳐서 하나로 만들까 생각했다. 검색어와 태그를 기반으로 필터링한 포스트만 보여주는 것이다. <a href=\"https://gatsby-starter-lavender.vercel.app/\">gatsby-starter-lavender</a>에서 이런 필터링을 사용한다.</p>\n<p>하지만 이렇게 하지 않은 이유는 다음과 같다.</p>\n<p>첫번째로 구현 난이도와 성능에서 차이를 보인다는 것이다. 태그와 검색어를 통한 필터링을 한 페이지에서 구현할 시 필터링된 결과의 페이지네이션을 미리 생성해 놓을 수 없다.</p>\n<p>따라서 페이지번호와 검색어를 쿼리스트링으로 관리하여 해당 쿼리 값을 기반으로 필터링된 결과를 검색 결과로써 보여줘야 한다. <code>/tag?search=검색어&#x26;page=2</code>와 같이 말이다.</p>\n<p>하지만 이렇게 하면 매번 검색어를 입력할 때마다 다음 과정을 거쳐야 한다.</p>\n<pre><code>전체 글에서 검색어에 맞는 글 필터링 -> 해당 글을 페이지로 분할해서 나온 결과를 화면에 뿌려주기\n</code></pre>\n<p>이는 글 분류와 페이지 번호로 정적으로 생성된 페이지(<code>/[tag]/[page]</code>와 같은 URL을 통해서)를 보여주는 것보다 성능이 떨어질 수밖에 없다.</p>\n<p>두번째로 검색과 태그를 통한 필터링 그리고 페이지네이션의 조합이 UX에서 별로 좋지 않다고 보인다는 것이다. 내가 현재 구현하고 있는 검색은 사용자의 검색창 입력이 바뀔 때마다 검색 결과를 업데이트해주는 방식이다. 실제로는 완전히 실시간은 아니고 디바운싱 최적화를 적용하지만.</p>\n<p>이렇게 하면 사용자가 검색어를 입력한 후 특별한 행동을 취하지 않아도 알아서 검색 결과를 보여주므로 사용자와의 상호작용이 줄어들어서 좋다.</p>\n<p>하지만 이런 실시간 검색을 통한 필터링과 페이지네이션이 그렇게 궁합이 좋지 않다. 예를 들어서 <code>A</code>라는 검색어가 타이핑되었을 때 100개의 포스트가 검색되어 10페이지가 생겼고 사용자가 9페이지로 이동했는데(<code>?search=A&#x26;page=9</code>), 이 상태에서 <code>B</code>를 검색어에 추가로 타이핑하니까 검색 결과가 25개밖에 안 된다.</p>\n<p>그러면 <code>AB</code>를 검색한 결과의 9페이지에서는 뭘 보여줘야 하는가? 검색 결과가 없다고 보여주기? 아니면 검색어를 초기화 해버리기? 혹은 현재 검색결과의 마지막 페이지로 이동? 무엇이든 할 수는 있겠지만 어떤 것을 해도 현재 URL이 바뀌고 페이지 번호도 바뀌어서 사용자가 혼란스러울 것이다.</p>\n<p>기존의 검색 페이지처럼 무한 스크롤을 이용해서 검색 결과를 보여준다면 좋겠지만 사용자가 페이지를 제어하고 있다는 느낌을 주는 페이지네이션의 이점을 포기할 수 없었다.</p>\n<p>또한 내가 UX디자인에 뭔가 전문성이 있는 것도 아니기 때문에 실시간 검색, 태그 필터링, 페이지네이션의 장점들을 취한 새로운 방식을 만들어내기는 어렵다고 생각했다. 따라서 위의 방식으로 페이지 라우트를 설계하기로 했다.</p>\n<h2>2.2. 페이지 구조</h2>\n<p>현재는 <code>/posts/[category]</code>가 각 글 분류의 목록을 보여주는 페이지이고 <code>/posts/[category]/[slug]</code>가 각 글의 상세 페이지이다. 그리고 <code>/posts/[category]/page/[page]</code>가 각 글 분류에서 2이상의 페이지 번호를 가진 페이지를 보여주는 페이지이다.</p>\n<p>먼저 복수 태그가 허용되는 것을 생각하면 <code>/posts/[tag]/[slug]</code>와 같은 URL을 갖도록 하는 것은 좋지 않다. 현재의 URL 작명 방식을 생각해 볼 때 서로 다른 태그를 가진 중복된 폴더명이 있을 가능성은 적으므로 글 상세 페이지의 경우 <code>/posts/[slug]</code> 경로를 가지도록 하겠다.</p>\n<p>그리고 페이지네이션을 만들 때 <code>/posts/[category]/page/[page]</code>와 같은 URL을 갖게 한 것은 중간에 <code>page</code>라는 단계가 있으면 좋겠어서가 아니었다.</p>\n<p><code>posts/[category]/[page]</code>와 같이 동적 URL을 구성하게 되면 글의 상세 페이지(<code>posts/[category]/[slug]</code>)와 같은 형식의 동적 URL을 갖게 되기 때문이었다. 이렇게 2가지의 동적 라우터가 있는 건 권장되지 않는 패턴이기 때문에 어쩔 수 없이 중간에 <code>page</code>를 한번 넣은 것이다.</p>\n<p>하지만 태그 기반으로 글을 분류하는 페이지 구조에서는 이런 동적 라우트의 중복이 일어나지 않으므로 2페이지 이상의 페이지를 가질 경우 <code>/posts/tag/[tag]/[page]</code>와 같은 동적 URL을 갖도록 하겠다. 모든 글을 보여주는 페이지는 <code>/all</code>라우트를 따로 만들어서 <code>/posts/all</code>과 <code>/posts/all/[page]</code>가 될 것이다.</p>\n<p>따라서 <code>src/pages/posts</code>내부는 다음과 같은 폴더 구조를 가지도록 설계하였다.</p>\n<pre><code>posts\n├── all\n│   └── [page]\n│   │   └── index.tsx\n│   └── index.tsx\n├── tag\n│   ├── [tag]\n│   │   ├── [page]\n│   │   │   └── index.tsx\n│   │   └── index.tsx\n├── [slug]\n│   └── index.tsx\n└── index.tsx(글 검색 페이지)\n</code></pre>\n<h1>3. 글 추출하기</h1>\n<h2>3.1. 전체 글을 페이지로 분류</h2>\n<p>이전에는 전체 글에 대한 페이지네이션이 없었다. 전체 글을 볼 수 있는 건 검색 페이지뿐이었고 카테고리별 페이지네이션밖에 없었다. 따라서 전체 글을 페이지별로 추출하는 함수를 따로 만들도록 하자. <code>src/utils/post.ts</code>를 편집한다.</p>\n<p>기존에 있던 페이지별 글 추출 함수를 거의 그대로 이용하면 된다.</p>\n<pre><code class=\"language-js\">// src/utils/post.ts\ninterface Page{\n  currentPage: number;\n  postsPerPage: number;\n}\n\nexport const getPostsByPage = (page: Page) => {\n  const { currentPage, postsPerPage } = page;\n  const pagenatedPosts=getSortedPosts().slice(\n    (currentPage-1)*postsPerPage,\n    currentPage*postsPerPage\n  );\n  return {pagePosts:pagenatedPosts, totalPostNumber: allDocuments.length};\n};\n</code></pre>\n<h2>3.2. 태그별 글을 페이지로 분류</h2>\n<p>각 글의 태그는 <code>contentlayer/generated</code>에 들어 있는 <code>allDocument</code>의 원소로 있는 각 문서들에 <code>post.tags</code> 배열로 존재한다. 따라서 이들을 모두 뽑아내자.</p>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Set\">JS의 Set 객체는 원소의 삽입 순서대로 순회할 수 있으므로</a> 날짜 순대로 정렬된 <code>getSortedPosts</code>에서 태그들을 뽑아내면 가장 최근에 글이 쓰여진 태그부터 순서대로 나오게 된다.</p>\n<p>글들의 모든 태그를 뽑아내는 함수를 넣기 위해 <code>src/utils/postTags.ts</code>를 만들고 함수를 작성한다.</p>\n<pre><code class=\"language-js\">// src/utils/postTags.ts\nexport const getAllPostTags = (): string[] => {\n  const allTags=new Set&#x3C;string>();\n  getSortedPosts().forEach((post: DocumentTypes)=>{\n    post.tags.forEach((tag: string)=>{\n      allTags.add(tag);\n    });\n  });\n  return Array.from(allTags);\n};\n</code></pre>\n<p>이번에는 태그를 기반으로 해당 태그를 가진 글을 뽑아내는 함수를 만들자. 기존의 <code>getCategoryPosts</code>는 다음과 같이 동작하였다. 딱 필요한 페이지만큼의 글을 불러오기 위한 <code>PageInfo</code>정보가 제공되었다.</p>\n<pre><code class=\"language-js\">// src/utils/posts.ts\n// 기존에 쓰이던 함수\ninterface PageInfo{\n  category: string;\n  currentPage: number;\n  postsPerPage: number;\n}\n\nexport const getCategoryPosts = (info: PageInfo) => {\n  const { category, currentPage, postsPerPage } = info;\n  const allDocumentsInCategory = getSortedPosts().filter((post: DocumentTypes)=>\n    post._raw.flattenedPath.startsWith(category));\n\n  const pagenatedPosts= allDocumentsInCategory.slice(\n    (currentPage-1)*postsPerPage, \n    currentPage*postsPerPage\n  );\n\n  return {pagePosts:pagenatedPosts, totalPostNumber: allDocumentsInCategory.length};\n};\n</code></pre>\n<p>이를 기반으로 비슷한 <code>getPostsByPageAndTag</code>를 만들자. 이 역시 태그에 해당하는 글들을 페이지로 분류해야 할 것은 마찬가지이므로 요구되는 정보는 똑같다.</p>\n<pre><code class=\"language-js\">// src/utils/post.ts\ninterface TagPage{\n  tag: string;\n  currentPage: number;\n  postsPerPage: number;\n}\n\nexport const getPostsByPageAndTag = (tagPage: TagPage) => {\n  const { tag, currentPage, postsPerPage } = tagPage;\n  const tagPosts=getSortedPosts().filter((post: DocumentTypes)=>post.tags.includes(tag));\n  const pagenatedPosts= tagPosts.slice(\n    (currentPage-1)*postsPerPage,\n    currentPage*postsPerPage\n  );\n  return {pagePosts:pagenatedPosts, totalPostNumber: tagPosts.length};\n};\n</code></pre>\n<h1>4. 페이지 구조 만들기</h1>\n<p>앞서 만들었던 페이지 폴더 구조가 실제로 작동하도록 해보자. 먼저 모든 글들을 <code>posts/cs</code> 와 같이 분류하는 폴더 내부가 아니라 <code>posts</code>로 옮긴다.</p>\n<h2>4.1. 태그별 페이지 구성하기</h2>\n<p>먼저 태그별로 글을 분류해 놓은 페이지를 구성하자. <code>src/pages/posts/tag/[tag]/index.tsx</code>를 편집하자.</p>\n<p>모든 태그를 가져오는 <code>getAllPostTags</code>를 이용해서 가능한 모든 태그들의 경로를 제공한다.</p>\n<pre><code class=\"language-tsx\">// src/pages/posts/tag/[tag]/index.tsx\nexport const getStaticPaths: GetStaticPaths=()=>{\n  const paths=getAllPostTags().map((tag)=>{\n    return {\n      params: { tag },\n    };\n  });\n  return {\n    paths,\n    fallback: false,\n  };\n};\n</code></pre>\n<p>그리고 이렇게 만들어진 path를 기반으로 <code>getPostsByPageAndTag</code>를 이용해서 해당 태그를 가진 글들을 가져오는 <code>getStaticProps</code>를 만들자. 기존에 있던 해당 함수에서 태그를 기반으로 하는 것을 감안해 변수명과 링크만 좀 바꾸면 된다.</p>\n<pre><code class=\"language-tsx\">// src/pages/posts/tag/[tag]/index.tsx\nexport const getStaticProps: GetStaticProps = async ({params}) => {\n  const {pagePosts, totalPostNumber} = await getPostsByPageAndTag({\n    tag:params?.tag as string,\n    currentPage:FIRST_PAGE,\n    postsPerPage:ITEMS_PER_PAGE\n  });\n\n  const pagePostsWithThumbnail=pagePosts.map((post: DocumentTypes) => {\n    const { title, description, date, tags, url } = post;\n    const metadata={title, description, date, tags, url};\n    return 'thumbnail' in post._raw ? \n      ({...metadata, thumbnail: post._raw.thumbnail} as CardProps) :\n      metadata;\n  });\n\n  return {\n    props: {\n      tag:params?.tag,\n      tagURL:`/posts/tag/${params?.tag}`,\n      pagePosts:pagePostsWithThumbnail,\n      totalPostNumber,\n      currentPage:FIRST_PAGE,\n    },\n    revalidate: 60 * 60 * 24, // &#x3C;--- ISR cache: once a day\n  };\n};\n</code></pre>\n<p>페이지 컴포넌트는 이렇게 생성된 <code>tag</code>, <code>tagURL</code>을 사용하도록 변경한다.</p>\n<pre><code class=\"language-tsx\">// src/pages/posts/tag/[tag]/index.tsx\nfunction PostListPage({\n  tag,\n  tagURL,\n  pagePosts,\n  totalPostNumber,\n  currentPage,\n}: InferGetStaticPropsType&#x3C;typeof getStaticProps>) {\n  /* SEO 정보 */\n  const SEOInfo: NextSeoProps={\n    title: `${tag} 태그를 가진 글`,\n    description: `${tag} 태그를 가진 글들을 모아서 보여주는 페이지`,\n    canonical:`${blogConfig.url}${tagURL}`,\n    openGraph:{\n      title: `${tag} 태그의 글`,\n      description: `${tag} 태그를 가진 글들을 모아서 보여주는 페이지`,\n      images: [\n        {\n          url:`${blogConfig.url}${blogConfig.thumbnail}`,\n          alt: `${blogConfig.name} 프로필 사진`,\n        },\n      ],\n      url:`${blogConfig.url}${tagURL}`,\n    },\n  };\n\n  return (\n    &#x3C;>\n      &#x3C;NextSeo {...SEOInfo} />\n      &#x3C;PageContainer>\n        &#x3C;Title title={`tag : ${tag}`} />\n        &#x3C;Pagination\n          totalItemNumber={totalPostNumber}\n          currentPage={currentPage}\n          renderPageLink={(page: number) => `${tagURL}/${page}`}\n          perPage={ITEMS_PER_PAGE}\n        />\n        &#x3C;PostList postList={pagePosts} />\n      &#x3C;/PageContainer>\n    &#x3C;/>\n  );\n}\n</code></pre>\n<p>이제 2페이지 이상의 페이지를 담당하는 파일을 편집하자. <code>src/pages/posts/tag/[tag]/[page]/index.tsx</code>를 본다. 일단 <code>getStaticPaths</code>에서 태그별로 페이지들을 생성하도록 바꿔야 한다. ISR을 이용하는 기존의 코드를 그대로 가져와서 태그를 기반으로 하도록 바꾸기만 했다.</p>\n<pre><code class=\"language-tsx\">// src/pages/posts/tag/[tag]/[page]/index.tsx\nexport const getStaticPaths: GetStaticPaths = async () => {\n  const paths=[];\n\n  const tags=getAllPostTags();\n\n  for (const tag of tags) {\n    // Prerender the next 5 pages after the first page, which is handled by the index page.\n    // Other pages will be prerendered at runtime.\n    for (let i=0;i&#x3C;5;i++) {\n      paths.push(`/posts/tag/${tag}/${i+2}`);\n    }\n  }\n\n  return {\n    paths,\n    // Block the request for non-generated pages and cache them in the background\n    fallback: 'blocking',\n  };\n};\n</code></pre>\n<p>그리고 <code>getStaticProps</code>에서는 이렇게 만들어진 페이지들을 기반으로 해당 페이지에 들어갈 글들을 가져오도록 한다. 기존 코드를 약간만 변경했다. <code>blogCategoryList</code>에서 해당 카테고리의 제목과 URL을 찾는 과정이 없어져서 조금은 간단해졌다.</p>\n<pre><code class=\"language-tsx\">// src/pages/posts/tag/[tag]/[page]/index.tsx\nexport const getStaticProps: GetStaticProps = async ({\n  params,\n}: GetStaticPropsContext) => {\n  const page: number = Number(params?.page) || 1;\n  const {pagePosts, totalPostNumber} = await getPostsByPageAndTag({\n    tag:params?.tag as string,\n    currentPage:page,\n    postsPerPage:ITEMS_PER_PAGE\n  });\n\n  const pagePostsWithThumbnail=pagePosts.map((post: DocumentTypes) => {\n    const { title, description, date, tags, url } = post;\n    const metadata={title, description, date, tags, url};\n    return 'thumbnail' in post._raw ? \n      ({...metadata, thumbnail: post._raw.thumbnail} as CardProps) :\n      metadata;\n  });\n\n  if (!pagePostsWithThumbnail.length) {\n    return {\n      notFound: true,\n    };\n  }\n  \n  if (page===1) {\n    return {\n      redirect: {\n        destination: `/posts/tag/${params?.tag}`,\n        permanent: false,\n      },\n    };\n  }\n\n  return {\n    props: {\n      tag:params?.tag,\n      tagURL:`/posts/tag/${params?.tag}`,\n      pagePosts:pagePostsWithThumbnail,\n      totalPostNumber,\n      currentPage:page,\n    },\n    revalidate: 60 * 60 * 24, // &#x3C;--- ISR cache: once a day\n  };\n};\n</code></pre>\n<p>역시 페이지 컴포넌트는 아까와 같이 <code>tag</code>, <code>tagURL</code>을 사용하도록 변경한다.</p>\n<h2>4.2. 전체 글 페이지</h2>\n<p>태그 분류 페이지를 생각해 보면 모든 글을 보여주는 페이지도 있는 게 정상이다. <a href=\"https://jbee.io/\">Jbee님의 블로그</a>나 <a href=\"https://gatsby-starter-lavender.vercel.app/\">gatsby-starter-lavender</a>와 같은 여러 블로그 템플릿에서 <code>All</code> 태그 분류를 넣어주고 있다.</p>\n<p>이를 담당하는 페이지는 동적 라우트 대신 명시적으로 만든 <code>posts/all</code>과 <code>posts/all/[page]</code>이다. 전체 글은 태그를 통한 분류가 아니기 때문에 <code>/tag</code> 가 URL에 붙는 게 적절하지 않다고 생각했다. 동적 라우트 중복을 막기 위해서도 이편이 더 낫다. 단 글을 쓸 때 <code>all</code>이라는 URL 경로를 생성하지 않도록 주의해야 한다.</p>\n<p>먼저 <code>src/pages/posts/all/index.tsx</code>를 만들자. 앞서 만들었던 태그 페이지와 거의 비슷하다. 다음과 같이 <code>getStaticProps</code>를 작성하고 컴포넌트를 적당히 만들면 된다.</p>\n<pre><code class=\"language-tsx\">// src/pages/posts/tag/all/index.tsx\nexport const getStaticProps: GetStaticProps = async () => {\n  const currentPage: number = FIRST_PAGE;\n  const postsPerPage: number = ITEMS_PER_PAGE;\n\n  const {pagePosts, totalPostNumber}=await getPostsByPage({\n    currentPage,\n    postsPerPage,\n  });\n\n  const pagePostsWithThumbnail=pagePosts.map((post: DocumentTypes) => {\n    const { title, description, date, tags, url } = post;\n    const metadata={title, description, date, tags, url};\n    return 'thumbnail' in post._raw ? \n      ({...metadata, thumbnail: post._raw.thumbnail} as CardProps) :\n      metadata;\n  });\n\n  return {\n    props: {\n      tag:'All',\n      tagURL:'/posts/tag/all',\n      pagePosts:pagePostsWithThumbnail,\n      totalPostNumber,\n      currentPage:FIRST_PAGE,\n    },\n    revalidate: 60 * 60 * 24, // &#x3C;--- ISR cache: once a day\n  };\n};\n</code></pre>\n<p>상세 페이지의 <code>getStaticProps</code>는 이렇게. 페이지가 1일 때는 <code>/posts/tag/all</code>로 리다이렉트하도록 한 것과 없는 페이지가 not found가 되도록 하는 처리가 추가적으로 들어갔다. 나머지 컴포넌트 구조는 같다.</p>\n<pre><code class=\"language-tsx\">export const getStaticProps: GetStaticProps = async ({\n  params,\n}: GetStaticPropsContext) => {\n  const page: number = Number(params?.page) || 1;\n\n  const currentPage: number = page;\n  const postsPerPage: number = ITEMS_PER_PAGE;\n\n  const {pagePosts, totalPostNumber}=await getPostsByPage({\n    currentPage,\n    postsPerPage,\n  });\n\n  const pagePostsWithThumbnail=pagePosts.map((post: DocumentTypes) => {\n    const { title, description, date, tags, url } = post;\n    const metadata={title, description, date, tags, url};\n    return 'thumbnail' in post._raw ? \n      ({...metadata, thumbnail: post._raw.thumbnail} as CardProps) :\n      metadata;\n  });\n\n  if (!pagePostsWithThumbnail.length) {\n    return {\n      notFound: true,\n    };\n  }\n  \n  if (page===1) {\n    return {\n      redirect: {\n        destination: '/posts/tag/all',\n        permanent: false,\n      },\n    };\n  }\n\n  return {\n    props: {\n      tag:'All',\n      tagURL:'/posts/tag/all',\n      pagePosts:pagePostsWithThumbnail,\n      totalPostNumber,\n      currentPage:page,\n    },\n    revalidate: 60 * 60 * 24, // &#x3C;--- ISR cache: once a day\n  };\n};\n</code></pre>\n<h2>4.3. 글 상세 페이지</h2>\n<p>기존의 <code>src/pages/posts/[category]/[slug]/index.tsx</code>를 <code>src/pages/posts/[slug]/index.tsx</code>로 만들었다. 이제 이를 기반으로 글 상세 페이지를 만들자.</p>\n<p><code>getStaticPaths</code>에서는 모든 글들의 경로를 만들어야 한다. 이제 모든 글들이 <code>/posts</code> 폴더 안에 바로 존재하므로 그냥 <code>post._raw.flattenedPath</code>를 slug path로 사용하면 된다.</p>\n<pre><code class=\"language-tsx\">// src/pages/posts/[slug]/index.tsx\nexport const getStaticPaths: GetStaticPaths = () => {\n  const paths = getSortedPosts().map((post: DocumentTypes)=>{\n    return {\n      params: {\n        slug: post._raw.flattenedPath\n      },\n    };\n  });\n  return {\n    paths,\n    fallback: false,\n  };\n};\n</code></pre>\n<p><code>getStaticProps</code>는 이를 이용해서 해당 글의 정보를 가져오도록 한다. 기존의 코드를 약간만 바꾸면 된다.</p>\n<pre><code class=\"language-tsx\">export const getStaticProps: GetStaticProps= async ({params})=>{\n  const post = getSortedPosts().find(\n    (p: DocumentTypes) => {\n      return p._raw.flattenedPath === params?.slug;\n    }\n  )!;\n\n  const URL=`/api/view?slug=${params?.slug}`;\n  const fallbackData=await fetchViewCount(params?.slug);\n  return {\n    props: {\n      post,\n      fallback:{\n        [URL]: fallbackData,\n      }\n    },\n  };\n};\n</code></pre>\n<h2>4.4. 메인 페이지</h2>\n<p>메인 페이지에서는 최근에 올라온 글을 9개만 보여주도록 하자. 3개짜리 글 3줄. 나쁘지 않다.</p>\n<pre><code class=\"language-tsx\">// src/pages/index.tsx\nexport default function Home({\n  categoryPosts\n}: InferGetStaticPropsType&#x3C;typeof getStaticProps>) {\n\n  return (\n    &#x3C;PageContainer>\n      &#x3C;Profile />\n      &#x3C;ProjectList />\n      &#x3C;Category {...categoryPosts} />\n    &#x3C;/PageContainer>\n  );\n}\n\nexport const getStaticProps: GetStaticProps = async () => {\n  await generateRssFeed();\n\n  const title='최근에 작성한 글';\n  const url='/posts';\n\n  const categoryPosts: CategoryProps={\n    title,\n    url,\n    items: getSortedPosts().slice(0, 9).map((post: DocumentTypes)=>{\n      return propsProperty(post);\n    })\n  };\n\n  return { props: { categoryPosts } };\n};\n</code></pre>\n<h1>5. 다른 수정사항</h1>\n<h2>5.1. 헤더 수정</h2>\n<p>폴더 기준으로 구분되어 있던 헤더의 구성을 바꾸자. <code>/posts/all</code>페이지와 검색 페이지, <code>/about</code> 만 남기면 될 것 같다. 원래는 이것들도 아이콘으로 하려고 했는데 굳이 그럴 거 없을 거 같다. 참고로 글 목록 페이지에는 모두 태그를 통해서 다른 태그 분류 페이지로 이동할 수 있는 기능을 넣을 예정이기 때문에 <code>/posts/all</code>만 넣어도 상관없다.</p>\n<p>현재 헤더는 <code>navList</code>를 props로 받아서 해당 메뉴들을 내비게이션 바로 표시해 주는 방식이므로 이를 담당하고 있는 <code>/blog-category.ts</code>를 수정하면 된다.</p>\n<pre><code class=\"language-ts\">// blog-category.ts\ninterface Category{\n  title: string;\n  url: string;\n}\n\nconst blogCategoryList: Category[] = [\n  {title:'글목록', url:'/posts/all'},\n  {title:'소개', url:'/about'},\n];\n\nexport default blogCategoryList;\n</code></pre>\n<h2>5.2. 태그를 통한 필터링</h2>\n<p>글을 태그 기반으로 분류하면서 글의 분류가 훨씬 더 늘어났다. 줄이려면 좀 줄이겠지만 그렇게 하더라도 CS, 개발, 기타 뿐이었던 3종류보다는 많을 것이다. 이것은 더 이상 헤더에 모든 글 분류를 나열하기 힘들어졌다는 것이다.</p>\n<p>물론 메뉴를 더 계층화하여 분류할 수도 있다. 하지만 그렇게까지 빡빡하게 분류해야 한다면 태그 시스템을 쓰는 의미가 별로 없다고 생각한다. 따라서 위의 헤더 수정 파트에서도 글 목록 페이지에 <code>/posts/all</code> 하나만 넣은 이유를 설명하면서 이야기했지만 글 목록 페이지에서 태그를 통해서 다른 글 분류 페이지로 이동할 수 있도록 하겠다.</p>\n<p>원래는 메뉴 버튼을 누르면 드롭다운 메뉴가 나오고 그곳에서 태그를 선택하여 해당 태그에 대한 페이지로 가는 방식도 고려했다.</p>\n<p>하지만 그렇게 하면 UI를 생각했을 때 사용자가 글 목록을 보기 위해서 상호작용을 한번 더 해야 하고 접근성 관점에서 생각해 봤을 때도 글 분류에 접근하는 방식이 드롭다운이라면 스크린 리더가 제대로 읽지 못할 거라 생각했다.</p>\n<p>따라서 글을 보는 페이지에서 태그별 글 분류 페이지로 이동하는 링크가 보이도록 한다. 완성시 다음과 같은 모습이 된다.</p>\n<p><img src=\"/static/tagfilter-design-60df3dfc.png\" alt=\"태그 필터 완성시 모습\"></p>\n<p>하지만 엄청나게 훌륭한 디자인인 것도 아니고(나는 디자이너가 아니니까...) CSS를 하나하나 설명할 필요는 없을 것 같아서 핵심 로직만 코드로 남긴다.</p>\n<h3>5.2.1. URL 변환 함수</h3>\n<p>태그는 <code>getAllPostTag</code>로 가져와서 전달할 게 뻔하므로, 태그명을 받아서 URL로 변환하는 함수가 필요하다. 태그 분류별로 페이지가 동적 라우터로 생성되었기 때문에, 각 태그에 대한 동적 라우트 경로로 이동할 수 있는 링크 주소를 생성할 수 있어야 하기 때문이다.</p>\n<p>따라서 다음과 같이 <code>src/utils/postTags.ts</code>에 태그명을 받아서 태그 분류 페이지에 대한 URL 링크로 변환하는 함수를 만든다. <code>All</code>의 경우 모든 글을 보여줄 특별한 태그명이며 향해야 할 링크도 다르기 때문에 따로 처리해 준다.</p>\n<pre><code class=\"language-ts\">export const makeTagURL=(tag: string): string=>{\n  if (tag==='All') {\n    return '/posts/all';\n  }\n  else {\n    return `/posts/tag/${tag}`;\n  }\n};\n</code></pre>\n<h3>5.2.2. 컴포넌트 제작</h3>\n<p>그리고 <code>src/components/tagFilter/index.tsx</code>에 태그 필터를 위한 컴포넌트를 만들자. 이 컴포넌트는 무엇을 받아야 할까? 이 컴포넌트에서 자체적으로 결정할 수 없는 요소는 무엇인가?</p>\n<p>먼저 전체 태그명을 받아야 한다. 사실 이건 이 컴포넌트에서 자체적으로 만들어 줄 수 있지만, 어차피 이는 상수이므로 따로 <code>src/utils/postTags.ts</code>에 <code>All</code>을 포함한 전체 태그 목록을 넣어 놓고 <code>TagFilter</code>컴포넌트에 props로 전달할 것이다.</p>\n<pre><code class=\"language-ts\">export const tagList: string[]=['All', ...getAllPostTags(),];\n</code></pre>\n<p>현재 선택된 태그는 URL을 통해 명시될 것이므로 컴포넌트에서는 알 수 없다. 따라서 props로 받아야 한다. 그리고 태그를 클릭하면 해당 태그에 대한 페이지로 이동해야 하는데 그 페이지 URL을 만들어 주는 함수도 props로 받아야 한다. 위에서 <code>makeTagURL</code>함수를 이미 제작한 바 있다.</p>\n<p>따라서 <code>TagFilter</code>컴포넌트는 다음과 같이 만들어질 수 있다.</p>\n<pre><code class=\"language-tsx\">interface Props{\n  tags: string[];\n  selectedTag: string;\n  makeTagURL: (tag: string) => string;\n}\n\nfunction TagFilter(props: Props) {\n  const {tags, selectedTag, makeTagURL} = props;\n\n  return (\n    &#x3C;section className={styles.container}>\n      &#x3C;Title title={'태그 목록'} />\n      &#x3C;ul className={styles.tagList}>\n        {tags.map((tag) => {\n          return (\n            &#x3C;li\n              key={tag} \n              className={tag===selectedTag ? styles.selectedTagItem : styles.tagItem}\n            >\n              &#x3C;Link\n                href={makeTagURL(tag)} \n                className={styles.tagLink}\n              >\n                {tag}\n              &#x3C;/Link>\n            &#x3C;/li>\n          );\n        })}\n      &#x3C;/ul>\n    &#x3C;/section>\n  );\n}\n</code></pre>\n<p>그리고 다음과 같이 사용할 수 있다. 이를 글 목록 관련 모든 페이지에 추가해 준다.</p>\n<pre><code class=\"language-tsx\">&#x3C;TagFilter \n  tags={tagList} \n  selectedTag={tag} \n  makeTagURL={makeTagURL} \n/>\n</code></pre>\n<h1>6. 플러그인 교정</h1>\n<p>폴더 구조가 바뀌었기 때문에 prebuild 시점에서 글의 이미지들을 다른 곳으로 복사해 주는 플러그인을 수정해야 한다. <code>src/bin/pre-build.mjs</code>를 다음과 같이 수정한다.</p>\n<pre><code class=\"language-js\">// src/bin/pre-build.mjs\nasync function getInnerDirectories(dir) {\n  const files = await fsPromises.readdir(dir, {withFileTypes:true});\n  return files.filter(file=>file.isDirectory());\n}\n\nasync function getInnerImages(dir) {\n  const files=await fsPromises.readdir(dir);\n  return files.filter((file) => imageFileExtensions.includes(path.extname(file)));\n}\n\nasync function copyPostDirImages() {\n  // posts 폴더 내의 글들\n  const posts=await getInnerDirectories(postDir);\n\n  for (const _post of posts) {\n    const post=_post.name;\n    const postImages=await getInnerImages(`${postDir}/${post}`);\n    if (postImages.length) {\n      // 폴더 생성\n      await fsPromises.mkdir(`${imageDir}/${post}`, { recursive: true });\n      await copyImage(`${postDir}/${post}`, `${imageDir}/${post}`, postImages);\n    }\n  }\n}\n</code></pre>\n<h1>7. 중복 경로 문제 트러블 슈팅</h1>\n<p>이렇게 하고 빌드를 해보았다. 바로 다음과 같은 에러가 발생했다.</p>\n<pre><code class=\"language-bash\">SourceFetchDataError {\n  error: JsonParseError {\n    str: 'undefined\\n',\n    error: SyntaxError: Unexpected token 'u', \"undefined\n    \" is not valid JSON\n        at JSON.parse (&#x3C;anonymous>)\n        at IEffectPartial.effect (file:///Users/kimsunghyun/Desktop/nextjs-blog/node_modules/@contentlayer/utils/src/node/fs.ts:90:20)\n        at FiberContext.evaluateNow (file:///Users/kimsunghyun/Desktop/nextjs-blog/node_modules/@effect-ts/system/_src/Fiber/context.ts:1049:50)\n        at file:///Users/kimsunghyun/Desktop/nextjs-blog/node_modules/@effect-ts/system/_src/Fiber/context.ts:576:33\n        at file:///Users/kimsunghyun/Desktop/nextjs-blog/node_modules/@effect-ts/system/_src/Support/Scheduler/index.ts:15:9,\n    _tag: 'fs.JsonParseError',\n    [Symbol()]: {\n      str: 'undefined\\n',\n      error: SyntaxError: Unexpected token 'u', \"undefined\n      \" is not valid JSON\n          at JSON.parse (&#x3C;anonymous>)\n          at IEffectPartial.effect (file:///Users/kimsunghyun/Desktop/nextjs-blog/node_modules/@contentlayer/utils/src/node/fs.ts:90:20)\n          at FiberContext.evaluateNow (file:///Users/kimsunghyun/Desktop/nextjs-blog/node_modules/@effect-ts/system/_src/Fiber/context.ts:1049:50)\n          at file:///Users/kimsunghyun/Desktop/nextjs-blog/node_modules/@effect-ts/system/_src/Fiber/context.ts:576:33\n          at file:///Users/kimsunghyun/Desktop/nextjs-blog/node_modules/@effect-ts/system/_src/Support/Scheduler/index.ts:15:9\n    },\n    [Symbol()]: [ 'error', 'str' ]\n  },\n  alreadyHandled: false,\n  _tag: 'SourceFetchDataError',\n  toString: [Function (anonymous)],\n  toJSON: [Function (anonymous)],\n  [Symbol()]: {\n    error: JsonParseError {\n      str: 'undefined\\n',\n      error: SyntaxError: Unexpected token 'u', \"undefined\n      \" is not valid JSON\n          at JSON.parse (&#x3C;anonymous>)\n          at IEffectPartial.effect (file:///Users/kimsunghyun/Desktop/nextjs-blog/node_modules/@contentlayer/utils/src/node/fs.ts:90:20)\n          at FiberContext.evaluateNow (file:///Users/kimsunghyun/Desktop/nextjs-blog/node_modules/@effect-ts/system/_src/Fiber/context.ts:1049:50)\n          at file:///Users/kimsunghyun/Desktop/nextjs-blog/node_modules/@effect-ts/system/_src/Fiber/context.ts:576:33\n          at file:///Users/kimsunghyun/Desktop/nextjs-blog/node_modules/@effect-ts/system/_src/Support/Scheduler/index.ts:15:9,\n      _tag: 'fs.JsonParseError',\n      [Symbol()]: [Object],\n      [Symbol()]: [Array]\n    },\n    alreadyHandled: false\n  },\n  [Symbol()]: [ 'alreadyHandled', 'error' ]\n}\n</code></pre>\n<p>무엇이 문제일까? 일단 의심되는 건 썸네일을 만들고 cloudinary에 업로드하는 로직이다. 따라서 업로드를 하지 않고 로컬에만 썸네일을 저장하도록 변경하였다. 썸네일을 만들고 저장하는 <code>src/plugins/make-thumbnail.mjs</code>의 <code>makeThumbnail</code> 함수를 다음과 같이 변경하였다.</p>\n<p>만약 <code>blogConfig.imageStorage</code>가 <code>local</code>이면 cloudinary에 업로드하지 않고 로컬에만 저장하도록 하였다.</p>\n<pre><code class=\"language-js\">export default function makeThumbnail() {\n  return async function(tree, file) {\n    /* \n    썸네일 생성하는 코드\n    */\n    if (blogConfig.imageStorage==='local') {return;}\n    /*\n    썸네일을 cloudinary에 업로드하는 코드\n    */\n  };\n}\n</code></pre>\n<p>그렇게 하자 해당 부분에서 발생하던 에러는 사라졌다. 대신 다른 에러가 발생했다.</p>\n<pre><code class=\"language-bash\">[Error: ENOENT: no such file or directory, rename '/Users/kimsunghyun/Desktop/nextjs-blog/.next/export/posts/tag/HTML.html' -> '/Users/kimsunghyun/Desktop/nextjs-blog/.next/server/pages/posts/tag/HTML.html'] {\n  errno: -2,\n  code: 'ENOENT',\n  syscall: 'rename',\n  path: '/Users/kimsunghyun/Desktop/nextjs-blog/.next/export/posts/tag/HTML.html',\n  dest: '/Users/kimsunghyun/Desktop/nextjs-blog/.next/server/pages/posts/tag/HTML.html'\n}\n</code></pre>\n<p><a href=\"https://github.com/i18next/next-i18next/issues/1852\">github 이슈를 찾아보니 중복된 라우트가 있어서 생기는 문제라고 했다.</a> 그래서 혹시 싶어서 각 태그별 분류 페이지의 2페이지 이상에서 동적 라우트를 생성하는 코드를 <code>params</code> 기반으로 손봐 보았다.</p>\n<pre><code class=\"language-tsx\">export const getStaticPaths: GetStaticPaths = async () => {\n  const paths=[];\n\n  const tags=getAllPostTags();\n\n  for (const tag of tags) {\n    // Prerender the next 5 pages after the first page, which is handled by the index page.\n    // Other pages will be prerendered at runtime.\n    for (let i=0;i&#x3C;5;i++) {\n      paths.push({\n        /* params key를 갖는 객체로 수정 */\n        params: {\n          tag,\n          page: (i+2).toString(),\n        }\n      });\n    }\n  }\n\n  return {\n    paths,\n    // Block the request for non-generated pages and cache them in the background\n    fallback: 'blocking',\n  };\n};\n</code></pre>\n<p>그런데 오류 메시지를 잘 보았더니 <code>HTML.html</code> 에 대한 오류인 것을 알 수 있었다. 뭔가 HTML이라는 것에 대한 문제가 있나? 해서 보았더니 <code>HTML</code>이라는 태그가 있었다. 문제는 소문자로 된 <code>html</code>이라는 태그도 있었다는 것이다. 이 둘이 중복 경로를 만드는 게 문제가 되었던 듯 했다.</p>\n<p>실제로 <code>html</code> 태그를 모두 <code>HTML</code>로 고치니 빌드가 잘 되는 것을 볼 수 있었다.</p>\n<pre><code class=\"language-bash\"># 전\n---\ntitle: HTML form의 데이터 다루기\ndate: \"2023-08-03T00:00:00Z\"\ndescription: \"HTML 폼의 데이터를 어떻게 다룰 것인가?\"\ntags: [\"html\"]\n---\n\n# 후\n---\ntitle: HTML form의 데이터 다루기\ndate: \"2023-08-03T00:00:00Z\"\ndescription: \"HTML 폼의 데이터를 어떻게 다룰 것인가?\"\ntags: [\"HTML\"]\n---\n</code></pre>\n<p>각 글들의 태그를 <code>Set</code>을 이용하여 중복을 제거하고 다시 저장할 때는 당연히 <code>HTML</code>과 <code>html</code>문자열은 다르게 취급되므로 두 태그가 모두 고유한 태그로 간주된다. 따라서 <code>src/pages/posts/tag/[tag]/index.tsx</code>에서 태그 분류 페이지를 만들 때도 html과 HTML 태그 문자열에 대한 URL이 모두 만들어지는데 페이지 URL에서는 대소문자 구분이 안되어서 이런 빌드 오류가 발생한 것이다.</p>\n<h1>8. 태그 줄이기</h1>\n<p>모호한 태그가 너무 많기 때문에 몇 가지 태그들만 추려서 남기도록 하겠다. 지금 분류가 필요할 것 같은 건 이 정도다. 일단 이들만으로 싹 글들을 정리하였다.</p>\n<ul>\n<li>OOP</li>\n<li>Javascript</li>\n<li>HTML</li>\n<li>study</li>\n<li>react</li>\n<li>web</li>\n<li>front</li>\n<li>tip</li>\n<li>CS</li>\n<li>CSS</li>\n<li>algorithm</li>\n<li>language</li>\n<li>git</li>\n<li>blog</li>\n</ul>",
    "excerpt": "블로그 만들기 시리즈\n|제목|링크|\n|---|---|\n|1. 기본 세팅|https://witch.work/posts/blog-remake-1|\n|2. 메인 페이지의 HTML 설계|https://witch.work/posts/blog-remake-2|\n|3. 글 상세 페이지의 구조 설계|https://witch.work/posts/blog-remake-3|\n|4. 이미지를 상대 경로로 쓸 수 있도록 하기|https://witch.work/posts/blog-rem",
    "headingTree": [
      {
        "title": "블로그 만들기 시리즈",
        "url": "#블로그-만들기-시리즈",
        "items": []
      },
      {
        "title": "1. 왜 태그를 이용해 분류하게 되었는가",
        "url": "#1-왜-태그를-이용해-분류하게-되었는가",
        "items": []
      },
      {
        "title": "2. 구상",
        "url": "#2-구상",
        "items": [
          {
            "title": "2.1. 폐기된 구상",
            "url": "#21-폐기된-구상",
            "items": []
          },
          {
            "title": "2.2. 페이지 구조",
            "url": "#22-페이지-구조",
            "items": []
          }
        ]
      },
      {
        "title": "3. 글 추출하기",
        "url": "#3-글-추출하기",
        "items": [
          {
            "title": "3.1. 전체 글을 페이지로 분류",
            "url": "#31-전체-글을-페이지로-분류",
            "items": []
          },
          {
            "title": "3.2. 태그별 글을 페이지로 분류",
            "url": "#32-태그별-글을-페이지로-분류",
            "items": []
          }
        ]
      },
      {
        "title": "4. 페이지 구조 만들기",
        "url": "#4-페이지-구조-만들기",
        "items": [
          {
            "title": "4.1. 태그별 페이지 구성하기",
            "url": "#41-태그별-페이지-구성하기",
            "items": []
          },
          {
            "title": "4.2. 전체 글 페이지",
            "url": "#42-전체-글-페이지",
            "items": []
          },
          {
            "title": "4.3. 글 상세 페이지",
            "url": "#43-글-상세-페이지",
            "items": []
          },
          {
            "title": "4.4. 메인 페이지",
            "url": "#44-메인-페이지",
            "items": []
          }
        ]
      },
      {
        "title": "5. 다른 수정사항",
        "url": "#5-다른-수정사항",
        "items": [
          {
            "title": "5.1. 헤더 수정",
            "url": "#51-헤더-수정",
            "items": []
          },
          {
            "title": "5.2. 태그를 통한 필터링",
            "url": "#52-태그를-통한-필터링",
            "items": [
              {
                "title": "5.2.1. URL 변환 함수",
                "url": "#521-url-변환-함수",
                "items": []
              },
              {
                "title": "5.2.2. 컴포넌트 제작",
                "url": "#522-컴포넌트-제작",
                "items": []
              }
            ]
          }
        ]
      },
      {
        "title": "6. 플러그인 교정",
        "url": "#6-플러그인-교정",
        "items": []
      },
      {
        "title": "7. 중복 경로 문제 트러블 슈팅",
        "url": "#7-중복-경로-문제-트러블-슈팅",
        "items": []
      },
      {
        "title": "8. 태그 줄이기",
        "url": "#8-태그-줄이기",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 7,
      "wordCount": 1844
    },
    "url": "/posts/blog-remake-14",
    "thumbnail": {
      "local": "/static/page-structure-898b0338.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-page-structure-898b0338-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAbElEQVR4nCXMQRVEMQhD0bpgXxs1gBAU4AAHcVAHkYCESqgELDBnfu/2nWTMOUVEVc85mamqIgJgmNmcc63V3VVFEsDee7h7RJhZVXU3ABFx9xERJCOiPgDc/X91781Mkv15uaoGSVV9i9eeH8x3W2BH+d4VAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "blog-remake-2",
    "title": "블로그 만들기 - 2. 메인 페이지 HTML 구조",
    "date": "2023-05-21T01:00:00Z",
    "description": "블로그의 HTML 구조를 만들어 보자.",
    "tags": [
      "blog",
      "web"
    ],
    "html": "<h1>블로그 만들기 시리즈</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>제목</th><th>링크</th></tr></thead><tbody><tr><td>1. 기본 세팅</td><td><a href=\"https://witch.work/posts/blog-remake-1\">https://witch.work/posts/blog-remake-1</a></td></tr><tr><td>2. 메인 페이지의 HTML 설계</td><td><a href=\"https://witch.work/posts/blog-remake-2\">https://witch.work/posts/blog-remake-2</a></td></tr><tr><td>3. 글 상세 페이지의 구조 설계</td><td><a href=\"https://witch.work/posts/blog-remake-3\">https://witch.work/posts/blog-remake-3</a></td></tr><tr><td>4. 이미지를 상대 경로로 쓸 수 있도록 하기</td><td><a href=\"https://witch.work/posts/blog-remake-4\">https://witch.work/posts/blog-remake-4</a></td></tr><tr><td>5. 자잘한 페이지 구성 개선과 배포</td><td><a href=\"https://witch.work/posts/blog-remake-5\">https://witch.work/posts/blog-remake-5</a></td></tr><tr><td>6. 페이지 요소의 배치 설계</td><td><a href=\"https://witch.work/posts/blog-remake-6\">https://witch.work/posts/blog-remake-6</a></td></tr><tr><td>7. 메인 페이지 컴포넌트 디자인</td><td><a href=\"https://witch.work/posts/blog-remake-7\">https://witch.work/posts/blog-remake-7</a></td></tr><tr><td>8. 글 목록/내용 페이지 컴포넌트 디자인</td><td><a href=\"https://witch.work/posts/blog-remake-8\">https://witch.work/posts/blog-remake-8</a></td></tr><tr><td>9. 글 썸네일 자동 생성하기</td><td><a href=\"https://witch.work/posts/blog-remake-9\">https://witch.work/posts/blog-remake-9</a></td></tr><tr><td>10. 폰트, 카드 디자인 등의 디자인 개선</td><td><a href=\"https://witch.work/posts/blog-remake-10\">https://witch.work/posts/blog-remake-10</a></td></tr><tr><td>11. 글에 조회수 달기</td><td><a href=\"https://witch.work/posts/blog-remake-11\">https://witch.work/posts/blog-remake-11</a></td></tr><tr><td>12. 페이지 테마와 글 검색 기능</td><td><a href=\"https://witch.work/posts/blog-remake-12\">https://witch.work/posts/blog-remake-12</a></td></tr><tr><td>13. 테마 아이콘과 썸네일 레이아웃 개선 등</td><td><a href=\"https://witch.work/posts/blog-remake-13\">https://witch.work/posts/blog-remake-13</a></td></tr><tr><td>14. 글 분류를 태그 기반으로 변경</td><td><a href=\"https://witch.work/posts/blog-remake-14\">https://witch.work/posts/blog-remake-14</a></td></tr><tr><td>메인 페이지의 연산 최적화</td><td><a href=\"https://witch.work/posts/blog-opt-1\">https://witch.work/posts/blog-opt-1</a></td></tr><tr><td>글 목록 페이지네이션 만들기</td><td><a href=\"https://witch.work/posts/blog-opt-2\">https://witch.work/posts/blog-opt-2</a></td></tr><tr><td>이미지를 CDN에 올리고 placeholder 만들기</td><td><a href=\"https://witch.work/posts/blog-opt-3\">https://witch.work/posts/blog-opt-3</a></td></tr><tr><td>검색 페이지에 무한 스크롤 구현하기</td><td><a href=\"https://witch.work/posts/blog-opt-4\">https://witch.work/posts/blog-opt-4</a></td></tr></tbody></table>\n<h1>0. 개요</h1>\n<p>이번에는 블로그 메인 페이지의 기본적인 HTML 구조를 잡아 보자. 다른 페이지들의 레이아웃은 일단 메인 페이지를 통해서 블로그의 기본적인 기능들을 모두 구현한 후 할 것이다.</p>\n<p>앞서 생각했던 메인 페이지 레이아웃은 다음과 같다.</p>\n<p><img src=\"/static/new-home-layout-e5ed565a.png\" alt=\"home-layout\"></p>\n<p>위에 있는 레이아웃을 보고 필요한 컴포넌트를 만들어보자. 지금 보기에 필요한 컴포넌트는 헤더, 푸터, 내 소개, 글 목록을 좀 보여주는 컴포넌트, 그리고 프로젝트 목록을 보여줄 컴포넌트 정도인 것 같다.</p>\n<p>스타일링은 아직 고려하지 말고 기초공사만 해보자. 컴포넌트를 위해 <code>src/components</code> 폴더 생성. 우리의(나의) 목표는 시맨틱하게 잘 짜인 페이지를 만드는 것이다. 여기에 주의하여 컴포넌트를 짰다.</p>\n<h1>1. Header 컴포넌트</h1>\n<p><code>src/components/header</code> 폴더를 만들고 <code>index.tsx</code>를 만들어 준다. 내 블로그 헤더에 들어갈 건 기본적인 내비게이션 바이기 때문에 다음과 같은 구조면 될 것 같다.</p>\n<pre><code class=\"language-tsx\">function Header() {\n  return &#x3C;header>\n    &#x3C;nav>\n      &#x3C;button>홈&#x3C;/button>\n      &#x3C;button>Front&#x3C;/button>\n      &#x3C;button>주제1&#x3C;/button>\n    &#x3C;/nav>\n  &#x3C;/header>;\n}\n</code></pre>\n<p>하지만 내비게이션 바에 들어갈 메뉴가 더 많아질 수도 있고, 링크도 더 생길 수 있기 때문에 props를 이용하도록 바꿔보자.</p>\n<pre><code class=\"language-tsx\">import Link from 'next/link';\n\ninterface PropsItem{\n  title: string;\n  url: string;\n}\n\nfunction Header({\n  navList\n}: {\n  navList: PropsItem[];\n}) {\n  return (\n    &#x3C;header>\n      &#x3C;nav>\n        {\n          navList.map((item) => {\n            return &#x3C;button key={item.title}>\n              &#x3C;Link href={item.url} aria-label={item.title}>\n                {item.title}\n              &#x3C;/Link>\n            &#x3C;/button>;\n          })\n        }\n      &#x3C;/nav>\n    &#x3C;/header>\n  );\n}\n\nexport default Header;\n</code></pre>\n<p>이를 index.tsx에 넣고 적절한 <code>navList</code> 변수를 생성하여 props로 넘기는 방식으로 한번 잘 되는지 체크해 볼 수 있다. 나머지 컴포넌트들도 마찬가지로 <code>src/pages/index.tsx</code>에 넣어서 잘 되는지 확인하는 방식으로 컴포넌트를 짰다.</p>\n<h1>2. Footer 컴포넌트</h1>\n<p>사실 Footer에는 별로 넣을 게 없다. 내 이름이나 넣자. 그런데 내 이름 같은 건 많이 쓰일 테니 먼저 <code>blog-config.ts</code> 파일을 만들어서 내 정보를 좀 넣어 놓도록 하자.</p>\n<p>그리고 내가 쓸 프로필 사진은 <code>/public</code>에 넣어준다. 아래에 보면 picture 항목에 <code>/witch.jpeg</code>이라고 되어 있는데, 이는 내가 넣어 놓은 프로필 사진인 <code>/public/witch.jpeg</code>을 의미한다.</p>\n<pre><code class=\"language-ts\">// /blog-config.ts\ninterface BlogConfigType {\n  name: string;\n  title: string;\n  description: string;\n  picture: string;\n  url: string;\n  social: {\n    github: string;\n  }\n}\n\nconst blogConfig: BlogConfigType = {\n  name:'김성현(Sung Hyun Kim)',\n  title:'Witch-Work',\n  description:\n    '서강대학교에서 기계공학과 컴퓨터공학을 복수전공하였습니다. ' +\n    '흔히 `마녀`라는 닉네임을 씁니다. ' +\n    '어떤 대단한 뜻을 품고 사는 사람은 아닙니다. ' +\n    '그저 멋진 사람들이 내는 빛을 따라가다 보니 여기까지 왔고, ' +\n    '앞으로도 그렇게 살 수 있었으면 좋겠다고 생각하는 사람입니다. ' +\n    '이곳에 찾아오신 당신과도 함께할 수 있어 영광입니다.',\n  picture:'/witch.jpeg',\n  url:'https://witch.work/',\n  social: {\n    github: 'witch-factory'\n  }\n};\n\nexport default blogConfig;\n</code></pre>\n<p>이제 푸터에 내 이름을 넣어보자. 이때 절대 경로를 사용하기 위해 루트의 <code>tsconfig.json</code>의 <code>compilerOptions</code>에  <code>\"baseUrl\": \".\"</code>을 추가해 주자. 꼭 해야 하는 건 아니지만 편하니까..</p>\n<pre><code class=\"language-tsx\">// src/components/footer/index.tsx\nimport blogConfig from 'blog-config';\n\nfunction Footer() {\n  return (\n    &#x3C;footer>\n    © {blogConfig.name}, Built with NextJS, 2023\n    &#x3C;/footer>\n  );\n}\n\nexport default Footer;\n</code></pre>\n<h1>3. 자기소개 컴포넌트</h1>\n<p>이제 내 소개를 담을 컴포넌트를 만들어 보자. 사진과 내 소개글, 링크를 담을 것이다. 아까 <code>blog-config.ts</code>를 만든 사실상의 주 목적이라고 할 수 있겠다.</p>\n<p><code>src/components/profile</code> 폴더를 생성한다. 그리고 <code>index.tsx</code>를 만들어 준다. 독립적으로 존재할 수 있는 부분이라고 생각하여 article 태그를 사용하였다.</p>\n<pre><code class=\"language-tsx\">// src/components/profile/index.tsx\nimport blogConfig from 'blog-config';\nimport Image from 'next/image';\nimport Link from 'next/link';\n\nfunction Profile() {\n  return (\n    &#x3C;article>\n      &#x3C;Image src={blogConfig.picture} alt={`${blogConfig.name} 프로필사진`} width={100} height={100} />\n      &#x3C;h2>{blogConfig.name}&#x3C;/h2>\n      &#x3C;p>{blogConfig.description}&#x3C;/p>\n      &#x3C;ul>\n        &#x3C;li>\n          &#x3C;Link href={`https://github.com/${blogConfig.social.github}`} target='_blank'>\n            Github\n          &#x3C;/Link>\n        &#x3C;/li>\n      &#x3C;/ul>\n    &#x3C;/article>\n  );\n}\n\nexport default Profile;\n</code></pre>\n<h1>4. 글 카테고리 컴포넌트</h1>\n<p>블로그의 메인 페이지에는 글 주제별로 몇 개의 글을 미리보기 형태로 카드 형식으로 보여주고 싶다. 이렇게 주제별로 몇 개의 글을 보여주는 컴포넌트를 글 카테고리 컴포넌트라고 하겠다.</p>\n<p>이 컴포넌트는 어떤 모습이 되어야 할까? 재사용을 위해서 어떤 부분을 props로 받아야 할지 생각해 보자.</p>\n<p>어떤 주제의 카테고리인지 정보가 있어야 하기 때문에 먼저 글 주제를 props로 받아야 한다. 그리고 그 주제와 연관해서 렌더링할 글 목록을 받아야 한다. 그럼 글 카테고리에서 보여주는 각 글 미리보기(?)에는 어떤 정보가 담겨 있을까?</p>\n<p>추후에 추가될 수도 있겠지만(특히 조회수를 추가하고 싶다)일단 여기서 보여줄 것은 글 제목, 글에 대한 간단한 설명, 글 생성일이 있어야 할 거라고 생각한다. 블로그 글은 md파일에 담길 것이기 때문에 md 파일의 메타데이터에 담길 내용들이기도 하다. 따라서 이런 구조로 HTML을 짜면 될 듯 하다.</p>\n<p><img src=\"/static/article-category-bb2dbc89.png\" alt=\"article-category\"></p>\n<p>메타데이터에는 태그도 있어야 한다고 생각하지만, 이를 굳이 글의 미리보기에서 보여줄 필요는 없다고 생각한다. 그래서 여기에서는 고려하지 않을 것이다. 이후에 props 구조를 설계하면서 type에 추가될 수는 있겠지만.</p>\n<p>이에 따라서 ArticleCategory 컴포넌트를 만들어 보자. HTML 구조는 다음과 같이 생각한다.</p>\n<p><img src=\"/static/article-category-html-0235f862.png\" alt=\"article-category-html\"></p>\n<h2>4.1. 글 카드 컴포넌트</h2>\n<p>일단 글 개요를 보여주는 카드와 같은 컴포넌트를 만들어 보자. 언젠가 이런 카드를 재사용할 일이 있을 거라 생각하고 좀 일반적인 이름으로<code>components/card/index.tsx</code>를 만들어 주자.</p>\n<p>이 컴포넌트는 article 태그를 사용할 것이다. 블로그 글 목록에서 개별 글(즉 blog entry)을 나타내는 컴포넌트로 article 태그를 사용하는 건 <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/article\">MDN의 article 문서</a>에서 제시하는 것과 정확히 일치하기 때문이다.</p>\n<p>props의 url은 해당 카드를 눌렀을 때 어디로 갈지에 대한 링크이다.</p>\n<pre><code class=\"language-tsx\">// src/components/card/index.tsx\nimport Link from 'next/link';\n\ninterface Props{\n  title: string;\n  description: string;\n  date: string;\n  url: string;\n}\n\nfunction Card(props: Props) {\n  const { title, description, date, url } = props;\n  return (\n    &#x3C;article>\n      &#x3C;Link href={url}>\n        &#x3C;h3>{title}&#x3C;/h3>\n        &#x3C;p>{description}&#x3C;/p>\n        &#x3C;time>{date}&#x3C;/time>\n      &#x3C;/Link>\n    &#x3C;/article>\n  );\n}\n\nexport default Card;\n</code></pre>\n<h2>4.2. 글 카테고리 컴포넌트</h2>\n<p>위에서 설계한 그대로 글 카테고리 컴포넌트도 만들어 주자. 어차피 카드를 묶어 주는 기능이기 때문에 이것도 언젠가 재사용을 대비하여 일반적인 이름의 category로 만들어 준다.</p>\n<pre><code class=\"language-tsx\">import Card from '../card';\n\ninterface CardProps{\n  title: string;\n  description: string;\n  date: string;\n  url: string;\n}\n\ninterface Props{\n  title: string;\n  items: CardProps[];\n}\n\nfunction Category(props: Props) {\n  return (\n    &#x3C;section>\n      &#x3C;h2>{props.title}&#x3C;/h2>\n      &#x3C;ul>\n        {\n          props.items.map((item, index) => {\n            return (\n              &#x3C;li key={index}>\n                &#x3C;Card title={item.title} description={item.description} date={item.date} url={item.url} />\n              &#x3C;/li>\n            );\n          })\n        }\n      &#x3C;/ul>\n    &#x3C;/section>\n  );\n}\n\nexport default Category;\n</code></pre>\n<h1>5. 프로젝트 소개 컴포넌트</h1>\n<p>나는 내가 한 프로젝트 소개도 블로그에 넣고 싶다. 물론 아직은 별로 넣을 게 없지만 뭐, 채워 나갈 것이다! 아무튼 프로젝트 소개 컴포넌트를 다시 생각해 보면, 이런 모습이 되면 좋겠다고 생각한다.</p>\n<p><img src=\"/static/project-layout-87a6f353.png\" alt=\"project-layout\"></p>\n<p>이를 위해서 일단 Card 컴포넌트가 이미지를 표시할 수 있도록 하고, 이를 적절히 수용하도록 Category 컴포넌트를 만들어 보자.</p>\n<h2>5.1. Card 컴포넌트 개선</h2>\n<p>넣을 이미지의 URL을 props로 받을 수 있도록 하고 image url이 주어졌을 경우에만 렌더링하도록 하면 된다. 스타일링을 할 때의 고난이 눈에 보이는 것 같지만 일단 구조만 잡도록 하자.</p>\n<pre><code class=\"language-tsx\">import Image from 'next/image';\nimport Link from 'next/link';\n\ninterface Props{\n  title: string;\n  description: string;\n  image?: string;\n  date: string;\n  url: string;\n}\n\nfunction Card(props: Props) {\n  const { title, description, image, date, url } = props;\n  return (\n    &#x3C;article>\n      &#x3C;Link href={url}>\n        {\n          image ? &#x3C;Image src={image} alt={`${title} 사진`} width={50} height={50} /> : null\n        }\n        &#x3C;h3>{title}&#x3C;/h3>\n        &#x3C;p>{description}&#x3C;/p>\n        &#x3C;time>{date}&#x3C;/time>\n      &#x3C;/Link>\n    &#x3C;/article>\n  );\n}\n\nexport default Card;\n</code></pre>\n<p>Props에 image가 있을 수도 있고 없을 수도 있기 때문에 <code>image?: string</code>으로 표시하였다. image 여부에 따라 Image 컴포넌트를 렌더링하도록 한 것 외에 다른 변경사항은 없다.</p>\n<h2>5.2. Category 컴포넌트 개선</h2>\n<p>역시 image를 받을 수 있도록 한 것 외에 변경사항은 없다.</p>\n<pre><code class=\"language-tsx\">import Card from 'src/components/card';\n\ninterface CardProps{\n  title: string;\n  description: string;\n  // 추가 부분\n  image?: string;\n  date: string;\n  url: string;\n}\n\ninterface Props{\n  title: string;\n  items: CardProps[];\n}\n\nfunction Category(props: Props) {\n  return (\n    &#x3C;section>\n      &#x3C;h2>{props.title}&#x3C;/h2>\n      &#x3C;ul>\n        {\n          props.items.map((item, index) => {\n            return (\n              &#x3C;li key={index}>\n                &#x3C;Card \n                  title={item.title} \n                  description={item.description} \n                  // 추가 부분\n                  image={item.image}\n                  date={item.date} \n                  url={item.url} \n                />\n              &#x3C;/li>\n            );\n          })\n        }\n      &#x3C;/ul>\n    &#x3C;/section>\n  );\n}\n\nexport default Category;\n</code></pre>\n<h1>6. 메타데이터 지정</h1>\n<p>이제 페이지의 메타데이터, 그러니까 일반적으로는 head 태그(NextJS에서는 Head)를 사용하여 지정하는 것들을 지정해 보려고 한다. 나중에 SEO를 하면서 열심히 메타데이터를 다듬을 예정이기 때문에 간단한 것만 하겠다.</p>\n<p>제목과 설명 메타데이터를 <code>blog-config.ts</code>에서 따와서 지정하고, favicon을 만들었다. 난 <a href=\"https://favicon.io/favicon-generator/\">favicon.ico</a>에서 텍스트를 favicon으로 만들어 주길래 그냥 단순하게 <code>마녀</code>라고 쓴 favicon을 넣어 보았다.</p>\n<p><img src=\"/static/favicon-490f3b02.ico\" alt=\"witch-favicon\"></p>\n<p>제목, favicon, 캐노니컬 데이터 등을 넣은 Head 태그는 다음과 같아진다.</p>\n<pre><code class=\"language-tsx\">&#x3C;Head>\n  &#x3C;title>{blogConfig.title}&#x3C;/title>\n  &#x3C;meta name='description' content={blogConfig.description} />\n  &#x3C;meta name='viewport' content='width=device-width, initial-scale=1' />\n  &#x3C;link rel='apple-touch-icon' sizes='180x180' href='/apple-touch-icon.png' />\n  &#x3C;link rel='icon' type='image/png' sizes='32x32' href='/favicon-32x32.png' />\n  &#x3C;link rel='icon' type='image/png' sizes='16x16' href='/favicon-16x16.png' />\n  &#x3C;link rel='manifest' href='/site.webmanifest' />\n  &#x3C;link rel='canonical' href='https://witch.work/' />\n&#x3C;/Head>\n</code></pre>\n<h1>7. HTML 공사결과</h1>\n<p>메인 페이지는 대강 다음과 같은 구조로 짜일 것이다. 물론 다른 페이지와 공통되는 구조를 밖으로 빼고, 또 CSS 등을 짜면서 더 많은 변경이 있겠지만 이렇게 시맨틱한 구조를 지키기 위해서 최선을 다할 것이다.</p>\n<pre><code class=\"language-tsx\">&#x3C;main>\n  &#x3C;Header navList={navList}/>\n  &#x3C;Profile />\n  &#x3C;h1>Welcome to My blog&#x3C;/h1>\n  {/* 프로젝트 목록은 독립적으로 존재 */}\n  &#x3C;article>\n    &#x3C;Category title={projectList.title} items={projectList.items} />\n  &#x3C;/article>\n  {/* 글 목록은 독립적인 영역으로 존재 */}\n  &#x3C;article>\n    &#x3C;Category title={postList.title} items={postList.items} />\n    &#x3C;Category title={postList.title} items={postList.items} />\n  &#x3C;/article>\n  &#x3C;Footer />\n&#x3C;/main>\n</code></pre>\n<p>이런 구조를 지키며 CSS를 짜나갈 생각을 하니 벌써부터 머리가 터져나갈 것 같이 신이 난다! 하지만 다행히(?) 아직 할 게 남았다. 블로그에 글을 쓰면 정적으로 페이지가 생성되도록 해야 한다. 즉 프리렌더링을 짜야 한다. 이거부터 하고 스타일링을 하도록 하자.</p>\n<h1>참고</h1>\n<p>내가 원하는 카드 컴포넌트에는 article이 적절하다. <a href=\"https://stackoverflow.com/questions/43953026/element-for-a-card-card-container-in-html5\">https://stackoverflow.com/questions/43953026/element-for-a-card-card-container-in-html5</a></p>\n<p>검색 달기 <a href=\"https://medium.com/frontendweb/build-the-search-functionality-in-a-static-blog-with-next-js-and-markdown-33ebc5a2214e\">https://medium.com/frontendweb/build-the-search-functionality-in-a-static-blog-with-next-js-and-markdown-33ebc5a2214e</a></p>",
    "excerpt": "블로그 만들기 시리즈\n|제목|링크|\n|---|---|\n|1. 기본 세팅|https://witch.work/posts/blog-remake-1|\n|2. 메인 페이지의 HTML 설계|https://witch.work/posts/blog-remake-2|\n|3. 글 상세 페이지의 구조 설계|https://witch.work/posts/blog-remake-3|\n|4. 이미지를 상대 경로로 쓸 수 있도록 하기|https://witch.work/posts/blog-rem",
    "headingTree": [
      {
        "title": "블로그 만들기 시리즈",
        "url": "#블로그-만들기-시리즈",
        "items": []
      },
      {
        "title": "0. 개요",
        "url": "#0-개요",
        "items": []
      },
      {
        "title": "1. Header 컴포넌트",
        "url": "#1-header-컴포넌트",
        "items": []
      },
      {
        "title": "2. Footer 컴포넌트",
        "url": "#2-footer-컴포넌트",
        "items": []
      },
      {
        "title": "3. 자기소개 컴포넌트",
        "url": "#3-자기소개-컴포넌트",
        "items": []
      },
      {
        "title": "4. 글 카테고리 컴포넌트",
        "url": "#4-글-카테고리-컴포넌트",
        "items": [
          {
            "title": "4.1. 글 카드 컴포넌트",
            "url": "#41-글-카드-컴포넌트",
            "items": []
          },
          {
            "title": "4.2. 글 카테고리 컴포넌트",
            "url": "#42-글-카테고리-컴포넌트",
            "items": []
          }
        ]
      },
      {
        "title": "5. 프로젝트 소개 컴포넌트",
        "url": "#5-프로젝트-소개-컴포넌트",
        "items": [
          {
            "title": "5.1. Card 컴포넌트 개선",
            "url": "#51-card-컴포넌트-개선",
            "items": []
          },
          {
            "title": "5.2. Category 컴포넌트 개선",
            "url": "#52-category-컴포넌트-개선",
            "items": []
          }
        ]
      },
      {
        "title": "6. 메타데이터 지정",
        "url": "#6-메타데이터-지정",
        "items": []
      },
      {
        "title": "7. HTML 공사결과",
        "url": "#7-html-공사결과",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 3,
      "wordCount": 769
    },
    "url": "/posts/blog-remake-2",
    "thumbnail": {
      "local": "/static/new-home-layout-e5ed565a.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-new-home-layout-e5ed565a-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAICAIAAABVpBlvAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAgUlEQVR4nC3KoQ1DIRAAUIZgExbAdQEcDofE4ZC4k0gcGkXSpDnJKPy6qztX0pT26SeUUlJKrXUppff+uA8BANZaRCSi63oSvYQxJudcSplz7v1mZuGc894752qte28iEiEEABhjICIfIsb4WwDwXyml1hoeRPRdOefbEUJg5rXWBzBiXGBOipdvAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "blog-remake-13",
    "title": "블로그 만들기 - 13. 아이콘 색상, 링크 추가, 코드 리팩토링",
    "date": "2023-06-12T05:00:00Z",
    "description": "자잘한 수리를 해보자.",
    "tags": [
      "blog",
      "web"
    ],
    "html": "<h1>블로그 만들기 시리즈</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>제목</th><th>링크</th></tr></thead><tbody><tr><td>1. 기본 세팅</td><td><a href=\"https://witch.work/posts/blog-remake-1\">https://witch.work/posts/blog-remake-1</a></td></tr><tr><td>2. 메인 페이지의 HTML 설계</td><td><a href=\"https://witch.work/posts/blog-remake-2\">https://witch.work/posts/blog-remake-2</a></td></tr><tr><td>3. 글 상세 페이지의 구조 설계</td><td><a href=\"https://witch.work/posts/blog-remake-3\">https://witch.work/posts/blog-remake-3</a></td></tr><tr><td>4. 이미지를 상대 경로로 쓸 수 있도록 하기</td><td><a href=\"https://witch.work/posts/blog-remake-4\">https://witch.work/posts/blog-remake-4</a></td></tr><tr><td>5. 자잘한 페이지 구성 개선과 배포</td><td><a href=\"https://witch.work/posts/blog-remake-5\">https://witch.work/posts/blog-remake-5</a></td></tr><tr><td>6. 페이지 요소의 배치 설계</td><td><a href=\"https://witch.work/posts/blog-remake-6\">https://witch.work/posts/blog-remake-6</a></td></tr><tr><td>7. 메인 페이지 컴포넌트 디자인</td><td><a href=\"https://witch.work/posts/blog-remake-7\">https://witch.work/posts/blog-remake-7</a></td></tr><tr><td>8. 글 목록/내용 페이지 컴포넌트 디자인</td><td><a href=\"https://witch.work/posts/blog-remake-8\">https://witch.work/posts/blog-remake-8</a></td></tr><tr><td>9. 글 썸네일 자동 생성하기</td><td><a href=\"https://witch.work/posts/blog-remake-9\">https://witch.work/posts/blog-remake-9</a></td></tr><tr><td>10. 폰트, 카드 디자인 등의 디자인 개선</td><td><a href=\"https://witch.work/posts/blog-remake-10\">https://witch.work/posts/blog-remake-10</a></td></tr><tr><td>11. 글에 조회수 달기</td><td><a href=\"https://witch.work/posts/blog-remake-11\">https://witch.work/posts/blog-remake-11</a></td></tr><tr><td>12. 페이지 테마와 글 검색 기능</td><td><a href=\"https://witch.work/posts/blog-remake-12\">https://witch.work/posts/blog-remake-12</a></td></tr><tr><td>13. 테마 아이콘과 썸네일 레이아웃 개선 등</td><td><a href=\"https://witch.work/posts/blog-remake-13\">https://witch.work/posts/blog-remake-13</a></td></tr><tr><td>14. 글 분류를 태그 기반으로 변경</td><td><a href=\"https://witch.work/posts/blog-remake-14\">https://witch.work/posts/blog-remake-14</a></td></tr><tr><td>메인 페이지의 연산 최적화</td><td><a href=\"https://witch.work/posts/blog-opt-1\">https://witch.work/posts/blog-opt-1</a></td></tr><tr><td>글 목록 페이지네이션 만들기</td><td><a href=\"https://witch.work/posts/blog-opt-2\">https://witch.work/posts/blog-opt-2</a></td></tr><tr><td>이미지를 CDN에 올리고 placeholder 만들기</td><td><a href=\"https://witch.work/posts/blog-opt-3\">https://witch.work/posts/blog-opt-3</a></td></tr><tr><td>검색 페이지에 무한 스크롤 구현하기</td><td><a href=\"https://witch.work/posts/blog-opt-4\">https://witch.work/posts/blog-opt-4</a></td></tr></tbody></table>\n<h1>1. 헤더 아이콘 색상</h1>\n<p>화면 너비가 작아지게 되면 헤더의 메뉴가 드롭다운으로 바뀌는데 이 아이콘 색상은 테마에 상관없이 검은색으로 일정하게 되어 있다. 따라서 다크모드에선 불편하다.</p>\n<p>이걸 테마에 따라 아이콘 색상이 달라지게 해보자. <a href=\"https://icons8.com/\">icons8</a>에서 iOS의 햄버거 메뉴/닫기 아이콘을 가져와서 <code>Toggler</code> 컴포넌트에 적용한다.</p>\n<pre><code class=\"language-tsx\">// src/components/header/menu/toggler/index.tsx\nimport Image from 'next/image';\nimport { useTheme } from 'next-themes';\n\nimport styles from './styles.module.css';\n\nconst hamburgerIcon: {[key: string]: string} = {\n  'light':'/icons/icons8-hamburger.svg',\n  'dark':'/icons/icons8-hamburger-dark.svg',\n  'pink':'/icons/icons8-hamburger-pink.svg',\n};\n\nconst cancelIcon: {[key: string]: string} = {\n  'light':'/icons/icons8-cancel.svg',\n  'dark':'/icons/icons8-cancel-dark.svg',\n  'pink':'/icons/icons8-cancel-pink.svg',\n};\n\nfunction Toggler({isMenuOpen, toggle}: {isMenuOpen: boolean, toggle: () => void}) {\n  const {theme} = useTheme();\n  \n  return (\n    &#x3C;button className={styles.button} onClick={toggle}>\n      &#x3C;Image\n        src={isMenuOpen ?\n          cancelIcon[theme || 'light'] :\n          hamburgerIcon[theme || 'light']\n        }\n        alt='Menu' \n        width={32} \n        height={32} \n      />\n    &#x3C;/button>\n  );\n}\n\nexport default Toggler;\n</code></pre>\n<p>그리고 이를 클라이언트 사이드에서 보이도록 하기 위해 메뉴 컴포넌트에서는 dynamic import를 한다.</p>\n<pre><code class=\"language-tsx\">// src/components/header/menu/index.tsx\n\nimport dynamic from 'next/dynamic';\n\n/* import문 일부 생략 */\n/* dynamic import */\nconst Toggler = dynamic(() => import('./toggler'), { ssr: false });\n\n/* 타입 생략 */\n\nfunction Menu({navList}: {navList: PropsItem[]}) {\n  /* 컴포넌트 내용은 이전과 똑같으므로 생략 */\n}\n\nexport default Menu;\n</code></pre>\n<h1>2. 자동 생성 썸네일의 간격 조정</h1>\n<p>현재 자동 생성 썸네일은 <code>src/plugins/make-thumbnail.mjs</code>에서 remark 플러그인 함수를 통해 생성하고 있다. 그런데 지금 코드의 경우 제목이 너무 길어서 여러 줄로 썸네일에 들어갈 경우 밑의 컨텐츠(헤딩 목록)가 유연하게 간격이 조절되지 않고 무조건 고정된 위치에 렌더링된다.</p>\n<p>이 코드를 수정하자. <code>drawHeadings</code> 함수만 수정하면 된다.</p>\n<pre><code class=\"language-js\">// src/plugins/make-thumbnail.mjs\n/* 나머지 함수들 생략 */\nfunction drawHeadings(ctx, title, headingTree) {\n  title=stringWrap(title, 15);\n  title=title.split('\\n');\n  \n  if (title.length>3) {return;}\n\n  const thumbnailHeadings=headingTree.slice(0, 2);\n  const headingTexts=[];\n  for (let h of thumbnailHeadings) {\n    const headingText=h.data.hProperties.title.replaceAll('. ', '-');\n    headingTexts.push(headingText);\n  }\n  headingTexts[headingTexts.length-1]+='...';\n  ctx.font = '20px NotoSansKR';\n  for (let i=0; i&#x3C;headingTexts.length; i++) {\n    ctx.fillText(headingTexts[i], 20, 50+50*title.length+25*i);\n  }\n}\n</code></pre>\n<p>그리고 <code>drawHeading</code>을 쓸 때 title도 같이 인수로 넣어준다.</p>\n<pre><code class=\"language-js\">drawHeadings(ctx, title, headings);\n</code></pre>\n<h1>3. 카테고리에 링크 추가</h1>\n<p>메인 페이지의 <code>Category</code>에서 표시하는 게시판 제목에 링크를 추가하자. 해당 컴포넌트에서는 props로 category의 URL을 이미 받고 있으므로 쉽다.</p>\n<p>링크가 있음을 표시하기 위해서 링크 표시 유니코드 <code>U+1F517</code>을 사용하였다.</p>\n<pre><code class=\"language-tsx\">// src/components/category/index.tsx\nfunction Category(props: Props) {\n  return (\n    &#x3C;section className={styles.container}>\n      &#x3C;h2 className={styles.title}>\n        &#x3C;Link href={props.url}>\n          {props.title} {'\\u{1F517}'}\n        &#x3C;/Link>\n      &#x3C;/h2>\n      \n      &#x3C;ul className={styles.list}>\n        {props.items.map((item) => {\n          return (\n            &#x3C;li key={item.url}>\n              &#x3C;Card\n                {...propsProperty(item)}\n              />\n            &#x3C;/li>\n          );\n        })}\n      &#x3C;/ul>\n    &#x3C;/section>\n  );\n}\n</code></pre>\n<p>그리고 hover시 텍스트 색상 스타일링 추가</p>\n<pre><code class=\"language-css\">// src/components/category/styles.module.css\n.container{\n  margin-bottom:2rem;\n}\n\n.title:hover{\n  color:var(--textLightIndigo);\n}\n\n.list{\n  list-style:none;\n  padding:0;\n  display: grid;\n  gap:1rem;\n  margin:0;\n}\n\n@media (min-width:768px){\n  .list{\n    grid-template-columns:repeat(3,1fr);\n  }\n}\n</code></pre>\n<h1>4. 푸터의 테마 설정 함수 지정</h1>\n<p>푸터에서 쓰던 기존의 테마 설정 함수는 테마 이름에 따라 하나하나 만들어 주고 있었다. 이를 테마 이름에 따라 자동으로 만들어주는 함수로 바꾸자.</p>\n<pre><code class=\"language-tsx\">// src/components/footer/index.tsx\n/* 기존에 쓰던 함수들 */\nconst pinkTheme = () => {\n  setTheme('pink');\n};\n\nconst witchTheme = () => {\n  setTheme('witch');\n};\n\n/* 새로 일반화한 함수 */\nconst changeTheme = useCallback((theme: string) => {\n  return ()=>{\n    setTheme(theme);\n  };\n}, []);\n</code></pre>\n<h1>5. 반복되는 부분 통합</h1>\n<h2>5.1. 테마에 따른 아이콘 색상</h2>\n<p>현재 테마에 따른 아이콘을 택하는 건 <code>Toggler</code> 컴포넌트와 <code>Search</code> 컴포넌트에서 객체를 통해 이루어지고 있다. 그런데 각각의 아이콘을 위한 함수들이 반복적으로 정의되었다.</p>\n<p>아래에 쓰인 외에도 <code>searchIconSrc</code> 함수도 있다...같은 로직으로 3번이나 비슷한 함수가 있는 것이다.</p>\n<pre><code class=\"language-tsx\">// src/components/header/menu/toggler/index.tsx\nfunction hamburgerIconSrc(isDark: boolean, isPink: boolean, isWitch: boolean) {\n  if (isDark || isWitch) {\n    return hamburgerIconMap['dark'];\n  }\n  else if (isPink) {\n    return hamburgerIconMap['pink'];\n  }\n  else {\n    return hamburgerIconMap['light'];\n  }\n}\n\nfunction cancelIconSrc(isDark: boolean, isPink: boolean, isWitch: boolean) {\n  if (isDark || isWitch) {\n    return cancelIconMap['dark'];\n  }\n  else if (isPink) {\n    return cancelIconMap['pink'];\n  }\n  else {\n    return cancelIconMap['light'];\n  }\n}\n</code></pre>\n<p>이를 함수를 통해 분리하자. <code>utils/getThemeName.ts</code>에 아래와 같이 함수를 정의한다. theme이 undefined도 가능하도록 한 이유는 여기에 들어가는 theme은 next-themes에 있는  <code>resolvedTheme</code>인데 이는 undefined일 수도 있기 때문이다.</p>\n<p>만약 theme이 undefined라면 light로 간주한다.</p>\n<pre><code class=\"language-ts\">export const getThemeName = (theme: string | undefined) => {\n  if (theme === 'witch') {\n    return 'dark';\n  }\n  return theme ?? 'light';\n}\n</code></pre>\n<p>그리고 기존 이미지 객체들도 <code>utils/iconsURL.ts</code>으로 옮겨준다.</p>\n<pre><code class=\"language-ts\">// src/utils/iconsURL.ts에 다음 내용 추가\nconst hamburgerIconMap: {[key: string]: string} = {\n  'light':hamburgerIcon,\n  'dark':hamburgerIconDark,\n  'pink':hamburgerIconPink,\n};\n\nconst cancelIconMap: {[key: string]: string} = {\n  'light':cancelIcon,\n  'dark':cancelIconDark,\n  'pink':cancelIconPink,\n};\n\nconst searchIconMap: {[key: string]: string}={\n  'light':searchIcon,\n  'dark':searchIconDark,\n  'pink':searchIconPink,\n};\n\nexport {\n  hamburgerIconMap,\n  cancelIconMap,\n  searchIconMap,\n};\n</code></pre>\n<p>그리고 <code>Toggler</code> 컴포넌트에서는 이를 아래와 같이 적용한다. 반복되는 논리와 함수 정의가 없어져서 훨씬 깔끔해졌다.</p>\n<pre><code class=\"language-tsx\">import Image from 'next/image';\nimport { useTheme } from 'next-themes';\n\nimport { getThemeName } from '@/utils/getThemeName';\nimport { hamburgerIconMap, cancelIconMap } from '@/utils/iconsURL';\n\nimport styles from './styles.module.css';\n\nfunction Toggler({isMenuOpen, toggle}: {isMenuOpen: boolean, toggle: () => void}) {\n  const {resolvedTheme} = useTheme();\n  \n  return (\n    &#x3C;button className={styles.button} onClick={toggle}>\n      &#x3C;Image\n        src={isMenuOpen ?\n          cancelIconMap[getThemeName(resolvedTheme)] :\n          hamburgerIconMap[getThemeName(resolvedTheme)]\n        }\n        alt='Menu' \n        width={32} \n        height={32} \n      />\n    &#x3C;/button>\n  );\n}\n\nexport default Toggler;\n</code></pre>\n<p><code>Search</code> 컴포넌트에도 다음과 같이 적용한다.</p>\n<pre><code class=\"language-tsx\">// src/components/header/search/index.tsx\nconst Search = () => {\n  const {resolvedTheme} = useTheme();\n\n  return (\n    &#x3C;Link href='/posts' className={styles.search}>\n      &#x3C;Image \n        src={searchIconMap[getThemeName(resolvedTheme)]} \n        alt='Search' \n        width={32} \n        height={32} \n        priority\n      />\n    &#x3C;/Link> \n  );\n};\n</code></pre>\n<h2>5.2. 메인 페이지의 중복 논리 map 제거</h2>\n<p><code>src/pages/index.tsx</code>에 있는 메인 페이지 코드를 보자. <code>getStaticProps</code>에서 <code>{카테고리명:해당 카테고리 글들의 배열}</code>형태의 객체를 리턴하고 이를 <code>Home</code> 컴포넌트에서 <code>blogCategoryList.map</code>을 통해 카테고리별로 <code>Category</code> 컴포넌트를 만들고 있다.</p>\n<p>이때 카테고리별 글들을 리턴하는 논리가 중복되어 있다. 이를 제거하자.</p>\n<pre><code class=\"language-tsx\">export default function Home({\n  categoryPostMap\n}: InferGetStaticPropsType&#x3C;typeof getStaticProps>) {\n  return (\n    &#x3C;PageContainer>\n      &#x3C;Profile />\n      {/* 프로젝트 목록을 만들기 */}\n      &#x3C;ProjectList />\n      &#x3C;article>\n        {/* 카테고리별 글 목록을 만들기 */}\n        {blogCategoryList.map((category) => {\n          const categoryPostList=categoryPostMap[category.url];\n\n          return categoryPostList.length?\n            &#x3C;Category\n              key={category.title} \n              title={category.title} \n              url={category.url} \n              items={categoryPostList}\n            />:null;\n        })}\n      &#x3C;/article>\n    &#x3C;/PageContainer>\n\n  );\n}\n\nexport const getStaticProps: GetStaticProps = () => {\n  const categoryPostMap: {[key: string]: CardProps[]}={};\n\n  blogCategoryList.forEach((category)=>{\n    categoryPostMap[category.url]=getSortedPosts()\n      .filter((post: DocumentTypes)=>{\n        return post._raw.flattenedPath.split('/')[0]===category.url.split('/').pop();\n      })\n      .slice(0, 3)\n      .map((post: DocumentTypes)=>{\n        return propsProperty(post);\n      });\n  });\n\n  return { props: { categoryPostMap } };\n};\n</code></pre>\n<p>이를 다음과 같이 수정한다. 이제 <code>Home</code> 컴포넌트에서는 객체를 통해 계산하는 게 아니라 배열을 이용한 map을 사용한다.</p>\n<pre><code class=\"language-tsx\">function propsProperty(post: DocumentTypes) {\n  const { title, description, date, tags, url } = post;\n  return { title, description, date, tags, url };\n}\n\nexport default function Home({\n  categoryPostList\n}: InferGetStaticPropsType&#x3C;typeof getStaticProps>) {\n  return (\n    &#x3C;PageContainer>\n      &#x3C;Profile />\n      {/* 프로젝트 목록을 만들기 */}\n      &#x3C;ProjectList />\n      &#x3C;article>\n        {/* 카테고리별 글 목록을 만들기 */}\n        {categoryPostList.map((category: CategoryProps) => {\n          return category.items.length?\n            &#x3C;Category\n              key={category.url}\n              {...category}\n            />:null;\n        })\n        }\n      &#x3C;/article>\n    &#x3C;/PageContainer>\n\n  );\n}\n\nexport const getStaticProps: GetStaticProps = () => {\n\n  const categoryPostList: CategoryProps[]=blogCategoryList.map((category)=>{\n    const {title:categoryTitle, url:categoryURL}=category;\n    const postList: CardProps[]=getSortedPosts()\n      .filter((post: DocumentTypes)=>{\n        return post._raw.flattenedPath.split('/')[0]===category.url.split('/').pop();\n      })\n      .slice(0, 3)\n      .map((post: DocumentTypes)=>{\n        return propsProperty(post);\n      });\n\n    return {title:categoryTitle, url:categoryURL, items: postList};\n  });\n\n  return { props: { categoryPostList } };\n};\n</code></pre>\n<p>위에 쓰인 <code>CategoryProps</code>는 <code>Category</code> 컴포넌트와 함께 정의된 타입인데 이전에 쓰이던 것과 같다.</p>\n<pre><code class=\"language-tsx\">// src/components/category/index.tsx\nexport interface CategoryProps{\n  title: string;\n  url: string;\n  items: CardProps[];\n}\n</code></pre>\n<h1>6. 페이지네이션 코드에 타입 추가</h1>\n<p>페이지네이션에 쓰이는 <code>getPaginationArray</code>에서 리턴하는 배열은 <code>...</code>과 숫자가 담긴 배열을 리턴한다. 따라서 이 둘을 포괄하는 타입을 정의하여 사용해 주자.</p>\n<p>다음과 같이 작성하면 이후 이 함수에서 생성한 <code>PaginationArray</code>의 map을 돌릴 때 각 원소가 <code>number | '...'</code>타입으로 추론되어서 다른 문자열이 해당 배열에 들어가는 것을 막을 수 있다.</p>\n<pre><code class=\"language-tsx\">// 상수 타입으로 변경\nexport const dotts='...' as const;\n\nfunction getPaginationArray(\n  totalItemNumber: number,\n  currentPage: number,\n  perPage: number\n): Array&#x3C;number | typeof dotts> {\n  /* 리턴 타입을 number 혹은 dotts 문자열로 강력히 정의 */\n  const totalPages=parseInt((totalItemNumber/perPage).toString()) + (totalItemNumber%perPage?1:0);\n  if (totalPages&#x3C;=7) {\n    return getPages(totalPages);\n  }\n  if (currentPage&#x3C;=4) {\n    return [1, 2, 3, 4, 5, dotts, totalPages-1 ,totalPages];\n  }\n  if (currentPage>=totalPages-3) {\n    return [1, dotts, ...getPages(6, totalPages - 5)];\n  }\n\n  return [1, \n    dotts,\n    ...getPages(5, currentPage - 2),\n    dotts, \n    totalPages\n  ];\n}\n</code></pre>\n<h1>7. 무한 스크롤의 디바운스</h1>\n<p><code>useDebounce</code> 훅을 <code>src/utils/useDebounce.ts</code>로 분리하고 다음과 같이 스크롤 페이지가 debounce되도록 한다.</p>\n<pre><code class=\"language-tsx\">function PostSearchPage({\n  category, postList,\n}: InferGetStaticPropsType&#x3C;typeof getStaticProps>) {\n  const [searchKeyword, debouncedKeyword, setSearchKeyword]=useSearchKeyword();\n  const [filteredPostList, setFilteredPostList]=useState&#x3C;CardProps[]>(postList);\n  const [page, setPage]=useState&#x3C;number>(1);\n  /* 300ms가 지나야 증가하는 페이지 */\n  const debouncedPage = useDebounce(page.toString(), 300);\n\n  const infiniteScrollRef=useRef&#x3C;HTMLDivElement>(null);\n  const totalPage=Math.ceil(filteredPostList.length/ITEMS_PER_PAGE);\n\n  const onKeywordChange = useCallback((event: ChangeEvent&#x3C;HTMLInputElement>) => {\n    setSearchKeyword(event.target.value);\n  }, [setSearchKeyword]);\n\n  useEffect(() => {\n    setFilteredPostList(filterPostsByKeyword(postList, debouncedKeyword));\n  }, [debouncedKeyword]);\n\n  /* 디바운스된 페이지 기준으로 스크롤 로드 */\n  useInfiniteScroll(infiniteScrollRef, useCallback(()=>{\n    if (page&#x3C;totalPage) {\n      setPage(prev=>prev+1);\n    }\n  }, [debouncedPage, totalPage]));\n\n  return (\n    &#x3C;PageContainer>\n      &#x3C;h2 className={styles.title}>{`${category} 검색`}&#x3C;/h2>\n      &#x3C;SearchConsole \n        value={searchKeyword}\n        onChange={onKeywordChange}\n      />\n      &#x3C;ul className={styles.list}>\n        {filteredPostList.slice(0, ITEMS_PER_PAGE * page).map((post: CardProps) => \n          &#x3C;li key={post.url}>\n            &#x3C;Card {...post} />\n          &#x3C;/li>\n        )}\n      &#x3C;/ul>\n      &#x3C;div className={styles.infScroll} ref={infiniteScrollRef} />\n    &#x3C;/PageContainer>\n  );\n}\n</code></pre>\n<h1>8. blur URL 개선</h1>\n<p>현재 이미지의 placeholder 역할을 하는 블러 이미지는 <code>src/utils/generateBlurPlaceholder.ts</code>에서 만들고 있다. 코드는 다음과 같다.</p>\n<pre><code class=\"language-ts\">import imagemin from 'imagemin';\nimport imageminJpegtran from 'imagemin-jpegtran';\n\nexport default async function getBase64ImageUrl(imageUrl: string) {\n  const response= await fetch(imageUrl.replace('w_300,f_auto', 'w_16,f_jpg'));\n  const buffer= await response.arrayBuffer();\n  const minified = await imagemin.buffer(Buffer.from(buffer), {\n    plugins: [imageminJpegtran()],\n  });\n  const blurURL = `data:image/jpeg;base64,${Buffer.from(minified).toString('base64')}`;\n  return blurURL;\n}\n</code></pre>\n<p>그런데 여기에 쓰인 imagemin은 이미 시체가 되었다. <a href=\"https://github.com/imagemin/imagemin#readme\">공식 github</a>의 About을 보면 Unmaintained라고 쓰여 있다.</p>\n<p>따라서 새로운 라이브러리를 쓰자. <a href=\"https://plaiceholder.co/docs\">plaiceholder</a>라는 라이브러리가 있다. plaice는 넙치라고 한다.</p>\n<pre><code>Q : Why have you misspelled \"placeholder\"?\nA : A Plaice(opens in a new tab) is a flat fish that lays stationary on the sea-bed, much like an image placehol… actually this is bullshit, all the other good names were taken.\n</code></pre>\n<h2>8.1. 라이브러리 세팅</h2>\n<p>기존에 깔았던 imagemin 관련 라이브러리를 삭제하고 plaiceholder를 설치하자.</p>\n<pre><code class=\"language-bash\">npm uninstall @types/imagemin\nnpm uninstall @types/imagemin-jpegtran\nnpm uninstall imagemin-jpegtran\nnpm uninstall imagemin\n\nnpm install sharp\nnpm install plaiceholder\n</code></pre>\n<p>만약 이를 nextJS 사이드의 코드에서 쓰고 싶다면 <code>@plaiceholder/next</code>도 설치해야 하겠지만 나는 빌드 시 remark 플러그인을 적용하는 데에서만 쓸 것이므로 굳이 설치할 필요 없다.</p>\n<p>참고로 <code>plaiceholder</code>에서는 <code>next.config</code>를 <code>ts</code>형식이나 <code>mjs</code>형식으로 해서 ESM 모듈 형식으로 라이브러리를 사용할 것을 요구한다. 공식 문서에서는 <code>ESM only</code>라고 곳곳에 쓰여 있기도 하다.</p>\n<p>하지만 이렇게 하면 빌드시 <code>contentlayer</code>쪽에서 나는 걸로 추정되는 캐시 에러가 마구마구 뜬다. <a href=\"https://github.com/vercel/next.js/issues/33693\">nextJS에 이슈도 있다.</a> 관련 이슈들을 찾아보면 웹팩에서 ESM 모듈 지원의 대부분이 실험적이며 아직 안정화되지 않아서 발생하는 문제일 것으로 추정된다고 한다.</p>\n<p>나는 어차피 이걸 nextJS 사이드에서 쓸 일이 없어서 넘어갔지만 만약 이를 해결해서 plaiceholder를 NextJS에서 사용한 사람이 있다면 댓글로 알려주길 바란다.</p>\n<h2>8.2. 코드 수정</h2>\n<p><code>generateBlurPlaceholder.ts</code>의 <code>getBase64ImageUrl</code> 함수만 수정하면 된다. 여기서 base64로 인코딩된 blurURL만 잘 리턴해 주면 나머지는 <code>make-thumbnail.mjs</code>에서 처리해 줄 것이다.</p>\n<pre><code class=\"language-ts\">import { getPlaiceholder } from 'plaiceholder';\n\nexport default async function getBase64ImageUrl(imageUrl: string) {\n  try {\n    const buffer=await fetch(imageUrl).then(async (res)=>{\n      return Buffer.from(await res.arrayBuffer());\n    });\n    const {base64:blurURL}=await getPlaiceholder(buffer, {size:8});\n    return blurURL;\n  } catch (err) {\n    err;\n  }\n}\n</code></pre>\n<h1>참고</h1>\n<p>plaiceholder 공식 문서 <a href=\"https://plaiceholder.co/docs\">https://plaiceholder.co/docs</a></p>\n<p><a href=\"https://github.com/vercel/next.js/issues/33693\">https://github.com/vercel/next.js/issues/33693</a></p>",
    "excerpt": "블로그 만들기 시리즈\n|제목|링크|\n|---|---|\n|1. 기본 세팅|https://witch.work/posts/blog-remake-1|\n|2. 메인 페이지의 HTML 설계|https://witch.work/posts/blog-remake-2|\n|3. 글 상세 페이지의 구조 설계|https://witch.work/posts/blog-remake-3|\n|4. 이미지를 상대 경로로 쓸 수 있도록 하기|https://witch.work/posts/blog-rem",
    "headingTree": [
      {
        "title": "블로그 만들기 시리즈",
        "url": "#블로그-만들기-시리즈",
        "items": []
      },
      {
        "title": "1. 헤더 아이콘 색상",
        "url": "#1-헤더-아이콘-색상",
        "items": []
      },
      {
        "title": "2. 자동 생성 썸네일의 간격 조정",
        "url": "#2-자동-생성-썸네일의-간격-조정",
        "items": []
      },
      {
        "title": "3. 카테고리에 링크 추가",
        "url": "#3-카테고리에-링크-추가",
        "items": []
      },
      {
        "title": "4. 푸터의 테마 설정 함수 지정",
        "url": "#4-푸터의-테마-설정-함수-지정",
        "items": []
      },
      {
        "title": "5. 반복되는 부분 통합",
        "url": "#5-반복되는-부분-통합",
        "items": [
          {
            "title": "5.1. 테마에 따른 아이콘 색상",
            "url": "#51-테마에-따른-아이콘-색상",
            "items": []
          },
          {
            "title": "5.2. 메인 페이지의 중복 논리 map 제거",
            "url": "#52-메인-페이지의-중복-논리-map-제거",
            "items": []
          }
        ]
      },
      {
        "title": "6. 페이지네이션 코드에 타입 추가",
        "url": "#6-페이지네이션-코드에-타입-추가",
        "items": []
      },
      {
        "title": "7. 무한 스크롤의 디바운스",
        "url": "#7-무한-스크롤의-디바운스",
        "items": []
      },
      {
        "title": "8. blur URL 개선",
        "url": "#8-blur-url-개선",
        "items": [
          {
            "title": "8.1. 라이브러리 세팅",
            "url": "#81-라이브러리-세팅",
            "items": []
          },
          {
            "title": "8.2. 코드 수정",
            "url": "#82-코드-수정",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 5,
      "wordCount": 1241
    },
    "url": "/posts/blog-remake-13",
    "thumbnail": {
      "local": "/thumbnails/blog-remake-13-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-blog-remake-13-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAkElEQVR4nGNITk62srJsaWnR0dHJzMxcvXp1e3v7////GdLS0kRFRf38/Pj5+TMzM21tbd3c3BISEhgmTpwYGBhoa2vLzc0tIyOzfPny58+fHzp0iGHmjBm5OTnd3d0VFRWHDh368ePHfzBgmDZ9Rlx8fH5+/uzZs////4+QWLV2w6pVq3bs2HHr1i2IEEQCAAxBVK+Fj9ZDAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "blog-remake-3",
    "title": "블로그 만들기 - 3. 글 상세 페이지 구조",
    "date": "2023-05-22T00:00:00Z",
    "description": "Contentlayer를 이용해서 블로그의 글 상세 페이지를 만들어 보자.",
    "tags": [
      "blog",
      "web"
    ],
    "html": "<h1>블로그 만들기 시리즈</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>제목</th><th>링크</th></tr></thead><tbody><tr><td>1. 기본 세팅</td><td><a href=\"https://witch.work/posts/blog-remake-1\">https://witch.work/posts/blog-remake-1</a></td></tr><tr><td>2. 메인 페이지의 HTML 설계</td><td><a href=\"https://witch.work/posts/blog-remake-2\">https://witch.work/posts/blog-remake-2</a></td></tr><tr><td>3. 글 상세 페이지의 구조 설계</td><td><a href=\"https://witch.work/posts/blog-remake-3\">https://witch.work/posts/blog-remake-3</a></td></tr><tr><td>4. 이미지를 상대 경로로 쓸 수 있도록 하기</td><td><a href=\"https://witch.work/posts/blog-remake-4\">https://witch.work/posts/blog-remake-4</a></td></tr><tr><td>5. 자잘한 페이지 구성 개선과 배포</td><td><a href=\"https://witch.work/posts/blog-remake-5\">https://witch.work/posts/blog-remake-5</a></td></tr><tr><td>6. 페이지 요소의 배치 설계</td><td><a href=\"https://witch.work/posts/blog-remake-6\">https://witch.work/posts/blog-remake-6</a></td></tr><tr><td>7. 메인 페이지 컴포넌트 디자인</td><td><a href=\"https://witch.work/posts/blog-remake-7\">https://witch.work/posts/blog-remake-7</a></td></tr><tr><td>8. 글 목록/내용 페이지 컴포넌트 디자인</td><td><a href=\"https://witch.work/posts/blog-remake-8\">https://witch.work/posts/blog-remake-8</a></td></tr><tr><td>9. 글 썸네일 자동 생성하기</td><td><a href=\"https://witch.work/posts/blog-remake-9\">https://witch.work/posts/blog-remake-9</a></td></tr><tr><td>10. 폰트, 카드 디자인 등의 디자인 개선</td><td><a href=\"https://witch.work/posts/blog-remake-10\">https://witch.work/posts/blog-remake-10</a></td></tr><tr><td>11. 글에 조회수 달기</td><td><a href=\"https://witch.work/posts/blog-remake-11\">https://witch.work/posts/blog-remake-11</a></td></tr><tr><td>12. 페이지 테마와 글 검색 기능</td><td><a href=\"https://witch.work/posts/blog-remake-12\">https://witch.work/posts/blog-remake-12</a></td></tr><tr><td>13. 테마 아이콘과 썸네일 레이아웃 개선 등</td><td><a href=\"https://witch.work/posts/blog-remake-13\">https://witch.work/posts/blog-remake-13</a></td></tr><tr><td>14. 글 분류를 태그 기반으로 변경</td><td><a href=\"https://witch.work/posts/blog-remake-14\">https://witch.work/posts/blog-remake-14</a></td></tr><tr><td>메인 페이지의 연산 최적화</td><td><a href=\"https://witch.work/posts/blog-opt-1\">https://witch.work/posts/blog-opt-1</a></td></tr><tr><td>글 목록 페이지네이션 만들기</td><td><a href=\"https://witch.work/posts/blog-opt-2\">https://witch.work/posts/blog-opt-2</a></td></tr><tr><td>이미지를 CDN에 올리고 placeholder 만들기</td><td><a href=\"https://witch.work/posts/blog-opt-3\">https://witch.work/posts/blog-opt-3</a></td></tr><tr><td>검색 페이지에 무한 스크롤 구현하기</td><td><a href=\"https://witch.work/posts/blog-opt-4\">https://witch.work/posts/blog-opt-4</a></td></tr></tbody></table>\n<p>이번에는 블로그의 글 상세 페이지를 만들어 보자. 일단 마크다운을 따와 보자. 아래 참고에 적어 놓은 페이지들을 많이 참고하였다.</p>\n<h1>1. 마크다운 가져오기</h1>\n<h2>1.1. contentlayer 설치+설정</h2>\n<p>contentlayer라는 라이브러리를 가져오면 쉽게 할 수 있다. 필요한 라이브러리를 설치해 주자.</p>\n<pre><code>npm install contentlayer next-contentlayer rehype-highlight rehype-pretty-code shiki\n</code></pre>\n<p>그리고 <code>next.config.js</code>에 다음과 같이 설정하여 contentlayer 플러그인 등록</p>\n<pre><code class=\"language-js\">// next.config.js\nconst { withContentlayer } = require('next-contentlayer');\n\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  reactStrictMode: true,\n  swcMinify:false,\n};\n\nmodule.exports = withContentlayer(nextConfig);\n</code></pre>\n<p><code>tsconfig.json</code>에서 import 경로 alias 설정</p>\n<pre><code class=\"language-json\">//tsconfig.json\n// 출처 https://yiyb-blog.vercel.app/posts/nextjs-contentlayer-blog\n{\n  // ...\n  \"compilerOptions\": {\n    // ...\n    \"paths\": {\n      \"@/contentlayer/generated\": [\"./.contentlayer/generated\"],\n\n      \"@/contentlayer/generated/*\": [\"./.contentlayer/generated/*\"]\n    }\n    // ...\n  },\n  \"include\": [\n    \"next-env.d.ts\",\n    \"**/*.ts\",\n    \"**/*.tsx\",\n    \"./.contentlayer/generated\"\n  ]\n}\n</code></pre>\n<h2>1.2. contentlayer.config.js 설정</h2>\n<p>이제 <code>contentlayer.config.js</code>을 만들고 정의해야 한다. 여기서는 markdown파일을 어떻게 변환할 것인지를 설정한다.</p>\n<p>일단 우리가 글에 넣을 메타데이터는 제목, 설명, 작성일, 태그들 정도가 생각난다. 이를 정의해 주자. 나의 영원한 프론트 리드 <a href=\"https://xo.dev/\">이창희</a>의 <a href=\"https://github.com/blurfx/ambienxo\">블로그 코드</a>에서 슬쩍해 왔다.</p>\n<pre><code class=\"language-js\">const postFields={\n  fields:{\n    title:{\n      type:'string',\n      description:'The title of the post',\n      required:true,\n    },\n    description: {\n      type: 'string',\n      description: 'The description of the post for preview and SEO',\n    },\n    date: {\n      type: 'date',\n      description: 'The date of the post',\n      required: true,\n    },\n    tags: {\n      type: 'list',\n      of: { type: 'string' },\n      description: 'The tags of the post',\n    },\n  },\n  computedFields: {\n    url: { type: 'string', resolve: (post) => `/posts/${post._raw.flattenedPath}` },\n  },\n};\n</code></pre>\n<p>이렇게 객체로 만든 이유는, <code>.md</code>파일과 <code>.mdx</code>파일을 따로 취급해 줘야 하기 때문이다. 다음과 같이 documentType을 2개 만들어 주자. 이렇게 documentType을 만들어 주면 contentlayer에서는 <code>filePathPattern</code>에 쓰인 파일 형식의 파일들을 자동으로 가져와서 <code>.contentlayer/generated</code>내의 <code>name</code>으로 정의된 폴더에 넣어 준다.</p>\n<p>예를 들어 다음과 같이 정의하면 <code>.md</code>파일은 <code>.contentlayer/generated/Post</code>폴더에, <code>.mdx</code>파일은 <code>.contentlayer/generated/MDXPost</code>폴더에 넣어 준다.</p>\n<pre><code class=\"language-js\">export const Post = defineDocumentType(() => ({\n  name: 'Post',\n  filePathPattern: '**/*.md',\n  contentType:'markdown',\n  ...postFields,\n}));\n\nexport const MDXPost = defineDocumentType(() => ({\n  name: 'MDXPost',\n  filePathPattern: '**/*.mdx',\n  contentType: 'mdx',\n  ...postFields,\n}));\n</code></pre>\n<p>그리고 github에서 제공하는 마크다운 확장(자동 링크, 각주, 표 등등)을 사용하도록 해주는 remark-gfm 설치</p>\n<pre><code>npm install remark-gfm\n</code></pre>\n<p>그리고 내 어플리케이션의 구성을 makeSource를 통해서 contentlayer에게 전달한다. 이때 플러그인 <code>remarkGfm</code>과 <code>rehypePrettyCode</code>를 import하는 걸 잊지 말자.</p>\n<pre><code class=\"language-js\">const rehypePrettyCodeOptions = {\n  theme: {\n    light: 'github-light',\n    dark: 'github-dark',\n  },\n};\n\nexport default makeSource({\n  // 마크다운 파일이 저장되어 있는 루트 폴더 내 경로\n  contentDirPath: 'posts',\n  // 사용할 document type\n  documentTypes: [MDXPost, Post],\n  // 각 contentType별로 사용할 플러그인 정의\n  markdown: {\n    remarkPlugins: [remarkGfm],\n    rehypePlugins: [[rehypePrettyCode, rehypePrettyCodeOptions]],\n  },\n  mdx: {\n    remarkPlugins: [remarkGfm],\n    rehypePlugins: [[rehypePrettyCode, rehypePrettyCodeOptions]],\n  },\n});\n</code></pre>\n<h1>2. 글 상세 페이지</h1>\n<h2>2.1. posts 페이지 내의 md, mdx 파일 동적 라우트</h2>\n<p>이제 글들을 이용해서 동적 라우터를 만들어야 한다. 이를 위해서는 getStaticPaths로 필요한 페이지 라우트를 생성하고, getStaticProps로 params를 이용해서 페이지별로 필요한 작업을 해야 한다.</p>\n<p>일단 루트의 <code>posts</code>폴더에 md파일이 바로 들어 있는 상황에서 동적 라우트를 생성해 보자. <code>pages/posts/[slug].tsx</code> 생성.</p>\n<p>이때 contentlayer가 변환해 준 모든 파일은 <code>.contentlayer/generated</code>의 <code>allDocument</code>에 저장되어 있다. <code>allPosts</code>를 통해서 변환된 md파일을, <code>allMDXPosts</code>를 통해서 변환된 mdx파일을 가져올 수도 있지만 그냥 한번에 다 가져오자.</p>\n<p>그리고 <code>.contentlayer/generated</code>에서 변환된 데이터가 어떻게 저장되는지 보면서 getStaticPaths를 작성하자. posts 뒤에 올 동적 경로는 <code>_raw.flattenedPath</code>에 저장되어 있다. 따라서 다음과 같이 작성하면 된다.</p>\n<pre><code class=\"language-tsx\">export const getStaticPaths: GetStaticPaths = () => {\n  const paths = allDocuments.map(({_raw})=>{\n    return {\n      params: {\n        slug: _raw.flattenedPath,\n      },\n    };\n  });\n  return {\n    paths,\n    fallback: false,\n  };\n};\n</code></pre>\n<p>getStaticProps에서는 <code>params.slug</code>와 같은 <code>_raw.flattenedPath</code>를 가진 문서를 찾아서 page에 Props로 넘겨주면 된다.</p>\n<pre><code class=\"language-tsx\">export const getStaticProps: GetStaticProps= ({params})=>{\n  const post = allDocuments.find(\n    (p) => p._raw.flattenedPath === params?.slug\n  )!;\n  return {\n    props: {\n      post,\n    },\n  };\n};\n</code></pre>\n<p>이제 마크다운의 몇 가지 정보들을 가져와서 동적 라우트가 잘 만들어졌는지 보자. 다음 페이지에서 간단하게 글 상세 페이지를 설계할 것이다.</p>\n<h2>2.2. 글 상세 페이지 설계</h2>\n<p>md, mdx를 구분해서 넣어 줘야 한다. 이를 무엇으로 구분할 수 있을까? <code>.contentlayer/generated</code>의 변환 파일을 보면, <code>post.body</code> 객체에 <code>code</code> 속성이 있는지로 구분할 수 있다. mdx 파일 변환 결과에는 <code>post.body.code</code>속성이 있다.</p>\n<p>md 파일의 경우 dangerouslySetInnerHTML을 이용하여 내용을 넣어주고, mdx 파일의 경우 contentlayer에서 제공하는 useMDXComponent를 사용하자.</p>\n<p>dangerouslySetInnerHTML은 XSS 공격을 당할 가능성이 있어서 보안 위험이 있지만 여기서 출처가 될 문자열은 내가 올린 마크다운 파일뿐이므로 큰 문제는 없을 것이다.</p>\n<p>일단 mdx 파일의 경우 <code>post.body.code</code>를 사용해야 하는데 md 파일의 경우 이게 없다. 따라서 이를 그냥 <code>PostPage</code> 내에서 사용할 시 undefined의 속성을 읽는다는 에러가 발생한다. 이게 있을 경우만 사용하는 MDXComponent 컴포넌트를 만들어 주자.</p>\n<pre><code class=\"language-tsx\">import { useMDXComponent } from 'next-contentlayer/hooks';\n\ninterface MDXProps{\n  code: string;\n}\n\nfunction MDXComponent(props: MDXProps) {\n  const MDX = useMDXComponent(props.code);\n  return &#x3C;MDX />;\n}\n</code></pre>\n<p>그 다음 이를 사용하는 PostPage 컴포넌트를 간단한 HTML 구조만 써서 만들어 주자. 스타일링은 일단 생각하지 말고.</p>\n<pre><code class=\"language-tsx\">function PostPage({\n  post\n}: InferGetStaticPropsType&#x3C;typeof getStaticProps>) {\n\n  return (\n    &#x3C;article>\n      &#x3C;h1>{post.title}&#x3C;/h1>\n      &#x3C;time>{post.date}&#x3C;/time>\n      &#x3C;ul>\n        {post.tags.map((tag: string)=>&#x3C;li key={tag}>{tag}&#x3C;/li>)}\n      &#x3C;/ul>\n      {'code' in post.body?\n        &#x3C;MDXComponent code={post.body.code}/>:\n        &#x3C;div dangerouslySetInnerHTML={{ __html: post.body.html }} />\n      }\n    &#x3C;/article>\n  );\n}\n</code></pre>\n<p>이렇게 하면 현재 post에 있는 모든 속성을 표시하는 글 상세 페이지가 만들어진다.</p>\n<h1>3. 동적 라우트의 개선</h1>\n<h2>3.1. 동적 라우트 개선 - 글 상세 페이지</h2>\n<p>사실 현재 생각하기로는 <code>/posts</code>폴더의 하위 폴더를 통해서 글들을 분류하고 싶다. 예를 들어서 <code>/posts</code> 내에 A,B,C,D..폴더가 있고 각각의 내부에 글들이 있다면 <code>/posts/A</code>, <code>/posts/B</code>... 이런 동적 라우트가 자동으로 생기고 각 하위 폴더 내부의 글들에 대해서도 <code>posts/A/Apost1</code>, <code>posts/A/Apost2</code>... 이런 식으로 동적 라우트가 자동으로 생기도록 하고자 한다.</p>\n<p>현재 만들고 싶은 글 분류는 cs, 프론트, 그 외 잡스러운 것들이 생각나는데, 그러니까 이런 식으로 분류하고 싶은 것이다.</p>\n<p><img src=\"/static/post-url-structure-0d5c97c8.png\" alt=\"post-url\"></p>\n<p>먼저 프로젝트 루트 디렉토리에 <code>/posts/cs</code>, <code>/posts/front</code>, <code>/posts/misc</code> 폴더를 만들었다.</p>\n<p>그리고 <code>posts/[category]</code>폴더를 생성. 그리고 위 그림과 같은 라우트를 어떻게 구현할지 한번 생각해 보자.</p>\n<p>우리가 생각하는 동적 라우트 구조에서 동적인 요소를 <code>[]</code>로 감싸서 나타내 본다면, 글 상세 페이지는 <code>/posts/[category]/[slug]</code>가 되겠다. 글 목록 페이지는 <code>/posts/[category]</code> 가 될 것이고.</p>\n<p>이때 <code>category</code>는 <code>cs</code>, <code>front</code>, <code>misc</code> 중 하나가 되고, <code>slug</code>는 각 폴더 내의 파일 이름이 된다. 이들을 어떻게 동적으로 가져올까? 글 상세 페이지에선 간단하다.</p>\n<p>먼저 <code>pages/posts/[slug].tsx</code>에 있던 내용을 <code>pages/posts/[category]/[slug].tsx</code>로 옮기고 기존 <code>[slug].tsx]</code>는 삭제한다. 놔두면 <code>[category]</code>폴더와 역할이 겹치게 되기 때문이다.</p>\n<p>위에서 썼던 <code>allDocument</code>를 이용하여 각 문서의 변환 데이터에 접근하고, <code>_raw.flattenedPath</code>를 split해서 각 요소를 가져오는 등의 방법으로 동적으로 가져올 수 있을 것이다. 뭐 이런 것이다.</p>\n<pre><code class=\"language-tsx\">export const getStaticPaths: GetStaticPaths = () => {\n  const paths = allDocuments.map(({_raw})=>{\n    const pathList=_raw.flattenedPath.split('/');\n    return {\n      params: {\n        category: pathList[0],\n        slug: pathList[1],\n      },\n    };\n  });\n  return {\n    paths,\n    fallback: false,\n  };\n};\n</code></pre>\n<p>그리고 <code>getStaticProps</code>의 경우에도 해당 페이지에 맞는 문서를 가져오기 위해 slug뿐 아니라 상위 경로인 category도 사용하도록 변경한다. 글을 렌더링하는 컴포넌트는 그대로 두면 된다.</p>\n<pre><code class=\"language-tsx\">export const getStaticProps: GetStaticProps= ({params})=>{\n  const post = allDocuments.find(\n    (p) => {\n      const temp=p._raw.flattenedPath.split('/');\n      return temp[0] === params?.category &#x26;&#x26; temp[1] === params?.slug;\n    }\n  )!;\n  return {\n    props: {\n      post,\n    },\n  };\n};\n</code></pre>\n<p>이때 만약 <code>[category]/index.tsx</code>가 아직 없으며 <code>posts</code> 폴더에 md가 폴더에 들어가 있는 게 아니라 직접 들어가 있다면 <code>_raw.flattenedPath</code>를 split한 결과가 하나밖에 없는 글 변환 데이터가 생기게 되므로 위의 <code>getStaticProps</code>에서 <code>temp[1]</code>이 없어서 에러가 뜬다. 따라서 완전해지기 위해선 다음 섹션의 글 목록 페이지를 만들어야 한다.</p>\n<p>하지만 위의 조건을 피해서 <code>posts</code>태그 안에 글(index.md)을 담은 하위 폴더들만 둔다면 동적 라우트가 잘 만들어질 것이다.</p>\n<h2>3.2. 동적 라우트 개선 - 글 목록 페이지</h2>\n<p>이제 글 목록 페이지다. <code>posts/[category]</code>에서는 <code>category</code>만 동적으로 가져와야 한다.</p>\n<p>위에서 썼던 예의 <code>flattenedPath</code>를 split한 후 적절한 인덱스를 가져올 수도 있다. 아마 <code>post._raw.flattenedPath.split('/')[0]</code>을 하면 맞을 것이다.</p>\n<p>하지만 그렇게 하면 같은 category를 가진 글이 여러 개씩 있을 것이므로 같은 라우트에 대한 작업을 여러 번 하게 된다. 내부적으로 최적화를 하는 것 같아서 같은 페이지에 대한 생성을 여러 번 하는 것 같지는 않다. 하지만 중복 작업이 좋은 건 아니다. 따라서 각 category를 유일하게 만들고자 했다.</p>\n<p>(실험을 통해 추측컨대 아마 해당 라우트에 해당하는 뭔가가 여러 개 있으면 가장 최근의 것만 정적 페이지로 만들고 이후의 요청은 만들어진 페이지를 리턴해 주는 듯 하다)</p>\n<p>그 자체가 어렵진 않다. <code>post._raw.flattenedPath.split('/')[0]</code>들을 가져와서 <code>Map</code>따위를 이용해서 중복을 없애는 방식도 가능할 테고, fs 모듈을 사용해서 폴더명을 가져올 수도 있다. 지금 당장 내게 생각나지 않는 더 좋은 방법도 있을 것이다. 하지만 앞서 말한 방식들이 뭔가 깔끔해 보이진 않는다.</p>\n<p>그런데 지금 카테고리가 그렇게 많이 필요할까? 지금 생각한 카테고리는 3개 정도고, 이 카테고리들이 블로그 헤더에 들어갈 것을 고려할 때 현재 블로그 레이아웃에서 카테고리가 5개 이상으로 늘어날 것 같지는 않다. 따라서 그냥 <code>blog-category.ts</code>를 만들어서 여기에 내가 필요한 카테고리를 담아 놓자.</p>\n<p>다음과 같은 파일을 작성하였다. 타입에 들어갈 정보는 추후 늘어날 수도 있겠지만 일단 카테고리 제목과 링크 URL 정도로 했다.</p>\n<pre><code class=\"language-ts\">// blog-category.ts\ninterface Category{\n  title: string;\n  url: string;\n}\n\nconst categoryList: Category[] = [\n  {title:'CS', url:'/posts/cs'},\n  {title:'Front', url:'/posts/front'},\n  {title:'Misc', url:'/posts/misc'},\n];\n\nexport default categoryList;\n</code></pre>\n<p>자. 이제 <code>pages/posts/[category]/index.tsx</code>를 만들어 보자. 일단 <code>getStaticPaths</code>는 <code>blog-category.ts</code>를 import하고 다음과 같이 작성하면 된다.</p>\n<pre><code class=\"language-tsx\">import categoryList from 'blog-category';\n\n/* 중간 내용들 */\n\nexport const getStaticPaths: GetStaticPaths=()=>{\n  const paths=categoryList.map((category)=>{\n    return {\n      params: {\n        // blog-category에는 대소문자가 섞여서 써있으므로 소문자 변환\n        category:category.title.toLowerCase(),\n      },\n    };\n  });\n  return {\n    paths,\n    fallback: false,\n  };\n};\n</code></pre>\n<p><code>getStaticProps</code>에서는 뭘 하면 될까? params를 통해서 category를 받으므로, 이 카테고리에 해당하는 글들을 모조리 가져온 다음 글 목록에 보여줘야 하는 정보만 골라서 페이지 컴포넌트에 props로 넘겨주면 된다. 또한 카테고리 제목도 페이지 props로 넘겨주자. 주제별 글 목록에선 당연히 보여줘야 할 테니까.</p>\n<pre><code class=\"language-tsx\">export const getStaticProps: GetStaticProps = ({params}) => {\n  const allDocumentsInCategory = allDocuments.filter((post)=>\n  // 여기서 category 타입은 string | string[] | undefined 이므로 string으로 강제해 줘야 함\n    post._raw.flattenedPath.startsWith(params?.category as string\n    ));\n\n  const postList = allDocumentsInCategory.map((post) => ({\n    title: post.title,\n    description: post.description,\n    date: post.date,\n    tags: post.tags,\n    url: post.url,\n  }));\n  // params.category는 카테고리 제목이므로 페이지에서 표시하도록 넘겨주자\n  return { props: { category:params?.category, postList } };\n};\n</code></pre>\n<p>이제 <code>blog-category.ts</code>에서 가져온 카테고리들에 대해서 각각의 페이지가 만들어지고, 페이지 컴포넌트에는 해당 카테고리에 속한 글들의 정보 중 일부(제목, 설명, 생성일 etc.)가 props로 넘어가게 된다. 이제 이 정보를 이용해서 글 목록 페이지를 만들어 보자.</p>\n<h1>4. 글 목록 페이지 설계</h1>\n<p>이제 각 카테고리별로 이 글들을 보여줄 목록 페이지를 간단히 구조만 잡아 보고 다음 글로 넘어가서 슬슬 색 같은 걸 좀 넣고 자잘한 개선들을(혹은 버그 수정) 해보자. 지금은 HTML뿐이기 때문에 블로그 페이지를 보면 눈이 썩을 것 같다. 물론 <a href=\"https://motherfuckingwebsite.com/\">motherfucking website</a>같은 디자인을 목표로 할 수도 있겠지만, 내 블로그인데 그렇게 하고 싶지는 않다.</p>\n<h2>4.1. Card 컴포넌트 재사용</h2>\n<p>생각해 보면 글 미리보기도 그냥 Card 컴포넌트를 쓸 수 있다. 제목, 설명, 이미지, 생성일, URL을 이미 Card에서 props로 받고 있으니까. 스타일링의 편의성을 생각하면 다른 컴포넌트를 쓰는 게 나을 수도 있겠지만 나는 의미상 비슷한 컴포넌트를 굳이 분리하고 싶지는 않다. 나중에 스타일링하다가 정 미칠 것 같으면 분리하겠지만 여기서는 재사용을 해보자.</p>\n<p>Card 컴포넌트가 태그를 받을 수 있도록 조금만 수정하자.</p>\n<pre><code class=\"language-tsx\">// src/components/card/index.tsx\ninterface Props{\n  title: string;\n  description: string;\n  image?: string;\n  date: string;\n  // 타입에 태그 추가. 일단 선택으로 남겨두었다.\n  tags?: string[];\n  url: string;\n}\n\nfunction Card(props: Props) {\n  // 여기서 tags도 구조 분해 할당해주는 것을 잊지 말자\n  const { title, description, image, date, tags, url } = props;\n  return (\n    &#x3C;article>\n      &#x3C;Link href={url}>\n        {\n          image ? &#x3C;Image src={image} alt={`${title} 사진`} width={50} height={50} /> : null\n        }\n        &#x3C;h3>{title}&#x3C;/h3>\n        &#x3C;p>{description}&#x3C;/p>\n        &#x3C;time>{date}&#x3C;/time>\n        {\n          // 태그 렌더링 부분이 추가됨\n          tags?&#x3C;ul>{tags.map((tag: string)=>&#x3C;li key={tag}>{tag}&#x3C;/li>)}&#x3C;/ul>:null\n        }\n      &#x3C;/Link>\n    &#x3C;/article>\n  );\n}\n</code></pre>\n<h2>4.2. 글 목록 페이지 구조</h2>\n<p>글 목록 페이지에서는 category, postList를 props로 받는다. category는 h1태그를 통해 제목으로, postList는 ul 컴포넌트 내부에 Card 컴포넌트를 통해 보여주면 된다.</p>\n<pre><code class=\"language-tsx\">// pages/posts/[category]/index.tsx\ninterface PostMetaData{\n  title: string;\n  description: string;\n  date: string;\n  tags: string[];\n  url: string;\n}\n\nfunction PostListPage({\n  category, postList,\n}: InferGetStaticPropsType&#x3C;typeof getStaticProps>) {\n  return (\n    &#x3C;main>\n      &#x3C;h1>{category}&#x3C;/h1>\n      &#x3C;ul>\n        {postList.map((post: PostMetaData) => \n          &#x3C;li key={post.url}>\n            &#x3C;Card {...post} />\n          &#x3C;/li>\n        )}\n      &#x3C;/ul>\n    &#x3C;/main>\n  );\n}\n\nexport default PostListPage;\n</code></pre>\n<p>이렇게 하고 나면 각 카테고리 페이지에서 글 목록을 보여줄 수 있다. 예를 들어 나는 cs라는 카테고리를 만들었으니 <code>/posts/cs</code>로 접속하면 글 목록이 보인다. 몇 개의 예시 글을 넣어 놓은 <code>/posts/cs</code> 화면은 다음과 같다.</p>\n<p><img src=\"/static/category-route-53f7974e.png\" alt=\"category-route\"></p>\n<p>디자인은 끔찍하지만 글 목록 페이지에 그럭저럭 있을 건 있다. 카드 컴포넌트 덕분에 링크까지 걸려 있다. 이제 다음 글에서는 색도 입히고 몇몇 버그들도 해결하여 이걸 좀 더 사람이 사는 것 같은 블로그처럼 만들어보도록 하자.</p>\n<h1>참고</h1>\n<p><a href=\"https://github.com/MiryangJung/Build-Own-blog-With-Next.js\">https://github.com/MiryangJung/Build-Own-blog-With-Next.js</a></p>\n<p><a href=\"https://yiyb-blog.vercel.app/posts/nextjs-contentlayer-blog\">https://yiyb-blog.vercel.app/posts/nextjs-contentlayer-blog</a></p>\n<p><a href=\"https://github.com/blurfx/ambienxo\">https://github.com/blurfx/ambienxo</a></p>\n<p><a href=\"https://www.contentlayer.dev/docs/getting-started\">https://www.contentlayer.dev/docs/getting-started</a></p>\n<p><a href=\"https://github.com/kagrin97/NextJS-myblog\">https://github.com/kagrin97/NextJS-myblog</a></p>",
    "excerpt": "블로그 만들기 시리즈\n|제목|링크|\n|---|---|\n|1. 기본 세팅|https://witch.work/posts/blog-remake-1|\n|2. 메인 페이지의 HTML 설계|https://witch.work/posts/blog-remake-2|\n|3. 글 상세 페이지의 구조 설계|https://witch.work/posts/blog-remake-3|\n|4. 이미지를 상대 경로로 쓸 수 있도록 하기|https://witch.work/posts/blog-rem",
    "headingTree": [
      {
        "title": "블로그 만들기 시리즈",
        "url": "#블로그-만들기-시리즈",
        "items": []
      },
      {
        "title": "1. 마크다운 가져오기",
        "url": "#1-마크다운-가져오기",
        "items": [
          {
            "title": "1.1. contentlayer 설치+설정",
            "url": "#11-contentlayer-설치설정",
            "items": []
          },
          {
            "title": "1.2. contentlayer.config.js 설정",
            "url": "#12-contentlayerconfigjs-설정",
            "items": []
          }
        ]
      },
      {
        "title": "2. 글 상세 페이지",
        "url": "#2-글-상세-페이지",
        "items": [
          {
            "title": "2.1. posts 페이지 내의 md, mdx 파일 동적 라우트",
            "url": "#21-posts-페이지-내의-md-mdx-파일-동적-라우트",
            "items": []
          },
          {
            "title": "2.2. 글 상세 페이지 설계",
            "url": "#22-글-상세-페이지-설계",
            "items": []
          }
        ]
      },
      {
        "title": "3. 동적 라우트의 개선",
        "url": "#3-동적-라우트의-개선",
        "items": [
          {
            "title": "3.1. 동적 라우트 개선 - 글 상세 페이지",
            "url": "#31-동적-라우트-개선---글-상세-페이지",
            "items": []
          },
          {
            "title": "3.2. 동적 라우트 개선 - 글 목록 페이지",
            "url": "#32-동적-라우트-개선---글-목록-페이지",
            "items": []
          }
        ]
      },
      {
        "title": "4. 글 목록 페이지 설계",
        "url": "#4-글-목록-페이지-설계",
        "items": [
          {
            "title": "4.1. Card 컴포넌트 재사용",
            "url": "#41-card-컴포넌트-재사용",
            "items": []
          },
          {
            "title": "4.2. 글 목록 페이지 구조",
            "url": "#42-글-목록-페이지-구조",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 4,
      "wordCount": 937
    },
    "url": "/posts/blog-remake-3",
    "thumbnail": {
      "local": "/static/post-url-structure-0d5c97c8.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-post-url-structure-0d5c97c8-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAcElEQVR4nDXNoRVEIQxEUXrAIakAiaSMkbGxtIDFppHUEB2bStDs2b/7r3tizqT7iggiEpFfpojwh6oC0IeZJREBwMyqSkRmtvcGkM45zDznJKIxhoi4+3fh7gDma631/6i1ttaIKOdcSum9m9m99wNRMla/d2VFkwAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "blog-remake-5",
    "title": "블로그 만들기 - 5. 디자인 이전에 남은 작업들",
    "date": "2023-05-24T01:00:00Z",
    "description": "메인 페이지의 글 프리뷰, 헤더, About 페이지, 전체 글 목록 페이지 작업",
    "tags": [
      "blog",
      "web"
    ],
    "html": "<h1>블로그 만들기 시리즈</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>제목</th><th>링크</th></tr></thead><tbody><tr><td>1. 기본 세팅</td><td><a href=\"https://witch.work/posts/blog-remake-1\">https://witch.work/posts/blog-remake-1</a></td></tr><tr><td>2. 메인 페이지의 HTML 설계</td><td><a href=\"https://witch.work/posts/blog-remake-2\">https://witch.work/posts/blog-remake-2</a></td></tr><tr><td>3. 글 상세 페이지의 구조 설계</td><td><a href=\"https://witch.work/posts/blog-remake-3\">https://witch.work/posts/blog-remake-3</a></td></tr><tr><td>4. 이미지를 상대 경로로 쓸 수 있도록 하기</td><td><a href=\"https://witch.work/posts/blog-remake-4\">https://witch.work/posts/blog-remake-4</a></td></tr><tr><td>5. 자잘한 페이지 구성 개선과 배포</td><td><a href=\"https://witch.work/posts/blog-remake-5\">https://witch.work/posts/blog-remake-5</a></td></tr><tr><td>6. 페이지 요소의 배치 설계</td><td><a href=\"https://witch.work/posts/blog-remake-6\">https://witch.work/posts/blog-remake-6</a></td></tr><tr><td>7. 메인 페이지 컴포넌트 디자인</td><td><a href=\"https://witch.work/posts/blog-remake-7\">https://witch.work/posts/blog-remake-7</a></td></tr><tr><td>8. 글 목록/내용 페이지 컴포넌트 디자인</td><td><a href=\"https://witch.work/posts/blog-remake-8\">https://witch.work/posts/blog-remake-8</a></td></tr><tr><td>9. 글 썸네일 자동 생성하기</td><td><a href=\"https://witch.work/posts/blog-remake-9\">https://witch.work/posts/blog-remake-9</a></td></tr><tr><td>10. 폰트, 카드 디자인 등의 디자인 개선</td><td><a href=\"https://witch.work/posts/blog-remake-10\">https://witch.work/posts/blog-remake-10</a></td></tr><tr><td>11. 글에 조회수 달기</td><td><a href=\"https://witch.work/posts/blog-remake-11\">https://witch.work/posts/blog-remake-11</a></td></tr><tr><td>12. 페이지 테마와 글 검색 기능</td><td><a href=\"https://witch.work/posts/blog-remake-12\">https://witch.work/posts/blog-remake-12</a></td></tr><tr><td>13. 테마 아이콘과 썸네일 레이아웃 개선 등</td><td><a href=\"https://witch.work/posts/blog-remake-13\">https://witch.work/posts/blog-remake-13</a></td></tr><tr><td>14. 글 분류를 태그 기반으로 변경</td><td><a href=\"https://witch.work/posts/blog-remake-14\">https://witch.work/posts/blog-remake-14</a></td></tr><tr><td>메인 페이지의 연산 최적화</td><td><a href=\"https://witch.work/posts/blog-opt-1\">https://witch.work/posts/blog-opt-1</a></td></tr><tr><td>글 목록 페이지네이션 만들기</td><td><a href=\"https://witch.work/posts/blog-opt-2\">https://witch.work/posts/blog-opt-2</a></td></tr><tr><td>이미지를 CDN에 올리고 placeholder 만들기</td><td><a href=\"https://witch.work/posts/blog-opt-3\">https://witch.work/posts/blog-opt-3</a></td></tr><tr><td>검색 페이지에 무한 스크롤 구현하기</td><td><a href=\"https://witch.work/posts/blog-opt-4\">https://witch.work/posts/blog-opt-4</a></td></tr></tbody></table>\n<p>페이지를 꾸며보기 전에 남은 작업이 무엇이 있는가? 물론 조회수 달기나 댓글 기능, 태그를 통한 글 목록 필터링 등 구현하고 싶은 목록은 하고 많다.</p>\n<p>하지만 당장 블로그 꼴을 갖추는 데에 필요한 자잘한 작업들, 메인 페이지에서 실제 글 목록을 표시해 주도록 하는 것, 헤더 변경, 간단한 자기소개 페이지 등을 만들어 보고 페이지를 한번 vercel로 배포해 보자. 잘 되는지는 봐야지.</p>\n<h1>1. 메인 페이지의 목록</h1>\n<p>글 목록에 너무 많은 기를 쏟았기에 벌써 메인 페이지를 어떻게 했는지 가물가물하다. 메인 페이지에서는 이런 걸 표시해 주는 게 목적이었다. 내 소개와, 프로젝트와 블로그 글 목록이다.</p>\n<p><img src=\"/static/new-home-layout-e5ed565a.png\" alt=\"home-layout\"></p>\n<p>이를 위한 <code>Category</code>와 <code>Card</code> 컴포넌트는 만들어 놓았었다. 이것들이 이제 진짜 글 목록을 표시하도록 해주자. 앞서 <code>allDocument</code>등을 통해서 글 목록을 가져오는 걸 많이 해봤으니 쉽다.</p>\n<p>아직 프로젝트 목록은 없으니 블로그 글 목록만 표시해주자. 구조를 생각해 보면, <code>blog-config.ts</code>에 지금 글들의 주제 목록(<code>/posts</code>의 하위 폴더들의 이름)이 들어 있으므로, allDocument에서 각각의 주제에 맞는 걸 찾아서 <code>Category</code>에 넘겨주면 된다.</p>\n<p>또한 메인 페이지의 글 목록에는 주제별로 몇 개씩의 글만 보여줄 것이므로 이렇게 필터링한 글 목록을 또 약간 잘라내야 한다. 따라서 글 목록을 표시하는 영역을 다음과 같이 설정한다.</p>\n<pre><code class=\"language-tsx\">{/* 글 목록은 독립적인 영역으로 존재 */}\n&#x3C;article>\n  {blogCategoryList.map((category) => {\n    const categoryPostList=allDocuments.filter((post)=>{\n      return post._raw.flattenedPath.split('/')[0]===category.title.toLowerCase();\n    }).slice(0, 3);\n    if (categoryPostList.length===0) {\n      return null;\n    }\n    return &#x3C;Category key={category.title} title={category.title} items={categoryPostList} />;\n  })\n  }\n&#x3C;/article>\n</code></pre>\n<h1>2. 헤더</h1>\n<p>헤더에 있는 메뉴들도 이제는 <code>blog-config.ts</code>에 있으므로 이걸 가져와서 헤더에 표시해 주도록 하자. <code>src/pages/index.tsx</code>에 쓰인 <code>Header</code>에 넘기는 props를 <code>blog-category.ts</code>로 가져온 걸로 변경하자.</p>\n<pre><code class=\"language-tsx\">// src/pages/index.tsx\nimport blogCategoryList from 'blog-category';\n\nexport default function Home() {\n  return (\n    &#x3C;>\n      &#x3C;Head>\n        &#x3C;title>{blogConfig.title}&#x3C;/title>\n        &#x3C;meta name='description' content={blogConfig.description} />\n        &#x3C;meta name='viewport' content='width=device-width, initial-scale=1' />\n        &#x3C;meta name='og:image' content={blogConfig.thumbnail} />\n        &#x3C;meta name='twitter:image' content={blogConfig.thumbnail} />\n        &#x3C;link rel='apple-touch-icon' sizes='180x180' href='/apple-touch-icon.png' />\n        &#x3C;link rel='icon' type='image/png' sizes='32x32' href='/favicon-32x32.png' />\n        &#x3C;link rel='icon' type='image/png' sizes='16x16' href='/favicon-16x16.png' />\n        &#x3C;link rel='manifest' href='/site.webmanifest' />\n        &#x3C;link rel='canonical' href='https://witch.work/' />\n      &#x3C;/Head>\n      &#x3C;main>\n        {/* 여기의 navList를 blogCategoryList 로 변경 */}\n        &#x3C;Header navList={blogCategoryList}/>\n        &#x3C;Profile />\n        {/* 프로젝트 목록은 독립적으로 존재 */}\n        &#x3C;article>\n          &#x3C;Category title={projectList.title} items={projectList.items} />\n        &#x3C;/article>\n        {/* 글 목록은 독립적인 영역으로 존재 */}\n        &#x3C;article>\n          &#x3C;Category title={postList.title} items={postList.items} />\n          &#x3C;Category title={postList.title} items={postList.items} />\n        &#x3C;/article>\n        &#x3C;Footer />\n      &#x3C;/main>\n    &#x3C;/>\n  );\n}\n</code></pre>\n<p>그리고 헤더에 홈으로 가는 링크, About 페이지로 가는 링크 정도는 있어야 하니까 <code>blog-category.ts</code>에 추가해주자. 이렇게 하면 각 카테고리에 해당하는 글 목록을 표시할 때 <code>home</code>, <code>about</code> 카테고리에 해당하는 글도 표시하려는 시도를 하겠지만, 어차피 그런 카테고리의 글은 없기 때문에 <code>if (categoryPostList.length===0) {return null;}</code> 이 부분에서 걸러져서 해당 글 목록은 표시되지 않을 거라 상관없다.</p>\n<pre><code class=\"language-ts\">// blog-category.ts\ninterface Category{\n  title: string;\n  url: string;\n}\n\nconst blogCategoryList: Category[] = [\n  {title:'Home', url:'/'},\n  {title:'CS', url:'/posts/cs'},\n  {title:'Front', url:'/posts/front'},\n  {title:'Misc', url:'/posts/misc'},\n  {title:'About', url:'/about'},\n];\n\nexport default blogCategoryList;\n</code></pre>\n<h1>3. 전체 글 목록 페이지</h1>\n<p>나는 UI/UX 이론을 잘 모르기 때문에 확신할 수는 없지만, 전체 글 목록 페이지도 있는 게 맞다고 보인다. <code>/posts/cs</code>, <code>/posts/front</code>, <code>/posts/misc</code>등의 카테고리 페이지에서는 각 카테고리에 해당하는 글만 보여주고, <code>/posts</code>페이지에서는 모든 글을 보여주겠다.</p>\n<p>따라서 <code>/pages/posts/index.tsx</code>를 만든다. 이 구조가 <code>/pages/posts/[category]/index.tsx</code>와 겹치는 부분이 매우 많을 거라는 건 쉽게 예상할 수 있다. 따라서 해당 파일 내용을 일단 복붙하자.</p>\n<p>여기서 고쳐야 할 내용은 무엇인가? 동적으로 경로를 생성하는 게 아니므로 <code>getStaticPaths</code>는 지워주자.</p>\n<p>또 <code>getStaticProps</code>에서 굳이 카테고리로 필터링을 할 필요가 없으니 그냥 <code>allDocuments</code>를 가져와서 필요한 정보를 끄집어내기만 하자. 또한 category도 이제 글 목록의 제목을 표시하는 역할만 하므로 그냥 \"전체 글\"로 수정해주자.</p>\n<p>나머지는 전부 똑같이 하면 된다. 이를 모두 수행하면 다음과 같아진다.</p>\n<pre><code class=\"language-tsx\">// src/pages/posts/index.tsx\nimport {\n  GetStaticProps,\n  InferGetStaticPropsType,\n} from 'next';\n\nimport Card from '@/components/card';\nimport { allDocuments } from '@/contentlayer/generated';\n\ninterface PostMetaData{\n  title: string;\n  description: string;\n  date: string;\n  tags: string[];\n  url: string;\n}\n\nfunction AllPostListPage({\n  category, postList,\n}: InferGetStaticPropsType&#x3C;typeof getStaticProps>) {\n  return (\n    &#x3C;main>\n      &#x3C;h1>{category}&#x3C;/h1>\n      &#x3C;ul>\n        {postList.map((post: PostMetaData) => \n          &#x3C;li key={post.url}>\n            &#x3C;Card {...post} />\n          &#x3C;/li>\n        )}\n      &#x3C;/ul>\n    &#x3C;/main>\n  );\n}\n\nexport default AllPostListPage;\n\nexport const getStaticProps: GetStaticProps = () => {\n  const postList = allDocuments.map((post) => ({\n    title: post.title,\n    description: post.description,\n    date: post.date,\n    tags: post.tags,\n    url: post.url,\n  }));\n  return { props: { category:'전체 글', postList } };\n};\n</code></pre>\n<p>그리고 이런 전체 글 페이지를 표시할 수 있는 링크..는 <code>blog-category.ts</code>에 추가해 줄 수도 있겠지만 사실 이렇게 헤더에까지 전체 글 목록을 넣는 게 맞는지 모르겠어서 일단 그대로 둔다.</p>\n<p>사용자가 헤더에서 전체 글을 뜻하는 내비게이션 메뉴와 각 카테고리 내비게이션의 차이를 직관적으로 이해하기 힘들 것 같다는 생각이 이유다.</p>\n<p>언젠가 쓸 일이 있을지도 모르니 남겨두자.</p>\n<h1>4. 내 소개 페이지</h1>\n<p><code>/about</code> 페이지를 만들어야 한다. <code>pages/about/index.tsx</code>를 만들자. 여기에 소개를 작성하면 된다.</p>\n<p>하지만 블로그에 아직 추가할 게 산더미같기 때문에 일단 적당히 내 이력서를 붙여넣었다. 내용이 궁금한 사람이 있다면 <a href=\"https://github.com/witch-factory/resume\">내 이력서 레포</a>로. 스타도 부탁드립니다...</p>\n<p><code>styles.module.css</code>를 작성하고 해당 이력서랑 비슷하게 className을 넣어서 작성했다. 그렇게 중요한 건 아니니 빠르게 넘어가자.</p>\n<h1>5. 배포해 보기</h1>\n<p>이제 배포를 해보고 다음 글에서는 정말로 스타일링을 해보자. 나중에는 cloudflare에 붙이겠지만, 지금은 배포 환경에서도 정상적으로 동작하는지만 확인하기 위한 것이므로 vercel로 간단히 배포하자.</p>\n<p>github에 <code>witch-next-blog</code> 레포지토리를 만들고 현재 레포에 연결하자.</p>\n<pre><code class=\"language-bash\">git init\ngit remote add origin git@github.com:witch-factory/witch-next-blog.git\ngit add .\ngit commit -m \"init\"\ngit push -u origin master\n</code></pre>\n<p>그리고 vercel을 통해 배포한다. 이건 인터넷에 이미 너무 많은 튜토리얼이 있어서 대충 넘어간다.</p>\n<p>vercel dashboard에서 Add New-Project를 누르면 자신의 github에 있는 프로젝트를 골라서 배포 가능하다. 방금 만든 <code>witch-next-blog</code>를 선택해 배포하고 이라도 닦고 오자.</p>\n<p>역시 처음부터 잘될 턱이 없다. 바~로 vercel에서 빌드 에러가 뜬다. 배포를 이래서 해봐야 한다. vercel에서 보여준 빌드 에러 메시지를 읽어보니 다음과 같다.</p>\n<pre><code class=\"language-bash\">./src/pages/index.tsx\n6:1  Error: There should be at least one empty line between import groups  import/order\n7:1  Error: There should be at least one empty line between import groups  import/order\n7:1  Error: `@/contentlayer/generated` import should occur after import of `blog-config`  import/order\n./src/pages/posts/[category]/index.tsx\n7:1  Error: There should be at least one empty line between import groups  import/order\n8:1  Error: There should be at least one empty line between import groups  import/order\n9:1  Error: `blog-category` import should occur before import of `@/contentlayer/generated`  import/order\n./src/pages/posts/index.tsx\n6:1  Error: There should be at least one empty line between import groups  import/order\ninfo  - Need to disable some ESLint rules? Learn more here: https://nextjs.org/docs/basic-features/eslint#disabling-rules\nError: Command \"npm run build\" exited with 1\nBUILD_UTILS_SPAWN_1: Command \"npm run build\" exited with 1\n</code></pre>\n<p>뭔가 eslint의 <code>import/order</code> 규칙에서 에러가 발생한 것 같다. 해당 규칙을 고칠 수도 있겠지만, 어차피 개발 환경에서는 잘 돌아가고 자동 수정도 잘 되니까 이 규칙을 에러 대신에 경고 수준으로 낮추자.</p>\n<pre><code class=\"language-json\">// .eslintrc.json\n{\n  // ...\n  \"rules\":{\n    \"import/order\": [\n      // 이게 원래는 \"error\"였다.\n      \"warn\", \n      // ...\n    ]\n  }\n  // ...\n}\n</code></pre>\n<p>이제 한번 vercel에 배포해 볼까? 그렇게 해보니 아까의 lint error는 warn으로 바뀌어서 거기까지는 잘 된다. 대신 다른 에러가 뜬다.</p>\n<pre><code>./src/pages/index.tsx:7:30\nType error: Cannot find module '@/contentlayer/generated' or its corresponding type declarations.\n</code></pre>\n<p>그럼 이걸 어떻게 고칠 수 있을까? 일단 저건 <code>tsconfig.json</code>에 정의되어 있는 별명인데, 골뱅이가 문제를 일으키는 걸지도 모르니 이걸 바꿔보자.</p>\n<pre><code class=\"language-json\">{\n  // ...\n  \"compilerOptions\":{\n    // ...\n    \"paths\": {\n      \"@/*\": [\"./src/*\"],\n      \"contentlayer/generated\": [\"./.contentlayer/generated\"],\n      \"contentlayer/generated/*\": [\"./.contentlayer/generated/*\"]\n    },\n    // ...\n  }\n  // ...\n}\n</code></pre>\n<p>그리고 이걸 import하는 측에서도 <code>@/contentlayer/generated</code>를 <code>contentlayer/generated</code>로 모두 바꿔주었다.</p>\n<p>하지만 별명만 바뀌었을 뿐 똑같은 에러가 발생하였다. 아마 <code>contentlayer/generated</code>를 사용하는 시점에 아직 해당 폴더가 생성되지 않는 것 같다.</p>\n<pre><code>Type error: Cannot find module 'contentlayer/generated' or its corresponding type declarations.\n</code></pre>\n<p>뭔가 순서가 좀 꼬인 것 같은데, 그럼 contentlayer와의 빌드가 잘 실행되는 사람들과 같은 contentlayer 버전으로 다운그레이드하면 어떨까? package.json에서 <code>contentlayer</code>와 <code>next-contentlayer</code> 버전을 ^0.3.2에서 ^0.3.0으로 바꿔봤다. 큰 의미가 없다. 다시 버전 롤백.</p>\n<p>찾아보니 pnpm 환경에서 나와 비슷한 문제에 대한 <a href=\"https://github.com/contentlayerdev/contentlayer/issues/415\">이슈가 이미 올라와 있었다.</a> 나는 pnpm을 사용하지는 않지만, 이럴 때는 뭐든 해봐야 한다. 여기서 제시한 해법대로 해보자.</p>\n<p><code>package.json</code>의 <code>build</code> 스크립트를 <code>\"contentlayer build &#x26;&#x26; next build\"</code>로 바꾸는 것이 위에 제시된 해법이다. contentlayer 빌드와 함께 빌드를 진행하는 커맨드인 듯 하다.</p>\n<pre><code class=\"language-json\">\"scripts\": {\n  \"copyimages\": \"node ./src/bin/pre-build.mjs\",\n  \"prebuild\": \"npm run copyimages\",\n  \"predev\": \"npm run copyimages\",\n  \"dev\": \"next dev\",\n  \"build\": \"contentlayer build &#x26;&#x26; next build\",\n  \"start\": \"next start\",\n  \"lint\": \"next lint\"\n},\n</code></pre>\n<p>아, 이거였다. 이게 문제였다. 이렇게 하니까 드디어 배포가 되었다.</p>\n<p><img src=\"/static/deploy-success-3d988f3a.png\" alt=\"deploy-success\"></p>\n<p>이때 배포한 페이지는 <a href=\"https://witch-next-blog-kgb1t697z-witch-factory.vercel.app/\">여기</a>에서 볼 수 있다. 조악하긴 하지만 나름 블로그에 필요한 것들은 갖추고 있다.</p>\n<h1>참고</h1>\n<p>배포 이슈 해결에 쓴 이슈 <a href=\"https://github.com/contentlayerdev/contentlayer/issues/415\">https://github.com/contentlayerdev/contentlayer/issues/415</a></p>",
    "excerpt": "블로그 만들기 시리즈\n|제목|링크|\n|---|---|\n|1. 기본 세팅|https://witch.work/posts/blog-remake-1|\n|2. 메인 페이지의 HTML 설계|https://witch.work/posts/blog-remake-2|\n|3. 글 상세 페이지의 구조 설계|https://witch.work/posts/blog-remake-3|\n|4. 이미지를 상대 경로로 쓸 수 있도록 하기|https://witch.work/posts/blog-rem",
    "headingTree": [
      {
        "title": "블로그 만들기 시리즈",
        "url": "#블로그-만들기-시리즈",
        "items": []
      },
      {
        "title": "1. 메인 페이지의 목록",
        "url": "#1-메인-페이지의-목록",
        "items": []
      },
      {
        "title": "2. 헤더",
        "url": "#2-헤더",
        "items": []
      },
      {
        "title": "3. 전체 글 목록 페이지",
        "url": "#3-전체-글-목록-페이지",
        "items": []
      },
      {
        "title": "4. 내 소개 페이지",
        "url": "#4-내-소개-페이지",
        "items": []
      },
      {
        "title": "5. 배포해 보기",
        "url": "#5-배포해-보기",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 3,
      "wordCount": 775
    },
    "url": "/posts/blog-remake-5",
    "thumbnail": {
      "local": "/static/new-home-layout-e5ed565a.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-new-home-layout-e5ed565a-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAICAIAAABVpBlvAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAgUlEQVR4nC3KoQ1DIRAAUIZgExbAdQEcDofE4ZC4k0gcGkXSpDnJKPy6qztX0pT26SeUUlJKrXUppff+uA8BANZaRCSi63oSvYQxJudcSplz7v1mZuGc894752qte28iEiEEABhjICIfIsb4WwDwXyml1hoeRPRdOefbEUJg5rXWBzBiXGBOipdvAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "blog-remake-4",
    "title": "블로그 만들기 - 4. 이미지 경로 문제 해결",
    "date": "2023-05-24T00:00:00Z",
    "description": "마크다운에서 이미지를 상대 경로로 불러올 수 있게 하자.",
    "tags": [
      "blog",
      "web"
    ],
    "html": "<h1>블로그 만들기 시리즈</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>제목</th><th>링크</th></tr></thead><tbody><tr><td>1. 기본 세팅</td><td><a href=\"https://witch.work/posts/blog-remake-1\">https://witch.work/posts/blog-remake-1</a></td></tr><tr><td>2. 메인 페이지의 HTML 설계</td><td><a href=\"https://witch.work/posts/blog-remake-2\">https://witch.work/posts/blog-remake-2</a></td></tr><tr><td>3. 글 상세 페이지의 구조 설계</td><td><a href=\"https://witch.work/posts/blog-remake-3\">https://witch.work/posts/blog-remake-3</a></td></tr><tr><td>4. 이미지를 상대 경로로 쓸 수 있도록 하기</td><td><a href=\"https://witch.work/posts/blog-remake-4\">https://witch.work/posts/blog-remake-4</a></td></tr><tr><td>5. 자잘한 페이지 구성 개선과 배포</td><td><a href=\"https://witch.work/posts/blog-remake-5\">https://witch.work/posts/blog-remake-5</a></td></tr><tr><td>6. 페이지 요소의 배치 설계</td><td><a href=\"https://witch.work/posts/blog-remake-6\">https://witch.work/posts/blog-remake-6</a></td></tr><tr><td>7. 메인 페이지 컴포넌트 디자인</td><td><a href=\"https://witch.work/posts/blog-remake-7\">https://witch.work/posts/blog-remake-7</a></td></tr><tr><td>8. 글 목록/내용 페이지 컴포넌트 디자인</td><td><a href=\"https://witch.work/posts/blog-remake-8\">https://witch.work/posts/blog-remake-8</a></td></tr><tr><td>9. 글 썸네일 자동 생성하기</td><td><a href=\"https://witch.work/posts/blog-remake-9\">https://witch.work/posts/blog-remake-9</a></td></tr><tr><td>10. 폰트, 카드 디자인 등의 디자인 개선</td><td><a href=\"https://witch.work/posts/blog-remake-10\">https://witch.work/posts/blog-remake-10</a></td></tr><tr><td>11. 글에 조회수 달기</td><td><a href=\"https://witch.work/posts/blog-remake-11\">https://witch.work/posts/blog-remake-11</a></td></tr><tr><td>12. 페이지 테마와 글 검색 기능</td><td><a href=\"https://witch.work/posts/blog-remake-12\">https://witch.work/posts/blog-remake-12</a></td></tr><tr><td>13. 테마 아이콘과 썸네일 레이아웃 개선 등</td><td><a href=\"https://witch.work/posts/blog-remake-13\">https://witch.work/posts/blog-remake-13</a></td></tr><tr><td>14. 글 분류를 태그 기반으로 변경</td><td><a href=\"https://witch.work/posts/blog-remake-14\">https://witch.work/posts/blog-remake-14</a></td></tr><tr><td>메인 페이지의 연산 최적화</td><td><a href=\"https://witch.work/posts/blog-opt-1\">https://witch.work/posts/blog-opt-1</a></td></tr><tr><td>글 목록 페이지네이션 만들기</td><td><a href=\"https://witch.work/posts/blog-opt-2\">https://witch.work/posts/blog-opt-2</a></td></tr><tr><td>이미지를 CDN에 올리고 placeholder 만들기</td><td><a href=\"https://witch.work/posts/blog-opt-3\">https://witch.work/posts/blog-opt-3</a></td></tr><tr><td>검색 페이지에 무한 스크롤 구현하기</td><td><a href=\"https://witch.work/posts/blog-opt-4\">https://witch.work/posts/blog-opt-4</a></td></tr></tbody></table>\n<h1>1. 문제 발생</h1>\n<p>앞서 만들었던 블로그는 글을 올릴 수 있으니 블로그 꼴은 갖췄다고 할 수 있겠지만, 아직 문제가 있다.</p>\n<p>지금 블로그의 각 글들은 <code>/posts/[slug]/index.md</code>라는 이름의 폴더에 저장되어 있다. 그런데 이 글에 이미지를 넣고 싶으면 어떻게 해야 할까? 나는 글과 같은 폴더에 글에 들어있는 이미지도 넣어두는 게 좋다고 생각한다. 그게 <code>![image](./img.png)</code> 와 같이 상대 경로로 불러오기 편하니까.</p>\n<p>문제는 이렇게 하면 이미지가 로드되지 않는다는 것이다. NextJS는 <code>/public</code>에 들어 있는 정적 리소스(이미지 등)만 빌드타임에 사용할 수 있기 때문이다. 따라서 빌드타임에는 <code>/posts</code>내부의 이미지가 인식되지 않아서 이미지를 불러올 수 없는 것이다.</p>\n<p>하지만 블로그에 글을 쓸 때마다 <code>/posts</code>폴더에서 글을 쓰다가 이미지에 필요해지면 <code>/public</code>폴더로 이미지를 옮기는 건 너무 한심해 보인다. 또 내가 기존 블로그에 쓴 글들도 바뀐 블로그로 옮겨야 하는데 그 몇십 개 글들의 이미지를 다 옮기고 경로 변경 하는 것도 큰일이다. 따라서 블로그 글과 같은 폴더의 이미지를 사용할 수 있도록 하는 방법을 고민하고 찾았다.</p>\n<p>역시 이미 이를 해결해 놓은 <a href=\"https://www.codeconcisely.com/posts/nextjs-relative-image-paths-in-markdown/\">사람의 블로그</a>가 있었기에 이를 참고하여 내 블로그에 맞게 사용하였다.</p>\n<p>여기서 해결한 방법은 다음과 같다.</p>\n<ol>\n<li>빌드 시 /posts 폴더의 글을 /public으로 옮기는 스크립트 짜기</li>\n<li>상대 경로를 절대 경로로 인식할 수 있도록 하기</li>\n</ol>\n<h1>2. 빌드 시에 이미지를 public으로 옮기기</h1>\n<p>해결 방법은 pre-build 스크립트를 짜서 빌드 시마다 <code>/posts</code> 폴더의 사진들을 <code>/public</code>으로 옮기는 것이다. 이를 위해 <code>fs-extra</code>라는 라이브러리를 사용했다.</p>\n<p>먼저 파일을 다루는 확장 함수 사용을 위해 <code>fs-extra</code>를 설치한다. 현재 기준으로 59.5KB이므로 그렇게 부담되는 크기는 아니다.</p>\n<pre><code>npm i fs-extra\n</code></pre>\n<p>그다음 <code>src/bin/pre-build.mjs</code>라는 파일을 만든다(어차피 prebuild 스크립트 실행시 경로를 지정해 주면 되기 때문에 경로는 크게 상관은 없다).</p>\n<p><code>.mjs</code>를 쓰는 이유는 모듈과 최상단 await을 쓰기 위해서이다.</p>\n<p>그럼 이제 우리가 해야 하는 건?</p>\n<ol>\n<li>빌드 시 기존에 <code>/public</code>에 있던 블로그 포스트 이미지들 모두 삭제</li>\n<li><code>/posts</code> 폴더의 모든 글 이미지를 <code>/public</code>으로 옮기기</li>\n</ol>\n<p>물론 업데이트만 반영할 수도 있겠지만 정적 사이트 생성기에서 굳이 그렇게 할 건 없을 것 같다.</p>\n<h2>2.1. 기존 public 폴더 청소</h2>\n<p>일단 블로그 글 이미지들을 담기 위해 <code>/public/images</code> 폴더 생성. 그리고 <code>src/bin/pre-build.mjs</code>에 다음 스크립트를 작성한다.</p>\n<pre><code class=\"language-js\">import fsExtra from 'fs-extra';\n\n// 이미지를 넣을 디렉토리\nconst imageDir='./public/images/posts';\n\nawait fsExtra.emptyDir(imageDir);\n</code></pre>\n<p>말 그대로, imageDir을 비우는 스크립트다.</p>\n<h2>2.2. 이미지 복사</h2>\n<p>서로 다른 블로그 글 간에 제목이 같은 이미지가 있을 수 있으므로, 각각에 대한 폴더를 따로 생성해 줘야 한다.</p>\n<p>먼저 sourceDir에 있는 이미지들을 targetDir로 옮기는 함수를 정의한다.</p>\n<pre><code class=\"language-js\">async function copyImage(sourceDir, targetDir, images) {\n  for (const image of images) {\n    const sourcePath = `${sourceDir}/${image}`;\n    const targetPath = `${targetDir}/${image}`;\n    await fsPromises.copyFile(sourcePath, targetPath);\n  }\n}\n</code></pre>\n<p>그리고 이제 글들이 담긴 폴더인 postDir을 정의한다,</p>\n<pre><code class=\"language-js\">// 포스트 디렉토리\nconst postDir='./posts';\n</code></pre>\n<p>posts 폴더 내에는 카테고리별로 폴더가 있고 그 카테고리 폴더들에는 글들마다의 폴더가 있다. 그것들을 모두 순회하면서 이미지를 복사해 주자.</p>\n<pre><code class=\"language-js\">const imageFileExtensions=['.png', '.jpg', '.jpeg', '.gif'];\n\nasync function copyPostDirImages() {\n  // posts 폴더 내의 카테고리들. cs, front...\n  let postCategories = (await fsPromises.readdir(postDir));\n\n  for (const category of postCategories) {\n    // 카테고리 내의 포스트 폴더들 읽어오기\n    const posts = await fsPromises.readdir(`${postDir}/${category}`);\n\n    for (const post of posts) {\n      // 글 폴더 내의 파일들\n      const postFiles = await fsPromises.readdir(`${postDir}/${category}/${post}`);\n      // 이미지 확장자를 가진 것만 골라낸다\n      const postImages=postFiles.filter((file) => imageFileExtensions.includes(path.extname(file)));\n\n      if (postImages.length) {\n        // 폴더 생성\n        await fsPromises.mkdir(`${imageDir}/${category}/${post}`, { recursive: true });\n        await copyImage(`${postDir}/${category}/${post}`, `${imageDir}/${category}/${post}`, postImages);\n      }\n    }\n  }\n}\n</code></pre>\n<p>이제 이걸 await으로 실행하면 되겠는걸?</p>\n<pre><code class=\"language-js\">await fsExtra.emptyDir(imageDir);\nawait copyPostDirImages();\n</code></pre>\n<p>그리고 이 스크립트를 package.json을 통해서 빌드나 dev 모드 실행 이전에 실행하도록 하면 되겠는걸?</p>\n<pre><code class=\"language-json\">{\n  //...\n  \"scripts\": {\n    /* 우리가 짠 스크립트를 실행하는 copyimages 커맨드를 추가하고\n     pre- 접두사를 통해 build와 dev 이전에 실행되도록 한다. */\n    \"copyimages\":\"node ./src/bin/pre-build.mjs\",\n    \"prebuild\": \"npm run copyimages\",\n    \"predev\": \"npm run copyimages\",\n    \"dev\": \"next dev\",\n    \"build\": \"next build\",\n    \"start\": \"next start\",\n    \"lint\": \"next lint\"\n  },\n  //...\n}\n</code></pre>\n<p>자 이제 <code>npm run dev</code>!</p>\n<p><img src=\"/static/copyimages-error-cd2476e9.png\" alt=\"copy-image-error\"></p>\n<p>역시 처음부터 잘되는 일은 없다.</p>\n<h2>2.3. 이미지 복사 문제 해결</h2>\n<p>에러 메시지를 보면 <code>./posts/.DS_Store</code>는 디렉토리가 아닌데 디렉토리 스캔을 하려고 해서 발생하는 에러인 것 같다. <code>.DS_Store</code>는 MacOS에서 파일의 인덱싱 최적화를 위해서 자동 생성하는 파일로 알고 있다. 아무튼 알아서 생기는 파일이다.</p>\n<p>해당 파일을 그냥 순회에서 무시하는 걸로 해결할 수도 있겠지만, 각 카테고리 폴더나 글 폴더의 리스트를 만들 때 <code>readdir</code>만 쓰는 것이 아니라 리스트 중 디렉토리인 것만 골라내도록 하자.</p>\n<p>이를 위해서는 fs에서 제공하는 <code>isDirectory</code> 함수가 있다. 이렇게 한번 써볼까?</p>\n<pre><code class=\"language-js\">let postCategories = (await fsPromises.readdir(postDir));\n// 디렉토리만 따지도록 변경\npostCategories=postCategories.filter(category=>category.isDirectory());\n</code></pre>\n<p>이렇게 하면 isDirectory가 function이 아니라는 에러가 뜬다. 현재 readdir은 인수로 받은 디렉토리 내의 파일명들을 문자열로만 반환하기 때문이다. <code>/posts</code> 폴더를 스캔한다면 [<code>DS_Store</code>, <code>cs</code>, <code>front</code>, <code>misc</code>]가 나오는 것이다. 문자열에는 당연히 isDirectory 메서드가 없으니까 에러가 뜬다.</p>\n<p>따라서 우리는 readdir을 할 때 파일의 정보까지 알아오도록 해야 한다. 이를 위해서 readdir의 options 인수에 <code>withFileTypes: true</code>를 넣어주자. 그러면 readdir이 파일명 뿐만 아니라 파일의 정보까지 들어있는 <code>fs.Dirent</code> 객체를 얻어온다.</p>\n<pre><code class=\"language-js\">// posts 폴더 내의 카테고리들. cs, front...\nlet postCategories = (await fsPromises.readdir(postDir), {withFileTypes:true});\n// 디렉토리만 따지도록 변경\npostCategories=postCategories.filter(category=>category.isDirectory());\n</code></pre>\n<p>이제 주의해야 할 것은 <code>postCategories</code>에서 폴더의 이름을 얻어오려면 원소에 바로 접근하는 게 아니라 배열의 원소인 <code>fs.Dirent</code>의 name 프로퍼티에 접근해야 한다는 것이다. 따라서 다음과 같이 짠다.</p>\n<pre><code class=\"language-js\">async function copyPostDirImages() {\n  // posts 폴더 내의 카테고리들. cs, front...\n  let postCategories = (await fsPromises.readdir(postDir, {withFileTypes:true}));\n  // 디렉토리만 따지도록 변경\n  postCategories=postCategories.filter(category=>category.isDirectory());\n\n  for (const _category of postCategories) {\n    // 카테고리 내의 포스트 폴더들 읽어오기\n    const category=_category.name;\n    let posts = await fsPromises.readdir(`${postDir}/${category}`, {withFileTypes:true});\n    // 디렉토리만 따지도록 변경\n    posts=posts.filter(post=>post.isDirectory());\n\n    for (const _post of posts) {\n      const post=_post.name;\n      // 글 폴더 내의 파일들\n      const postFiles = await fsPromises.readdir(`${postDir}/${category}/${post}`);\n      // 이미지 확장자를 가진 것만 골라낸다\n      const postImages=postFiles.filter((file) => imageFileExtensions.includes(path.extname(file)));\n\n      if (postImages.length) {\n        // 폴더 생성\n        await fsPromises.mkdir(`${imageDir}/${category}/${post}`, { recursive: true });\n        await copyImage(`${postDir}/${category}/${post}`, `${imageDir}/${category}/${post}`, postImages);\n      }\n    }\n  }\n}\n</code></pre>\n<p>반복되는 부분을 적당히 함수로 빼서 정리해 보면 이렇게 된다.</p>\n<pre><code class=\"language-js\">const imageFileExtensions=['.png', '.jpg', '.jpeg', '.gif'];\n\nasync function getInnerDirectories(dir) {\n  const files = await fsPromises.readdir(dir, {withFileTypes:true});\n  return files.filter(file=>file.isDirectory());\n}\n\nasync function getInnerImages(dir) {\n  const files=await fsPromises.readdir(dir);\n  return files.filter((file) => imageFileExtensions.includes(path.extname(file)));\n}\n\nasync function copyPostDirImages() {\n  // posts 폴더 내의 카테고리들. cs, front...\n  const postCategories = await getInnerDirectories(postDir);\n\n  for (const _category of postCategories) {\n    // 카테고리 내의 포스트 폴더들 읽어오기\n    const category=_category.name;\n    const posts=await getInnerDirectories(`${postDir}/${category}`);\n\n    for (const _post of posts) {\n      const post=_post.name;\n      const postImages=await getInnerImages(`${postDir}/${category}/${post}`);\n\n      if (postImages.length) {\n        // 폴더 생성\n        await fsPromises.mkdir(`${imageDir}/${category}/${post}`, { recursive: true });\n        await copyImage(`${postDir}/${category}/${post}`, `${imageDir}/${category}/${post}`, postImages);\n      }\n    }\n  }\n}\n</code></pre>\n<h1>3. 상대 경로를 절대 경로로 인식할 수 있도록 하기</h1>\n<p>위의 작업을 완료하였다면, <code>/posts/cs/os-1</code>폴더에 글을 쓰고 같은 경로에 이미지를 넣고 빌드하면 <code>/images/posts/cs/os-1/</code>라는 경로를 통해서 이미지를 쓸 수 있을 것이다. 만약 위의 <code>pre-build.mjs</code>파일의 <code>imageDir</code>을 좀 만져줬다면 <code>/posts/cs/os-1</code>을 통한 접근도 가능하다.</p>\n<p>하지만 블로그에 글 쓰면서 이미지를 넣을 때 저따위의 이미지 절대경로를 설정해 주고 싶은 사람은 거의 없을 것이다. 따라서 이를 상대 경로로 바꿔주는 작업을 해주자. <a href=\"https://www.codeconcisely.com/posts/nextjs-relative-image-paths-in-markdown/\">이곳</a>을 참고해서 내 블로그에 맞게 수정했다.</p>\n<h2>3.1. 방법 설계</h2>\n<p>앞서 말했듯이 NextJS는 <code>/public</code>에 있는 정적 리소스만 빌드타임에 사용할 수 있다. 그래서 우리는 앞서 <code>/posts</code>폴더에 있는 사진들을 빌드 시에 <code>/public</code>으로 적절히 옮겨 주었다.</p>\n<p>그럼 마크다운(여기서 마크다운이란 md, mdx 파일을 모두 이른다)에서 이미지를 상대 경로로 불러올 수 있도록 하기 위해서는 어떻게 해야 할까?</p>\n<p>마크다운 파일은 현재 contentlayer를 통해 HTML 혹은 코드로 변환되는데 이 과정에서 이미지 출처에 명시된 상대 경로를 절대 경로로 바꿔주는 작업을 추가하면 된다.</p>\n<p>contentlayer에서는 markdown을 다루는 데에 remark 플러그인을 사용할 수 있도록 하므로 remark 플러그인을 사용하자.</p>\n<p><img src=\"/static/how-contentlayer-work-404d7b35.png\" alt=\"how-contentlayer-works\"></p>\n<p>또한 우리는 md 문서에서 이미지들을 찾아야 하는데, remark에서는 md파일을 JSON object 형식으로 쓰인 AST로 바꿔 주는 기능을 제공하기에 우리의 목적에 매우 잘 부합한다고 하겠다.</p>\n<blockquote>\n<p>마크다운을 HTML로 변환하는 기능만 필요하다면 micromark를 쓰는 게 좋다. remark또한 그걸 할 수 있지만 remark는 그것보다는 AST(Abstract Syntax Tree)를 만들고 그걸 변환하기 위한 플러그인을 제공하는 데에 초점이 맞춰져 있다. (remark github README에서 발췌)</p>\n</blockquote>\n<p>따라서 우리는 remark 플러그인을 만들어서 contentlayer에 적용하면 된다.</p>\n<h2>3.2. remark 플러그인 만들기</h2>\n<p><code>/src/plugins/change-image-src.mjs</code>파일 생성. ES 모듈을 쓰기 위해 mjs혹은 ts 파일을 써야 한다. 그러나 ts를 쓰려면 우리는 마크다운 AST의 type을 사용해야 하는데 이런 작업에 그렇게까지 하는 건 낭비라고 생각했다. 따라서 mjs를 쓰기로 했다.</p>\n<p>이 파일에선, 최종적으로 글에 들어간 이미지들을 찾아서 src 프로퍼티에 있는 상대 경로들을 몽땅 절대 경로로 바꿔 주는 플러그인을 짜면 된다. 그럼 뭐부터 해야 할까? 플러그인 꼴부터 갖춰야 한다.</p>\n<p>그러니 먼저 remark 플러그인의 포맷부터 잡아 보자. remark 플러그인 함수는 tree, file을 인수로 받는 함수를 리턴해야 한다. tree는 mdast이고 file은 contentlayer에서 제공하는 파일 정보를 담고 있는 객체다. 이 file인수를 통해서 우리는 파일의 경로를 알 수 있게 된다.</p>\n<pre><code class=\"language-js\">// src/plugins/change-image-src.mjs\nexport default function changeImageSrc() {\n  return function(tree, file) {\n    // tree, file을 가지고 뭔가 해보는 코드\n  };\n}\n</code></pre>\n<p>우리가 md파일을 변환한 AST는 여기서 리턴한 함수를 거칠 것이다. 그럼 이 함수에선 뭘 해야 할까? 트리를 순회하면서 이미지를 찾고 src 프로퍼티를 모두 절대 경로로 바꿔주면 된다.</p>\n<p>먼저 순회 같은 경우, remark에서 사용하는 신택스 트리는 <a href=\"https://github.com/syntax-tree/mdast\">mdast</a>에 정의되어 있다. 이 트리를 통해서 우리는 노드들을 순회할 수 있다. 또한 이런 신택스 트리 포맷은 <a href=\"https://github.com/syntax-tree/unist\">Unist(Universal Syntax Tree)</a>를 통해서 정의되는데, 이들을 순회하기 위한 유틸리티 라이브러리로 <a href=\"https://github.com/syntax-tree/unist-util-visit\">unist-util-visit</a>이 나와 있다. 따라서 이를 설치하자.</p>\n<pre><code>npm install unist-util-visit\n</code></pre>\n<p>이 라이브러리의 <code>visit(tree[, test], visitor[, reverse])</code>을 이용하면 preorder의 depth-first-search를 하면서 각 노드에 대해 visitor 함수를 실행하여 HTML AST의 각 노드를 편집할 수 있다.</p>\n<pre><code class=\"language-js\">export default function changeImageSrc() {\n  return function(tree, file) {\n    const filePath=file.data.rawDocumentData.flattenedPath;\n    visit(tree, function() {});\n  };\n}\n</code></pre>\n<p>노드들을 순회하면서 이미지들을 어떻게 찾을까? contentlayer에서 HTML로 변환한 md 글들에 들어간 사진을 보면 전부 <code>p</code> 태그 내의 <code>img</code>태그로 들어가 있다. 이를 감지하면 된다. 먼저 visit 함수의 2번째 인수로 특정 노드의 type을 나타내는 문자열을 넣어 주면 해당 노드에 대해서만 visitor 함수를 실행하게 된다. <a href=\"https://github.com/syntax-tree/mdast#paragraph\">mdast</a>에 따르면 <code>p</code> 태그는 <code>paragraph</code>라는 type을 가지고 있다. 따라서 이를 넣어주자.</p>\n<p>이렇게 찾은 <code>p</code>태그는 visitor 함수의 인수로 들어가게 되는데 거기서 해당 노드의 children 중 img태그를 찾아 url을 바꿔주자.</p>\n<pre><code class=\"language-js\">const imageDirInPublic = 'images/posts';\n\nexport default function changeImageSrc() {\n  return function(tree, file) {\n    const filePath=file.data.rawDocumentData.flattenedPath;\n    visit(tree, 'paragraph', function(node) {\n      const image=node.children.find(child=>child.type==='image');\n\n      if (image) {\n        const fileName=image.url.replace('./', '');\n        image.url=`/${imageDirInPublic}/${filePath}/${fileName}`;\n      }\n    });\n  };\n}\n</code></pre>\n<p>md파일이 변환된 트리가 들어오면->트리를 순회하면서 p태그 내에 있는 img 태그를 찾고->그런 게 있다면 해당 img 태그의 url을 바꿔주는 플러그인이 완성되었다.</p>\n<h3>3.2.1. 이미지 경로 새로 만들기에 대한 설명</h3>\n<pre><code class=\"language-js\">if (image) {\n  const fileName=image.url.replace('./', '');\n  image.url=`/${imageDirInPublic}/${filePath}/${fileName}`;\n}\n</code></pre>\n<p>이 부분 얘기다.</p>\n<p>이미지 경로를 만드는 부분에 대한 설명을 약간 들이면, 우리는 블로그에 있는 사진들을 <code>./A.png</code> 같은 상대 경로로 불러올 것이다.(단 모든 상대 경로를 포괄하는 것은 아니고, <code>../</code>같은 건 안된다. 그냥 블로그 글과 같은 경로에 있는 사진만 사용한다고 가정하자)</p>\n<p>따라서 fileName은 기존 경로에서 <code>./</code>만 떼면 된다.</p>\n<p>그리고 리턴하는 함수에서 받는 file인수는 contentlayer에서 변환한 것이기 때문에 file.data에는 <code>.contentlayer/generated</code>에 있는 변환 파일에 있던 정보들이 비슷하게 들어 있다. 따라서 <code>/posts</code>이하의 글 경로들을 받아오기 위해서는 <code>file.data.rawDocumentData.flattenedPath</code>를 사용하면 된다. 이게 바로 위에서 사용한 <code>filePath</code>이다.</p>\n<p>또한 우리가 사용할 이미지들은 빌드 시점에 <code>/public/images/posts</code>에 들어 있으며, 변환된 글들은 <code>/posts</code>에 있지만 contentlayer에서 md 문서 변환 결과를 만들 때 <code>/posts</code>경로 내에 있는 것만 했으므로 <code>flattenedPath</code>에는 <code>/posts</code>가 없다.</p>\n<p>따라서 우리가 file의 <code>flattenedPath</code>를 이용해서 이미지를 불러오기 위해서는 <code>/public</code>내의 이미지 경로를 알려주는 <code>imageDirInPublic</code>도 사용해야 한다. 그렇게 만들어진 게 위의 새로운 이미지 URL이다.</p>\n<pre><code class=\"language-js\">image.url=`/${imageDirInPublic}/${filePath}/${fileName}`;\n</code></pre>\n<h1>4. 실제 적용</h1>\n<p>이렇게 하고 나서 내 기존 블로그의 글들을 모두 옮긴 후 한번 빌드해 보았다. 문서들을 생성하는 데에 약 15초 정도가 걸린다. 세부적인 벤치마크를 해볼 수도 있겠지만, 지금 내 블로그 글이 140개 정도 있고 이미지를 다 합쳐 70메가쯤 있는데 그걸 빌드하는 데 15초 걸리는 게 그렇게 나쁘지는 않아 보인다. 언젠가 최적화할 일이 있을지도 모르지만.</p>\n<p>그리고 빌드한 이후로는 public/images/posts에는 글들의 이미지들이 잘 들어가 있었다. 하지만 이 이미지들은 어차피 <code>/posts</code>에 들어 있을 텐데 이것까지 굳이 github에 올릴 이유는 없다. 그러니 해당 폴더를 <code>.gitignore</code>에 추가해 주자.</p>\n<pre><code># .gitignore\n/public/images/posts\n/public/images/posts/*\n</code></pre>\n<p>그리고 다음 글에서는 대충하고 넘어갔던 작업들을 해보자. 가령 메인 페이지에서 지금은 그냥 임시로 만든 배열의 내용을 렌더링하고 있는데, 이를 제대로 글 목록을 불러와서 표시하게 하는 것과 전체 글 목록 페이지를 만드는 등의 작업들이다.</p>\n<h1>참고</h1>\n<p>나와 같은 고민을 한 사람이 이미 있었다. 그래서 그 사람이 만든 글을 참고했다. <a href=\"https://www.codeconcisely.com/posts/nextjs-storing-images-next-to-markdown/\">https://www.codeconcisely.com/posts/nextjs-storing-images-next-to-markdown/</a></p>\n<p>remark 플러그인을 만들기 위해 remark github의 설명을 참고했다. <a href=\"https://github.com/remarkjs/remark\">https://github.com/remarkjs/remark</a></p>\n<p><a href=\"https://github.com/syntax-tree/mdast\">https://github.com/syntax-tree/mdast</a></p>\n<p><a href=\"https://github.com/syntax-tree/unist\">https://github.com/syntax-tree/unist</a></p>\n<p><a href=\"https://swizec.com/blog/how-to-build-a-remark-plugin-to-supercharge-your-static-site/\">https://swizec.com/blog/how-to-build-a-remark-plugin-to-supercharge-your-static-site/</a></p>",
    "excerpt": "블로그 만들기 시리즈\n|제목|링크|\n|---|---|\n|1. 기본 세팅|https://witch.work/posts/blog-remake-1|\n|2. 메인 페이지의 HTML 설계|https://witch.work/posts/blog-remake-2|\n|3. 글 상세 페이지의 구조 설계|https://witch.work/posts/blog-remake-3|\n|4. 이미지를 상대 경로로 쓸 수 있도록 하기|https://witch.work/posts/blog-rem",
    "headingTree": [
      {
        "title": "블로그 만들기 시리즈",
        "url": "#블로그-만들기-시리즈",
        "items": []
      },
      {
        "title": "1. 문제 발생",
        "url": "#1-문제-발생",
        "items": []
      },
      {
        "title": "2. 빌드 시에 이미지를 public으로 옮기기",
        "url": "#2-빌드-시에-이미지를-public으로-옮기기",
        "items": [
          {
            "title": "2.1. 기존 public 폴더 청소",
            "url": "#21-기존-public-폴더-청소",
            "items": []
          },
          {
            "title": "2.2. 이미지 복사",
            "url": "#22-이미지-복사",
            "items": []
          },
          {
            "title": "2.3. 이미지 복사 문제 해결",
            "url": "#23-이미지-복사-문제-해결",
            "items": []
          }
        ]
      },
      {
        "title": "3. 상대 경로를 절대 경로로 인식할 수 있도록 하기",
        "url": "#3-상대-경로를-절대-경로로-인식할-수-있도록-하기",
        "items": [
          {
            "title": "3.1. 방법 설계",
            "url": "#31-방법-설계",
            "items": []
          },
          {
            "title": "3.2. remark 플러그인 만들기",
            "url": "#32-remark-플러그인-만들기",
            "items": [
              {
                "title": "3.2.1. 이미지 경로 새로 만들기에 대한 설명",
                "url": "#321-이미지-경로-새로-만들기에-대한-설명",
                "items": []
              }
            ]
          }
        ]
      },
      {
        "title": "4. 실제 적용",
        "url": "#4-실제-적용",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 3,
      "wordCount": 880
    },
    "url": "/posts/blog-remake-4",
    "thumbnail": {
      "local": "/static/copyimages-error-cd2476e9.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-copyimages-error-cd2476e9-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAFCAIAAAD38zoCAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAdklEQVR4nGOwtrIWFhaOiIhYsWLF/PnzV4DBuXPnGPIL8j08PBwcHDZt2vQfCTBUVVVZW1lbWFgEBAQ0Nzf39PSsWLHi69evDK5urhHx4Ru3bDxy5MgmMNi9e/fr168ZioqK5i2e9+DZg99/fkMMef369f///wGYf0yudxzOLgAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "blog-remake-7",
    "title": "블로그 만들기 - 7. 메인 페이지 컴포넌트 디자인",
    "date": "2023-05-26T01:00:00Z",
    "description": "메인 페이지 CSS를 작성해 보자",
    "tags": [
      "blog",
      "web"
    ],
    "html": "<h1>블로그 만들기 시리즈</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>제목</th><th>링크</th></tr></thead><tbody><tr><td>1. 기본 세팅</td><td><a href=\"https://witch.work/posts/blog-remake-1\">https://witch.work/posts/blog-remake-1</a></td></tr><tr><td>2. 메인 페이지의 HTML 설계</td><td><a href=\"https://witch.work/posts/blog-remake-2\">https://witch.work/posts/blog-remake-2</a></td></tr><tr><td>3. 글 상세 페이지의 구조 설계</td><td><a href=\"https://witch.work/posts/blog-remake-3\">https://witch.work/posts/blog-remake-3</a></td></tr><tr><td>4. 이미지를 상대 경로로 쓸 수 있도록 하기</td><td><a href=\"https://witch.work/posts/blog-remake-4\">https://witch.work/posts/blog-remake-4</a></td></tr><tr><td>5. 자잘한 페이지 구성 개선과 배포</td><td><a href=\"https://witch.work/posts/blog-remake-5\">https://witch.work/posts/blog-remake-5</a></td></tr><tr><td>6. 페이지 요소의 배치 설계</td><td><a href=\"https://witch.work/posts/blog-remake-6\">https://witch.work/posts/blog-remake-6</a></td></tr><tr><td>7. 메인 페이지 컴포넌트 디자인</td><td><a href=\"https://witch.work/posts/blog-remake-7\">https://witch.work/posts/blog-remake-7</a></td></tr><tr><td>8. 글 목록/내용 페이지 컴포넌트 디자인</td><td><a href=\"https://witch.work/posts/blog-remake-8\">https://witch.work/posts/blog-remake-8</a></td></tr><tr><td>9. 글 썸네일 자동 생성하기</td><td><a href=\"https://witch.work/posts/blog-remake-9\">https://witch.work/posts/blog-remake-9</a></td></tr><tr><td>10. 폰트, 카드 디자인 등의 디자인 개선</td><td><a href=\"https://witch.work/posts/blog-remake-10\">https://witch.work/posts/blog-remake-10</a></td></tr><tr><td>11. 글에 조회수 달기</td><td><a href=\"https://witch.work/posts/blog-remake-11\">https://witch.work/posts/blog-remake-11</a></td></tr><tr><td>12. 페이지 테마와 글 검색 기능</td><td><a href=\"https://witch.work/posts/blog-remake-12\">https://witch.work/posts/blog-remake-12</a></td></tr><tr><td>13. 테마 아이콘과 썸네일 레이아웃 개선 등</td><td><a href=\"https://witch.work/posts/blog-remake-13\">https://witch.work/posts/blog-remake-13</a></td></tr><tr><td>14. 글 분류를 태그 기반으로 변경</td><td><a href=\"https://witch.work/posts/blog-remake-14\">https://witch.work/posts/blog-remake-14</a></td></tr><tr><td>메인 페이지의 연산 최적화</td><td><a href=\"https://witch.work/posts/blog-opt-1\">https://witch.work/posts/blog-opt-1</a></td></tr><tr><td>글 목록 페이지네이션 만들기</td><td><a href=\"https://witch.work/posts/blog-opt-2\">https://witch.work/posts/blog-opt-2</a></td></tr><tr><td>이미지를 CDN에 올리고 placeholder 만들기</td><td><a href=\"https://witch.work/posts/blog-opt-3\">https://witch.work/posts/blog-opt-3</a></td></tr><tr><td>검색 페이지에 무한 스크롤 구현하기</td><td><a href=\"https://witch.work/posts/blog-opt-4\">https://witch.work/posts/blog-opt-4</a></td></tr></tbody></table>\n<p>내가 디자이너는 아니지만, 최선을 다해서 메인 페이지를 만들어 보는 과정을 담았다. 내게는 화려한 디자인을 제어할 역량이 없으므로 너무 화려하게 꾸미지 않도록 노력했다.</p>\n<h1>0. 색 정의</h1>\n<p>그전에 <code>styles/globals.css</code>에 색 변수를 지정해 두자. <a href=\"https://yeun.github.io/open-color/\">open color</a>의 gray, indigo 색을 사용하였다.</p>\n<p>그리고 body의 기본 margin 8px를 없애 주는 css도 추가했다.</p>\n<pre><code class=\"language-css\">// styles/globals.css\n:root{\n  --white:#fff;\n\n  --gray0:#f8f9fa;\n  --gray1:#f1f3f5;\n  --gray2:#e9ecef;\n  --gray3:#dee2e6;\n  --gray4:#ced4da;\n  --gray5:#adb5bd;\n  --gray6:#868e96;\n  --gray7:#495057;\n  --gray8:#343a40;\n  --gray9:#212529;\n\n\n  --indigo0:#edf2ff;\n  --indigo1:#dbe4ff;\n  --indigo2:#bac8ff;\n  --indigo3:#91a7ff;\n  --indigo4:#748ffc;\n  --indigo5:#5c7cfa;\n  --indigo6:#4c6ef5;\n  --indigo7:#4263eb;\n  --indigo8:#3b5bdb;\n  --indigo9:#364fc7;\n}\n\nbody{\n  margin:0;\n}\n</code></pre>\n<h1>1. 헤더 컴포넌트</h1>\n<p>모든 페이지에 공통으로 들어가 있는 헤더와 푸터로 시작하겠다.</p>\n<p>부대찌개를 먹으며 고민한 결과 다음과 같은 배치를 생각했다. 그리고 About의 경우에는 다른 게시판 분류와 다른 느낌이기 때문에 살짝 다른 색으로 구분해 줄까 하고 있다. 나는 디자이너가 아니지만 최선을 다해보았다.</p>\n<p><img src=\"/static/header-layout-4a73c159.png\" alt=\"header-layout\"></p>\n<h2>1.1. 컨테이너</h2>\n<p>헤더 높이는 다른 컨텐츠와의 조화를 생각할 때 50px가 가장 적절해 보였다. 그리고 늘 상단에 고정시켜야 하므로 <code>position:sticky;</code>와 <code>top:0</code>. 다른 페이지 요소들과 같이 <code>width:100%; max-width: 60rem;</code>로 너비 제한. <code>margin:0 auto</code>로 가운데 정렬.</p>\n<p>배경색은 흰색 설정 후 다른 컨텐츠와의 구분을 위해 연한 회색의 하단 테두리 지정.</p>\n<pre><code class=\"language-css\">.header{\n  height:50px;\n  position:sticky;\n  top:0;\n  width:100%;\n  max-width:60rem;\n  margin:0 auto;\n  background-color:#FFFFFF;\n  border-bottom:1px solid var(--gray3);\n}\n</code></pre>\n<p>그다음은 header 컴포넌트 내의 nav 컴포넌트. 여기에 메뉴들이 본격적으로 들어갈 텐데, 여기서도 width를 100%로 설정하면 내비게이션이 너무 양쪽에 딱 붙어 보일 것이다. 따라서 <code>width:92%</code>로 설정한다.</p>\n<p>또한 모바일 환경이든 PC환경이든 내부 요소가 양쪽에 몰려 있어야 하기에(게시판 메뉴들은 후에 div 박스로 묶을 것이다) flex를 space-between으로 설정. height는 당연히 100%, margin 0 auto.</p>\n<pre><code class=\"language-css\">.header__nav{\n  width:92%;\n  display:flex;\n  flex-direction:row;\n  justify-content:space-between;\n  height:100%;\n  margin:0 auto;\n}\n</code></pre>\n<h2>1.1. 홈 버튼</h2>\n<p>이제 홈 버튼을 만들어 주자. <code>src/components/header/homeButton</code>에 index.tsx와 styles.module.css 생성</p>\n<p>index.tsx의 HomeButton 컴포넌트 구조는 다음과 같이 한다. 링크 내부에 div를 넣고 거기에 사진과 텍스트를 넣은 간단한 구조다.</p>\n<pre><code class=\"language-tsx\">import Image from 'next/image';\nimport Link from 'next/link';\n\nimport blogConfig from 'blog-config';\n\nimport styles from './styles.module.css';\n\nfunction HomeButton() {\n  return (\n    &#x3C;Link href='/' aria-label='Home' className={styles.link}>\n      &#x3C;div className={styles.container}>\n        &#x3C;Image src='/witch-hat.svg' alt='logo' width={40} height={40} />\n        {blogConfig.title}\n      &#x3C;/div>\n    &#x3C;/Link>\n  );\n}\n\nexport default HomeButton;\n</code></pre>\n<p>그리고 링크에는 너비와 높이를 주기 위해서 block으로 설정하고 내용에 딱 맞게 너비를 설정. 링크에 기본적으로 들어가는 스타일도 없애준다. 또한 약간의 패딩을 추가하고 마우스 호버시 연한 회색의 배경색을 준다.</p>\n<pre><code class=\"language-css\">.link{\n  text-decoration:none;\n  color:#000;\n  display:block;\n  width:fit-content;\n  padding:5px;\n}\n\n.link:hover{\n  background:var(--gray2)\n}\n</code></pre>\n<p>그리고 홈 버튼의 내부 요소 배치를 위해 flex 설정을 해준 후 너비와 높이를 100%로 설정한다. 그리고 내부 요소들을 세로축에서 가운데 정렬하고 사이에 5px의 간격을 준다.</p>\n<pre><code class=\"language-css\">.container{\n  display:flex;\n  flex-direction:row;\n  align-items:center;\n  gap:5px;\n  width:100%;\n  height:100%;\n  font-size:24px;\n}\n</code></pre>\n<p>헤더에 들어갈 이미지는 적당히 <a href=\"https://pixabay.com/vectors/magician-wizard-hat-magic-mystery-41104/\">픽사베이에서 마녀 모자를 찾아서</a>넣었다.</p>\n<h2>1.2. 내비게이션 메뉴</h2>\n<p>헤더 컴포넌트의 가장 큰 벽이다. 화면 너비가 작을 경우 드롭다운 메뉴를 보여줘야 하고 너비가 넓을 땐 그냥 일반적인 메뉴를 보여줘야 한다.</p>\n<p>일단 <code>src/components/header/menu</code>에 index.tsx와 styles.module.css 생성.</p>\n<p>이 내비게이션에서 레이아웃을 신경써야 할 부분은 다음과 같다.</p>\n<ol>\n<li>컨테이너</li>\n<li>드롭다운 메뉴의 토글 버튼</li>\n<li>드롭다운 메뉴 본체</li>\n</ol>\n<p>그럼 컨테이너에는 별거 필요 없다. 그냥 크기만 컨텐츠에 맞게 설정해 주자.</p>\n<pre><code class=\"language-css\">.container{\n  display:flex;\n  flex-direction:column;\n  width:fit-content;\n  height:100%;\n  font-size:20px;\n}\n</code></pre>\n<p>이제 버튼을 만들어 보자. <code>menu/toggler</code>에 index.tsx와 styles.module.css를 생성.</p>\n<p>사실 버튼에 주어질 스타일은 별거 없다. 그냥 테두리와 배경을 없애주고 적절한 너비, 높이를 주는 것. 그리고 호버 시 배경색을 연한 회색으로 주는 것 정도.</p>\n<pre><code class=\"language-css\">// src/components/header/menu/toggler/styles.module.css\n.button{\n  border:none;\n  background:transparent;\n  width:50px;\n  height:100%;\n}\n\n.button:hover{\n  cursor:pointer;\n  background:var(--gray2);\n}\n</code></pre>\n<p>그리고 버튼 내부에 들어갈 아이콘을 포함해서 컴포넌트를 작성하자. 이때 원래는 <code>react-icons</code>를 쓰려 했으나 많이 쓰지도 않을 아이콘을 위해 패키지 크기가 55MB나 하는 패키지를 깔고 싶지 않아서 그냥 적당한 svg사진을 찾아와서 썼다.</p>\n<p>또한 메뉴의 열림 여부에 따라서 표시하는 아이콘이 달라져야 하므로 메뉴가 열려 있는지 여부와 토글 함수를 props로 받도록 했다.</p>\n<pre><code class=\"language-tsx\">import Image from 'next/image';\n\nimport styles from './styles.module.css';\n\nfunction Toggler({isMenuOpen, toggle}: {isMenuOpen: boolean, toggle: () => void}) {\n  return (\n    &#x3C;button className={styles.button} onClick={toggle}>\n      &#x3C;Image\n        src={isMenuOpen?'/cancel-32x32.svg':'/hamburger-32x32.svg'} \n        alt='Menu' \n        width={32} \n        height={32} \n      />\n    &#x3C;/button>\n  );\n}\n\nexport default Toggler;\n</code></pre>\n<p>이제 메뉴 본체를 만들어 보자. <code>menu/dropdown</code>에 index.tsx와 styles.module.css를 생성.</p>\n<p>여기서 해야 할 건 뭘까? 가장 먼저 메뉴를 보여줘야 한다. 또한 모바일 환경에서는 메뉴가 드롭다운으로 보여야 하고 PC 환경에서는 그냥 보여야 한다. 그리고 메뉴 열림 여부에 따라 보이고 말고를 결정할 수 있어야 한다.</p>\n<p>따라서 navList와 isMenuOpen을 Dropdown 컴포넌트의 props로 받아야 한다는 것을 생각할 수 있다. 우선 다음과 같이 구조를 잡는다.</p>\n<pre><code class=\"language-tsx\">// src/components/header/menu/dropdown/index.tsx\nimport Link from 'next/link';\n\nimport styles from './styles.module.css';\n\ninterface PropsItem{\n  title: string;\n  url: string;\n}\n\nfunction Dropdown({navList, isMenuOpen}: {navList: PropsItem[], isMenuOpen: boolean}) {\n  return (\n    &#x3C;ul>\n      {navList.map((item) => {\n        return (\n          &#x3C;li key={item.title}>\n            &#x3C;Link\n              href={item.url} \n              aria-label={item.title} \n            >\n              {item.title}\n            &#x3C;/Link>\n          &#x3C;/li>\n        );\n      })}\n    &#x3C;/ul>\n  );\n}\n\nexport default Dropdown;\n</code></pre>\n<p>어차피 CSS 모듈을 쓰므로 여기서만 쓰일 list, link, item 같은 간단한 클래스명을 주자. 또한 메뉴가 열려 있는 경우와 닫혀 있는 경우에 대해 isMenuOpen을 이용해 다른 클래스명을 적용하도록 한다.</p>\n<pre><code class=\"language-tsx\">function Dropdown({navList, isMenuOpen}: {navList: PropsItem[], isMenuOpen: boolean}) {\n  return (\n    &#x3C;ul className={`${styles.list} ${isMenuOpen?styles['list--active']:styles['list--inactive']}`}>\n      {navList.map((item) => {\n        return (\n          &#x3C;li key={item.title} className={styles.item}>\n            &#x3C;Link\n              href={item.url} \n              aria-label={item.title} \n              className={styles.link}\n            >\n              {item.title}\n            &#x3C;/Link>\n          &#x3C;/li>\n        );\n      })}\n    &#x3C;/ul>\n  );\n}\n</code></pre>\n<p>CSS는 다음과 같이 설정했다. 주석으로 각각에 대한 간단한 설명들을 적었다.</p>\n<pre><code class=\"language-css\">// src/components/header/menu/dropdown/styles.module.css\n/*\n모바일 환경에선 세로 배열. bullet point와 패딩, 마진은 없앤다. 흰색 배경과 회색 테두리를 주고, 테두리를 크기에 포함시키기 위한 box-sizing 설정.\n헤더 높이는 50px 고정이며 메뉴는 그 아래에 위치하므로 position:absolute로 설정하고 top, left 속성을 줘서 루트 태그 기준으로 배치되도록 한다(현재 조상 태그 중 relative position이 없으므로 가능)\n*/\n.list{\n  width:100%;\n  flex-direction:column;\n  list-style:none;\n  padding:0;\n  margin:0;\n  background-color:white;\n  border:1px solid var(--gray2);\n  box-sizing:border-box;\n  position:absolute;\n  top:50px;\n  left:0;\n}\n\n/* 메뉴 열려 있을 땐 flex 배치, 아닐 땐 메뉴 보여주지 않기 */\n.list--active{\n  display:flex;\n}\n\n.list--inactive{\n  display:none;\n}\n\n/* 링크의 기본 스타일링을 없애고 크기 설정이 가능하도록 블록 태그로 설정.\n그리고 모바일 환경에서 약간의 들여쓰기와 가운데 위치 정렬을 한다. */\n.link{\n  text-decoration:none;\n  color:#000;\n  display:block;\n  width:100%;\n  height:40px;\n  text-indent:30px;\n  line-height:35px;\n}\n// 그냥 호버시 회색으로 만드는 것\n.link:hover{\n  background:var(--gray2)\n}\n\n// 640px이상의 넓은 화면\n@media (min-width:640px){\n  /*\n  넓은 화면에선 드롭다운 메뉴로 보일 필요 없으므로 가로배열.\n  또한 이제 드롭다운 형식이 아니므로 기본 position인 static으로 설정하고 테두리 없애기\n  */\n  .list{\n    flex-direction:row;\n    height:100%;\n    position:static;\n    border:none;\n  }\n  /* 드롭다운 메뉴가 아닐 때는 고정 너비 */\n  .item{\n    width:60px;\n  }\n  /* 넓은 너비 화면에서 메뉴는 언제나 보여야 한다. */\n  .list--active{\n    display:flex;\n  }\n\n  .list--inactive{\n    display:flex;\n  }\n  /* 메뉴의 가로 배열에 적당한 크기와 텍스트 정렬 */\n  .link{\n    width:60px;\n    height:100%;\n    text-indent:0;\n    line-height:50px;\n    text-align:center;\n  }\n}\n</code></pre>\n<h2>1.3. 페이지 이동시 드롭다운 닫기</h2>\n<p>그런데 문제가 있다. nextJS는 클라이언트 사이드 내비게이션을 지원하기 때문에 페이지가 이동한다고 해서 다시 렌더링되지 않는 컴포넌트들이 있다. 우리가 만든 헤더는 모든 페이지 공통으로 사용되기 때문에 <code>_app.js</code>에 넣었고 따라서 페이지가 이동한다고 해서 헤더의 <code>isMenuOpen</code> state가 바뀌지 않는다!</p>\n<p>즉 모바일 환경에서 메뉴를 열고 다른 페이지로 이동하더라도 메뉴가 계속 열려 있는 것이다.</p>\n<p>이를 해결하기 위해 <a href=\"https://nextjs.org/docs/pages/api-reference/functions/use-router#routerevents\">nextJS 문서의 라우터 이벤트 부분</a>을 참고했다.</p>\n<p><code>useEffect</code>와 nextJS에서 제공하는 <code>useRouter</code>를 사용하자. router가 변하고 컴포넌트가 unmount될 때 <code>isMenuOpen</code>을 false로 만들어준다.</p>\n<pre><code class=\"language-tsx\">/* src/components/header/menu/index.tsx */\n\nfunction Menu({navList}: {navList: PropsItem[]}) {\n  const [isMenuOpen, setIsMenuOpen] = useState&#x3C;boolean>(false);\n\n  const router=useRouter();\n\n  useEffect(()=>{\n    return router.events.on('routeChangeStart', ()=>setIsMenuOpen(false));\n  }, [router]);\n\n  return (\n    &#x3C;div className={styles.container}>\n      &#x3C;Toggler isMenuOpen={isMenuOpen} toggle={() => setIsMenuOpen(!isMenuOpen)} />\n      &#x3C;Dropdown navList={navList} isMenuOpen={isMenuOpen} />\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h2>1.4. 내비게이션 메뉴 로직 수정</h2>\n<p>이렇게 해놓고 헤더를 보니, 헤더에 있는 메뉴가 Home, CS, Front, Misc, About이 있었다. 그리고 이 이름들을 기반으로 각 카테고리별 페이지가 만들어지며 이 이름들은 <code>blog-category.ts</code>에서 관리한다.</p>\n<p>하지만 이 이름들이 별로 마음에 들지 않았다. 일단 Home을 빼고 싶었는데 지금의 페이지 생성 방식 상 이건 문제가 없다. 그냥 <code>blog-category.ts</code>만 조금 편집하면 된다.</p>\n<p>또 하고 싶은 건 헤더의 메뉴가 <code>개발</code>처럼 한글로 되어 있도록 하고 싶다. 따라서 먼저 <code>blog-category.ts</code>를 수정하였다. 그다음 posts의 폴더 이름 중 front도 dev로 바꿨다.</p>\n<pre><code class=\"language-ts\">// blog-category.ts\ninterface Category{\n  title: string;\n  url: string;\n}\n\nconst blogCategoryList: Category[] = [\n  {title:'CS', url:'/posts/cs'},\n  {title:'개발', url:'/posts/dev'},\n  {title:'기타', url:'/posts/misc'},\n  {title:'소개', url:'/about'},\n];\n\nexport default blogCategoryList;\n</code></pre>\n<p>이러면 일단 <code>/pages/posts/[category]/index.tsx</code>에서 동적 라우트 생성시 문제가 생긴다. <code>category.title</code>이 바뀌기 때문이다. 따라서 이를 title 기반이 아닌 url 기반으로 동적 라우트가 생성되도록 바꾸자.</p>\n<p>url을 <code>/</code>로 split 해준 후 마지막 요소만 취해주면 된다.</p>\n<pre><code class=\"language-tsx\">// pages/posts/[category]/index.tsx 의 getStaticPaths\nexport const getStaticPaths: GetStaticPaths=()=>{\n  const paths=blogCategoryList.map((category)=>{\n    return {\n      params: {\n        category:category.url.split('/').pop(),\n      },\n    };\n  });\n  return {\n    paths,\n    fallback: false,\n  };\n};\n</code></pre>\n<p>메인 페이지에서 각 카테고리별 글을 보여주는 필터링을 할 때도 <code>category.title</code>을 사용했는데 이것도 <code>category.url</code>로 바꿔주자.</p>\n<p><img src=\"/static/category-filtering-edited-f36d3ac9.png\" alt=\"filtering-edited\"></p>\n<h1>2. 푸터 컴포넌트</h1>\n<p>푸터에는 이전에 넣었던 내 이름과 github 링크 정도를 넣어 주자. 이를 위해서 <a href=\"https://github.com/logos\">github 로고 페이지</a>에서 로고를 다운받아서 사용했다.</p>\n<pre><code class=\"language-tsx\">import Image from 'next/image';\nimport Link from 'next/link';\n\nimport blogConfig from 'blog-config';\n\nimport styles from './styles.module.css';\n\nfunction Footer() {\n  return (\n    &#x3C;footer className={styles.footer}>\n      &#x3C;p className={styles.copyright}>\n      © {blogConfig.name}, Built with NextJS, 2023\n      &#x3C;/p>\n      &#x3C;Link href='https://github.com/witch-factory' className={styles.github}>\n        &#x3C;Image src='/github-mark.png' alt='Github' width={32} height={32} />\n      &#x3C;/Link>\n    &#x3C;/footer>\n  );\n}\n\nexport default Footer;\n</code></pre>\n<p>스타일은 약간의 간격과 배경 정도만 조절해 주었다.</p>\n<pre><code class=\"language-css\">.footer{\n  height:100px;\n  color:var(--gray6);\n  background-color:var(--gray2);\n  margin-top:50px;\n  padding:20px;\n}\n\n.copyright{\n  margin:10px 0;\n}\n\n.github{\n  display:block;\n  width:32px;\n  height:32px;\n}\n</code></pre>\n<h1>3. 자기소개 컴포넌트</h1>\n<h2>3.1. 페이지 너비조정</h2>\n<p>아까 우리는 블로그 컨텐츠가 들어갈 컨테이너 너비를 <code>max-width</code>로 제한했었다. 그런데 이렇게 하면 내부 컨텐츠들은 해당 컨테이너를 꽉 채우게 된다. 그럼 만약 창 너비가 <code>max-width</code>보다 작으면? 컨텐츠가 페이지 너비를 여백없이 꽉 채울 것이다. 이는 좋지 않다.</p>\n<p>따라서 컨테이너를 하나 더 만들어서 <code>width:92%</code>와 <code>margin:0 auto;</code>를 주자.</p>\n<pre><code class=\"language-css\">// pages/styles.module.css\n.container{\n  width:92%;\n  margin:0 auto;\n}\n</code></pre>\n<p>그리고 메인 페이지에 컨테이너 추가.</p>\n<pre><code class=\"language-tsx\">// pages/index.tsx\n&#x3C;main className={styles.pagewrapper}>\n  // 여기 div 컨테이너를 추가하였다.\n  &#x3C;div className={styles.container}>\n    &#x3C;Profile />\n    {/* 프로젝트 목록을 만들기 */}\n    {/* 글 목록은 독립적인 영역으로 존재 */}\n    &#x3C;article>\n      {blogCategoryList.map((category) => {\n        const categoryPostList=allDocuments.filter((post)=>{\n          return post._raw.flattenedPath.split('/')[0]===category.url.split('/').pop();\n        }).slice(0, 3);\n        if (categoryPostList.length===0) {\n          return null;\n        }\n        return &#x3C;Category key={category.title} title={category.title} items={categoryPostList} />;\n      })\n      }\n    &#x3C;/article>\n  &#x3C;/div>\n&#x3C;/main>\n</code></pre>\n<p>이제 이 페이지의 맨 위(헤더 제외)에 보일 자기소개 컴포넌트를 한번 만들어 보자. 구조는 이전에 다 만들어 놓았으므로 간단히 CSS만 작성하자.</p>\n<p>일단 화면 너비가 작을 경우에든 클 경우에도 보이는 자기소개 부분을 Intro 컴포넌트로 분리한다. <code>src/components/profile/intro</code>에 index.tsx와 styles.module.css를 생성.</p>\n<p>그리고 다음과 같이 index.tsx를 작성한다. 기존에는 링크를 하나하나 생성해 주었는데 이를 수정하여 <code>Object.entries</code>를 이용해 자동으로 생성하도록 하였다. 이제 blog-config.ts만 편집하면 프로필에 새로운 링크를 표시할 수 있다.</p>\n<pre><code class=\"language-tsx\">// src/components/profile/intro/index.tsx\nimport Link from 'next/link';\n\nimport blogConfig from 'blog-config';\n\nimport styles from './styles.module.css';\n\n\nfunction Intro() {\n  return (\n    &#x3C;div>\n      &#x3C;h2 className={styles.name}>{blogConfig.name}&#x3C;/h2>\n      &#x3C;p className={styles.description}>{blogConfig.description}&#x3C;/p>\n      &#x3C;ul className={styles.linklist}>\n        {Object.entries(blogConfig.social).map(([key, value]) => (\n          &#x3C;li key={key}>\n            &#x3C;Link href={value} target='_blank' className={styles.link}>\n              {key}\n            &#x3C;/Link>\n          &#x3C;/li>\n        ))}\n      &#x3C;/ul>\n    &#x3C;/div>\n  );\n}\n\nexport default Intro;\n</code></pre>\n<p>그리고 다음과 같이 클래스들을 스타일링해준다. 이름은 화면 너비가 작아지면 크기와 간격을 조금 줄이도록 했다. 설명도 마찬가지로 화면 너비가 작아질 시 행간을 좁혔다.</p>\n<p>그리고 링크들은 가로로 배열되도록 했고 간격 조정을 적당히 해준 후 남색 계열의 적당한 색상을 부여하였다.</p>\n<pre><code class=\"language-css\">.name{\n  margin:10px 0;\n  font-size:1.2rem;\n}\n\n.description{\n  margin:10px 0;\n  word-break:keep-all;\n}\n\n.linklist{\n  display:flex;\n  flex-direction:row;\n  list-style:none;\n  padding-left:0;\n  margin-bottom:0.5rem;\n  gap:0 15px;\n}\n\n.link{\n  text-decoration:none;\n  color:var(--indigo6);\n}\n\n@media (min-width:768px){\n  .name{\n    font-size:1.5rem;\n  }\n\n  .description{\n    line-height:1.5;\n  }\n}\n</code></pre>\n<p>이렇게 한 뒤 <code>Intro</code>컴포넌트를 <code>Profile</code>컴포넌트에 추가한다.</p>\n<pre><code class=\"language-tsx\">// src/components/profile/index.tsx\nfunction Profile() {\n  return (\n    &#x3C;article className={styles.profile}>\n      &#x3C;Image \n        className={styles.image} \n        src={blogConfig.picture} \n        alt={`${blogConfig.name}의 프로필 사진`} \n        width={100} \n        height={100} \n      />\n      // 간략해진 Intro 컴포넌트\n      &#x3C;Intro />\n    &#x3C;/article>\n  );\n}\n</code></pre>\n<p>profile의 styles.module.css에서는 사진이 동그랗게 보이도록 하고 적절한 간격을 준다. 그리고 자기소개 컴포넌트 전체에 아주 연한 회색의 배경을 주고 여백을 좀 주었다. 또한 모서리도 둥글게 만들었다.</p>\n<pre><code class=\"language-css\">.image{\n  display:none;\n  border-radius:50%;\n  margin-top:20px;\n  margin-right:20px;\n}\n\n.profile{\n  background:var(--gray1);\n  margin:20px 0;\n  padding:10px 20px;\n  border-radius:1rem;\n}\n\n@media (min-width:768px){\n  .image{\n    display:block;\n  }\n\n  /* 화면 너비가 클 시 사진과 소개를 가로 배열 */\n  .profile{\n    display:flex;\n    flex-direction:row;\n  }\n}\n</code></pre>\n<h1>4. 프로젝트 컴포넌트</h1>\n<p>이전에는 프로젝트 소개에 <code>Card</code> 컴포넌트를 재사용할 수 있을 거라 생각했지만 생각하던 레이아웃이 달라졌다. 따라서 프로젝트를 보여주는 컴포넌트들은 아예 새로 만드는 게 좋겠다. 들어가야 할 정보를 생각해 보자.</p>\n<h1>4.1. 레이아웃 설계</h1>\n<p>지금 생각하기에 들어가야 할 정보는 일단 프로젝트 이름, 프로젝트 설명, 프로젝트 링크(github등), 프로젝트에 관한 이미지 정도가 있겠다.</p>\n<p>이전에 만들었다가 버려 놓았던 <code>src/components/projects</code>를 <code>projectList</code>로 이름을 바꾸고 작업해 보자. 생각해본 레이아웃은 다음과 같다.</p>\n<p><img src=\"/static/project-layout-4c8137e8.png\" alt=\"project-layout\"></p>\n<p>일단 <code>components/projectList/project</code> 폴더도 만들고 index.tsx와 styles.module.css를 생성한다. article로 이루어진 적당한 <code>Project</code> 컴포넌트를 만들어 놓는다. 이제 프로젝트들을 담아 놓을 컨테이너를 만들어보자.</p>\n<p>아, 그전에 프로젝트를 담아 놓을 projectList를 만들어야 한다. 루트 경로에 <code>blog-project.ts</code>를 만들고 다음과 같이 작성한다. 타입은 다른 데서도 쓸 것이므로 export 해주자.</p>\n<pre><code class=\"language-ts\">// /blog-project.ts\nexport interface projectType {\n  title: string;\n  description: string;\n  image: string;\n  url: {\n    title: string;\n    link: string;\n  }[];\n  techStack: string[];\n}\n\nconst projectList: projectType[] = [\n  {\n    title: 'Witch-Work',\n    description: '직접 제작하고 Cloudflare로 배포해 운영중인 개인 블로그',\n    image: '/witch.jpeg',\n    url: [\n      {\n        title: 'Github',\n        link:'https://github.com/witch-factory/witch-next-blog'\n      },\n      {\n        title: 'URL',\n        link:'https://witch.work/'\n      }\n    ],\n    techStack: ['Next.js', 'React', 'TypeScript']\n  },\n];\n\nexport default projectList;\n</code></pre>\n<h2>4.2. 컨테이너 컴포넌트</h2>\n<p>프로젝트 부분은 독립적으로 존재할 수 있으므로 article 태그를 쓴다. 그리고 제목과 리스트를 만든다. 그뿐이다.</p>\n<pre><code class=\"language-tsx\">// src/components/projectList/index.tsx\nimport { projectType } from 'blog-project';\nimport projectList from 'blog-project';\n\nimport Project from './project';\nimport styles from './styles.module.css';\n\nfunction ProjectList() {\n  return (\n    &#x3C;article>\n      &#x3C;h2 className={styles.title}>프로젝트&#x3C;/h2>\n      &#x3C;ul className={styles.list}>\n        {projectList.map((project: projectType) => {\n          return (\n            &#x3C;li key={project.title}>\n              &#x3C;Project project={project} />\n            &#x3C;/li>\n          );\n        })}\n      &#x3C;/ul>\n    &#x3C;/article>\n  );\n}\n\nexport default ProjectList;\n</code></pre>\n<p>title은 하단 마진을 없애고, 리스트는 좌우 여백을 없애고 bullet point도 없앤다. 또한 화면이 커질 경우 2열로 배치하도록 하기 위해 grid display를 사용한다. 2열 사이에는 약간의 간격을 둔다.</p>\n<pre><code class=\"language-css\">.title{\n  margin-bottom:0;\n}\n\n.list{\n  list-style:none;\n  padding:0;\n}\n\n@media (min-width: 768px) {\n  .list{\n    display:grid;\n    grid-template-columns:repeat(2,1fr);\n    column-gap: 1rem;\n  }\n}\n</code></pre>\n<h2>4.3. 프로젝트 소개 컴포넌트</h2>\n<p>일단 프로젝트 소개와 프로젝트 이미지를 분리하기 위해서, 프로젝트 소개(제목, 설명, 링크 등이 들어갈 곳)를 위한 컴포넌트를 만들자. <code>projectList/project/intro</code> 폴더를 만들고 내부에 index.tsx와 styles.module.css를 생성한다.</p>\n<p>그리고 다음과 같은 구조를 잡자. div를 많이 쓰고 싶지 않았는데..결국 CSS를 하다 보면 어쩔 수 없다.</p>\n<p>길어 보이지만 스타일링을 위해 요소를 묶은 div를 제외하고 의미적인 부분만 보면 제목, 설명, 링크, 기술 스택(링크와 기술 스택은 ul로 묶음)을 순서대로 나열한 것일 뿐이다.</p>\n<pre><code class=\"language-tsx\">import Link from 'next/link';\n\nimport { projectType } from 'blog-project';\n\nimport styles from './styles.module.css';\n\nfunction ProjectIntro({project}: {project: projectType}) {\n  return (\n    &#x3C;div className={styles.intro}>\n      &#x3C;div>\n        &#x3C;h3 className={styles.title}>{project.title}&#x3C;/h3>\n        &#x3C;p className={styles.description}>{project.description}&#x3C;/p>\n      &#x3C;/div>\n      &#x3C;div>\n        &#x3C;ul className={styles.list}>\n          {project.url.map((url,) =>\n            &#x3C;li key={url.link}>\n              &#x3C;Link \n                className={styles.link} \n                href={url.link} \n                target='_blank'\n              >\n                {`${url.title} Link`}\n              &#x3C;/Link>\n            &#x3C;/li>\n          )}\n        &#x3C;/ul>\n        &#x3C;ul className={styles.list}>\n          {project.techStack.map((tech) =>\n            &#x3C;li key={tech} className={styles.tech}>{tech}&#x3C;/li>\n          )}\n        &#x3C;/ul>\n      &#x3C;/div>\n    &#x3C;/div>\n  );\n}\n\nexport default ProjectIntro;\n</code></pre>\n<p>그리고 CSS는 다음과 같이 작성한다. 디자인 감각이 딸리지만 최선을 다해 컬러와 간격을 지정했다.</p>\n<pre><code class=\"language-css\">/* 콘테이너 높이가 요소들 높이보다 클 경우, \n제목/설명은 위쪽에, 링크/기술스택은 아래쪽에 배치하도록 한다. */\n.intro{\n  display:flex;\n  flex-direction: column;\n  justify-content: space-between;\n}\n\n/* 그냥 h3과 p 태그의 기본 간격 없애주고\n제목과 설명 간에는 약간의 간격 */\n.title{\n  margin: 0;\n}\n\n.description{\n  margin: 0;\n  margin-top:5px;\n}\n\n/* 가로 배치 후 간격 주기 */\n.list{\n  display: flex;\n  flex-direction: row;\n  gap: 6px;\n  list-style: none;\n  padding: 0;\n  margin-top:5px;\n}\n\n/* block으로 설정한 후 적당히 디자인, 간격주기 */\n.link{\n  display:block;\n  padding: 3px;\n  border-radius: 5px;\n  text-decoration: none;\n  background-color: var(--indigo1);\n  color: var(--indigo8);\n}\n\n.link:hover{\n  background-color: var(--indigo2);\n}\n\n.tech{\n  padding: 1.5px 3px;\n  border-radius: 5px;\n  background-color: var(--indigo9);\n  color:var(--white);\n  font-size: 0.8rem;\n}\n</code></pre>\n<h2>4.4. 프로젝트 접기 기능</h2>\n<p>현재 PC에서는 그럭저럭 괜찮지만 모바일에서는 프로젝트 소개가 너무 길어서 너무 내려야 포스트가 보이는 문제가 있다. 따라서 모바일에서는 프로젝트 소개 카드들이 접혀 있는 상태로 있다가 펼쳐보기 버튼을 누르면 펼쳐볼 수 있도록 하자.</p>\n<p><img src=\"/static/mobile-old-layout-86a39020.png\" alt=\"old-layout\"></p>\n<p>프로젝트 컴포넌트에서 제목과 펼쳐보기 버튼이 들어갈 컨테이너로 div를 만들고, 버튼을 넣어준다. 그리고 <code>open</code> 상태를 만들어서 버튼을 누를 때마다 상태가 반전되도록 한다.</p>\n<pre><code class=\"language-tsx\">function ProjectList() {\n  const [open, setOpen] = useState(false);\n\n  const toggle = ()=>{\n    setOpen(prev=>!prev);\n  };\n\n  return (\n    &#x3C;article>\n    // 이 부분이 달라졌다\n      &#x3C;div className={styles.header}>\n        &#x3C;h2 className={styles.title}>프로젝트&#x3C;/h2>\n        &#x3C;button className={styles.toggle} onClick={toggle}>{open?'접기':'펼쳐보기'}&#x3C;/button>\n      &#x3C;/div>\n      &#x3C;ul className={`${styles.list} ${open?styles['list--open']:styles['list--close']}`}>\n        {projectList.map((project: projectType) => {\n          return (\n            &#x3C;li key={project.title}>\n              &#x3C;Project project={project} />\n            &#x3C;/li>\n          );\n        })}\n      &#x3C;/ul>\n    &#x3C;/article>\n  );\n}\n</code></pre>\n<p>그리고 header 클래스의 내부 요소 배열을 가로로 하도록 하고 내부 요소가 양쪽 끝에 배치되도록 하자. 버튼은 프로젝트 소개의 URL 링크들과 같은 스타일링을 해주고 적절한 크기를 부여한다. 또한 만약 사이트 너비가 커지면 toggle 버튼은 안 보여야 하므로 이것도 미디어 쿼리에 추가한다.</p>\n<pre><code class=\"language-css\">// src/components/projectList/styles.module.css\n.header{\n  display:flex;\n  flex-direction:row;\n  justify-content:space-between;\n}\n\n.title{\n  margin:0;\n}\n\n.toggle{\n  width:70px;\n  height:30px;\n  border:none;\n  border-radius:5px;\n  background:var(--indigo1);\n  color:var(--indigo8);\n}\n\n.toggle:hover{\n  background:var(--indigo2);\n}\n\n@media (min-width: 768px) {\n  .toggle{\n    display:none;\n  }\n}\n</code></pre>\n<p>그리고 만약 open state가 false인 경우 프로젝트를 한 개만 보여주도록 하자. 이는 CSS grid를 이용해서 구현할 수 있다.</p>\n<p>먼저 <code>list</code> 클래스를 grid layout으로 지정한 후 한 행, 한 열만 존재하도록 한다. 그리고 <code>list--closed</code> 클래스에선 자동으로 생성된 행들의 너비를 관리하는 <code>grid-auto-rows</code> 속성을 0으로 준 후 overflow를 hidden으로 설정한다. 그러면 1행을 넘는 요소들은 모두 overflow로 취급되는데 이를 숨기도록 설정한 것이므로 숨겨진다. 당연히 1개의 프로젝트 소개만 표시된다.</p>\n<p>그리고 <code>list--open</code>에서는 <code>grid-auto-rows</code>를 다시 1fr로 설정해주면 된다. 이렇게 하면 다른 요소들도 적절한 너비를 받아서 모두 보이게 된다. 화면 너비가 커지면 작동하는 미디어 쿼리에서는 아까와 똑같이, 768px 이상의 너비에서는 open에 상관없이 2열로 보이도록 하자.</p>\n<pre><code class=\"language-css\">// src/components/projectList/styles.module.css\n.list{\n  list-style:none;\n  padding:0;\n  display:grid;\n  grid-template-columns:1fr;\n  grid-template-rows:1fr;\n}\n\n.list--open{\n  grid-auto-rows:1fr;\n}\n\n.list--close{\n  grid-auto-rows:0;\n  overflow:hidden;\n}\n\n@media (min-width: 768px) {\n  .list{\n    display:grid;\n    grid-template-columns:repeat(2,1fr);\n    grid-auto-rows:1fr;\n    column-gap: 1rem;\n  }\n\n  .toggle{\n    display:none;\n  }\n}\n</code></pre>\n<h1>5. 글 소개 컴포넌트</h1>\n<h2>5.1. Category 컴포넌트</h2>\n<p>이 컴포넌트에서는 별로 할 게 없다. 카드들을 정렬해 줄 뿐인 역할이므로 반응형 레이아웃으로만 만들어 주자. 너비가 커질 시에는 가로로 배열하는 방식으로. 여기에는 grid를 사용하였다. flex를 사용할 경우 <code>Card</code>를 감싼 <code>li</code>태그에도 클래스를 부여하여 <code>width:100%</code>를 줘야 하는데 굳이 그럴 필요성을 못 느낀다.</p>\n<pre><code class=\"language-tsx\">// src/components/category/index.tsx\nimport Card from 'src/components/card';\n\nimport styles from './styles.module.css';\n\ninterface CardProps{\n  title: string;\n  description: string;\n  image?: string;\n  date: string;\n  tags?: string[];\n  url: string;\n}\n\ninterface Props{\n  title: string;\n  url: string;\n  items: CardProps[];\n}\n\nfunction propsProperty(item: CardProps) {\n  const { title, description, image, date, tags, url } = item;\n  return { title, description, image, date, tags, url };\n}\n\nfunction Category(props: Props) {\n  return (\n    &#x3C;section className={styles.container}>\n      &#x3C;h2>{props.title}&#x3C;/h2>\n      \n      &#x3C;ul className={styles.list}>\n        {props.items.map((item) => {\n          return (\n            &#x3C;li key={item.url}>\n              &#x3C;Card\n                {...propsProperty(item)}\n              />\n            &#x3C;/li>\n          );\n        })}\n      &#x3C;/ul>\n    &#x3C;/section>\n  );\n}\n\nexport default Category;\n</code></pre>\n<p>따라서 list 클래스에만 적절한 반응형 레이아웃과 간격 부여.</p>\n<pre><code class=\"language-css\">// src/components/category/styles.module.css\n.list{\n  list-style:none;\n  padding:0;\n  display: grid;\n  gap:1rem;\n}\n\n@media (min-width:768px){\n  .list{\n    grid-template-columns:repeat(3,1fr);\n  }\n}\n</code></pre>\n<h2>5.2. Card 컴포넌트</h2>\n<p>이 <code>Card</code>컴포넌트는 각 카테고리별 페이지에서도 사용되므로 레이아웃을 좀 생각해 보자.</p>\n<p>그전에 먼저 높이를 좀 수정하자. 지금은 높이가 고정 너비 150px로 되어 있는데 이럴 경우 글 제목 혹은 설명이 길어지면 글이 약간 컴포넌트를 넘어가는 문제가 생겼다.</p>\n<p><img src=\"/static/card-overflow-353f142a.png\" alt=\"card-overflow\"></p>\n<p>따라서 이 너비가 유동적으로 조절되도록 바꿔주자. 먼저 <code>components/card/styles.module.css</code>에서 container 클래스의 height를 그냥 100%로 바꿔주자.</p>\n<pre><code class=\"language-css\">// src/components/card/styles.module.css\n.container{\n  border: 1px solid var(--gray5);\n  border-radius: 1rem;\n  box-sizing: border-box;\n  height:100%;\n  display:flex;\n  flex-direction:column;\n}\n</code></pre>\n<p>설계의 편의를 위해서 컨테이너와 이미지를 제외한, 글의 진짜 내용이 텍스트로 들어가는 부분을 Intro 컴포넌트로 분리해 준다. <code>src/components/card/intro</code> 폴더를 만들고 index.tsx와 styles.module.css를 생성한다.</p>\n<p>그리고 <code>card/intro/index.tsx</code>를 다음과 같이 기존의 글 개요의 역할을 그대로 하도록 만든다. 클래스명도 적당히 붙여주었다. 그렇게 한 후 <code>Card</code>컴포넌트에 붙여준다.</p>\n<pre><code class=\"language-tsx\">// src/components/card/intro/index.tsx\nimport { toISODate, formatDate } from '@/utils/date';\n\nimport styles from './styles.module.css';\n\ninterface Props{\n  title: string;\n  description: string;\n  date: string;\n  tags: string[];\n}\n\nfunction Intro(props: Props) {\n  const { title, description, date, tags } = props;\n  const dateObj = new Date(date);\n  return (\n    &#x3C;>\n      &#x3C;h3 className={styles.title}>{title}&#x3C;/h3>\n      &#x3C;p className={styles.description}>{description}&#x3C;/p>\n      {tags.length ?\n        &#x3C;ul className={styles.tagList}>\n          {tags.map((tag: string)=>\n            &#x3C;li key={tag} className={styles.tag}>{tag}&#x3C;/li>\n          )}\n        &#x3C;/ul> :\n        null}\n      &#x3C;time dateTime={toISODate(dateObj)}>{formatDate(dateObj)}&#x3C;/time>\n    &#x3C;/>\n  );\n}\n\nexport default Intro;\n</code></pre>\n<p>위에서 <code>toISODate</code>와 <code>formatDate</code>함수를 사용하였는데, 이는 <code>src/utils/date.ts</code>를 만들고 거기에 정의해 사용하였다. 해당 함수들의 내용은 다음과 같다.</p>\n<pre><code class=\"language-ts\">// src/utils/date.ts\nexport const toISODate = (date: Date) => {\n  return date.toISOString().split('T')[0];\n};\n\nexport const formatDate = (date: Date) => {\n  const year = date.getFullYear();\n  const month = String(date.getMonth() + 1).padStart(2, '0');\n  const day = String(date.getDate()).padStart(2, '0');\n  return `${year}. ${month}. ${day}`;\n};\n</code></pre>\n<p>그리고 Card 컴포넌트에 Intro를 붙이면 다음과 같아진다.</p>\n<pre><code class=\"language-tsx\">// src/components/card/index.tsx\nimport Image from 'next/image';\nimport Link from 'next/link';\n\nimport Intro from './intro';\nimport styles from './styles.module.css';\n\ninterface Props{\n  title: string;\n  description: string;\n  image?: string;\n  date: string;\n  tags: string[];\n  url: string;\n}\n\nfunction Card(props: Props) {\n  const { title, description, image, date, tags, url } = props;\n  return (\n    &#x3C;article className={styles.container}>\n      &#x3C;Link className={styles.link} href={url}>\n        {image ?\n          &#x3C;Image src={image} alt={`${title} 사진`} width={50} height={50} /> : \n          null\n        }\n        {/* 이 부분이 Intro 컴포넌트로 처리되었다. */}\n        &#x3C;Intro title={title} description={description} date={date} tags={tags} />\n      &#x3C;/Link>\n    &#x3C;/article>\n  );\n}\n\nexport default Card;\n</code></pre>\n<p>카드 컴포넌트의 스타일링은 다음과 같다. 간단한 테두리와 약간의 여백, 색깔 정도만 주었다. 링크 컴포넌트에 크기를 부여하기 위해 <code>display:block</code>도 주었다.</p>\n<pre><code class=\"language-css\">// src/components/card/styles.module.css\n.container{\n  border: 1px solid var(--gray5);\n  border-radius: 1rem;\n  box-sizing: border-box;\n  height:100%;\n  display:flex;\n  flex-direction:column;\n}\n\n.link{\n  display:block;\n  height:100%;\n  padding:1rem;\n  text-decoration:none;\n  color:var(--black);\n}\n\n.link:hover{\n  color:var(--indigo6);\n}\n</code></pre>\n<p>그리고 Intro 컴포넌트의 스타일링도 해준다. 제목과 설명의 기본 간격을 없애고 새로 주었다. 글씨 크기도 조정했다. 태그들은 가로로 배열되도록 하고, 아까 프로젝트 설명 란의 기술 스택 블럭과 비슷하게 디자인해 주었다. 단 여백을 좀더 주었다.</p>\n<pre><code class=\"language-css\">// src/components/card/intro/styles.module.css\n.title{\n  font-size:1.2rem;\n  margin:0;\n  margin-bottom:10px;\n}\n\n.description{\n  font-size:1rem;\n  margin:0;\n  margin-bottom:10px;\n}\n\n.tagList{\n  display:flex;\n  flex-wrap:wrap;\n  margin:0;\n  padding:0;\n  list-style:none;\n  gap:5px;\n}\n\n.tag{\n  background-color:var(--indigo6);\n  color:var(--white);\n  border-radius:5px;\n  font-size:0.8rem;\n  margin:0;\n  margin-bottom:5px;\n  padding:3px 8px;\n}\n</code></pre>\n<h2>5.3. 글 날짜순 정렬</h2>\n<p>지금 메인 페이지에 보이는 글들은 날짜순으로 정렬이 안 되어 있다. 각 카테고리별 페이지에서도 마찬가지다. 이를 날짜 순으로 정렬해서 가져오도록 하자.</p>\n<p>우리는 지금까지 글들을 가져올 때 <code>allDocuments</code>를 사용했는데, 먼저 <code>allDocuments</code>를 날짜순으로 정렬해서 리턴하는 함수를 만든 후 이를 <code>allDocuments</code>의 위치에 대신 넣어 주면 된다.</p>\n<p><code>src/utils/post.ts</code>를 생성한다. 그리고 <code>getSortedPosts</code>함수를 작성하자.</p>\n<pre><code class=\"language-ts\">// src/utils/post.ts\nimport { allDocuments } from 'contentlayer/generated';\n\nexport const getSortedPosts = () => {\n  return allDocuments.sort((a, b) => {\n    return new Date(b.date).getTime() - new Date(a.date).getTime();\n  });\n};\n</code></pre>\n<p>그리고 <code>allDocuments</code>를 사용하는 부분을 모두 <code>getSortedPosts()</code>로 바꿔주면 된다.</p>\n<h2>5.4. Intro에 간격 넣기</h2>\n<p>그런데 화면 너비를 조절하며 <code>Card</code> 컴포넌트를 보면 문제가 있다. 제목과 설명의 길이에 따라서 줄 수가 달라지므로 각각의 높이가 달라지는데, 이 때문에 밑의 태그와 날짜 컴포넌트의 위치가 정렬되지 않는 것이다.</p>\n<p><img src=\"/static/card-not-aligned-bf50b111.png\" alt=\"card-not-aligned\"></p>\n<p>이를 해결하기 위해서는 <code>Card</code> 컴포넌트의 <code>Intro</code> 컴포넌트에 간격을 주어야 한다. 이를 위해 <code>Card</code> 컴포넌트의 <code>Intro</code> 컴포넌트의 <code>styles.module.css</code>를 만들고 다음과 같은 container 클래스를 작성한다.</p>\n<pre><code class=\"language-css\">// src/components/card/intro/styles.module.css\n.container{\n  display:flex;\n  flex-direction:column;\n  justify-content:space-between;\n  height:100%;\n}\n</code></pre>\n<p>Intro 컴포넌트는 다음과 같이 변경. 전체를 container 클래스의 div로 감싸고, tags와 time이 뭉쳐 있도록 div로 감쌌다.</p>\n<pre><code class=\"language-tsx\">function Intro(props: Props) {\n  const { title, description, date, tags } = props;\n  const dateObj = new Date(date);\n  return (\n    &#x3C;div className={styles.container}>\n      &#x3C;h3 className={styles.title}>{title}&#x3C;/h3>\n      &#x3C;p className={styles.description}>{description}&#x3C;/p>\n      &#x3C;div>\n        {tags.length ?\n          &#x3C;ul className={styles.tagList}>\n            {tags.map((tag: string)=>\n              &#x3C;li key={tag} className={styles.tag}>{tag}&#x3C;/li>\n            )}\n          &#x3C;/ul> :\n          null}\n        &#x3C;time dateTime={toISODate(dateObj)}>{formatDate(dateObj)}&#x3C;/time>\n      &#x3C;/div>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h1>6. 약간의 개선</h1>\n<p>그런데 꼭 프로젝트 소개와 글 프리뷰(<code>Card</code>)컴포넌트에 굳이 테두리가 있어야 할까? 없앨 수 있는 건 없애 버리자.</p>\n<p><code>src/components/projectList/project/styles.module.css</code>의 container를 편집하여 다음과 같이 테두리를 없애고 간격을 약간 넓혀준다.</p>\n<p>이미지도 원래 <code>border-radius:50%</code>로 동그랗게 보이도록 했는데 그냥 약간의 모깎기만 하자.</p>\n<pre><code class=\"language-css\">// src/components/projectList/project/styles.module.css\n.container{\n  display: flex;\n  flex-direction: row;\n  gap:1rem;\n  /*border: 1px solid var(--gray5);\n  border-radius: 1rem;*/\n  box-sizing: border-box;\n  padding:15px;\n  margin-bottom: 1rem;\n  min-height:150px;\n}\n\n.image{\n  border-radius:1rem;\n}\n\n@media (min-width: 768px) {\n  .container{\n    padding: 10px;\n  }\n\n  .image{\n    display: block;\n  }\n}\n</code></pre>\n<p>그리고 <code>src/components/card/styles.module.css</code>의 container도 다음과 같이 테두리를 없애고 hover 시에 background-color를 추가해준다.</p>\n<pre><code class=\"language-css\">.container{\n  /*border: 1px solid var(--gray5);*/\n  border-radius: 1rem;\n  box-sizing: border-box;\n  height:100%;\n  display:flex;\n  flex-direction:column;\n}\n\n.link{\n  display:block;\n  height:100%;\n  padding:1rem;\n  text-decoration:none;\n  color:var(--black);\n}\n\n.link:hover{\n  border-radius: 1rem;\n  color:var(--indigo6);\n  background-color:var(--gray1);\n}\n</code></pre>\n<p>내 착각일 수도 있지만 테두리를 이루는 선들이 없어지니 화면이 좀더 깔끔해진 것 같다.</p>\n<h1>7. 다음 이야기</h1>\n<p><code>Card</code> 컴포넌트는 메인 페이지 뿐 아니라 각 카테고리별로 글 목록을 보여주는 페이지에서도 사용된다. 그리고 이때의 카드는 한 줄에 하나씩만 보여지므로, 상당히 넓은 너비를 차지한다.</p>\n<p>따라서 썸네일을 넣음으로써 글의 이해에도 도움을 주고 글 한 줄의 너비도 줄여서 사용자의 집중도를 높이려고 한다.</p>\n<p>그런데 그걸 하기 위해선 꽤나 여러가지 작업이 필요할 것 같아서 먼저 다른 페이지들을 좀 손보고 나서 그 작업을 하도록 하겠다. 글 목록 페이지와 글 상세보기 페이지뿐이지만.</p>\n<h1>참고</h1>\n<p>토스 기술블로그의 디자인을 많이 참고하였다. 토스만큼 UI에 신경쓰는 기업이 많지 않다고 생각한다. <a href=\"https://toss.tech/tech\">https://toss.tech/tech</a></p>\n<p>마녀 모자 이미지 출처 <a href=\"https://pixabay.com/vectors/magician-wizard-hat-magic-mystery-41104/\">https://pixabay.com/vectors/magician-wizard-hat-magic-mystery-41104/</a></p>\n<p>nextJS 페이지 이동 감지를 위한 useRouter <a href=\"https://nextjs.org/docs/pages/api-reference/functions/use-router#routerevents\">https://nextjs.org/docs/pages/api-reference/functions/use-router#routerevents</a></p>\n<p>프로젝트를 보여주는 컴포넌트를 만들기 위해 참고하였다.\n<a href=\"https://portfolio-kagrin97.vercel.app/portfolio\">https://portfolio-kagrin97.vercel.app/portfolio</a></p>\n<p>프로젝트를 하다가 vscode 폴더의 구조에 따른 들여쓰기 간격을 넓히기 위해 사용했다. <a href=\"https://thenicesj.tistory.com/35\">https://thenicesj.tistory.com/35</a></p>\n<p>grid css를 이용한 접힘 구현에 참고 <a href=\"https://stackoverflow.com/questions/63184642/display-only-one-row-and-hide-others-in-css-grid\">https://stackoverflow.com/questions/63184642/display-only-one-row-and-hide-others-in-css-grid</a></p>",
    "excerpt": "블로그 만들기 시리즈\n|제목|링크|\n|---|---|\n|1. 기본 세팅|https://witch.work/posts/blog-remake-1|\n|2. 메인 페이지의 HTML 설계|https://witch.work/posts/blog-remake-2|\n|3. 글 상세 페이지의 구조 설계|https://witch.work/posts/blog-remake-3|\n|4. 이미지를 상대 경로로 쓸 수 있도록 하기|https://witch.work/posts/blog-rem",
    "headingTree": [
      {
        "title": "블로그 만들기 시리즈",
        "url": "#블로그-만들기-시리즈",
        "items": []
      },
      {
        "title": "0. 색 정의",
        "url": "#0-색-정의",
        "items": []
      },
      {
        "title": "1. 헤더 컴포넌트",
        "url": "#1-헤더-컴포넌트",
        "items": [
          {
            "title": "1.1. 컨테이너",
            "url": "#11-컨테이너",
            "items": []
          },
          {
            "title": "1.1. 홈 버튼",
            "url": "#11-홈-버튼",
            "items": []
          },
          {
            "title": "1.2. 내비게이션 메뉴",
            "url": "#12-내비게이션-메뉴",
            "items": []
          },
          {
            "title": "1.3. 페이지 이동시 드롭다운 닫기",
            "url": "#13-페이지-이동시-드롭다운-닫기",
            "items": []
          },
          {
            "title": "1.4. 내비게이션 메뉴 로직 수정",
            "url": "#14-내비게이션-메뉴-로직-수정",
            "items": []
          }
        ]
      },
      {
        "title": "2. 푸터 컴포넌트",
        "url": "#2-푸터-컴포넌트",
        "items": []
      },
      {
        "title": "3. 자기소개 컴포넌트",
        "url": "#3-자기소개-컴포넌트",
        "items": [
          {
            "title": "3.1. 페이지 너비조정",
            "url": "#31-페이지-너비조정",
            "items": []
          }
        ]
      },
      {
        "title": "4. 프로젝트 컴포넌트",
        "url": "#4-프로젝트-컴포넌트",
        "items": []
      },
      {
        "title": "4.1. 레이아웃 설계",
        "url": "#41-레이아웃-설계",
        "items": [
          {
            "title": "4.2. 컨테이너 컴포넌트",
            "url": "#42-컨테이너-컴포넌트",
            "items": []
          },
          {
            "title": "4.3. 프로젝트 소개 컴포넌트",
            "url": "#43-프로젝트-소개-컴포넌트",
            "items": []
          },
          {
            "title": "4.4. 프로젝트 접기 기능",
            "url": "#44-프로젝트-접기-기능",
            "items": []
          }
        ]
      },
      {
        "title": "5. 글 소개 컴포넌트",
        "url": "#5-글-소개-컴포넌트",
        "items": [
          {
            "title": "5.1. Category 컴포넌트",
            "url": "#51-category-컴포넌트",
            "items": []
          },
          {
            "title": "5.2. Card 컴포넌트",
            "url": "#52-card-컴포넌트",
            "items": []
          },
          {
            "title": "5.3. 글 날짜순 정렬",
            "url": "#53-글-날짜순-정렬",
            "items": []
          },
          {
            "title": "5.4. Intro에 간격 넣기",
            "url": "#54-intro에-간격-넣기",
            "items": []
          }
        ]
      },
      {
        "title": "6. 약간의 개선",
        "url": "#6-약간의-개선",
        "items": []
      },
      {
        "title": "7. 다음 이야기",
        "url": "#7-다음-이야기",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 10,
      "wordCount": 2519
    },
    "url": "/posts/blog-remake-7",
    "thumbnail": {
      "local": "/static/header-layout-4a73c159.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-header-layout-4a73c159-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAf0lEQVR4nCXJERpFIRBA4ag1RFEWRtlgloWDLeFiODjYNtK0LaRp2hp63333wJFfSCkB4Jyz926tMXOttbUmYozOOSIqpSAiET3PQ0QvaK1TSjFGABhjrLXuvcIYo5RCRGYOISDiGOMFpZS11nv/vfd+/wkAyDkzMxEx85zzgx8DUkh5YwmWmwAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "blog-remake-8",
    "title": "블로그 만들기 - 8. 글 목록/상세보기 페이지",
    "date": "2023-05-30T00:00:00Z",
    "description": "글 목록 페이지와 글 상세보기 페이지 CSS를 손봐주자. 디자인, TOC, SEO 작업도",
    "tags": [
      "blog",
      "web"
    ],
    "html": "<h1>블로그 만들기 시리즈</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>제목</th><th>링크</th></tr></thead><tbody><tr><td>1. 기본 세팅</td><td><a href=\"https://witch.work/posts/blog-remake-1\">https://witch.work/posts/blog-remake-1</a></td></tr><tr><td>2. 메인 페이지의 HTML 설계</td><td><a href=\"https://witch.work/posts/blog-remake-2\">https://witch.work/posts/blog-remake-2</a></td></tr><tr><td>3. 글 상세 페이지의 구조 설계</td><td><a href=\"https://witch.work/posts/blog-remake-3\">https://witch.work/posts/blog-remake-3</a></td></tr><tr><td>4. 이미지를 상대 경로로 쓸 수 있도록 하기</td><td><a href=\"https://witch.work/posts/blog-remake-4\">https://witch.work/posts/blog-remake-4</a></td></tr><tr><td>5. 자잘한 페이지 구성 개선과 배포</td><td><a href=\"https://witch.work/posts/blog-remake-5\">https://witch.work/posts/blog-remake-5</a></td></tr><tr><td>6. 페이지 요소의 배치 설계</td><td><a href=\"https://witch.work/posts/blog-remake-6\">https://witch.work/posts/blog-remake-6</a></td></tr><tr><td>7. 메인 페이지 컴포넌트 디자인</td><td><a href=\"https://witch.work/posts/blog-remake-7\">https://witch.work/posts/blog-remake-7</a></td></tr><tr><td>8. 글 목록/내용 페이지 컴포넌트 디자인</td><td><a href=\"https://witch.work/posts/blog-remake-8\">https://witch.work/posts/blog-remake-8</a></td></tr><tr><td>9. 글 썸네일 자동 생성하기</td><td><a href=\"https://witch.work/posts/blog-remake-9\">https://witch.work/posts/blog-remake-9</a></td></tr><tr><td>10. 폰트, 카드 디자인 등의 디자인 개선</td><td><a href=\"https://witch.work/posts/blog-remake-10\">https://witch.work/posts/blog-remake-10</a></td></tr><tr><td>11. 글에 조회수 달기</td><td><a href=\"https://witch.work/posts/blog-remake-11\">https://witch.work/posts/blog-remake-11</a></td></tr><tr><td>12. 페이지 테마와 글 검색 기능</td><td><a href=\"https://witch.work/posts/blog-remake-12\">https://witch.work/posts/blog-remake-12</a></td></tr><tr><td>13. 테마 아이콘과 썸네일 레이아웃 개선 등</td><td><a href=\"https://witch.work/posts/blog-remake-13\">https://witch.work/posts/blog-remake-13</a></td></tr><tr><td>14. 글 분류를 태그 기반으로 변경</td><td><a href=\"https://witch.work/posts/blog-remake-14\">https://witch.work/posts/blog-remake-14</a></td></tr><tr><td>메인 페이지의 연산 최적화</td><td><a href=\"https://witch.work/posts/blog-opt-1\">https://witch.work/posts/blog-opt-1</a></td></tr><tr><td>글 목록 페이지네이션 만들기</td><td><a href=\"https://witch.work/posts/blog-opt-2\">https://witch.work/posts/blog-opt-2</a></td></tr><tr><td>이미지를 CDN에 올리고 placeholder 만들기</td><td><a href=\"https://witch.work/posts/blog-opt-3\">https://witch.work/posts/blog-opt-3</a></td></tr><tr><td>검색 페이지에 무한 스크롤 구현하기</td><td><a href=\"https://witch.work/posts/blog-opt-4\">https://witch.work/posts/blog-opt-4</a></td></tr></tbody></table>\n<p>메인 페이지의 <code>Card</code> 컴포넌트를 만들고 있었는데 <code>Card</code>가 글 카테고리 페이지에서도 쓰이기 때문에 이를 위해서 썸네일을 만들어 주는 작업을 하려고 했다.</p>\n<p>그러나 이를 설계하다 보니 사전에 해야 할 일이 점점 많아져서 먼저 다른 페이지들을 간단히나마 손보고 나서 할 예정이다. 이 글은 그렇게 다른 페이지를 약간 손보는 내용이다. 썸네일을 만드는 공사는 다음 글에 할 예정이다.</p>\n<h1>1. 글 목록 페이지 바꾸기</h1>\n<p>사실 메인 페이지에서 보이는 <code>Card</code> 컴포넌트의 용도 같은 경우 이미 이전 글에서 다 만들었다. 디자인에 아직 개선할 부분이 있지만 들어갈 내용은 다 들어가 있으니. 그런데 <code>Card</code>는 글 카테고리별로 글 목록을 보여주는 페이지에서도 쓰인다. 따라서 여기에 맞는 디자인도 해주자.</p>\n<p>그런데 지금 글 목록 페이지에서 Card 컴포넌트가 어떻게 쓰이는지를 보면서 해야 하는데 글 목록 페이지가 아직 디자인되지 않았다. 따라서 글 목록 페이지에서 Card 컴포넌트를 잘 볼 수 있게 하기 위해서만 조금 바꿔주자.</p>\n<p>본격적으로는 좀 이후에 다시 다룰 것이다.(사실 글 목록 페이지는 별거 없어서 카드를 잘 디자인한다면 그 이후에 크게 엄청난 디자인이 있지 않을 거라 생각하지만)</p>\n<p>먼저 전체 글 목록을 메인 페이지에서 했듯이 width 92%를 갖는 컨테이너로 한번 감싸고, 글 목록 태그(ul)의 기본 스타일을 없앤다. 또한 글 블럭 간의 약간의 간격 주기. 이 정도만 해도 썸네일을 넣고 괜찮은지 볼 정도의 레이아웃은 될 것 같다.</p>\n<p>글 목록 페이지를 담당하는 <code>pages/posts/[category]/index.tsx</code> 파일을 열고 <code>PostListPage</code> 컴포넌트를 다음과 같이 수정한다.</p>\n<pre><code class=\"language-tsx\">function PostListPage({\n  category, postList,\n}: InferGetStaticPropsType&#x3C;typeof getStaticProps>) {\n  return (\n    &#x3C;main className={styles.pagewrapper}>\n    {/* container, list 클래스가 추가되었다 */}\n      &#x3C;div className={styles.container}>\n        &#x3C;h1>{category}&#x3C;/h1>\n        &#x3C;ul className={styles.list}>\n          {postList.map((post: PostMetaData) => \n            &#x3C;li key={post.url}>\n              &#x3C;Card {...post} />\n            &#x3C;/li>\n          )}\n        &#x3C;/ul>\n      &#x3C;/div>\n    &#x3C;/main>\n  );\n}\n</code></pre>\n<p>그리고 위에서 추가된 클래스의 CSS는 다음과 같이 작성한다. 어차피 너비에 상관없이 같은 레이아웃이 될 부분이므로 미디어 쿼리는 없어도 된다.</p>\n<pre><code class=\"language-css\">// pages/posts/[category]/style.module.css 에 해당 부분 추가\n.container{\n  width:92%;\n  margin:0 auto;\n}\n\n.list{\n  list-style:none;\n  padding:0;\n  margin:0;\n  display:flex;\n  flex-direction:column;\n  gap:1rem;\n}\n</code></pre>\n<h1>2. 글로벌 CSS 적용</h1>\n<h2>2.1. 글로벌 스타일</h2>\n<p>글 상세보기 페이지를 만들기 전에, 문제가 발생했다. 현재 배포된 블로그를 모바일에서 들어가 보았는데 글씨체도 다르고 간격도 약간씩 달라 보였다. 따라서 글로벌 reset CSS를 적용해 주자.</p>\n<p><code>src/styles/globals.css</code>를 편집해 주자.</p>\n<p><a href=\"https://github.com/blurfx/gatsby-starter-lavender\">gatsby-starter-lavender</a>의 글로벌 CSS를 거의 똑같이 따왔다.</p>\n<pre><code class=\"language-css\">// src/styles/globals.css\n:root {\n  --white:#fff;\n  --black:#000;\n\n  --gray0:#f8f9fa;\n  --gray1:#f1f3f5;\n  --gray2:#e9ecef;\n  --gray3:#dee2e6;\n  --gray4:#ced4da;\n  --gray5:#adb5bd;\n  --gray6:#868e96;\n  --gray7:#495057;\n  --gray8:#343a40;\n  --gray9:#212529;\n\n  --indigo0:#edf2ff;\n  --indigo1:#dbe4ff;\n  --indigo2:#bac8ff;\n  --indigo3:#91a7ff;\n  --indigo4:#748ffc;\n  --indigo5:#5c7cfa;\n  --indigo6:#4c6ef5;\n  --indigo7:#4263eb;\n  --indigo8:#3b5bdb;\n  --indigo9:#364fc7;\n\n  font-family:\"Pretendard\", apple-system, system-ui, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif;\n  text-rendering: optimizeLegibility;\n}\n\n* {\n  box-sizing:border-box;\n  margin:0;\n  padding:0;\n}\n\nhtml, body {\n  min-height:100vh;\n}\n\na {\n  color: inherit;\n  text-decoration: none;\n}\n\nh1 {\n  font-size:1.75rem;\n}\n\nh2 {\n  font-size:1.5rem;\n}\n\nh3 {\n  font-size:1.25rem;\n}\n\nh4 {\n  font-size:1rem;\n}\n\nh5 {\n  font-size:0.875rem;\n}\n\nh6 {\n  font-size:0.75rem;\n}\n\nhr{\n  margin:0.25rem 0;\n  border:0;\n  border-top:0.125rem solid var(--gray5);\n}\n\nimg{\n  display:block;\n  margin:0 auto;\n}\n\np{\n  margin:0.75rem 0;\n  line-height:1.625rem;\n}\n\ntable{\n  width:100%;\n  margin:0.75rem 0;\n  border-collapse:collapse;\n  line-height:1.75rem;\n}\n\ntr{\n  border-bottom:1px solid var(--gray5);\n}\n\nth, td{\n  padding:0.75rem 0;\n}\n\nblockquote{\n  padding-left:1rem;\n  border-left:0.25rem solid var(--indigo7);\n}\n\narticle{\n  overflow-wrap:break-word;\n}\n\narticle :is(ul, ol){\n  margin-left:2rem;\n}\n\narticle :is(ul, ol) :is(ul, ol){\n  margin-left:1.5rem;\n}\n\narticle :is(ul, ol) li{\n  margin:0.375rem 0;\n}\n\narticle :is(ul, ol) li p{\n  margin:0;\n}\n\narticle pre[class^=\"language-\"]{\n  border-radius:0.25rem;\n}\n\npre[class*=\"language-\"], code[class*=\"language-\"]: {\n  white-space: 'pre-wrap',\n}\n</code></pre>\n<p>이렇게 하고 나면 메인 페이지의 레이아웃이 약간 변형된다. 원래대로 돌려 주는 작업을 좀 해주자.</p>\n<h2>2.2. 헤더, 푸터</h2>\n<p>내부에 레이아웃 생각할 요소도 많지 않거니와 가능한 거의 모든 것에 클래스를 박아 놓았기 때문에 고칠 게 없다.</p>\n<h2>2.3. 자기소개 컴포넌트</h2>\n<p>내 소개의 링크들이 article 태그의 후손인 ul 태그에 들어 있기에 글로벌 CSS의 영향을 받는다. 따라서 margin을 기본적으로 없애주고, p 태그의 line-height를 줄여준다. 그리고 linkbox 클래스를 만들어서 링크를 감싸는 li 태그의 margin을 없앤다.</p>\n<pre><code class=\"language-css\">// src/components/profile/intro/styles.module.css\n.description{\n  margin:10px 0;\n  word-break:keep-all;\n  line-height:1.2;\n}\n\n.linklist{\n  display:flex;\n  flex-direction:row;\n  list-style:none;\n  padding-left:0;\n  margin:0;\n  margin-bottom:0.5rem;\n  gap:0 15px;\n}\n\n.link{\n  text-decoration:none;\n  color:var(--indigo6);\n}\n\n.linkbox{\n  margin:0;\n}\n</code></pre>\n<p>Intro 컴포넌트 내부의 링크를 감싸는 부분에 <code>linkbox</code> 클래스 추가</p>\n<pre><code class=\"language-tsx\">// src/components/profile/intro/index.tsx 일부\n&#x3C;ul className={styles.linklist}>\n  {Object.entries(blogConfig.social).map(([key, value]) => (\n    {/* 여기에 linkbox 클래스 추가 */}\n    &#x3C;li key={key} className={styles.linkbox}>\n      &#x3C;Link href={value} target='_blank' className={styles.link}>\n        {key}\n      &#x3C;/Link>\n    &#x3C;/li>\n  ))}\n&#x3C;/ul>\n</code></pre>\n<h2>2.4. 프로젝트 소개 컴포넌트</h2>\n<p>가장 먼저 보이는 건 ul 태그의 왼쪽 margin과 li의 상하 마진이다. 이를 없애주자. 일단 <code>projectList</code>전체를 감싸고 있는 article태그에 <code>styles.container</code> 클래스를 적용한 후 이 내부에 있는 ul, li에 대해서 모두 처리해 주면 된다.</p>\n<pre><code class=\"language-css\">// src/components/projectList/styles.module.css에 추가\n.container ul{\n  margin-left:0;\n}\n\n.container li{\n  margin:0;\n}\n</code></pre>\n<p>그리고 현재는 개별 프로젝트 컴포넌트 간의 간격이 margin과 grid display의 gap이 섞여서 쓰이고 있는데 이를 gap으로 통일해주자.</p>\n<p>projectList의 list 클래스의 gap을 1rem으로 설정.</p>\n<pre><code class=\"language-css\">// src/components/projectList/styles.module.css에 추가\n.list{\n  list-style:none;\n  padding:0;\n  display:grid;\n  grid-template-columns:1fr;\n  grid-template-rows:1fr;\n  gap:1rem;\n}\n</code></pre>\n<p>project 컴포넌트의 container margin은 삭제. <code>projectList</code>의 제목과 프로젝트 사진을 같은 줄로 정렬하기 위해 container의 padding-left도 0으로. 또 프로젝트 이미지는 현재 <code>margin:0 auto;</code>로 설정되어서 이상하게 정렬되므로 이를 없애주자.</p>\n<pre><code class=\"language-css\">// src/components/projectList/project/styles.module.css\n.container{\n  display: flex;\n  flex-direction: row;\n  gap:1rem;\n  box-sizing: border-box;\n  /* padding 수정됨 */\n  padding:15px 15px 15px 0;\n  min-height:150px;\n}\n\n.image{\n  border-radius:1rem;\n  /* margin 0으로 */\n  margin:0;\n}\n\n@media (min-width: 768px) {\n  .container{\n    /* padding 수정됨 */\n    padding:10px 10px 10px 0;\n  }\n\n  .image{\n    display: block;\n  }\n}\n</code></pre>\n<p>projectList가 접힌 상태일 때도 row-gap이 적용되어 아래쪽에 여백이 생기는 문제가 있었다. 따라서 접힌 상태일 때는 row-gap을 없애주자.</p>\n<p>그런데 이렇게만 하면 <code>list--close</code> 클래스는 화면 너비가 넓을 때도 적용되므로 화면 너비가 넓은 상태에서도 row-gap이 없어지는 문제가 있다. 따라서 화면 너비가 넓을 땐 적당한 gap을 또 적용해 주자.</p>\n<pre><code class=\"language-css\">.list--close{\n  grid-auto-rows:0;\n  overflow:hidden;\n  // 닫혀있을땐 row-gap 없게\n  row-gap:0;\n}\n\n@media (min-width: 768px) {\n  .list{\n    display:grid;\n    grid-template-columns:repeat(2,1fr);\n    grid-auto-rows:1fr;\n    // 화면 너비 넓을 땐 gap이 늘 있다\n    row-gap:1rem;\n    column-gap:2rem;\n  }\n}\n</code></pre>\n<p>그리고 아래 컴포넌트와의 간격이 없어진 projectList 컨테이너에 약간의 하단 여백을 주자.</p>\n<pre><code class=\"language-css\">// src/components/projectList/styles.module.css\n.container{\n  margin-bottom:2rem;\n}\n</code></pre>\n<h2>2.5. 글 카테고리 컴포넌트</h2>\n<p><code>Category</code>와 <code>Card</code>컴포넌트를 손보자.</p>\n<p>Category는 그냥 ul의 margin을 없애주고 container에 구분을 위한 약간의 하단 간격을 준다.</p>\n<pre><code class=\"language-tsx\">// src/components/category/index.tsx\nfunction Category(props: Props) {\n  return (\n    &#x3C;section className={styles.container}>\n      &#x3C;h2 className={styles.title}>{props.title}&#x3C;/h2>\n      \n      &#x3C;ul className={styles.list}>\n        {props.items.map((item) => {\n          return (\n            &#x3C;li key={item.url}>\n              &#x3C;Card\n                {...propsProperty(item)}\n              />\n            &#x3C;/li>\n          );\n        })}\n      &#x3C;/ul>\n    &#x3C;/section>\n  );\n}\n</code></pre>\n<p>즉 CSS를 다음과 같이.</p>\n<pre><code class=\"language-css\">// src/components/category/styles.module.css\n.container{\n  margin-bottom:2rem;\n}\n\n.list{\n  list-style:none;\n  padding:0;\n  display: grid;\n  gap:1rem;\n  margin:0;\n}\n\n@media (min-width:768px){\n  .list{\n    grid-template-columns:repeat(3,1fr);\n  }\n}\n</code></pre>\n<p>그리고 <code>Card</code>의 경우에는 카테고리 제목과 정렬하기 위해 <code>padding-left</code>를 없애주고 hover 시에만 약간의 이펙트를 위해서 <code>padding-left</code>가 생기도록 했다. link 클래스만 편집해주면 된다.</p>\n<pre><code class=\"language-css\">// src/components/card/styles.module.css\n.link{\n  display:block;\n  height:100%;\n  padding:1rem;\n  padding-left:0;\n  text-decoration:none;\n  color:var(--black);\n}\n\n.link:hover{\n  padding-left:1rem;\n  border-radius: 1rem;\n  color:var(--indigo6);\n  background-color:var(--gray1);\n}\n</code></pre>\n<h1>3. 글 상세보기 페이지</h1>\n<h2>3.1. 컨테이너 레이아웃</h2>\n<p><code>/pages/posts/[category]/[slug].tsx</code>와 같은 디렉토리의 <code>styles.module.css</code>를 편집하자.</p>\n<p>이는 글의 컨텐츠가 들어가는 위치에 wrapper class를 준 후 스타일링을 하면 된다. 클래스 이름은 간단하게 content로 지었다.</p>\n<pre><code class=\"language-tsx\">// src/pages/posts/[category]/[slug].tsx\nfunction PostPage({\n  post\n}: InferGetStaticPropsType&#x3C;typeof getStaticProps>) {\n  return (\n    &#x3C;main className={styles.pagewrapper}>\n      &#x3C;article className={styles.container}>\n        &#x3C;h1>{post.title}&#x3C;/h1>\n        &#x3C;time>{post.date}&#x3C;/time>\n        &#x3C;ul>\n          {post.tags.map((tag: string)=>&#x3C;li key={tag}>{tag}&#x3C;/li>)}\n        &#x3C;/ul>\n        {'code' in post.body?\n        {/* 래퍼 클래스 post */}\n          &#x3C;div className={styles.content}>\n            &#x3C;MDXComponent code={post.body.code}/>\n          &#x3C;/div>\n          :\n          &#x3C;div \n            className={styles.content} \n            dangerouslySetInnerHTML={{ __html: post.body.html }} \n          />\n        }\n      &#x3C;/article>\n    &#x3C;/main>\n  );\n}\n</code></pre>\n<p>예를 들어서 포스트 내의 h1 태그를 스타일링하고 싶다고 하면 <code>.content h1</code> 선택자에 스타일을 주면 된다. styled-component 같은 걸 쓸 때는 이렇게 불편하지 않았는데, 왜 CSS in JS가 유행했는지 좀 알 것 같다..</p>\n<p>좀 폴더 구조 정리를 하자. 일단 <code>[slug].tsx</code>를 폴더로 분리하자. <code>pages/posts/[category]/[slug]</code> 폴더를 만들고 해당 폴더에 <code>index.tsx</code>와 <code>styles.module.css</code>를 생성한 후 원래 <code>[slug].tsx</code>에 있던 내용을 방금 만든 <code>index.tsx</code>에 옮기자.</p>\n<p>그리고 포스트 내용 관련된 css는 다른 CSS 모듈 파일로 분리하자. <code>pages/posts/[category]/[slug]</code>에 <code>content.module.css</code>를 생성하고 .content 클래스를 만들어준다. 현재 <code>[slug]</code>폴더 내엔 index.tsx, styles.module.css, content.module.css가 있고 그 각각의 내용은 다음과 같다. <code>getStaticPaths, getStaticProps</code>는 이전 글에서 설명했으므로 생략하였다.</p>\n<pre><code class=\"language-tsx\">import {\n  GetStaticPaths,\n  GetStaticProps,\n  InferGetStaticPropsType,\n} from 'next';\nimport { useMDXComponent } from 'next-contentlayer/hooks';\n\nimport { getSortedPosts } from '@/utils/post';\n\nimport contentStyles from './content.module.css';\nimport styles from './styles.module.css';\n\n\ninterface MDXProps{\n  code: string;\n}\n\nfunction MDXComponent(props: MDXProps) {\n  const MDX = useMDXComponent(props.code);\n  return &#x3C;MDX />;\n}\n\nfunction PostPage({\n  post\n}: InferGetStaticPropsType&#x3C;typeof getStaticProps>) {\n  return (\n    &#x3C;main className={styles.page}>\n      &#x3C;article className={styles.container}>\n        &#x3C;h1>{post.title}&#x3C;/h1>\n        &#x3C;time>{post.date}&#x3C;/time>\n        &#x3C;ul>\n          {post.tags.map((tag: string)=>&#x3C;li key={tag}>{tag}&#x3C;/li>)}\n        &#x3C;/ul>\n        {'code' in post.body?\n          &#x3C;div className={contentStyles.content}>\n            &#x3C;MDXComponent code={post.body.code}/>\n          &#x3C;/div>\n          :\n          &#x3C;div\n            className={contentStyles.content} \n            dangerouslySetInnerHTML={{ __html: post.body.html }} \n          />\n        }\n      &#x3C;/article>\n    &#x3C;/main>\n  );\n}\n\nexport default PostPage;\n</code></pre>\n<p><code>content.module.css</code></p>\n<pre><code class=\"language-css\">// src/pages/posts/[category]/[slug]/content.module.css\n.content{\n  margin:0 auto;\n  width:100%;\n  min-height:100vh;\n}\n</code></pre>\n<p><code>styles.module.css</code></p>\n<pre><code class=\"language-css\">// src/pages/posts/[category]/[slug]/styles.module.css\n.page{\n  margin:0 auto;\n  width:100%;\n  min-height:100vh;\n}\n\n.container{\n  width:92%;\n  /*max-width:calc(100% - 48px);*/\n  margin:0 auto;\n}\n\n@media (min-width: 768px) {\n  .page{\n    max-width:50rem;\n  }\n}\n</code></pre>\n<h2>3.2. 글 컨텐츠 레이아웃</h2>\n<p>이제 <code>content</code>클래스의 자식 셀렉터를 한번 만들어보자. <code>src/pages/posts/[category]/[slug]/content.module.css</code>를 편집하면 된다.</p>\n<p>그리고 아주 좋은 레퍼런스가 있다. 그게 무엇인가? 원래 쓰던 <a href=\"https://gatsby-starter-lavender.vercel.app/\">gatsby-starter-lavender</a>. 일단 여기 있는 걸 다 따오자.</p>\n<pre><code class=\"language-css\">// src/pages/posts/[category]/[slug]/content.module.css\n.content{\n  margin:0 auto;\n  width:100%;\n  min-height:100vh;\n  word-break:keep-all;\n}\n\n.content h1{\n  margin: 2rem 0 1.25rem 0;\n  padding-bottom:0.25rem;\n  border-bottom:1px solid var(--gray5);\n  font-weight:600;\n}\n\n.content h1 a{\n  border-bottom:none;\n}\n\n.content h2{\n  margin: 1.5rem 0 1rem 0;\n  padding-bottom:0.25rem;\n  border-bottom:1px solid var(--gray5);\n}\n\n.content h2 a{\n  border-bottom:none;\n}\n\n.content a{\n  border-bottom:1px solid var(--indigo7);\n  color:var(--indigo7);\n}\n\n.content pre code{\n  white-space:pre-wrap;\n  word-break:break-all;\n  overflow-wrap:break-word;\n}\n\n/* 점 병합에 관한 옵션 */\n.content :is(pre,code){\n  font-variant-ligatures: none;\n}\n</code></pre>\n<p>그리고 코드를 예쁘게 만들기 위해 <code>contentlayer.config.js</code>에서 다음과 같이 rehype plugin 적용.</p>\n<pre><code class=\"language-js\">// contentlayer.config.js\nconst rehypePrettyCodeOptions = {\n  theme: 'github-light',\n};\n\nexport default makeSource({\n  contentDirPath: 'posts',\n  documentTypes: [MDXPost, Post],\n  markdown: {\n    remarkPlugins: [remarkGfm, changeImageSrc],\n    rehypePlugins: [[rehypePrettyCode, rehypePrettyCodeOptions]],\n  },\n  mdx: {\n    remarkPlugins: [remarkGfm, changeImageSrc],\n    rehypePlugins: [[rehypePrettyCode, rehypePrettyCodeOptions], highlight],\n  },\n});\n</code></pre>\n<p>그런데 이렇게 해도 어쩐지 코드의 글씨체가 자꾸 monospace로 나왔다. 따라서 <code>content.styles.css</code>에 가서 <code>.content :is(pre,code)</code>에 <code>font-family</code>를 새로 주었다.</p>\n<p>그리고 코드 블럭의 배경 등을 주기 위해서 다음과 같이 예의 <code>content.module.css</code> 내용을 추가했다.</p>\n<pre><code class=\"language-css\">// src/pages/posts/[category]/[slug]/content.module.css\n\n```css\n.content pre code{\n  white-space:pre-wrap;\n  word-break:break-all;\n  overflow-wrap:break-word;\n}\n\n/* 점 병합에 관한 옵션 */\n.content :is(pre,code){\n  font-family:monospace, Pretendard, apple-system, system-ui, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif;\n  font-variant-ligatures: none;\n  font-size:1rem;\n  overflow:auto;\n}\n\n.content pre{\n  margin:1rem 0;\n  padding:1rem;\n  border-radius:0.5rem;\n  background-color:var(--gray1);\n  line-height:1.5;\n}\n\n.content :not(pre) > code{\n  padding:0.25rem;\n  border-radius:0.25rem;\n  background-color:var(--indigo0);\n  color:var(--indigo9);\n}\n\n.content img{\n  display:block;\n  margin:0 auto;\n  max-width:92%;\n}\n\n.content blockquote{\n  border-left:2px solid var(--gray5);\n  padding-left:1rem;\n  color:var(--gray7);\n}\n\n.content p{\n  line-height:1.625;\n  margin-bottom:1.25rem;\n}\n\n.content p code{\n  white-space:pre-wrap;\n}\n\n.content hr{\n  border:0;\n  border-top:1px solid var(--gray5);\n  margin:0.5rem 0;\n}\n</code></pre>\n<p>또 너무 화면 너비가 작아지면 글 양쪽의 여백이 너무 좁아지는 것 같아서 max-width를 전체 너비에서 48px는 작게 되도록 설정했다. (<a href=\"https://toss.tech/tech\">토스 기술블로그</a>의 레이아웃을 참고했다)</p>\n<pre><code class=\"language-css\">// src/pages/posts/[category]/[slug]/styles.module.css\n.container{\n  width:92%;\n  // 이걸 추가했다.\n  max-width:calc(100% - 48px);\n  margin:0 auto;\n}\n</code></pre>\n<h2>3.3. 글의 제목, 태그</h2>\n<p>이제 글은 잘 보인다 치자. 그런데 아직 제목과 작성시간, 태그는 기본 스타일로 보이고 있다. 여기에 적절한 스타일을 주자.</p>\n<p><code>src/pages/posts/[category]/[slug]/index.tsx</code>의 <code>PostPage</code>에 클래스들을 먼저 추가하자. 날짜 포매팅은 덤으로 해준다.</p>\n<pre><code class=\"language-tsx\">function PostPage({\n  post\n}: InferGetStaticPropsType&#x3C;typeof getStaticProps>) {\n  const dateObj=new Date(post.date);\n  return (\n    &#x3C;main className={styles.page}>\n      &#x3C;article className={styles.container}>\n        &#x3C;h1 className={styles.title}>{post.title}&#x3C;/h1>\n        &#x3C;time className={styles.time} dateTime={toISODate(dateObj)}>\n          {formatDate(dateObj)}\n        &#x3C;/time>\n        &#x3C;ul className={styles.tagList}>\n          {post.tags.map((tag: string)=>\n            &#x3C;li key={tag} className={styles.tag}>{tag}&#x3C;/li>\n          )}\n        &#x3C;/ul>\n        {'code' in post.body?\n          &#x3C;div className={contentStyles.content}>\n            &#x3C;MDXComponent code={post.body.code}/>\n          &#x3C;/div>\n          :\n          &#x3C;div\n            className={contentStyles.content} \n            dangerouslySetInnerHTML={{ __html: post.body.html }} \n          />\n        }\n      &#x3C;/article>\n    &#x3C;/main>\n  );\n}\n</code></pre>\n<p>그리고 각 요소 스타일링은 다음과 같다. <code>container</code>클래스에 margin을 줘서 헤더와 글 부분 간의 간격을 좀 두었다. <code>page</code> 클래스는 이전과 같다.</p>\n<pre><code class=\"language-css\">// src/pages/posts/[category]/[slug]/styles.module.css\n.container{\n  width:92%;\n  max-width:calc(100% - 48px);\n  margin:0 auto;\n  margin-top:2rem;\n}\n\n.title{\n  font-size:2rem;\n  font-weight:700;\n  margin-bottom:1rem;\n}\n\n.time{\n  display:block;\n  font-size:1.25rem;\n  font-weight:400;\n  margin-bottom:0.5rem;\n}\n\n.tagList{\n  list-style:none;\n  margin:0;\n  display:flex;\n  flex-wrap:wrap;\n  flex-direction:row;\n  gap:10px;\n}\n\n.tag{\n  background-color:var(--indigo1);\n  color:var(--indigo8);\n  padding:5px;\n  border-radius:5px;\n}\n</code></pre>\n<h1>4. 다시, 글 목록 페이지</h1>\n<p>global CSS를 만들어 주고 나서 글 목록 페이지는 거들떠보지도 않았었는데 여기에서도 약간 이상해진 간격들이 있으니 간단히 고치고 넘어가자.</p>\n<h2>4.1. 주제 따오는 방식 바꾸기</h2>\n<p>그런데 현재 글 목록 페이지에 들어가 보면 글 주제의 표기가 <code>dev</code>, <code>misc</code> 따위가 아니라 <code>개발</code>, <code>기타</code>로 바뀐지가 언젠데 아직 적용이 안되어 있다.</p>\n<p>이는 <code>src/pages/posts/[category]/index.tsx</code>에서 <code>getStaticProps</code>를 수정하면 된다. 다음과 같이 넘겨주는 <code>category</code>가 진짜 게시판의 제목이 되도록 바꿔준다.</p>\n<pre><code class=\"language-tsx\">/*\nsrc/pages/posts/[category]/index.tsx\n의 getStaticProps를 이렇게 수정한다.\n*/\nexport const getStaticProps: GetStaticProps = ({params}) => {\n  const allDocumentsInCategory = getSortedPosts().filter((post)=>\n    post._raw.flattenedPath.startsWith(params?.category as string\n    ));\n  // category를 얻어오는 방식을 바꿨다.\n  const category=blogCategoryList.find((c)=>\n    c.url.split('/').pop()===params?.category)?.title;\n\n  const postList = allDocumentsInCategory.map((post) => ({\n    title: post.title,\n    description: post.description,\n    date: post.date,\n    tags: post.tags,\n    url: post.url,\n  }));\n  return { props: { category, postList } };\n};\n</code></pre>\n<h2>4.2. 스타일 조정</h2>\n<p>그리고 <code>src/pages/posts/[category]/styles.module.css</code>를 다음과 같이 수정한다. title 클래스를 새로 만들고, container에 간격을 준 게 전부다.</p>\n<pre><code class=\"language-css\">.page{\n  margin:0 auto;\n  width:100%;\n  min-height:100vh;\n}\n\n.container{\n  width:92%;\n  max-width:calc(100% - 48px);\n  margin:0 auto;\n  margin-top:2rem;\n}\n\n.title{\n  font-size:1.5rem;\n  margin-bottom:0.5rem;\n}\n\n.list{\n  list-style:none;\n  padding:0;\n  margin:0;\n  display:flex;\n  flex-direction:column;\n  gap:1rem;\n}\n\n@media (min-width: 768px) {\n  .page{\n    max-width:60rem;\n  }\n\n  .title{\n    font-size:1.75rem;\n    margin-bottom:1rem;\n  }\n}\n</code></pre>\n<p>하려면 더 할 게 수도 없겠지만 다른 할 게 많으니 글 목록 페이지 수정은 이쯤 마치자.</p>\n<h1>5. TOC 만들어주기</h1>\n<p>TOC는 Table of Contents의 약자로, 글의 목차를 의미한다. 이를 직접 만들어보자. 마크다운 파일에서 h1~h6 태그를 쓰면 이를 직접 파싱해서 TOC를 만들어주는 방식으로 말이다.</p>\n<h2>5.1. 헤딩에 ID 부여하기</h2>\n<p>일단 마크다운 파일에서 모든 heading을 추출해서 ID를 부여해 줘야 한다. 이는 예전에 깔아 놓았던 <code>unist-util-visit</code>을 이용해서 가능하다. 이번에도 커스텀 remark plugin을 만들어서 사용하자. <a href=\"https://claritydev.net/blog/nextjs-blog-remark-interactive-table-of-contents\">여기</a>를 많이 참고했다.</p>\n<p><code>src/plugins/heading-tree.mjs</code>생성하고 내용 작성</p>\n<p>일단 기본적으로 AST에서 h1~h6을 방문하는 코드는 다음과 같다. 단순히 헤딩 노드를 출력하도록 했다.</p>\n<pre><code class=\"language-js\">// src/plugins/heading-tree.mjs\nimport {visit} from 'unist-util-visit';\n\nfunction getHeadings(tree) {\n  visit(tree, 'heading', (node) => {\n    console.log(node);\n  });\n}\n\nexport default function headingTree() {\n  return (tree, file)=>{\n    getHeadings(tree);\n  };\n}\n</code></pre>\n<p>heading 노드들을 잘 출력하는 걸 볼 수 있다. 그럼 이제 각각에 id를 부여해보자. 먼저 mdast를 순회하며 헤딩 요소마다 ID를 추가해 주는 <code>addID</code> 함수를 만들자.</p>\n<pre><code class=\"language-js\">// src/plugins/heading-tree.mjs\nfunction addID(node, headings) {\n  const id=node.children.map(c=>c.value).join('');\n  headings[id]=(headings[id]||0)+1;\n  node.data=node.data||{\n    hProperties:{\n      title:id,\n      // id를 넣는 이유는 같은 제목의 heading이 여러 개 있을 수 있기 때문\n      id:`${id}${(headings[id]>1?`-${headings[id]}`:'')}`\n        .split(' ')\n        .join('-')\n    }\n  };\n}\n</code></pre>\n<p>headings 객체를 사용해서 중복을 확인해 주는 이유가 있는데 이는 같은 제목의 heading이 여러 개 있을 수 있는 상황을 막기 위해서이다. 헤딩의 특성을 생각해 볼 때 그럴 일이 많지는 않을 거라 생각하지만 만약을 대비하여 그냥 넣어주었다.</p>\n<p>id를 만들 땐 공백을 없애주는 것도 잊지 말자. 공백 대신 <code>-</code>을 넣어주었다.</p>\n<p>그리고 위의 <code>node.data</code>의 <code>hProperties</code>에 title, id를 넣어 줬는데 이렇게 하면 해당 특성들이 헤딩 요소의 프로퍼티로 들어간다. 이는 반드시 <code>hProperties</code>라는 이름이어야 하고 다른 건 안된다.</p>\n<p>HTML AST(hast)에서 요소의 프로퍼티를 정해 줄 때 쓰는 프로퍼티명이 <code>hProperties</code>로 정해져 있기 때문이다. <a href=\"https://github.com/syntax-tree/mdast-util-to-hast#hproperties\">hast 관련 github</a>참고.</p>\n<h2>5.2. 헤딩 계층 구조 만들기</h2>\n<p>이제 헤딩들에 계층 구조를 만들어 줘야 한다. h1 헤딩부터 h6 헤딩까지가 있는데 일반적으로 TOC를 사용하는 용법을 생각할 때 이들 간에는 계층 구조가 있기 때문이다.</p>\n<p>예를 들어서 다음과 같이 헤딩들이 쓰여 있다면 캡슐화, 상속, 다형성 헤딩은 <code>객체 지향의 특성</code> 헤딩에 속해 있다고 보는 것이 자연스럽다.</p>\n<pre><code># 1. 객체 지향의 특성\n## 1.1. 캡슐화\n## 1.2. 상속\n## 1.3. 다형성\n</code></pre>\n<p>따라서 이를 구현해 주는 <code>makeHeadingTree</code>함수를 이렇게 만든다.</p>\n<pre><code class=\"language-js\">// src/plugins/heading-tree.mjs\nfunction makeHeadingTree(node, output, depthMap) {\n  const newNode={\n    data:node.data,\n    depth:node.depth,\n    children:[],\n  };\n  /* h1은 부모가 없으므로 바로 headingTree output에 push */\n  if (node.depth===1) {\n    output.push(newNode);\n    depthMap[node.depth]=newNode;\n  }\n  else {\n    /* DFS와 헤딩의 특성상 depth가 현재 방문하고 있는 노드보다 depth가 1작은\n    노드 중 가장 최근에 방문한 노드가 부모가 된다 */\n    const parent=depthMap[node.depth-1];\n    if (parent) {\n      parent.children.push(newNode);\n      /* 특정 depth에서 가장 최근에 방문한 노드 업데이트 */\n      depthMap[node.depth]=newNode;\n    }\n  }\n}\n</code></pre>\n<h2>5.3. 데이터 넘겨주기</h2>\n<p>그럼 아까의 <code>getHeading</code> 함수를 <code>handleHeading</code>으로 이름을 바꾸고, heading 요소들을 순회하며 ID 부여와 헤딩 계층 트리 제작을 해주는 기능을 넣자.</p>\n<pre><code class=\"language-js\">// src/plugins/heading-tree.mjs\nfunction handleHeading(tree) {\n  const headings={};\n  const output=[];\n  const depthMap={};\n  visit(tree, 'heading', (node) => {\n    addID(node, headings);\n    makeHeadingTree(node, output, depthMap);\n    //console.log(node);\n  });\n  return output;\n}\n</code></pre>\n<p><code>handleHeading</code> 함수는 계층적으로 만들어진 헤딩들을 반환한다. 그럼 이를 어떻게 contentlayer가 변환한 파일로 넘겨줄 것인가?</p>\n<p>수많은 console.log를 찍어보며 검토한 결과, remark 플러그인에서 반환하는 함수가 받는 인수 <code>tree, file</code>의 <code>file</code>에 들어 있는 <code>file.data.rawDocumentData</code>가 <code>contentlayer/generated</code>의 변환 파일들에 있는 객체의 <code>_raw</code> 프로퍼티로 넘어간다는 추측을 할 수 있었다.</p>\n<p>따라서 최종적인 플러그인 함수인 <code>headingTree</code>함수에서는 <code>file.data.rawDocumentData</code>에 우리가 만든 헤딩 계층 트리를 추가해 주었다.</p>\n<pre><code class=\"language-js\">// src/plugins/heading-tree.mjs\nexport default function headingTree() {\n  return (tree, file)=>{\n    file.data.rawDocumentData.headingTree=handleHeading(tree);\n  };\n}\n</code></pre>\n<p>그리고 이를 <code>contentlayer.config.ts</code>에서 remark 플러그인으로 추가해 주었다.</p>\n<pre><code class=\"language-ts\">export default makeSource({\n  contentDirPath: 'posts',\n  documentTypes: [MDXPost, Post],\n  markdown: {\n    /* headingTree 플러그인 추가! */\n    remarkPlugins: [remarkGfm, changeImageSrc, headingTree],\n    rehypePlugins: [[rehypePrettyCode, rehypePrettyCodeOptions]],\n  },\n  mdx: {\n    remarkPlugins: [remarkGfm, changeImageSrc, headingTree],\n    rehypePlugins: [[rehypePrettyCode, rehypePrettyCodeOptions], highlight],\n  },\n});\n</code></pre>\n<p>이렇게 한 상태에서 <code>npm run dev</code> 실행후 <code>contentlayer/generated</code>에 들어가서 md 파일의 변환 결과를 보면 <code>_raw</code>에 <code>headingTree</code> 프로퍼티가 아주 잘 들어가 있으며 계층 구조도 잘 생겨 있는 걸 볼 수 있다.</p>\n<h2>5.4. TOC 제작</h2>\n<p>TOC를 위한 헤딩 트리(?)의 구조는 다 잡혔다. 각 글에 대한 마크다운 파일의 변환 데이터는 <code>src/pages/[category]/[slug]/index.tsx</code>의 <code>getStaticProps</code>에서 받아진다. 이는 <code>contentlayer/generated</code>에 있는 JSON 파일을 가져오는 것이다.</p>\n<p>따라서 우리는 해당 tsx 파일의 <code>PostPage</code> 컴포넌트에서 post props의 <code>post._raw.headingTree</code>를 통해 아까 만든 헤딩 트리를 얻을 수 있다.</p>\n<p>그럼 이를 렌더링할 컴포넌트를 만들자. <code>src/components/toc</code>폴더와 그 내부의 index.tsx와 styles.module.css를 생성한다.</p>\n<p>먼저 헤딩 트리의 각 노드를 위한 타입을 생성해준다. 재귀적 구조에 유의.</p>\n<pre><code class=\"language-tsx\">interface ContentType{\n  data: {\n    hProperties: {\n      id: string;\n      title: string;\n    }\n  };\n  depth: number;\n  children: ContentType[];\n}\n</code></pre>\n<p>그리고 헤딩 트리를 재귀적으로 렌더링해 주는 <code>renderContent</code>함수가 있다고 가정하고 먼저 다음과 같은 TOC 컴포넌트 구조 작성.</p>\n<pre><code class=\"language-tsx\">function TableOfContents({nodes}: {nodes: ContentType[]}) {\n  if (!nodes.length) return null;\n  return (\n    &#x3C;section>\n      &#x3C;span>Table of Contents&#x3C;/span>\n      {renderContent(nodes)}\n    &#x3C;/section>\n  );\n}\n\nexport default TableOfContents;\n</code></pre>\n<p><code>renderContent</code> 함수는 다음과 같이 ul 태그 내에 재귀적으로 헤딩 트리를 렌더링해주도록 작성한다.</p>\n<pre><code class=\"language-tsx\">function renderContent(nodes: ContentType[]) {\n  return (\n    &#x3C;ul>\n      {nodes.map((node: ContentType) => (\n        &#x3C;li key={node.data.hProperties.id}>\n          &#x3C;a href={`#${node.data.hProperties.id}`}>{node.data.hProperties.title}&#x3C;/a>\n          {node.children.length>0 &#x26;&#x26; renderContent(node.children)}\n        &#x3C;/li>\n      ))}\n    &#x3C;/ul>\n  );\n}\n</code></pre>\n<p><code>src/pages/[category]/[slug]/index.tsx</code>의 <code>PostPage</code>의 적절한 위치에 다음과 같이 TOC 컴포넌트를 넣어 주면 글의 목차가 자동으로 생성되어 나오는 것을 볼 수 있다. 링크도 잘 작동한다.</p>\n<pre><code class=\"language-tsx\">&#x3C;TableOfContents nodes={post._raw.headingTree} />\n</code></pre>\n<p><img src=\"/static/toc-layout-dcc4903f.png\" alt=\"toc-layout\"></p>\n<h2>5.5. 부드러운 스크롤과 스타일링</h2>\n<p>지금 상태에서는 TOC에서 특정 목차를 누르면 해당 목차로 스크롤이 이동하지만, 한번에 이동해 버린다. 이 스크롤 이동을 좀 더 부드럽게 이동하도록 만들어 보자. 또한 간단한 스타일링도 해보자.</p>\n<p>부드러운 스크롤은 간단하다. 그냥 global CSS의 <code>scroll-behavior</code>를 수정하면 된다.</p>\n<pre><code class=\"language-css\">// src/styles/globals.css\nhtml, body {\n  min-height:100vh;\n  scroll-behavior: smooth;\n}\n</code></pre>\n<p>그다음 TOC 컴포넌트에 다음과 같이 클래스들을 부여.</p>\n<pre><code class=\"language-tsx\">function renderContent(nodes: ContentType[]) {\n  return (\n    &#x3C;ul className={`${styles.list} ${nodes[0].depth-1?'':styles.list__h1}`}>\n      {nodes.map((node: ContentType) => (\n        &#x3C;li key={node.data.hProperties.id} className={styles.item}>\n          &#x3C;a\n            className={styles.link}\n            href={`#${node.data.hProperties.id}`}\n          >\n            {node.data.hProperties.title}\n          &#x3C;/a>\n          {node.children.length>0 &#x26;&#x26; renderContent(node.children)}\n        &#x3C;/li>\n      ))}\n    &#x3C;/ul>\n  );\n}\n\nfunction TableOfContents({nodes}: {nodes: ContentType[]}) {\n  if (!nodes.length) return null;\n  return (\n    &#x3C;section>\n      &#x3C;span className={styles.title}>Table of Contents&#x3C;/span>\n      {renderContent(nodes)}\n    &#x3C;/section>\n  );\n}\n</code></pre>\n<p>각 클래스의 스타일링은 다음과 같이 해준다.</p>\n<pre><code class=\"language-css\">.title{\n  display:block;\n  font-size:1.25rem;\n  font-weight:700;\n  margin:0.5rem 0;\n}\n\n.list{\n  list-style: none;\n  margin-left:1.5rem;\n  font-size:0.875rem;\n}\n\n.list__h1{\n  margin-left:0;\n}\n\n.item{\n  margin:0;\n}\n\n.link{\n  color:var(--gray7);\n  line-height:1.75;\n  text-decoration:underline;\n}\n\n.link:hover{\n  color:var(--indigo6);\n}\n</code></pre>\n<h2>5.6. 스크롤 이동 위치 문제</h2>\n<p>현재 만들어진 목차를 통해서 각 목차의 헤딩 요소로 이동할 수 있다. 그런데 문제는 그 헤딩으로 이동할 시 해당 요소가 페이지 최상단에 위치하도록 스크롤이 이동한다는 것이다. 이렇게 되면 늘 페이지 최상단에 위치하도록 되어 있는 페이지 헤더에 그 요소가 가려져 버린다.</p>\n<p>이를 해결해 보자.</p>\n<p><img src=\"/static/scroll-problem-68f104be.png\" alt=\"scroll-problem\"></p>\n<p>매우 간단하다. <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-margin\">scroll-margin</a> CSS를 쓰면 된다.</p>\n<p><code>src/pages/posts/[category]/[slug]/content.module.css</code>에 다음과 같이 헤딩 요소들에 대한 <code>scroll-margin-top</code>을 추가해 주자. 헤더 높이는 늘 50px로 고정되어 있으므로 수치를 정하는 건 쉽다.</p>\n<pre><code class=\"language-css\">/* src/pages/posts/[category]/[slug]/content.module.css 에 추가 */\n.content :is(h1, h2, h3, h4, h5, h6){\n  scroll-margin-top:50px;\n}\n</code></pre>\n<h2>5.7. 글 진도 표기</h2>\n<p>지금은 글 내용 전부의 위에 TOC가 위치하고 있지만 만약 화면 너비가 넓어질 시, TOC가 글 내용의 오른쪽에 언제나 표시되어서 글의 진도를 표시해 준다면 좋을 것이다. 이를 구현해보자.</p>\n<p>이는 <code>Intersection Observer API</code>를 이용하여 구현될 것이다. 비동기적으로 처리되므로 스크롤 이벤트와 달리 부하가 적다.</p>\n<p>당연히 <code>src/components/toc/index.tsx</code>를 편집해야 한다. 먼저 TOC에 쓰이는 링크 컴포넌트를 분리하여 TOCLink 컴포넌트를 만들자.</p>\n<p><code>src/components/toc/tocLink</code> 폴더 생성후 내부에 index.tsx와 styles.module.css 생성.</p>\n<p>index.tsx는 그냥 TOC 내에서 쓰이는 링크 컴포넌트를 따와서 기본 구조를 잡는다.</p>\n<pre><code class=\"language-tsx\">// src/components/toc/tocLink/index.tsx\nfunction TOCLink({node}: {node: ContentType}) {\n  return (\n    &#x3C;a\n      className={styles.link}\n      href={`#${node.data.hProperties.id}`}\n    >\n      {node.data.hProperties.title}\n    &#x3C;/a>\n  );\n}\n</code></pre>\n<p>그리고 다음과 같이 스크롤에 따라서 어떤 ID의 헤딩이 활성화 상태인지를 리턴하는 <code>useHighlight</code> 훅을 만든다. useEffect를 이용해 해당 훅이 렌더링될 때 <code>IntersectionObserver</code>를 만들고, 이를 통해 헤딩 요소들의 변화를 감지한다. 그리고 훅에서는 활성화된 헤딩 요소의 ID와 활성화 요소ID를 변경하는 함수를 반환한다.</p>\n<pre><code class=\"language-tsx\">// src/components/toc/tocLink/index.tsx\nfunction useHighLight(): [string, Dispatch&#x3C;SetStateAction&#x3C;string>>] {\n  const observer=useRef&#x3C;IntersectionObserver>();\n  const [activeID, setActiveID]=useState&#x3C;string>('');\n\n  useEffect(()=>{\n    // 변화가 나타나면 실행되는 콜백 함수\n    const handleObserver=(entries: IntersectionObserverEntry[])=>{\n      entries.forEach((entry)=>{\n        if (entry.isIntersecting) {\n          setActiveID(entry.target.id);\n        }\n      });\n    };\n\n    observer.current=new IntersectionObserver(handleObserver, {\n      rootMargin: '0px 0px -40% 0px',\n    });\n\n    const elements=document.querySelectorAll('h1[id], h2[id], h3[id], h4[id], h5[id], h6[id]');\n    elements.forEach((element)=>observer.current?.observe(element));\n    return ()=>observer.current?.disconnect();\n  }, []);\n\n  return [activeID, setActiveID];\n}\n</code></pre>\n<p>또한 TOCLink 컴포넌트에서는 이 훅을 이용해서 활성화된 헤딩 요소의 ID를 받아와서 현재 링크의 ID와 같은지 검사하여 활성화 상태인지를 판단하고, 이에 따라서 스타일을 적용해 준다.</p>\n<pre><code class=\"language-tsx\">// src/components/toc/tocLink/index.tsx\nfunction TOCLink({node}: {node: ContentType}) {\n  const id=node.data.hProperties.id;\n  const [activeID, setActiveID]=useHighLight();\n  return (\n    &#x3C;a\n      className={`${styles.link} ${activeID===id?styles.link__active:''}`}\n      href={`#${node.data.hProperties.id}`}\n      onClick={()=>setActiveID(id)}\n    >\n      {node.data.hProperties.title}\n    &#x3C;/a>\n  );\n}\n</code></pre>\n<p>TOCLink 스타일시트는 다음과 같다.</p>\n<pre><code class=\"language-css\">// src/components/toc/tocLink/styles.module.css\n.link{\n  color:var(--gray7);\n  line-height:1.75;\n  text-decoration:underline;\n}\n\n.link:hover{\n  color:var(--indigo6);\n}\n\n.link__active{\n  background-color:var(--indigo1);\n  color:var(--indigo8);\n  padding:3px;\n  border-radius:5px;\n}\n\n.link__active:hover{\n  background-color:var(--indigo2);\n}\n</code></pre>\n<p>이렇게 하고 나면 TOC가 스크롤에 따라서 이동한다. 하지만 문제는...TOC는 현재 글 최상단에 있기 때문에 스크롤이 이동하면 사라져 버리기 때문에, 스크롤에 따라 TOC가 이동하는 것을 볼 수 없다. 이러면 사실 TOC가 스크롤에 따라 변하는 것을 구현한 이유가 없다. 따라서 화면 너비가 충분히 넓을 경우, 글의 오른쪽에 TOC가 고정되어 있도록 해보자.</p>\n<p>이는 TOC를 담은 컨테이너 클래스에 fixed position과 적당한 간격을 주는 것으로 구현 가능하다.</p>\n<pre><code class=\"language-css\">// src/components/toc/styles.module.css\n@media(min-width: 1280px){\n  .container{\n    position:fixed;\n    top:50px;\n    left:calc(50% + 25rem);\n    margin-top:2rem;\n  }\n}\n</code></pre>\n<p>left 간격은 <code>calc</code>함수를 사용하였는데, 화면 너비가 1280px 이상이 되면 컨텐츠 영역은 max-width인 50rem에 도달하므로 이를 기준으로 TOC가 고정되도록 하였다.</p>\n<h1>6. favicon 바꾸기(+SEO)</h1>\n<p>오래전, 메인 페이지의 <code>Head</code>태그에 각종 메타데이터를 채워넣은 것을 기억하는가? 대강 제목과 여러 가지를 채웠었다. 다음과 같이.</p>\n<pre><code class=\"language-tsx\">// src/pages/index.tsx\n&#x3C;Head>\n  &#x3C;title>{blogConfig.title}&#x3C;/title>\n  &#x3C;meta name='description' content={blogConfig.description} />\n  &#x3C;meta name='viewport' content='width=device-width, initial-scale=1' />\n  &#x3C;meta name='og:image' content={blogConfig.thumbnail} />\n  &#x3C;meta name='twitter:image' content={blogConfig.thumbnail} />\n  &#x3C;link rel='apple-touch-icon' sizes='180x180' href='/apple-touch-icon.png' />\n  &#x3C;link rel='icon' href='/witch-hat.svg' />\n  &#x3C;link rel='manifest' href='/site.webmanifest' />\n  &#x3C;link rel='canonical' href='https://witch.work/' />\n&#x3C;/Head>\n</code></pre>\n<p>이제 SEO도 해보고 favicon도 이전에 찾은 svg 마녀 모자로 바꿔주자.</p>\n<h2>6.1. next-seo</h2>\n<p>앞서서는 next의 Head 요소를 이용해서 메타데이터를 넣어 주었다. 하지만 next-seo를 사용하면 더 쉽게 할 수 있다. 바로 설치한다.</p>\n<pre><code class=\"language-bash\">npm install next-seo\n</code></pre>\n<p>그리고 <code>blog-config.ts</code>에 SEO를 위한 Config 객체도 만들어준다.</p>\n<pre><code class=\"language-ts\">// /blog-config.ts\nexport const SEOConfig: NextSeoProps = {\n  title: blogConfig.title,\n  description: blogConfig.description,\n  canonical: blogConfig.url,\n  openGraph: {\n    type: 'website',\n    locale: 'ko_KR',\n    title: blogConfig.title,\n    description: blogConfig.description,\n    url: blogConfig.url,\n    siteName: blogConfig.title,\n    images: [\n      {\n        url:'/witch.jpeg',\n        alt: `${blogConfig.name} 프로필 사진`,\n      },\n    ],\n  },\n};\n</code></pre>\n<p>이는 <code>src/pages/_app.tsx</code>에 <code>DefaultSeo</code> 컴포넌트를 이용해서 적용한다.</p>\n<pre><code class=\"language-tsx\">// src/pages/_app.tsx\nexport default function App({ Component, pageProps }: AppProps) {\n  return (\n    &#x3C;>\n      &#x3C;DefaultSeo {...SEOConfig} />\n      &#x3C;Header navList={blogCategoryList} />\n      &#x3C;Component {...pageProps} />\n      &#x3C;Footer />\n    &#x3C;/>\n  );\n}\n</code></pre>\n<p>이제 각 글을 위한 SEO를 해주자. <code>NextSeo</code> 컴포넌트를 쓰면 된다. 개별 글 페이지를 먼저 처리.</p>\n<pre><code class=\"language-tsx\">// src/pages/posts/[category]/[slug]/index.tsx\nfunction PostPage({\n  post\n}: InferGetStaticPropsType&#x3C;typeof getStaticProps>) {\n  const dateObj=new Date(post.date);\n  // seo 정보를 추가\n  const SEOInfo: NextSeoProps={\n    title: post.title,\n    description: post.description,\n    canonical:`${SEOConfig.canonical}${post.url}`,\n    openGraph:{\n      title: post.title,\n      description: post.description,\n      images: [\n        {\n          url:'/witch.jpeg',\n          alt: `${blogConfig.name} 프로필 사진`,\n        },\n      ],\n      url:`${SEOConfig.canonical}${post.url}`,\n    }\n  };\n\n  return (\n    &#x3C;main className={styles.page}>\n      &#x3C;NextSeo {...SEOInfo} />\n      &#x3C;article className={styles.container}>\n        &#x3C;h1 className={styles.title}>{post.title}&#x3C;/h1>\n        &#x3C;time className={styles.time} dateTime={toISODate(dateObj)}>\n          {formatDate(dateObj)}\n        &#x3C;/time>\n        &#x3C;ul className={styles.tagList}>\n          {post.tags.map((tag: string)=>\n            &#x3C;li key={tag} className={styles.tag}>{tag}&#x3C;/li>\n          )}\n        &#x3C;/ul>\n        &#x3C;TableOfContents nodes={post._raw.headingTree} />\n        {'code' in post.body?\n          &#x3C;div className={contentStyles.content}>\n            &#x3C;MDXComponent code={post.body.code}/>\n          &#x3C;/div>\n          :\n          &#x3C;div\n            className={contentStyles.content} \n            dangerouslySetInnerHTML={{ __html: post.body.html }} \n          />\n        }\n      &#x3C;/article>\n    &#x3C;/main>\n  );\n}\n</code></pre>\n<p>그리고 PostListPage에도 비슷하게 해주자. <code>pages/posts/[category]/index.tsx</code>를 편집한다. 각 주제별 글 목록의 SEO가 그렇게 중요하지는 않을 듯 해서 몇 가지만 넣었다.</p>\n<pre><code class=\"language-tsx\">// src/pages/posts/[category]/index.tsx\nconst SEOInfo: NextSeoProps={\n  title: `${category} 주제의 글`,\n  description: `${category} 주제의 글들을 모아서 보여주는 페이지`,\n  openGraph:{\n    title: `${category} 주제의 글`,\n    description: `${category} 주제의 글들을 모아서 보여주는 페이지`,\n    images: [\n      {\n        url:'/witch.jpeg',\n        alt: `${blogConfig.name} 프로필 사진`,\n      },\n    ],\n  }\n};\n// 이 정도만 하고 PostListPage 컴포넌트 내에 다음 컴포넌트 삽입\n&#x3C;NextSeo {...SEOInfo} />\n</code></pre>\n<h2>6.2. next-sitemap</h2>\n<p><code>next-sitemap</code>을 사용해서 사이트맵도 자동으로 생성되게 해주자. 먼저 패키지 설치.</p>\n<pre><code class=\"language-bash\">npm i next-sitemap\n</code></pre>\n<p>그리고 config 파일 생성. 루트에 <code>next-sitemap.config.js</code>를 생성하고 다음과 같이 작성한다.</p>\n<pre><code class=\"language-js\">/** @type {import('next-sitemap').IConfig} */\n\nmodule.exports = {\n  // 내 블로그 apex URL\n  siteUrl: process.env.SITE_URL || 'https://witch.work',\n  generateRobotsTxt: true, // (optional)\n  // ...other options\n};\n</code></pre>\n<p>그리고 postbuild 명령으로 빌드 완료 이후 사이트맵을 생성하게 한다.</p>\n<pre><code class=\"language-json\">// package.json\n\"scripts\": {\n  \"copyimages\": \"node ./src/bin/pre-build.mjs\",\n  \"prebuild\": \"npm run copyimages\",\n  // 이거 추가\n  \"postbuild\": \"next-sitemap\",\n  \"predev\": \"npm run copyimages\",\n  \"dev\": \"next dev\",\n  \"build\": \"contentlayer build &#x26;&#x26; next build\",\n  \"start\": \"next start\",\n  \"lint\": \"next lint\"\n},\n</code></pre>\n<p>이제 <code>npm run build</code>로 빌드하고 나면 <code>public</code>폴더에 <code>sitemap.xml</code>이 생성된 것을 볼 수 있다. robots.txt도 자동으로 만들어준다.</p>\n<h2>6.3. favicon 바꾸기</h2>\n<p>이는 default SEO config를 바꾸면 된다. <code>src/blog-config.ts</code>의 <code>SEOconfig</code>에 <code>additionalLinkTags</code>를 추가해주자.</p>\n<pre><code class=\"language-ts\">// blog-config.ts\nexport const SEOConfig: NextSeoProps = {\n  title: blogConfig.title,\n  description: blogConfig.description,\n  canonical: blogConfig.url,\n  openGraph: {\n    type: 'website',\n    locale: 'ko_KR',\n    title: blogConfig.title,\n    description: blogConfig.description,\n    url: blogConfig.url,\n    siteName: blogConfig.title,\n    images: [\n      {\n        url :blogConfig.picture,\n        alt: `${blogConfig.name} 프로필 사진`,\n      },\n    ],\n  },\n  additionalLinkTags: [\n    {\n      rel: 'icon',\n      href: '/witch-hat.svg',\n    },\n    {\n      rel: 'mask-icon',\n      href: '/witch-hat.svg',\n      color: '#000000'\n    },\n    {\n      rel: 'apple-touch-icon',\n      href: '/witch-hat.png',\n    }\n  ]\n};\n</code></pre>\n<p>그리고 이참에 메인 페이지에 있던 Head 태그도 없애자. 그런데 남겨 놔야 할 건 없을까? next-seo에서 처리해 준 것과 하나하나 대조해 가며 지워보니 다음과 같은 내용이 남았다.</p>\n<pre><code class=\"language-tsx\">// src/pages/index.tsx의 남은 Head 태그\n&#x3C;Head>\n  &#x3C;meta name='viewport' content='width=device-width, initial-scale=1' />\n  &#x3C;link rel='manifest' href='/site.webmanifest' />\n&#x3C;/Head>\n</code></pre>\n<p>그런데 viewport 설정과 manifest는 모든 페이지에 적용되어야 한다. 따라서 <code>pages/index.tsx</code>에서 이를 옮겨서 모든 페이지에 적용되는 <code>_app.tsx</code>에 넣어주자. 다음과 같이 <code>Head</code>를 넣어주는 것이다.</p>\n<pre><code class=\"language-tsx\">// src/pages/_app.tsx\nexport default function App({ Component, pageProps }: AppProps) {\n  return (\n    &#x3C;>\n      &#x3C;Head>\n        &#x3C;meta name='viewport' content='width=device-width, initial-scale=1' />\n        &#x3C;link rel='manifest' href='/site.webmanifest' />\n      &#x3C;/Head>\n      &#x3C;DefaultSeo {...SEOConfig} />\n      &#x3C;Header navList={blogCategoryList} />\n      &#x3C;Component {...pageProps} />\n      &#x3C;Footer />\n    &#x3C;/>\n  );\n}\n</code></pre>\n<h2>6.4. 카톡 미리보기가 안 뜨는 문제</h2>\n<p>그런데 문제가 생겼다. 특정 글 링크를 카톡으로 보낼 땐 미리보기가 잘만 뜨더니 메인 페이지나 글 목록 페이지를 보내면 미리보기가 안 뜬다.</p>\n<p><img src=\"/static/kakao-preview-prob-9f447b9c.jpeg\" alt=\"kakao-problem\"></p>\n<p>카카오톡은 페이지 미리보기 이미지 파싱에 <code>og:image</code>를 쓰는 걸로 알고 있는데 개발자 도구에서 head 요소 내부를 까보면 이 요소가 잘 들어가 있다. 그러면 해당 이미지를 불러오지 못하고 있다는 뜻인 것 같다.</p>\n<p>그러면 이미지는 잘 들어가 있는 걸까? 현재 내가 모든 페이지의 미리보기로 사용하고 있는 이미지는 <code>/witch.jpeg</code>다. 이건 잘 들어가 있을까? <a href=\"https://witch-next-blog.vercel.app/witch.jpeg\">해당 링크</a>에 들어가 보니 이미지는 배포와 함께 잘 들어가 있는 걸 볼 수 있었다.</p>\n<p>따라서 <code>NextSeo</code>와 <code>DefaultSeo</code>컴포넌트에서 불러오는 이미지 URL을 수정해주자. 일단 <code>blog-config.ts</code>의 SEOconfig를 수정.</p>\n<pre><code class=\"language-ts\">// blog-config.ts\nexport const SEOConfig: NextSeoProps = {\n  /* 생략 */\n  openGraph: {\n    type: 'website',\n    locale: 'ko_KR',\n    title: blogConfig.title,\n    description: blogConfig.description,\n    url: blogConfig.url,\n    siteName: blogConfig.title,\n    images: [\n      {\n        // 이미지 URL을 블로그 URL + 이미지경로 로 수정\n        url :`${blogConfig.url}${blogConfig.thumbnail}`,\n        alt: `${blogConfig.name} 프로필 사진`,\n      },\n    ],\n  },\n  /* 생략 */\n}\n</code></pre>\n<p>이제 글 목록 페이지와 글 상세 페이지에서도 <code>og:image</code> URL을 수정해주자. 글 목록 페이지의 경우 <code>og:url</code>도 새로 넣어준다. <code>getStaticProps</code>에서 게시글 URL도 받아오게 수정하면 된다.</p>\n<pre><code class=\"language-tsx\">export const getStaticProps: GetStaticProps = ({params}) => {\n  const allDocumentsInCategory = getSortedPosts().filter((post)=>\n    post._raw.flattenedPath.startsWith(params?.category as string\n    ));\n  \n  const {title:category, url:categoryURL}=blogCategoryList.find((c)=>\n    c.url.split('/').pop()===params?.category) as {title: string, url: string};\n\n  const postList = allDocumentsInCategory.map((post) => ({\n    title: post.title,\n    description: post.description,\n    date: post.date,\n    tags: post.tags,\n    url: post.url,\n  }));\n  return { props: { category, categoryURL,postList } };\n};\n</code></pre>\n<p>또한 여기서 canonical도 새로 넣어줄 수 있다. 만약 canonical이 없거나 메인페이지가 같으면 미리보기가 안 뜨는 것 같다.</p>\n<pre><code class=\"language-tsx\">/* src/pages/posts/[category]/index.tsx 등\n에서 NextSeo 컴포넌트 Props로 들어가는 객체 */\n  const SEOInfo: NextSeoProps={\n    title: `${category} 주제의 글`,\n    description: `${category} 주제의 글들을 모아서 보여주는 페이지`,\n    canonical:`${blogConfig.url}${categoryURL}`,\n    openGraph:{\n      title: `${category} 주제의 글`,\n      description: `${category} 주제의 글들을 모아서 보여주는 페이지`,\n      images: [\n        {\n          url:`${blogConfig.url}${blogConfig.thumbnail}`,\n          alt: `${blogConfig.name} 프로필 사진`,\n        },\n      ],\n      url:`${blogConfig.url}${categoryURL}`,\n    },\n  };\n</code></pre>\n<p>이제 카카오톡에서도 미리보기가 잘 뜨는 것을 확인할 수 있었다.</p>\n<p><img src=\"/static/kakao-preview-solved-4ec081a3.jpeg\" alt=\"kakao-solved\"></p>\n<h1>참고</h1>\n<p><a href=\"https://gamguma.dev/post/2022/01/nextjs-blog-development-review\">https://gamguma.dev/post/2022/01/nextjs-blog-development-review</a></p>\n<p>TOC를 만들어보자 <a href=\"https://claritydev.net/blog/nextjs-blog-remark-interactive-table-of-contents\">https://claritydev.net/blog/nextjs-blog-remark-interactive-table-of-contents</a></p>\n<p><a href=\"https://thisyujeong.dev/blog/toc-generator\">https://thisyujeong.dev/blog/toc-generator</a></p>\n<p>mdast에서 heading의 구조 참고 <a href=\"https://github.com/syntax-tree/mdast-util-to-hast#hproperties\">https://github.com/syntax-tree/mdast-util-to-hast#hproperties</a></p>\n<p>is 유사 클래스 셀렉터로 여러 태그의 자식 선택 <a href=\"https://stackoverflow.com/questions/11054305/css-select-multiple-descendants-of-another-element\">https://stackoverflow.com/questions/11054305/css-select-multiple-descendants-of-another-element</a></p>\n<p>코드 포매팅 <a href=\"https://yiyb-blog.vercel.app/posts/nextjs-contentlayer-blog\">https://yiyb-blog.vercel.app/posts/nextjs-contentlayer-blog</a></p>\n<p><a href=\"https://maintainhoon.vercel.app/blog/post/blog_development_period\">https://maintainhoon.vercel.app/blog/post/blog_development_period</a></p>\n<p>id를 주자 <a href=\"https://github.com/syntax-tree/mdast-util-to-hast\">https://github.com/syntax-tree/mdast-util-to-hast</a></p>\n<p>만약 플러그인을 TS로 짜고 싶다면...\n<a href=\"https://rokt33r.github.io/posts/contribute-definitely-typed\">https://rokt33r.github.io/posts/contribute-definitely-typed</a></p>\n<p>scroll-margin <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-margin\">https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-margin</a></p>\n<p>SEO 등 메타데이터에 참고한 사이트들</p>\n<ul>\n<li>favicon을 바꾸기 위해 참고하였다. <a href=\"https://brunch.co.kr/@ultra0034/129\">https://brunch.co.kr/@ultra0034/129</a></li>\n<li>next-seo 적용 <a href=\"https://kyounghwan01.github.io/blog/React/next/next-seo/\">https://kyounghwan01.github.io/blog/React/next/next-seo/</a></li>\n<li>next sitemap <a href=\"https://vroomfan.tistory.com/51\">https://vroomfan.tistory.com/51</a>, <a href=\"https://bepyan.github.io/blog/nextjs-blog/5-create-sitemap\">https://bepyan.github.io/blog/nextjs-blog/5-create-sitemap</a></li>\n<li>next-seo 공식문서 <a href=\"https://www.npmjs.com/package/next-seo\">https://www.npmjs.com/package/next-seo</a></li>\n</ul>\n<p>next-sitemap npm 페이지 <a href=\"https://www.npmjs.com/package/next-sitemap\">https://www.npmjs.com/package/next-sitemap</a></p>\n<p>intersection observer\n<a href=\"https://developer.mozilla.org/ko/docs/Web/API/Intersection_Observer_API\">https://developer.mozilla.org/ko/docs/Web/API/Intersection_Observer_API</a></p>",
    "excerpt": "블로그 만들기 시리즈\n|제목|링크|\n|---|---|\n|1. 기본 세팅|https://witch.work/posts/blog-remake-1|\n|2. 메인 페이지의 HTML 설계|https://witch.work/posts/blog-remake-2|\n|3. 글 상세 페이지의 구조 설계|https://witch.work/posts/blog-remake-3|\n|4. 이미지를 상대 경로로 쓸 수 있도록 하기|https://witch.work/posts/blog-rem",
    "headingTree": [
      {
        "title": "블로그 만들기 시리즈",
        "url": "#블로그-만들기-시리즈",
        "items": []
      },
      {
        "title": "1. 글 목록 페이지 바꾸기",
        "url": "#1-글-목록-페이지-바꾸기",
        "items": []
      },
      {
        "title": "2. 글로벌 CSS 적용",
        "url": "#2-글로벌-css-적용",
        "items": [
          {
            "title": "2.1. 글로벌 스타일",
            "url": "#21-글로벌-스타일",
            "items": []
          },
          {
            "title": "2.2. 헤더, 푸터",
            "url": "#22-헤더-푸터",
            "items": []
          },
          {
            "title": "2.3. 자기소개 컴포넌트",
            "url": "#23-자기소개-컴포넌트",
            "items": []
          },
          {
            "title": "2.4. 프로젝트 소개 컴포넌트",
            "url": "#24-프로젝트-소개-컴포넌트",
            "items": []
          },
          {
            "title": "2.5. 글 카테고리 컴포넌트",
            "url": "#25-글-카테고리-컴포넌트",
            "items": []
          }
        ]
      },
      {
        "title": "3. 글 상세보기 페이지",
        "url": "#3-글-상세보기-페이지",
        "items": [
          {
            "title": "3.1. 컨테이너 레이아웃",
            "url": "#31-컨테이너-레이아웃",
            "items": []
          },
          {
            "title": "3.2. 글 컨텐츠 레이아웃",
            "url": "#32-글-컨텐츠-레이아웃",
            "items": []
          },
          {
            "title": "3.3. 글의 제목, 태그",
            "url": "#33-글의-제목-태그",
            "items": []
          }
        ]
      },
      {
        "title": "4. 다시, 글 목록 페이지",
        "url": "#4-다시-글-목록-페이지",
        "items": [
          {
            "title": "4.1. 주제 따오는 방식 바꾸기",
            "url": "#41-주제-따오는-방식-바꾸기",
            "items": []
          },
          {
            "title": "4.2. 스타일 조정",
            "url": "#42-스타일-조정",
            "items": []
          }
        ]
      },
      {
        "title": "5. TOC 만들어주기",
        "url": "#5-toc-만들어주기",
        "items": [
          {
            "title": "5.1. 헤딩에 ID 부여하기",
            "url": "#51-헤딩에-id-부여하기",
            "items": []
          },
          {
            "title": "5.2. 헤딩 계층 구조 만들기",
            "url": "#52-헤딩-계층-구조-만들기",
            "items": []
          },
          {
            "title": "5.3. 데이터 넘겨주기",
            "url": "#53-데이터-넘겨주기",
            "items": []
          },
          {
            "title": "5.4. TOC 제작",
            "url": "#54-toc-제작",
            "items": []
          },
          {
            "title": "5.5. 부드러운 스크롤과 스타일링",
            "url": "#55-부드러운-스크롤과-스타일링",
            "items": []
          },
          {
            "title": "5.6. 스크롤 이동 위치 문제",
            "url": "#56-스크롤-이동-위치-문제",
            "items": []
          },
          {
            "title": "5.7. 글 진도 표기",
            "url": "#57-글-진도-표기",
            "items": []
          }
        ]
      },
      {
        "title": "6. favicon 바꾸기(+SEO)",
        "url": "#6-favicon-바꾸기seo",
        "items": [
          {
            "title": "6.1. next-seo",
            "url": "#61-next-seo",
            "items": []
          },
          {
            "title": "6.2. next-sitemap",
            "url": "#62-next-sitemap",
            "items": []
          },
          {
            "title": "6.3. favicon 바꾸기",
            "url": "#63-favicon-바꾸기",
            "items": []
          },
          {
            "title": "6.4. 카톡 미리보기가 안 뜨는 문제",
            "url": "#64-카톡-미리보기가-안-뜨는-문제",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 13,
      "wordCount": 3364
    },
    "url": "/posts/blog-remake-8",
    "thumbnail": {
      "local": "/static/toc-layout-dcc4903f.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-toc-layout-dcc4903f-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAICAIAAAC6ZnJRAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAc0lEQVR4nGMICAhjZmbv7Oz8////9+/fX7x4cfPmTYbIqGg5OTmIKBwwzJg5v7m5BVkIJPr//393d/e1a9dCTECI+vr6QZQjRD98+JCWltbU1PQdCTB8//49Lzv71KlTKOY2trYxMDCIS0mlpWdERkVDEACnynvTYQnPeAAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "blog-remake-6",
    "title": "블로그 만들기 - 6. 기본적인 페이지 레이아웃",
    "date": "2023-05-25T00:00:00Z",
    "description": "너무 못생긴 페이지, 가독성부터 높여보자.",
    "tags": [
      "blog",
      "web"
    ],
    "html": "<h1>블로그 만들기 시리즈</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>제목</th><th>링크</th></tr></thead><tbody><tr><td>1. 기본 세팅</td><td><a href=\"https://witch.work/posts/blog-remake-1\">https://witch.work/posts/blog-remake-1</a></td></tr><tr><td>2. 메인 페이지의 HTML 설계</td><td><a href=\"https://witch.work/posts/blog-remake-2\">https://witch.work/posts/blog-remake-2</a></td></tr><tr><td>3. 글 상세 페이지의 구조 설계</td><td><a href=\"https://witch.work/posts/blog-remake-3\">https://witch.work/posts/blog-remake-3</a></td></tr><tr><td>4. 이미지를 상대 경로로 쓸 수 있도록 하기</td><td><a href=\"https://witch.work/posts/blog-remake-4\">https://witch.work/posts/blog-remake-4</a></td></tr><tr><td>5. 자잘한 페이지 구성 개선과 배포</td><td><a href=\"https://witch.work/posts/blog-remake-5\">https://witch.work/posts/blog-remake-5</a></td></tr><tr><td>6. 페이지 요소의 배치 설계</td><td><a href=\"https://witch.work/posts/blog-remake-6\">https://witch.work/posts/blog-remake-6</a></td></tr><tr><td>7. 메인 페이지 컴포넌트 디자인</td><td><a href=\"https://witch.work/posts/blog-remake-7\">https://witch.work/posts/blog-remake-7</a></td></tr><tr><td>8. 글 목록/내용 페이지 컴포넌트 디자인</td><td><a href=\"https://witch.work/posts/blog-remake-8\">https://witch.work/posts/blog-remake-8</a></td></tr><tr><td>9. 글 썸네일 자동 생성하기</td><td><a href=\"https://witch.work/posts/blog-remake-9\">https://witch.work/posts/blog-remake-9</a></td></tr><tr><td>10. 폰트, 카드 디자인 등의 디자인 개선</td><td><a href=\"https://witch.work/posts/blog-remake-10\">https://witch.work/posts/blog-remake-10</a></td></tr><tr><td>11. 글에 조회수 달기</td><td><a href=\"https://witch.work/posts/blog-remake-11\">https://witch.work/posts/blog-remake-11</a></td></tr><tr><td>12. 페이지 테마와 글 검색 기능</td><td><a href=\"https://witch.work/posts/blog-remake-12\">https://witch.work/posts/blog-remake-12</a></td></tr><tr><td>13. 테마 아이콘과 썸네일 레이아웃 개선 등</td><td><a href=\"https://witch.work/posts/blog-remake-13\">https://witch.work/posts/blog-remake-13</a></td></tr><tr><td>14. 글 분류를 태그 기반으로 변경</td><td><a href=\"https://witch.work/posts/blog-remake-14\">https://witch.work/posts/blog-remake-14</a></td></tr><tr><td>메인 페이지의 연산 최적화</td><td><a href=\"https://witch.work/posts/blog-opt-1\">https://witch.work/posts/blog-opt-1</a></td></tr><tr><td>글 목록 페이지네이션 만들기</td><td><a href=\"https://witch.work/posts/blog-opt-2\">https://witch.work/posts/blog-opt-2</a></td></tr><tr><td>이미지를 CDN에 올리고 placeholder 만들기</td><td><a href=\"https://witch.work/posts/blog-opt-3\">https://witch.work/posts/blog-opt-3</a></td></tr><tr><td>검색 페이지에 무한 스크롤 구현하기</td><td><a href=\"https://witch.work/posts/blog-opt-4\">https://witch.work/posts/blog-opt-4</a></td></tr></tbody></table>\n<h1>1. 디자인의 시작, 레이아웃</h1>\n<p><img src=\"/static/ugly-blog-21ae328e.png\" alt=\"my-ugly-blog\"></p>\n<p>지금 내 블로그는 매우 못생겼다. 색도 하나도 안 입혀져 있고(링크에 입혀진 기본 색상 말고는), CSS도 하나도 없어서 링크들은 쨍한 파란색으로 보이고 난리가 났다.</p>\n<p>하지만 가장 문제는 배치가 제멋대로라는 것이다. HTML 시맨틱이야 잘 짜여 있(다고 믿)지만 그냥 위에서 아래로 배열되었을 뿐이다. 레이아웃이 페이지에서 얼마나 중요한지를 생각해 보면 이는 큰 문제다.</p>\n<p>내가 참고한 <a href=\"https://product.kyobobook.co.kr/detail/S000001033015\">누구나 쉽게 배우는 웹사이트 디자인의 비밀</a>에서도 레이아웃을 목차의 첫번째로 꼽고 있다.</p>\n<p>또한 10년차 디자이너분의 시리즈 <a href=\"https://brunch.co.kr/@sarayun/22\">누구나 디자이너가 될 수 있다</a>에서도 디자인의 4대 핵심 요소 중 가장 기본이라고 말하고 있다. 가독성이 정말 안 좋은 페이지를 본 사람이라면 충분히 이해할 수 있는 이야기다.</p>\n<p>따라서 이번에는 CSS를 활용해서 페이지의 레이아웃을 한번 수정해 보도록 하자. 메인 페이지부터 시작해 볼까.</p>\n<p>모바일 우선 디자인을 적용하였다. 내 블로그를 모바일로 보는 사람도 많을 것이고 또한 일반적으로 컴퓨터가 성능이 더 좋기 때문에 모바일 우선으로 로드하고 나서 컴퓨터 환경에서 미디어 쿼리를 적용하는 게 속도 면에서 더 나을 거라고 생각했기 때문이다.</p>\n<p>또한 css 라이브러리를 딱히 사용하지 않는 것이 처음이라 가장 고전적인 BEM 클래스 작명법을 적당히 사용하였다.</p>\n<h1>2. 페이지 헤더와 푸터 공통화</h1>\n<p>현재 페이지 헤더에는 내비게이션이 있고, 푸터에는 간단한 내 이름이 있다. 현재 이 요소들은 메인 페이지에만 들어 있다. 그런데 각 헤더와 푸터에 들어 있는 정보를 생각해 볼 때 모든 페이지에 공통으로 들어가 있는 게 합리적이다.</p>\n<p>따라서 이를 모든 페이지에 공통으로 넣어주도록 하자. <code>/src/pages/_app.tsx</code>를 수정해주면 된다.</p>\n<pre><code class=\"language-tsx\">// src/pages/_app.tsx\nimport '@/styles/globals.css';\nimport type { AppProps } from 'next/app';\n\nimport Footer from '@/components/footer';\nimport Header from '@/components/header';\nimport blogCategoryList from 'blog-category';\n\nexport default function App({ Component, pageProps }: AppProps) {\n  return (\n    &#x3C;>\n      &#x3C;Header navList={blogCategoryList} />\n      &#x3C;Component {...pageProps} />\n      &#x3C;Footer />\n    &#x3C;/>\n  );\n}\n</code></pre>\n<p>그리고 <code>/src/pages/index.tsx</code>에 있던 헤더와 푸터는 지워준다.</p>\n<h1>3. 콘텐츠 영역 너비</h1>\n<p>현재 블로그 페이지의 컨텐츠는 width가 100%라 페이지를 꽉 채우고 있다. 화면이 좁은 모바일 환경에서라면 텍스트가 답답하게 배치된 것처럼 보이지 않도록 컨텐츠를 최대한 넓은 너비에 배치해야 하겠다. 그리고 그게 거의 정답이라 생각한다. 안 그래도 768px 미만의 화면 너비일 때는 양쪽에 약간의 패딩을 주겠지만 콘텐츠를 화면에 거의 꽉 채우도록 할 것이다.</p>\n<p>하지만 1920px 너비가 많은 데스크톱 환경에서는 이게 너무 넓어 보이고 한 줄에 있는 글자도 너무 많아서 읽기 힘들 것이다. 따라서 콘텐츠의 최대 넓이를 제한해야 한다고 본다. max-width 속성을 이용할 것이다.</p>\n<h2>3.1. 최대 콘텐츠 너비에 관한 고찰</h2>\n<p>그런데 어느 정도의 너비까지 컨텐츠를 채우도록 해야 할까?</p>\n<p><a href=\"https://www.w3.org/WAI/tutorials/page-structure/styling/#line-length\">웹 접근성 가이드</a>에서는 텍스트 컨테이너가 80자 너비를 넘으면 안 된다고 한다. <code>max-width: 70rem</code>으로 설정하는 방식으로 해보라고 조언도 해주고 있다.</p>\n<p>기본 폰트 사이즈가 16px이므로 약 1120px 정도의 최대 너비를 갖게 하라고 말하는 것이다. 그래서 max-width를 60rem으로도 해보고 70rem으로도 해봤다. 1920px에서 봐도 여백이 생각만큼 엄청 넓어 보이지 않고 괜찮아 보였다.</p>\n<p>그 정도로 설정하자 여백은 충분해 보였으나 해당 너비에 텍스트뿐일 때 한 줄당 텍스트가 너무 많아 보였다. 그럼 한 줄에 얼만큼의 글자 수가 적절할까?</p>\n<p>타이포그래피 연구에 의하면 사람들은 온라인 컨텐츠를 읽을 때 더 짧은 줄 길이를 쓰는 것이 더 조직화되고 이해하기 쉽다고 느끼기 때문에 짧은 줄을 더 선호한다고 한다. 그리고 40~55자 정도의 줄 길이가 가장 이상적이라고 한다.</p>\n<p>그럼 우리가 추구해야 할 건 다음과 같다.</p>\n<ul>\n<li>콘텐츠 컨테이너의 너비는 60~70rem으로</li>\n<li>텍스트는 한 줄당 40<del>55자(즉 40</del>55rem)이 되도록 설정</li>\n</ul>\n<p>우리가 지금 생각해야 할 건 메인 페이지, 글 목록 페이지, 글 상세보기 페이지이다. 이때 메인 페이지와 글 목록 페이지는 최대 너비가 60<del>70rem이 되도록 설정할 수 있다. 텍스트는 한 줄에 40</del>55자만 들어가도록 설정하도록 할 수 있는 장치들이 있기 때문이다.</p>\n<p>메인 페이지 같은 경우 다음과 같은 레이아웃을 생각할 수 있겠다.</p>\n<p><img src=\"/static/article-list-layout-2e52b7d6.png\" alt=\"article-list\"></p>\n<p>소개 영역은 내 프로필 사진을 올리는 걸로 텍스트 영역의 너비를 40~55자로 만들 수 있을 것이고 글 프리뷰에 있는 텍스트는 당연히 한참 적은 줄당 글자수를 가질 것이다.</p>\n<p>또한 글 목록 페이지는 다음과 같이, 글 프리뷰 카드(?)에 글의 썸네일을 넣어주는 방식으로 카드에 들어가는 텍스트를 한정할 수 있겠다. <a href=\"https://toss.tech/tech\">토스 기술블로그</a>의 레이아웃을 참고하였다.</p>\n<p><img src=\"/static/article-list-page-layout-cbcbb19e.png\" alt=\"article-list-page\"></p>\n<p>하지만 글 상세보기 페이지의 경우 딱히 글 콘텐츠 영역 너비를 줄여줄 어떤 장치가 없기 때문에(물론 TOC를 옆쪽에 넣거나 하는 방식도 가능하겠지만 그건 나중에 생각해보자) 그냥 전체 영역을 50rem으로 하는 것으로 생각했다.</p>\n<h2>3.2. 콘텐츠 영역 컨테이너 설정</h2>\n<p>일단 메인 페이지에 들어갈 래퍼 클래스는 다음과 같이 <code>/src/pages/styles.module.css</code>에 만들면 된다. <code>max-width</code>만 제외하고 나머지 래퍼들도 이를 따르면 된다.</p>\n<pre><code class=\"language-css\">// /src/pages/styles.module.css\n.pagewrapper{\n  margin:0 auto;\n  width:100%;\n  min-height:100vh;\n}\n\n@media (min-width: 768px) {\n  .pagewrapper{\n    max-width:60rem;\n  }\n}\n</code></pre>\n<p>그리고 <code>/src/pages/index.tsx</code>의 main 태그 className으로 <code>styles.pagewrapper</code>를 추가한다.(import style은 당연히 선행되어야 한다)</p>\n<p><code>/src/pages/posts/[category]/styles.module.css</code>에도 다음과 같이 같은 래퍼 클래스를 만들어준다.</p>\n<pre><code class=\"language-css\">.pagewrapper{\n  margin:0 auto;\n  width:100%;\n  min-height:100vh;\n}\n\n@media (min-width: 768px) {\n  .pagewrapper{\n    max-width:60rem;\n  }\n}\n</code></pre>\n<p><code>/src/pages/[category]/index.tsx</code>의 페이지 컴포넌트의 main 태그에도 해당 래퍼를 추가.</p>\n<pre><code class=\"language-tsx\">function PostListPage({\n  category, postList,\n}: InferGetStaticPropsType&#x3C;typeof getStaticProps>) {\n  return (\n    // 페이지 래퍼 추가\n    &#x3C;main className={styles.pagewrapper}>\n      &#x3C;h1>{category}&#x3C;/h1>\n      &#x3C;ul>\n        {postList.map((post: PostMetaData) => \n          &#x3C;li key={post.url}>\n            &#x3C;Card {...post} />\n          &#x3C;/li>\n        )}\n      &#x3C;/ul>\n    &#x3C;/main>\n  );\n}\n</code></pre>\n<p>그리고 글 상세 페이지의 컨테이너를 위한 클래스도 <code>/src/pages/posts/[category]/styles.module.css</code>에 추가적으로 정의</p>\n<pre><code class=\"language-css\">.pagewrapper{\n  margin:0 auto;\n  width:100%;\n  min-height:100vh;\n}\n\n.articlewrapper{\n  margin:0 auto;\n  width:100%;\n  min-height:100vh;\n}\n\n@media (min-width: 768px) {\n  .pagewrapper{\n    max-width:60rem;\n  }\n\n  .articlewrapper{\n    max-width:50rem;\n  }\n}\n</code></pre>\n<p>그리고 <code>/src/pages/posts/[category]/[slug].tsx</code>의 페이지 컴포넌트의 main 태그에도 해당 래퍼를 추가.</p>\n<pre><code class=\"language-tsx\">function PostPage({\n  post\n}: InferGetStaticPropsType&#x3C;typeof getStaticProps>) {\n\n  return (\n    // 여기에 추가\n    &#x3C;main className={styles.articlewrapper}>\n      &#x3C;article>\n        &#x3C;h1>{post.title}&#x3C;/h1>\n        &#x3C;time>{post.date}&#x3C;/time>\n        &#x3C;ul>\n          {post.tags.map((tag: string)=>&#x3C;li key={tag}>{tag}&#x3C;/li>)}\n        &#x3C;/ul>\n        {'code' in post.body?\n          &#x3C;MDXComponent code={post.body.code}/>:\n          &#x3C;div dangerouslySetInnerHTML={{ __html: post.body.html }} />\n        }\n      &#x3C;/article>\n    &#x3C;/main>\n  );\n}\n</code></pre>\n<p>이렇게 설정한 후 여러 기업의 기술 블로그들의 페이지 컨테이너 너비를 조사하였다. 대부분이 내가 쓴 것과 같이 max-width를 제한하는 방식을 사용했다.</p>\n<p>토스는 980px(단 width 92%인 내부 컨테이너가 하나 더 있어서 실제 콘텐츠 너비는 더 작았다), 배민은 900px, 구글 978px, 토스트UI 1060px, 라인 790px등 대충 나와 비슷한 수준이었다. 내가 설정한 60rem(960px)가 정답은 아닐지언정 그렇게까지 틀려먹은 수치는 아닌 것으로 보인다.</p>\n<p>이제 페이지의 몇몇 컴포넌트 레이아웃을 수정해 보자. 메인 페이지와 글 목록 페이지 등..</p>\n<p>참고로, 위에서 간간이 사용한 <code>min-height:100vh</code>등의 속성은 예전에는 wrapper div를 넣어서 기본적으로 넣어 주던 속성이다. 하지만 이는 <a href=\"https://stackoverflow.com/questions/27582691/why-is-web-content-wrapped-in-a-wrapper-div\">오래된 버전의 IE에서는 몇몇 태그에 대해 적용되지 않는 CSS가 있었기 때문에 하던 관행이며 지금 시점에 꼭 따를 필요는 없다.</a></p>\n<h1>4. 메인 페이지 간략 레이아웃</h1>\n<p>현재 메인 페이지는 의미적으로 4개의 영역으로 나눠져 있다고 할 수 있다. 다음과 같이 헤더, 내 소개, 글 목록, 푸터가 그 4개의 영역이다.</p>\n<p><img src=\"/static/whole-page-map-b24dd37c.png\" alt=\"whole-page-map\"></p>\n<p>여기서 헤더와 푸터는 지금 당장 레이아웃이 문제가 되지는 않으므로 내 소개와 글 목록에 대해서만 생각해 보자.</p>\n<h2>4.1. 메인 페이지 내 소개 영역</h2>\n<p>메인 페이지는 사용자가 내 블로그에 접속했을 때 처음으로 보게 되는 페이지다. 따라서 내 소개가 최상단에 있어야 하는 건 맞지만, 내 블로그 컨텐츠도 적절히 노출되도록 하면 좋겠다. 이는 모바일 환경에서도 마찬가지이므로 공간을 최대한 덜 차지하면서 적절해 보이는 레이아웃이 되도록 하고자 한다.</p>\n<p>따라서 다음과 같은 반응형 레이아웃을 생각해 보았다.</p>\n<p><img src=\"/static/intro-section-layout-d80d1219.png\" alt=\"intro-section-layout\"></p>\n<p>이를 어떻게 구현할까? 먼저 이름, 소개글, 링크들의 배열은 어차피 기본적으로 위에서 아래로 배열되어 있으므로 굳이 수정할 필요가 없다. 하지만 이미지와 레이아웃이 섞이지 않도록 이 부분을 div로 한번 묶어주자. 그리고 CSS 모듈 파일을 <code>src/components/profile</code>에 만들어 주자. <code>styles.module.css</code>정도의 이름이면 되겠다.</p>\n<p>이미지는 화면 너비가 클 때, 일반적으로 모바일과 데스크탑을 가르는 기준이 되는 768px를 기준으로 그보다 크면 보여주도록 한다. 이미지가 나온 후 세로로 배열된 나머지 요소들이 와야 하므로 내 소개 박스의 display를 flex로 설정하고 가로로 배열되도록 한다. 이 설정은 화면 너비가 768px보다 클 때만 해주면 된다.</p>\n<p>그리고 링크들은 가로로 배열되었으면 한다. 따라서 링크들을 감싸는 ul 컴포넌트에 적용해 줄 flex도 설정해 주자. 여기엔 미디어 쿼리가 필요없다. 그리고 링크에는 bullet point가 필요없으므로 이를 없애주고 링크 간의 어느 정도의 간격을 준다.</p>\n<p>이를 CSS 클래스로 구현하면 다음과 같다.</p>\n<pre><code class=\"language-css\">// src/components/profile/profile.module.css\n.profile__image{\n  display:none;\n}\n\n.profile__linklist{\n  display:flex;\n  flex-direction:row;\n  list-style:none;\n  padding-left:0;\n  gap:0 15px;\n}\n\n@media (min-width:768px){\n  .profile__image{\n    display:block;\n  }\n\n  .profile{\n    display:flex;\n    flex-direction:row;\n  }\n}\n</code></pre>\n<p>그리고 프로필 컴포넌트에선 다음과 같이 클래스를 사용해 준다.</p>\n<pre><code class=\"language-tsx\">// src/components/profile/index.tsx\nimport styles from './profile.module.css';\n\nfunction Profile() {\n  return (\n    &#x3C;article className={styles.profile}>\n      &#x3C;Image className={styles.profile__image} src={blogConfig.picture} alt={`${blogConfig.name}의 프로필 사진`} width={80} height={80} />\n      &#x3C;div>\n        &#x3C;h2>{blogConfig.name}&#x3C;/h2>\n        &#x3C;p>{blogConfig.description}&#x3C;/p>\n        &#x3C;ul className={styles.profile__linklist}>\n          &#x3C;li>\n            &#x3C;Link href={blogConfig.social.github} target='_blank'>\n            Github\n            &#x3C;/Link>\n          &#x3C;/li>\n          &#x3C;li>\n            &#x3C;Link href={blogConfig.social.BOJ} target='_blank'>\n            BOJ\n            &#x3C;/Link>\n          &#x3C;/li>\n        &#x3C;/ul>\n      &#x3C;/div>\n    &#x3C;/article>\n  );\n}\n</code></pre>\n<p>이렇게 하고 적용해 보면 내 소개 컴포넌트의 사진이 소개글 왼쪽에 보이고, 화면 너비가 작아지면 없어지는 걸 확인할 수 있다. 또 링크도 가로로 잘 배열되어 있다.</p>\n<h2>4.2. 메인 페이지 글 목록 영역</h2>\n<p>메인 페이지상의 글 목록의 배치에 대해 생각나는 요구 사항은 다음과 같다.</p>\n<ol>\n<li>모바일에서 텍스트가 답답하게 보이지 않아야 한다. PC 환경에서도 마찬가지.</li>\n<li>처음 페이지가 떴을 때 메인 페이지에서 최대한 많은 글을 보여줄 수 있어야 한다.</li>\n</ol>\n<p>여기에 부합하기 위해서는, 1번 요구사항을 더 우선적으로 생각했을 때 다음과 같은 요소 배치를 생각해 보았다. 모바일에서 답답해 보이지 않기 위해서는 글 프리뷰 카드 하나가 너비를 전부 차지해야 한다고 생각했다.</p>\n<p><img src=\"/static/article-list-layout-2e52b7d6.png\" alt=\"article-list\"></p>\n<p>이번에도 <code>src/components/category/styles.module.css</code> 생성. 그냥 화면이 일정 너비 이상이 되면 가로로 배열되도록 하기만 하면 된다. 그 외엔 bullet point를 없애주고 가로 배열시 간격을 주는 정도만 해주자.</p>\n<pre><code class=\"language-css\">.category__cardlist{\n  list-style:none;\n}\n\n@media (min-width:768px){\n  .category__cardlist{\n    display: flex;\n    flex-direction:row;\n    gap:20px;\n  }\n}\n</code></pre>\n<p>그리고 <code>src/components/category/index.tsx</code>의 ul태그에 <code>styles.category__cardlist</code>를 적용해 주기만 하면 된다.</p>\n<p>여기까지 하면 배치가 이렇게 바뀐다. 아직도 엄청나게 못생겼지만 아까보다 훨씬 나아 보이는 것 같다.</p>\n<p><img src=\"/static/temp-layout-2ec8f8a3.png\" alt=\"temp-layout\"></p>\n<h1>참고</h1>\n<p><a href=\"https://brunch.co.kr/@sarayun/22\">https://brunch.co.kr/@sarayun/22</a></p>\n<p><a href=\"https://merrily-code.tistory.com/154\">https://merrily-code.tistory.com/154</a></p>\n<p><a href=\"https://socialtriggers.com/perfect-content-width/\">https://socialtriggers.com/perfect-content-width/</a></p>",
    "excerpt": "블로그 만들기 시리즈\n|제목|링크|\n|---|---|\n|1. 기본 세팅|https://witch.work/posts/blog-remake-1|\n|2. 메인 페이지의 HTML 설계|https://witch.work/posts/blog-remake-2|\n|3. 글 상세 페이지의 구조 설계|https://witch.work/posts/blog-remake-3|\n|4. 이미지를 상대 경로로 쓸 수 있도록 하기|https://witch.work/posts/blog-rem",
    "headingTree": [
      {
        "title": "블로그 만들기 시리즈",
        "url": "#블로그-만들기-시리즈",
        "items": []
      },
      {
        "title": "1. 디자인의 시작, 레이아웃",
        "url": "#1-디자인의-시작-레이아웃",
        "items": []
      },
      {
        "title": "2. 페이지 헤더와 푸터 공통화",
        "url": "#2-페이지-헤더와-푸터-공통화",
        "items": []
      },
      {
        "title": "3. 콘텐츠 영역 너비",
        "url": "#3-콘텐츠-영역-너비",
        "items": [
          {
            "title": "3.1. 최대 콘텐츠 너비에 관한 고찰",
            "url": "#31-최대-콘텐츠-너비에-관한-고찰",
            "items": []
          },
          {
            "title": "3.2. 콘텐츠 영역 컨테이너 설정",
            "url": "#32-콘텐츠-영역-컨테이너-설정",
            "items": []
          }
        ]
      },
      {
        "title": "4. 메인 페이지 간략 레이아웃",
        "url": "#4-메인-페이지-간략-레이아웃",
        "items": [
          {
            "title": "4.1. 메인 페이지 내 소개 영역",
            "url": "#41-메인-페이지-내-소개-영역",
            "items": []
          },
          {
            "title": "4.2. 메인 페이지 글 목록 영역",
            "url": "#42-메인-페이지-글-목록-영역",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 2,
      "wordCount": 565
    },
    "url": "/posts/blog-remake-6",
    "thumbnail": {
      "local": "/static/ugly-blog-21ae328e.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-ugly-blog-21ae328e-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAICAIAAAC6ZnJRAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAaElEQVR4nGNgYGCYOnXavXv3rly5cu/evZdgwGBhYV1YUDgFBk6AAYOyjIayjMZ/VMAgL6WSGJf6////r1+/IUQdbNyS4tPR1RrqmIT4h6GLsjFKiour/////8f3HwhRIz3L0OBYNLUARFZ8EbSeZ9oAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "blog-remake-9",
    "title": "블로그 만들기 - 9. 글 썸네일 만들기",
    "date": "2023-05-30T01:00:00Z",
    "description": "canvas로 글의 썸네일 사진을 자동으로 생성하자.",
    "tags": [
      "blog",
      "web"
    ],
    "html": "<h1>블로그 만들기 시리즈</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>제목</th><th>링크</th></tr></thead><tbody><tr><td>1. 기본 세팅</td><td><a href=\"https://witch.work/posts/blog-remake-1\">https://witch.work/posts/blog-remake-1</a></td></tr><tr><td>2. 메인 페이지의 HTML 설계</td><td><a href=\"https://witch.work/posts/blog-remake-2\">https://witch.work/posts/blog-remake-2</a></td></tr><tr><td>3. 글 상세 페이지의 구조 설계</td><td><a href=\"https://witch.work/posts/blog-remake-3\">https://witch.work/posts/blog-remake-3</a></td></tr><tr><td>4. 이미지를 상대 경로로 쓸 수 있도록 하기</td><td><a href=\"https://witch.work/posts/blog-remake-4\">https://witch.work/posts/blog-remake-4</a></td></tr><tr><td>5. 자잘한 페이지 구성 개선과 배포</td><td><a href=\"https://witch.work/posts/blog-remake-5\">https://witch.work/posts/blog-remake-5</a></td></tr><tr><td>6. 페이지 요소의 배치 설계</td><td><a href=\"https://witch.work/posts/blog-remake-6\">https://witch.work/posts/blog-remake-6</a></td></tr><tr><td>7. 메인 페이지 컴포넌트 디자인</td><td><a href=\"https://witch.work/posts/blog-remake-7\">https://witch.work/posts/blog-remake-7</a></td></tr><tr><td>8. 글 목록/내용 페이지 컴포넌트 디자인</td><td><a href=\"https://witch.work/posts/blog-remake-8\">https://witch.work/posts/blog-remake-8</a></td></tr><tr><td>9. 글 썸네일 자동 생성하기</td><td><a href=\"https://witch.work/posts/blog-remake-9\">https://witch.work/posts/blog-remake-9</a></td></tr><tr><td>10. 폰트, 카드 디자인 등의 디자인 개선</td><td><a href=\"https://witch.work/posts/blog-remake-10\">https://witch.work/posts/blog-remake-10</a></td></tr><tr><td>11. 글에 조회수 달기</td><td><a href=\"https://witch.work/posts/blog-remake-11\">https://witch.work/posts/blog-remake-11</a></td></tr><tr><td>12. 페이지 테마와 글 검색 기능</td><td><a href=\"https://witch.work/posts/blog-remake-12\">https://witch.work/posts/blog-remake-12</a></td></tr><tr><td>13. 테마 아이콘과 썸네일 레이아웃 개선 등</td><td><a href=\"https://witch.work/posts/blog-remake-13\">https://witch.work/posts/blog-remake-13</a></td></tr><tr><td>14. 글 분류를 태그 기반으로 변경</td><td><a href=\"https://witch.work/posts/blog-remake-14\">https://witch.work/posts/blog-remake-14</a></td></tr><tr><td>메인 페이지의 연산 최적화</td><td><a href=\"https://witch.work/posts/blog-opt-1\">https://witch.work/posts/blog-opt-1</a></td></tr><tr><td>글 목록 페이지네이션 만들기</td><td><a href=\"https://witch.work/posts/blog-opt-2\">https://witch.work/posts/blog-opt-2</a></td></tr><tr><td>이미지를 CDN에 올리고 placeholder 만들기</td><td><a href=\"https://witch.work/posts/blog-opt-3\">https://witch.work/posts/blog-opt-3</a></td></tr><tr><td>검색 페이지에 무한 스크롤 구현하기</td><td><a href=\"https://witch.work/posts/blog-opt-4\">https://witch.work/posts/blog-opt-4</a></td></tr></tbody></table>\n<p>드디어 다시 Card 컴포넌트에 들어갈 글 썸네일을 만들어 주는 작업으로 돌아왔다. 다른 페이지들을 대강이나마 꾸며주는 데에 글 하나가 쓰였다. 특히 TOC를 만들어 주는 데에 많은 시간이 걸렸다.</p>\n<h1>1. 설계</h1>\n<p>이 글에서 하기로 생각하는 건 하나뿐이다. 글의 썸네일을 만드는 것이다.</p>\n<p>글 목록에서 보이는 <code>Card</code> 컴포넌트는 현재 글의 프리뷰 같은 느낌으로 작동하므로 여기에 글의 썸네일을 넣을 수도 있을 것이고, 또한 open graph 이미지에도 넣을 수 있을 것이다. 이는 글의 이해에도 도움을 주고 링크 미리보기도 생성해 주며 글 목록 페이지의 카드 내의 텍스트 한 줄의 너비도 줄여서 사용자의 집중도를 높일 수 있을 것이다.</p>\n<p>이때 썸네일을 넣으면 글 목록의 카드 내의 텍스트 한 줄 너비가 줄어든다고 한 이유는 다음과 같은 레이아웃을 생각하고 있기 때문이다.</p>\n<p><img src=\"/static/card-layout-318eb82f.png\" alt=\"card-layout\"></p>\n<p>하지만 이를 위해 해야 하는 일이 많다. 과연 썸네일에는 어떤 이미지가 들어가야 할까?</p>\n<p>만약 글 내에 쓰인 이미지가 있다면, 그게 썸네일이 되는 게 마땅하다고 생각한다. 물론 그게 꼭 글의 내용을 간략하게 정리하는 이미지일 거라고 생각하지는 않지만 일단 그렇게 해보자. 나중에 이상하면 바꾸면 되니까.</p>\n<p>더 큰 문제는 글에 쓰인 이미지가 없을 때이다. 이때는 무엇이 썸네일이 되어야 할까? 글의 제목 혹은 글의 요약이라고도 할 수 있는 TOC(Table Of Content)의 일부가 되어야 하지 않을까 한다. 이런 썸네일을 동적으로 만들어보자.</p>\n<p>일단 이전에 <code>Card</code>컴포넌트에서 이미지를 넣을 수 있도록 타입을 정해 놓긴 했다. 따라서 이미지를 가져올 방법을 생각해 보자. <code>src/pages/posts/[category]/index.tsx</code>에서 <code>Card</code> 컴포넌트에 어떻게든 썸네일 이미지를 넘겨주기만 하면 된다.</p>\n<h1>2. 구상</h1>\n<p>먼저 생각을 해보았다. md 파일 내용은 html 형식을 한 문자열로 변환되어 저장되어 있으니 여기서 정규식으로 img 태그의 src를 파싱해서 그걸 썸네일로 만들 수 있겠다. 실제로 이 방법으로 시도하였고 어느 정도 성공을 거두었다.</p>\n<p>그런데 mdx 파일은? mdx 파일은 코드로 변환되기 때문에 쓰인 이미지를 찾기가 난감했다. 라이브러리 같은 게 있기는 했지만 그렇게 내키지 않았다.</p>\n<p>그런데 우리는 이미 md파일이건 mdx파일이건 내부의 요소 계층 구조를 다룰 수 있는 방법을 알고 있다. 바로 remark 플러그인에서 하는 것이다.</p>\n<p>따라서 다음과 같은 방식을 생각했다.</p>\n<ol>\n<li>remark 플러그인에서 AST상의 이미지 요소를 찾고, src를 파싱한다.</li>\n<li>이미지가 없을 경우 제목과 heading 요소를 이용해서 어떻게든 썸네일을 만든다.</li>\n</ol>\n<h1>3. 글에 이미지가 있을 경우</h1>\n<p>일단 플러그인을 만들자. <code>src/plugins</code>에 <code>make-thumbnail.mjs</code>를 만들자.</p>\n<p>마크다운으로 만들어진 AST 중 이미지 태그를 순회하면서 이미지 URL들을 모두 파싱한 후 그 첫번째 URL을 thumbnail로 넘겨주는 것이다. 만약 글에 이미지가 없다면 그대로 넘어간다.</p>\n<pre><code class=\"language-js\">// src/plugins/make-thumbnail.mjs\nimport {visit} from 'unist-util-visit';\n\n// 모든 이미지 뽑아내기\nfunction extractImgSrc(tree) {\n  const images=[];\n  visit(tree, 'image', (node)=>{\n    images.push(node.url);\n  });\n  return images;\n}\n\nexport default function makeThumbnail() {\n  return function(tree, file) {\n    const images=extractImgSrc(tree);\n    if (images.length>0) {\n      file.data.rawDocumentData.thumbnail=images[0];\n    }\n  };\n}\n</code></pre>\n<p>이제 이 플러그인을 <code>contentlayer.config.js</code>에서 remark plugin으로 추가해 준다.</p>\n<pre><code class=\"language-js\">// contentlayer.config.js\nexport default makeSource({\n  contentDirPath: 'posts',\n  documentTypes: [MDXPost, Post],\n  markdown: {\n    // 여기에 플러그인으로 추가\n    remarkPlugins: [remarkGfm, changeImageSrc, headingTree, makeThumbnail],\n    rehypePlugins: [[rehypePrettyCode, rehypePrettyCodeOptions]],\n  },\n  mdx: {\n    remarkPlugins: [remarkGfm, changeImageSrc, headingTree, makeThumbnail],\n    rehypePlugins: [[rehypePrettyCode, rehypePrettyCodeOptions], highlight],\n  },\n});\n</code></pre>\n<p>이렇게 하면 JSON으로 변환된 파일에 thumbnail 항목이 추가된 것을 확인할 수 있다. 단 이미지가 들어가 있는 글에 한해서 해당 이미지의 경로가 들어가 있다. 이미지가 있는 글의 경우 <code>make-thumbnail.mjs</code>에서 썸네일을 만들어 주면 되겠다.</p>\n<h1>4. 글에 이미지가 없을 경우</h1>\n<p>이 경우 이미지를 동적으로 만들어줘야 한다. 이런 용도로 최근에 vercel에서 나온 라이브러리 <code>@vercel/og</code>가 있다. open graph만을 위해 나온 거긴 하지만 이를 한번 써보자.</p>\n<pre><code class=\"language-bash\">npm i @vercel/og\n</code></pre>\n<p><a href=\"https://vercel.com/docs/concepts/functions/edge-functions/og-image-generation#usage\">공식 문서</a>를 참고해서 해보았다. 먼저 <code>src/pages/api/thumbnail.tsx</code>를 만들고 다음과 같이 작성한다.</p>\n<pre><code class=\"language-tsx\">import { ImageResponse } from '@vercel/og';\nimport { NextRequest } from 'next/server';\n\nexport const config = {\n  runtime: 'edge',\n};\n \nexport default function handler (request: NextRequest) {\n  try {\n    const { nextUrl: { search } } = request;\n    const urlSearchParams = new URLSearchParams(search);\n    const params = Object.fromEntries(urlSearchParams.entries());\n    const title=params.title;\n\n    return new ImageResponse(\n      (\n        &#x3C;div\n          style={{\n            fontSize: 128,\n            background: 'white',\n            width: '100%',\n            height: '100%',\n            display: 'flex',\n            textAlign: 'center',\n            alignItems: 'center',\n            justifyContent: 'center',\n          }}\n        >\n          {title}\n        &#x3C;/div>\n\n      ),\n      {\n        width: 1200,\n        height: 600,\n      },\n    );\n  }\n  catch (error) {\n    console.error(error);\n    return new Response('Failed to generate thumbnail', { status: 500 });\n  }\n}\n</code></pre>\n<p>이러면 <code>블로그주소/api/thumnail</code>에 쿼리스트링으로 title을 전달한 URL로 접속하면 title이 크게 쓰인 사진 같은 게 보이게 된다. 이를 썸네일 소스로 사용하면 되겠다.</p>\n<p>하지만 이게 내가 블로그 배포에 쓸 Cloudflare Pages에서도 잘 될까? 해보니 역시나. 엄청난 고난들이 있었다.</p>\n<h1>5. Cloudflare 배포</h1>\n<p>나는 블로그를 Cloudflare에서 배포할 예정이다. 하지만 <code>@vercel/og</code>는 vercel에서 만든 라이브러리인데, vercel에서 배포할 때만 돌아가는 게 아닐까? 그래서 Cloudflare에서 배포하고 실험해 보기로 했다.</p>\n<p>당연히 NextJS는 Vercel에서 만든 것이므로 그쪽에 가장 최적화가 잘 되어 있고, 따라서 Cloudflare에서 배포할 때는 <code>@vercel/og</code> 말고도 문제가 좀 있었다.</p>\n<p>그나마 다행히도 <a href=\"https://blog.cloudflare.com/next-on-pages/\">Cloudflare에서도 작년 말부터 nextJS 배포 정식 지원</a>을 시작했지만, 당연히 제작자인 Vercel에서 배포하는 것만큼 좋지는 않았다.</p>\n<p>아무튼 다음은 <a href=\"https://developers.cloudflare.com/pages/framework-guides/deploy-a-nextjs-site/\">Cloudflare Nextjs 배포 문서</a>을 참고해서 Nextjs를 Cloudflare에서 배포하면서 문제를 해결한 과정이다.</p>\n<p>먼저 nextJS 배포를 위한 cloudflare 패키지 설치</p>\n<pre><code class=\"language-bash\">npm install --save-dev @cloudflare/next-on-pages\n</code></pre>\n<p>그리고 Workers &#x26; Pages 메뉴에서 페이지를 만들고 github 레포를 연결한다. 이 과정은 <a href=\"https://jojoldu.tistory.com/657\">조졸두님의 글</a>에 잘 설명되어 있다.</p>\n<p>하지만 나는 api 라우트를 사용할 것이므로 프레임워크 프리셋에서 그냥 Next.js를 선택한다. <code>Next.js(Static HTML Export)</code>가 아니다!</p>\n<p>그리고 <a href=\"https://witch.work/blog-move-to-cloudflare/#11-%EC%98%A4%EB%A5%98-%ED%95%B4%EA%B2%B0\">내가 이전에 쓴 글</a>을 참고하여 Cloudflare의 빌드에 쓰일 노드 버전을 <code>17.9.1</code>로 올렸다.</p>\n<p>공식 문서에서도 NextJS가 Node.js 16 버전 이상을 요구하므로 이렇게 Node 버전을 올리라고 설명하고 있다.</p>\n<p>그다음에 배포를 해보면 실패한다. 에러 메시지를 읽어보면 <code>nodejs_compat</code>호환성 플래그가 문제라고 한다.</p>\n<p>Workers 및 페이지 -> 내 프로젝트 방문 -> 설정 -> 함수 -> 호환성 플래그 에서 프로덕션 호환성 플래그와 미리보기 호환성 플래그에 <code>nodejs_compat</code>을 설정한다.</p>\n<p><img src=\"/static/compat_flag-c615ec1b.png\" alt=\"compatibility-flag\"></p>\n<p>이번에는 이미지가 제대로 뜨지 않는다. <a href=\"https://github.com/cloudflare/next-on-pages/issues/94\">NextJS의 이미지를 Cloudflare에서 제대로 지원하지 않는다고 한다</a>따라서 next의 이미지 최적화를 끄자. <code>next.config.js</code>에서 <code>images.unoptimized</code>를 <code>true</code>로 설정한다.</p>\n<pre><code class=\"language-js\">// next.config.js\nconst nextConfig = {\n  images:{\n    /* 이 부분 추가 */\n    unoptimized:true,\n  },\n  compress:true,\n  reactStrictMode: true,\n  swcMinify:false,\n};\n</code></pre>\n<p>이번에는 타입 에러가 뜬다. 내가 <code>getSortedPosts()</code>함수를 써서 가져온 데이터에서 필터링을 하는 부분이 있는데 여기에 쓰인 필터 함수의 인수가 정의가 안 되어 있다는 에러였다.</p>\n<pre><code class=\"language-tsx\">/* 여기 쓰인 필터 함수의 post에 타입 정의가 안되어 있다 */\nconst categoryPostList=getSortedPosts().filter((post)=>{\n  return post._raw.flattenedPath.split('/')[0]===category.url.split('/').pop();\n}).slice(0, 3);\n</code></pre>\n<p>따라서 <code>contentlayer/generated</code>에 정의된 <code>DocumentTypes</code> 타입을 찾아와서 정의해주었다.</p>\n<pre><code class=\"language-tsx\">const categoryPostList=getSortedPosts().filter((post: DocumentTypes)=>{\n  return post._raw.flattenedPath.split('/')[0]===category.url.split('/').pop();\n}).slice(0, 3);\n</code></pre>\n<p>이외에도 <code>getSortedPosts()</code>와 관련된 부분들에 다 타입을 붙여줬다. Cloudflare 배포를 한번씩 하면서 배포(5분쯤 걸림)-버그확인-고치기 를 반복하는 지루한 작업이었다.</p>\n<p>그런데 이제는 <code>@vercel/og</code>가 동작하지 않는다. Cloudflare에선 안된다...</p>\n<h1>6. Cloudflare에서 썸네일 만들기</h1>\n<p>Cloudflare에서도 open graph 2023년 4월 정도부터 이미지 생성을 지원한다. 이건 Cloudflare worker에서 동작한다는 차이점뿐 API 명세 등은 같다. 버전 0.1.0밖에 안 되는 따끈한 버전이다.</p>\n<p><a href=\"https://developers.cloudflare.com/pages/platform/functions/plugins/vercel-og/\">공식 문서</a>를 참고하여 Cloudflare버전의 <code>@vercel/og</code>를 사용해보자.</p>\n<pre><code class=\"language-bash\">npm install @cloudflare/pages-plugin-vercel-og\n</code></pre>\n<p>하지만 이걸 써보려고 하루종일 시도했으나 잘 되지 않았다. 사실 vercel에서 <code>@vercel/og</code>를 쓸 때도, 대부분의 사진은 잘 생성되었지만 가끔씩 사진이 생성되지 않는 경우가 있었다. 이유는 잘 모르겠지만 한글 인코딩 과정에서 뭔가 문제가 생기지 않았을까 추측한다. <a href=\"https://morethanmin.com/posts/how-to-generate-dynamic-og-image\">og-image-korean</a>이라는 것도 있는 모양이지만 어차피 vercel에서만 될 것 같았다.</p>\n<h2>6.1. canvas로 이미지 생성해보기</h2>\n<p>그래서 어차피 우리가 썸네일 생성에 쓸 것은 그냥 텍스트(제목 등)와 정적 이미지만 들어간 사진이므로 canvas를 써서 직접 생성해 보기로 했다.</p>\n<p>원래 쓰던 <code>@vercel/og</code> 플러그인 삭제. 그리고 canvas 설치</p>\n<pre><code class=\"language-bash\">npm uninstall @cloudflare/pages-plugin-vercel-og\nnpm install canvas\n</code></pre>\n<p>바로 엄청난 에러의 향연이 펼쳐졌다. canvas를 못 깔겠단다.</p>\n<pre><code class=\"language-bash\">npm ERR! code 1\nnpm ERR! path /Users/kimsunghyun/Desktop/nextjs-blog/node_modules/canvas\nnpm ERR! command failed\nnpm ERR! command sh -c node-pre-gyp install --fallback-to-build --update-binary\nnpm ERR! Failed to execute '/opt/homebrew/Cellar/node/20.1.0/bin/node /opt/homebrew/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js configure --fallback-to-build --update-binary --module=/Users/kimsunghyun/Desktop/nextjs-blog/node_modules/canvas/build/Release/canvas.node --module_name=canvas --module_path=/Users/kimsunghyun/Desktop/nextjs-blog/node_modules/canvas/build/Release --napi_version=8 --node_abi_napi=napi --napi_build_version=0 --node_napi_label=node-v115' (1)\nnpm ERR! node-pre-gyp info it worked if it ends with ok\nnpm ERR! node-pre-gyp info using node-pre-gyp@1.0.10\nnpm ERR! node-pre-gyp info using node@20.1.0 | darwin | arm64\nnpm ERR! node-pre-gyp http GET https://github.com/Automattic/node-canvas/releases/download/v2.11.2/canvas-v2.11.2-node-v115-darwin-unknown-arm64.tar.gz\nnpm ERR! node-pre-gyp ERR! install response status 404 Not Found on https://github.com/Automattic/node-canvas/releases/download/v2.11.2/canvas-v2.11.2-node-v115-darwin-unknown-arm64.tar.gz \nnpm ERR! node-pre-gyp WARN Pre-built binaries not installable for canvas@2.11.2 and node@20.1.0 (node-v115 ABI, unknown) (falling back to source compile with node-gyp) \nnpm ERR! node\n이하 생략\n</code></pre>\n<p>node-pre-gyp가 문제인 것 같다. 그래서 <a href=\"https://github.com/Brooooooklyn/canvas\">그걸 안 쓰는 canvasAPI</a>를 찾아서 써보았다. 심지어 더 빠르다고 한다. Rust를 써서 컴파일되며 시스템 디펜던시도 없다고 한다.</p>\n<pre><code class=\"language-bash\">npm install @napi-rs/canvas\n</code></pre>\n<p>이를 이용해서 <code>make-thumbnail.mjs</code>를 다음과 같이 수정해보자. 만약 글에 이미지가 없을 경우, 간단하게 제목을 썸네일로 만들어주는 실험을 해보았다. 제목을 뽑아내는 건 여기서 쓰는 file 객체의 형식을 <code>console.log</code>로 열심히 찍어 보면서 직접 만들었다.</p>\n<p>파일의 원래 내용이 <code>file.value</code>에 저장되어 있었고 이를 개행 기준으로 split해주면 2번째 요소가 <code>title: 제목어쩌고저쩌고</code>였다.</p>\n<pre><code class=\"language-js\">export default function makeThumbnail() {\n  return function(tree, file) {\n    //console.log(file);\n    const images=extractImgSrc(tree);\n    if (images.length>0) {\n      file.data.rawDocumentData.thumbnail=images[0];\n    }\n    else {\n      const title=file.value.split('\\n')[1];\n\n      const canvas = createCanvas(300, 320);\n      const ctx = canvas.getContext('2d');\n      ctx.fillText(title, 50, 150);\n      const b = canvas.toBuffer('image/png');\n\n      file.data.rawDocumentData.thumbnail=`data:image/png;base64,${b.toString('base64')}`;\n    }\n  };\n}\n</code></pre>\n<p>이렇게 하니까 글에 이미지가 없을 경우 <code>file.data.rawDocumentData.thumbnail</code>에 이미지 자체는 잘 만들어졌다. 그런데 한글이 깨진다. 찾아보니 폰트를 직접 받아서 지정해 줘야 한다. 따라서 구글 폰트에서 제공하는 무료 폰트를 사용하기로 했다.</p>\n<p>TMI지만 이렇게 한글이 깨지는 등, 폰트에서 지원하지 않는 글자가 있을 때 글자가 깨져서 나오는 네모난 모양을 tofu라고 부르는데(아마 두부처럼 네모나서 그렇지 않을까) 이러한 tofu가 없다는 의미로 위 폰트에 Noto 라는 이름이 붙었다고 한다.</p>\n<pre><code>이러한 글꼴에 비용이 있나요?\n아니요, 모든 Google Fonts는 오픈소스이며 무료로 제공됩니다.\n- Google Fonts FAQ 중\n</code></pre>\n<p>그래서 <a href=\"https://fonts.google.com/noto/specimen/Noto+Sans+KR\">NotoSansKR</a>의 otf 파일을 다운받아서 <code>/font</code>에 넣고 다음과 같이 폰트를 직접 지정해 주었다.</p>\n<pre><code class=\"language-js\">import {join} from 'path';\nimport path from 'path';\n\nimport { createCanvas, GlobalFonts } from '@napi-rs/canvas';\nimport {visit} from 'unist-util-visit';\n\nconst __dirname = path.resolve();\nGlobalFonts.registerFromPath(join(__dirname, 'fonts', 'NotoSansKR-Light.otf'), 'NotoSansKR');\n\n// 모든 이미지 뽑아내기\nfunction extractImgSrc(tree) {/* 생략 */}\n\nexport default function makeThumbnail() {\n  return function(tree, file) {\n    //console.log(file);\n    const images=extractImgSrc(tree);\n    if (images.length>0) {\n      file.data.rawDocumentData.thumbnail=images[0];\n    }\n    else {\n      const title=file.value.split('\\n')[1];\n\n      const canvas = createCanvas(300, 300);\n      const ctx = canvas.getContext('2d');\n      /* 폰트 지정 */\n      ctx.font = '35px NotoSansKR';\n      ctx.fillText(title, 0, 100);\n      const b = canvas.toBuffer('image/png');\n\n      file.data.rawDocumentData.thumbnail=`data:image/png;base64,${b.toString('base64')}`;\n    }\n  };\n}\n</code></pre>\n<p>이렇게 하니까 썸네일이 잘 나온다. 이제 이를 좀더 다듬어보자.</p>\n<h2>6.2. 썸네일 이미지 구성</h2>\n<p>일단 글씨에 들어가는 <code>title:</code>부터 떼버리고, 레이아웃도 어떻게 할지 생각해 보았다. 일단 제목은 어떻게든 들어가야 하고. 부연 설명도 heading 2개 정도를 떼어서 넣어주면 좋겠다. 그리고 내 블로그의 제목도 넣고자 한다.</p>\n<p>이런 레이아웃을 어떻게든 만들면 되지 않을까?</p>\n<p><img src=\"/static/thumbnail-layout-c1a29312.png\" alt=\"썸네일 레이아웃\"></p>\n<p>이를 기반으로 <code>createThumbnailFromText</code>함수를 구성해 보자. 먼저 400x300 정도로 캔버스를 생성하자. 이후에 이미지 처리를 위한 비동기 로직이 쓰일 것이므로 async 함수로 만들어준다.</p>\n<pre><code class=\"language-js\">async function createThumbnailFromText(title, headings, filePath) {\n  const width=400;\n  const height=300;\n\n  const canvas = createCanvas(width, height);\n  const ctx = canvas.getContext('2d');\n}\n</code></pre>\n<p>필요한 함수들을 하나하나 생성해 보자. 먼저 캔버스를 흰색으로 칠해 주는 <code>initCanvas</code> 함수를 만들자. 그냥 흰색 직사각형으로 캔버스를 칠해주는 함수다. 그 후 스타일 색상을 바꿔주는 것만 잊지 않으면 된다.</p>\n<pre><code class=\"language-js\">function initCanvas(ctx, width, height) {\n  ctx.fillStyle = '#fff';\n  ctx.fillRect(0, 0, width, height);\n  ctx.fillStyle = '#000';\n}\n</code></pre>\n<p>이제는 제목을 일정 글자수마다 끊어 주는 함수를 만들고 그렇게 끊긴 제목 부분들을 하나씩 그려주는 함수 <code>drawTitle</code></p>\n<pre><code class=\"language-js\">// maxWidth가 넘으면 개행 문자를 삽입해서 break-word를 수행해 주는 함수\nconst stringWrap = (s, maxWidth) => s.replace(\n  new RegExp(`(?![^\\\\n]{1,${maxWidth}}$)([^\\\\n]{1,${maxWidth}})\\\\s`, 'g'), '$1\\n'\n);\n\nfunction drawTitle(ctx, title) {\n  // 15글자가 넘으면 자동 break-word\n  title=stringWrap(title, 15);\n  title=title.split('\\n');\n  // 한줄씩 캔버스에 그림\n  ctx.font = '40px NotoSansKR';\n  for (let i=0; i&#x3C;title.length; i++) {\n    ctx.fillText(title[i], 0, 50+50*i);\n  }\n}\n</code></pre>\n<p>그리고 headingTree를 받아서 그중 depth 1짜리(즉 h1에 쓰인) 소제목들을 최대 2개까지 뽑아서 캔버스에 그려 주는 <code>drawHeadings</code>함수도 작성한다. 내가 주로 쓰는 소제목 양식에 맞춰 적당히 포매팅도 했다. 소제목들은 굳이 break-word를 쓰진 않았다.</p>\n<pre><code class=\"language-js\">function drawHeadings(ctx, headingTree) {\n  const thumbnailHeadings=headingTree.slice(0, 2);\n  const headingTexts=[];\n  for (let h of thumbnailHeadings) {\n    const headingText=h.data.hProperties.title.replaceAll('. ', '-');\n    headingTexts.push(headingText);\n  }\n  headingTexts[headingTexts.length-1]+='...';\n  ctx.font = '20px NotoSansKR';\n  for (let i=0; i&#x3C;headingTexts.length; i++) {\n    ctx.fillText(headingTexts[i], 0, 150+25*i);\n  }\n}\n</code></pre>\n<p>그리고 내 블로그의 favicon으로도 쓰이고 있는 마녀 모자 사진을 가져와서 캔버스에 그려주는 <code>drawBlogSymbol</code>함수도 만들어 준다. 이때 마녀 모자 사진은 40x40으로 캔버스에 그려준다. 그리고 이미지 로딩이 끝나고 나서 이미지를 사용해야 하므로 await을 사용했다.</p>\n<pre><code class=\"language-js\">async function drawBlogSymbol(ctx, blogName) {\n  const hatImage = await fs.readFile(join(__dirname, 'public', 'witch-hat.svg'));\n  const image=new Image();\n  image.src=hatImage;\n\n  image.width=40;\n  image.height=40;\n\n  ctx.drawImage(image, 0, 220);\n\n  ctx.font = '20px NotoSansKR';\n  ctx.fillText(blogName, 45, 250);\n}\n</code></pre>\n<p>그리고 이렇게 만든 함수들을 모두 사용해서 그린 캔버스를 png로 인코딩해서 파일로 만든 후 경로를 리턴하는 함수 <code>createThumbnailFromText</code>를 완성하자.</p>\n<pre><code class=\"language-js\">async function createThumbnailFromText(title, headings, filePath) {\n  const width=400;\n  const height=300;\n\n  const canvas = createCanvas(width, height);\n  const ctx = canvas.getContext('2d');\n\n  initCanvas(ctx, width, height);\n\n  drawTitle(ctx, title);\n\n  drawHeadings(ctx, headings);\n\n  await drawBlogSymbol(ctx, 'Witch-Work');\n\n  const fileName=`${filePath.replaceAll('/', '-').replaceAll('.','-')}-thumbnail.png`;\n\n  const pngData=await canvas.encode('png');\n  await fs.writeFile(join(__dirname, 'public', 'thumbnails', fileName), pngData);\n  const resultPath=`/thumbnails/${fileName}`;\n\n  return resultPath;\n}\n</code></pre>\n<p>이렇게 해주면 내 프로젝트 폴더의 <code>/public/thumbnails</code>에 썸네일이 잘 만들어진다. 단 <code>/public/thumbnails</code>폴더까지는 직접 생성해 줘야 한다. 그렇지 않으면 <code>fs.writeFile</code>에서 에러가 나더라.</p>\n<p>예를 들어 이런 썸네일이 자동으로 생성되게 된다.</p>\n<p><img src=\"/static/test-thumbnail-9a096062.png\" alt=\"썸네일 예시\"></p>\n<p>contentlayer에서 무슨 변경 flag 처리라도 하는 건지, 이렇게 하면 알아서 정보가 변경된 글에 대해서만 썸네일이 새로 생성된다.</p>\n<h1>7. 썸네일 넣어 주기</h1>\n<p>그럼 이제 양식을 잘 맞춰서 글을 썼다고 할 때, 모든 글의 변환 데이터에 <code>thumbnail</code> 속성이 들어가 있을 것이다. 사실 양식이 좀 안 맞아도 어쨌든 들어가 있긴 할 거라 생각한다. null이나 undefined라도...</p>\n<p>이걸 이제 글 목록 페이지의 Card 컴포넌트에 넣고, 글 상세 페이지의 <code>og:image</code>에도 넣어주자. <code>Card</code>컴포넌트에는 이미 이미지를 넣을 수 있는 기능이 있으므로 이를 props로 넘겨주기만 하면 된다. 따라서 <code>src/pages/posts/[category]/index.tsx</code>의 <code>getStaticProps</code>를 다음과 같이 수정한다.</p>\n<p><code>post._raw</code> 의 타입이 엄격하게 정해져 있는 편이었어서 이를 회피하느라 좀 코드가 길어졌는데, <code>post._raw</code> 내에 <code>thumbnail</code>이 있을 때만 그걸 넘겨주는 식으로 했다.</p>\n<pre><code class=\"language-tsx\">// src/pages/posts/[category]/index.tsx\nexport const getStaticProps: GetStaticProps = ({params}) => {\n  const allDocumentsInCategory = getSortedPosts().filter((post: DocumentTypes)=>\n    post._raw.flattenedPath.startsWith(params?.category as string\n    ));\n  \n  const {title:category, url:categoryURL}=blogCategoryList.find((c: {title: string, url: string})=>\n    c.url.split('/').pop()===params?.category) as {title: string, url: string};\n\n  const postList = allDocumentsInCategory.map((post: DocumentTypes) => {\n    const { title, description, date, tags, url } = post;\n    const metadata={title, description, date, tags, url};\n    return 'thumbnail' in post._raw ? \n      ({...metadata, image: post._raw.thumbnail} as PostMetaData) :\n      metadata;\n  });\n\n  return { props: { category, categoryURL,postList } };\n};\n</code></pre>\n<p>그리고 <code>PostListPage</code> 컴포넌트에서는 다음과 같이 post별 데이터를 그냥 <code>Card</code>에 넘겨주도록 한다.</p>\n<pre><code class=\"language-tsx\">// src/pages/posts/[category]/index.tsx\nfunction PostListPage({\n  category, categoryURL, postList,\n}: InferGetStaticPropsType&#x3C;typeof getStaticProps>) {\n\n  /* SEO 정보 부분 생략 */\n\n  return (\n    &#x3C;main className={styles.page}>\n      &#x3C;NextSeo {...SEOInfo} />\n      &#x3C;div className={styles.container}>\n        &#x3C;h1 className={styles.title}>{`${category} 주제의 글`}&#x3C;/h1>\n        &#x3C;ul className={styles.list}>\n          {postList.map((post: PostMetaData) =>{\n            return (\n              &#x3C;li key={post.url}>\n              {/* 이렇게 그냥 모든 정보를 넘겨준다 */}\n                &#x3C;Card {...post} />\n              &#x3C;/li>\n            );\n          }\n\n          )}\n        &#x3C;/ul>\n      &#x3C;/div>\n    &#x3C;/main>\n  );\n}\n</code></pre>\n<p>이제 글 목록 페이지에서 썸네일이 잘 보이는 걸 확인할 수 있다. 이제 <code>src/pages/posts/[category]/[slug]/index.tsx</code>에서 open graph 이미지도 넣어주자. 이건 <code>getStaticProps</code>에서 post를 통째로 넘겨주기 때문에 <code>post._raw.thumbnail</code>을 <code>SEOconfig</code>에 넣어 주기만 하면 된다.</p>\n<pre><code class=\"language-tsx\">/* src/pages/posts/[category]/[slug]/index.tsx\n파일에서 쓰는 SEOinfo 객체.\n이걸 &#x3C;NextSeo {...SEOInfo} /> 형태로 넘긴다. */\nconst SEOInfo: NextSeoProps={\n  title: post.title,\n  description: post.description,\n  canonical:`${SEOConfig.canonical}${post.url}`,\n  openGraph:{\n    title: post.title,\n    description: post.description,\n    images: [\n      {\n        url:`${blogConfig.url}${post._raw.thumbnail}`,\n        alt: `${blogConfig.name} 프로필 사진`,\n      },\n    ],\n    url:`${SEOConfig.canonical}${post.url}`,\n  }\n};\n</code></pre>\n<h1>8. 카드 내부 요소 배치</h1>\n<p>그런데 지금 보니 카드에서 썸네일 사진과 글 인트로가 딱 붙어 있다.</p>\n<pre><code class=\"language-tsx\">// src/components/Card/index.tsx\nfunction Card(props: Props) {\n  const { title, description, image, date, tags, url } = props;\n  return (\n    &#x3C;Link className={styles.link} href={url}>\n      &#x3C;article className={styles.container}>\n        {image ?\n          &#x3C;div className={styles.imagebox}>\n            &#x3C;Image className={styles.image} src={image} alt={`${image} 사진`} width={200} height={200} />\n          &#x3C;/div>\n          :\n          null\n        }\n        &#x3C;Intro title={title} description={description} date={date} tags={tags} />\n      &#x3C;/article>\n    &#x3C;/Link>\n  );\n}\n</code></pre>\n<p>그리고 <code>src/components/Card/styles.module.css</code>를 다음과 같이 수정한다. 높이를 기준으로 사진 크기를 조절할 수 있다면 좋았겠지만 그럴 방법을 모르겠어서, 어차피 다 비슷한 레이아웃으로 쓰일 거라 width, height를 딱 정해 주었다.</p>\n<pre><code class=\"language-css\">// src/components/Card/styles.module.css\n.container{\n  /*border: 1px solid var(--gray5);*/\n  border-radius: 1rem;\n  box-sizing: border-box;\n  height: 100%;\n  display:flex;\n  flex-direction:row;\n}\n\n.link{\n  display:block;\n  height:100%;\n  padding:1rem;\n  padding-left:0;\n  text-decoration:none;\n  color:var(--black);\n}\n\n.link:hover{\n  padding-left:1rem;\n  border-radius: 1rem;\n  color:var(--indigo6);\n  background-color:var(--gray1);\n}\n\n.image{\n  display:block;\n  width:150px;\n  height:120px;\n  object-fit:fill;\n  margin:0;\n  margin-right:1rem;\n}\n</code></pre>\n<p>이렇게 하니까 사진 크기가 무조건 고정된다. 높이 기준으로 어떻게든 해보려 했지만, 이미지 요소의 조상 요소들 중에 computed height가 없어서 쉽지 않았기에 그냥 고정해 버렸다.</p>\n<h1>참고</h1>\n<p>동적 썸네일 만들기 <a href=\"https://dev.to/xaconi_94/how-to-create-dynamic-nextjs-post-thumbnails-like-dev-to-3ika\">https://dev.to/xaconi_94/how-to-create-dynamic-nextjs-post-thumbnails-like-dev-to-3ika</a></p>\n<p><a href=\"https://articles.wesionary.team/customize-social-media-preview-of-your-nextjs-website-links-82f6bce035b\">https://articles.wesionary.team/customize-social-media-preview-of-your-nextjs-website-links-82f6bce035b</a></p>\n<p><a href=\"https://morethanmin.com/posts/how-to-generate-dynamic-og-image\">https://morethanmin.com/posts/how-to-generate-dynamic-og-image</a></p>\n<p><a href=\"https://vercel.com/docs/concepts/functions/edge-functions/og-image-generation#usage\">https://vercel.com/docs/concepts/functions/edge-functions/og-image-generation#usage</a></p>\n<p>img 태그 src 파싱 <a href=\"https://stackoverflow.com/questions/14939296/extract-image-src-from-a-string\">https://stackoverflow.com/questions/14939296/extract-image-src-from-a-string</a></p>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/match\">https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/match</a></p>\n<p><a href=\"https://stackoverflow.com/questions/10585029/parse-an-html-string-with-js\">https://stackoverflow.com/questions/10585029/parse-an-html-string-with-js</a></p>\n<p>NextRequest에서 쿼리스트링 얻기\n<a href=\"https://stackoverflow.com/questions/70272983/how-do-i-get-query-string-params-in-nextjs-middleware\">https://stackoverflow.com/questions/70272983/how-do-i-get-query-string-params-in-nextjs-middleware</a></p>\n<p>간단히 쿼리스트링 만들기 <a href=\"https://stackoverflow.com/questions/316781/how-to-build-query-string-with-javascript\">https://stackoverflow.com/questions/316781/how-to-build-query-string-with-javascript</a></p>\n<p>nextjs를 cloudflare로 배포하기 <a href=\"https://jojoldu.tistory.com/657\">https://jojoldu.tistory.com/657</a></p>\n<p><a href=\"https://developers.cloudflare.com/pages/framework-guides/deploy-a-nextjs-site/\">https://developers.cloudflare.com/pages/framework-guides/deploy-a-nextjs-site/</a></p>\n<p>og 이미지 생성기 <a href=\"https://vercel.com/docs/concepts/functions/edge-functions/og-image-generation#usage\">https://vercel.com/docs/concepts/functions/edge-functions/og-image-generation#usage</a></p>\n<p><a href=\"https://konstantinmuenster.medium.com/generating-dynamic-og-images-for-your-blog-with-vercel-og-1b5f940f6fb3\">https://konstantinmuenster.medium.com/generating-dynamic-og-images-for-your-blog-with-vercel-og-1b5f940f6fb3</a></p>\n<p><a href=\"https://community.cloudflare.com/t/cant-access-api-endpoints-created-by-next-js-on-cloudflare-pages/494813\">https://community.cloudflare.com/t/cant-access-api-endpoints-created-by-next-js-on-cloudflare-pages/494813</a></p>\n<p>cloudflare에서 vercel/og 쓰기\n<a href=\"https://developers.cloudflare.com/pages/platform/functions/plugins/vercel-og/\">https://developers.cloudflare.com/pages/platform/functions/plugins/vercel-og/</a></p>\n<p><a href=\"https://stackoverflow.com/questions/73913732/nextjs-app-wont-export-due-to-image-optimization\">https://stackoverflow.com/questions/73913732/nextjs-app-wont-export-due-to-image-optimization</a></p>\n<p><a href=\"https://www.cloudflare.com/ko-kr/learning/serverless/what-is-serverless/\">https://www.cloudflare.com/ko-kr/learning/serverless/what-is-serverless/</a></p>\n<p>page function 만들기 <a href=\"https://developers.cloudflare.com/pages/platform/functions/get-started/\">https://developers.cloudflare.com/pages/platform/functions/get-started/</a></p>\n<p>로컬에서 cloudflare pages 환경으로 테스트하기 <a href=\"https://github.com/cloudflare/next-on-pages\">https://github.com/cloudflare/next-on-pages</a></p>\n<p><a href=\"https://blog.cloudflare.com/next-on-pages/\">https://blog.cloudflare.com/next-on-pages/</a></p>\n<p>다른 canvas <a href=\"https://github.com/Brooooooklyn/canvas\">https://github.com/Brooooooklyn/canvas</a></p>\n<p>notosans KR <a href=\"https://fonts.google.com/noto/specimen/Noto+Sans+KR\">https://fonts.google.com/noto/specimen/Noto+Sans+KR</a></p>\n<p>node canvas로 이미지 생성 <a href=\"https://blog.logrocket.com/creating-saving-images-node-canvas/\">https://blog.logrocket.com/creating-saving-images-node-canvas/</a></p>\n<p>mac에서 사용중인 port kill <a href=\"https://88240.tistory.com/475\">https://88240.tistory.com/475</a></p>\n<p>ES 모듈에서 <code>__dirname</code> 사용 <a href=\"https://node-js.tistory.com/entry/Nodejs-dirname-is-not-defined-%EC%97%90%EB%9F%AC\">https://node-js.tistory.com/entry/Nodejs-dirname-is-not-defined-%EC%97%90%EB%9F%AC</a></p>\n<p>일정 글자마다 개행 삽입하기 <a href=\"https://stackoverflow.com/questions/14484787/wrap-text-in-javascript\">https://stackoverflow.com/questions/14484787/wrap-text-in-javascript</a></p>\n<p><a href=\"https://morethanmin.com/posts/how-to-generate-dynamic-og-image\">https://morethanmin.com/posts/how-to-generate-dynamic-og-image</a></p>",
    "excerpt": "블로그 만들기 시리즈\n|제목|링크|\n|---|---|\n|1. 기본 세팅|https://witch.work/posts/blog-remake-1|\n|2. 메인 페이지의 HTML 설계|https://witch.work/posts/blog-remake-2|\n|3. 글 상세 페이지의 구조 설계|https://witch.work/posts/blog-remake-3|\n|4. 이미지를 상대 경로로 쓸 수 있도록 하기|https://witch.work/posts/blog-rem",
    "headingTree": [
      {
        "title": "블로그 만들기 시리즈",
        "url": "#블로그-만들기-시리즈",
        "items": []
      },
      {
        "title": "1. 설계",
        "url": "#1-설계",
        "items": []
      },
      {
        "title": "2. 구상",
        "url": "#2-구상",
        "items": []
      },
      {
        "title": "3. 글에 이미지가 있을 경우",
        "url": "#3-글에-이미지가-있을-경우",
        "items": []
      },
      {
        "title": "4. 글에 이미지가 없을 경우",
        "url": "#4-글에-이미지가-없을-경우",
        "items": []
      },
      {
        "title": "5. Cloudflare 배포",
        "url": "#5-cloudflare-배포",
        "items": []
      },
      {
        "title": "6. Cloudflare에서 썸네일 만들기",
        "url": "#6-cloudflare에서-썸네일-만들기",
        "items": [
          {
            "title": "6.1. canvas로 이미지 생성해보기",
            "url": "#61-canvas로-이미지-생성해보기",
            "items": []
          },
          {
            "title": "6.2. 썸네일 이미지 구성",
            "url": "#62-썸네일-이미지-구성",
            "items": []
          }
        ]
      },
      {
        "title": "7. 썸네일 넣어 주기",
        "url": "#7-썸네일-넣어-주기",
        "items": []
      },
      {
        "title": "8. 카드 내부 요소 배치",
        "url": "#8-카드-내부-요소-배치",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 7,
      "wordCount": 1820
    },
    "url": "/posts/blog-remake-9",
    "thumbnail": {
      "local": "/static/card-layout-318eb82f.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-card-layout-318eb82f-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAIAAAA8r+mnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAW0lEQVR4nDXBoRHAIAwF0Cg0kh2+ZIFskA2QjBBZGYmMRSIzEHvU0jvu+h611nLOKaW99znn/ZFdANz9uSJizkm9d1UVEQC1VmZea7k7jTHMjJkBlFJERFUj4gPMNy4JaAi+awAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "book-community-1",
    "title": "책 커뮤니티 만들기 - 1. 최초 설계",
    "date": "2022-02-07T00:00:00Z",
    "description": "책 커뮤니티 폴더 구조 짜기",
    "tags": [
      "web",
      "study"
    ],
    "html": "<h1>1. 책 커뮤니티 만들기 시작</h1>\n<p>스터디에서 3명 팀을 꾸려 React, Express, MySQL을 이용한 프로젝트를 하기로 했다. 스터디원 한 분(<a href=\"https://github.com/hamuneulbo\">https://github.com/hamuneulbo</a>) 의 제안으로, 책을 기반으로 하는 커뮤니티 사이트를 제작하기로 하였다. 그래서 블로그에 개발기록을 간단히 기록해 놓기로 했다. 블로그에 내가 하는 작업(이라고 하기에는 공부에 더 가깝지만)들을 정리해 놓는 것이 도움이 될 거라는 조언도 많이 들었기에...</p>\n<h1>2. 사이트 구조 짜기</h1>\n<p>이전에 한 번, 클론코딩을 잠깐 시도한 적이 있었다. 그런데 그때, 클론코딩이니까 그대로 따라 만들기만 하면 되겠지-하고 생각했다가 큰코다쳤었다. 물론 완성된 형태의 사이트가 이미 있기 때문에 내가 만드는 사이트의 완성본이 어떻게 되어야 할지는 너무 확실했다. 그런데 문제는 순서와 구조였다. 사이트 구조가 그려지지 않은 상태에서 시작하려고 하니 무엇부터 해야 할지도 막막했고 뭐 하나 기능을 붙일 때마다 너무 많은 생각을 해야 했다. 이 기능은 어떤 페이지랑 연결되어야 하지? 이 페이지에서 이 컴포넌트를 동작시켰을 때 어떤 점이 변해야 하지? 페이지끼리는 어떻게 연결되어야 하고 DB와는 어떻게 상호작용해야 하지? 이런 부분들을 계속 생각해야 했기에 겨우 하나를 개발하는 데에도 너무 많은 정신력이 들었다.</p>\n<p>그래서 이번에는, 어차피 팀원들도 사이트 구조를 머리에 넣어야 하니까-라고 생각하며 사이트 구조부터 짜 보았다. 찾아보니 xmind라는, 사이트 구조를 그릴 수 있는 툴이 있기에 그것을 이용했다. 그리고 팀원들의 피드백을 받아서 완성한 사이트 구조는 다음과 같았다. 하루만에 짠 거라 엉성하긴 하다. 실제로 개발하다 보면 훨씬 더 많은 연결과, 이때는 생각하지 못했던 기능들이 생길 가능성이 높다는 것은 알고 있었다. 하지만 우리는 방학 중에 프로젝트를 어느 정도 궤도에 올려 놓아야 했고(배포까진 아니더라도), 모든 것이 급했다. 그래서 적당히 생각나는 것만 협의한 다음 바로 코딩에 뛰어들기로 했다.</p>\n<p><img src=\"/static/mindmap-cd900ab9.png\" alt=\"page\"></p>\n<h1>3. 프로젝트 폴더 구조 만들기</h1>\n<p>클라이언트 폴더와 서버 폴더를 따로 두기로 했다. 클라이언트는 create-react-app으로 만들고 서버는 그냥 Express만 써서 만들기로 했다. nestjs 등 여러가지 툴이 있는 건 알고 있었지만 일단은 그런 툴은 아직 쓰지 않기로 협의했다. 나중에 협의 후에 쓸 수도 있긴 하다. 일단 book-community 폴더를 두고 그 안에 client, server 폴더를 만들었다.</p>\n<p><code>npx create-react-app client</code>로 client 폴더를 생성했다. 서버 폴더는 server 폴더를 생성 후 <code>npm init</code> 으로 환경을 만들고 <code>package.json</code> 을 생성해 준다.</p>\n<p>서버 폴더에서는 추가적으로 express를 설치해 준다.</p>\n<p><code>npm install express --save</code> 를 터미널에 입력해서 Express를 설치하고 기본적인 코드만 작성해 두자. 공식 문서를 따라했다.</p>\n<p>그전에 나는 nodejs에서 import/export 사용을 위해 <code>package.json</code> 에서 <code>type : \"module\"</code> 을 추가해 주었다. 그 다음 server/index.js를 다음과 같이 작성해준다.</p>\n<pre><code class=\"language-js\">import express from 'express';\n\nconst app=express();\nconst port=8000;\n\napp.get('/', (req, res)=>{\n  res.send('hello world');\n})\n\napp.listen(port, ()=>{\n  console.log(`Example app listening on port ${port}`);\n})\n</code></pre>\n<h1>4. eslint 설정</h1>\n<p>eslint를 설정해서 팀원들 간에 코드 스타일을 어느 정도 맞추기로 했다. 이때 5. 참고 부분에 써 있는 eslint/prettier 설정, 그리고 webstorm에 적용하는 방법을 설명한 블로그 글들을 많이 참고했다. 그런데 서버에 eslint를 적용할 때 문제가 있었다. 그래서 이를 해결하기 위해 eslint를 .cjs파일로 해 주어서 eslintrc 파일만은 commonJS 문법이 적용되도록 했다. 이는 아까 type : \"module\"을 설정해 주었기 때문인데 이에 대해서는 참고자료에 링크를 걸어 두었다.</p>\n<p>그리고 webstorm에서 lint를 사용할 수 있게 설정하는 방법도 참고자료에 걸어 두었다. 그런데 클라이언트와 서버에 다른 eslint를 적용하는 건 webstorm에서는 아직 안되는 듯 하다..</p>\n<h1>5. 참고</h1>\n<p>express 공식 문서 <a href=\"https://expressjs.com/ko/starter/hello-world.html\">https://expressjs.com/ko/starter/hello-world.html</a></p>\n<p>nodejs에서 import 사용하기 <a href=\"https://velog.io/@ohzzi/Node.js-%EC%97%90%EC%84%9C-importexport-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\">https://velog.io/@ohzzi/Node.js-%EC%97%90%EC%84%9C-importexport-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0</a></p>\n<p>eslint + prettier 에어비앤비 스타일로 설정하기 <a href=\"https://velog.io/@_jouz_ryul/ESLint-Prettier-Airbnb-Style-Guide%EB%A1%9C-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0\">https://velog.io/@_jouz_ryul/ESLint-Prettier-Airbnb-Style-Guide%EB%A1%9C-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0</a></p>\n<p>webstorm에 eslint 적용하기 <a href=\"https://modipi.tistory.com/10\">https://modipi.tistory.com/10</a>, <a href=\"https://valuefactory.tistory.com/828\">https://valuefactory.tistory.com/828</a></p>\n<p>cjs와 esm <a href=\"https://yceffort.kr/2020/08/commonjs-esmodules\">https://yceffort.kr/2020/08/commonjs-esmodules</a></p>",
    "excerpt": "1. 책 커뮤니티 만들기 시작\n스터디에서 3명 팀을 꾸려 React, Express, MySQL을 이용한 프로젝트를 하기로 했다. 스터디원 한 분(https://github.com/hamuneulbo) 의 제안으로, 책을 기반으로 하는 커뮤니티 사이트를 제작하기로 하였다. 그래서 블로그에 개발기록을 간단히 기록해 놓기로 했다. 블로그에 내가 하는 작업(이라고 하기에는 공부에 더 가깝지만)들을 정리해 놓는 것이 도움이 될 거라는 조언도 많이 들었기에...\n2. 사",
    "headingTree": [
      {
        "title": "1. 책 커뮤니티 만들기 시작",
        "url": "#1-책-커뮤니티-만들기-시작",
        "items": []
      },
      {
        "title": "2. 사이트 구조 짜기",
        "url": "#2-사이트-구조-짜기",
        "items": []
      },
      {
        "title": "3. 프로젝트 폴더 구조 만들기",
        "url": "#3-프로젝트-폴더-구조-만들기",
        "items": []
      },
      {
        "title": "4. eslint 설정",
        "url": "#4-eslint-설정",
        "items": []
      },
      {
        "title": "5. 참고",
        "url": "#5-참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 159
    },
    "url": "/posts/book-community-1",
    "thumbnail": {
      "local": "/static/mindmap-cd900ab9.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-mindmap-cd900ab9-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAIAAABLbSncAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAw0lEQVR4nGP4DwOfv3yp7+2au3BhRmX5tRs3GP7////t27efP36+ePXKKzZm1dq17mFh7T3dIAmI3KPHjz9/+XL79u2169Y9evwYJLFq08a127b+//+/b/ZMMWXFY0eOfP7yBSQRl54Wk5ry9u3bz1++7NixY+3atSAJITGl5KS03t7effv3i+nrhSYmvHzx4tu3bwwCIoqpaZlLli7ZvXcPg6xMx5RJ//////P3L8io+fPnd/f0nD1/PqemsqS5EeIWACg6iNEtWiefAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "blog-theme-changer",
    "title": "블로그 테마 변경 버튼 리뉴얼하기",
    "date": "2023-09-19T04:00:00Z",
    "description": "블로그의 테마 변경 버튼을 다시 만들어보자",
    "tags": [
      "blog"
    ],
    "html": "<p><a href=\"https://www.youtube.com/watch?v=RTAJ-enfums\">next-themes를 nextjs 13에서 사용하는 방법을 설명하는 유튜브 영상</a>과 <a href=\"https://github.com/pacocoursey/next-themes\">next-themes 문서</a> 그리고 <a href=\"https://web.dev/building-a-theme-switch-component/\">web.dev의 접근성 좋은 Theme switch 컴포넌트 만들기 글</a>을 참고하였다.</p>\n<h1>1. 기초 작업</h1>\n<h2>1.1. Providers 컴포넌트</h2>\n<p>현재 블로그에서는 <code>next-themes</code>를 사용해서 테마를 관리하고 있다. 하지만 nextjs13으로 넘어오면서 Context API 때문에 코드를 약간 변경해 줘야 한다. 이를 먼저 해보자.</p>\n<p><code>next-themes</code>에서는 Context API를 사용한다. 하지만 nextjs 13의 기본 컴포넌트 형식인 서버 컴포넌트에서는 이를 사용할 수 없다. 따라서 클라이언트에서 관리되는 컴포넌트로 변경해 주어야 한다.</p>\n<p><code>src/app/Provider.tsx</code>를 만들고 다음과 같이 내용을 작성한다. 이후에 만들 테마들까지 함께 작성해 주었다. 여기서 최대로 중요한 점은 <code>use client</code>를 적용하는 것이다.</p>\n<pre><code class=\"language-tsx\">'use client';\n\nimport { ThemeProvider } from 'next-themes';\n\nexport function Providers({ children }: { children: React.ReactNode }) {\n  return (\n    &#x3C;ThemeProvider\n      defaultTheme='system'\n      enableSystem={true}\n      value={{ dark: 'dark', light: 'light', pink: 'pink', darkPink: 'darkPink' }}\n      themes={['dark', 'light', 'pink', 'darkPink']}\n    >\n      {children}\n    &#x3C;/ThemeProvider>\n  );\n};\n</code></pre>\n<p>다른 Provider 속성이 필요할 경우 이 컴포넌트에 추가적으로 작성해 줘도 좋다.</p>\n<p>그리고 이를 <code>src/app/layout.tsx</code> 즉 root layout에 적용해 주자.</p>\n<pre><code class=\"language-tsx\">export default async function RootLayout({\n  // Layouts must accept a children prop.\n  // This will be populated with nested layouts or pages\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    &#x3C;html lang='en' suppressHydrationWarning>\n      &#x3C;body>\n        &#x3C;Providers>\n          &#x3C;Header navList={blogCategoryList} />\n          {children}\n          &#x3C;Footer />\n          &#x3C;GoogleAnalytics />\n        &#x3C;/Providers> \n      &#x3C;/body>\n    &#x3C;/html>\n  );\n}\n</code></pre>\n<h2>1.2. 색상 정의하기</h2>\n<p><code>src/styles/theme.css</code>에 테마 색상들을 적용하자. 블로그에 쓰이는 용도를 기반으로 색상 변수들의 이름을 정의하였다. <code>[data-theme:\"dark\"]</code> 셀렉터를 이용해서 다크모드의 변수들을 정의해 줄 수 있었다.</p>\n<pre><code class=\"language-css\">:root {\n  --white:#fff;\n  --black:#000;\n\n  --bgColor: #ffffff;\n  --textColor: #28292D;\n\n  --contentBgColor: #f1f3f5;\n  --contentBgHover: #e9ecef;\n  --headerBorderColor: #dee2e6;\n  --borderColor: #adb5bd;\n  --shadowColor:#868e96;\n  --infoTextColor:#495057;\n\n  --codeBlockBgColor:#edf2ff;\n  --codeBlockTextColor:#364fc7;\n  --accentBgColor:#dbe4ff;\n  --accentBgHover:#bac8ff;\n  --accentTextColor:#3b5bdb;\n  --lightAccentTextColor:#4c6ef5;\n  --linkColor:#4263eb;\n}\n\n[data-theme='dark'] {\n  --bgColor: #212529;\n  --textColor: #ececec;\n\n  --contentBgColor: #343a40;\n  --contentBgHover: #343a40;\n  --headerBorderColor:#495057;\n  --borderColor: #868e96;\n  --shadowColor:#868e96;\n  --infoTextColor:#ced4da;\n\n  --codeBlockBgColor:#343a40;\n  --codeBlockTextColor:#edf2ff;\n  --accentBgColor:#002395;\n  --accentBgHover:#2b4aaf;\n  --accentTextColor:#edf2ff;\n  --lightAccentTextColor:#748ffc;\n  --linkColor:#91a7ff;\n}\n</code></pre>\n<p>그럼 테마를 사용할 수 있게 되었으니 테마를 사용하기 위한 버튼을 만들어보자.</p>\n<p>마침 <a href=\"https://web.dev/building-a-theme-switch-component/\">web.dev의 테마 스위치 컴포넌트 만들기 글</a>이 있어서 이를 거의 따라하였다. 더 자세한 설명은 해당 글을 참고하자.</p>\n<h1>2. 버튼 구조 잡기</h1>\n<h2>2.1. 마크업</h2>\n<p>테마 변경을 하는 컴포넌트는 의미상 <code>&#x3C;button></code>이 적절하다. 접근성을 고려하여 <code>aria-label</code>과 <code>aria-live</code>를 추가하고, <code>title</code>은 툴팁을 위해 추가한다.</p>\n<pre><code class=\"language-tsx\">function ThemeSwitch() {\n  return (\n    &#x3C;button \n      className={styles.toggle} \n      title='Toggle Light &#x26; Dark' \n      aria-label='auto'\n      aria-live='polite'\n    >\n      토글\n    &#x3C;/button>\n  );\n}\n</code></pre>\n<h2>2.2. 아이콘 만들기</h2>\n<p>아이콘을 위해서는 svg 컴포넌트를 사용할 것이다. 이런 식으로 만들고자 한다.</p>\n<p><img src=\"/static/theme-sketch-29f85118.png\" alt=\"theme-sketch\"></p>\n<p>이를 위해서 지금 작업중인 <code>components/molecules/themeSwitch</code>폴더에서 <code>icon.tsx</code>를 만들고 <code>SunAndMoonIcon</code>컴포넌트를 만들자.</p>\n<p>위와 같이 하려면 먼저 중앙에 원을 만들고 주변에 햇살을 표시하는 선들을 그린다. 선들은 그룹핑을 위한 <code>&#x3C;g></code>로 묶는다. 그리고 다크 모드의 달 모양을 만들기 위해 원의 일부를 가리는 것은 <code>&#x3C;mask></code>로 처리한다. 이렇게 만든  <code>SunAndMoonIcon</code>컴포넌트는 다음과 같이 생겼다.</p>\n<p><code>&#x3C;svg></code>에 <code>aria-hidden</code>속성이 적용되어 있는데 이는 스크린 리더가 이를 무시하게 한다. 아이콘은 그냥 시각적인 장식이니까 그렇다. 그리고 <code>&#x3C;g></code>의 <code>stroke</code>속성은 선 색깔이다.</p>\n<pre><code class=\"language-tsx\">import styles from './theme.module.css';\n\nfunction SunAndMoonIcon() {\n  return (\n    &#x3C;svg className={styles.sunAndMoon} aria-hidden='true' width='24' height='24' viewBox='0 0 24 24'>\n      &#x3C;circle className={styles.sun} cx='12' cy='12' r='6' mask='url(#moonMask)' fill='currentColor'/>\n      &#x3C;g className={styles.sunBeams} stroke='currentColor'>\n        &#x3C;line x1='12' y1='1' x2='12' y2='3' />\n        &#x3C;line x1='12' y1='21' x2='12' y2='23' />\n        &#x3C;line x1='4.22' y1='4.22' x2='5.64' y2='5.64' />\n        &#x3C;line x1='18.36' y1='18.36' x2='19.78' y2='19.78' />\n        &#x3C;line x1='1' y1='12' x2='3' y2='12' />\n        &#x3C;line x1='21' y1='12' x2='23' y2='12' />\n        &#x3C;line x1='4.22' y1='19.78' x2='5.64' y2='18.36' />\n        &#x3C;line x1='18.36' y1='5.64' x2='19.78' y2='4.22' />\n      &#x3C;/g>\n      &#x3C;mask className={styles.moon} id='moonMask'>\n        &#x3C;rect x='0' y='0' width='100%' height='100%' fill='white' />\n        &#x3C;circle cx='24' cy='10' r='6' fill='black' />\n      &#x3C;/mask>\n    &#x3C;/svg>\n  );\n}\n</code></pre>\n<h2>2.3. 간단한 동작</h2>\n<p>이를 시험하기 위해 버튼을 클릭하면 테마가 바뀌는 동작을 넣어보자.</p>\n<p><code>ThemeSwitch</code>컴포넌트를 다음과 같이 수정한다. 이러면 버튼을 클릭할 시 테마가 바뀌는 것을 볼 수 있다(아이콘은 아직 바뀌지 않는다).</p>\n<pre><code class=\"language-tsx\">'use client';\n\nimport { useTheme } from 'next-themes';\n\nimport { getThemeName } from '@/utils/theme';\n\nimport SunAndMoonIcon from './icon';\nimport styles from './theme.module.css';\n\nfunction ThemeSwitch() {\n  const { theme, setTheme } = useTheme();\n\n  const isDark = getThemeName(theme) === 'dark';\n  const toggleTheme = () => setTheme(isDark ? 'light' : 'dark');\n\n  return (\n    &#x3C;button \n      className={styles.themeToggle} \n      title='Toggle Light &#x26; Dark'\n      aria-label='auto'\n      aria-live='polite'\n      onClick={toggleTheme}\n    >\n      &#x3C;SunAndMoonIcon />\n    &#x3C;/button>\n  );\n}\n\nexport default ThemeSwitch;\n</code></pre>\n<p>참고로 <code>getThemeName</code>은 그냥 테마 이름을 반환하는 간단한 함수이다.</p>\n<pre><code class=\"language-ts\">export type ThemeType = 'light' | 'dark';\n\nexport const getThemeName = (theme: string | undefined): ThemeType => {\n  if (theme === 'dark' || theme === 'light') {\n    return theme;\n  }\n  return 'light';\n};\n</code></pre>\n<h2>2.4. CSS</h2>\n<p>해당 가이드를 따라서 아이콘의 CSS를 조작해보자. <code>theme.module.css</code>를 수정하면 된다.</p>\n<p>먼저 버튼의 클래스인 <code>.themeToggle</code>을 설정하자. 버튼의 기본 스타일을 없애고 적절히 디자인한다. 또한 <code>outline-offset</code>을 통해 어느 정도의 간격을 준다.</p>\n<p>이때 터치스크린을 사용하는 유저에게는 사이즈 <code>2rem</code>이 충분하지 못할 수 있기 때문에 <code>@media (hover: none)</code>을 통해 터치스크린에서는 사이즈를 더 크게 만들어 준다.</p>\n<p>또 색을 위한 변수를 설정하는데 <code>reset.css</code>에서 정의해 둔 CSS 변수를 사용한다. <code>reset.css</code>의 색상 변수는 현재 테마에 따라 자동으로 색상이 바뀌도록 되어 있으므로 이렇게 하면 테마에 따라 아이콘의 색을 따로 설정해 줄 필요가 없어진다.</p>\n<pre><code class=\"language-css\">.themeToggle{\n  --size: 2rem;\n  --icon-fill: var(--infoTextColor);\n  --icon-fill-hover: var(--textColor);\n\n  background: none;\n  border: none;\n  padding: 0;\n\n  inline-size: var(--size);\n  block-size: var(--size);\n  aspect-ratio: 1;\n  border-radius: 50%;\n\n  cursor: pointer;\n  /* 더 빠른 터치 반응 경험을 제공하도록 해준다 */\n  touch-action: manipulation;\n  -webkit-tap-highlight-color: transparent;\n  outline-offset: 5px;\n}\n\n@media (hover: none){\n  .themeToggle{\n    --size: 48px;\n  }\n}\n</code></pre>\n<p>버튼 내부의 svg 컴포넌트의 크기를 조정하고 <code>stroke-linecap</code>으로 선의 양쪽 끝 모양을 둥글게 만들어준다.</p>\n<pre><code class=\"language-css\">.themeToggle > svg{\n  inline-size: 100%;\n  block-size: 100%;\n  stroke-linecap: round;\n}\n</code></pre>\n<p>그리고 다음과 같이 색상과 선 굵기처럼 자잘한 부분들을 설정하고 애니메이션을 위한 <code>transform</code>속성들을 설정한다.</p>\n<pre><code class=\"language-css\">/* 애니메이션 동작의 중심 설정 */\n.sunAndMoon > :is(.moon, .sun, .sunBeams){\n  transform-origin: center center;\n}\n\n.sunAndMoon > :is(.moon, .sun){\n  fill: var(--icon-fill);\n}\n\n.themeToggle:is(:hover, :focus-visible) > .sunAndMoon > :is(.moon, .sun){\n  fill: var(--icon-fill-hover);\n}\n\n.sunAndMoon > .sunBeams{\n  stroke: var(--icon-fill);\n  stroke-width: 2px;\n}\n\n.themeToggle:is(:hover, :focus-visible) .sunAndMoon > .sunBeams{\n  stroke: var(--icon-fill-hover);\n}\n\n/* 다크 모드 스타일링 */\n[data-theme=\"dark\"] .sunAndMoon > .sun{\n  transform: scale(1.75);\n}\n\n[data-theme=\"dark\"] .sunAndMoon > .sunBeams{\n  opacity: 0;\n}\n\n[data-theme=\"dark\"] .sunAndMoon > .moon > circle{\n  transform: translateX(-7px);\n}\n\n@supports (cx: 1){\n  [data-theme=\"dark\"] .sunAndMoon > .moon > circle{\n    transform: translateX(0);\n    cx:17;\n  }\n}\n</code></pre>\n<p>이렇게 하면 버튼 클릭 시 테마는 물론 아이콘까지 변경되게 된다.</p>\n<h2>2.5. 애니메이션</h2>\n<p>자연스러운 아이콘 전환을 위한 애니메이션도 삽입해 보자. 그런데 애니메이션은 저사양 기기에 큰 부하를 걸 수 있고 시각적인 피로 등으로 인해 애니메이션을 보고 싶어하지 않는 설정을 한 사용자도 있을 수 있다.</p>\n<p>이런 이유로 애니메이션에는 <code>prefers-reduced-motion</code>미디어 쿼리를 사용한다. 해당 쿼리에 관해서는 <a href=\"https://mong-blog.tistory.com/entry/CSS-%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98-%EB%8F%99%EC%9E%91%EC%9D%84-%EC%BB%A8%ED%8A%B8%EB%A1%A4%ED%95%98%EB%8A%94-prefers-reduced-motion\">애니메이션 동작을 컨트롤하는, prefers-reduced-motion</a>글을 참고하자.</p>\n<p>이런 이유로 애니메이션은 <code>prefers-reduced-motion: no-preference</code> 미디어 쿼리 내부에 존재하도록 한다. 애니메이션 진행은 <a href=\"https://developer.chrome.com/docs/devtools/css/animations/\">크롬 개발자 도구의 애니메이션 패널</a>에서 볼 수도 있다. 진행 그래프까지도 보여준다.</p>\n<p>어쨌건 postCSS로 작성되어 있는 원 글의 CSS를 풀어서 작성해 보면 다음과 같이 나온다. <code>@nest</code>대용으로 <code>:has</code>를 쓸 수도 있겠지만 아직은 지원되지 않는 브라우저가 꽤 있기 때문에 쓰지 않았다.</p>\n<pre><code class=\"language-css\">/* 애니메이션 동작의 중심 설정 */\n.sunAndMoon > :is(.moon, .sun, .sunBeams){\n  transform-origin: center center;\n}\n\n.sunAndMoon > :is(.moon, .sun){\n  fill: var(--icon-fill);\n}\n\n.themeToggle:is(:hover, :focus-visible) > .sunAndMoon > :is(.moon, .sun){\n  fill: var(--icon-fill-hover);\n}\n\n.sunAndMoon > .sunBeams{\n  stroke: var(--icon-fill);\n  stroke-width: 2px;\n}\n\n.themeToggle:is(:hover, :focus-visible) .sunAndMoon > .sunBeams{\n  stroke: var(--icon-fill-hover);\n}\n\n/* 다크 모드 스타일링 */\n[data-theme=\"dark\"] .sunAndMoon > .sun{\n  transform: scale(1.75);\n}\n\n[data-theme=\"dark\"] .sunAndMoon > .sunBeams{\n  opacity: 0;\n}\n\n[data-theme=\"dark\"] .sunAndMoon > .moon > circle{\n  transform: translateX(-7px);\n}\n\n@supports (cx: 1){\n  [data-theme=\"dark\"] .sunAndMoon > .moon > circle{\n    transform: translateX(0);\n    cx:17;\n  }\n}\n\n@media (prefers-reduced-motion: no-preference){\n  .sunAndMoon > .sun{\n    transition: transform .5s var(--ease-elastic-3);\n  }\n\n  .sunAndMoon > .sunBeams{\n    transition: \n        transform .5s var(--ease-elastic-4),\n        opacity .5s var(--ease-3)\n      ;\n  }\n\n  /* 달 아이콘을 위한 애니메이션 */\n  .sunAndMoon .moon > circle{\n    transition: transform .25s var(--ease-out-5);\n  }\n\n  @supports (cx: 1){\n    .sunAndMoon .moon > circle{\n      transition: cx .25s var(--ease-out-5);\n    }\n  }\n\n  [data-theme='dark'] .sunAndMoon > .sun{\n    transform:scale(1.75);\n    transition-timing-function: var(--ease-3);\n    transition-duration: .25s;\n  }\n\n  /* 애니메이션의 역동성을 위해 해로 전환될 때 약간의 회전을 부여한다 */\n  [data-theme='dark'] .sunAndMoon > .sunBeams{\n    transform: rotateZ(-25deg);\n    transition-duration: .15s;\n  }\n\n  [data-theme='dark'] .sunAndMoon > .moon > circle{\n    transition-delay: .25s;\n    transition-duration: .5s;\n  }\n}\n</code></pre>\n<p>버튼 클릭 시 자연스럽게 아이콘이 전환되는 애니메이션까지 보이게 되었다.</p>\n<h1>3. 새로운 테마 만들기</h1>\n<h2>3.1. 테마 색상 만들기</h2>\n<p>나는 vscode에서 <a href=\"https://marketplace.visualstudio.com/items?itemName=mgwg.light-pink-theme\">Light Pink Theme</a>을 사용하고 있고 이 테마를 매우 좋아한다. 따라서 라이트 테마와 다크 테마에 더해 핑크 테마도 만들어 주도록 하자. 앞서 <code>Provider</code>컴포넌트를 만들 때 pink, darkPink 테마에 대한 부분도 미리 만들어 놓았다.</p>\n<p>위에서 보았던 <code>ThemeProvider</code>의 <code>value</code>와 <code>themes</code> props를 보면 알 수 있다.</p>\n<pre><code class=\"language-tsx\">export function Providers({ children }: { children: React.ReactNode }) {\n  return (\n    &#x3C;ThemeProvider\n      defaultTheme='system'\n      enableSystem={true}\n      value={{ dark: 'dark', light: 'light', pink: 'pink', darkPink: 'darkPink' }}\n      themes={['dark', 'light', 'pink', 'darkPink']}\n    >\n      {children}\n    &#x3C;/ThemeProvider>\n  );\n};\n</code></pre>\n<p>이미 거의 모든 요소들의 색상을 CSS 변수명 기반으로 작성해 놓았으므로 테마들의 색을 <code>src/styles/theme.css</code>에 작성해 놓으면 자동으로 적용된다.</p>\n<p>해당 색상들은 그냥 pink 테마의 경우 <a href=\"https://marketplace.visualstudio.com/items?itemName=mgwg.light-pink-theme\">vscode의 Light Pink Theme</a>와 <a href=\"https://yeun.github.io/open-color/\">open color</a>를 참고하였다.</p>\n<p>또한 darkPink 테마의 경우 <a href=\"https://www.color-hex.com/color-palette/95814\">kuromi Color Palette</a>와 <a href=\"https://www.color-hex.com/color-palette/1022257\">Kuromi colours Color Palette</a>에서 몇 가지의 색상을 따왔고, 해당 컬러 팔레트에서 분홍과 보라 계통이 생각보다 잘 어울린다는 것을 보아 역시 <a href=\"https://yeun.github.io/open-color/\">open color</a>에서도 몇 가지 색을 가져왔다.</p>\n<p>그렇게 정의한 색상 변수들은 다음과 같다.</p>\n<pre><code class=\"language-css\">[data-theme='pink'] {\n  --bgColor: #f5f0f3;\n  --textColor: #632c3b;\n\n  --contentBgColor: #f5e3ef;\n  --contentBgHover:#f5e3ef;\n  --headerBorderColor:#ffdeeb;\n  --borderColor: #af4670;\n  --shadowColor:#868e96;\n  --infoTextColor:#d6336c;\n  \n  --codeBlockBgColor:#ffdeeb;\n  --codeBlockTextColor:#a61e4d;\n  --accentBgColor:#ffdeeb;\n  --accentBgHover:#fcc2d7;\n  --accentTextColor:#c2255c;\n  --lightAccentTextColor:#f06595;\n  --linkColor:#d6336c;\n}\n\n[data-theme='darkPink'] {\n  --bgColor: #252526;\n  --textColor: #f695c6;\n\n  --contentBgColor: #343a40;\n  --contentBgHover: #343a40;\n  --headerBorderColor:#565656;\n\n  --borderColor: #FFD6CD;\n  --shadowColor:#868e96;\n  --infoTextColor:#c097cf;\n\n  --codeBlockBgColor:#845ef7;\n  --codeBlockTextColor:#f3f0ff;\n  --accentBgColor:#845ef7;\n  --accentBgHover:#5f3dc4;\n  --accentTextColor:#e5dbff;\n  --lightAccentTextColor:#9775fa;\n  --linkColor:#b197fc;\n}\n</code></pre>\n<h2>3.2. 새로운 테마 전환 동작 설계</h2>\n<p>지금 적용할 수 있는 테마는 light, dark의 2종류이다. 그런데 여기 pink와 darkPink를 적용하기 위한 버튼을 하나 더 만들 것이다. 그 동작은 다음과 같이 생각할 수 있다.</p>\n<p>현재 있는 해/달 버튼의 경우 현재 상태를 나타내며 누를 시 다른 테마로 이동한다. light 상태이면 dark로, dark 상태이면 light로 간다. 즉 다음과 같이 동작하게 될 것이다.</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>현재 테마</th><th>해/달 버튼 클릭시</th></tr></thead><tbody><tr><td>light</td><td>dark</td></tr><tr><td>dark</td><td>light</td></tr></tbody></table>\n<p>그러면 핑크 테마 전환 버튼은 어떻게 동작해야 할까? 핑크 테마의 존재가 그렇게 익숙하지 않은 것을 생각했을 때 현재 테마에 기반한 테마로 전환해 주는 것이 적절하다고 본다. 따라서 다음과 같은 동작을 생각해볼 수 있다.</p>\n<p>또한 핑크 테마에 있는 상태에서 핑크 토글 버튼을 또 누르면 pink &#x3C;-> darkPink 테마의 전환이 이루어지는 게 적절할 것 같다. 여기까지를 표로 나타내면 다음과 같다.</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>현재 테마</th><th>해/달 버튼 클릭</th><th>핑크 버튼 클릭</th></tr></thead><tbody><tr><td>light</td><td>dark</td><td>pink</td></tr><tr><td>dark</td><td>light</td><td>darkPink</td></tr><tr><td>pink</td><td>?</td><td>darkPink</td></tr><tr><td>darkPink</td><td>?</td><td>pink</td></tr></tbody></table>\n<p>그런데 핑크 테마에서 해/달 버튼을 다시 누르면 무슨 일이 일어나야 하는가? light/dark 테마에서 핑크 버튼을 클릭했을 때 일어났던 일을 생각해볼 때 반대의 경우도 기대할 수 있을 거라고 생각했다. light pink 테마에서 해 버튼을 눌렀는데 갑자기 dark 테마로 가는 것을 기대하지는 않을 거라고 보았다. 따라서 다음과 같이 테마 토글 버튼들이 동작하도록 설계해 보았다.</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>현재 테마</th><th>해/달 버튼 클릭</th><th>핑크 버튼 클릭</th></tr></thead><tbody><tr><td>light</td><td>dark</td><td>pink</td></tr><tr><td>dark</td><td>light</td><td>darkPink</td></tr><tr><td>pink</td><td>light</td><td>darkPink</td></tr><tr><td>darkPink</td><td>dark</td><td>pink</td></tr></tbody></table>\n<h2>3.3. 기존 버튼을 컴포넌트로 분리</h2>\n<p>슬슬 버튼들을 그냥 컴포넌트로 분리해 주는 게 나을 것 같다. 따라서 <code>themeSwitch</code>폴더 내에 <code>lightDarkToggle</code>과 <code>pinkToggle</code> 폴더를 만들고 각각에 <code>index.tsx</code>와 <code>styles.module.css</code>를 만들어준다. <code>LightDarkToggle</code>컴포넌트는 다음과 같이 만들어진다.</p>\n<p>그리고 <code>lightDarkToggle/styles.module.css</code>에는 위에서 정의한 CSS 중 해/달 버튼에 해당되는 부분을 복사해서 넣어주자.</p>\n<pre><code class=\"language-tsx\">// src/components/molecules/themeSwitch/lightDarkToggle/index.tsx\nimport styles from './styles.module.css';\n\nfunction LightDarkToggle({ toggleClick }: {toggleClick: () => void}) {\n  {/* aria-hidden은 스크린 리더가 이를 무시하게 한다. 아이콘은 그냥 시각적인 장식이니까\n  그리고 stroke는 선 색깔이다 */}\n  return (\n    &#x3C;button \n      className={styles.themeToggle} \n      title='Toggle Light &#x26; Dark' \n      aria-label='auto'\n      aria-live='polite'\n      onClick={toggleClick}\n    >\n      &#x3C;svg className={styles.sunAndMoon} aria-hidden='true' width='24' height='24' viewBox='0 0 24 24'>\n        &#x3C;circle className={styles.sun} cx='12' cy='12' r='6' mask='url(#moonMask)' fill='currentColor'/>\n        &#x3C;g className={styles.sunBeams} stroke='currentColor'>\n          &#x3C;line x1='12' y1='1' x2='12' y2='3' />\n          &#x3C;line x1='12' y1='21' x2='12' y2='23' />\n          &#x3C;line x1='4.22' y1='4.22' x2='5.64' y2='5.64' />\n          &#x3C;line x1='18.36' y1='18.36' x2='19.78' y2='19.78' />\n          &#x3C;line x1='1' y1='12' x2='3' y2='12' />\n          &#x3C;line x1='21' y1='12' x2='23' y2='12' />\n          &#x3C;line x1='4.22' y1='19.78' x2='5.64' y2='18.36' />\n          &#x3C;line x1='18.36' y1='5.64' x2='19.78' y2='4.22' />\n        &#x3C;/g>\n        &#x3C;mask className={styles.moon} id='moonMask'>\n          &#x3C;rect x='0' y='0' width='100%' height='100%' fill='white' />\n          &#x3C;circle cx='24' cy='10' r='6' fill='black' />\n        &#x3C;/mask>\n      &#x3C;/svg>\n    &#x3C;/button>\n\n  );\n}\n\nexport default LightDarkToggle;\n</code></pre>\n<h2>3.4. 핑크 버튼 마크업</h2>\n<p>핑크 버튼도 다음과 같이 만들어줄 수 있다. 위에서와 비슷하게 마크업을 잡고 적당한 svg 아이콘을 넣어주면 된다. 나는 light/dark 토글 버튼이 해/달로 된 것에 착안해서 <a href=\"https://www.svgrepo.com/svg/529943/star-fall-minimalistic\">별 svg 아이콘</a>을 찾아서 넣어주었다.</p>\n<pre><code class=\"language-tsx\">import styles from './styles.module.css';\n\nfunction PinkToggle({ toggleClick }: {toggleClick: () => void}) {\n  return (\n    &#x3C;button\n      className={styles.pinkThemeToggle} \n      title='Toggle Pink &#x26; Dark Pink' \n      aria-label='auto'\n      aria-live='polite'\n      onClick={toggleClick}\n    >\n      &#x3C;svg aria-hidden='true' width='30' height='30' viewBox='0 0 24 24' className={styles.star} fill='none'>\n        &#x3C;g className={styles.starBody} stroke='currentColor'>\n          &#x3C;path d='M8.32181 14.4933C7.3798 15.9862 6.90879 16.7327 7.22969 17.3433C7.55059 17.9538 8.45088 18.0241 10.2514 18.1647L10.7173 18.201C11.2289 18.241 11.4848 18.261 11.7084 18.3785C11.9321 18.4961 12.0983 18.6979 12.4306 19.1015L12.7331 19.469C13.9026 20.8895 14.4873 21.5997 15.1543 21.5084C15.8213 21.417 16.1289 20.5846 16.7439 18.9198L16.9031 18.4891C17.0778 18.0161 17.1652 17.7795 17.3369 17.6078C17.5086 17.4362 17.7451 17.3488 18.2182 17.174L18.6489 17.0149C20.3137 16.3998 21.1461 16.0923 21.2374 15.4253C21.3288 14.7583 20.6185 14.1735 19.1981 13.0041M17.8938 10.5224C17.7532 8.72179 17.6829 7.8215 17.0723 7.5006C16.4618 7.1797 15.7153 7.65071 14.2224 8.59272L13.8361 8.83643C13.4119 9.10412 13.1998 9.23797 12.9554 9.27143C12.7111 9.30488 12.4622 9.23416 11.9644 9.09271L11.5113 8.96394C9.75959 8.46619 8.88375 8.21732 8.41508 8.68599C7.94641 9.15467 8.19528 10.0305 8.69303 11.7822' />\n          &#x3C;path d='M13.5 6.5L13 6M9.5 2.5L11.5 4.5' />\n          &#x3C;path d='M6.5 6.5L4 4'/>\n          &#x3C;path d='M6 12L4.5 10.5M2 8L2.5 8.5' />\n        &#x3C;/g>\n      &#x3C;/svg>\n    &#x3C;/button>\n  );\n}\n\nexport default PinkToggle;\n</code></pre>\n<h2>3.5. 테마 토글 버튼 동작</h2>\n<p>핑크 테마 버튼을 스타일링하기 전에 먼저 위에서 설계했던 동작을 구현하자. <code>themeSwitch/index.tsx</code>에서 적당한 <code>toggleClick</code>함수들을 정의해 주고 위에서 만든 컴포넌트들에 props로 넘겨주면 된다. <code>isDarkOrPink</code>변수를 만들어서 조정했다.</p>\n<pre><code class=\"language-tsx\">function ThemeSwitch() {\n  const { theme, setTheme } = useTheme();\n\n  const isDarkOrPink = getThemeName(theme) === 'dark' || getThemeName(theme) === 'pink';\n  const toggleTheme = () => setTheme(isDarkOrPink ? 'light' : 'dark');\n  const togglePinkTheme = () => setTheme(isDarkOrPink ? 'darkPink' : 'pink');\n\n  return (\n    &#x3C;div className={styles.container}>\n      &#x3C;LightDarkToggle toggleClick={toggleTheme} />\n      &#x3C;PinkToggle toggleClick={togglePinkTheme} />\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h2>3.6. 핑크 테마 버튼 디자인</h2>\n<p>CSS는 다음과 같이 디자인했다. <code>.pinkThemeToggle</code>은 <code>LightDarkToggle</code>을 디자인할 때와 비슷하고 적절한 색을 찾아 준 정도다. 그리고 버튼 호버 시 마치 별이 떨어지는 것과 같은 애니메이션을 주도록 했다.</p>\n<pre><code class=\"language-css\">.pinkThemeToggle{\n  --size: 36px;\n  --pink2: #fcc2d7;\n  --pink5: #f06595;\n  --pink7: #d6336c;\n\n  --darkPinkBgColor:#f695c6;\n  --darkPinkIconColor:#845ef7;\n\n  /* 테스트를 위한 모바일 화면 숨기기 임시 주석처리\n  display: none; */\n  background: var(--pink2);\n\n  border: none;\n  padding: 0;\n\n  inline-size: var(--size);\n  block-size: var(--size);\n\n  aspect-ratio: 1;\n  border-radius: 50%;\n\n  cursor: pointer;\n  /* 더 빠른 터치 반응 경험을 제공하도록 해준다 */\n  touch-action: manipulation;\n  -webkit-tap-highlight-color: transparent;\n  outline-offset: 5px;\n  \n  overflow:hidden;\n}\n\n@media (min-width: 768px){\n  .pinkThemeToggle{\n    display:block;\n  }\n}\n\n.pinkThemeToggle > .star{\n  padding-top:3px;\n  padding-left:1px;\n}\n\n.pinkThemeToggle > .star > .starBody{\n  stroke: var(--pink5);\n\n  stroke-width: 1.5px;\n  stroke-linecap: round;\n}\n\n[data-theme='dark'] .pinkThemeToggle{\n  background:var(--darkPinkBgColor);\n}\n\n[data-theme='dark'] .pinkThemeToggle > .star > .starBody{\n  stroke: var(--darkPinkIconColor);\n}\n\n[data-theme='darkPink'] .pinkThemeToggle{\n  background:var(--darkPinkBgColor);\n}\n\n[data-theme='darkPink'] .pinkThemeToggle > .star > .starBody{\n  stroke: var(--darkPinkIconColor);\n}\n\n@keyframes starFall{\n  from{\n    transform:translate(-1.5rem, -1.5rem);\n  }\n  to{\n    transform:translate(1.5rem, 1.5rem);\n  }\n}\n\n@media (prefers-reduced-motion: no-preference){\n  .pinkThemeToggle:hover > .star{\n    animation:starFall 1s ease-in-out infinite;\n  }\n}\n</code></pre>\n<p><code>[data-theme='dark']</code>와 <code>[data-theme='darkPink']</code>는 <code>:is</code> 유사 클래스를 사용하거나 좀더 오래된 방식으로는 <code>[data-theme^='dark']</code>(dark로 시작하는 data-theme 속성을 모두 선택) 선택자를 사용해서 더 짧게 둘 다 선택할 수 있다.</p>\n<h1>4. 동작 만들기</h1>\n<p>원문인 <a href=\"https://web.dev/building-a-theme-switch-component/#javascript\">building a theme switch component</a>에는 JS를 이용해서 페이지 로드 시 flickering 없이 테마가 바로 적용되도록 JS를 작성하는 부분이 있다.</p>\n<p>하지만 <code>next-themes</code>에서 이를 알아서 해주기 때문에 여기서 할 필요는 없다. 만약 필요한 사람이 이 글을 본다면, 원문 링크를 참고하자.</p>\n<h1>5. 추가 수정 작업</h1>\n<p>(2023-09-22 작성)</p>\n<h2>5.1. 테마 토글 버튼 디자인 수정</h2>\n<p>버튼에 hover하면 애니메이션이 나오는 게 괜찮은 것 같아서 애니메이션을 넣었었다. <code>LightDarkToggle</code>의 경우 호버시 약간 회전하는 효과를, <code>PinkToggle</code>의 경우 별이 떨어지는 효과를 넣었다.</p>\n<p>그런데 모바일에서는 한번 클릭시 다른 곳을 클릭할 때까지 호버 상태가 유지되기 때문에 이상해 보인다. 따라서 이를 PC에서만 보이도록 수정하자.</p>\n<p>호버가 가능하고 정확한 포인터를 쓰는 경우, 그러니까 <code>@media (hover: hover)</code> 그리고 <code>@media (pointer: fine)</code> 미디어 쿼리를 적용하면 된다. 애니메이션이 쓰인 곳에 다음과 같이 nested media query를 적용하자.</p>\n<pre><code class=\"language-css\">@media (prefers-reduced-motion: no-preference){\n  @media (hover: hover) and (pointer: fine){\n    .pinkThemeToggle:hover > .star{\n      animation:starFall 1s ease-in-out infinite;\n    }\n  }\n}\n</code></pre>\n<p><code>LightDarkToggle</code>의 CSS에도 똑같이 적용해 주면 된다.</p>\n<pre><code class=\"language-css\">@media (prefers-reduced-motion: no-preference){\n  @media (hover: hover) and (pointer: fine){\n    .sunAndMoon:hover > .sunBeams{\n      animation:rotate 1s ease-in-out infinite;\n    }\n  \n    [data-theme^='dark'] .sunAndMoon:hover :is(.sun, .moon){\n      animation:rotate-moon 1s ease-in-out infinite;\n    }\n  }\n}\n</code></pre>\n<h2>5.2. 코드 테마 수정</h2>\n<p>이 블로그는 마크다운 기반으로 글을 작성할 수 있다. 그리고 마크다운을 블로그 글에 필요한 정보들로 변환해 주는 작업은 contentlayer라는 라이브러리가 담당한다. 그러면 코드 블록은 어떻게 하이라이팅될까?</p>\n<p>이는 <a href=\"https://rehype-pretty-code.netlify.app/\">rehype-pretty-code</a>라는 라이브러리가 해주고 있다. <code>contentlayer.config.js</code>파일을 보면 이를 사용하고 있는 걸 확인도 가능하다. 이 설정파일을 좀 만지면 코드 블록의 테마를 바꿀 수 있다. 일단 핑크 테마는 light-plus 테마가 좋아보인다.</p>\n<p>일단 다음과 같이 설정해 주자. 내 <code>contentlayer.config.js</code>의 일부이다.</p>\n<pre><code class=\"language-js\">const rehypePrettyCodeOptions = {\n  theme: {\n    light: 'github-light',\n    pink: 'light-plus',\n    dark: 'github-dark',\n  },\n};\n\nexport default makeSource({\n  contentDirPath: 'posts',\n  documentTypes: [MDXPost, Post],\n  markdown: {\n    remarkPlugins: [remarkGfm, remarkMath, changeImageSrc, headingTree, makeThumbnail],\n    rehypePlugins: [[rehypePrettyCode, rehypePrettyCodeOptions], rehypeKatex, highlight],\n  },\n  mdx: {\n    remarkPlugins: [remarkGfm, remarkMath, changeImageSrc, headingTree, makeThumbnail],\n    rehypePlugins: [[rehypePrettyCode, rehypePrettyCodeOptions], rehypeKatex, highlight],\n  },\n});\n</code></pre>\n<p>darkPink 같은 경우 <a href=\"https://unpkg.com/browse/shiki@0.14.2/themes/\">shiki에서 미리 제공하는 테마들</a>을 거의 다 찾아보았지만 딱히 어울려 보이는 게 없었다. 따라서 <a href=\"https://github.com/mgwg/light-pink-theme/blob/master/themes/Dark%20Pink-color-theme.json\">light pink theme의 dark pink 테마 설정 파일</a>을 가져다 쓰기로 했다.</p>\n<p>해당 json 파일을 가져와서 적당히 포매팅하고 <code>public/themes/dark-pink-themes.json</code>에 저장해 놓았다. 그리고 <code>contentlayer.config.js</code>의 <code>rehypePrettyCodeOptions</code>에 다음과 같이 추가해 주었다. 해당 파일을 가져와서 <code>JSON.parse</code>를 해주면 된다.</p>\n<pre><code class=\"language-js\">const rehypePrettyCodeOptions = {\n  theme: {\n    light: 'github-light',\n    pink: 'light-plus',\n    dark: 'github-dark',\n    darkPink:JSON.parse(\n      readFileSync('./public/themes/dark-pink-theme.json')\n    ),\n  },\n};\n</code></pre>\n<h3>5.2.1. 테마 색상 부족 문제</h3>\n<p>그런데 문제가 하나 생겼다. dark pink theme의 color json을 가져와서 적용했는데 몇몇 부분에서 색이 너무 밋밋하게 나오고 있었다. 예를 들어 현재 pink theme(코드 테마는 <a href=\"https://unpkg.com/shiki@0.14.2/themes/light-plus.json\">light-plus</a>)에서 <a href=\"http://localhost:3000/posts/nextjs-13-trouble-1\">NextJS metadata 오류 해결</a>글에 있는 내 코드 하나를 보면 이렇게 나오고 있다.</p>\n<p><img src=\"/static/code-in-pink-theme-db3b93e9.png\" alt=\"핑크 테마에서의 나름 알록달록한 코드\"></p>\n<p>같은 코드를 dark pink theme으로 바꾸면 다음과 같이 나온다.</p>\n<p><img src=\"/static/code-in-dark-pink-theme-87a5b7d4.png\" alt=\"다크 핑크 테마에서의 코드\"></p>\n<p>가장 밋밋하게 나온 코드를 찍은 것이기 때문에 더 낫게 나온 부분들도 있다. 하지만 상대적으로 밋밋하다는 것은 여전하다. 그리고 <a href=\"https://marketplace.visualstudio.com/items?itemName=mgwg.light-pink-theme\">vscode의 light pink theme</a>에 있는 dark pink 테마는 원래 좀 색이 밋밋하기는 하지만 그것보다도 더 적용되는 색이 적다! 뭔가 제대로 적용되지 못하고 있는 것 같다.</p>\n<p>따라서 잘 적용되고 있는 <a href=\"https://unpkg.com/shiki@0.14.2/themes/light-plus.json\">shiki의 light-plus 테마 설정 파일</a>을 가져와서 비교해 보기로 했다. light-plus 테마 파일이 약 200줄 더 긴 걸 보면 뭔가 더 있기는 있는 것 같다.</p>\n<p>둘 다 json 파일이므로 <a href=\"https://www.jsondiff.com/\">JSON 파일의 차이를 찾아 주는 사이트</a>를 사용하였다. <a href=\"https://jsoncompare.org/\">비슷한 용도의 다른 사이트도 있다. 이후에 알게 된 곳인데 여기가 더 좋아 보였다.</a></p>\n<p>거기서 가르쳐주는 차이들을 light plus 테마들로 고치자. 예를 들어서 <code>$schema</code> 프로퍼티를 추가하는 것과 같이. 그러면 <code>editorIndentGuide.background</code>는 deprecated 되었고 <code>editorIndentGuide.background1</code>를 사용하라는 등 몇 가지 warning을 띄워준다.</p>\n<p>이런 프로퍼티명을 고치는 것들은 금방 했지만 그 외의 대부분의 것들은 노가다였다. JSON 파일 차이를 보고 <code>tokenColors</code>에 정의되어 있는 색상들을 하나하나 찾아 주는 그런 일들.</p>\n<p>예를 들어서 이런 방식으로 진행되었다. light plus 테마 설정 파일의 <code>tokenColors</code>배열에는 다음과 같은 프로퍼티가 있고 dark pink 테마 설정 파일에는 없다.</p>\n<pre><code class=\"language-json\">{\n    \"name\": \"Function declarations\",\n    \"scope\": [\n      \"entity.name.function\",\n      \"support.function\",\n      \"support.constant.handlebars\",\n      \"source.powershell variable.other.member\",\n      \"entity.name.operator.custom-literal\"\n    ],\n    \"settings\": {\n        \"foreground\": \"#795E26\"\n    }\n},\n</code></pre>\n<p>그럼 이 <code>#795E26</code>이라는 색상은 어디에 쓰이고 있는가? <code>semanticTokenColors.customLiteral</code>이 바로 이 색상이다. 그리고 이 속성은 dark pink 테마 설정 파일에도 <code>#d4d4d4</code>로 정의되어 있다. 그러면 dark pink 테마 설정 파일에는 다음과 같이 추가해 주면 되는 것이다.</p>\n<pre><code class=\"language-json\">{\n  \"name\": \"Function declarations\",\n  \"scope\": [\n    \"entity.name.function\",\n    \"support.function\",\n    \"support.constant.handlebars\",\n    \"source.powershell variable.other.member\",\n    \"entity.name.operator.custom-liter al\"\n  ],\n  \"settings\": {\n    \"foreground\": \"#d4d4d4\"\n  }\n},\n</code></pre>\n<p>없는 색상은 적당히 추가해 가면서 테마의 색상을 보강하였다. 현재 Dark pink 테마는 분홍, 보라, 연한 파랑을 중심으로 색상들이 입혀져 있는 것을 참고하였다.</p>\n<p>이런 쪽의 전문은 아니기 때문에 품질을 장담할 수는 없지만 가독성을 떨어뜨리는 색상은 최대한 배제하고 각 토큰간의 구별이 최대한 잘 되도록 색상을 입혀 보았다.</p>\n<p>파랑색 계열은 분홍색 계열로, 빨강 계열 색은 하늘색으로, 그 외 색은 적절한 색을 다른 테마나 팔레트 등에서 가져와서 입혔다. 각 색의 밝기 조절에 대해서는 <a href=\"https://yeun.github.io/open-color\">Open Color</a>사이트를 참고하였다.</p>\n<p>그 외에도 다른 메이저 테마들의 설정파일을 몇 참고하였다.</p>\n<p>그렇게 설정하고 다시 빌드해 보니 이제 코드 블록의 색상이 더 잘 입혀진 것을 확인할 수 있었다. 물론 디자인이 마음에 들지는 않지만 내가 디자이너는 아니라서 이런 곳에 시간을 많이 쓰지는 않았다...</p>\n<p><img src=\"/static/code-in-new-dark-pink-theme-ce8a6157.png\" alt=\"더 잘 입혀진 코드\"></p>\n<h1>참고</h1>\n<p>Building a theme switch component <a href=\"https://web.dev/building-a-theme-switch-component/\">https://web.dev/building-a-theme-switch-component/</a></p>\n<p>Dark Theme in NextJs 13 – Using React Context in Server Components <a href=\"https://www.youtube.com/watch?v=RTAJ-enfums\">https://www.youtube.com/watch?v=RTAJ-enfums</a></p>\n<p>next themes github <a href=\"https://github.com/pacocoursey/next-themes\">https://github.com/pacocoursey/next-themes</a></p>\n<p>svg의 viewbox 속성 <a href=\"https://tecoble.techcourse.co.kr/post/2021-10-24-svg-viewBox/\">https://tecoble.techcourse.co.kr/post/2021-10-24-svg-viewBox/</a></p>\n<p>prefers-reduced-motion <a href=\"https://mong-blog.tistory.com/entry/CSS-%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98-%EB%8F%99%EC%9E%91%EC%9D%84-%EC%BB%A8%ED%8A%B8%EB%A1%A4%ED%95%98%EB%8A%94-prefers-reduced-motion\">https://mong-blog.tistory.com/entry/CSS-%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98-%EB%8F%99%EC%9E%91%EC%9D%84-%EC%BB%A8%ED%8A%B8%EB%A1%A4%ED%95%98%EB%8A%94-prefers-reduced-motion</a></p>\n<p>search icon <a href=\"https://www.svgrepo.com/svg/532555/search\">https://www.svgrepo.com/svg/532555/search</a></p>\n<p>star fall icon <a href=\"https://www.svgrepo.com/svg/529943/star-fall-minimalistic\">https://www.svgrepo.com/svg/529943/star-fall-minimalistic</a></p>\n<p>rehype pretty code docs <a href=\"https://rehype-pretty-code.netlify.app/\">https://rehype-pretty-code.netlify.app/</a></p>\n<p>pointer media query <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/@media/pointer\">https://developer.mozilla.org/en-US/docs/Web/CSS/@media/pointer</a></p>",
    "excerpt": "next-themes를 nextjs 13에서 사용하는 방법을 설명하는 유튜브 영상과 next-themes 문서 그리고 web.dev의 접근성 좋은 Theme switch 컴포넌트 만들기 글을 참고하였다.\n1. 기초 작업\n1.1. Providers 컴포넌트\n현재 블로그에서는 next-themes를 사용해서 테마를 관리하고 있다. 하지만 nextjs13으로 넘어오면서 Context API 때문에 코드를 약간 변경해 줘야 한다. 이를 먼저 해보자.\nnext-theme",
    "headingTree": [
      {
        "title": "1. 기초 작업",
        "url": "#1-기초-작업",
        "items": [
          {
            "title": "1.1. Providers 컴포넌트",
            "url": "#11-providers-컴포넌트",
            "items": []
          },
          {
            "title": "1.2. 색상 정의하기",
            "url": "#12-색상-정의하기",
            "items": []
          }
        ]
      },
      {
        "title": "2. 버튼 구조 잡기",
        "url": "#2-버튼-구조-잡기",
        "items": [
          {
            "title": "2.1. 마크업",
            "url": "#21-마크업",
            "items": []
          },
          {
            "title": "2.2. 아이콘 만들기",
            "url": "#22-아이콘-만들기",
            "items": []
          },
          {
            "title": "2.3. 간단한 동작",
            "url": "#23-간단한-동작",
            "items": []
          },
          {
            "title": "2.4. CSS",
            "url": "#24-css",
            "items": []
          },
          {
            "title": "2.5. 애니메이션",
            "url": "#25-애니메이션",
            "items": []
          }
        ]
      },
      {
        "title": "3. 새로운 테마 만들기",
        "url": "#3-새로운-테마-만들기",
        "items": [
          {
            "title": "3.1. 테마 색상 만들기",
            "url": "#31-테마-색상-만들기",
            "items": []
          },
          {
            "title": "3.2. 새로운 테마 전환 동작 설계",
            "url": "#32-새로운-테마-전환-동작-설계",
            "items": []
          },
          {
            "title": "3.3. 기존 버튼을 컴포넌트로 분리",
            "url": "#33-기존-버튼을-컴포넌트로-분리",
            "items": []
          },
          {
            "title": "3.4. 핑크 버튼 마크업",
            "url": "#34-핑크-버튼-마크업",
            "items": []
          },
          {
            "title": "3.5. 테마 토글 버튼 동작",
            "url": "#35-테마-토글-버튼-동작",
            "items": []
          },
          {
            "title": "3.6. 핑크 테마 버튼 디자인",
            "url": "#36-핑크-테마-버튼-디자인",
            "items": []
          }
        ]
      },
      {
        "title": "4. 동작 만들기",
        "url": "#4-동작-만들기",
        "items": []
      },
      {
        "title": "5. 추가 수정 작업",
        "url": "#5-추가-수정-작업",
        "items": [
          {
            "title": "5.1. 테마 토글 버튼 디자인 수정",
            "url": "#51-테마-토글-버튼-디자인-수정",
            "items": []
          },
          {
            "title": "5.2. 코드 테마 수정",
            "url": "#52-코드-테마-수정",
            "items": [
              {
                "title": "5.2.1. 테마 색상 부족 문제",
                "url": "#521-테마-색상-부족-문제",
                "items": []
              }
            ]
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 7,
      "wordCount": 1823
    },
    "url": "/posts/blog-theme-changer",
    "thumbnail": {
      "local": "/static/theme-sketch-29f85118.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-theme-sketch-29f85118-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAADCAIAAAAhqtkfAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAVElEQVR4nAXBQQqAIBAFUBd5t8qOZueQiLYtW3UQNwMWoRhUMDDze88AIKIYIwARSem4y/kWMgAG5xprVZ99W9uuryWrsPkqLfPk/QhIvlIIgZkB/LCsOlNT92+eAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "book-community-2",
    "title": "책 커뮤니티 만들기 - 2. 협업 방식",
    "date": "2022-02-09T00:00:00Z",
    "description": "책 커뮤니티 프로젝트 협업 방식 가이드",
    "tags": [
      "web",
      "study",
      "git"
    ],
    "html": "<h1>1. 협업 가이드라인의 필요성</h1>\n<p>내가 처음 다른 사람들과 코드를 같이 짜본 건 1년 전 어느 스터디에서였다. 많은 스터디가 그렇듯 그 스터디도 곧 흐지부지되었지만 거기서 굉장히 기억에 남는 경험을 하나 했다. 그때는 다같이 하나의 레포지토리를 사용하고, 브랜치로 각자의 작업을 분리해서 각자가 알아서 작업한 후 마스터 브랜치에 머지하는 주먹구구식 방식을 사용했었다. PR같은건 사용하지 않았다.</p>\n<p>그러던 어느 날 내가 실수로 마스터 브랜치에 내 작업을 커밋-푸시해서 남의 작업들을 통째로 날려버렸다. 다행히 이전 커밋 기록까지 밀어버리거나 한 건 아니라서 어떻게든 복구가 되었다. 하지만 다른 사람들의 모든 작업까지 한번에 다 날려버릴 뻔했다는 경험은 내 기억에 생생하게 남았다.</p>\n<p>내가 실수한 것은 맞지만 내가 아니더라도 누구나 저지를 수 있는 실수였다고 감히 생각한다. 나를 제외한 다른 스터디원들도 프로그래밍이나 협업에 익숙한 사람들은 아니었으니까. 따라서 이번 프로젝트에서는 그런 실수를 좀 줄일 수 있는 가이드라인을 미리 만든다. 여전히 실수가 나올 수 있을 것이고, 어쩌면 내가 전혀 생각지도 못한 어떤 실수가 또 나올지도 모른다. 하지만 적어도 한번 했던 실수는 방지하는 게 좋지 않겠는가?</p>\n<h1>2. 사전 지식</h1>\n<h2>1. 작업할 공용 공간 만들기</h2>\n<p>우리는 스터디를 할 때 쓰던 organization이 이미 있기 때문에 거기서 공용 저장소를 만들기로 했다. 따라서 organization에 레포지토리를 하나 새로 만들어서 그곳에서 작업을 하기로 했다.</p>\n<p><img src=\"/static/group-894f7581.png\" alt=\"group\"></p>\n<p>이전 글에서 설명했던 것처럼 클라이언트와 서버 폴더를 만들고 역할 분배 문서도 적어서 넣어 놓았다.</p>\n<h2>2. 용어</h2>\n<p><strong>중앙 원격 저장소</strong> : organization에 있는 원격 저장소. 여기서는 우리가 만든 book-community 공용 레포지토리를 가리킨다.</p>\n<p><strong>내 원격 저장소</strong> : 내가 중앙 원격 저장소를 포크해 와서 내 계정에 만든 원격 저장소. git fork를 이용한다. 그리고 github 홈페이지에서는 <code>내 계정명/book-community</code> 와 같이 표시되며 중앙 원격 저장소가 어디인지도 표시해 준다.</p>\n<p><img src=\"/static/forked-92c61564.png\" alt=\"fork\"></p>\n<p>내 계정에 fork해 와서 만든 원격 저장소 모습</p>\n<p><strong>로컬 저장소</strong> : 원격이 아니라 내 pc에 저장해 놓은 저장소. 실제 코드를 짜는 작업은 이곳에서 진행한다.</p>\n<h1>3. 협업 시스템 구성</h1>\n<h2>1. 내 원격 저장소 만들기</h2>\n<p>github 홈페이지의 중앙 원격 저장소에서 fork를 이용하여, 중앙 원격 저장소를 내 계정으로 복사한다.</p>\n<p><img src=\"/static/fork_guide-050970af.png\" alt=\"forking\"></p>\n<p>그러면 내 계정에 원격 저장소가 만들어진다.</p>\n<h2>2. 내 로컬로 원격 저장소 가져오기</h2>\n<p>이제 실제 작업을 위해서는 저장소의 내용을 내 로컬로 가져와서 작업해야 한다. 이를 위해서 <code>git clone</code> 을 이용해 내 로컬 저장소로 가져오자. 원격 저장소의 내용을 가져와서 작업하고 싶은 폴더를 만들고 그 폴더 내부에서 <code>git init</code>을 한 후 <code>git clone</code> 을 하자</p>\n<pre><code>git clone [원격 저장소 URL]\n</code></pre>\n<p>혹은</p>\n<pre><code>git remote add origin [원격 저장소 URL]\ngit pull origin [가져오고 싶은 브랜치 이름]\n</code></pre>\n<p>단 이 둘은 결과는 똑같더라도 차이가 있다. git clone은 로컬 저장소의 내용을 원격 저장소와 일치시켜 준다. 반면 git pull은 원격 저장소의 내용을 가져와서 로컬 저장소의 기존 내용과 병합해 주는 것이다.</p>\n<p>지금 우리가 하는 것이 빈 폴더에 원격 저장소의 내용을 가져와 주는 것이기 때문에 둘의 결과는 같다. 하지만 만약 기존 작업 내용이 있는데 <code>git clone</code>을 실행한다면 로컬 저장소의 내용이 원격 저장소 내용으로 덮어씌워질 것이다. 반면 <code>git pull</code>은 충돌이 나지 않는 선에서 원격 저장소의 내용을 로컬 저장소와 병합한다.</p>\n<p>따라서 처음에 원격 저장소를 로컬 저장소로 옮길 때는 git clone을 추천한다.</p>\n<p>그런데 원격 저장소 URL은 어디 있는가? 중앙 원격 저장소를 내 게정으로 fork해 왔다면 그것에 해당하는 레포지토리가 내 계정에 존재한다. 그 레포지토리에 가서 <code>Code</code> 라 쓰인 버튼을 누르면 HTTP 혹은 SSH URL을 찾을 수 있다.</p>\n<p><img src=\"/static/url-1c54b2d9.png\" alt=\"url\"></p>\n<p>사진에서 빨간 표시가 된 버튼을 누르면 원격 저장소 URL을 찾을 수 있다. 위의 사진에서 중앙 원격 저장소가 아니라 내 원격 저장소(중앙 저장소에서 fork한 것)에 들어와 있는 것에 주의한다.</p>\n<p>git clone을 통해 로컬 저장소에 내 원격 저장소가 잘 연결되었는지를 보려면 다음 명령어를 사용하면 된다.</p>\n<pre><code>git remote -v\n</code></pre>\n<p>로컬 저장소의 터미널에서 이 명령을 사용하면 현재 이 로컬 저장소에 연결된 원격 저장소에 지정된 이름과 URL을 볼 수 있다. 그러면 내가 아까 연결한 원격 저장소의 이름이 origin으로 설정되어 있는 것을 볼 수 있는데, 그것은 <code>git clone</code> 을 할 때 clone한 원격 저장소에 자동으로 지정되는 이름이 origin이기 때문이다.</p>\n<p>만약 로컬 저장소에 기존에 연결되어 있는 어떤 원격 저장소가 있어서 그 원격 저장소와의 연결을 삭제하고 싶다면 다음과 같이 하면 된다.</p>\n<pre><code>git remote remove [삭제할 원격 저장소에 지정된 이름]\n</code></pre>\n<p>예를 들어 origin이라는 이름을 붙인 원격 저장소 연결을 삭제하고 싶으면 <code>git remote remove origin</code> 을 터미널에 타이핑하면 되는 것이다.</p>\n<h2>3. 로컬에 중앙 원격 저장소 연결</h2>\n<p>현재 우리의 로컬 저장소에는 중앙 원격 저장소를 내 계정에 fork한 저장소가 연결되어 있다. 하지만 중앙 원격 저장소 또한 연결해 놓는 것이 좋다. 왜냐 하면 내가 한 작업만 있는 게 아니기 때문이다.</p>\n<p>다른 사람들이 작업한 결과물 A가 중앙 원격 저장소에 추가되었다고 하자. 그래도 내 원격 저장소는 중앙 원격 저장소와는 다른 저장소이기 때문에 A가 없다. 따라서 내가 A를 기반으로 어떤 추가적인 작업을 하기 위해서는 중앙 원격 저장소에서 A를 가져올 수 있어야 한다. 이런 작업을 위해 로컬 저장소에도 중앙 원격 저장소를 연결해 두고 중앙 원격 저장소의 내용(보통 남들이 작업한 결과물)을 가져올 수 있게 하는 것이다.</p>\n<p>터미널에서 다음과 같은 스크립트를 입력해서 중앙 원격 저장소를 로컬 저장소와 연결한다.</p>\n<pre><code>git remote add upstream [중앙 원격 저장소 URL]\n</code></pre>\n<p>중앙 원격 저장소 URL 또한 위와 같이 github 홈페이지의 중앙 원격 저장소 레포지토리에서 <code>Code</code> 버튼을 누른다.</p>\n<p>이제 중앙 원격 저장소를 내 계정으로 fork해서 내 원격 저장소를 만들었고 둘 다 내 로컬 저장소에 연결하였다. 내 원격 저장소는 origin으로, 중앙 원격 저장소는 upstream으로 연결되어 있다.</p>\n<h1>4. 새로운 작업을 하기</h1>\n<p>내가 맡은 새로운 작업은 로컬 저장소에서 새로운 브랜치를 따서 진행할 것이다. 그리고 작업이 완료되면 내 원격 저장소에 푸시한다. 그 다음 그 브랜치를 합병해 달라는 요청(Pull Request)을 중앙 원격 저장소에 보낸다. 이 과정을 하나하나 설명할 것이다.</p>\n<h2>1. 새로운 작업을 위한 브랜치 만들기</h2>\n<p><code>git branch</code> 명령으로 현재 저장소가 위치하고 있는 브랜치를 확인할 수 있다. 아마 현재는 <code>master</code> 브랜치에 있을 것이다. 여기서 이제 새로운 작업을 위한 브랜치를 만들어서 거기서 작업을 진행하도록 하자. 다음 명령어로 새로운 이름의 브랜치를 만든다.</p>\n<pre><code>git branch [새로 만들 브랜치 이름]\n</code></pre>\n<p>그리고 다음 명령어로 새로 만든 브랜치로 이동한다.</p>\n<pre><code>git checkout [이동할 브랜치 이름]\n</code></pre>\n<p>위의 두 명령은</p>\n<pre><code>git checkout -b [새로 만든 다음 이동할 브랜치 이름]\n</code></pre>\n<p>예를 들어서 나는</p>\n<pre><code>git branch test\ngit checkout test\n</code></pre>\n<p>라는 명령어로 <code>test</code> 라는 브랜치를 만들고 거기로 이동했다.</p>\n<p>이제 내가 하려고 하는 작업을 로컬 저장소에서 진행한다.</p>\n<h2>2. 작업을 원격 저장소에 푸시하기</h2>\n<p>로컬 저장소에서 작업을 완료하고 나면 그것을 내 원격 저장소에 올려야 한다. 이때 중앙 원격 저장소에 올리는 것이 아니라 내 원격 저장소(중앙 원격 저장소를 fork한 것)에 올리는 것이라는 것에 크게 주의해야 한다. 먼저 다음 명령어로 내가 작업한 파일 내역을 확인할 수 있다.</p>\n<pre><code>git status\n</code></pre>\n<p>그러면 로컬에서 진행되었지만 아직 커밋되지 않은 작업 내역이 표시된다. 이 작업 내역을 스테이징 영역에 추가하자. 커밋할 수 있는 상태로 만들어 주는 작업이라고 생각하면 된다.</p>\n<pre><code>git add .\n</code></pre>\n<p>만약 특정 파일만 스테이징 영역에 추가하고 싶다면 git add 뒤에 <code>.</code> 대신 스테이징 영역에 추가하고자 하는 파일 이름을 쓰면 된다. 그렇게 스테이징 영역에 작업 내역을 추가하고 나면 커밋을 진행하자.</p>\n<pre><code>git commit -m \"commit message\"\n</code></pre>\n<p>이제 커밋을 통해 로컬 저장소에 있는 작업 내역들을 원격 저장소에 올릴 준비가 다 되었다. 우리가 작업을 진행하기로 한 브랜치에 푸시하자.</p>\n<pre><code>git push origin [작업중인 브랜치 이름]\n</code></pre>\n<p>이때 push하는 저장소가 origin임에 주의하자. origin은 중앙 원격 저장소가 아니다. 내가 중앙 원격 저장소를 내 계정으로 fork해온 내 원격 저장소이다. 그리고 브랜치명도, master가 아니라 내가 진행중인 작업을 위해 만든 브랜치에 푸시해야 한다. 내가 작업을 위해 만든 브랜치 이름이 <code>test</code> 라면 다음과 같이 진행한다.</p>\n<pre><code>git commit -a -m \"commit message\" #이 커맨드는 커밋과 함께  git add 도 같이 진행해 준다\ngit push origin test\n</code></pre>\n<h2>3. 중앙 원격 저장소에 반영 요청하기</h2>\n<p>프로젝트에서 내가 맡은 부분의 작업을 내 원격 저장소에서 진행했다면 그것을 중앙 원격 저장소에도 올려서 모두가 볼 수 있게 해줘야 한다. 그래야 내 작업을 기반으로 다른 사람들이 다른 작업을 더 진행할 수도 있고, 또 중복된 일을 하는 것을 막을 수 있기 때문이다. 그러기 위해서는 중앙 원격 저장소에 내 작업의 반영을 요청해야 한다. 이를 Pull Request라 한다.</p>\n<p>이 요청을 하면 내 원격 저장소에서 브랜치 하나를 택해서 중앙 원격 저장소에 반영하기를 요청할 수 있다. 나는 이 글에서  지금까지 <code>test</code> 라는 이름의 브랜치를 써 왔으므로 그 브랜치를 중앙 원격 저장소에 반영을 요청해 보겠다.</p>\n<p>내가 test 브랜치에서 작업을 진행하면, git에서는 내 원격 저장소에서 중앙 원격 저장소의 내용을 fork해온 후 어떤 브랜치에서 추가적인 작업을 진행했는지를 추적해 준다. 그리고 중앙 원격 저장소에 비해 내 원격 저장소에서 진행한 내용이 있다면 그걸 반영할 수 있도록 해준다.</p>\n<p><img src=\"/static/pr_button-7d14a286.png\" alt=\"button\"></p>\n<p>사진을 보면 <code>compare &#x26; pull request</code> 라 쓰인 버튼이 있는 것을 볼 수 있다. 이를 누르면 페이지가 이동되고 pull request의 이름과 설명을 적을 수 있다. 아래에서는 본인이 변경한 사항을 검토할 수도 있다. 이제 제목에 주요 변경사항을 적고, 내용에는 세부 설명을 적절히 써서 Create pull request를 하면 된다.</p>\n<p><img src=\"/static/pr_example-58c2ccdf.png\" alt=\"prex\"></p>\n<h2>4. 중앙 원격 저장소에 반영하기</h2>\n<p>이제 중앙 원격 저장소의 pull request 메뉴에 가면 내가 요청한 pull request가 떠 있는 것을 볼 수 있다.</p>\n<p><img src=\"/static/pr_show-e5fd04d9.png\" alt=\"prsee\"></p>\n<p>pull request를 누르면 이 pull request에서 중앙 원격 저장소에 반영 요청한 커밋은 무엇이며 요청한 사람이 어떤 설명을 썼는지도 볼 수 있다. 커밋 내역을 누르면 그 커밋에서 변경한 사항을 볼 수도 있다. 커밋의 변경사항이 여러 개라면 이렇게 각 커밋마다 어떤 것을 변경했는지 볼 수 있는 기능이 유용하다. 내가 한 작업이라면 내가 웬만큼 알고 있겠지만 남의 작업을 볼 때 유용하다. 결과물 코드만 보고 남이 무슨 작업을 했는지 한눈에 아는 것은 쉽지 않기 때문이다.</p>\n<p><img src=\"/static/merge_example-abd3e6e3.png\" alt=\"mergeex\"></p>\n<p>그리고 만약 특별한 문제가 없다면 Merge pull request 버튼을 통해서 pull request의 작업 내용을 중앙 원격 저장소에 반영할 수 있다.</p>\n<p>그런데 무작정 merge를 하면 안 된다. 다른 작업 내용과 충돌할 수도 있고 팀의 다른 사람이 그 내용에 어떤 문제가 있다고 판단할 수도 있기 때문이다. 따라서 다른 사람의 확인과 충분한 이해를 받은 후에 merge 해야 한다.</p>\n<p>그렇게 확인받은 후 merge하는 과정까지 거치면 내가 한 작업이 중앙 원격 저장소에 반영되는 것이다!</p>\n<h1>5. 다른 작업과 동기화하기</h1>\n<p>그런데 이 중앙 원격 저장소에서는 나만 작업을 하는 것이 아니다. 다른 팀원들도 작업을 하고 있다. 따라서 중앙 원격 저장소의 코드는 다른 사람들의 작업 내용이 반영되면서 내 작업과는 상관없이 변경될 것이다. 이런 변경 사항들을 내 로컬 저장소와 동기화해가며 작업해야 한다.</p>\n<p>내가 작업한 내용이 다른 사람들의 작업 내용과 충돌하고 있을 수도 있고, 나도 다른 사람의 결과물을 기반으로 작업할 때가 있을 것이기 때문이다. 이러한 동기화는 다음과 같이 진행한다. 아까 로컬에 중앙 원격 저장소를 upstream이라는 이름으로 연결한 이유가 이제야 드러난다.</p>\n<pre><code>git pull upstream master\n</code></pre>\n<p>이러면 upstream이라는 이름으로 로컬 저장소에 연결된 중앙 원격 저장소의 master브랜치 내용을 로컬 저장소에 추가한다. 만약 오류가 발생하면 무언가 다른 사람의 작업 내용과 내 작업 내용이 충돌을 일으키는 등 어떤 문제가 생겼다는 것이므로, 오류 메시지를 잘 읽어보고 대처하자.</p>\n<p>만약 저 커맨드가 특별한 오류 없이 완료된다면 로컬 저장소가 중앙 원격 저장소와 잘 동기화되었다는 것이다. 이를 내 원격 저장소에도 반영하고 싶다면 <code>git push origin master</code>를 쓰자.</p>\n<h2>5.1. 새로운 작업의 시작</h2>\n<p>내가 진행한 작업 하나가 끝나고, 그 사이에 진행된 다른 사람들의 작업물도 로컬 저장소와 동기화했다면 새로운 작업을 시작할 수 있는 상태로 다시 돌아왔다. 이제 다시 4. 번에서 새로운 작업을 시작하면서 했던 일로 돌아가자. 새로운 작업을 위한 브랜치를 만들어서 작업을 시작하면 된다.</p>\n<h1>6. 참고</h1>\n<p>매우 자세하게 쓰인 github 협업 가이드. 내가 쓴 글도 이걸 내가 이해한 대로 쓴 것에 불과하다. <a href=\"https://gmlwjd9405.github.io/2017/10/28/how-to-collaborate-on-GitHub-2.html\">https://gmlwjd9405.github.io/2017/10/28/how-to-collaborate-on-GitHub-2.html</a></p>\n<p>git pull 과 git clone의 차이 <a href=\"https://kimcoder.tistory.com/288\">https://kimcoder.tistory.com/288</a></p>",
    "excerpt": "1. 협업 가이드라인의 필요성\n내가 처음 다른 사람들과 코드를 같이 짜본 건 1년 전 어느 스터디에서였다. 많은 스터디가 그렇듯 그 스터디도 곧 흐지부지되었지만 거기서 굉장히 기억에 남는 경험을 하나 했다. 그때는 다같이 하나의 레포지토리를 사용하고, 브랜치로 각자의 작업을 분리해서 각자가 알아서 작업한 후 마스터 브랜치에 머지하는 주먹구구식 방식을 사용했었다. PR같은건 사용하지 않았다.\n그러던 어느 날 내가 실수로 마스터 브랜치에 내 작업을 커밋-푸시해서 남",
    "headingTree": [
      {
        "title": "1. 협업 가이드라인의 필요성",
        "url": "#1-협업-가이드라인의-필요성",
        "items": []
      },
      {
        "title": "2. 사전 지식",
        "url": "#2-사전-지식",
        "items": [
          {
            "title": "1. 작업할 공용 공간 만들기",
            "url": "#1-작업할-공용-공간-만들기",
            "items": []
          },
          {
            "title": "2. 용어",
            "url": "#2-용어",
            "items": []
          }
        ]
      },
      {
        "title": "3. 협업 시스템 구성",
        "url": "#3-협업-시스템-구성",
        "items": [
          {
            "title": "1. 내 원격 저장소 만들기",
            "url": "#1-내-원격-저장소-만들기",
            "items": []
          },
          {
            "title": "2. 내 로컬로 원격 저장소 가져오기",
            "url": "#2-내-로컬로-원격-저장소-가져오기",
            "items": []
          },
          {
            "title": "3. 로컬에 중앙 원격 저장소 연결",
            "url": "#3-로컬에-중앙-원격-저장소-연결",
            "items": []
          }
        ]
      },
      {
        "title": "4. 새로운 작업을 하기",
        "url": "#4-새로운-작업을-하기",
        "items": [
          {
            "title": "1. 새로운 작업을 위한 브랜치 만들기",
            "url": "#1-새로운-작업을-위한-브랜치-만들기",
            "items": []
          },
          {
            "title": "2. 작업을 원격 저장소에 푸시하기",
            "url": "#2-작업을-원격-저장소에-푸시하기",
            "items": []
          },
          {
            "title": "3. 중앙 원격 저장소에 반영 요청하기",
            "url": "#3-중앙-원격-저장소에-반영-요청하기",
            "items": []
          },
          {
            "title": "4. 중앙 원격 저장소에 반영하기",
            "url": "#4-중앙-원격-저장소에-반영하기",
            "items": []
          }
        ]
      },
      {
        "title": "5. 다른 작업과 동기화하기",
        "url": "#5-다른-작업과-동기화하기",
        "items": [
          {
            "title": "5.1. 새로운 작업의 시작",
            "url": "#51-새로운-작업의-시작",
            "items": []
          }
        ]
      },
      {
        "title": "6. 참고",
        "url": "#6-참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 197
    },
    "url": "/posts/book-community-2",
    "thumbnail": {
      "local": "/static/group-894f7581.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-group-894f7581-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAFCAIAAAD38zoCAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAiElEQVR4nAF9AIL/AGVpb1ZeZ0FLVTxGTomMkZOUmHt9gJ+dogCjoqK+v7/k5OTV1NSrra6fn6JibGkAHRAAMzk7enx+jY6RyMnLztDRwsLFanFxDiUdAGtzd8HBwba3uISFh9zc3fb29tPT1LWztACUlZa0trbCxcaSlJS9vr/Z2tu9vr+doaEeW0fzms8a0QAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "book-community-3",
    "title": "책 커뮤니티 만들기 - 3. 메인 페이지 제작 - 1",
    "date": "2022-02-11T00:00:00Z",
    "description": "책 커뮤니티 메인 페이지 만들기, 그 첫걸음",
    "tags": [
      "web",
      "study",
      "react"
    ],
    "html": "<h1>1. styled-components 설치</h1>\n<p>css를 그대로 쓰는 대신 styled-components 라이브러리를 사용할 것이므로 이를 client 폴더 내부에 설치해 준다.</p>\n<pre><code>npm install styled-components\n</code></pre>\n<p>그리고 잘 되는지 확인해 보기 위해 styled-components  공식 문서에 있는 Button 코드를 가져와서 한번 메인 페이지에 넣어 보았다.</p>\n<pre><code class=\"language-tsx\">import React from 'react';\nimport styled from 'styled-components';\n\nconst MyButton = styled.button`\n  background: transparent;\n  border-radius: 3px;\n  border: 2px solid palevioletred;\n  color: palevioletred;\n  margin: 0 1em;\n  padding: 0.25em 1em;\n`;\n\nfunction MainPage() {\n  return (\n    &#x3C;MyButton>예시버튼&#x3C;/MyButton>\n  );\n}\n\nexport default MainPage;\n</code></pre>\n<p>예시 버튼이 잘 표시되는 것을 알 수 있다. 이제 본격적으로 메인 페이지의 요소들을 만들어 보자.</p>\n<h1>2. 사이트 로고</h1>\n<p>사이트 로고에 들어갈 문구는 프로젝트 팀원인 하늘(<a href=\"https://github.com/hamuneulbo\">https://github.com/hamuneulbo</a>) 님의 아이디어대로 만들었다. <code>Reviewary - 너와 나의 리뷰 도서관</code> 이라는 문구를 로고에 적기로 하였다. 지금은 아직 페이지의 형태만 간단하게 잡는 단계이므로 적당히 만들었다.</p>\n<pre><code class=\"language-tsx\">const HeaderMainLogo = styled.h1`\n  font-size:3rem;\n  margin: 3px;\n`;\n\nconst HeaderSubLogo = styled.h2`\n  font-size:1.5rem;\n  margin:0;\n`;\n\nfunction HeaderLogo() {\n  return (\n    &#x3C;>\n      &#x3C;HeaderMainLogo>Reviewary&#x3C;/HeaderMainLogo>\n      &#x3C;HeaderSubLogo>너와 나의 리뷰 도서관&#x3C;/HeaderSubLogo>\n    &#x3C;/>\n  );\n}\n</code></pre>\n<p>그렇게 멋지지는 않지만, 적당히 큰 글씨로 쓰여진 로고같은 게 사이트에 들어갔다.</p>\n<p><img src=\"/static/logo-0db2ce1e.png\" alt=\"logo\"></p>\n<p>이렇게 로고를 만들고 난 뒤에는, 로고는 대부분의 페이지에서 재사용될 것으로 예상되므로 로고 컴포넌트를 src/common/HeaderLogo.js 로 분리해 주었다.</p>\n<h1>3. 컨테이너 만들기</h1>\n<p>앞으로 자주 쓰일 듯한 간단한 컨테이너들을 만들었다. 빠르게 만들기 위해서 아주 단순하게, display : flex를 이용해서 내부 요소들을 가로로 정렬할 것인지, 세로로 정렬할 것인지만 정해주는 컨테이너를 만들었다. 요소 정렬과 같은 기능들은 추후 추가하려고 한다.</p>\n<pre><code class=\"language-tsx\">/* src/common/HorizontalContainer.js */\nimport styled from 'styled-components';\n\nconst HorizontalContainer = styled.div`\n  display: flex;\n  flex-direction: row;\n`;\n\nexport default HorizontalContainer;\n\n</code></pre>\n<pre><code class=\"language-tsx\">/* src/common/VerticalContainer.js */\nimport styled from 'styled-components';\n\nconst VerticalContainer = styled.div`\n  display: flex;\n  flex-direction: column;\n`;\n\nexport default VerticalContainer;\n</code></pre>\n<p>그래서 이를 이용해 먼저, 로고에 쓰인 <code>HeaderMainLogo</code> 와 <code>HeaderSubLogo</code> 를 세로로 정렬되어 있도록 바꾸었다.</p>\n<pre><code class=\"language-tsx\">/* src/common.HeaderLogo.js 일부 */\nfunction HeaderLogo() {\n  return (\n    &#x3C;VerticalContainer>\n      &#x3C;HeaderMainLogo>Reviewary&#x3C;/HeaderMainLogo>\n      &#x3C;HeaderSubLogo>너와 나의 리뷰 도서관&#x3C;/HeaderSubLogo>\n    &#x3C;/VerticalContainer>\n  );\n}\n</code></pre>\n<h1>4. 메뉴</h1>\n<p>흔한 드롭다운 메뉴를 만들기로 했다. 드롭다운 메뉴를 만들면서 참고한 문서는 아래의 참고 문서들에 적어 놓았다. 참고 문서의 <code>드롭다운 메뉴 2</code> 에 있는 문서를 참고하여 비슷한 방식으로 드롭다운 메뉴의 헤더를 표현하는 <code>DropDownMenuHeader</code> 컴포넌트를 구현하였다.</p>\n<pre><code class=\"language-tsx\">const DropDownMenuHeader = styled.div`\n  font-weight: 500;\n  font-size: 1.3rem;\n  background: #ffffff;\n  height:1.8rem;\n  width:9rem;\n`;\n</code></pre>\n<p>그리고 드롭다운 메뉴 활성화 시 보이게 될 서브메뉴들을 담는 컨테이너인 <code>DropDownMenuContainer</code> 를 만든다.</p>\n<pre><code class=\"language-tsx\">const DropDownMenuContainer = styled.div`\n  color:#000000;\n  width:10rem;\n  margin: 0 auto;\n`;\n</code></pre>\n<p>드롭다운 메뉴 리스트를 담는 <code>ul</code> 요소인 <code>DropDownMenuList</code> 를 만든다. 이 안에는 <code>DropDownListItem</code> 들이 들어가서 드롭다운 메뉴를 구성하게 될 것이다.</p>\n<pre><code class=\"language-tsx\">const DropDownMenuList = styled.ul`\n  padding: 0;\n  margin: 0;\n  background: #ffffff;\n  border:2px solid #000000;\n  box-sizing: border-box;\n  color:#000000;\n  font-size: 1.3rem;\n  font-weight: 500;\n  &#x26;:first-child{\n    padding-top: 0.8rem;\n  }\n`;\n\nconst DropDownListItem = styled.li`\n  list-style: none;\n  margin-bottom: 0.8rem;\n`;\n</code></pre>\n<p>그리고 이 모든 것을 묶는 <code>DropDownMenu</code> 컴포넌트를 만든다. 이때 드롭다운 메뉴에서 특정 메뉴를 선택할 경우가 있을 수 있는데, 이때 어떤 메뉴가 선택되었는지를 알려주는 selectedMenu state를 만들어 주고 onClick 이벤트를 이용하여 특정 드롭다운 메뉴 항목을 클릭했을 때 그 메뉴가 선택 상태가 되도록 했다.</p>\n<p>이러한 동작은 드롭다운 메뉴의 어떤 항목을 클릭했을 때 특정 게시판으로 이동하거나 특정 페이지로 이동하는 등의 동작으로 추후에 대체될 것이다.</p>\n<p>드롭다운 메뉴는 여러 개를 만들 것이므로, 드롭다운 메뉴의 헤더 이름과 항목 이름은 각각 문자열과 배열로 받을 수 있게 하였다. 배열 map 함수의 key로는 각 항목을 그대로 준 것을 볼 수 있는데(<code>key={item}</code>) 이는 보통 게시판 이름은 겹치지 않게 작명하기 때문에 게시판 이름을 key로 써도 무방하기 때문이다. 만약 서로 이름이 겹치는 항목들을 드롭다운 메뉴에 넣어야 하는 경우가 온다면 드롭다운 메뉴 항목들을 넣는 배열(여기서는 dropDownItemList)의 원소들을 객체로 만든 후 각 객체에 <code>id</code> 를 따로 만들어서 넣어주는 게 좋을 것이다.</p>\n<pre><code class=\"language-tsx\">function DropDownMenu({ menuName, dropDownItemList }) {\n  const [selectedMenu, setSelectedMenu] = useState(null);\n\n  const onOptionSelected = (value) => () => {\n    setSelectedMenu(value);\n  };\n\n  return (\n    &#x3C;VerticalContainer>\n      &#x3C;DropDownMenuHeader>{menuName}&#x3C;/DropDownMenuHeader>\n      &#x3C;DropDownMenuContainer>\n        &#x3C;DropDownMenuList>\n          {dropDownItemList.map((item) => (\n            &#x3C;DropDownListItem\n              onClick={onOptionSelected(item)}\n              key={item}\n            >\n              {item}\n            &#x3C;/DropDownListItem>\n          ))}\n        &#x3C;/DropDownMenuList>\n      &#x3C;/DropDownMenuContainer>\n    &#x3C;/VerticalContainer>\n  );\n}\n</code></pre>\n<p>이제는 드롭다운 메뉴가 동작하게 만들어 보자. 참고 문서에서는 드롭다운 메뉴의 헤더를 클릭할 시에 메뉴 항목들이 내려와서 표시되도록 했다. 하지만 일반적으로 우리가 사용하는 사이트들에서는 드롭다운 메뉴를 클릭해서 동작시키는 경우보다는 드롭다운 메뉴 헤더에 마우스를 올리면(<code>hover</code>) 드롭다운 메뉴 항목들이 표시되는 게 일반적이다.</p>\n<p>따라서 이를 css를 이용해서 구현해 보자. 생각보다 그렇게 어렵지 않다. 먼저 지금 상태에서는 <code>DropDownMenuContainer</code>에 들어있는, 드롭다운 메뉴의 서브메뉴들이 언제나 페이지에 표시되고 있을 것이다. 이를 평소 상태에는 안 보이고 마우스를 올려야 보이도록 설정해 주자. 이제 <code>DropDownMenuContainer</code>는 그 위에 마우스가 올려져 있는 한 언제나 표시될 것이다.</p>\n<pre><code class=\"language-tsx\">const DropDownMenuContainer = styled.div`\n  display: none;\n  color:#000000;\n  width:10rem;\n  margin: 0 auto;\n  &#x26;:hover {\n    display: block;\n  }\n`;\n</code></pre>\n<p>그런데 평소에 <code>DropDownMenuContainer</code> 는 페이지에 렌더링되지 않는 상태이다. 어떤 조치를 취해주지 않으면 이 컨테이너 요소에 마우스를 올리는 것은 불가능하다. 일반적인 드롭다운 메뉴의 방식대로, 드롭다운 메뉴의 제목이 표시된 헤더에 마우스를 올리면 <code>DropDownMenuContainer</code>가 렌더링되도록 하자. 이때 <code>DropDownMenuHeader</code> 의 형제인<code>DropDownMenuContainer</code> 들만 보이게 해야 하므로 <code>+</code> 셀렉터를 적절히 이용하였다. 이렇게 셀렉터를 이용해서 다른 요소를 선택하는 법은 이창희(<a href=\"https://xo.dev/)%EB%8B%98%EC%9D%B4\">https://xo.dev/)님이</a> 알려주셨다. 분명 CSS를 배울 때 이런 셀렉터가 있다는 것을 지나치듯 본 것 같은데, CSS를 조만간 복습해야겠다고 느꼈다.</p>\n<pre><code class=\"language-tsx\">const DropDownMenuHeader = styled.div`\n  margin: 0;\n  padding: 1rem;\n  font-weight: 500;\n  font-size: 1.3rem;\n  background: #ffffff;\n  height:1.8rem;\n  width:9rem;\n  &#x26;:hover + ${DropDownMenuContainer}{\n    display:block;\n  }\n`;\n</code></pre>\n<p>이때 헤더와 메뉴 요소 사이 간격이 있으면, 헤더에서 메뉴로 hover가 이어질 수 없는 현상이 발생한다.(그 간격을 지나가는 동안 마우스 커서가 메뉴 요소를 벗어나 버리므로)그렇게 되면 드롭다운 메뉴의 항목을 선택할 수 없게 된다. 따라서 드롭다운 메뉴 요소들 간의 margin을 모두 0으로 설정한다. 만약 시각적으로 간격을 표시해야 되는 일이 있으면 padding을 사용한다. (margin은 요소 외부의 간격을, padding은 요소 내부의 간격을 설정한다)</p>\n<p>이제 드롭다운 메뉴에 적절한 이름 문자열과 항목 배열을 props로 전달하면 드롭다운 메뉴가 잘 렌더링되고 작동한다.</p>\n<p><img src=\"/static/dropdown-3dcec673.png\" alt=\"dropdown\"></p>\n<p>이제 <code>DropDownMenu</code> 도 <code>src/common</code> 폴더에 <code>DropDownMenu.js</code> 파일을 만들어서 분리해 준다.</p>\n<h1>5. 캐로셀 구현하기</h1>\n<p>이미지를 옆으로 넘기면서 정보를 확인하는 메뉴의 이름을 잘 몰라서 처음에는 '슬라이더 메뉴' 등으로 검색했었다. 그러던 중 이런 메뉴를 캐로셀이라고 하는 것을 알았다. 지금 만들고 있는 사이트에는 이런 캐로셀이 있는 게 좋다고 생각되어 이것을 메인 페이지에 구현하기로 했다.</p>\n<p>일단 캐로셀 슬라이드에 띄울 이미지들을 적당히 픽사베이(<a href=\"https://pixabay.com/\">https://pixabay.com/</a>) 에서 다운받았다. 여러 사이즈의 이미지를 받아보았다. 책 표지 이미지도 서점 홈페이지에서 받았다. 책 표지는 일반적인 사진과 달리 세로가 길고 이런 이미지는 책이 아니면 흔치 않기 때문에...</p>\n<h1>6. 참고</h1>\n<p>styled-components 공식문서 <a href=\"https://styled-components.com/\">https://styled-components.com/</a></p>\n<p>드롭다운 메뉴 만들기 <a href=\"https://programming-oddments.tistory.com/177\">https://programming-oddments.tistory.com/177</a></p>\n<p>드롭다운 메뉴 2 <a href=\"https://andela.com/insights/react-js-tutorial-on-creating-a-custom-select-dropdown/\">https://andela.com/insights/react-js-tutorial-on-creating-a-custom-select-dropdown/</a></p>\n<p>css flex <a href=\"https://studiomeal.com/archives/197\">https://studiomeal.com/archives/197</a></p>\n<p>css selecter <a href=\"https://poiemaweb.com/css3-selector\">https://poiemaweb.com/css3-selector</a></p>\n<p>다양한 방법으로 캐로셀 구현하기 <a href=\"https://programming119.tistory.com/211\">https://programming119.tistory.com/211</a></p>\n<p>react hook으로 캐로셀 구현하기 <a href=\"https://velog.io/@peppermint100/JSReact-Hooks%EB%A1%9C-Carousel-Slider-%EB%A7%8C%EB%93%A4%EA%B8%B0\">https://velog.io/@peppermint100/JSReact-Hooks%EB%A1%9C-Carousel-Slider-%EB%A7%8C%EB%93%A4%EA%B8%B0</a></p>\n<p>화살표 형태의 버튼 만들기 <a href=\"https://www.w3schools.com/howto/howto_css_arrows.asp\">https://www.w3schools.com/howto/howto_css_arrows.asp</a></p>",
    "excerpt": "1. styled-components 설치\ncss를 그대로 쓰는 대신 styled-components 라이브러리를 사용할 것이므로 이를 client 폴더 내부에 설치해 준다.\nnpm install styled-components\n\n그리고 잘 되는지 확인해 보기 위해 styled-components  공식 문서에 있는 Button 코드를 가져와서 한번 메인 페이지에 넣어 보았다.\nimport React from 'react';\nimport styled from '",
    "headingTree": [
      {
        "title": "1. styled-components 설치",
        "url": "#1-styled-components-설치",
        "items": []
      },
      {
        "title": "2. 사이트 로고",
        "url": "#2-사이트-로고",
        "items": []
      },
      {
        "title": "3. 컨테이너 만들기",
        "url": "#3-컨테이너-만들기",
        "items": []
      },
      {
        "title": "4. 메뉴",
        "url": "#4-메뉴",
        "items": []
      },
      {
        "title": "5. 캐로셀 구현하기",
        "url": "#5-캐로셀-구현하기",
        "items": []
      },
      {
        "title": "6. 참고",
        "url": "#6-참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 390
    },
    "url": "/posts/book-community-3",
    "thumbnail": {
      "local": "/static/logo-0db2ce1e.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-logo-0db2ce1e-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAHCAIAAAC6O5sJAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAeUlEQVR4nGOQlZWdNXt2fV1dalra/AULpk6dMmv2nBMnTzKwc7BLSko6OjhwcnKrqqkLC4vIyssXFBYx1NTU9E2YWFsHAk2NTe0dHTV1df///2e4devWo0ePHjx4eO/+/cePH9+9e/fBg4cgif8Y4M+fP9glIACnBACDKHraqidQmQAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "c-through-1",
    "title": "C-through - 1. Implicit int rule",
    "date": "2022-01-09T00:00:00Z",
    "description": "C언어의 implicit int rule에 대하여",
    "tags": [
      "language"
    ],
    "html": "<h1>1. C-through</h1>\n<p>C에 관해 복습하면서 알게 되는 점들에 대해 서술하는 시리즈이다. 변수가 무엇이고 상수가 무엇이고 하는 C의 기본적인 문법에 대해서 서술하지는 않는다. 내가 여러 책들을 보고 또 구글링하면서 얻은 추가적인 정보들에 대해서 정리해 놓기 위한 것이다. 글 길이는 너무 길어지는 것은 피하겠지만(만약 쓰다가 너무 길어지면 글 2개로 나누려고 한다) 글마다 담고 있는 정보의 양이 다를 수밖에 없으므로 글 길이는 들쭉날쭉할 것이다.</p>\n<h1>2. \"Implicit int\" rule</h1>\n<p>C언어의 바이블 중 하나라고 꼽히는, 커니핸과 리치가 쓴 The C Programming Language에는 다음과 같은 예제 코드가 나온다. 굉장히 초반에 나오는 코드이다.</p>\n<pre><code class=\"language-c\"> #include &#x3C;stdio.h>\n\n main()\n {    \n     printf(\"hello, world\\n\");\n }\n</code></pre>\n<p>C언어를 조금 배워본 사람이라면 위 코드를 보고 이상하게 여길 것이다. main함수의 반환값 자료형이 없다는 이유에서이다. 심지어 main함수의 리턴값도 없다!</p>\n<p>다만 이는 C89표준에서는 문제없이 돌아간다. 그때 당시의 표준에서는 반환값 자료형이 명시되어 있지 않은 함수의 반환형은 암묵적으로 int로 받아들이도록 되어 있었다. 또한 꼭 함수 반환형만이 아니라 선언에서 타입 지정자를 아예 생략할 수도 있었다.</p>\n<p>이를 implicit int rule 이나 default to int rule이라고도 했다. 이러한 문법이 있었던 이유는 C언어의 조상격인 언어가 타입이 존재하지 않는 B 언어였으며 C언어의 초기에는 대부분의 코드들이 정수형만 다루었기 때문이다. 따라서 타입을 명시하지 않고도 프로그래머들 사이에서 암묵적으로 모든 것이 int로 통했고, 그래서 타입 지정자를 명시하지 않는 것이 편리함으로 다가오기도 했던 것 같다.</p>\n<p>그러나 이 문법은 C99 표준에서부터 폐기되었다. 이 문법이 만들어내는 위험이 편리함보다 더 크다고 위원회에서 판단했기 때문이다. 이 implicit int rule은 C가 타입이 없는 언어에서 강타입 언어로 넘어가는 과도기에 존재했던 문법 정도로 이해하면 될 것 같다. gcc등의 몇몇 컴파일러에서 해당 문법을 여전히 지원하고 위의 프로그램은 여전히 돌아간다. 그러나 이런 예전 코드를 이해하는 것 외에 새로운 C코드 작성시에는 꼭 함수의 반환형을 명시해 주자.</p>\n<h1>3. 참고</h1>\n<p><a href=\"https://stackoverflow.com/questions/8220463/c-function-calls-understanding-the-implicit-int-rule\">https://stackoverflow.com/questions/8220463/c-function-calls-understanding-the-implicit-int-rule</a></p>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/text/n661.txt\">http://www.open-std.org/jtc1/sc22/wg14/www/docs/text/n661.txt</a></p>",
    "excerpt": "1. C-through\nC에 관해 복습하면서 알게 되는 점들에 대해 서술하는 시리즈이다. 변수가 무엇이고 상수가 무엇이고 하는 C의 기본적인 문법에 대해서 서술하지는 않는다. 내가 여러 책들을 보고 또 구글링하면서 얻은 추가적인 정보들에 대해서 정리해 놓기 위한 것이다. 글 길이는 너무 길어지는 것은 피하겠지만(만약 쓰다가 너무 길어지면 글 2개로 나누려고 한다) 글마다 담고 있는 정보의 양이 다를 수밖에 없으므로 글 길이는 들쭉날쭉할 것이다.\n2. \"Impli",
    "headingTree": [
      {
        "title": "1. C-through",
        "url": "#1-c-through",
        "items": []
      },
      {
        "title": "2. \"Implicit int\" rule",
        "url": "#2-implicit-int-rule",
        "items": []
      },
      {
        "title": "3. 참고",
        "url": "#3-참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 68
    },
    "url": "/posts/c-through-1",
    "thumbnail": {
      "local": "/thumbnails/c-through-1-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-c-through-1-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAfklEQVR4nGNYvXp1Chh4e3svXbp0586d/8GAobe3V1JSUk1NjYODIysr69WrV79//wZJtLS0yMnJXbx48erVqzdu3IAoB0ns3LmjoaHhyJEjX758+Q0GUImVq9ZERkUlJiYuXbr06tWr////hxq1ZPnqBQsXbdm8GVn0////AMzWaJzn7zeXAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "c-through-2",
    "title": "C-through - 2. Unknown parameter",
    "date": "2022-01-10T00:00:00Z",
    "description": "C언어의 함수 선언/정의시 파라미터 자리를 비워 놓는 것에 대하여",
    "tags": [
      "language"
    ],
    "html": "<h1>1. 인자 없이 함수 선언하기</h1>\n<pre><code class=\"language-c\">#include &#x3C;stdio.h>\n\nvoid f();\n\nint main() {\n    f();\n    return 0;\n}\n\nvoid f(){\n    printf(\"Hello, I'm Witch\\n\");\n}\n</code></pre>\n<p>C를 배운 사람이라면 대부분 이 코드를 해석할 수 있을 것이다. 이 코드에 오류가 있을까?</p>\n<p>실행해 보면 딱히 아무 오류도 발생하지 않고 잘 실행된다. 나도 대부분 이렇게 C 코드를 작성해 왔다. 그런데, C언어의 함수를 선언할 때 인자를 아무것도 넣지 않는 것은 함수 인자에 대한 아무 정보도 주지 않는다는 것이라서, 함수가 인자를 받지 않는 것을 명시적으로 선언에 넣어 주기 위해서는 인자에 <code>void</code>를 넣어 줘야 한다는 말을 들었다. 다음과 같이 쓰는 게 더 좋다는 것이다.</p>\n<pre><code class=\"language-c\">#include &#x3C;stdio.h>\n\nvoid f(void);\n\nint main() {\n    f();\n    return 0;\n}\n\nvoid f(){\n    printf(\"Hello, I'm Witch\\n\");\n}\n</code></pre>\n<p>가능한 한 명시적으로 모든 것을 표현해 주는 게 더 나은 코드이므로, 이게 좋다는 것은 받아들일 수 있었다. 그런데 C에는 대체 왜 이런 기능이 있을까? 하는 의문이 들었다. C++의 경우 함수 선언시에 아무 인자도 넣어 주지 않아도 인자를 받지 않는 함수임을 명시적으로 뜻하게 된다. 그런데 왜 C에는 이런 쓸모없어 보이는 기능이 있는 것일까? 함수 선언시 인자를 넣어 주지 않는 것이 어디 쓰이는 걸까?</p>\n<p>탐구한 결과, C언어의 전신인 B언어는 타입이 없는 언어였고, B언어에서 넘어올 당시에는 함수의 인자 개수와 타입을 명시해 주는 함수 프로토타입 같은 건 없었다. C89 표준 이전의 이야기이다. 그때는 다른 방식의 함수 선언과 정의를 사용했다. 함수 선언시 인자를 넣어주지 않는 것은 그 당시의 방식이다. 그 방식으로 함수 선언을 작성한 코드와의 하위 호환성을 지키기 위해서 C 표준에서는 여전히 인자를 넣어 주지 않는 함수 선언 방식을 지원하고 있는 것이다.</p>\n<p>이러한 결과를 얻기 위해 공부하면서 얻게 된 지식들을 여기 간략하게 정리한다.</p>\n<h1>2. Identifier List 함수 선언</h1>\n<p>함수 선언시에 함수 인자를 주지 않으면, 함수 인자의 개수나 타입에 대해서 아무 정보도 주지 않는 것이라고 설명하였다. 따라서 어떤 인자든 함수 정의 시에 전달할 수 있다. 다음과 같은 코드는 <code>f</code>의 선언에서 인자가 명시되지 않았음에도 <code>f</code>의 함수 정의에서 인자를 정의한다. 그러나 잘 작동한다. <code>f</code>의 인자에 대한 정보가 선언부에서 알 수 없다는 말은 모든 것을 허용한다는 것이기 때문이다(C는 프로그래머에게 많은 것을 맡긴다).</p>\n<pre><code class=\"language-c\">#include &#x3C;stdio.h>\n\nint f();\n\nint main(void){\n    /* 실행 결과는 3이 잘 출력된다 */\n    printf(\"%d\\n\", f(1,2));\n    return 0;\n}\n\nint f(int x, int y){\n    return x+y;\n}\n</code></pre>\n<p>반면 <code>f</code>의 인자로 <code>void</code>를 명시하여 <code>f</code>가 인자를 받지 않는다는 것을 나타내어 준 다음 코드는 오류를 발생시킨다. <code>f</code>가 인자를 받지 않는다는 것을 선언부에서 명시해 주었는데도 <code>f</code>에 인자를 정의했기 때문이다.</p>\n<pre><code class=\"language-c\">#include &#x3C;stdio.h>\n\nint f(void);\n/* 이 코드는 오류를 발생시킨다 */\nint main(void){\n    printf(\"%d\\n\", f(1,2));\n    return 0;\n}\n\nint f(int x, int y){\n    return x+y;\n}\n</code></pre>\n<p>그런데 별로 쓸모없어 보이는, 인자를 아무것도 전달하지 않는 방식의 함수 선언으로만 함수를 선언할 수 있는 방식이 있다. 바로 C의 레거시 문법이라고 할 수 있는 Identifier List 함수 선언 방식이다. 당장 코드로 예시를 보자.</p>\n<pre><code class=\"language-c\">#include &#x3C;stdio.h>\n\nint f();\n\nint main(void){\n    /* 결과로 3이 출력된다 */\n    printf(\"%d\\n\", f(1,2));\n    return 0;\n}\n\nint f(x,y)\nint x; int y;\n{\n    return x+y;\n}\n</code></pre>\n<p>위와 같은 함수 선언과 정의 방식을 identifier list 방식이라고 부른다. 함수 선언 시에는 아무것도 인자로 넣어주지 않고, 함수 정의 시 인자 리스트에는 함수 인자의 이름들만 넣어 준 후 타입은 아래에서 지시한다. 그리고 중괄호 내부에서 인자들을 이용해 연산을 해주는 것이다.</p>\n<p>이는 예전에 C에서 함수 프로토타입 선언이 나오기 전에 쓰였던 방식이다. 타입 같은 게 없던 언어인 B에서 넘어오던 과도기에 쓰이던 방식인 것이다.</p>\n<h1>3. Identifier List 방식의 위험성과 흔적</h1>\n<p>이 방식은 함수에 적절한 타입과 개수의 인자가 전달되는지를 컴파일러에서 검사하지 않고, 온전히 프로그래머에게 맡긴다. 위의 코드에서는 딱 적절한 타입과 개수의 인자를 전달해 주었지만, <code>f(1,2,3)</code> 으로 함수를 호출해도, <code>f(1.5,2.0)</code> 으로 함수를 호출해도 잘 컴파일된다.</p>\n<p>그러나 함수에 실제 전달된 인자와 함수의 정의에서 사용하는 인자의 개수나 타입이 다를 때 표준은 아무것도 보장해 주지 않는다.</p>\n<pre><code class=\"language-c\">#include &#x3C;stdio.h>\n\nint f();\n\nint main(void){\n    /* 함수 호출 시 사용한 인자의 타입이 다르므로 결과로 아무 의미 없는 쓰레기값이 출력된다 */\n    printf(\"%d\\n\", f(1.5,2.0));\n    return 0;\n}\n\nint f(x,y)\nint x; int y;\n{\n    return x+y;\n}\n</code></pre>\n<p>만약 함수 프로토타입을 선언하고 함수 인자의 타입과 개수를 명시하여 함수를 정의하는 방식(이를 parameter list 방식이라고도 한다)으로 위와 같은 함수를 정의한다면, 묵시적인 형변환이 이루어지기 때문에 약간의 값 손실은 있을 수도 있지만 어느 정도 정상적인 범위의 값이 출력된다. 하지만 위와 같이, 그런 것을 쓰지 않고 예전 C의 방식대로 함수 선언을  할 경우 아주 이상한 결과가 나오게 된다.</p>\n<p>하지만 C에서 함수 프로토타입이 나오기 전에는 분명 쓰였던 방식이기에 표준에서는 이를 서술하고 있고, 이 방식의 함수 선언에 대해 이렇게 설명한다.</p>\n<pre><code>6.7.5.3 Function declarators(including prototypes)\nAn identifier list in a function declarator that is not part of a definition of that function shall be empty.\n</code></pre>\n<p>identifier list로 함수를 정의하는 경우, 그 선언부의 인자 리스트는 비워 두는 게 표준이다. 물론 <code>int f(int x, int y);</code> 와 같이 프로토타입으로 함수 선언을 해 주어도 코드는 작동하긴 하지만 이는 프로토타입을 사용해서 함수 선언을 해 주는 게 identifier list를 호환해 주기 때문일 뿐이다.</p>\n<p>이제 우리는 함수 선언부에서 인자 자리를 비워 두는 방식이 왜 존재하는지 알았다! 이는 C89 이전에 사용되던 함수 선언 방식의 흔적이다.</p>\n<p>그럼 대체 왜 이런 방식이 존재했을까 하는 의문이 들 수 있다. 스택오버플로우의 몇몇 답변을 요약하면 이렇다. 그때는 프로그래머가 더 빠르게 작업을 수행할 수 있는 방법을 제공하는 데에 언어의 초점이 맞춰져 있었기 때문이다. 그러기 위해서 프로토타입을 이용해서 컴파일 타임에 에러를 잡아내기 위한 방법 같은 걸 도입할 필요는 없었다.</p>\n<p>또한 당시에는 현재보다 컴퓨터의 메모리 제한 등이 훨씬 빡빡했는데, identifier list 방식으로 함수를 선언하고 정의하는 것이 메모리 관리 측면에서 더 효율적인 부분이 있었다고 한다. 지금에야 컴파일 타임에 더 많은 에러를 잡아내는 것이 훨씬 더 중요하게 여겨지지만 말이다.</p>\n<h1>4. 함수 정의에서 인자 자리 비워두기</h1>\n<p>그런데 함수 정의시에 인자 자리를 비워 놓으면 어떻게 될까? 이 경우에는 함수가 인자를 받지 않는다는 것을 명시적으로 의미해 준다.</p>\n<pre><code>C99 standard 6.7.5.3\nAn empty list in a function declarator that is part of a definition of that function specifies that the function has no parameters.\n</code></pre>\n<p>정의의 일부에서 함수 인자 리스트가 비어 있으면 인자를 받지 않는다는 걸 명시적으로 의미해 준다는 뜻이다. 그런데 이 경우 함수 호출시에 인자를 전달해 준다 해서 반드시 오류가 발생하는 것은 아니다. 가령 다음과 같은 코드는 clang으로 컴파일하면 오류가 발생하지만 gcc로 컴파일하면 오류가 발생하지 않는다.</p>\n<pre><code class=\"language-c\">#include &#x3C;stdio.h>\n\nint f(){\n    printf(\"Hello\\n\");\n    return 0;\n}\n\nint main(void){\n    /* gcc로 컴파일시 함수가 잘 동작한다. 그러나 표준에 보장되어 있는 것은 아니다 */\n    f(1,2,3);\n    return 0;\n}\n</code></pre>\n<p>만약 위의 함수 <code>f</code>가 프로토타입도 정의되어 있었다면 이야기가 다르다. C에서, 호출된 함수가 프로토타입을 갖는 경우 함수 호출시에 전달해준 인자(보통 argument라 한다) 개수와 함수 프로토타입의 인자(보통 prototype이라 한다) 개수가 일치해야 된다는 것을 표준에서 강제하기 때문이다. 그러나 호출된 함수가 프로토타입을 갖지 않는 경우, 함수 호출시 전달해준 인자 개수와 함수 정의에서의 인자 개수가 일치하지 않는 것은 표준에 정의되어 있지 않다.(undefined behavior라 한다)</p>\n<p>따라서 위 코드의 경우 환경에 따라 컴파일 시 오류를 발생시킬 수도 있고 안 발생시킬 수도 있다. 하지만 컴파일이 되더라도 어떤 동작을 할지 표준에서 정의할 수 없는 코드이므로 쓰지 않는 것이 좋다.</p>\n<p>다음과 같이 프로토타입에서 인자를 받지 않는다고 미리 선언해준 코드의 경우, 함수 호출시의 인자 개수가 너무 많다는 에러를 컴파일시 발생시키는 것을 관찰할 수 있다.</p>\n<pre><code class=\"language-c\">#include &#x3C;stdio.h>\n\nint f(void);\n/* 함수 선언 시 인자를 받지 않는다는 것을 명시해 주었다 */\nint main(void){\n    f(1,2,3);\n    return 0;\n}\n\nint f(){\n    printf(\"Hello\\n\");\n    return 0;\n}\n</code></pre>\n<h1>5. 결론</h1>\n<p>함수의 선언에서 인자의 자리를 비워 놓는 것은 예전의 C 문법의 유산이다. C언어에 프로토타입 같은 건 없던 시절에 함수 선언을 하기 위해서는 인자의 자리를 비워 놓아야 했기 때문이다.</p>\n<p>오늘날 인자가 없는 함수를 선언할 때는 인자가 없다는 것을 명시적으로 나타내 주기 위해 인자 자리에 <code>void</code>를 꼭 명시적으로 써넣어 주자. 함수 정의에는 굳이 <code>void</code>를 쓰지 않아도 인자가 없는 함수임을 뜻한다.</p>\n<h1>6. 참고</h1>\n<p><a href=\"https://stackoverflow.com/questions/693788/is-it-better-to-use-c-void-arguments-void-foovoid-or-not-void-foo\">https://stackoverflow.com/questions/693788/is-it-better-to-use-c-void-arguments-void-foovoid-or-not-void-foo</a></p>\n<p><a href=\"https://stackoverflow.com/questions/5481579/why-does-an-empty-declaration-work-for-definitions-with-int-arguments-but-not-fo\">https://stackoverflow.com/questions/5481579/why-does-an-empty-declaration-work-for-definitions-with-int-arguments-but-not-fo</a></p>\n<p><a href=\"https://stackoverflow.com/questions/12643202/why-does-gcc-allow-arguments-to-be-passed-to-a-function-defined-to-be-with-no-ar\">https://stackoverflow.com/questions/12643202/why-does-gcc-allow-arguments-to-be-passed-to-a-function-defined-to-be-with-no-ar</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/B_%28programming_language%29\">https://en.wikipedia.org/wiki/B_%28programming_language%29</a></p>\n<p><a href=\"https://stackoverflow.com/questions/4664100/does-printfx-1-invoke-undefined-behavior\">https://stackoverflow.com/questions/4664100/does-printfx-1-invoke-undefined-behavior</a></p>\n<p>(<code>C 표준 문서의 내용이 있다</code>)</p>\n<p><a href=\"https://stackoverflow.com/questions/18820751/identifier-list-vs-parameter-type-list-in-c\">https://stackoverflow.com/questions/18820751/identifier-list-vs-parameter-type-list-in-c</a></p>\n<p><a href=\"https://stackoverflow.com/questions/41803937/func-vs-funcvoid-in-c99\">https://stackoverflow.com/questions/41803937/func-vs-funcvoid-in-c99</a> (C 표준 관련한 설명이 아주 잘되어 있음)</p>\n<p><a href=\"http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.369.3559&#x26;rep=rep1&#x26;type=pdf\">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.369.3559&#x26;rep=rep1&#x26;type=pdf</a></p>\n<p>실제 C 표준 문서 중 일부</p>",
    "excerpt": "1. 인자 없이 함수 선언하기\n#include <stdio.h>\n\nvoid f();\n\nint main() {\n    f();\n    return 0;\n}\n\nvoid f(){\n    printf(\"Hello, I'm Witch\\n\");\n}\n\nC를 배운 사람이라면 대부분 이 코드를 해석할 수 있을 것이다. 이 코드에 오류가 있을까?\n실행해 보면 딱히 아무 오류도 발생하지 않고 잘 실행된다. 나도 대부분 이렇게 C 코드를 작성해 왔다. 그런데, C언어의 함수를 선언할",
    "headingTree": [
      {
        "title": "1. 인자 없이 함수 선언하기",
        "url": "#1-인자-없이-함수-선언하기",
        "items": []
      },
      {
        "title": "2. Identifier List 함수 선언",
        "url": "#2-identifier-list-함수-선언",
        "items": []
      },
      {
        "title": "3. Identifier List 방식의 위험성과 흔적",
        "url": "#3-identifier-list-방식의-위험성과-흔적",
        "items": []
      },
      {
        "title": "4. 함수 정의에서 인자 자리 비워두기",
        "url": "#4-함수-정의에서-인자-자리-비워두기",
        "items": []
      },
      {
        "title": "5. 결론",
        "url": "#5-결론",
        "items": []
      },
      {
        "title": "6. 참고",
        "url": "#6-참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 380
    },
    "url": "/posts/c-through-2",
    "thumbnail": {
      "local": "/thumbnails/c-through-2-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-c-through-2-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAhklEQVR4nD3MoQ0DIRhA4WMLBkAxABbLBCSsgCMhwVwlHoHqhTZNikDgWAWPZAfE31x76bNf8racs5RSKcU5DyGUUuDbdtt3jDFjDCHUWptzrrVOsNYSQiiljLEYIwBckPNbSumcU0p573+fE+5HEkJorY0xMcYxxgVHeqXHs9bae/9/AOADZ61cqk95MQwAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "callstack-and-async",
    "title": "콜스택과 비동기 프로그래밍",
    "date": "2023-07-26T00:00:00Z",
    "description": "What Color is Your Function?을 읽고",
    "tags": [
      "study",
      "CS"
    ],
    "html": "<h1>0. 개요</h1>\n<p>유명한 글인 <a href=\"http://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/\">What Color is Your Function?</a>과 <a href=\"https://news.ycombinator.com/item?id=8984648\">해당 글에 대한 토론</a>을 읽고 작성한 글이다.</p>\n<p>개인적으로 비동기 프로그래밍의 어려움이 콜스택 관리에서 오며 이는 쉽게 해결 가능한 문제가 아니라는 것이 이 글의 시사점이라 생각한다.</p>\n<p>원 글의 저자는 Ruby, Dart 등의 언어에 매우 익숙하기 때문에 원 글에서는 이런 언어들을 예시로 들고 있다. 하지만 JS, Python 등 내가 알고 있고 좀더 유명하기도 한 언어로 예시를 바꾸어 작성하도록 노력하였다.</p>\n<p>그리고 나는 개인적으로 이 글의 논지 전부에 동의하지는 않는다. <a href=\"https://blainehansen.me/post/red-blue-functions-are-actually-good/\">Red &#x26; blue functions are actually a good thing</a>과 같이 동기와 비동기를 명확히 구분할 수 있는 것이 더 좋다는 것에 동의하는 편이다. 하지만 이 글에서 주장하는 바도 충분히 시사점이 있다고 생각하여 블로그에 남긴다.</p>\n<h1>1. 비동기의 전염성</h1>\n<p>이런 JS 코드를 작성한다고 해보자. A, B, C는 잘 출력되고 아무 문제도 없다.</p>\n<pre><code class=\"language-js\">function A(){\n  return \"A\";\n}\n\nfunction B(){\n  console.log(A());\n  return \"B\";\n}\n\nfunction C(){\n  console.log(B());\n  return \"C\";\n}\n\nconsole.log(C());\n/* \nA\nB\nC\n콘솔 출력\n*/\n</code></pre>\n<p>그런데 만약 이렇게 연쇄적으로 호출되는 함수의 콜체인 중 <code>B</code>함수에서 비동기로 동작하는 <code>fetchData</code>함수의 데이터를 사용하게 되었다고 하자. 그럼 B는 데이터 페칭을 위해 비동기 작업을 포함하도록 바뀐다. 그리고 C에서 B의 결과물을 사용하기 위해서는 C도 비동기 함수가 되어야 한다. 그럼 전체적으로 다음과 같은 코드가 된다.</p>\n<pre><code class=\"language-js\">async function B(){\n  console.log(A());\n  const data=await fetchData();\n  return data;\n}\n\nasync function C(){\n  someJob(await B());\n  return \"C\";\n}\n</code></pre>\n<p>만약 <code>C()</code>의 결과를 <code>D()</code>에서도 사용해야 한다면 <code>D()</code>는 또 <code>C()</code>를 사용하기 위해서 비동기 함수가 되고...이런 비동기 함수의 전염성은 계속되어 간다. 비동기 함수는 비동기 함수 내부에서만 호출될 수 있기 때문이다. 서버 데이터 페칭 하나를 위해서 대체 몇 개의 함수가 비동기가 되어야 하는 것인지 알 수조차 없다.</p>\n<p>이런 문제는 Promise를 사용해도 마찬가지고, JS에서는 무엇을 써도 마찬가지다(Web Worker가 있긴 하지만, 싱글스레드 환경에서는 그렇다는 이야기다).</p>\n<p><code>B()</code>의 비동기성은 결국 전염된다. 비동기 함수의 결과를 사용한다면, 해당 코드가 완결될 때까지 비동기 함수의 결과를 기다려야 하기 때문이다.</p>\n<pre><code class=\"language-js\">async function B(){\n  console.log(A());\n  const data=await fetchData();\n  return data;\n}\n\nasync function C(){\n  console.log(await B());\n  return \"C\";\n}\n\nasync function D(){\n  console.log(await C());\n  return \"D\";\n}\n// ...\n</code></pre>\n<p>이 문제는 어떤 패러다임이나 개발자의 실력 문제가 아니고, 특정 라이브러리나 방법론을 통해서 깔끔하게 해결할 수 있는 것도 아니다.</p>\n<p>이는 재사용될 수 있는 함수들로 프로그램을 구성하고, 그 결과들을 또 다른 함수에서 사용하는 기본적인 프로그래밍 방법에서 발생하는 문제이기 때문이다. <a href=\"https://www.rinae.dev/posts/why-every-beginner-front-end-developer-should-know-publish-subscribe-pattern-kr\">비동기 코드를 적절하게 배치하는 일은 지금도, 앞으로도 결코 간단하지 않을 것이다.</a></p>\n<p><img src=\"/static/async-reality-dcb4c0cc.png\" alt=\"비동기 처리의 어려움\"></p>\n<h1>2. 원인</h1>\n<p>그러나 우리는 그럼에도 무언가 해야 한다. 그렇다면 가장 먼저 해야 할 일은 근본적인 원인의 탐구이다. 왜 JS에서 비동기 함수는 전염될 수밖에 없는가? 해결 방안을 알기 위해서는 원인을 알아야 한다.</p>\n<p>먼저 비동기 함수를 다음과 같이 정의하자. Promise를 쓰거나 하는 것이 비동기 함수의 조건은 아니다. (async/await은 비동기를 동기처럼 쓸 수 있게 해줌으로써 다음 조건들 중 몇몇을 완화하고 동기처럼 쓸 수 있도록 해주지만 지금은 생각하지 말자.)</p>\n<ul>\n<li>비동기 함수는 그 결과를 비동기적으로 반환하는 함수이다.</li>\n<li>동기 함수는 값을 반환하지만 비동기 함수는 값을 반환하지 않고 콜백을 실행한다.</li>\n<li>즉 동기 함수는 값을 통해서 결과를 전달하지만 비동기 함수는 콜백을 실행하는 것을 통해서 결과를 전달한다.</li>\n</ul>\n<p>이러한 점 때문에 비동기 함수는 에러 핸들링이나 다른 여러 제어 흐름에 사용될 수 없다.</p>\n<h2>2.1. 비동기 작업의 맥락 유지</h2>\n<p>근본적인 이유는 JS가 싱글스레드이고 따라서 프로그램이 실행되고 있는 환경을 저장할 콜스택이 하나밖에 없기 때문이다.</p>\n<p>그럼 싱글스레드가 왜 문제일까? 예를 들어서 다음과 같은 코드를 생각해보자. 비동기 작업을 하는 <code>asyncJob</code>이라는 함수가 있다. 이 함수는 비동기 작업을 하고 그 결과물을 반환한다. 그리고 그 결과물은 <code>useAsyncJobResult</code>라는 함수에서 사용된다.</p>\n<pre><code class=\"language-js\">A()\nconst data=asyncJob();\nuseAsyncJobResult(data);\nB();\nC();\n</code></pre>\n<p>하지만 <code>useAsyncJobResult</code>에서 <code>data</code>를 사용하는 시점에 <code>asyncJob</code>은 완료되어 있을까? 당연하게도 비동기 작업과 그 뒤에 진행될 동기 작업의 순서가 꼬일 가능성이 높다. 운좋게 경쟁 상태에서 잘 처리되어서 우리가 원하는 대로 될 수도 있겠지만, 보장되는 것은 전혀 아니다.</p>\n<p><img src=\"/static/callstack-ideal-and-real-ce0913bf.png\" alt=\"콜스택 이상과 현실\"></p>\n<p>그럼 우리는 어떻게 해야 하는가? <code>asyncJob</code>이 완료될 때까지 메인 스레드를 블로킹할 수 있겠다. 실제로 이렇게 한다는 건 아니지만 그냥 비유적인 표현이다.</p>\n<pre><code class=\"language-js\">A()\nconst data=asyncJob();\nblockUntilAsyncDone();\nuseAsyncJobResult(data);\nB();\nC();\n</code></pre>\n<p>하지만 이렇게 하면 이미 비동기가 아니다. 그리고 B나 C같은 비동기 함수의 결과물을 사용하지 않는 함수들도 영향을 받아 버린다. 또한 fetch같은 진짜 비동기 내장 함수들을 제대로 다룰 수 있는 방식도 아니다.</p>\n<p>그럼 어떻게 해야 하는가? 우리가 근본적으로 해야 할 일은 <code>asyncJob()</code>과 그것이 완료된 후 진행해야 할 작업인 <code>useAsyncJobResult(data)</code>사이의 순서를 보장하고 나머지 부분은 영향을 받지 않도록 하는 것이다.</p>\n<p>이를 실현하기 위해서는 <code>asyncJob()</code>이 호출되는 시기의 환경(정확히는 콜스택)을 보존하고 해당 비동기 작업이 완료되는 시점에 그 환경을 다시 불러와서 비동기 작업의 결과물을 사용하는 작업을 진행해야 한다. 왜 환경을 보존해야 하는지는 다음과 같은 코드를 통해 알 수 있다.</p>\n<pre><code class=\"language-js\">A();\nlet dataForJob=someData;\nconst data=asyncJob();\nuseAsyncJobResult(data);\ndataForJob=otherData;\nB();\nC();\n</code></pre>\n<p>만약 이 환경을 보존하지 않고 <code>asyncJob</code>, <code>useAsyncJobResult</code>만 비동기로 어떻게 만들어서 사용한다고 하면 <code>useAsyncJobResult</code>가 실행되는 시점에 <code>dataForJob</code>이 변경되어 있을 수도 있다. 하지만 그러면 안된다! 따라서 비동기 작업들이 실행되는 환경을 보존해 놓고 비동기 작업이 완료되는 시점에 다시 불러오는 것은 필수적이다.</p>\n<p>그런데 <strong>어떻게?</strong> 앞서 말했듯이 JS는 싱글스레드이고 콜스택이 하나뿐이다. 원래 이런 환경은 스레드에서 보존하는데 대체 메인 스레드 외에 <strong>어디서</strong> 이를 보존할 것인가? 콜백을 이용할 수 있다. '비동기 작업이 완료된 후 진행되어야 할 작업에 필요한 환경'들을 콜백을 이용해 모두 하나의 함수에 탑재되도록 하는 것이다.</p>\n<p>달리 말하면 JS에서는 이런 실행 환경을 저장할 수 있는 콜스택이 하나밖에 없다는 점을 극복하기 위해 '비동기 작업 이후에 진행할 코드의 실행 환경'을 콜백 함수를 통해 개발자가 직접 설정해 주는 것이다.</p>\n<pre><code class=\"language-js\">A();\n/* 비동기 작업 완료시 실행시킬 함수를 콜백으로 받는다 */\nasyncJob(function(data){\n  useAsyncJobResult(data, function(secondData){\n    //...\n  });\n});\nB();\nC();\n</code></pre>\n<p>JS의 Promise가 왜 나왔는지에 대해서 검색해 본다면 반드시 나오는 말인 '콜백 지옥'이 바로 여기서 기인한다. 예전에는 비동기 처리에 콜백만을 썼는데 이러다가 콜백 지옥이 생겼고 Promise를 쓰면 콜백 지옥을 해결할 수 있고 신뢰성도 늘어나고...하는 말들은 유명하다.</p>\n<p>아무튼 이렇게 콜백을 통해서 비동기 작업 환경을 보존해 주는 방법으로 인해서 엄청난 콜백의 연쇄가 만들어지게 된다. 진짜 콜백 지옥 코드라면 아마 저기에 errorback 함수도 들어가 있겠지만 콜백 지옥 해설이 목적이 아니므로 넘어가자.</p>\n<pre><code class=\"language-js\">A();\n/* 비동기 작업 완료시 실행시킬 함수를 콜백으로 받는다 */\nasyncJob(function(data){\n  useAsyncJobResult(data, function(secondData){\n    useAsyncJobResultOther(data, function(someData){\n      // ...\n    });\n    //...\n  });\n});\nB();\nC();\n</code></pre>\n<p>아마 해당 콜백 함수들의 내부는 이런 식으로 비동기 처리가 되어 있을 것이다. Eventemitter나 커스텀 이벤트를 사용해서 더 똑똑하게 비동기 완료를 감지할 수도 있겠으나 이게 주제가 아니므로 적당히 했다.</p>\n<pre><code class=\"language-js\">function useAsyncJobResult(data, callback){\n  setTimeout(function(){\n    callback(data);\n  }, 100);\n}\n</code></pre>\n<p>이렇게 하면 비동기 작업의 실행 환경을(적어도 비동기 완료 이후 실행할 작업에 필요할 환경 정보들을) 보존할 수 있다. 아래와 같은 코드에서 만약 <code>asyncWrapper</code>가 <code>asyncJob</code>과 그 콜백보다 먼저 종료되더라도 <code>asyncJob</code> 내부에서 콜백이 실행될 때는 함수 인수를 통해 <code>data</code>내용이 힙에 보존되어 있고 이는 <code>useAsyncJobResult</code>에 전달된다. 우리가 원하는 비동기 작업 실행 -> 그 결과물을 이용한 작업의 순서가 보장되었고 당연히 이는 전부 비동기로 처리되기 때문에 다른 부분에 영향을 주지도 않는다.</p>\n<pre><code class=\"language-js\">function asyncWrapper(){\n\n  // do something\n\n  asyncJob(function(data){\n    useAsyncJobResult(data, function(secondData){\n      //...\n    });\n  });\n}\n</code></pre>\n<p>이런 실행 환경의 보장을 위해서는 당연히 비동기 함수가 전염되어야 한다. 만약 <code>asyncJob</code>의 결과물을 가공하는 함수들의 체인이 있다면 그것들은 모두 <code>asyncJob</code>의 인수로 넘어가는 콜백 내부의 콜백 내부의 ... 내부의 콜백이 되어야 할 것이다.</p>\n<p>이는 <a href=\"http://dogfeet.github.io/articles/2012/by-example-continuation-passing-style-in-javascript.html\">continuation-passing style</a>이라고 불리는 기존 패턴과 비슷한데 실제로 컴파일러에서 코드를 최적화할 때 사용하는 방식이다. (C#의 <code>.NET</code>의 경우 컴파일러에서 await을 이런 continuation-passing style로 변환하기 때문에 따로 await에 대한 런타임 지원이 없다고 한다)</p>\n<p>하지만 이는 너무 복잡하다. Node에서도 이런 continuation-passing style방식을 쓰긴 하지만 개발에서 많이 쓰이지 않는 방식인 이유이다.</p>\n<p>더 큰 문제는 복잡성도 복잡성이지만, 이런 환경 전달의 복잡성이 근본적으로 싱글스레드에서는 쉽게 해결할 수 없는 문제라는 것이다.</p>\n<p>콜스택이 하나뿐이라 비동기 함수가 완료된 후 실행되어야 할 콜백과 해당 콜백이 가져야 할 환경을 개발자가 직접 콜백의 연쇄 호출을 통해 하나하나 설정해 줘야 한다는 게 근본적인 원인이기에, 개발자는 어떤 변수가 힙에 남아 있어야 하고 어떤 맥락이 비동기 함수 완료시 남아 있어야 하는가를 직접 설정해 줘야 한다. 이를 따져주며 콜백을 만드는 개발자의 머리가 터져나가는 소리가 과거에서 들려오는 것 같다.</p>\n<p>음, 전통적인 콜백보다 나은 것은 없을까? 무언가 이런 비동기 작업의 실행환경 보장을 좀더 깔끔하게 해줄 수 있는 무언가가...?</p>\n<h2>2.2. Promise와 async</h2>\n<p>이를 개선하기 위해 나온 것이 Promise이다. Promise가 이런 복잡성의 해결을 위해서만 나온 건 아니지만 Promise 역시 이 글의 주제가 아니므로 깊이 다루지는 않겠다. 그냥 문제를 좀 완화시켰다는 것 정도만 쓰고 넘어가자. Promise를 사용해 함수들을 변경했다는 가정 하에 다음과 비슷하게 변할 것이다.</p>\n<pre><code class=\"language-js\">A();\nasyncJob().then((data)=>{\n  useAsyncJobResult(data);\n});\nB();\nC();\n</code></pre>\n<p>혹은 좀더 현대 문법인 async/await을 사용할 수도 있겠다. Top-level await인지 아닌지는 여기서 그렇게 중요한 게 아니다. top-level await이 싫다면 이 코드도 그냥 어떤 async 함수 내부에 있다고 생각하면 된다.</p>\n<pre><code class=\"language-js\">A();\nconst data=await asyncJob();\nuseAsyncJobResult(data);\nB();\nC();\n\n/* 이는 논리적으로 사실 다음과 같다. */\nA();\nasyncJob().then((data)=>{\n  useAsyncJobResult(data);\n  B();\n  C();\n})\n</code></pre>\n<p>await이 실제로 작동하는 방식을 생각하면 이는 Promise의 then을 사용하는 코드와 큰 차이는 없지만 어쩐지 동기와 비동기의 진행 방향이 비슷해진 것 같다.</p>\n<p>그런데 이건 결국 상황을 약간 낫게 할 뿐 근본적으로 해결할 수 없는 미봉책이다. <a href=\"https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/\">What color is your function?</a>\n에서는 심지어 이들을 약장수의 약 같은 걸로 비유되는 snake oil로 표현하고 콜백 대신 이걸 사용해서 비동기를 처리하는 것은 배를 맞거나 성기를 맞거나 둘 중 하나를 선택하는 급의 일일 뿐이라고 한다.</p>\n<p>왜 그런가? Promise를 사용하더라도 비동기 함수의 완료 이후 실행되어야 할 작업의 맥락은 그 수단이 콜백 지옥이 아니다 뿐이지 직접 <code>then</code>을 통해 전해줘야 하기 때문이다. 그리고 async/await은 Promise를 내부적으로 숨겨서 비동기 함수를 마치 동기의 맥락에 있는 것처럼 사용하게 해줄 뿐이지 근본적인 문제 해결이 아니기 때문이다.</p>\n<p>실제로 하나의 await만 함수의 콜체인에 있어도 비동기 함수의 상위 함수들은 모두 비동기가 되지 않는가? 이런 것들을 생각해보면 위의 비유는 극단적이기는 하지만 근본적인 문제 해결을 하지 못한다는 것은 분명하다.</p>\n<h2>2.3. 비동기 전염성을 그냥 없애 버린다면?</h2>\n<p>약간 다르게 접근해서, JS의 싱글스레드 환경에서 비동기 함수가 전염되지 않는 상황을 가정하고 비동기가 필요한 작업을 한다고 생각해보자. <code>asyncJob</code>이라는, 비동기 함수(<code>fetch</code>)를 사용하는 함수를 생각한다. 다음과 같은 코드가 될 것이다.</p>\n<pre><code class=\"language-js\">function asyncJob(){\n  const data=fetch(\"https://example.com\");\n  /* fetch의 결과물을 사용하는 작업 */\n}\n</code></pre>\n<p>JS에서 비동기 함수를 사용할 때는 일반적으로 해당 함수의 결과를 사용해서 실행해야 하는 코드가 있기 마련이므로 fetch 이후에는 해당 결과를 사용하는 작업이 있다고 가정했다. 예를 들어서 서버에서 데이터를 가져온 후 그걸 화면에 보여주는 작업이라든지.</p>\n<p>그러면 <a href=\"https://stackoverflow.com/questions/44894691/why-await-requires-async-in-function-definition\">비동기는 호출 스레드를 블로킹하지 않으므로</a> fetch 다음에 오는 <code>asyncJob</code> 내부 코드는 바로 실행된다.</p>\n<p>하지만 이렇게 하면 fetch의 결과물을 사용하는 작업은 제대로 진행될 수 없다. 해당 작업이 실행되는 시점에 fetch의 결과물이 존재한다는 보장이 안 되기 때문이다. 비동기 처리는 잘 되었지만 우리는 그걸로 아무것도 제대로 할 수가 없다!</p>\n<p><img src=\"/static/async-without-await-b9ca965b.png\" alt=\"await 없는 비동기\"></p>\n<p>그럼 이제 다음처럼 바꿀 수 있다고 해보자. await을 이용해서 fetch를 기다리고 따라서 return 이전에 fetch가 완료된다는 것을 보장하였다. 비동기의 전염성은 여전히 없다고 가정하므로 <code>asyncJob</code>함수는 async를 붙이지 않는다.</p>\n<pre><code class=\"language-js\">function asyncJob(){\n  const data=await fetch(\"https://example.com\");\n  /* fetch의 결과물을 사용하는 작업 */\n  return resultFromJob;\n}\n</code></pre>\n<p>그런데 위 코드에 있는 <code>fetch의 결과물을 사용하는 작업</code>부분은 어디서 실행되어야 하는가? 그 작업 또한 JS코드일 것이므로 JS 런타임의 하나뿐인 메인 스레드에서 실행되어야 한다. 따라서 <code>asyncJob</code>함수에서는 <code>fetch</code>가 끝날 때까지 메인 스레드를 블로킹해야 한다.</p>\n<p>그리고 이 함수를 다음과 같은 코드에서 쓴다고 가정하자. <code>asyncJob</code>의 결과물을 <code>B()</code>함수에서 사용하고 있다.</p>\n<pre><code class=\"language-js\">A();\nconst data=asyncJob();\nB(data);\n</code></pre>\n<p>하지만 <code>B()</code>에서 <code>asyncJob</code>의 결과물을 사용하기 위해서는 비동기 연산을 포함하는 <code>asyncJob</code>이 끝나기를 기다려야 한다. 엔진 쪽에서 이를 알 수 있을까? 없다. 따라서 우리는 <code>asyncJob</code> 호출에도 await을 붙여서 해당 함수에는 비동기 작업이 있으며 우리는 그것이 끝날 때까지 기다려야 한다는 것을 알려줘야 한다.</p>\n<pre><code class=\"language-js\">A();\nconst data=await asyncJob();\nB(data);\n</code></pre>\n<p><code>asyncJob</code>내부의 비동기성이 전염되고 있는 것을 볼 수 있다. 싱글스레드에서는 이런 전염성이 있을 수밖에 없는 것이다.</p>\n<h2>2.4. 여담 - 왜 async를 쓰는가?</h2>\n<p>그런데 JS를 아는 사람이라면 위 글을 읽다가 의문이 들 수 있다. 우리는 지금까지 JS를 하면서 비동기 함수를 사용할 때 async를 붙여서 사용했다.</p>\n<p>하지만 위의 예시에서 async는 코빼기도 보이지 않는다. 그렇게 썼다고 해서 크게 이상한 것도 없지 않은가? await을 사용해서 비동기 함수를 기다렸고 해당 작업이 완료된 후에는 비동기 함수 결과물을 사용하는 작업을 진행할 수 있었다.</p>\n<p>그러면 우리는 왜 JS에서 async 함수 내부에서만 await을 쓰는 것일까? 몇 가지 이유가 있다.</p>\n<p>첫번째는 성능상의 이유다. 만약 우리가 위의 예시처럼 await을 사용한다고 하자.</p>\n<pre><code class=\"language-js\">function asyncJob(){\n  const data=await fetch(\"https://example.com\");\n  /* fetch의 결과물을 사용하는 작업 */\n  return resultFromJob;\n}\n\nA();\nconst data=await asyncJob();\nB(data);\n</code></pre>\n<p>그럼 우리는 await이 기다리는 작업이 끝날 때까지 메인 스레드를 블로킹해야 한다(JS는 싱글스레드 언어니까). fetch가 끝날 때까지 기다리고, 또 fetch의 결과물을 사용하는 작업이 끝나고 <code>asyncJob</code>에서 결과를 리턴할 때까지 메인스레드는 기다려야 한다.</p>\n<p>async를 사용하면 어떻게 되는데? 또 async가 시작되지...가 아니라 Promise가 리턴되게 된다.</p>\n<pre><code class=\"language-js\">async function asyncJob(){\n  const data=await fetch(\"https://example.com\");\n  /* fetch의 결과물을 사용하는 작업 */\n  return resultFromJob;\n}\n\n/* 위 함수는 다음과 같이 동작하게 된다. */\nfunction asyncJob(){\n  return fetch(\"https://example.com\").then((data)=>{\n    /* fetch의 결과물을 사용하는 작업 */\n  });\n}\n</code></pre>\n<p>따라서 fetch가 끝나면 진행할 작업을 마이크로태스크 큐로 넘김으로써 fetch가 진행되는 동안 메인 스레드가 블로킹되지 않도록 할 수 있다. 이는 성능상의 이점이 있다.</p>\n<p>물론 이런 처리를 직접 해줌으로써 async를 쓰지 않고도 비동기 작업 동안 메인스레드의 블로킹을 막을 수 있다. 하지만 async 키워드를 쓰면 이런 작업을 쉽게 할 수 있고 실수 가능성도 줄어든다. 비동기 처리가 연쇄되다 보면 위처럼 직접 Promise를 사용하다가는 실수할 가능성이 높아질 수밖에 없다.</p>\n<p><a href=\"https://stackoverflow.com/a/39384160\">왜 async를 함수에 붙여야 하는가에 대한 스택오버플로 답변에서는 더 복잡해지는 예시를 제공하고 있다.</a></p>\n<pre><code class=\"language-js\">async function test() {\n  const user = await getUser();\n  const report = await user.getReport();\n  report.read = true\n  return report;\n}\n\n/* 위 함수는 다음과 같이 동작하게 된다. */\nfunction test() {\n  return getUser().then(function (user) {\n    return user.getReport().then(function (report) {\n      report.read = true;\n      return report;\n    });\n  });\n}\n</code></pre>\n<p>이런 코드를 작성하면서 실수하지 않기는 쉽지 않을 것이다.</p>\n<p>await을 async 함수 내부에서만 써야 하는 두번째 이유는 후방 호환성을 위해서이다. ES2017 이전에는 <code>await</code>이 JS의 키워드가 아니었다.</p>\n<p>따라서 <code>await</code>을 그냥 도입할 시 이전에 <code>await</code>을 변수명 등으로 썼던 코드들은 모두 에러를 일으키게 될 것이었다. <a href=\"https://www.npmjs.com/package/asyncawait\">실제로 await키워드를 핵심적으로 사용했던 라이브러리도 있었다.</a></p>\n<p>이런 문제를 해결하기 위해 JS에서는 <code>async</code>라는 키워드를 도입하고 <code>await</code>은 <code>async</code>함수 내부에서는 식별자가 아니라 예약어로 취급하도록 하여 이전 코드와의 호환성을 유지한 것이다.</p>\n<p>JS에서 async/await을 도입하기 이전에 C#에서 해당 키워드를 도입했기 때문에 영향을 받았다는 주장도 있는데, 물론 키워드를 따라했을 수는 있다. 하지만 <a href=\"https://www.sysnet.pe.kr/2/0/11129\">C#에서 async 키워드를 도입한 이유도 근본적으로는 await을 식별자가 아니라 예약어로 취급하라는 정보를 프로그램 실행시 제공하는 것이었다.</a></p>\n<p><a href=\"https://stackoverflow.com/questions/44184006/js-async-await-why-does-await-need-async\">또한 원래 async는 await을 식별자로 처리하도록 하기 위한 키워드였을 뿐이므로 처음에는 이름도 async가 아니라 <code>function^ foo(){}</code>와 같이 <code>^</code>를 사용해서 함수에 표시하는 것이었다.</a></p>\n<p>그리고 세번째의 작은 이유가 하나 더 있다. async는 JS 파서에 비동기 함수에 대한 단서(marker)를 제공한다. 이 함수는 비동기로 작동하며 함수의 종료까지 좀 시간이 걸릴 수 있다는 걸 알려주는 것이다.</p>\n<p>async가 있으면 파서에서는 어떤 함수가 비동기인지 결정하기 위해서 해당 함수를 전부 검토하는 것이 아니라 async 키워드가 붙은 함수를 비동기로 분류하면 되고 이는 파싱 성능을 향상시킨다.</p>\n<h1>3. 비동기 전염성 문제 해결?</h1>\n<p>그럼 이렇게 비동기 함수의 결과 사용 하나를 위해서 그걸 감싸는 모든 함수가 비동기가 되어야 하는 이런 비동기의 전염성 문제를 어떻게 해결할 수 있을까?</p>\n<p>Promise나 async/await은 앞서 보았듯이 근본적인 문제를 해결할 수 없다. 근본적인 문제는 함수의 실행 맥락 유지이기 때문이다.</p>\n<h2>3.1. 해결 가능한가?</h2>\n<p>이런 문제가 없는 언어가 있는가? 부터 살펴봐야 하겠다. 있다. java의 non-blocking IO나 C#의 <code>Task&#x3C;T></code>와 같은 것들을 보면 이런 비동기의 전염성 문제가 없다. Go에서는 고루틴을, Ruby에서는 fiber, Lua는 coroutine을 사용하여 이런 비동기 전염성 문제를 해결한다.</p>\n<p>그럼 위 언어들의 공통점은 뭘까? 멀티스레딩을 한다, 더 정확하게는 여러 독립적인 콜스택이 있고 그들 간에 스위칭이 가능하다는 것이다.</p>\n<p>이렇게 하면 모든 함수의 실행이 병렬로 진행되고 결과값을 가지고 스레드끼리 통신하여 결과를 합칠 수 있다. 이렇게 하면 비동기 함수의 전염성 문제는 해결된다.</p>\n<p>핵심은 스레드가 여러 개라는 게 아니라 멀티스레딩으로 인해 콜스택이 여러 개라서 이들간의 스위칭이 가능하다는 것이다. 비동기 함수와 그 이후 작업에 대한 맥락이 저장된 콜스택을 따로 둘 수 있기 때문에 이런 비동기 함수 전염성 문제가 해결된 것이다.</p>\n<h2>3.2. 멀티스레드가 답은 아니다 - 그럼?</h2>\n<p>여기부터는 원 글의 생각이라기보다는 <a href=\"https://news.ycombinator.com/item?id=8984648\">와이콤비네이터 페이지에 올라온 해당 글의 댓글창</a> 내용을 나의 선호대로 정리하여 작성하였다.</p>\n<p><a href=\"https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/\">What Color is Your Function?</a>에서는 Go와 같은 언어를 답으로 제시하고 있다.</p>\n<p>Go는 모든 작업이 비동기로 흘러가고 많은 스레드를 통해서 이 비동기 작업들을 관리한다. 고루틴을 통해서 모든 함수에서 이를 제어하는 것도 가능하다.</p>\n<p>따라서 모든 함수에서 동기함수와 비동기 함수 실행이 가능하고 비동기 함수의 전염성은 없다. 모든 작업이 비동기고 채널을 통해 각 스레드간의 통신을 하며 내부적으로는 async/await을 사용중이기 때문이다. 즉 모든 작업이 비동기지만 동기처럼 보이게 된다.</p>\n<p>현대의 많은 언어들이 모든 작업을 비동기로 처리하도록 한 후 내부적으로 async await을 심어두고 외부에는 이를 숨기는 이런 방법을 택하고 있다.</p>\n<p>하지만 요즘 장치들의 성능이 좋아져서 문제가 없어 보이지만 스레드는 결국 제한된 자원이며 생성과 스위칭 비용이 큰 자원이다. 그리고 동기화도 되어야 한다. 멀티스레드가 장점만 있지 않다는 건 기본적인 CS과목에도 나오지 않는가? 운영체제에 나오는 그 멀티스레딩이 진짜 이 비동기의 전염성에 대한 해답일까? 진짜?</p>\n<p><a href=\"https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/\">What Color is Your Function?</a>의 저자인 Bob Nystrom의 머릿속에 들어가 볼 수는 없지만, OS에 나오는 그 멀티스레딩을 해법으로 제시한 건 아니라고 본다. 글에서 제안하는 현존 최고의 솔루션이 Go의 고루틴이며, 이런 글을 쓸 정도의 사람이 운영체제 멀티스레딩에서의 문제들에 대해 아예 모를 리는 없는데 스레드의 생성에 대해서는 전혀 언급하지 않고 있다는 점에 주목해야 한다고 본다.</p>\n<p>Bob이 실제로 원하고 있는 것은 진짜 스레드가 아니라 콜스택 환경의 스위칭이다. Go언어는 실제 운영체제의 스레드를 여러 개 쓰는 게 아니다. 좀 더 경량이고 생성, 스위칭 비용이 적은 그린 스레드를 사용하며 고루틴은 그보다도 더 경량이다.</p>\n<p>심지어는 진짜 콜스택이 여러 개 있을 필요도 없다. 해당 글의 멀티스레딩에 대한 제안은 진짜 그 뜻인 게 아니라 문법적인 것이므로(his concern is syntactic, not semantic)만약 스레드를 만드는 것처럼 보이지만 실제로는 CPS로 컴파일되어서 콜스택 여러 개 없이도 비동기 함수의 전염성 문제를 해결할 수 있다면 Bob은 분명 좋아할 것이다.</p>\n<pre><code>Since he's a Go fan, he might prefer lightweight threads running in an event loop rather than real threads with their context-switches. Moreover his concern is syntactic, not semantic: so maybe he'd like something which \"looks thread-like\" but \"complies-to-CPS\" too.\n\n와이콤비네이터 페이지에 올라온 해당 글에 대한 drostie의 댓글 중 하나에서 발췌\nhttps://news.ycombinator.com/item?id=8984648\n</code></pre>\n<p>하지만 이렇게 멀티스레딩(혹은 그것처럼 보이는) 방식의 해결은 성능상 문제가 없을지는 몰라도 오히려 코드 작성을 복잡하게 만들 수 있다. 비동기 함수의 전염성이 없어진 건 좋지만, 이제 그들의 순서를 보장하기 위해서 또 개발자는 채널이나 뮤텍스를 쓰면서 머리를 싸매야 한다.</p>\n<p>따라서 개인적으로는 이 글의 시사점은 결국 비동기 함수의 전염성에 완벽한 해결책은 없으며 어느 쪽으로 가도 폭탄뿐인 길이라는 거라고 생각한다. Go와 같은 언어에서 폭탄을 좀 제거하기는 했지만 결국은 비슷하다...</p>\n<p>사실 어떤 결론이 있으리라고 기대했는데, 생각보다는 그렇지 않았다. 그냥 비동기 함수의 전염성 문제는 깔끔하게 해결할 수 없다는 글이었다. 무언가 전염성을 퇴치할 마법이 있는 줄 알았는데, 그런 건 없었다.</p>\n<p>그리고 개인적으로는 둘 중 그냥 async-await이 더 나은 해결책이라고 생각한다. 비동기의 전염성은 프로그램을 망치는 것이 아니라 '프로그램이 망쳐질 수 있다'는 걸 알려주는 수단이라고 보이기 때문이다.</p>\n<blockquote>\n<p>Inconvenient knowledge is better than convenient ignorance</p>\n<p><a href=\"https://blainehansen.me/post/red-blue-functions-are-actually-good/\">Red &#x26; blue functions are actually a good thing</a>에서 발췌</p>\n</blockquote>\n<h1>참고</h1>\n<p><a href=\"https://willowryu.github.io/2021-05-21/\">https://willowryu.github.io/2021-05-21/</a></p>\n<p><a href=\"https://www.rinae.dev/posts/why-every-beginner-front-end-developer-should-know-publish-subscribe-pattern-kr\">https://www.rinae.dev/posts/why-every-beginner-front-end-developer-should-know-publish-subscribe-pattern-kr</a></p>\n<p><a href=\"https://medium.com/technofunnel/javascript-async-await-c83b15950a71\">https://medium.com/technofunnel/javascript-async-await-c83b15950a71</a></p>\n<p><a href=\"https://inpa.tistory.com/entry/%F0%9F%94%84-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84-%EA%B5%AC%EC%A1%B0-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC\">https://inpa.tistory.com/entry/%F0%9F%94%84-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84-%EA%B5%AC%EC%A1%B0-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC</a></p>\n<p><a href=\"https://stackoverflow.com/questions/66113393/why-is-async-required-to-call-await-inside-a-javascript-function-body\">https://stackoverflow.com/questions/66113393/why-is-async-required-to-call-await-inside-a-javascript-function-body</a></p>\n<p><a href=\"https://stackoverflow.com/questions/44184006/js-async-await-why-does-await-need-async\">https://stackoverflow.com/questions/44184006/js-async-await-why-does-await-need-async</a></p>\n<p><a href=\"https://stackoverflow.com/questions/31483342/es2017-async-vs-yield/41744179#41744179\">https://stackoverflow.com/questions/31483342/es2017-async-vs-yield/41744179#41744179</a></p>\n<p><a href=\"https://www.sysnet.pe.kr/2/0/11129\">https://www.sysnet.pe.kr/2/0/11129</a></p>\n<p><a href=\"https://stackoverflow.com/questions/35380162/is-it-ok-to-use-async-await-almost-everywhere\">https://stackoverflow.com/questions/35380162/is-it-ok-to-use-async-await-almost-everywhere</a></p>\n<p><a href=\"https://medium.com/technofunnel/javascript-async-await-c83b15950a71\">https://medium.com/technofunnel/javascript-async-await-c83b15950a71</a></p>\n<p><a href=\"https://stackoverflow.com/questions/62196932/what-are-asynchronous-functions-in-javascript-what-is-async-and-await-in-ja\">https://stackoverflow.com/questions/62196932/what-are-asynchronous-functions-in-javascript-what-is-async-and-await-in-ja</a></p>\n<p><a href=\"https://dev.to/thebabscraig/the-javascript-execution-context-call-stack-event-loop-1if1\">https://dev.to/thebabscraig/the-javascript-execution-context-call-stack-event-loop-1if1</a></p>\n<p><a href=\"https://medium.com/sjk5766/call-stack%EA%B3%BC-execution-context-%EB%A5%BC-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90-3c877072db79\">https://medium.com/sjk5766/call-stack%EA%B3%BC-execution-context-%EB%A5%BC-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90-3c877072db79</a></p>\n<p><a href=\"https://blainehansen.me/post/red-blue-functions-are-actually-good/\">https://blainehansen.me/post/red-blue-functions-are-actually-good/</a></p>\n<p><a href=\"https://curiouscactus.wixsite.com/blog/post/async-await-considered-harmful\">https://curiouscactus.wixsite.com/blog/post/async-await-considered-harmful</a></p>\n<p><a href=\"https://frozenpond.tistory.com/148\">https://frozenpond.tistory.com/148</a></p>\n<p><a href=\"https://news.ycombinator.com/item?id=8984648\">https://news.ycombinator.com/item?id=8984648</a></p>",
    "excerpt": "0. 개요\n유명한 글인 What Color is Your Function?과 해당 글에 대한 토론을 읽고 작성한 글이다.\n개인적으로 비동기 프로그래밍의 어려움이 콜스택 관리에서 오며 이는 쉽게 해결 가능한 문제가 아니라는 것이 이 글의 시사점이라 생각한다.\n원 글의 저자는 Ruby, Dart 등의 언어에 매우 익숙하기 때문에 원 글에서는 이런 언어들을 예시로 들고 있다. 하지만 JS, Python 등 내가 알고 있고 좀더 유명하기도 한 언어로 예시를 바꾸어 작성",
    "headingTree": [
      {
        "title": "0. 개요",
        "url": "#0-개요",
        "items": []
      },
      {
        "title": "1. 비동기의 전염성",
        "url": "#1-비동기의-전염성",
        "items": []
      },
      {
        "title": "2. 원인",
        "url": "#2-원인",
        "items": [
          {
            "title": "2.1. 비동기 작업의 맥락 유지",
            "url": "#21-비동기-작업의-맥락-유지",
            "items": []
          },
          {
            "title": "2.2. Promise와 async",
            "url": "#22-promise와-async",
            "items": []
          },
          {
            "title": "2.3. 비동기 전염성을 그냥 없애 버린다면?",
            "url": "#23-비동기-전염성을-그냥-없애-버린다면",
            "items": []
          },
          {
            "title": "2.4. 여담 - 왜 async를 쓰는가?",
            "url": "#24-여담---왜-async를-쓰는가",
            "items": []
          }
        ]
      },
      {
        "title": "3. 비동기 전염성 문제 해결?",
        "url": "#3-비동기-전염성-문제-해결",
        "items": [
          {
            "title": "3.1. 해결 가능한가?",
            "url": "#31-해결-가능한가",
            "items": []
          },
          {
            "title": "3.2. 멀티스레드가 답은 아니다 - 그럼?",
            "url": "#32-멀티스레드가-답은-아니다---그럼",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 3,
      "wordCount": 825
    },
    "url": "/posts/callstack-and-async",
    "thumbnail": {
      "local": "/static/async-reality-dcb4c0cc.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-async-reality-dcb4c0cc-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAFCAIAAAD38zoCAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAdElEQVR4nB3BIRVFIRAFQAyJaIDBYDAoNApzFX4NATbAGtQLsIoMBKADigL/nD9jSilE9N6791prnXNrrb23mXP23scYrTUAOecQAhEZEZlzEhEzA/DeA6i1GgApJe+9qopIjLHWKiLmnPPe+/5UFQAzq+oPCBU/slTQhvUAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "carousel-1",
    "title": "프로젝트 작업 - 캐로셀 제작기 1",
    "date": "2022-08-25T00:00:00Z",
    "description": "우당탕탕 캐로셀 제작기 그 첫번째, 캐로셀의 핵심인 넘기는 동작 구현하기",
    "tags": [
      "web",
      "front",
      "react"
    ],
    "html": "<h1>1. 캐로셀을 만들자</h1>\n<p>캐로셀은 여러 장의 이미지와 내용을 넘기면서 볼 수 있게 해주는 인터페이스이다. 슬라이더라고도 부르는 것 같다. 이 캐로셀은 다음과 같은 특징을 가진다.</p>\n<ul>\n<li>웹사이트 맨 위에 있다.</li>\n<li>로딩했을 때 모니터의 상당 부분을 차지한다.</li>\n<li>한 번에 하나씩 여러 이미지를 보여준다.</li>\n<li>캐로셀 안에는 넘길 수 있는 내용이 더 있다는 것을 알려 주는 표시자나 내비게이션이 있다.</li>\n<li>이미지와 짧은 텍스트가 있다.</li>\n<li>내용은 조직의 소개나 사명에 대한 것 혹은 주요 정보나 프로모션이다.</li>\n</ul>\n<p>물론 캐로셀을 사용하는 것에도 장단점이 있다. 대부분의 경우에는 히어로 이미지를 사용하는 게 좋다고 한다. 그러나 여전히 캐로셀은 많이 사용되고 있고 나는 캐로셀이 그렇게 나쁜 디자인이라고 생각하지 않는다. 따라서 내가 하고 있는 프로젝트의 홈페이지에서도 캐로셀 메뉴를 사용하기로 했다.</p>\n<p>하지만 캐로셀을 만드는 건 그렇게 녹록한 일이 아니었다. 여러 예외 상황까지 고려하면 더더욱. 그래서 캐로셀을 만들고 여러 상황들을 처리하는 내용을 여기 정리한다.</p>\n<p>프로젝트에서는 React와 tailwind, typescript를 사용한다. 따라서 코드는 React, tailwind, typescript로 작성될 것이다. 그 외에 UI 컴포넌트 라이브러리인 DaisyUI를 사용하고 있다. 하지만 캐로셀을 만들 때 UI를 쓸 것 같았으면 그냥 DaisyUI에서 제공하는 캐로셀을 썼을 것 같다..</p>\n<p><img src=\"/static/carousel-1-f3b3c000.jpeg\" alt=\"carousel\"></p>\n<h1>2. 이미지를 일단 띄워 보자</h1>\n<p>캐로셀은 기본적으로 여러 이미지들이 있고 그것을 하나씩 보여주는 것이다. 그러면 여러 이미지들을 렌더링한 후 하나씩만 화면에 보이게 하면 되지 않을까?</p>\n<p><img src=\"/static/carousel-2-28ad42f7.png\" alt=\"carousel2\"></p>\n<p>한번 코드로 작성해 보자. 캐로셀 컴포넌트는 어떤 형태가 되어야 할까? 가장 단순하게, 어떤 이미지들을 받아서 캐로셀 형태로 그려주면 된다. 따라서 먼저 이미지들을 길게 렌더링한 후 화면에 하나만 보여주면 된다. 이를 위한 캐로셀의 개별 아이템 타입은 다음과 같이 정의될 수 있다.</p>\n<pre><code class=\"language-tsx\">interface CarouselItemType {\n  id: number;\n  image: string;\n}\n</code></pre>\n<p>이를 우리가 원하는 대로 렌더링하려면 어떻게 해야 할까? 가로로 배열되어야 하므로 flex를 이용해서 배치해야 한다. 그리고 높이는 고정해야 한다. 여기서는 뷰포트의 50%가 되도록 설정하였다. 너비는 내부에 들어가는 요소들을 모두 포함할 만큼이 되도록 해야 하므로 fit-content를 사용한다. 마지막으로 화면을 넘어가는 부분은 안 보이도록 해야 하므로 상위 요소에 overflow-hidden을 설정한다. 즉 캐로셀 컴포넌트는 다음과 같이 짜인다.</p>\n<pre><code class=\"language-tsx\">function Carousel({ items }: { items: CarouselItemType[] }) {\n  return (\n    &#x3C;section className=\"overflow-hidden\">\n      &#x3C;div className=\"flex flex-row w-fit h-[50vh]\">\n        {items.map((item) => (\n          &#x3C;CarouselItem key={item.id} item={item} />\n        ))}\n      &#x3C;/div>\n    &#x3C;/section>\n  );\n}\n</code></pre>\n<p>사진이 길게 늘어진 띠 같은 것이 있고, 그 중 첫번째 사진만 화면에 보이고 나머지는 화면을 넘어가서 잘려 버린 형태라고 생각하면 된다.</p>\n<p>그럼 <code>CarouselItem</code>은 어떻게 짜야 할까? 먼저 한번에 하나의 이미지만 보여주고 싶으므로 full width(<code>width:100%</code>)여야 한다. 그리고 이미지 너비가 축소되면 안 되기 때문에 shrink도 설정해 준다. 다음과 같이 작성했다.</p>\n<pre><code class=\"language-tsx\">function CarouselItem({ item }: { item: CarouselItemType }) {\n  return (\n    &#x3C;div className=\"w-full shrink-0\">\n      &#x3C;img\n        className=\"object-fill w-full h-full\"\n        src={item.image}\n        alt={`carousel-item-${item.id}`}\n      />\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<p>이미지는 박스에 꽉 차게 들어가게 하기 위해서 full width, full height를 적용했고 object-fit 옵션도 적용하여 이미지가 컨테이너 div에 맞추느라 쪼그라드는 일을 막았다. 이렇게 하면 기본 요소들은 다 만들었다. 이제 이미지가 넘어가는 것을 만들어 보자.</p>\n<h1>3. 이미지가 넘어가는 동작을 만들어 보자</h1>\n<p>어떻게 하면 다음 이미지를 보여줄 수 있을까? 현재 캐로셀의 형태를 생각해 보자. 사진이 길게 늘어진 띠가 <code>section</code>태그 안에 들어가서 일정 부분만 보이는 상태라고 생각할 수 있다. 그러면 이 띠를 조금 이동시켜서 section 태그에 비치는 부분을 바꿀 수 있지 않을까?</p>\n<p>이걸 해주는 것이 바로 <code>transform</code>의 <code>translate</code>이다. 일단 슬라이드를 옮길 버튼을 만들어 보자. <code>이전 슬라이드</code>, <code>다음 슬라이드</code> 버튼을 캐로셀 아래에 삽입했다. Carousel 컴포넌트의 변경된 코드는 다음과 같다.</p>\n<pre><code class=\"language-tsx\">function Carousel({ items }: { items: CarouselItemType[] }) {\n  return (\n    // section 태그가 최외곽 태그가 되도록 바꾸었지만 레이아웃에 변화는 없다.\n    &#x3C;section>\n      &#x3C;div className=\"overflow-hidden\">\n        &#x3C;div className=\"flex flex-row w-fit h-[50vh]\">\n          {items.map((item) => (\n            &#x3C;CarouselItem key={item.id} item={item} />\n          ))}\n        &#x3C;/div>\n      &#x3C;/div>\n      {/* 이전 슬라이드, 다음 슬라이드 버튼을 추가했다. */}\n      &#x3C;button className=\"p-3 border border-gray-500\">이전 슬라이드&#x3C;/button>\n      &#x3C;button className=\"p-3 border border-gray-500\">다음 슬라이드&#x3C;/button>\n    &#x3C;/section>\n  );\n}\n</code></pre>\n<p>이제 슬라이드를 옮기는 버튼도 생겼다. 그럼 동작만 만들어 주면 된다. 저 버튼을 누름에 따라서 일정한 정도로 translate css를 바꿔 주면 된다.</p>\n<pre><code class=\"language-tsx\">function Carousel({ items }: { items: CarouselItemType[] }) {\n  const [translation, setTranslation] = useState(0);\n\n  // 이전 슬라이드로 넘어간다\n  const prevClick = (e: React.MouseEvent&#x3C;HTMLButtonElement>) => {\n    e.preventDefault();\n    if (translation === 0) {\n      setTranslation(items.length - 1);\n    } else {\n      setTranslation(translation - 1);\n    }\n  };\n\n  // 다음 슬라이드로 넘어간다\n  const nextClick = (e: React.MouseEvent&#x3C;HTMLButtonElement>) => {\n    if (translation === items.length - 1) {\n      setTranslation(0);\n    } else {\n      setTranslation(translation + 1);\n    }\n  };\n\n  return (\n    &#x3C;section>\n      &#x3C;div className=\"overflow-hidden\">\n        &#x3C;div\n          // translation state에 따라서 평행이동 정도를 바꿔 준다.\n          className={`flex flex-row w-fit h-[50vh] translate-x-[-${\n            translation * 100\n          }%]`}\n        >\n          {items.map((item) => (\n            &#x3C;CarouselItem key={item.id} item={item} />\n          ))}\n        &#x3C;/div>\n      &#x3C;/div>\n      &#x3C;button onClick={prevClick} className=\"p-3 border border-gray-500\">\n        이전 슬라이드\n      &#x3C;/button>\n      &#x3C;button onClick={nextClick} className=\"p-3 border border-gray-500\">\n        다음 슬라이드\n      &#x3C;/button>\n    &#x3C;/section>\n  );\n}\n</code></pre>\n<p>자 이제 버튼을 누르면 캐로셀이 넘어가면서 이미지가 이동할 것이다!</p>\n<hr>\n<p>안된다. 아무리 버튼을 눌러도 이미지가 이동하지 않는다. 개발자 도구를 열어서 css가 잘 변하고 있는지 살펴보면 css 값은 잘 바뀌고 있다. 분명 어떤 오류도 없다... 왜 안될까?</p>\n<h1>3. 이미지가 안 넘어가는 문제를 해결해 보자</h1>\n<p>tailwind는 우리의 소스 코드를 직접 파싱하거나 어떤 부분을 실행하지 않는다. 그저 정규 표현식을 통해서 tailwind class가 될 수 있는 문자열을 탐색할 뿐이다. <code>className=\"...\"</code>으로 되어 있는 부분만 찾지도 않는다. 소스 코드의 전체를 탐색한다. 이는 아래 참고에 적어 놓은 공식 문서에 나오는 내용이다.</p>\n<p>여기서 중요한 점은, 소스 코드를 실행시켜서 그 결과로 css가 나오는 것이 아니라 그냥 코드에서 className이 될 수 있는 부분을 탐색할 뿐이라는 것이다. 따라서 <code>complete unbroken string</code>, 중간에 어떤 계산식 등으로 인해 끊긴 게 아니라 온전한 class name만이 찾아진다.</p>\n<p>물론 safelist지정 등을 통해 동적 className 생성을 가능하게 할 수 있다. 하지만 이는 공식 문서에 의하면 전혀 권장되지 않는다.</p>\n<p>즉 우리는 위에서 한 것처럼 동적으로 문자열을 생성하는 것이 아니라 온전한 className을 제공해야 한다. string interpolation을 하거나(백틱으로 감싸진 문자열에 변수명 넣기) className의 일부를 이어붙이는 식으로 만든 className은 인식되지 않는다.</p>\n<p>이를 어떻게 해결할까? classnames(<a href=\"https://www.npmjs.com/package/classnames)%EB%9D%BC%EB%8A%94\">https://www.npmjs.com/package/classnames)라는</a> 라이브러리를 사용하는 방법이 있다고 한다. 그러나 이는 그렇게 좋지 않아 보인다.</p>\n<p>함수를 이용해서 먼저 complete class name을 생성해 주고 그걸 class에 전달하면 어떨까? 다음과 같은 코드를 작성하는 것이다.</p>\n<pre><code class=\"language-jsx\">function Carousel({ items }: { items: CarouselItemType[] }) {\n  const [translation, setTranslation] = useState(0);\n\n  const prevClick = (e: React.MouseEvent&#x3C;HTMLButtonElement>) => {\n    e.preventDefault();\n    if (translation === 0) {\n      setTranslation(items.length - 1);\n    } else {\n      setTranslation(translation - 1);\n    }\n  };\n\n  const nextClick = (e: React.MouseEvent&#x3C;HTMLButtonElement>) => {\n    if (translation === items.length - 1) {\n      setTranslation(0);\n    } else {\n      setTranslation(translation + 1);\n    }\n  };\n\n  const calculateTranslation = (index: number) => {\n    return `translate-x-[-${index * 100}%]`;\n  };\n\n  return (\n    &#x3C;section>\n      &#x3C;div className=\"overflow-hidden\">\n        &#x3C;div\n          className={`flex flex-row w-fit h-[50vh] ${calculateTranslation(\n            translation\n          )}`}\n        >\n          {items.map((item) => (\n            &#x3C;CarouselItem key={item.id} item={item} />\n          ))}\n        &#x3C;/div>\n      &#x3C;/div>\n      &#x3C;button onClick={prevClick} className=\"p-3 border border-gray-500\">\n        이전 슬라이드\n      &#x3C;/button>\n      &#x3C;button onClick={nextClick} className=\"p-3 border border-gray-500\">\n        다음 슬라이드\n      &#x3C;/button>\n    &#x3C;/section>\n  );\n}\n</code></pre>\n<p>하지만 함수 역시 className을 동적으로 생성하는 것으로 취급되는 듯 했다. 전혀 작동하지 않았다. 이외에도 items 배열을 통해 className을 구할 수 있는 객체를 생성한 후 거기서 ClassName을 얻어오려고 하는 시도를 하는 등 여러 시도를 해봤지만 어떻게든 뭔가 '동적'으로 className을 구해낸다는 아이디어는 다 실패했다.</p>\n<p>다음과 같이 미리 생성한 객체 translateConfig를 이용하는 방법만이 성공했다.</p>\n<pre><code class=\"language-tsx\">function Carousel({ items }: { items: CarouselItemType[] }) {\n  const [translation, setTranslation] = useState(0);\n\n  const prevClick = (e: React.MouseEvent&#x3C;HTMLButtonElement>) => {\n    e.preventDefault();\n    if (translation === 0) {\n      setTranslation(items.length - 1);\n    } else {\n      setTranslation(translation - 1);\n    }\n  };\n\n  const nextClick = (e: React.MouseEvent&#x3C;HTMLButtonElement>) => {\n    if (translation === items.length - 1) {\n      setTranslation(0);\n    } else {\n      setTranslation(translation + 1);\n    }\n  };\n\n  const translateConfig: { [key: number]: string } = {\n    0: \"translate-x-[0%]\",\n    1: \"translate-x-[-100%]\",\n    2: \"translate-x-[-200%]\",\n    3: \"translate-x-[-300%]\",\n    4: \"translate-x-[-400%]\",\n    5: \"translate-x-[-500%]\",\n  };\n\n  return (\n    &#x3C;section>\n      &#x3C;div className=\"overflow-hidden\">\n        &#x3C;div\n          className={`flex flex-row w-fit h-[50vh] ${translateConfig[translation]}`}\n        >\n          {items.map((item) => (\n            &#x3C;CarouselItem key={item.id} item={item} />\n          ))}\n        &#x3C;/div>\n      &#x3C;/div>\n      &#x3C;button onClick={prevClick} className=\"p-3 border border-gray-500\">\n        이전 슬라이드\n      &#x3C;/button>\n      &#x3C;button onClick={nextClick} className=\"p-3 border border-gray-500\">\n        다음 슬라이드\n      &#x3C;/button>\n    &#x3C;/section>\n  );\n}\n</code></pre>\n<p>객체가 정적으로 생성되어 있다면 여기서 값을 구해오는 건 동적인 것으로 취급되지 않는 모양이다. 물론 이런 방식으로 할 수 있다. 객체를 미리 선언해 줘야 하긴 하지만 현실적으로 캐로셀에 많은 수의 이미지를 넣지 않을 것이므로 약 30개의 이미지가 캐로셀에 들어가 있는 경우까지, 즉 <code>translate-x-[-3000%]</code>정도까지만 커버할 수 있게 객체를 생성해 준다면 문제없이 작동할 것이다.</p>\n<p>또다른 방법으로는 tailwind와 별개로 스타일을 주는 방법이 있겠다. tailwind도 애초에 css 기반이므로 같이 사용할 수도 있다. 코드는 다음과 같다.</p>\n<pre><code class=\"language-tsx\">function Carousel({ items }: { items: CarouselItemType[] }) {\n  const [translation, setTranslation] = useState(0);\n\n  const prevClick = (e: React.MouseEvent&#x3C;HTMLButtonElement>) => {\n    e.preventDefault();\n    if (translation === 0) {\n      setTranslation(items.length - 1);\n    } else {\n      setTranslation(translation - 1);\n    }\n  };\n\n  const nextClick = (e: React.MouseEvent&#x3C;HTMLButtonElement>) => {\n    if (translation === items.length - 1) {\n      setTranslation(0);\n    } else {\n      setTranslation(translation + 1);\n    }\n  };\n\n  return (\n    &#x3C;section>\n      &#x3C;div className=\"overflow-hidden\">\n        &#x3C;div\n          className={`flex flex-row w-fit h-[50vh]`}\n          style={{ transform: `translateX(${-translation * 100}%)` }}\n        >\n          {items.map((item) => (\n            &#x3C;CarouselItem key={item.id} item={item} />\n          ))}\n        &#x3C;/div>\n      &#x3C;/div>\n      &#x3C;button onClick={prevClick} className=\"p-3 border border-gray-500\">\n        이전 슬라이드\n      &#x3C;/button>\n      &#x3C;button onClick={nextClick} className=\"p-3 border border-gray-500\">\n        다음 슬라이드\n      &#x3C;/button>\n    &#x3C;/section>\n  );\n}\n</code></pre>\n<p>하지만 앞선 2가지 방식 모두 좋지 않아 보인다. 지금까지 만든 캐로셀이 좋지 않은 이유는 다음과 같다.</p>\n<ol>\n<li>화면에 보이는 게 이미지 하나일 뿐 결국 모든 이미지를 렌더링해야 한다.</li>\n<li>translate 너비를 구하기 위한 객체를 하드코딩해야 한다. 혹은 Tailwind 외에 다른 style을 사용해야 한다.</li>\n</ol>\n<p>물론 캐로셀을 만드는 방식은 margin-left를 이용하는 방식도 있다. Tailwind에서도 시도해 볼 수 있을 것이다. 그러나 transform 연산이 gpu를 이용하기 때문에 더 낫거니와 그걸 쓰더라도 위의 2가지 문제를 해결하지 못한다. 따라서 다음 글에서는 캐로셀을 만들 때 현재 보여주는 이미지만 렌더링하며, translateConfig 객체도 만들 필요 없는 방식의 캐로셀을 제작할 것이다.</p>\n<h1>참고</h1>\n<p>캐로셀의 정의와 UI 디자인 원칙들 <a href=\"https://mytory.net/2021/08/03/carousel-usability.html\">https://mytory.net/2021/08/03/carousel-usability.html</a></p>\n<p>tailwind의 파싱 방식과 dynamic class name <a href=\"https://tailwindcss.com/docs/content-configuration#class-detection-in-depth\">https://tailwindcss.com/docs/content-configuration#class-detection-in-depth</a></p>\n<p>관련 스택오버플로우 질문답변\n<a href=\"https://stackoverflow.com/questions/72550439/tailwind-css-unresponsive-to-react-state-change\">https://stackoverflow.com/questions/72550439/tailwind-css-unresponsive-to-react-state-change</a></p>\n<p><a href=\"https://stackoverflow.com/questions/71791472/fontawesome-icons-not-accepting-color-props-through-react-functional-components/\">https://stackoverflow.com/questions/71791472/fontawesome-icons-not-accepting-color-props-through-react-functional-components/</a></p>",
    "excerpt": "1. 캐로셀을 만들자\n캐로셀은 여러 장의 이미지와 내용을 넘기면서 볼 수 있게 해주는 인터페이스이다. 슬라이더라고도 부르는 것 같다. 이 캐로셀은 다음과 같은 특징을 가진다.\n\n웹사이트 맨 위에 있다.\n로딩했을 때 모니터의 상당 부분을 차지한다.\n한 번에 하나씩 여러 이미지를 보여준다.\n캐로셀 안에는 넘길 수 있는 내용이 더 있다는 것을 알려 주는 표시자나 내비게이션이 있다.\n이미지와 짧은 텍스트가 있다.\n내용은 조직의 소개나 사명에 대한 것 혹은 주요 정보나 ",
    "headingTree": [
      {
        "title": "1. 캐로셀을 만들자",
        "url": "#1-캐로셀을-만들자",
        "items": []
      },
      {
        "title": "2. 이미지를 일단 띄워 보자",
        "url": "#2-이미지를-일단-띄워-보자",
        "items": []
      },
      {
        "title": "3. 이미지가 넘어가는 동작을 만들어 보자",
        "url": "#3-이미지가-넘어가는-동작을-만들어-보자",
        "items": []
      },
      {
        "title": "3. 이미지가 안 넘어가는 문제를 해결해 보자",
        "url": "#3-이미지가-안-넘어가는-문제를-해결해-보자",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 2,
      "wordCount": 616
    },
    "url": "/posts/carousel-1",
    "thumbnail": {
      "local": "/static/carousel-1-f3b3c000.jpeg",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-carousel-1-f3b3c000-jpeg",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAHCAIAAAC6O5sJAAAACXBIWXMAAAsTAAALEwEAmpwYAAAApElEQVR4nGNg4BJzzekMrJnrUTKVwSyRQcGXQTucQTOUgUHRce/5O99//3/z8WvHop0MxvEMasFgCdOMjUeuvXj3+fXHrwcv3GWwTmVQDWTQDGNgkDGNrZmW27cqsHwaR1AFgwpYFKRDUGnBliPzt50CGW0YC7UAJGGcvOPUzW+//73++P364zcMTtlQTQza4S0Ldm44eHHtoUvrD1xk8C+BSAAAymFEalM5/sQAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "callstack-and-iteration",
    "title": "반복문에서 동시성까지",
    "date": "2023-07-27T00:00:00Z",
    "description": "Iteration Inside and Out을 읽고",
    "tags": [
      "study",
      "CS"
    ],
    "html": "<h1>0. 개요</h1>\n<p>최근에 <a href=\"https://witch.work/posts/misc/callstack-and-async\">What color is your function?을 읽고 글을 작성하였다. 비동기 프로그래밍과 콜스택 관리에 관한 글이었다.</a></p>\n<p>그런데 같은 블로그에 반복과 동시성의 연관관계를 다룬 <a href=\"http://journal.stuffwithstuff.com/2013/01/13/iteration-inside-and-out/\">Iteration Inside and Out</a>, <a href=\"http://journal.stuffwithstuff.com/2013/02/24/iteration-inside-and-out-part-2/\">그리고 해당 글의 2번째 시리즈</a>도 상당히 흥미로워 이를 읽고 하나의 글을 더 쓴다.</p>\n<p>해당 글의 저자는 Ruby를 상당히 좋아하는지 Ruby로 된 예시가 꽤 많은데(보통 '이런 문제를 개선한 언어가 있을까?'라고 생각하면 보통 Ruby가 그런 점을 다 개선해 놓았다는 말이 원문 중에도 있다) JS로 최대한 바꿔 쓰도록 노력했다. 하지만 원래 나는 Ruby를 거의 모르기 때문에 잘못 옮긴 부분이 있을 수도 있다. 하지만 글의 내용을 보아 저자가 말하고자 하는 바는 최대한 옮기고자 했다.</p>\n<p>이 시리즈는 반복문이라는 간단해 보이는 작업을 스레드 간의 통신으로 해석할 수 있고 따라서 동시성에까지 가닿아 있다는 것을 알려준다. 동시성이라는 이슈가 생각도 못한 부분까지 닿아 있다는 걸 알 수 있는 글이었다.</p>\n<h1>1. 시작</h1>\n<p>대부분의 개발자들은 어떤 것을 반복하는 문법이 프로그래밍 언어에서 아주 간단한 문제라고 생각할 것이다. 50년 전의 컴퓨터에서 작동하던 FORTRAN에서조차도 이러한 반복문이 이미 존재했을 정도니까 당연한 생각이다. 참고로 FORTRAN의 반복문은 다음과 같이 작동하였다.</p>\n<pre><code class=\"language-c\">do i=1,10\n  print i\nend do\n</code></pre>\n<p>그럼 우리가 프로그래밍 언어, 예를 들어서 <a href=\"http://magpie-lang.org/\">새 프로그래밍 언어 Magpie(Iteration Inside and Out의 저자 Bob Nystrom이 만들고 있는 언어라고 한다)</a>를 만든다면 이렇게 하면 되지 않을까?</p>\n<ol>\n<li>다른 언어들의 반복문을 조사한다.</li>\n<li>그중 가장 좋아 보이는 것을 고른다.</li>\n<li>그것을 내 프로그래밍 언어에 추가한다.</li>\n</ol>\n<p>문제는 이렇게 반복문을 만드는 것이 단순히 몇 번 같은 작업을 반복하거나 특정 숫자 범위만 왔다갔다하는 문제가 아니라는 것이다.</p>\n<p>원초적인 질문으로 돌아가서, 반복(iteration)이란 대체 무엇인가? 우리는 다음과 같은 간단한 반복문을 생각할 수 있다.</p>\n<pre><code class=\"language-js\">for (let i = 0; i &#x3C; 10; i++) {\n  console.log(i);\n}\n</code></pre>\n<p>하지만 이런 반복도 있지 않은가? JS에서는 <code>for..of</code>와 같이 객체의 원소 전체를 반복하는 반복문도 있다. JS가 특별한 것도 아니고 Python이나 C++도 이런 기능을 지원한다.</p>\n<pre><code class=\"language-js\">let fruits=[\"사과\", \"바나나\", \"포도\"];\n\nfor(const fruit of fruits){\n  console.log(fruit);\n}\n</code></pre>\n<p>그럼 꼭 for문의 형태를 해야 하는가? JS의 <code>forEach</code>같은 건 어떤가? 객체의 원소 전체를 반복하며, 그 원소들에 대해 콜백 함수를 실행한다.</p>\n<pre><code class=\"language-js\">let fruits=[\"사과\", \"바나나\", \"포도\"];\n\nfruits.forEach((fruit)=>console.log(fruit));\n</code></pre>\n<p>반복을 어떤 추상적인 시퀀스에 대하여 그것을 순회하는 것으로 생각한다면 트리 형태로 되어 있는 객체를 순회하는 것은 어떤가? 아니면 소수 전체를 순회하면서 어떤 조건을 만족하는 소수가 나올 때까지 연산하는 것은? 이런 문제들을 전부 어떻게 처리할 것인가? 반복은 그렇게 쉬운 문제가 아니다.</p>\n<p>먼저 반복문에는 2가지의 다른 스타일인 internal iteration과 external iteration이 있는데 이것들부터 알아보자. 각각은 서로의 명확한 장단점이 있다.</p>\n<h1>2. External iteration : 함수가 객체를 호출한다</h1>\n<p>External iteration는 말 그대로 외부에서 반복자(iterator)를 제어하는 것이다. 객체에는 반복자가 있고, 다음 원소에 접근할 수 있는 방법이 있다. 그리고 외부에서는 그 반복자를 제어하면서 해당 반복자의 값에 어떤 조작을 가하는 것이다.</p>\n<p>C++, Java, C#, Python, PHP등의 많은 OOP 언어에서 사용한다. for, foreach(<code>forEach</code>와 같은 메서드가 아니라 객체의 전체 원소를 순회하는 것을 일반적으로 칭한 단어이다) 문을 제공한다. JS라면 다음과 같을 것이다.</p>\n<pre><code class=\"language-js\">for(let i=0;i&#x3C;10;i++){\n  console.log(i);\n}\n\nlet fruits=[\"사과\",\"바나나\",\"포도\"];\nfor (let i of fruits) {\n  console.log(i);\n}\n</code></pre>\n<p>위에서 <code>fruits</code> 배열을 순회하는 코드는 실제로는 잘 알려진 심볼 <code>[Symbol.iterator]()</code>메서드를 이용해 동작한다. 간단히 흉내내 보면 다음과 같다. 제너레이터를 사용할 수도 있고 이 또한 이후에 다루겠지만 지금의 핵심은 아니다.</p>\n<pre><code class=\"language-js\">let fruits=[\"사과\",\"바나나\",\"포도\"];\nlet iter=fruits[Symbol.iterator]();\nlet i;\nwhile(i=iter.next()){\n  if(i.done){break;}\n  console.log(i.value)\n}\n</code></pre>\n<p>핵심은 반복할 객체의 각 원소에 접근하기 위한 어떤 방법이 있고 그것이 외부로 노출되어 있다는 것이다.</p>\n<p>이를 실제로 구현하는 반복자 프로토콜에 사용자가 접근할 일은 별로 없다. 위같이 <code>next()</code>를 사용해서 반복자를 직접 제어할 일이 많지는 않으니까. 하지만 일반적인 for문의 사용을 생각해 보아도 알 수 있다.</p>\n<p>JS의 for문으로 예를 든다면 <code>for..of</code>문(어쨌거나 객체의 외부)에서 객체의 각 원소에 접근하고 for문의 루프 본문에서 해당 원소에 어떤 연산을 가하는 방식이다.</p>\n<p>external iteration을 구현하기 위해서는 이러한 반복자(iterator)를 외부에서 접근할 수 있는 방법을 정의해야 하고 이를 반복자 프로토콜이라고 한다.</p>\n<p>dart에서는 <code>.iterator()</code>, <code>moveNext()</code>, <code>.current</code>이고 Python에서는 <code>__iter__</code>와 <code>__next__</code>이며 JS에서는 <code>[Symbol.iterator]()</code>메서드의 generator 함수이다.</p>\n<h1>3. internal iteration : 객체가 함수를 호출한다</h1>\n<p>internal iteration은 반대다. 반복할 객체에 함수 객체를 전달하고 객체에서 알아서 반복을 진행하면서 반복되는 각 원소를 인자로 하여 함수를 호출하는 것이다.</p>\n<p>external iteration에서는 값을 사용하는 쪽에서 반복되는 값에 가할 연산을 언제 실행할지 제어하는 반면 internal iteration에서는 값을 생성하는 쪽에서 콜백을 이용해서 값에 언제 연산을 가할지 제어한다.</p>\n<pre><code class=\"language-js\">let fruits=[\"사과\",\"바나나\",\"포도\"];\nfruits.forEach((fruit)=>console.log(fruit));\n</code></pre>\n<p>Ruby, Smalltalk, 그리고 Lisp의 대부분이 이 방식을 사용한다. 물론 Python이나 JS와 같이 함수가 일급 객체로 취급되고 고차 함수가 많이 쓰이는 언어에서도 이 방식을 사용할 수 있다.</p>\n<h1>4. external vs internal</h1>\n<p>프로그램에서의 반복문을 2가지 부분으로 나눈다면 첫번째로 순회할 값들을 생성하는 부분, 그리고 그렇게 순회되는 값들에 어떤 조작을 가하는 부분 이렇게 두 부분이 있다고 할 수 있다.</p>\n<p>external/internal iteration을 가르는 기준은 이 두 단계 중 어느 쪽이 반복의 핵심 제어권을 갖는지이다.</p>\n<p>External iteration에서는 값들에 조작을 가하는 부분이 제어권을 갖는다. 반복자 프로토콜에서 순회할 값들을 생성하고, 언제 해당 값을 불러올지도 for문 본문에서 결정하여 for문의 본문에서 해당 값들에 조작을 가한다.</p>\n<pre><code class=\"language-js\">for(let i of arr){\n  foo(i);\n}\n</code></pre>\n<p>반면 Internal iteration에서는 순회할 값들을 만드는 쪽에서 해당 값을 사용할 콜백 함수를 제어한다. 콜백을 언제 호출할지는 값을 순회하는 <code>forEach</code>에서 정한다.</p>\n<pre><code class=\"language-js\">arr.forEach((i)=>foo(i));\n</code></pre>\n<h2>4.1. 각각의 강점</h2>\n<p>각각의 반복 방식은 강점이 있다. 그리고 그 강점이란 반복문의 제어권을 가진 쪽의 기능이 클 때 처리하기 쉽다는 것이다.</p>\n<p>external iteration의 경우 반복자를 세심하게 조작해야 하는 부분에서 강점이 있다. 예를 들어서 두 리스트를 번갈아가면서 반복해야 하는 경우는 어떤가? external iteration에서 그렇게 어렵지 않다.</p>\n<p>참고로 여기 쓰인 이름은 이 글을 쓰는 시점에 디스코드에 접속해 있는 친구들의 이름에서 따왔다.</p>\n<pre><code class=\"language-js\">let fruits = [\"사과\", \"바나나\", \"포도\", \"딸기\"];\nlet people = [\"김성현\", \"김유진\", \"전지수\", \"안재현\", \"이진호\"];\n\nlet fruit_iter = fruits[Symbol.iterator]();\nlet people_iter = people[Symbol.iterator]();\n\nlet fruit = fruit_iter.next();\nlet person = people_iter.next();\n\nwhile (!fruit.done || !person.done) {\n  if (!fruit.done) {\n    console.log(fruit.value);\n    fruit = fruit_iter.next();\n  }\n\n  if (!person.done) {\n    console.log(person.value);\n    person = people_iter.next();\n  }\n}\n</code></pre>\n<p>internal iteration에선 이런 반복자의 세심한 조작이 거의 불가능하다. 따라서 위와 같이 두 시퀀스의 반복자를 번갈아 반복하도록 한다든지 하는 건 쉽지 않다.</p>\n<p>반면 internal iteration은 반복자에 접근하는 것(특히 <code>next()</code>메서드) 자체가 복잡한 연산일 때 강점을 지닌다. 예를 들어서 객체가 이진 트리일 때를 가정해 보자. 어떻게 트리를 순회할 것인가? 트리를 중위 순회하며 어떤 작업을 해줘야 한다면?</p>\n<p>internal iteration에서는 쉽다. forEach에서 이를 구현하면 되기 때문이다. 에러 처리 등은 생략하였다.</p>\n<pre><code class=\"language-js\">class Tree{\n  // 이진 트리의 insert 메서드 등은 생략한다\n  inorder(node, callback){\n    if(node.left){\n      this.inorder(node.left, callback);\n    }\n    callback(node);\n    if(node.right){\n      this.inorder(node.right, callback);\n    }\n  }\n\n  forEach(callback){\n    this.inorder(this.root, callback);\n  }\n}\n</code></pre>\n<h2>4.2. 각각의 약점</h2>\n<p>하지만 external iteration에서 트리를 중위 순회하는 반복자의 순서를 명시적으로 정의해 주는 건 복잡한 일이 될 것이다. 스택을 사용해서 직접 순서를 하나하나 지시해 줘야 하니까.(제너레이터의 <code>yield*</code>를 쓰면 재귀적으로 구현할 수 있다는 걸 안다. 하지만 전통적인 이터레이터 프로토콜을 구현한다고 할 때의 이야기다)</p>\n<p>기초적인 알고리즘이므로 아주 어려운 작업은 아니지만 그냥 재귀를 이용한 중위 순회를 하기만 하면 되는 internal iteration에 비해 복잡한 구조가 된다는 건 분명하다.</p>\n<pre><code class=\"language-js\">/* 콜스택 구조를 구체적으로 작성함으로써 구현한 inorder traversal iterator 코드. \n실제로는 yield*를 써서 더 쉽게 구현할 수 있지만 구조를 보이기 위한 예시이다 */\n[Symbol.iterator](){\n  const stack=[];\n  let currentNode=this.root;\n\n  return {\n    next(){\n      while(currentNode!==null){\n        stack.push(currentNode);\n        currentNode=currentNode.left;\n      }\n\n      currentNode=stack.pop();\n      const value=currentNode.value;\n      currentNode=currentNode.right;\n\n      return {\n        value,\n        done:false\n      }\n    }\n  }\n}\n</code></pre>\n<p>그리고 internal iteration의 약점은 또 있다. short circuit이 어렵다는 것이다.</p>\n<p>예를 들어서 리스트에서 어떤 아이템을 찾는 작업은 어떤가? external iteration에서는 아주 간단하다. 찾는 원소를 찾는 순간 return하거나 break하면 된다.</p>\n<pre><code class=\"language-js\">for(let i of arr){\n  if(i===target){\n    return i;\n  }\n}\n\n// 아니면\n\nfor(let i of arr){\n  if(i===target){\n    console.log(\"찾았다!\");\n    break;\n  }\n}\n</code></pre>\n<p>하지만 internal iteration에서는 어떤가? break 같은 게 없기 때문에 모든 원소에 대해서 다 콜백을 실행해야 한다. flag 같은 걸 만들어야 할 수도 있다.</p>\n<pre><code class=\"language-js\">let found=false;\narr.forEach((i)=>{\n  if(i===target){\n    found=true;\n  }\n});\n</code></pre>\n<p>바깥에 있는 다른 블록에서 반환하게 하는 non-local return(Kotlin, Ruby 등의 언어에 있다)을 쓸 수 있다면 모르겠지만 많은 대중적인 언어들에서 그런 건 없기 때문에 이런 short circuit이 필요한 경우에는 일반적으로 external iteration이 더 강점을 지닌다.</p>\n<pre><code class=\"language-ruby\">=begin\nnon-local return을 사용하여 리스트에서 어떤 원소를 찾을 때 short-circuit을 할 수 있도록 한 코드. Ruby로 작성되었다.\n=end\ndef contains(arr, target)\n  arr.each { |item| return true if item == target }\n  false\nend\n</code></pre>\n<h2>4.3. JS의 forEach 약간의 탐구</h2>\n<p>참고로 JS에서는 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach?v=control\">forEach의 조기 종료가 쉽지 않기 때문에</a> 대부분의 JS 배열 메서드(<code>Array.prototype.some</code> 등등)들은 external iteration을 사용한다.</p>\n<pre><code class=\"language-js\">/* 이런 시도를 해 보았으나 안 된다. */\nfunction some(arr, callback){\n  let targetItem;\n  forEach((item)=>{\n    if(callback(item)){\n      targetItem=item;\n      continue loopBreak;\n    }\n  });\n  loopBreak:\n    return targetItem;\n}\n</code></pre>\n<p>JS의 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach?v=control#description\">forEach를 조기종료하기 위해서는 에러를 throw하는 방법밖에 없는데</a> 이게 그렇게 좋은 방식이 아니라는 것은 확실하다.</p>\n<pre><code class=\"language-js\">/* forEach의 throw를 통해 조기 종료를 구현한 코드 */\nfunction some(arr, callback){\n  let targetItem;\n  try{\n    forEach((item)=>{\n      if(callback(item)){\n        targetItem=item;\n        throw new Error();\n      }\n    });\n    // item을 못 찾았다는 것\n    return null;\n  } catch{\n    return targetItem;\n  }\n}\n</code></pre>\n<p>이 섹션 내용을 함께 고민해주신 <a href=\"https://github.com/CreeJee\">CreeJee</a>님께 감사를 전한다.</p>\n<h2>4.4. 분석</h2>\n<p>그럼 왜 이런 차이가 발생하는가? 어째서 external iteration은 반복자를 얻은 후 조작하는 데에 강점이 있고 internal iteration은 반복자를 얻는 데에 강점이 있는가?</p>\n<p>콜스택에 작업이 쌓이는 순서가 다르기 때문이다.</p>\n<p>external iteration에서는 반복자에 가할 연산이 먼저 콜스택에 쌓이고 그 다음에 반복자를 얻는다. 반면 internal iteration에서는 반복자를 얻는 것이 먼저 콜스택에 쌓이고 그 다음에 반복자에 가할 연산이 쌓인다.</p>\n<p>무슨 의미인지 좀더 구체적으로 보기 위해 다음과 같이 두 스타일의 반복을 실행하는 코드를 보자.</p>\n<pre><code class=\"language-js\">// external iteration\nfor(let i of arr){\n  func(i);\n}\n\n// internal iteration\narr.forEach((i)=>func(i));\n</code></pre>\n<p>그럼 두 코드를 실행할 때 콜스택에 쌓이는 순서는 각각 다음과 같다.<code>next</code>는 for문에서 다음 반복자를 얻어 오는 동작을 의미한다. JS의 경우 실제 <code>Symbol.iterator</code>에 정의되어 있는 제너레이터 함수가 리턴하는 객체의 next메서드를 호출한다.</p>\n<p>하지만 다른 언어에서 external iteration을 구현하는 데 쓰이는 메서드를 생각해도 상관없다. C#의 <code>MoveNext</code>라거나.</p>\n<p><img src=\"/static/iteration-callstack-b1182167.png\" alt=\"두 종류 반복문의 콜스택 구조\"></p>\n<p>문제는 콜스택에서 아래쪽에 있는 함수가 어떤 동작을 하기 위해서는 콜스택의 위쪽에 들어 있는 함수들이 모두 빠진 상태여야 한다는 것이다.</p>\n<p>그리고 콜스택의 위쪽에 있는 함수에서는 아래쪽에 있는 함수의 동작을 제어하기가 일반적으로 힘들다. 따라서 콜스택에서 아래쪽에 있는 함수가 반복문에서 주도권을 갖는다.</p>\n<p>왜 external iteration은 다음 원소를 얻는 것이 복잡할 때(더 엄밀하게 제한하면 단순히 복잡한 연산이 필요할 때라기보다는 다음 원소를 얻어내기 위해서 콜스택에서 어떤 재귀적으로 유지되고 있던 맥락이 필요할 때) 문제가 있는가? 위와 같은 콜스택 구조를 가지기 때문이다.</p>\n<p>반복문의 본문을 의미하는 <code>func</code>가 실행되기 위해서는 반복자를 얻는 <code>next</code>가 실행이 완료되어 콜스택에서 빠져야 한다. 이 말은 <code>next</code>가 콜스택에서 유지하고 있던 맥락이 모두 사라져야 한다는 뜻이다. 재귀적으로 구현한 inorder traversal이 제너레이터 없이 external iteration의 반복자에 쓰일 수 없는 이유다.</p>\n<pre><code class=\"language-js\">/* 콜스택 구조를 구체적으로 작성함으로써 구현한 inorder traversal iterator 코드. \n실제로는 yield*를 써서 더 쉽게 구현할 수 있지만 구조를 보이기 위한 예시이다 */\n[Symbol.iterator](){\n  const stack=[];\n  let currentNode=this.root;\n\n  return {\n    next(){\n      while(currentNode!==null){\n        stack.push(currentNode);\n        currentNode=currentNode.left;\n      }\n\n      currentNode=stack.pop();\n      const value=currentNode.value;\n      currentNode=currentNode.right;\n\n      return {\n        value,\n        done:false\n      }\n    }\n  }\n}\n</code></pre>\n<p>반면 internal iteration은 반대로 원소를 얻어오는 역할을 하는 <code>forEach</code>가 콜스택에서 상대적으로 아래쪽에 있다. 따라서 <code>func</code>가 각 원소에 대해서 실행되는 동안 콜스택 내부의 필요한 맥락을 유지할 수 있다. 재귀적인 연산으로 다음 원소를 얻어와도 되는 이유이다.</p>\n<p>하지만 두 이터러블의 반복자를 섞는다거나 하는 것은 internal iteration에서는 불가능하다. 해당 동작은 <code>func</code>에서 이루어져야 하는데 이는 forEach보다 콜스택에서 위쪽에 있고 따라서 <code>forEach</code>에 해당하는 동작인 다음 원소를 얻어오는 작업을 제어할 수 없기 때문이다.</p>\n<p>즉 콜스택에서 더 아래쪽에 놓이는 함수가 작업의 맥락을 가져갈 수 있게 된다. 위쪽에 있는 함수는 아래쪽에 있는 함수가 실행되기 전에 전부 종료되어서 콜스택에서 빠져야 하기 때문이다.</p>\n<p>그럼 이게 최선일까? 더 나은 방식은 없을까?</p>\n<h1>5. 한 걸음 더 나아가기</h1>\n<h2>5.1. 제너레이터를 이용한 개선</h2>\n<p>제너레이터를 이용하면 external iteration에서 값을 불러오는 작업의 맥락을 저장할 수 없다는 문제를 해결할 수 있다.</p>\n<p>JS를 어느 정도 배운 사람이라면, 위의 external iteration의 예시에서 inorder traversal을 개선할 수 있는 방법을 알고 있을 것이다. 어쩌면 이미 위의 코드를 보며 답답함을 느끼고 있었을지도 모른다.</p>\n<p>몇 번 언급했듯이 그 방법은 제너레이터이다. 제너레이터 위임까지 쓰면 위 코드를 정말 간단히 개선할 수 있다. 제너레이터를 이용해서 이진 트리의 inorder traversal을 구현해 보자.</p>\n<p>코드의 길이는 <code>Node</code> 클래스와 같은 것들 때문에 좀더 길어졌을지 모르나 반복의 핵심 로직은 재귀를 이용해서 더 간단하게 구현되었다.</p>\n<pre><code class=\"language-js\">// 이진 트리의 노드 클래스 정의\nclass Node {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// 이진 트리 클래스 정의\nclass BinaryTree {\n  constructor() {\n    this.root = null;\n  }\n\n  /* 이진 트리의 다른 기능을 위한 메서드는 생략하였다 */\n\n  // 중위 순회를 수행하는 제너레이터 함수\n  *inorderTraversal(node) {\n    if (node !== null) {\n      // 왼쪽 서브트리 순회\n      yield* this.inorderTraversal(node.left);\n      // 현재 노드의 값을 반환\n      yield node.value;\n      // 오른쪽 서브트리 순회\n      yield* this.inorderTraversal(node.right);\n    }\n  }\n\n  // 중위 순회를 위한 이터레이터 프로토콜 구현\n  [Symbol.iterator]() {\n    return this.inorderTraversal(this.root);\n  }\n}\n\n/* 이진 트리 만드는 과정은 생략 */\n\nfor(let i of bTree){\n  console.log(i);\n}\n</code></pre>\n<p>그런데 이건 대체 어떻게 동작하는가? external iteration인 건 똑같으니까 콜스택의 구조는 똑같을 것이다. <code>next</code>를 이용해서(실제 위 코드에 <code>next</code>는 없지만 논리적으로 그렇다는 뜻이다)값을 먼저 불러오고 그 값을 이용해서 무언가를 할 것이다.</p>\n<p>그럼 왜 제너레이터를 사용할 때는 이와 같은 문제가 없는가? 어떻게 위 코드에서 제너레이터는 중위 순회를 하면서 값을 불러오던 작업의 흐름을 콜스택의 명시적인 구현 없이도 유지할 수 있는가?</p>\n<h2>5.2. 분석</h2>\n<p>제너레이터 함수는 실행되면 제너레이터 객체를 반환한다. 이 제너레이터 객체는 <code>next()</code>메서드와 현재 반복의 진행 상태를 담고 있다. 따라서 <code>next</code>가 호출되면 이전 진행 상태에서 다음 yield까지 함수를 진행하고 yield된 값을 반환한다.</p>\n<p>다음 코드를 보면 제너레이터 함수를 실행할 때마다 새로운 제너레이터 객체를 반환하는 것을 알 수 있다.</p>\n<pre><code class=\"language-js\">function* gen(){\n  yield \"first\";\n  yield \"second\";\n  yield \"third\";\n  yield \"last\";\n}\n\nlet iter=gen();\n// {value: \"first\", done: false}\nconsole.log(iter.next());\n// {value: \"second\", done: false}\nconsole.log(iter.next());\n// {value: \"third\", done: false}\nconsole.log(iter.next());\n\nlet iter2=gen();\n// {value: \"first\", done: false}\nconsole.log(iter2.next());\n// {value: \"second\", done: false}\nconsole.log(iter2.next());\n</code></pre>\n<p>JS의 external iteration <code>for..of</code>도 이터러블의 <code>[Symbol.iterator]()</code>를 호출하고 반환된 제너레이터 객체의 <code>next()</code>를 호출하면서 동작한다. <code>next()</code>에서 반환된 객체의 <code>done</code>이 <code>true</code>가 될 때까지.</p>\n<p>아무튼 이 제너레이터 객체가 값을 불러오는 작업의 흐름을 콜스택 대신 저장하면서 힙에 저장되어 있는 것이다. <code>next()</code>가 종료되어도 해당 흐름은 힙에 있는 제너레이터 객체에 남아 있기 때문에 콜스택에서 맥락이 날아가는 것을 신경쓸 필요가 없다.</p>\n<p><img src=\"/static/generator-callstack-fd4f5015.png\" alt=\"콜스택 대신 제너레이터 객체가 맥락을 저장하는 모습\"></p>\n<p>프로그램 내에서의 작업의 흐름...어디선가 많이 들어본 것 같지 않은가? 우리는 제너레이터 객체를 스레드와 같이 볼 수 있다.</p>\n<p>기능은 실제 스레드에 비해 좀 제한적이지만 작업의 흐름을 저장하며 <code>yield*</code>를 이용하여 다른 제너레이터에 작업을 위임할 수도 있으며 <code>return</code>을 이용해 종료도 가능하다. 또한 제너레이터 함수 안에 명시함으로써 지역 변수를 만들 수도 있다.</p>\n<p>결국 제너레이터 객체가 마치 다른 스레드가 하나 더 있는 것처럼 작업의 흐름을 저장하고 있어 주기 때문에 external iteration에서도 반복자를 불러오는 복잡한 작업의 흐름을 유지할 수 있다.</p>\n<p>물론 internal iteration에서도 <code>forEach</code>함수를 재정의해 주면 이런 제너레이터를 이용해서 반복할 수 있다.</p>\n<p>아무튼 이런 해석은 반복을 메인 스레드와 제너레이터 객체 스레드 간의 통신으로 이루어지는 동작이라는 관점으로 볼 수 있게 해준다. 하나는 값을 생성하고, 하나는 값을 소모하고 반복의 진행을 넘기는 식이다.</p>\n<p>각 반복 스타일의 장단점을 극복하면서 더 나은 반복 제어를 하는 열쇠는 결국 어떻게 하면 반복의 작업 흐름을 저장할 스레드를 만들 수 있는지에 있었던 것이다!</p>\n<h1>6. 결론</h1>\n<p>우리는 처음에 반복의 여러 가지 문제들을 보았고, 이를 잘 해결하기 위한 2가지 스타일인 external iteration과 internal iteration을 살펴보았다. 그리고 각각의 장단점을 살펴보았다.</p>\n<p>또한 external iteration의 단점을 제너레이터를 이용해서 극복할 수 있다는 것을 알았다. 제너레이터 객체를 일종의 스레드로 해석하여 반복을 스레드 간의 통신으로 해석할 수 있었다.</p>\n<p>우리는 처음에 반복이라는 굉장히 간단해 보이는 주제로 시작했지만, 어느새 꽤나 깊은 주제인 동시성에 도달해 있다. Ruby에서 제너레이터와 같은 역할을 하는 fiber의 경우 실제로 동시성 메커니즘이다!</p>\n<p>우리가 반복을 하는 것은 사실 동시성을 다루는 것이다. 우리는 값을 생성하는 스레드와 값을 사용하는 스레드가 있고 이들 간의 통신을 제어한다.</p>\n<p><a href=\"https://journal.stuffwithstuff.com/2013/02/24/iteration-inside-and-out-part-2/\">물론 언어에서 워낙 잘 처리해 주기 때문에 이를 생각하거나 직접 제어할 일은 거의 없지만 동시성이라는 이슈가 반복이라는, 우리가 동시성이 존재할 거라고 생각지도 못한 부분까지 닿아 있다는 시사점이 있는 글이었다.</a></p>\n<h1>참고</h1>\n<p><a href=\"https://stackoverflow.com/questions/224648/external-iterator-vs-internal-iterator\">https://stackoverflow.com/questions/224648/external-iterator-vs-internal-iterator</a></p>\n<p><a href=\"https://witch.work/posts/dev/javascript-symbol-usage\">https://witch.work/posts/dev/javascript-symbol-usage</a></p>\n<p><a href=\"https://journal.stuffwithstuff.com/2013/02/24/iteration-inside-and-out-part-2/\">https://journal.stuffwithstuff.com/2013/02/24/iteration-inside-and-out-part-2/</a></p>",
    "excerpt": "0. 개요\n최근에 What color is your function?을 읽고 글을 작성하였다. 비동기 프로그래밍과 콜스택 관리에 관한 글이었다.\n그런데 같은 블로그에 반복과 동시성의 연관관계를 다룬 Iteration Inside and Out, 그리고 해당 글의 2번째 시리즈도 상당히 흥미로워 이를 읽고 하나의 글을 더 쓴다.\n해당 글의 저자는 Ruby를 상당히 좋아하는지 Ruby로 된 예시가 꽤 많은데(보통 '이런 문제를 개선한 언어가 있을까?'라고 생각하면 ",
    "headingTree": [
      {
        "title": "0. 개요",
        "url": "#0-개요",
        "items": []
      },
      {
        "title": "1. 시작",
        "url": "#1-시작",
        "items": []
      },
      {
        "title": "2. External iteration : 함수가 객체를 호출한다",
        "url": "#2-external-iteration--함수가-객체를-호출한다",
        "items": []
      },
      {
        "title": "3. internal iteration : 객체가 함수를 호출한다",
        "url": "#3-internal-iteration--객체가-함수를-호출한다",
        "items": []
      },
      {
        "title": "4. external vs internal",
        "url": "#4-external-vs-internal",
        "items": [
          {
            "title": "4.1. 각각의 강점",
            "url": "#41-각각의-강점",
            "items": []
          },
          {
            "title": "4.2. 각각의 약점",
            "url": "#42-각각의-약점",
            "items": []
          },
          {
            "title": "4.3. JS의 forEach 약간의 탐구",
            "url": "#43-js의-foreach-약간의-탐구",
            "items": []
          },
          {
            "title": "4.4. 분석",
            "url": "#44-분석",
            "items": []
          }
        ]
      },
      {
        "title": "5. 한 걸음 더 나아가기",
        "url": "#5-한-걸음-더-나아가기",
        "items": [
          {
            "title": "5.1. 제너레이터를 이용한 개선",
            "url": "#51-제너레이터를-이용한-개선",
            "items": []
          },
          {
            "title": "5.2. 분석",
            "url": "#52-분석",
            "items": []
          }
        ]
      },
      {
        "title": "6. 결론",
        "url": "#6-결론",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 3,
      "wordCount": 731
    },
    "url": "/posts/callstack-and-iteration",
    "thumbnail": {
      "local": "/static/iteration-callstack-b1182167.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-iteration-callstack-b1182167-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAXElEQVR4nE3JoQ3AMAxEUQMvHZYtDAOzgWFGCAw0DDQ96KpxW/WD00mPSinMHG/uzswiQu6OUwIAP9HeOyJyv/MAgD9kpKq997VWwpxTRMYYN7TWzCzBzGqtqnoBK9V5CV6YYFQAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "carousel-2",
    "title": "프로젝트 작업 - 캐로셀 제작기 2",
    "date": "2022-08-26T00:00:00Z",
    "description": "우당탕탕 캐로셀 제작기 그 두번째, 렌더링을 덜 해주면서 유연한 코드의 캐로셀 만들기",
    "tags": [
      "web",
      "front",
      "react"
    ],
    "html": "<h1>1. 문제를 개선한 캐로셀 만들기 시작</h1>\n<p>지난 글(<a href=\"https://www.witch.work/carousel-1/)%EC%97%90%EC%84%9C%EB%8A%94\">https://www.witch.work/carousel-1/)에서는</a> tailwind를 써서 캐로셀을 만들었다. 하지만 다음과 같은 문제가 있었다.</p>\n<ol>\n<li>화면에 보이는 게 이미지 하나일 뿐 결국 모든 이미지를 렌더링해야 한다.</li>\n<li>translate 너비를 구하기 위한 객체를 하드코딩해야 한다. 혹은 Tailwind 외에 다른 style을 사용해야 한다.</li>\n</ol>\n<p>이번 글에서는 그걸 개선하고 좀 더 코드가 깔끔하며 렌더링이 덜 일어나는 캐로셀을 제작해 본다.</p>\n<h1>2. 현재 보이는 사진과 그 전후 사진만 렌더링해 주기</h1>\n<p>캐로셀에서 이미지를 더 적게 렌더링하려면 어떻게 해야 할까? 보이는 이미지만 렌더링해주면 된다. 따라서 현재 화면에 보이고 있는 사진, 바로 그전 차례의 사진, 바로 다음 차례의 사진만 렌더링하게 해보자. 여기서 이전과 다음 차례 사진도 렌더링해주는 이유는 추후 캐로셀의 화면 전환시 이전/다음 슬라이드로 넘어가는 애니메이션을 넣어 주기 위해서이다.</p>\n<p>다음과 같은 타입을 먼저 정의해 주자.</p>\n<pre><code class=\"language-tsx\">interface CarouselIndexType {\n  prevIndex: number;\n  currentIndex: number;\n  nextIndex: number;\n}\n</code></pre>\n<h2>2.1 CarouselItem component</h2>\n<p>그럼 이 타입을 사용해서 어떻게 캐로셀의 이미지들을 렌더링할 것인가? <code>CarouselItem</code>컴포넌트에 현재 상태를 전달하고, 그 상태에 따라서 요소를 다른 방식으로 렌더링하는 방식을 생각해 보았다. 따라서 먼저 캐로셀이 현재 보여줘야 하는 인덱스와 캐로셀 아이템의 인덱스를 인수로 받아서 캐로셀 내부에서 아이템의 상태가 어떤지를 반환해 주는 함수를 만들었다.</p>\n<pre><code class=\"language-tsx\">const CarouselItemStates = {\n  PREV: \"prev\",\n  CURRENT: \"current\",\n  NEXT: \"next\",\n  INACTIVE: \"inactive\",\n} as const;\ntype CarouselItemStateType =\n  typeof CarouselItemStates[keyof typeof CarouselItemStates];\n\nfunction determineCarouselItemState(\n  itemIndex: number,\n  carouselIndex: CarouselIndexType\n): CarouselItemStateType {\n  switch (itemIndex) {\n    case carouselIndex.prevIndex:\n      return \"prev\";\n    case carouselIndex.currentIndex:\n      return \"current\";\n    case carouselIndex.nextIndex:\n      return \"next\";\n    default:\n      return \"inactive\";\n  }\n}\n</code></pre>\n<p>enum type을 사용하는 것보다 union type을 사용하는 것이 낫다고 해서 union type을 사용했다. enum type은 Javascript에는 존재하지 않는 기능이라 typescript 컴파일러는 즉시 실행 함수를 만들게 되는데 이렇게 되면 tree-shaking이 되지 않아서 좋지 않다고 한다. 이때 참고한 글은 LINE 엔지니어링 기술 블로그의 글인데 밑의 참고에 올려 놓겠다.</p>\n<p>그럼 이제 <code>CarouselItem</code> 컴포넌트를 현재 아이템이 가져야 하는 상태를 인자로 받아 이에 따른 스타일을 적용해 주는 방식으로 작동하게 하자. 위의 <code>determineCarouselItemState</code>의 반환값을 이용할 것이므로 상태는 prev, current, next, inactive 를 사용할 것이다.</p>\n<p>우리가 만들어 주고자 하는 상태는 다음과 같다.</p>\n<pre><code>* prev: 왼쪽으로 이동하면 보여지는 이미지\n* current: 현재 보여지는 이미지\n* next: 오른쪽으로 이동하면 보여지는 이미지\n* inactive: 현재 보여지지 않는 이미지\n</code></pre>\n<p><img src=\"/static/carousel-2-1-15e54f93.png\" alt=\"carousel-model\"></p>\n<p>이를 위해서 다음과 같은 방식을 생각해 주었다. 먼저 각 사진을 absoulte position으로 설정한다. 그리고 각 사진의 위치를 다음과 같은 className으로 설정한다.</p>\n<ul>\n<li>prev: <code>-translate-x-full</code>(transform: translateX(-100%); 와 동일)</li>\n<li>current: <code>translate-x-0</code>(transform: translateX(0); 와 동일. 평행이동해줄 필요가 없으므로 빈 문자열로 설정해도 된다)</li>\n<li>next: <code>translate-x-full</code>(transform: translateX(100%); 와 동일)</li>\n<li>inactive: 렌더링 안함</li>\n</ul>\n<p>그리고 부모 컴포넌트를 relative position으로 설정하고 item width를 100%로 설정하면 current 상태의 item만 화면에 보여지게 될 것이다. 이전/다음 슬라이드는 각각 화면의 왼쪽과 오른쪽에 숨겨지게 될 것이다. 나머지 inactive 상태의 item은 렌더링 되지 않을 것이다.</p>\n<p>이를 구현한 <code>CarouselItem</code> 컴포넌트는 다음과 같다.</p>\n<pre><code class=\"language-tsx\">function CarouselItem({\n  item,\n  itemState,\n}: {\n  item: CarouselItemType;\n  itemState: CarouselItemStateType;\n}) {\n  const carouselItemTranslateX = {\n    [CarouselItemStates.PREV]: \"-translate-x-full\",\n    [CarouselItemStates.CURRENT]: \"\",\n    [CarouselItemStates.NEXT]: \"translate-x-full\",\n  };\n\n  return itemState !== CarouselItemStates.INACTIVE ? (\n    &#x3C;div\n      className={`absolute w-full h-full shrink-0 ${carouselItemTranslateX[itemState]}`}\n    >\n      &#x3C;img\n        className=\"object-fill w-full h-full\"\n        src={item.image}\n        alt={`carousel-item-${item.id}`}\n      />\n    &#x3C;/div>\n  ) : null;\n}\n</code></pre>\n<p>이때 position이 absolute가 되면서 부모 컴포넌트의 높이에도 자동으로 들어가지 않는다. 따라서 가용 높이에 item이 맞춰서 들어갈 수 있도록 className에 <code>h-full</code>도 추가해 주었다.</p>\n<h2>2.2 Carousel Component</h2>\n<p>이제 <code>Carousel</code> 컴포넌트에서 <code>CarouselItem</code> 컴포넌트를 렌더링해 주면 된다. 기존의 translation state를 삭제하고 현재 캐로셀이 렌더링하고 있는 사진의 인덱스를 나타내는 <code>carouselIndex</code> state를 추가해 주었다. <code>prevClick</code> <code>nextClick</code> 함수도 거기에 맞게 수정했다. 그리고 <code>CarouselItem</code> 컴포넌트들이 렌더링되는 레벨의 상위에 relative position을 설정해서 캐로셀의 개별 요소들이 Carousel 컴포넌트가 렌더링되는 위치에 맞춰서 움직이게 했다.</p>\n<pre><code class=\"language-tsx\">function Carousel({ items }: { items: CarouselItemType[] }) {\n  const [carouselIndex, setCarouselIndex] = useState&#x3C;CarouselIndexType>({\n    prevIndex: items.length - 1,\n    currentIndex: 0,\n    nextIndex: 1,\n  });\n\n  const prevClick = (e: React.MouseEvent&#x3C;HTMLButtonElement>) => {\n    e.preventDefault();\n    if (carouselIndex.currentIndex === 0) {\n      setCarouselIndex({\n        prevIndex: items.length - 2,\n        currentIndex: items.length - 1,\n        nextIndex: 0,\n      });\n    } else if (carouselIndex.currentIndex === 1) {\n      setCarouselIndex({\n        prevIndex: items.length - 1,\n        currentIndex: 0,\n        nextIndex: 1,\n      });\n    } else {\n      setCarouselIndex({\n        prevIndex: carouselIndex.currentIndex - 2,\n        currentIndex: carouselIndex.currentIndex - 1,\n        nextIndex: carouselIndex.currentIndex,\n      });\n    }\n  };\n\n  const nextClick = (e: React.MouseEvent&#x3C;HTMLButtonElement>) => {\n    e.preventDefault();\n    if (carouselIndex.currentIndex === items.length - 1) {\n      setCarouselIndex({\n        prevIndex: items.length - 1,\n        currentIndex: 0,\n        nextIndex: 1,\n      });\n    } else if (carouselIndex.currentIndex === 0) {\n      setCarouselIndex({\n        prevIndex: 0,\n        currentIndex: 1,\n        nextIndex: 2,\n      });\n    } else {\n      setCarouselIndex({\n        prevIndex: carouselIndex.currentIndex,\n        currentIndex: carouselIndex.currentIndex + 1,\n        nextIndex: carouselIndex.currentIndex + 2,\n      });\n    }\n  };\n\n  return (\n    &#x3C;section>\n      &#x3C;div className=\"overflow-hidden\">\n        &#x3C;div className={`relative flex flex-row w-full h-[50vh]`}>\n          {items.map((item, index) => (\n            &#x3C;CarouselItem\n              key={item.id}\n              item={item}\n              itemState={determineCarouselItemState(index, carouselIndex)}\n            />\n          ))}\n        &#x3C;/div>\n      &#x3C;/div>\n      &#x3C;button onClick={prevClick} className=\"p-3 border border-gray-500\">\n        이전 슬라이드\n      &#x3C;/button>\n      &#x3C;button onClick={nextClick} className=\"p-3 border border-gray-500\">\n        다음 슬라이드\n      &#x3C;/button>\n    &#x3C;/section>\n  );\n}\n</code></pre>\n<p>이를 실행해 보면 우리가 의도한 대로 잘 작동하는 것을 확인할 수 있다. 또한 지난 글의 경우와 달리 tailwind style만을 적절히 사용했고 하드 코딩을 해주지도 않았다. 다음 글에서는 애니메이션을 넣고 이를 좀 꾸며 보자.</p>\n<h1>참고</h1>\n<p>enum type보다는 union type을 쓰자 <a href=\"https://engineering.linecorp.com/ko/blog/typescript-enum-tree-shaking/\">https://engineering.linecorp.com/ko/blog/typescript-enum-tree-shaking/</a></p>",
    "excerpt": "1. 문제를 개선한 캐로셀 만들기 시작\n지난 글(https://www.witch.work/carousel-1/)에서는 tailwind를 써서 캐로셀을 만들었다. 하지만 다음과 같은 문제가 있었다.\n\n화면에 보이는 게 이미지 하나일 뿐 결국 모든 이미지를 렌더링해야 한다.\ntranslate 너비를 구하기 위한 객체를 하드코딩해야 한다. 혹은 Tailwind 외에 다른 style을 사용해야 한다.\n\n이번 글에서는 그걸 개선하고 좀 더 코드가 깔끔하며 렌더링이 덜 일",
    "headingTree": [
      {
        "title": "1. 문제를 개선한 캐로셀 만들기 시작",
        "url": "#1-문제를-개선한-캐로셀-만들기-시작",
        "items": []
      },
      {
        "title": "2. 현재 보이는 사진과 그 전후 사진만 렌더링해 주기",
        "url": "#2-현재-보이는-사진과-그-전후-사진만-렌더링해-주기",
        "items": [
          {
            "title": "2.1 CarouselItem component",
            "url": "#21-carouselitem-component",
            "items": []
          },
          {
            "title": "2.2 Carousel Component",
            "url": "#22-carousel-component",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 353
    },
    "url": "/posts/carousel-2",
    "thumbnail": {
      "local": "/static/carousel-2-1-15e54f93.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-carousel-2-1-15e54f93-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAACCAIAAADq9gq6AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAPUlEQVR4nAEyAM3/AJHgeCiaCyGLCAAlAAAnAB2GBh6TAprmgQDD/61vxFdywlsAYwAAYwBwvVhovFHI/7Kd8hLVmMJbWwAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "carousel-4",
    "title": "프로젝트 작업 - 캐로셀 제작기 4",
    "date": "2022-08-27T01:00:00Z",
    "description": "우당탕탕 캐로셀 제작기 그 네번째, 캐로셀의 네비게이션 구현하기",
    "tags": [
      "web",
      "front",
      "react"
    ],
    "html": "<h1>1. 캐로셀 네비게이션 구현 시작</h1>\n<p>지난 글들에서는 캐로셀에서 각 이미지들이 넘어가는 동작을 구현해 보고 버튼 등의 UI를 구현해 보았다. 우리의 캐로셀은 점점 발전하고 있다. 이제 웬만큼 캐로셀처럼 보이기는 한다. 하지만 아직 우리는 할 게 많다. 네비게이션도 구현해야 하고 모바일 환경을 고려해서 터치 이벤트에도 반응하도록 해야 한다. 접근성도 고민해야 한다. 캐로셀이 괜히 난이도가 높은 게 아니다. 그중에 이번 글에서는 캐로셀의 네비게이션을 구현해 본다. 단순히 버튼만 나열하는 것이 아니라 나름대로 깔끔하게, 또 사용하기 편하게 구현해 보고자 한다.</p>\n<p>네비게이션을 만드는 이유는 이 캐로셀이 현재 보여주는 이미지 외에는 아무 정보도 제공하지 않기 때문이다. 사용자는 캐로셀에 얼마나 많은 이미지가 있는지, 각 캐로셀에 들어 있는 이미지는 무슨 의미인지 알 수가 없다. 설명이 있기는 하지만 그것도 결국 그 이미지까지 캐로셀을 넘겨 봐야 알 수 있다.</p>\n<p>또한 내가 보고 싶은 게 어디 있는지 알아서 캐로셀의 그 이미지로 이동하려고 하더라도 캐로셀에 있는 특정 차례로 바로 이동할 수도 없다. 따라서 캐로셀의 각 페이지로 이동할 수 있으며 간단한 설명이 있는 네비게이션 버튼들을 캐로셀 하단에 만들어 보자.</p>\n<p>이 캐로셀을 디자인할 때는 메이플스토리 메인 홈페이지(<a href=\"https://maplestory.nexon.com/Home/Main)%EC%97%90\">https://maplestory.nexon.com/Home/Main)에</a> 있는 캐로셀 구성을 참고하였다. 물론 많이 조악해진 형태로 구현되었다..</p>\n<h1>2. 네비게이션 버튼 만들기</h1>\n<p>먼저 네비게이션이 어떤 방식으로 구현될지 한번 고민해 보자. 캐로셀의 아래에 있는 게 일반적이다. 그리고 각 캐로셀 요소의 이미지와 내용을 담은 요소들이 네비게이션에 위치할 것이다. 또한 현재 보고 있는 캐로셀 요소가 몇 번째 요소인지 보여주는 부분도 있어야 한다.</p>\n<p>간략히 다음과 같은 설계를 해보았다. 캐로셀 이동을 위한 화살표도 아래로 내렸다.</p>\n<p><img src=\"/static/carousel-4-0-1d147bb4.jpeg\" alt=\"caruosel-4-0\"></p>\n<p>우리는 이미 각 캐로셀 요소의 이미지와 거기에 대한 간략한 정보를 제공하는 속성을 가지고 있다. <code>CarouselItemType</code>타입의 <code>image</code>와 <code>title</code>이 그것이다. 이 속성을 이용해서 각 이미지와 설명이 표시된 네비게이션 요소를 만들어 보자. 먼저 한 줄에 버튼이 모두 들어가게 만들어 보자.</p>\n<p>이를 위해 <code>CarouselNavigation</code>, <code>CarouselNavigationItem</code>컴포넌트를 만들자.</p>\n<p>우리가 설계한 <code>CarouselNavigationItem</code>은 각각 이미지 하나와 짧은 텍스트 하나로 이루어질 것이다. 이를 div들의 집합으로 표현하거나 ul, li를 이용해서 표현할 수도 있을 것이다. 그러나 최근에 Data들의 집합을 표현하는 dl, dt, dd 태그에 대해 알게 되었고, 이를 이용해서 표현해 보았다. 먼저 <code>CarouselNavigationItem</code>은 이미지를 포함하는 dt, 짧은 텍스트를 포함하는 dd로 구성한다. 그리고 이 둘을 div로 감싸준다.</p>\n<p>그리고 각 네비게이션 요소에는 flex-1 클래스(<code>flex:1 1 0;</code>)을 부여해서 버튼들이 부모 컨테이너를 같은 크기로 분할하도록 한다. 네비게이션 요소는 이미지, 텍스트가 똑같이 분할하게 할 것이므로 dt, dd 태그에도 <code>flex-1</code>클래스를 부여한다.</p>\n<pre><code class=\"language-tsx\">function CarouselNavigationItem({ item }: { item: CarouselItemType }) {\n  return (\n    &#x3C;div className=\"flex-1 flex flex-row border border-gray-500\">\n      &#x3C;dt className=\"flex-1\">\n        &#x3C;img\n          className=\"object-fill w-full h-full\"\n          src={item.image}\n          alt={`carousel-item-${item.id}`}\n        />\n      &#x3C;/dt>\n      &#x3C;dd className=\"flex-1 text-sm\">{item.title}&#x3C;/dd>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<p>이제 <code>CarouselNavigation</code>은 <code>CarouselNavigationItem</code>을 여러 개 포함하는 dl로 구성한다. 단순히 가로로 배열해 주면 된다.</p>\n<pre><code class=\"language-tsx\">function CarouselNavigation({ items }: { items: CarouselItemType[] }) {\n  return (\n    &#x3C;dl className=\"flex flex-row w-full h-10\">\n      {items.map((item, index) => (\n        &#x3C;CarouselNavigationItem key={index} item={item} />\n      ))}\n    &#x3C;/dl>\n  );\n}\n</code></pre>\n<p>이를 Carousel 컴포넌트의 하단에 추가하면 다음과 같은 모습으로 렌더링되게 된다.</p>\n<p><img src=\"/static/carousel-4-1-e97b48c6.png\" alt=\"Carousel-4-1\"></p>\n<h2>2.1 겹치는 테두리 제거</h2>\n<p>그런데 렌더링된 걸 잘 보면 네비게이션 요소끼리 만나는 곳의 테두리가 겹치는 것을 볼 수 있다. 이를 해결하는 건 간단하다. 요소가 겹치는 곳에는 테두리를 안 만들면 된다. 먼저 버튼의 오른쪽 테두리를 제거한다. 단순한 <code>border</code> 클래스 대신 <code>border-y border-l</code> 클래스를 주면 된다. 이렇게 하면 오른쪽 테두리는 제거되고 위쪽과 왼쪽 테두리는 그대로 남게 된다.</p>\n<p>아직 하나의 문제가 있다. 우리가 오른쪽 테두리를 제거해 준 것은 다음에 오는 버튼의 왼쪽 테두리가 있어서 이 버튼의 오른쪽 테두리 역할도 겸해 줄 거라고 생각했기 때문이다. 하지만 맨 오른쪽 버튼의 경우 다음에 오는 버튼이 없다. 즉 맨 오른쪽 버튼의 경우 오른쪽 테두리가 아예 없게 된다.</p>\n<p>이는 현재 버튼이 한 줄에 다 들어가 있으므로 last-child 선택자를 이용해서 맨 오른쪽 버튼의 오른쪽 테두리를 다시 만들어 주는 걸로 해결해 줄 수 있다. 나중에 버튼이 2줄 이상이게 되면 또 문제가 발생할 수도 있고 버튼의 테두리가 사라지게 되면 쓸모없는 방법일 수도 있지만 일단은 이렇게 해결해 주었다.</p>\n<pre><code class=\"language-tsx\">function CarouselNavigationItem({ item }: { item: CarouselItemType }) {\n  return (\n    &#x3C;div className=\"flex-1 flex flex-row border-y borderl-l last:border-r border-gray-500\">\n      &#x3C;dt className=\"flex-1\">\n        &#x3C;img\n          className=\"object-fill w-full h-full\"\n          src={item.image}\n          alt={`carousel-item-${item.id}`}\n        />\n      &#x3C;/dt>\n      &#x3C;dd className=\"flex-1 text-sm\">{item.title}&#x3C;/dd>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<p>이렇게 하면 현재 코드에서는 버튼의 테두리 겹침이 일어나지 않는다.</p>\n<h1>3. 네비게이션 버튼의 현재 위치 표시</h1>\n<p>사용자가 지금 보고 있는 페이지가 어디인지 알 수 있게 해주는 정보도 제공해 보자. 간단하게, 캐로셀이 현재 위치한 페이지의 경우 해당 네비게이션 요소가 활성화되었다는 표시로 색을 입혀 주는 정도면 될 것이다. 그리고 이왕이면 활성화된 요소가 네비게이션의 가운데 위치하면 좋을 것이다.</p>\n<h2>3.1. 활성화된 버튼의 색상 변경</h2>\n<p>먼저 캐로셀이 현재 위치하고 있는 페이지에 해당하는 네비게이션 요소의 색상부터 변경해 주자. 이를 위해서 네비게이션 요소 컴포넌트를 변경시키자. 가져야 할 상태를 props로 받고(active, pending, inactive 정도의 상태가 있을 것)거기에 따라 적절한 방식으로 렌더링해주는 컴포넌트로 만들 것이다.</p>\n<p>그러기 위해 먼저 네비게이션 요소의 상태를 결정하는 함수를 만들자. 아직은 매우 간단하게 활성화되어 있으면 <code>active</code> 비활성화되어 있으면 <code>inactive</code>를 반환하도록 할 것이다.</p>\n<pre><code class=\"language-tsx\">const determineCarouselItemState = (itemIndex: number) => {\n  if (itemIndex === carouselIndex.currentIndex) {\n    return \"active\";\n  } else {\n    return \"inactive\";\n  }\n};\n</code></pre>\n<p>캐로셀 네비게이션 아이템 컴포넌트를 다음과 같이 변경해 보자. 아이템이 활성화되어 있는지를 의미하는 <code>itemState</code>를 props로 받도록 하고 이에 따라 <code>carouselItemConfig</code>를 통해 밝기, 배경색 등을 결정해 주었다. 또한 활성화된 아이템이 변경되는 동작을 transition을 이용해 부드럽게 나타나도록 처리했다.</p>\n<pre><code class=\"language-tsx\">function CarouselNavigationItem({\n  item,\n  itemState,\n}: {\n  item: CarouselItemType;\n  itemState: string;\n}) {\n  // active는 현재 캐로셀에서 보이고 있는 아이템에 해당하는 버튼의 상태\n  // inactive는 화면에는 보이지만 활성화되어 있지 않은 버튼의 상태\n  const carouselItemConfig: { [key: string]: string } = {\n    active: \"border-none bg-gray-500 text-base-100 hover:bg-gray-600\",\n    inactive: \"border-y border-l last:border-r border-gray-500 brightness-50\",\n  };\n\n  return (\n    &#x3C;div\n      className={`flex-1 flex flex-row transition-all duration-700 ${carouselItemConfig[itemState]}`}\n    >\n      &#x3C;dt className=\"flex-1\">\n        &#x3C;img\n          className=\"object-fill w-full h-full\"\n          src={item.image}\n          alt={`carousel-item-${item.id}`}\n        />\n      &#x3C;/dt>\n      &#x3C;dd className=\"flex-1 text-sm\">{item.title}&#x3C;/dd>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<p>또한 캐로셀 네비게이션 컴포넌트는 다음과 같이, <code>determineCarouselItemState</code>함수를 이용하여 각 아이템에 itemState를 넘겨주도록 했다.</p>\n<pre><code class=\"language-tsx\">function CarouselNavigation({\n  items,\n  carouselIndex,\n}: {\n  items: CarouselItemType[];\n  // 현재 캐로셀이 보여주고 있는 인덱스\n  carouselIndex: CarouselIndexType;\n}) {\n  //아이템의 상태를 결정하는 함수\n  const determineCarouselItemState = (itemIndex: number) => {\n    if (itemIndex === carouselIndex.currentIndex) {\n      return \"active\";\n    } else {\n      return \"inactive\";\n    }\n  };\n\n  return (\n    &#x3C;dl className=\"flex flex-row w-full h-10\">\n      {items.map((item, index) => (\n        &#x3C;CarouselNavigationItem\n          key={index}\n          item={item}\n          itemState={determineCarouselItemState(index)}\n        />\n      ))}\n    &#x3C;/dl>\n  );\n}\n</code></pre>\n<p>이제 캐로셀 네비게이션에서 활성화된 페이지에 해당하는 요소가 특별하게 표시되는 것을 볼 수 있다.</p>\n<p><img src=\"/static/carousel-4-3-aedd0ef7.png\" alt=\"carousel-4-3\"></p>\n<h2>3.2 특정 개수의 아이템만 네비게이션에 표시하기</h2>\n<p>하지만 만약 캐로셀의 페이지 개수가 많아진다면? 캐로셀의 페이지 수는 적으면 좋겠지만 그렇지 않은 경우도 있을 수 있다. 예를 들어 디자인에 큰 참고가 된 메이플스토리 메인 페이지의 경우 현재 기준으로 캐로셀에 25개의 페이지가 있다. 이 절반 정도 되는 11개의 페이지 정도만 넣어도 이렇게 보기 싫은 빽빽한 네비게이션 배치가 나온다.</p>\n<p><img src=\"/static/carousel-4-4-d98eae76.png\" alt=\"carousel-4-4\"></p>\n<p>따라서 캐로셀 네비게이션엔 기본적으로 현재 활성화되어 있는 페이지의 버튼, 그리고 그 앞뒤 2개씩의 인덱스에 해당하는 버튼까지 5개의 버튼이 들어가도록 할 것이다. 나머지 버튼은 일단은 화면에 보이지 않도록 한다. 이를 위해 앞서 작성한 <code>determineCarouselItemState</code>함수를 다음과 같이 수정한다.</p>\n<p>활성화된 요소는 active, 화면에는 보이지만 비활성화된 요소는 pending, 아예 화면에 표시되지 않는 요소는 inactive로 구분하도록 한다.</p>\n<pre><code class=\"language-tsx\">const determineCarouselItemState = (itemIndex: number) => {\n  if (itemIndex === carouselIndex.currentIndex) {\n    return \"active\";\n  } else if (\n    /* \n    캐로셀의 초반부나 후반부 페이지가 활성화되어있을 경우 \n    활성화 요소를 가운데에 배치하지 못하더라도 5개를 일단 채운다 \n    */\n    carouselIndex.currentIndex === 0 ||\n    carouselIndex.currentIndex === 1\n  ) {\n    return itemIndex &#x3C; 5 ? \"pending\" : \"inactive\";\n  } else if (\n    carouselIndex.currentIndex === items.length - 1 ||\n    carouselIndex.currentIndex === items.length - 2\n  ) {\n    return itemIndex >= items.length - 5 ? \"pending\" : \"inactive\";\n  } else {\n    return carouselIndex.currentIndex - 2 &#x3C;= itemIndex &#x26;&#x26;\n      itemIndex &#x3C;= carouselIndex.currentIndex + 2\n      ? \"pending\"\n      : \"inactive\";\n  }\n};\n</code></pre>\n<p>그리고 inactive 상태인 요소는 화면에 표시되지 않도록 <code>display:none</code>에 해당하는 <code>hidden</code>클래스를 부여한다. 또한 <code>pending</code> 상태에도 적절한 스타일링을 한다. <code>CarouselNavigationItem</code> 컴포넌트를 다음과 같이 수정했다.</p>\n<pre><code class=\"language-tsx\">function CarouselNavigationItem({\n  item,\n  itemState,\n}: {\n  item: CarouselItemType;\n  itemState: string;\n}) {\n  // active는 현재 캐로셀에서 보이고 있는 아이템에 해당하는 버튼의 상태\n  // pending은 화면에는 보이지만 활성화되어 있지 않은 버튼의 상태\n  const carouselItemConfig: { [key: string]: string } = {\n    active:\n      \"border-y border-l last:border-r border-gray-500 bg-gray-500 text-base-100 hover:bg-gray-600\",\n    pending: \"border-y border-l last:border-r border-gray-500 brightness-50\",\n    inactive: \"hidden\",\n  };\n\n  return (\n    &#x3C;div\n      className={`flex-1 flex flex-row transition-all duration-700 ${carouselItemConfig[itemState]}`}\n    >\n      &#x3C;dt className=\"flex-1\">\n        &#x3C;img\n          className=\"object-fill w-full h-full\"\n          src={item.image}\n          alt={`carousel-item-${item.id}`}\n        />\n      &#x3C;/dt>\n      &#x3C;dd className=\"flex-1 text-sm\">{item.title}&#x3C;/dd>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<p>여기까지 완료하고 캐로셀을 렌더링해보면 아래와 같이 보인다. 디자인이 그렇게 훌륭하지는 않지만 어쨌든 각 페이지에 해당하는 버튼이 표시되고, 주변 페이지의 버튼도 네비게이션에 잘 표시된다. 캐로셀이 초반 페이지나 후반 페이지에 있을 때에도 꽤 일반적으로 잘 작동한다. 네비게이션은 언제나 5개(물론 캐로셀에 5개 미만의 요소가 있을 때는 제외)의 버튼을 가지고 활성화된 페이지의 버튼을 잘 감지한다.</p>\n<p><img src=\"/static/carousel-4-5-1d936064.png\" alt=\"carousel-4-5\"></p>\n<h1>4. 네비게이션 버튼 동작 구현</h1>\n<p>지금은 캐로셀의 네비게이션 아이템을 눌렀을 때 그 페이지로 이동하는 기능이 없다. 기존에 있는 화살표를 통해 캐로셀을 이동하면 활성화된 요소의 색이 바뀔 뿐이다. 이제 네비게이션 아이템을 통해 특정 페이지로 이동하는 기능을 구현해보자.</p>\n<p>그런데 지금 캐로셀에서 활성화된 페이지 인덱스를 관리하는 기능은 <code>CarouselNavigation</code>의 상위 컴포넌트인 <code>Carousel</code>에서 <code>carouselIndex</code> state를 통해 가지고 있다. 따라서 네비게이션에 페이지 이동 기능을 추가해 주기 위해서는 <code>CarouselNavigation</code>컴포넌트에 props로 <code>setCarouselIndex</code>를 넘겨줘야 한다.</p>\n<p>그렇게 작성한 <code>CarouselNavigation</code>컴포넌트는 다음과 같아진다.</p>\n<pre><code class=\"language-tsx\">function CarouselNavigation({\n  items,\n  carouselIndex,\n  setCarouselIndex,\n}: {\n  items: CarouselItemType[];\n  // 현재 캐로셀이 보여주고 있는 인덱스\n  carouselIndex: CarouselIndexType;\n  setCarouselIndex: (newCarouselIndex: CarouselIndexType) => void;\n}) {\n  //버튼의 상태를 결정하는 함수\n  const determineCarouselItemState = (itemIndex: number) => {\n    if (itemIndex === carouselIndex.currentIndex) {\n      return \"active\";\n    } else if (\n      /* \n    캐로셀의 초반부나 후반부 페이지가 활성화되어있을 경우 \n    활성화 요소를 가운데에 배치하지 못하더라도 5개를 일단 채운다 \n    */\n      carouselIndex.currentIndex === 0 ||\n      carouselIndex.currentIndex === 1\n    ) {\n      return itemIndex &#x3C; 5 ? \"pending\" : \"inactive\";\n    } else if (\n      carouselIndex.currentIndex === items.length - 1 ||\n      carouselIndex.currentIndex === items.length - 2\n    ) {\n      return itemIndex >= items.length - 5 ? \"pending\" : \"inactive\";\n    } else {\n      return carouselIndex.currentIndex - 2 &#x3C;= itemIndex &#x26;&#x26;\n        itemIndex &#x3C;= carouselIndex.currentIndex + 2\n        ? \"pending\"\n        : \"inactive\";\n    }\n  };\n\n  // 특정 인덱스의 페이지로 이동하는 함수\n  const onCarouselNavigationItemClick = (itemIndex: number) => {\n    setCarouselIndex({\n      prevIndex: itemIndex === 0 ? items.length - 1 : itemIndex - 1,\n      currentIndex: itemIndex,\n      nextIndex: itemIndex === items.length - 1 ? 0 : itemIndex + 1,\n    });\n  };\n\n  return (\n    &#x3C;dl className=\"flex flex-row w-full h-10\">\n      {items.map((item, index) => (\n        &#x3C;CarouselNavigationItem\n          key={index}\n          item={item}\n          itemState={determineCarouselItemState(index)}\n          onItemClick={() => {\n            onCarouselNavigationItemClick(index);\n          }}\n        />\n      ))}\n    &#x3C;/dl>\n  );\n}\n</code></pre>\n<p>그리고 <code>onCarouselNavigationItemClick</code> 함수를 받은 <code>CarouselNavigationItem</code> 컴포넌트는 다음과 같이 버튼으로 만든 후 onClick 이벤트 핸들러를 부여한다.</p>\n<pre><code class=\"language-tsx\">function CarouselNavigationItem({\n  item,\n  itemState,\n  onItemClick,\n}: {\n  item: CarouselItemType;\n  itemState: string;\n  onItemClick: () => void;\n}) {\n  // active는 현재 캐로셀에서 보이고 있는 아이템에 해당하는 버튼의 상태\n  // pending은 화면에는 보이지만 활성화되어 있지 않은 버튼의 상태\n  const carouselItemConfig: { [key: string]: string } = {\n    active:\n      \"border-y border-l last:border-r border-gray-500 bg-gray-500 text-base-100 hover:bg-gray-600\",\n    pending: \"border-y border-l last:border-r border-gray-500 brightness-50\",\n    inactive: \"hidden\",\n  };\n\n  return (\n    &#x3C;button\n      onClick={onItemClick}\n      className={`flex-1 flex flex-row transition-all duration-700 ${carouselItemConfig[itemState]}`}\n    >\n      &#x3C;dt className=\"flex-1\">\n        &#x3C;img\n          className=\"object-fill w-full h-full\"\n          src={item.image}\n          alt={`carousel-item-${item.id}`}\n        />\n      &#x3C;/dt>\n      &#x3C;dd className=\"flex-1 text-sm\">{item.title}&#x3C;/dd>\n    &#x3C;/button>\n  );\n}\n</code></pre>\n<p>그러나 여전히 거슬리는 부분이 있다. 아까는 캐로셀 아이템이 이동하는 듯한 효과를 위해 transform 애니메이션을 넣었다. 하지만 네비게이션 바의 버튼을 이용해서 페이지를 이동하면 그 효과가 제대로 발생하지 않는다. 이는 캐로셀에서 이전 인덱스와 다음 인덱스의 정보만 저장하고 있기 때문이다.</p>\n<p>이를 어떻게든 처리해서 기존 페이지에서 이동할 페이지로 페이지가 쭉 넘어가는 효과를 줄 수도 있을 것이다. 하지만 그렇게 하면 넘길 페이지가 많을 때 10개가 넘는 페이지가 사용자의 시선을 빠른 속도로 지나가게 된다. 이는 매우 어지러울 것이다. 따라서 전환 효과를 리뉴얼하자.</p>\n<p>캐로셀의 동작 로직을 좀 많이 바꿀 예정이라 이는 다음 글에서 다룬다.</p>\n<h1>참고</h1>\n<p>디자인 참고 <a href=\"https://maplestory.nexon.com/Home/Main\">https://maplestory.nexon.com/Home/Main</a></p>\n<p>dl, dt, dd 태그의 사용 <a href=\"https://xo.dev/why-html-is-important-than-you-think/\">https://xo.dev/why-html-is-important-than-you-think/</a></p>\n<p>자식 요소들의 너비를 균등하게 분배하기 <a href=\"https://stackoverflow.com/questions/23930684/allocate-equal-width-to-child-elements-with-css\">https://stackoverflow.com/questions/23930684/allocate-equal-width-to-child-elements-with-css</a></p>\n<p><code>flex:1 1 0;</code>의 의미 <a href=\"https://heewon26.tistory.com/275\">https://heewon26.tistory.com/275</a></p>\n<p>버튼 테두리가 겹치는 현상 막기 <a href=\"https://stackoverflow.com/questions/12692089/preventing-double-borders-in-css\">https://stackoverflow.com/questions/12692089/preventing-double-borders-in-css</a></p>",
    "excerpt": "1. 캐로셀 네비게이션 구현 시작\n지난 글들에서는 캐로셀에서 각 이미지들이 넘어가는 동작을 구현해 보고 버튼 등의 UI를 구현해 보았다. 우리의 캐로셀은 점점 발전하고 있다. 이제 웬만큼 캐로셀처럼 보이기는 한다. 하지만 아직 우리는 할 게 많다. 네비게이션도 구현해야 하고 모바일 환경을 고려해서 터치 이벤트에도 반응하도록 해야 한다. 접근성도 고민해야 한다. 캐로셀이 괜히 난이도가 높은 게 아니다. 그중에 이번 글에서는 캐로셀의 네비게이션을 구현해 본다. 단순",
    "headingTree": [
      {
        "title": "1. 캐로셀 네비게이션 구현 시작",
        "url": "#1-캐로셀-네비게이션-구현-시작",
        "items": []
      },
      {
        "title": "2. 네비게이션 버튼 만들기",
        "url": "#2-네비게이션-버튼-만들기",
        "items": [
          {
            "title": "2.1 겹치는 테두리 제거",
            "url": "#21-겹치는-테두리-제거",
            "items": []
          }
        ]
      },
      {
        "title": "3. 네비게이션 버튼의 현재 위치 표시",
        "url": "#3-네비게이션-버튼의-현재-위치-표시",
        "items": [
          {
            "title": "3.1. 활성화된 버튼의 색상 변경",
            "url": "#31-활성화된-버튼의-색상-변경",
            "items": []
          },
          {
            "title": "3.2 특정 개수의 아이템만 네비게이션에 표시하기",
            "url": "#32-특정-개수의-아이템만-네비게이션에-표시하기",
            "items": []
          }
        ]
      },
      {
        "title": "4. 네비게이션 버튼 동작 구현",
        "url": "#4-네비게이션-버튼-동작-구현",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 3,
      "wordCount": 694
    },
    "url": "/posts/carousel-4",
    "thumbnail": {
      "local": "/static/carousel-4-0-1d147bb4.jpeg",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-carousel-4-0-1d147bb4-jpeg",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAoUlEQVR4nAGWAGn/APv8/+nr8dzd5dXZ38nK0sHDy7W4wba5vwDm6O6lpaybm6J9foRvb3ZtbXNxcXdYWV8A0NLYyMrRlpecLy82GRcfTEtRRkVKJiYrALq8wqCiqIOEil9fZkNCSTk5PysrMSgoLgCfn6ZMS1RFRU0xMTkXFR0SERgJCRUqKjEAmJufdXd8bW5zcHN4XV1jUFBVTE1SQ0RI7sdDQlp+cZgAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "carousel-3",
    "title": "프로젝트 작업 - 캐로셀 제작기 3",
    "date": "2022-08-27T00:00:00Z",
    "description": "우당탕탕 캐로셀 제작기 그 세번째, 좀더 캐로셀처럼 보이는 캐로셀 만들기",
    "tags": [
      "web",
      "front",
      "react"
    ],
    "html": "<h1>1. 캐로셀이 캐로셀처럼 보이지 않아..</h1>\n<p>첫번째 글에서 언급한 캐로셀의 조건 중 다음과 같은 것이 있었다.</p>\n<ul>\n<li>캐로셀 안에는 넘길 수 있는 내용이 더 있다는 것을 알려 주는 표시자나 내비게이션이 있다.</li>\n<li>이미지와 짧은 텍스트가 있다.</li>\n</ul>\n<p>하지만 우리의 캐로셀은 이런 조건들을 만족하지 못하고 있다. 캐로셀을 넘기는 건 <code>이전 슬라이드</code>와 <code>다음 슬라이드</code>버튼에 의존하고 있으며 설명을 위한 짧은 텍스트도 들어가 있지 않다. 캐로셀은 사이트의 메인에 걸리는 핵심 이미지인 만큼 여기에 어떤 슬로건이나 링크 등 많은 것을 넣을 수 있을 텐데 말이다. 또한 슬라이드 전환시 밋밋하게 사진이 바뀐다. 어떤 애니메이션도 없다.</p>\n<p>이런 디자인적인 문제들을 이 글에서는 풀어가 보려고 한다. 디자이너가 따로 있는 게 아니므로 완벽하진 않겠지만 그나마 아까보단 캐로셀처럼 보일 수 있도록.</p>\n<h1>2. 애니메이션 삽입</h1>\n<p>지금 만든 캐로셀은 화면 전환 시 딱히 전환 효과 없이 바로 화면에 표시되는 사진이 바뀐다. 하지만 일반적인 캐로셀은 사진이 넘어가는 효과가 있다. 이 효과를 삽입해 보자.</p>\n<p>이는 간단하다. <code>CarouselItem</code> 컴포넌트에 transform에 대한 transition을 주면 된다. 이를 위해 tailwind의 transition 관련 클래스를 사용하자. 또한 tailwind의 기본 duration은 150ms인데 이는 좀 짧다고 느껴지므로 500ms로 늘려주었다. 최상위 div의 classname에 <code>transition-transform duration-500</code>가 추가된 걸 볼 수 있다.</p>\n<pre><code class=\"language-tsx\">function CarouselItem({\n  item,\n  itemState,\n}: {\n  item: CarouselItemType;\n  itemState: CarouselItemStateType;\n}) {\n  const carouselItemTranslateX = {\n    [CarouselItemStates.PREV]: \"-translate-x-full\",\n    [CarouselItemStates.CURRENT]: \"\",\n    [CarouselItemStates.NEXT]: \"translate-x-full\",\n  };\n\n  return itemState !== CarouselItemStates.INACTIVE ? (\n    &#x3C;div\n      className={`transition-transform duration-500 absolute w-full h-full shrink-0 ${carouselItemTranslateX[itemState]}`}\n    >\n      &#x3C;img\n        className=\"object-fill w-full h-full\"\n        src={item.image}\n        alt={`carousel-item-${item.id}`}\n      />\n    &#x3C;/div>\n  ) : null;\n}\n</code></pre>\n<h1>3. 캐로셀 조작을 화살표로 하도록 바꿔주기</h1>\n<p>현재 캐로셀에서 이미지가 뜨는 곳 아래에는 <code>이전 슬라이드</code>, <code>다음 슬라이드</code>버튼이 있다. 이를 좀 더 사용자 친화적으로 바꿔보자. 이전 슬라이드, 다음 슬라이드 버튼을 좌우 화살표로 바꿔주고, 이를 클릭하면 캐로셀이 이동하도록 하자.</p>\n<p>따라서 <code>react-icons</code>에 있는 화살표 아이콘을 사용하도록 하자. 이는 npm을 이용하여 설치할 수 있다. 나는 프로젝트의 다른 페이지를 만들면서 이미 <code>react-icons</code>를 설치해 놓았다. 따라서 여기 있는 <code>IoIosArrowForward</code>와 <code>IoIosArrowBack</code>를 사용하겠다.</p>\n<p>먼저 <code>IoIosArrowForward</code>와 <code>IoIosArrowBack</code>를 import해주자. 그리고 현재 캐로셀의 구조는 다음과 같다. 캐로셀의 아이템들은 relative position으로 지정되어 있는 div 태그 내부에 있다. 또한 아이템 각각은 absolute position으로 지정되어 있다. 그런데 absolute position으로 지정된 요소는 일반적인 문서 흐름에 들어 있지 않다. 또한 페이지 레이아웃에 공간도 배정되지 않는다. 캐로셀의 각 아이템 요소는 absolute position이므로 문서 흐름에 없다는 것이다! relative position으로 지정된 div 내에는 아무 요소도 없는 것으로 간주된다.</p>\n<p>따라서 아무 요소도 없이 비어 있는 것으로 간주되는 div 태그(relative position으로 된 것)에 화살표 아이콘을 넣어주면 된다. 이 빈 태그에 <code>flex flex-row justify-between</code>을 추가해주면 두 화살표가 좌우 끝으로 정렬되는 것을 볼 수 있다. 이 화살표의 onClick 이벤트에 기존에 있던 <code>prevClick</code>과 <code>nextClick</code>함수를 연결해 주면 된다. 코드를 보자. 위에 있는 캐로셀 코드의 컴포넌트 구조를 다음과 같이 바꿔주면 된다.</p>\n<pre><code class=\"language-tsx\">&#x3C;section>\n  &#x3C;div className=\"overflow-hidden\">\n    &#x3C;div className=\"relative flex flex-row justify-between w-full h-[50vh]\">\n      {/* 이 CarouselItem들은 absolute position이기 때문에 레이아웃에서 공간을 차지하지 않는다 */}\n      {items.map((item, index) => (\n        &#x3C;CarouselItem\n          key={item.id}\n          item={item}\n          itemState={determineCarouselItemState(index, carouselIndex)}\n        />\n      ))}\n      &#x3C;button onClick={prevClick} className=\"z-10 h-full\">\n        &#x3C;IoIosArrowBack className=\"text-base-100\" size={60} />\n      &#x3C;/button>\n      &#x3C;button onClick={nextClick} className=\"z-10 h-full\">\n        &#x3C;IoIosArrowForward className=\"text-base-100\" size={60} />\n      &#x3C;/button>\n    &#x3C;/div>\n  &#x3C;/div>\n&#x3C;/section>\n</code></pre>\n<h1>4. 캐로셀 내에 텍스트와 링크 추가하기</h1>\n<p>일반적인 캐로셀에는 텍스트와 링크가 들어가는 경우가 많다. 이번에는 캐로셀 내에 텍스트와 링크를 추가해보자. 먼저 <code>CarouselItemType</code>을 다음과 같이 수정해주자. 캐로셀의 제목, 부제목, 간단한 내용, 그리고 그 캐로셀에 해당하는 링크를 타입에 추가해주었다.</p>\n<pre><code class=\"language-tsx\">interface CarouselItemType {\n  id: number;\n  image: string;\n  title: string;\n  subtitle: string;\n  content: string;\n  link: string;\n}\n</code></pre>\n<p>그리고 다음과 같은 내용들을 담은 샘플을 만들어 주었다. 내용은 나중에 필요한 대로 바꾸면 되니까 일단은 이렇게 해두자.</p>\n<pre><code class=\"language-tsx\">const tempItems: CarouselItemType[] = [\n  {\n    id: 1,\n    image: carouselImage,\n    title: \"환영합니다\",\n    subtitle: \"이건 첫번째 샘플 캐로셀입니다.\",\n    content: \"샘플 캐로셀의 내용입니다.\",\n    link: \"/\",\n  },\n  {\n    id: 2,\n    image: carouselImage2,\n    title: \"환영합니다 2\",\n    subtitle: \"이건 두번째 샘플 캐로셀입니다.\",\n    content: \"샘플 캐로셀의 내용입니다.\",\n    link: \"/\",\n  },\n  {\n    id: 3,\n    image: carouselImage3,\n    title: \"환영합니다 3\",\n    subtitle: \"이건 세번째 샘플 캐로셀입니다.\",\n    content: \"샘플 캐로셀의 내용입니다.\",\n    link: \"/\",\n  },\n];\n</code></pre>\n<p>그러면 이를 수용할 부분을 먼저 만들어 준다. 새로 추가된 제목, 부제목 등의 내용은 캐로셀 요소의 사진 위에 들어가야 한다. 이는 사진과 문서 흐름이 섞이지 않고 배치되어야 함을 뜻한다. 따라서 이 요소는 absolute position으로 지정되어야 한다. 부모에도 absolute position으로 지정된 요소가 있기 때문에 위치 지정 조상 요소에 대해서도 걱정할 필요가 없다.</p>\n<p>앞서 말한 대로 div 태그를 구성하고 나면 내부 내용은 자유롭게 배치하면 된다. 난 그냥 위에서 아래로 쭉 늘어놓았다. 또한 링크는 daisyUI에서 제공하는 버튼을 한번 사용해 보았다. glass 효과를 한번 써보고 싶어서..그리고 링크는 react-router-dom에서 제공하는 Link 컴포넌트이다. 아무튼 캐로셀 개별 아이템은 다음과 같이 생긴 컴포넌트에 수용하였다.</p>\n<pre><code class=\"language-tsx\">&#x3C;div className=\"absolute flex flex-col gap-2 items-center\">\n  &#x3C;h1 className=\"text-4xl text-base-100\">{item.title}&#x3C;/h1>\n  &#x3C;h2 className=\"text-2xl text-base-100\">{item.subtitle}&#x3C;/h2>\n  &#x3C;p className=\"text-base text-base-100\">{item.content}&#x3C;/p>\n  &#x3C;Link to={item.link}>\n    &#x3C;button className=\"btn btn-primary w-32 btn-outline glass hover:glass\">\n      이동하기\n    &#x3C;/button>\n  &#x3C;/Link>\n&#x3C;/div>\n</code></pre>\n<p>이렇게 사진 위에 들어갈 요소들을 디자인했으니 배치해 줘야 한다. 이는 상위 컴포넌트에 <code>flex flex-col justify-center items-center</code> 클래스를 지정해 주면 된다. 이것까지 처리한 <code>CarouselItem</code> 컴포넌트는 다음과 같다.</p>\n<pre><code class=\"language-tsx\">function CarouselItem({\n  item,\n  itemState,\n}: {\n  item: CarouselItemType;\n  itemState: CarouselItemStateType;\n}) {\n  const carouselItemTranslateX = {\n    [CarouselItemStates.PREV]: \"-translate-x-full\",\n    [CarouselItemStates.CURRENT]: \"\",\n    [CarouselItemStates.NEXT]: \"translate-x-full\",\n  };\n\n  return itemState !== CarouselItemStates.INACTIVE ? (\n    &#x3C;div\n      className={`absolute flex flex-col justify-center items-center w-full h-full shrink-0 transition-transform duration-500 ${carouselItemTranslateX[itemState]}`}\n    >\n      &#x3C;img\n        className=\"object-fill w-full h-full\"\n        src={item.image}\n        alt={`carousel-item-${item.id}`}\n      />\n      {/* 사진 위에 배치되는 글자, 링크 등의 요소들이다 */}\n      &#x3C;div className=\"absolute flex flex-col gap-2 items-center\">\n        &#x3C;h1 className=\"text-4xl text-base-100\">{item.title}&#x3C;/h1>\n        &#x3C;h2 className=\"text-2xl text-base-100\">{item.subtitle}&#x3C;/h2>\n        &#x3C;p className=\"text-base text-base-100\">{item.content}&#x3C;/p>\n        &#x3C;Link to={item.link}>\n          &#x3C;button className=\"btn btn-primary w-32 btn-outline glass hover:glass\">\n            이동하기\n          &#x3C;/button>\n        &#x3C;/Link>\n      &#x3C;/div>\n    &#x3C;/div>\n  ) : null;\n}\n</code></pre>\n<p>이렇게 하면 문제없이 캐로셀 요소의 이미지 위에 우리가 원하는 제목, 부제목, 컨텐츠, 링크 버튼이 배치된다. 지금까지 만든 캐로셀의 형태는 다음과 같다.</p>\n<p><img src=\"/static/carousel-3-1-cd0c0809.png\" alt=\"carousel-2-2\"></p>\n<p>단 이 상태에서는 뒤 이미지에 가려서 텍스트가 잘 안 보일 때가 많다. 완벽한 방법은 아니지만 backdrop filter로 배경 이미지에 블러 효과를 넣어 볼 수 있다. tailwind에서는 <code>backdrop-blur-md</code> 클래스로 할 수 있다.</p>\n<p>물론 이렇게 해도 배경 이미지에 흰색이 많이 포함되면 텍스트가 잘 안 보일 수 있다. 이럴 경우에는 텍스트를 검은색으로 바꿔 줄 수도 있겠다.. 하지만 일단은 블러 효과 정도로 만족하고 넘어가자.</p>\n<p>디자인은 조금 조악하지만 어쨌든 있을 건 다 있어 보이고, 버튼들도 잘 동작한다. 애니메이션 효과도 촌스럽긴 하지만 있다. 다 된 것 같은데? 싶지만 물론 그럴 리가 없다. 네비게이션도 구현해야 하고 모바일 환경을 고려해서 터치 이벤트에도 반응하도록 해야 한다. 접근성도 고민해야 한다. 캐로셀이 괜히 난이도가 높은 게 아니다. 하지만 일단 한 고비를 넘은 것 같다. 그러므로 일단 글을 마치고 다음 글에서부터는 캐로셀의 네비게이션을 만들어 보도록 하겠다.</p>\n<h1>참고</h1>\n<p>enum type보다는 union type을 쓰자 <a href=\"https://engineering.linecorp.com/ko/blog/typescript-enum-tree-shaking/\">https://engineering.linecorp.com/ko/blog/typescript-enum-tree-shaking/</a></p>\n<p>position absolute <a href=\"https://developer.mozilla.org/ko/docs/Web/CSS/position\">https://developer.mozilla.org/ko/docs/Web/CSS/position</a></p>\n<p>position css에 대한 좀더 구체적인 설명 <a href=\"https://velog.io/@rimu/css-%EC%9A%94%EC%86%8C%EC%9D%98-%EC%9C%84%EC%B9%98position-%EC%A0%95%EB%A6%AC\">https://velog.io/@rimu/css-%EC%9A%94%EC%86%8C%EC%9D%98-%EC%9C%84%EC%B9%98position-%EC%A0%95%EB%A6%AC</a></p>",
    "excerpt": "1. 캐로셀이 캐로셀처럼 보이지 않아..\n첫번째 글에서 언급한 캐로셀의 조건 중 다음과 같은 것이 있었다.\n\n캐로셀 안에는 넘길 수 있는 내용이 더 있다는 것을 알려 주는 표시자나 내비게이션이 있다.\n이미지와 짧은 텍스트가 있다.\n\n하지만 우리의 캐로셀은 이런 조건들을 만족하지 못하고 있다. 캐로셀을 넘기는 건 이전 슬라이드와 다음 슬라이드버튼에 의존하고 있으며 설명을 위한 짧은 텍스트도 들어가 있지 않다. 캐로셀은 사이트의 메인에 걸리는 핵심 이미지인 만큼 여",
    "headingTree": [
      {
        "title": "1. 캐로셀이 캐로셀처럼 보이지 않아..",
        "url": "#1-캐로셀이-캐로셀처럼-보이지-않아",
        "items": []
      },
      {
        "title": "2. 애니메이션 삽입",
        "url": "#2-애니메이션-삽입",
        "items": []
      },
      {
        "title": "3. 캐로셀 조작을 화살표로 하도록 바꿔주기",
        "url": "#3-캐로셀-조작을-화살표로-하도록-바꿔주기",
        "items": []
      },
      {
        "title": "4. 캐로셀 내에 텍스트와 링크 추가하기",
        "url": "#4-캐로셀-내에-텍스트와-링크-추가하기",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 2,
      "wordCount": 451
    },
    "url": "/posts/carousel-3",
    "thumbnail": {
      "local": "/static/carousel-3-1-cd0c0809.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-carousel-3-1-cd0c0809-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAIAAAA8r+mnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAb0lEQVR4nAFkAJv/AMa3/5ae6Kun9ura/9vQ/8Cy/7yx/5+f6gBgZqMAGEAQPXH/7v//5f//zv93cLEAFjwATlF4AAUlAClFkZS3x7PWyanQSF2GFEpdACqBfjyNlBSCeRaDeB2KgB+OhRmHfiCQg5rAM6r7oEpoAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "carousel-6",
    "title": "프로젝트 작업 - 캐로셀 제작기 6",
    "date": "2022-08-30T00:00:00Z",
    "description": "우당탕탕 캐로셀 제작기 그 여섯번째, 터치 이벤트 처리",
    "tags": [
      "web",
      "front",
      "react"
    ],
    "html": "<h1>1. 터치 이벤트의 필요성</h1>\n<p>지금 우리의 캐로셀은 오직 마우스 클릭을 이용해서만 사용할 수 있다. 하지만 모바일 환경에서는 마우스로 화살표 버튼을 클릭해서 다음 페이지로 넘어가는 게 그렇게 편한 조작이 아니다. 모바일 화면에서 스와이프를 통해서도 캐로셀을 넘길 수 있게 해야 한다. 따라서 이를 구현한다.</p>\n<h1>2. 터치 이벤트 감지</h1>\n<p>사용자가 모바일 화면에서 스와이프하는 것을 감지하는 로직은 간단하다. 먼저 사용자가 화면을 터치하면 터치 시작 위치를 기억한다. 그리고 사용자가 터치를 이동하면 그 위치를 계속 갱신한다. 그리고 사용자가 터치하고 있는 위치가 처음에 사용자가 터치를 시작한 위치와 X축 상에서 일정 정도 이상의 차이를 갖게 되면 스와이프를 했다고 간주한다. 이를 구현해보자.</p>\n<p>먼저 사용자의 터치 위치를 저장하는 state와 사용자가 터치를 시작할 때 터치한 위치를 저장하는 함수 <code>handleTouchStart</code>를 만들어준다.</p>\n<pre><code class=\"language-tsx\">// 터치를 시작하지 않았을 땐 널 상태이다\nconst [touchPosition, setTouchPosition] = useState&#x3C;number | null>(null);\n\nconst handleTouchStart = (e: React.TouchEvent&#x3C;HTMLDivElement>) => {\n  const touchDown = e.touches[0].clientX;\n  setTouchPosition(touchDown);\n};\n</code></pre>\n<p>그리고 사용자가 터치를 이동할 때마다 터치 위치를 갱신하는 함수 <code>handleTouchMove</code>를 만들어준다. 이 함수는 <code>handleTouchStart</code>에서 저장한 터치 위치와 현재 터치 위치의 차이를 계산해서 그 차이가 일정 정도 이상(여기서는 10픽셀 이상)이면 스와이프를 했다고 간주한다.</p>\n<p>이렇게 스와이프가 되었을 떄는 페이지를 넘길 때 사용했던 <code>prevClick</code>, <code>nextClick</code>함수를 호출해서 적절한 방향으로 캐로셀 페이지를 넘겨준다.</p>\n<p>또한 한번 스와이프를 하고 나면 <code>TouchPosition</code>을 다시 null로 초기화시켜 준다. 따라서 10픽셀 이상 긴 스와이프를 하더라도 한번만 스와이프된 것으로 간주하도록 한다.</p>\n<pre><code class=\"language-tsx\">const handleTouchMove = (e: React.TouchEvent&#x3C;HTMLDivElement>) => {\n  // 터치를 시작했던 위치 저장\n  const touchStarted = touchPosition;\n  //만약 아직 터치를 시작하지 않았던 상태거나 이미 터지를\n  if (touchStarted === null) {\n    return;\n  }\n\n  const currentTouch = e.touches[0].clientX;\n  const diff = touchStarted - currentTouch;\n\n  if (diff > 10) {\n    nextClick();\n  }\n\n  if (diff &#x3C; -10) {\n    prevClick();\n  }\n\n  setTouchPosition(null);\n};\n</code></pre>\n<p>이제 이 터치 관련 함수들을 캐로셀을 감싸는 div에 적용하면 된다. 이때 캐로셀 네비게이션에는 스와이프 이벤트를 넣지 않을 것이므로 네비게이션까지 감싸는 요소에 이벤트를 넣지 않도록 주의한다.</p>\n<p>이를 반영한 캐로셀 컴포넌트는 다음과 같다.</p>\n<pre><code class=\"language-tsx\">function Carousel({ items }: { items: CarouselItemType[] }) {\n  const [carouselIndex, setCarouselIndex] = useState&#x3C;CarouselIndexType>({\n    previousIndex: items.length - 1,\n    currentIndex: 0,\n  });\n\n  const [touchPosition, setTouchPosition] = useState&#x3C;number | null>(null);\n\n  const prevClick = () => {\n    setCarouselIndex((prev) => ({\n      previousIndex: prev.currentIndex,\n      currentIndex: (prev.currentIndex - 1 + items.length) % items.length,\n    }));\n  };\n\n  const nextClick = () => {\n    setCarouselIndex((prev) => ({\n      previousIndex: prev.currentIndex,\n      currentIndex: (prev.currentIndex + 1) % items.length,\n    }));\n  };\n\n  const handleTouchStart = (e: React.TouchEvent&#x3C;HTMLDivElement>) => {\n    const touchDown = e.touches[0].clientX;\n    setTouchPosition(touchDown);\n  };\n\n  const handleTouchMove = (e: React.TouchEvent&#x3C;HTMLDivElement>) => {\n    const touchStarted = touchPosition;\n\n    if (touchStarted === null) {\n      return;\n    }\n\n    const currentTouch = e.touches[0].clientX;\n    const diff = touchStarted - currentTouch;\n\n    if (diff > 10) {\n      nextClick();\n    }\n    // 차이가 음수이면 오른쪽으로 스와이프했다는 뜻\n    if (diff &#x3C; -10) {\n      prevClick();\n    }\n\n    setTouchPosition(null);\n  };\n\n  // 각 캐로셀 아이템의 상태를 결정하는 함수\n  const determineCarouselItemState = useCallback(\n    (itemIndex: number) => {\n      if (itemIndex === carouselIndex.currentIndex) {\n        return CarouselItemStates.CURRENT;\n      } else if (itemIndex === carouselIndex.previousIndex) {\n        return CarouselItemStates.PREVIOUS;\n      } else {\n        return CarouselItemStates.INACTIVE;\n      }\n    },\n    [carouselIndex]\n  );\n\n  return (\n    &#x3C;section>\n      &#x3C;div\n        className=\"relative flex flex-row justify-between w-full h-[50vh]\"\n        onTouchStart={handleTouchStart}\n        onTouchMove={handleTouchMove}\n      >\n        {/* 이 CarouselItem들은 absolute position이기 때문에 레이아웃에서 공간을 차지하지 않는다 */}\n        {items.map((item, index) => (\n          &#x3C;CarouselItem\n            key={item.id}\n            item={item}\n            itemState={determineCarouselItemState(index)}\n          />\n        ))}\n        &#x3C;button onClick={prevClick} className=\"z-10 h-full\">\n          &#x3C;IoIosArrowBack className=\"text-base-100\" size={60} />\n        &#x3C;/button>\n        &#x3C;button onClick={nextClick} className=\"z-10 h-full\">\n          &#x3C;IoIosArrowForward className=\"text-base-100\" size={60} />\n        &#x3C;/button>\n      &#x3C;/div>\n      &#x3C;CarouselNavigation\n        items={items}\n        carouselIndex={carouselIndex}\n        setCarouselIndex={setCarouselIndex}\n      />\n    &#x3C;/section>\n  );\n}\n</code></pre>\n<p>이제 크롬의 개발자 도구에서 디바이스 툴바를 이용해서 모바일 환경에서 캐로셀을 테스트해보자. 이제 스와이프로도 캐로셀을 넘길 수 있게 되었다. 다음 글에서는 디자인에서 잡다한 수정 사항들을 반영하면서 캐로셀을 마무리하도록 하겠다.</p>\n<h1>참고</h1>\n<p>스와이프를 지원하는 캐로셀 만드는 법을 자세히 설명한 글. 이 글을 그대로 따라했다. <a href=\"https://dev.to/rakumairu/how-to-handle-swipe-event-on-react-carousel-24ab\">https://dev.to/rakumairu/how-to-handle-swipe-event-on-react-carousel-24ab</a></p>",
    "excerpt": "1. 터치 이벤트의 필요성\n지금 우리의 캐로셀은 오직 마우스 클릭을 이용해서만 사용할 수 있다. 하지만 모바일 환경에서는 마우스로 화살표 버튼을 클릭해서 다음 페이지로 넘어가는 게 그렇게 편한 조작이 아니다. 모바일 화면에서 스와이프를 통해서도 캐로셀을 넘길 수 있게 해야 한다. 따라서 이를 구현한다.\n2. 터치 이벤트 감지\n사용자가 모바일 화면에서 스와이프하는 것을 감지하는 로직은 간단하다. 먼저 사용자가 화면을 터치하면 터치 시작 위치를 기억한다. 그리고 사",
    "headingTree": [
      {
        "title": "1. 터치 이벤트의 필요성",
        "url": "#1-터치-이벤트의-필요성",
        "items": []
      },
      {
        "title": "2. 터치 이벤트 감지",
        "url": "#2-터치-이벤트-감지",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 257
    },
    "url": "/posts/carousel-6",
    "thumbnail": {
      "local": "/thumbnails/carousel-6-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-carousel-6-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAjklEQVR4nE3MIQrDMBSA4dgcoCeIi66szhkiYiNyi0DhQVxhsDExGIXq+Ii6+vjRNxUfERfx5sp++8HPAEBKKYQwxkzTFEIYhmEcR6a15pwrpdZ1zTkj4r7vKSUWY7TWOue897VWIuq9ExE7jgMA5nleluWC3jv7nIj4LaW01ugv9ny9b/fHtm055+tDRD/n2WMNrmso4AAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "carousel-5",
    "title": "프로젝트 작업 - 캐로셀 제작기 5",
    "date": "2022-08-29T00:00:00Z",
    "description": "우당탕탕 캐로셀 제작기 그 다섯번째, 캐로셀 작동 방식 리뉴얼",
    "tags": [
      "web",
      "front",
      "react"
    ],
    "html": "<h1>1. 캐로셀의 작동 방식 바꾸기</h1>\n<p>지금까지 만든 캐로셀은 사진을 긴 띠처럼 배열한 후 이를 평행 이동하는 방식으로 작동한다. 하지만 이는 전환 효과 등을 넣는 데에 있어서 여러 힘든 점이 있었다. 따라서 이를 다른 방식으로 바꿀 것이다.</p>\n<p>원래는 지금까지 한 글들도 새로 설계한 방식에 맞게 리뉴얼하려고 했지만 여러 방식을 고민했던 흔적을 남겨 놓고자 이전 글들은 그대로 남겨 놓는다.</p>\n<p>새로 설계한 방식은 다음과 같다. 이전에 표시하고 있던 이미지의 인덱스(<code>previousIndex</code>)와 현재 표시중인 이미지의 인덱스(<code>currentIndex</code>) 2개의 페이지 인덱스를 저장해 놓는다. 그리고 새로운 이미지를 표시하려고 할 시 기존에 표시하던 이미지 인덱스를 <code>previousIndex</code>로 보내고 새로운 이미지 인덱스를 <code>currentIndex</code> 로 만든다.</p>\n<p>그 후 이전 이미지는 투명도 0으로 표시하고 새로운 이미지는 투명도 1로 표시한다. 그리고 나서 이전 이미지의 z-index를 새로운 이미지보다 높게 주면 기존에 표시하던 이미지는 사라지고 새로운 이미지가 나타나는 효과를 낼 수 있다.</p>\n<p>새로운 이미지는 즉시 렌더링되지만 이전 이미지가 z-index가 더 높다. 그래서 이렇게 하면 기존 이미지가 새로운 이미지를 덮은 상태에서 투명도가 줄어들면서 사라지는 효과를 보일 수 있다.</p>\n<h1>2. 캐로셀의 작동 방식 바꾸기 - 코드</h1>\n<h2>2.1 타입 정의</h2>\n<p>캐로셀의 각 페이지의 상태를 나타내는 타입을 다음과 같이 다시 정의하였다.</p>\n<pre><code class=\"language-tsx\">const CarouselItemStates = {\n  CURRENT: \"current\",\n  PREVIOUS: \"previous\",\n  INACTIVE: \"inactive\",\n} as const;\ntype CarouselItemStateType =\n  typeof CarouselItemStates[keyof typeof CarouselItemStates];\n</code></pre>\n<p>말 그대로다. currentsms 현재 표시중인 페이지, previous는 이전에 표시하던 페이지, inactive는 표시되지 않는 페이지를 나타낸다.</p>\n<h2>2.2 CarouselItem 컴포넌트</h2>\n<p>CarouselItem 컴포넌트는 다음과 같이 변경되었다. 현재 표시중인 페이지는 투명도 1, 이전 페이지는 투명도 0인 대신 z-index를 높게 줘서 사라지는 효과가 사용자에게 보일 수 있도록 했다. 그리고 inactive 상태의 페이지는 hidden(<code>display:none</code>과 동일)클래스를 줬지만 만약 inactive 상태의 페이지일 경우 아예 null을 반환하여 렌더링이 되지 않도록 했다.</p>\n<pre><code class=\"language-tsx\">function CarouselItem({\n  item,\n  itemState,\n}: {\n  item: CarouselItemType;\n  itemState: CarouselItemStateType;\n}) {\n  const carouselItemStateConfig = {\n    [CarouselItemStates.CURRENT]: \"opacity-100\",\n    [CarouselItemStates.PREVIOUS]: \"opacity-0 z-10\",\n    [CarouselItemStates.INACTIVE]: \"hidden\",\n  };\n\n  return itemState !== CarouselItemStates.INACTIVE ? (\n    &#x3C;div\n      className={`absolute flex flex-col justify-center items-center w-full h-full shrink-0 transition-opacity duration-700 ${carouselItemStateConfig[itemState]}`}\n    >\n      &#x3C;img\n        className=\"object-fill w-full h-full\"\n        src={item.image}\n        alt={`carousel-item-${item.id}`}\n      />\n      &#x3C;div className=\"backdrop-blur-md p-3 rounded-3xl absolute flex flex-col gap-2 items-center\">\n        &#x3C;h1 className=\"text-4xl text-base-100\">{item.title}&#x3C;/h1>\n        &#x3C;h2 className=\"text-2xl text-base-100\">{item.subtitle}&#x3C;/h2>\n        &#x3C;p className=\"text-base text-base-100\">{item.content}&#x3C;/p>\n        &#x3C;Link to={item.link}>\n          &#x3C;button className=\"btn btn-primary w-32 btn-outline glass hover:glass\">\n            이동하기\n          &#x3C;/button>\n        &#x3C;/Link>\n      &#x3C;/div>\n    &#x3C;/div>\n  ) : null;\n}\n</code></pre>\n<h2>2.3 Carousel 컴포넌트</h2>\n<p>Carousel 컴포넌트는 다음과 같이 변경되었다. carouselIndex 형식을 변경하고 그에 따라 <code>prevClick</code>, <code>nextClick</code>함수를 변경한 것, 그리고 <code>determineCarouselItemState</code>를 도입해 각 페이지의 상태를 결정하는 변경사항이 있었다.</p>\n<p>또한 이제 캐로셀의 작동 방식이 바뀌어서 화면 밖으로 넘쳐 나오는 사진이 없다. 따라서 화면 밖으로 나오는 사진을 가리기 위해 <code>overflow-hidden</code>클래스를 주었던 div element를 제거하였다.</p>\n<pre><code class=\"language-tsx\">function Carousel({ items }: { items: CarouselItemType[] }) {\n  const [carouselIndex, setCarouselIndex] = useState&#x3C;CarouselIndexType>({\n    previousIndex: items.length - 1,\n    currentIndex: 0,\n  });\n\n  const prevClick = () => {\n    setCarouselIndex((prev) => ({\n      previousIndex: prev.currentIndex,\n      currentIndex: (prev.currentIndex - 1 + items.length) % items.length,\n    }));\n  };\n\n  const nextClick = () => {\n    setCarouselIndex((prev) => ({\n      previousIndex: prev.currentIndex,\n      currentIndex: (prev.currentIndex + 1) % items.length,\n    }));\n  };\n\n  // 각 캐로셀 아이템의 상태를 결정하는 함수\n  const determineCarouselItemState = useCallback(\n    (itemIndex: number) => {\n      if (itemIndex === carouselIndex.currentIndex) {\n        return CarouselItemStates.CURRENT;\n      } else if (itemIndex === carouselIndex.previousIndex) {\n        return CarouselItemStates.PREVIOUS;\n      } else {\n        return CarouselItemStates.INACTIVE;\n      }\n    },\n    [carouselIndex]\n  );\n\n  return (\n    &#x3C;section>\n      &#x3C;div className=\"relative flex flex-row justify-between w-full h-[50vh]\">\n        {/* 이 CarouselItem들은 absolute position이기 때문에 레이아웃에서 공간을 차지하지 않는다 */}\n        {items.map((item, index) => (\n          &#x3C;CarouselItem\n            key={item.id}\n            item={item}\n            itemState={determineCarouselItemState(index)}\n          />\n        ))}\n        &#x3C;button onClick={prevClick} className=\"z-10 h-full\">\n          &#x3C;IoIosArrowBack className=\"text-base-100\" size={60} />\n        &#x3C;/button>\n        &#x3C;button onClick={nextClick} className=\"z-10 h-full\">\n          &#x3C;IoIosArrowForward className=\"text-base-100\" size={60} />\n        &#x3C;/button>\n      &#x3C;/div>\n      &#x3C;CarouselNavigation\n        items={items}\n        carouselIndex={carouselIndex}\n        setCarouselIndex={setCarouselIndex}\n      />\n    &#x3C;/section>\n  );\n}\n</code></pre>\n<p>네비게이션에 따른 전환 효과도 이제 잘 작동한다. 어떤 페이지로 이동해도 기존 이미지가 사라지고 새로운 이미지가 잘 표시된다. 이제 다음 글들에서는 잡다한 수정 사항들을 처리하고, 터치 이벤트에 대해 처리해 보겠다.</p>",
    "excerpt": "1. 캐로셀의 작동 방식 바꾸기\n지금까지 만든 캐로셀은 사진을 긴 띠처럼 배열한 후 이를 평행 이동하는 방식으로 작동한다. 하지만 이는 전환 효과 등을 넣는 데에 있어서 여러 힘든 점이 있었다. 따라서 이를 다른 방식으로 바꿀 것이다.\n원래는 지금까지 한 글들도 새로 설계한 방식에 맞게 리뉴얼하려고 했지만 여러 방식을 고민했던 흔적을 남겨 놓고자 이전 글들은 그대로 남겨 놓는다.\n새로 설계한 방식은 다음과 같다. 이전에 표시하고 있던 이미지의 인덱스(previo",
    "headingTree": [
      {
        "title": "1. 캐로셀의 작동 방식 바꾸기",
        "url": "#1-캐로셀의-작동-방식-바꾸기",
        "items": []
      },
      {
        "title": "2. 캐로셀의 작동 방식 바꾸기 - 코드",
        "url": "#2-캐로셀의-작동-방식-바꾸기---코드",
        "items": [
          {
            "title": "2.1 타입 정의",
            "url": "#21-타입-정의",
            "items": []
          },
          {
            "title": "2.2 CarouselItem 컴포넌트",
            "url": "#22-carouselitem-컴포넌트",
            "items": []
          },
          {
            "title": "2.3 Carousel 컴포넌트",
            "url": "#23-carousel-컴포넌트",
            "items": []
          }
        ]
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 300
    },
    "url": "/posts/carousel-5",
    "thumbnail": {
      "local": "/thumbnails/carousel-5-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-carousel-5-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAj0lEQVR4nC2LIQ7DIBRAsRygHl2N6h06/Q/xNQkXIEGv2TKxZAZB0gSPwOFxiGYTP+kNcBUsWffse48ZY8ZxFEIAwDRN1tphGKSUDAA45/Nl9t7XWokopRRjZOu6AgAiKqW890TUf7CcMyIaY7TWy7KEEE7HtveHiPZ9b62d7f94PF/X2905V0rpvR/HcYov2XFfFxeAQUkAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "carousel-7",
    "title": "프로젝트 작업 - 캐로셀 제작기 7",
    "date": "2022-08-30T01:00:00Z",
    "description": "우당탕탕 캐로셀 제작기 그 일곱번째, 마무리 다듬기",
    "tags": [
      "web",
      "front",
      "react"
    ],
    "html": "<h1>1. 화살표 버튼을 네비게이션 바로</h1>\n<p>지금의 캐로셀에서는 캐로셀을 앞뒤 페이지로 이동시킬 수 있는 화살표 버튼이 있는데 이걸 네비게이션 바로 옮기도록 하겠다. 캐로셀의 이동은 아래의 네비게이션 바에서 모두 책임지는 게 나을 것 같다는 판단이다.</p>\n<p>그런데 이미 캐로셀 네비게이션 컴포넌트에서는 각 네비게이션 아이템을 클릭할 때 그 아이템에 해당하는 페이지로 이동하는 기능을 담당하고 있다. 즉 캐로셀의 페이지를 조절하는 기능을 이미 가지고 있다는 것이다. <code>carouselIndex</code>와 <code>setCarouselIndex</code>를 props로 받는 것으로 확인할 수 있다.</p>\n<p>즉 props 등을 바꿔 줄 필요는 없다. 원래 있던 <code>prevClick</code>함수와 <code>nextClick</code>함수 그리고 그 함수를 클릭 이벤트에 따라 발동시키던 버튼을 캐로셀 네비게이션 컴포넌트로 옮겨 주기만 하면 된다.</p>\n<p>이를 수정한 <code>CarouselNavigation</code>컴포넌트는 다음과 같아진다.</p>\n<pre><code class=\"language-tsx\">function CarouselNavigation({\n  items,\n  carouselIndex,\n  setCarouselIndex,\n}: {\n  items: CarouselItemType[];\n  // 현재 캐로셀이 보여주고 있는 인덱스\n  carouselIndex: CarouselIndexType;\n  setCarouselIndex: React.Dispatch&#x3C;React.SetStateAction&#x3C;CarouselIndexType>>;\n}) {\n  //버튼의 상태를 결정하는 함수\n  const determineCarouselItemState = (itemIndex: number) => {\n    if (itemIndex === carouselIndex.currentIndex) {\n      return \"active\";\n    } else if (\n      /* \n    캐로셀의 초반부나 후반부 페이지가 활성화되어있을 경우 \n    활성화 요소를 가운데에 배치하지 못하더라도 5개를 일단 채운다 \n    */\n      carouselIndex.currentIndex === 0 ||\n      carouselIndex.currentIndex === 1\n    ) {\n      return itemIndex &#x3C; 5 ? \"pending\" : \"inactive\";\n    } else if (\n      carouselIndex.currentIndex === items.length - 1 ||\n      carouselIndex.currentIndex === items.length - 2\n    ) {\n      return itemIndex >= items.length - 5 ? \"pending\" : \"inactive\";\n    } else {\n      return carouselIndex.currentIndex - 2 &#x3C;= itemIndex &#x26;&#x26;\n        itemIndex &#x3C;= carouselIndex.currentIndex + 2\n        ? \"pending\"\n        : \"inactive\";\n    }\n  };\n\n  // 특정 인덱스의 페이지로 이동하는 함수\n  const onCarouselNavigationItemClick = (itemIndex: number) => {\n    setCarouselIndex((prev) => {\n      if (prev.currentIndex === itemIndex) {\n        return prev;\n      } else {\n        return {\n          previousIndex: prev.currentIndex,\n          currentIndex: itemIndex,\n        };\n      }\n    });\n    //console.log(carouselIndex);\n  };\n\n  const handlePrevClick = () => {\n    setCarouselIndex((prev) => ({\n      previousIndex: prev.currentIndex,\n      currentIndex: (prev.currentIndex - 1 + items.length) % items.length,\n    }));\n  };\n\n  const handleNextClick = () => {\n    setCarouselIndex((prev) => ({\n      previousIndex: prev.currentIndex,\n      currentIndex: (prev.currentIndex + 1) % items.length,\n    }));\n  };\n\n  return (\n    &#x3C;dl className=\"flex flex-row w-full h-10\">\n      &#x3C;button onClick={handlePrevClick} className=\"z-10 h-full\">\n        &#x3C;IoIosArrowBack className=\"text-gray-500\" size={30} />\n      &#x3C;/button>\n      {items.map((item, index) => (\n        &#x3C;CarouselNavigationItem\n          key={index}\n          item={item}\n          itemState={determineCarouselItemState(index)}\n          onItemClick={() => {\n            onCarouselNavigationItemClick(index);\n          }}\n        />\n      ))}\n      &#x3C;button onClick={handleNextClick} className=\"z-10 h-full\">\n        &#x3C;IoIosArrowForward className=\"text-gray-500\" size={30} />\n      &#x3C;/button>\n    &#x3C;/dl>\n  );\n}\n</code></pre>\n<p>이참에 <code>determineCarouselItemState</code> 함수도 컴포넌트 외부로 빼버리자. 다음과 같이 함수를 수정하고 컴포넌트 외부로 뺀 후 <code>CarouselNavigationItem</code>컴포넌트에서 사용될 때 인수를 적절히 바꿔주면 된다.</p>\n<pre><code class=\"language-tsx\">//버튼의 상태를 결정하는 함수\nfunction determineCarouselItemState(\n  itemIndex: number,\n  carouselCurrentIndex: number,\n  carouselTotalLength: number\n) {\n  if (itemIndex === carouselCurrentIndex) {\n    return \"active\";\n  } else if (carouselCurrentIndex === 0 || carouselCurrentIndex === 1) {\n    return itemIndex &#x3C; 5 ? \"pending\" : \"inactive\";\n  } else if (\n    carouselCurrentIndex === carouselTotalLength - 1 ||\n    carouselCurrentIndex === carouselTotalLength - 2\n  ) {\n    return itemIndex >= carouselTotalLength - 5 ? \"pending\" : \"inactive\";\n  } else {\n    return carouselCurrentIndex - 2 &#x3C;= itemIndex &#x26;&#x26;\n      itemIndex &#x3C;= carouselCurrentIndex + 2\n      ? \"pending\"\n      : \"inactive\";\n  }\n}\n</code></pre>\n<p>그리고 캐로셀 컴포넌트에선 <code>prevClick</code>함수와 <code>nextClick</code>함수 그리고 그 함수를 클릭 이벤트에 따라 발동시키던 화살표 버튼을 삭제해 준다. 이제 캐로셀을 렌더링해 보면 다음과 같이 화살표 버튼이 네비게이션 바에 들어가 있으며 페이지 전환 기능도 잘 동작하는 것을 볼 수 있다.</p>\n<p><img src=\"/static/carousel-7-1-bc5698ff.png\" alt=\"carousel-7-1\"></p>\n<h1>2. 캐로셀 네비게이션 디자인 리뉴얼</h1>\n<h2>2.1 네비게이션 바 디자인</h2>\n<p>지금 네비게이션 바는 매우 못생겼다. 따라서 이를 최대한 리뉴얼해보고자 한다. 역시 메이플스토리 메인 페이지의 캐로셀 디자인을 참고하였다.</p>\n<p>먼저 네비게이션 바를 캐로셀 내부에 포함시킨다. 현재 캐로셀 페이지 컴포넌트들은 absolute position으로 관리되고 있기 때문에 레이아웃 내에서 명목상으론 공간을 차지하지 않고 따라서 네비게이션 바만 배치한다고 생각하면 된다.</p>\n<p>고로 캐로셀을 감싸는 div element 내에 <code>CarouselNavigation</code>컴포넌트를 넣고 하단부에 배치하기 위해 <code>items-center</code>클래스를 추가한다. 그러면 캐로셀 컴포넌트의 구조는 다음과 같아진다.</p>\n<pre><code class=\"language-tsx\">&#x3C;section>\n  &#x3C;div\n    className=\"relative flex flex-row items-end justify-between w-full h-[60vh]\"\n    onTouchStart={handleTouchStart}\n    onTouchMove={handleTouchMove}\n  >\n    {/* 이 CarouselItem들은 absolute position이기 때문에 레이아웃에서 공간을 차지하지 않는다 */}\n    {items.map((item, index) => (\n      &#x3C;CarouselItem\n        key={item.id}\n        item={item}\n        itemState={determineCarouselItemState(index)}\n      />\n    ))}\n    &#x3C;CarouselNavigation\n      items={items}\n      carouselIndex={carouselIndex}\n      setCarouselIndex={setCarouselIndex}\n    />\n  &#x3C;/div>\n&#x3C;/section>\n</code></pre>\n<p>이제 캐로셀 네비게이션 바의 색을 좀 바꾸고 투명도를 넣어서 캐로셀에 표시되고 있는 이미지가 약간은 네비게이션 바 너머로 비치게 하자. 그럼으로써 네비게이션 바가 캐로셀에 포함되어 있다는 것을 좀더 확실히 보여주도록 하자. 거기에 따라 화살표의 색도 바꾸어주고, 네비게이션 바의 높이도 캐로셀의 높이와 상대적이 되도록 설정한다. 그리고 z-index를 설정하여 캐로셀의 이미지들이 네비게이션 바를 가리지 않도록 한다.</p>\n<p>따라서 <code>dl</code> 태그에는 <code>h-[10%] bg-gray-400/70 z-20</code>클래스를 주었과 화살표 버튼의 색은 <code>text-gray-300</code> 클래스로 설정했다. 완성된 네비게이션 바 컴포넌트는 다음과 같다.</p>\n<pre><code class=\"language-tsx\">function CarouselNavigation({\n  items,\n  carouselIndex,\n  setCarouselIndex,\n}: {\n  items: CarouselItemType[];\n  // 현재 캐로셀이 보여주고 있는 인덱스\n  carouselIndex: CarouselIndexType;\n  setCarouselIndex: React.Dispatch&#x3C;React.SetStateAction&#x3C;CarouselIndexType>>;\n}) {\n  // 특정 인덱스의 페이지로 이동하는 함수\n  const onCarouselNavigationItemClick = (itemIndex: number) => {\n    setCarouselIndex((prev) => {\n      if (prev.currentIndex === itemIndex) {\n        return prev;\n      } else {\n        return {\n          previousIndex: prev.currentIndex,\n          currentIndex: itemIndex,\n        };\n      }\n    });\n  };\n\n  const handlePrevClick = () => {\n    setCarouselIndex((prev) => ({\n      previousIndex: prev.currentIndex,\n      currentIndex: (prev.currentIndex - 1 + items.length) % items.length,\n    }));\n  };\n\n  const handleNextClick = () => {\n    setCarouselIndex((prev) => ({\n      previousIndex: prev.currentIndex,\n      currentIndex: (prev.currentIndex + 1) % items.length,\n    }));\n  };\n\n  return (\n    &#x3C;dl className=\"flex flex-row w-full h-[10%] bg-gray-400/70 z-20\">\n      &#x3C;button onClick={handlePrevClick} className=\"z-10 h-full\">\n        &#x3C;IoIosArrowBack className=\"text-gray-300\" size={30} />\n      &#x3C;/button>\n      {items.map((item, index) => (\n        &#x3C;CarouselNavigationItem\n          key={index}\n          item={item}\n          itemState={determineCarouselItemState(\n            index,\n            carouselIndex.currentIndex,\n            items.length\n          )}\n          onItemClick={() => {\n            onCarouselNavigationItemClick(index);\n          }}\n        />\n      ))}\n      &#x3C;button onClick={handleNextClick} className=\"z-10 h-full\">\n        &#x3C;IoIosArrowForward className=\"text-gray-300\" size={30} />\n      &#x3C;/button>\n    &#x3C;/dl>\n  );\n}\n</code></pre>\n<h2>2.2 CarouselNavigationItem 디자인</h2>\n<p>이제 네비게이션의 각 아이템을 디자인한다. 먼저 네비게이션 아이템들의 멋없는 테두리를 모두 없앤 후 네비게이션 바에 적절한 간격을 두고 위치하도록 했다. 또한 활성화된 아이템의 경우 이미지를 더 밝게 보여주고 이미지에 초록색 테두리를 치는 등으로 강조해 주었다. 텍스트 색도 다르게 했다.</p>\n<p>이를 적용한 <code>CarouselNavigationItem</code> 컴포넌트는 다음과 같다.</p>\n<pre><code class=\"language-tsx\">function CarouselNavigationItem({\n  item,\n  itemState,\n  onItemClick,\n}: {\n  item: CarouselItemType;\n  itemState: string;\n  onItemClick: () => void;\n}) {\n  // active는 현재 캐로셀에서 보이고 있는 아이템에 해당하는 버튼의 상태\n  // pending은 화면에는 보이지만 활성화되어 있지 않은 버튼의 상태\n  const carouselItemConfig: { [key: string]: string } = {\n    active: \"text-base-100 hover:bg-gray-600\",\n    pending:\n      \"brightness-50 text-gray-500 hover:brightness-100 hover:bg-gray-400\",\n    inactive: \"hidden\",\n  };\n\n  return (\n    &#x3C;button\n      onClick={onItemClick}\n      className={`flex-1 flex flex-row mx-1 items-center transition-all duration-700 ${carouselItemConfig[itemState]}`}\n    >\n      &#x3C;dt\n        className={`flex-1 w-full h-full ${\n          itemState === \"active\" ? \"py-1.5 px-1\" : \"p-2\"\n        }`}\n      >\n        &#x3C;img\n          className={`object-fill w-full h-full ${\n            itemState === \"active\" ? \"border-2 border-primary\" : \"\"\n          }`}\n          src={item.image}\n          alt={`carousel-item-${item.id}`}\n        />\n      &#x3C;/dt>\n      &#x3C;dd className=\"flex-1 text-sm\">{item.title}&#x3C;/dd>\n    &#x3C;/button>\n  );\n}\n</code></pre>\n<p>이제 아까보단 좀 나은 캐로셀 네비게이션의 모습을 볼 수 있다.</p>\n<p><img src=\"/static/carousel-7-2-e08d3fcc.png\" alt=\"carousel-7-2\"></p>\n<h2>2.3 모바일 화면의 뷰 수정</h2>\n<p>하지만 아직 네비게이션 바에 문제가 하나 있다. 화면의 크기에 따라 뷰가 너무 차이난다는 것이다. 가령 큰 화면에선 좀 더 못생긴 네비게이션이 나온다.</p>\n<p>그래도 큰 화면에서 생기는 문제는 넘어가줄 만 하다. 가장 큰 문제는 모바일 화면이다. 모바일 화면에서는 네비게이션 바가 너무 작아서 아이템들을 제대로 볼 수 없다.</p>\n<p><img src=\"/static/carousel-7-3-b82bb8d9.png\" alt=\"carousel-7-3\"></p>\n<p>이는 그렇게 세련되지는 않았지만 간단한 방식으로 해결해 주었다. 모바일 화면에서는 네비게이션 바에서 각 페이지의 이미지를 보여주지 않도록 하는 것이다. 이는 tailwind에서 반응형 디자인을 아주 쉽게 할 수 있도록 제공해 주기 때문에 더 쉽게 해결할 수 있었다.</p>\n<p><code>CarouselNavigationItem</code>에서 이미지를 포함하고 있는 dt태그를 기본적으로 hidden(display:none과 같다)클래스로 설정해 주고 화면 너비가 768px 이상이 될 때만 보이도록 설정해 주었다. 코드는 다음과 같지만 dt 태그 외에는 변경사항이 없으므로 그것만 보면 된다.</p>\n<pre><code class=\"language-tsx\">function CarouselNavigationItem({\n  item,\n  itemState,\n  onItemClick,\n}: {\n  item: CarouselItemType;\n  itemState: string;\n  onItemClick: () => void;\n}) {\n  // active는 현재 캐로셀에서 보이고 있는 아이템에 해당하는 버튼의 상태\n  // pending은 화면에는 보이지만 활성화되어 있지 않은 버튼의 상태\n  const carouselItemConfig: { [key: string]: string } = {\n    active: \"text-base-100 hover:bg-gray-600\",\n    pending:\n      \"brightness-50 text-gray-500 hover:brightness-100 hover:bg-gray-400\",\n    inactive: \"hidden\",\n  };\n\n  return (\n    &#x3C;button\n      onClick={onItemClick}\n      className={`flex-1 flex flex-row mx-1 items-center transition-all duration-700 ${carouselItemConfig[itemState]}`}\n    >\n      &#x3C;dt\n        className={`hidden md:block flex-1 w-full h-full ${\n          itemState === \"active\" ? \"py-1.5 px-1\" : \"p-2\"\n        }`}\n      >\n        &#x3C;img\n          className={`object-fill w-full h-full ${\n            itemState === \"active\" ? \"border-2 border-primary\" : \"\"\n          }`}\n          src={item.image}\n          alt={`carousel-item-${item.id}`}\n        />\n      &#x3C;/dt>\n      &#x3C;dd className=\"flex-1 text-sm\">{item.title}&#x3C;/dd>\n    &#x3C;/button>\n  );\n}\n</code></pre>\n<p>이렇게 하면 모바일 화면에서는 아래와 같이 네비게이션 바에서 이미지가 보이지 않게 된다. 좀 볼품없어지기는 했지만 아까처럼 텍스트가 네비게이션 바를 넘어가서 늘어지는 것보다는 낫다.</p>\n<p><img src=\"/static/carousel-7-4-9410a683.png\" alt=\"carousel-7-4\"></p>\n<h1>3. 네비게이션 바에 페이지 번호 표시</h1>\n<p>이는 캐로셀 네비게이션에서 캐로셀의 현재 인덱스와 전체 items를 props로 받기 때문에 디자인만 하면 간단하게 구현할 수 있다. 위치를 잡는 건 absolute position으로 처리하고 나머지 디자인은 네비게이션 바 아이템과 같은 색, 그리고 적절한 크기로 구현하면 된다.</p>\n<p>다음과 같은 버튼을 <code>CarouselNavigation</code> 컴포넌트의 dl 태그 안에 추가한다.</p>\n<pre><code class=\"language-tsx\">&#x3C;button className=\"absolute bottom-[15%] btn btn-xs bg-gray-400/70 hover:bg-gray-400 w-28 h-7 z-30 border-none rounded-none rounded-t-lg text-lg tracking-[0.3rem]\">\n  {carouselIndex.currentIndex + 1} / {items.length}\n&#x3C;/button>\n</code></pre>\n<p>그러면 다음과 같이 페이지 번호가 표시된다.</p>\n<p><img src=\"/static/carousel-7-5-bbc8809e.png\" alt=\"carousel-7-5\"></p>\n<h1>4. 일정 시간마다 자동 넘김</h1>\n<p>setInterval함수를 사용하면 간단히 할 수 있다. carousel 컴포넌트의 useEffect에서 인터벌을 설정하여, 일정 시간마다 캐로셀이 다음 인덱스로 넘어가도록 설정한다.</p>\n<p>다음 코드를 <code>Carousel</code> 컴포넌트에 추가하면 된다. 그러면 3초마다 캐로셀 화면이 전환된다.</p>\n<pre><code class=\"language-tsx\">useEffect(() => {\n  const carouselTimer = setInterval(() => {\n    setCarouselIndex((prev) => ({\n      previousIndex: prev.currentIndex,\n      currentIndex: (prev.currentIndex + 1) % items.length,\n    }));\n  }, 3000);\n\n  return () => {\n    clearInterval(carouselTimer);\n  };\n}, []);\n</code></pre>\n<h1>참고</h1>\n<p>setInterval 사용 <a href=\"https://ko.javascript.info/settimeout-setinterval\">https://ko.javascript.info/settimeout-setinterval</a></p>\n<p>완벽한 캐로셀 만들기 1부 <a href=\"https://code.tutsplus.com/ko/tutorials/create-the-perfect-carousel-part-1--cms-29481\">https://code.tutsplus.com/ko/tutorials/create-the-perfect-carousel-part-1--cms-29481</a></p>",
    "excerpt": "1. 화살표 버튼을 네비게이션 바로\n지금의 캐로셀에서는 캐로셀을 앞뒤 페이지로 이동시킬 수 있는 화살표 버튼이 있는데 이걸 네비게이션 바로 옮기도록 하겠다. 캐로셀의 이동은 아래의 네비게이션 바에서 모두 책임지는 게 나을 것 같다는 판단이다.\n그런데 이미 캐로셀 네비게이션 컴포넌트에서는 각 네비게이션 아이템을 클릭할 때 그 아이템에 해당하는 페이지로 이동하는 기능을 담당하고 있다. 즉 캐로셀의 페이지를 조절하는 기능을 이미 가지고 있다는 것이다. carousel",
    "headingTree": [
      {
        "title": "1. 화살표 버튼을 네비게이션 바로",
        "url": "#1-화살표-버튼을-네비게이션-바로",
        "items": []
      },
      {
        "title": "2. 캐로셀 네비게이션 디자인 리뉴얼",
        "url": "#2-캐로셀-네비게이션-디자인-리뉴얼",
        "items": [
          {
            "title": "2.1 네비게이션 바 디자인",
            "url": "#21-네비게이션-바-디자인",
            "items": []
          },
          {
            "title": "2.2 CarouselNavigationItem 디자인",
            "url": "#22-carouselnavigationitem-디자인",
            "items": []
          },
          {
            "title": "2.3 모바일 화면의 뷰 수정",
            "url": "#23-모바일-화면의-뷰-수정",
            "items": []
          }
        ]
      },
      {
        "title": "3. 네비게이션 바에 페이지 번호 표시",
        "url": "#3-네비게이션-바에-페이지-번호-표시",
        "items": []
      },
      {
        "title": "4. 일정 시간마다 자동 넘김",
        "url": "#4-일정-시간마다-자동-넘김",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 3,
      "wordCount": 669
    },
    "url": "/posts/carousel-7",
    "thumbnail": {
      "local": "/static/carousel-7-1-bc5698ff.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-carousel-7-1-bc5698ff-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAIAAAA8r+mnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAb0lEQVR4nAFkAJv/ANrO/6+5/cPA///0/+/n/9bM/9DJ/7S5/gBZWZgAAzIAL2X/6f//6f//zv96aq8ACzcAOVhxACI3ADZGTnmMlKy7hpevI2B3AFBWAE6DfYqxuWCUknu/whtlZF6elGKjoKnn3wJQN1mtngtyAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "clang-1-1",
    "title": "C - 1.1. 시작",
    "date": "2021-06-25T00:00:00Z",
    "description": "C언어 1.1 시작",
    "tags": [
      "language"
    ],
    "html": "<h1>1. 시작</h1>\n<p>이번에 여름방학을 맞아 초심으로 돌아가 C언어를 복습하면서 블로그에 그 내용을 정리하기로 했다.\n다만 복습하면서 쓰는 것이므로 프로그래밍을 완전히 처음 시작하는 사람이 보기에는 배려가 부족할 수 있다.</p>\n<p>교재는 흔히 C언어의 바이블 중 하나라고 꼽히는 K&#x26;R을 사용할 것이며 내가 지금까지 주워들었던 지식들도 중간중간 서술할 예정이다.\n책 내용을 마무리하고 나면 링크드 리스트 등의 자료구조나, C언어로 구현할 만한 간단한 프로그램 등을 추가로 쓸 것이다.</p>\n<p>이때 K&#x26;R에서는 터미널에서 컴파일하는 방식으로 가르치고 있으므로 나는 wsl에서 돌아가는 Ubuntu 터미널을 사용하여 글의 코드들을 실행할 것이다.\n에디터로는 vscode를 사용할 것이다.</p>\n<p>만약 당신이 특별히 사용하는 에디터나 IDE가 없다면, 흔히 C언어를 처음 시작할 때 사용하는 비주얼 스튜디오를 사용해도 좋을 것이다.</p>\n<h1>2. C언어의 구성</h1>\n<p>컴퓨터는 기본적으로 우리가 지시하는 연산을 순서대로 처리할 뿐인 기계이다.\n그리고 C언어는 컴퓨터에게 우리가 원하는 연산을 지시할 수 있는 도구 중 하나이다.\n이때 우리가 C언어로 내리는 지시는 얼마나 복잡한 지시건에 상관없이 함수(function)와 변수(variable)들로 이루어진다.</p>\n<p>그럼 그 함수와 변수란 무엇일까?\n함수는 어떤 작업과 어떤 연산을 할 것인지를 컴퓨터에 알려주는 문(statement)들로 구성되어 있는 요소이다.\n그리고 변수는 그런 작업에 필요한 값들을 저장하고 있다.\n개념만 설명하니까 굉장히 어려워 보인다. 쉬운 이해를 위해 예시를 들어 보자.</p>\n<p><code>1+2</code>를 계산한다고 생각해 보자. 거의 누구나가 3이라고 대답할 수 있을 것이다. 하지만 이를 뜯어서 생각해 보면 우리는 덧셈이라는 2항 연산을\n1과 2를 대상으로 실행한 것이다.</p>\n<p>즉 덧셈이라는 작업을 지시하는 것이 함수이고, 그 대상이 되는 값인 1과 2가 변수에 해당한다.\n이런 식으로 변수에 있는 값들을 이용해서 함수에서 지시하는 작업을 하는 것이 바로 C언어 프로그램이다.</p>\n<p>그러면 이제 긴 문법 설명을 하기 전에 먼저, 직접 프로그램을 작성해 보자.</p>\n<h1>3. 첫 프로그램</h1>\n<p>우리가 처음 작성할 프로그램은 <code>hello, world</code>를 출력해 주는 것이다.\n일단 에디터에서 다음 문장을 따라 쳐서 <code>hello.c</code>라는 이름으로 저장해 주자.</p>\n<pre><code class=\"language-c\">#include &#x3C;stdio.h>\n\nmain()\n{\n    printf(\"hello, world\\n\");\n}\n</code></pre>\n<hr>\n<div>\n<strong>NOTE</strong>\n<p></p>\nC언어를 조금 배워본 사람이라면 위 코드를 보고 이상하게 여길 수 있다. main함수의 반환값 자료형이 없다는 이유에서이다. 심지어 main함수의 리턴값도 없다.\n하지만 C가 처음 나올 당시의 표준에 의하면 `implicit int rule` 에 따라 반환값 자료형이 명시되어 있지 않은 함수의 반환형은 암묵적으로 int로 받아들인다.\n이 문법은 C99 표준에서부터 폐기되었다. 하지만 많은 컴파일러에서 여전히 잘 돌아간다.\n<p></p>\n그리고 아직 함수가 정확히 무엇이고 어떻게 작성되는지도 쓰지 않았다.\n그런 상황에 반환형에 관련된 서술을 하는 것은 시기상조인 듯 하여 처음에 받아들이는 정보량을 좀 줄이기 위해 이런 코드를 작성하였다.\n<p></p>\n정리하자면, 함수의 반환값의 자료형이 명시되어 있지 않은 경우 반환값의 자료형이 int인 것으로 컴파일러에서 받아들이기 때문에 위의 코드는 문제가 없다.\n또한 함수의 반환값이 없는 것도 문제가 되지 않는다. 함수의 반환값이 없을 경우 자동으로 0을 반환해 주기 때문이다.\n<p> </p>\n</div>\n<hr>\n<p>그리고 나서 이를 gcc가 설치된 터미널에서 <code>gcc hello.c</code> 로 컴파일하고 <code>./a.out</code>을 열어보면 <code>hello, world</code> 가 나오는 것을 볼 수 있다.\n뭔가 나오긴 하는 것 같은데 대체 어떤 규칙에 따라 돌아가는 것인지 알 수가 없다. 한 줄씩 분석해 보자.</p>\n<h1>4. 첫 프로그램에 대한 설명</h1>\n<p><code>#include &#x3C;stdio.h></code></p>\n<p>이 줄은 컴파일러에게, 표준 입출력 라이브러리(stdio는 standard input/output의 약자이다)를 쓰겠다고 알려 주는 것이다.\n입출력 함수를 쓰게 해 주는 역할을 하는 부분이라고 생각해 주면 된다.</p>\n<p><code>main()</code></p>\n<p>C언어 프로그램의 실행은 언제나 메인함수부터 시작한다. 어떤 구조로 코드를 짜던지 간에 코드의 실행은 메인함수의 내용부터 실행된다.\n<code>main</code>의 내용 외에 다른 함수 내부에 있는 코드가 먼저 실행된다든지 하는 일은 없다.</p>\n<p>이는 <code>main</code>이라는 이름의 함수에 대해 정해진 규칙이다.\n따라서 일반적으로 함수의 이름은 자유롭게 정할 수 있지만 <code>main</code>이라는 이름은 예외이다. 즉 이 줄은 프로그램이 실행하는 내용의 시작을 알리는 것이라고 생각하면 된다.</p>\n<p>또 함수의 내용은 함수 이름 뒤에 오는 중괄호 내부에 있다. 따라서 <code>main()</code> 뒤에 오는 중괄호 내부의 내용이, 프로그램이 실행하는 문(statement)이다.\n그런데 <code>main</code>은 함수 이름이라고 치고, 그 뒤에 오는 소괄호는 뭘까?</p>\n<p>그건 함수의 인자(argument)를 뜻한다. 함수들 간에 정보를 주고받는 방식은 함수 호출시에 인자를 전달하는 방식이다.\n<code>main</code>함수도 함수이므로 <code>int main(int argc, char* argv[])</code> 등으로 <code>main</code>함수에 인자를 줄 수도 있다. 이런 방식은 나중에 보도록 하자.</p>\n<p><code>printf(\"hello, world\\n\");</code>\n함수 <code>printf</code>에 인자 <code>\"hello, world\\n\"</code>을 전달하면서 호출한다. 이때 <code>printf</code>는 &#x3C;stdio.h> 에 포함되어 있는 출력 함수이다.\n인자로 받은 format string을 출력하는 것인데, 자세한 내용은 나중에 다루고 지금은 그냥 출력할 것을 인자로 받아서 출력해 주는 함수라고 생각하면 된다.</p>\n<p>다만, 코드에서 이렇게 한 문장을 끝낼 때 세미콜론을 붙여 준다는 것만 주의깊게 보자.\nC언어에서 세미콜론은 자연어 문장에서의 마침표와 비슷한 기능을 한다.</p>\n<h1>5. 이스케이프 문자</h1>\n<p>위 코드의 <code>\"hello, world\\n\"</code> 내에 있는 <code>\\n</code>은 줄바꿈을 뜻한다. 줄바꿈 같은 문자는 쉽게 표현할 수 없으니 <code>\\</code>를 붙여서 따로 정의하는 것이다.\n만약 <code>\\n</code>없이 프로그램을 실행하면 출력된 <code>hello, world</code>뒤에 줄바꿈이 없어지는 것을 볼 수 있을 것이다.\n이때 이러한 <code>\\</code>를 붙여서 따로 정의해 주는 문자들을 이스케이프 문자라고 한다.</p>\n<p>C언어에서 이스케이프 문자를 사용하지 않고 줄바꿈을 표기할 수 있는 방법은 없다.\n반드시 <code>\\n</code>을 사용해서 표기해 주어야 한다.\n만약 문자열 내에 줄바꿈을 그대로 넣어 주겠다는 생각으로 다음과 같은 코드를 짜서 실행한다면 바로 에러 코드를 보게 될 것이다.</p>\n<pre><code class=\"language-c\">printf(\"hello, world\n\");\n</code></pre>\n<p>물론 이스케이프 문자보다는 그냥 엔터키로 줄바꿈을 넣어 주는 것이 직관적이다.\n따라서 좀더 최신의 언어들은 Python의 삼중 따옴표나 Javascript의 템플릿 리터럴처럼, 줄바꿈을 그대로 출력해 줄 수 있는 방식을 지원하기도 한다.\n하지만 C같은 고전적인 언어에서는 그런 것을 지원하지 않는다. 이스케이프 문자밖에는 방법이 없다.</p>\n<p>줄바꿈 외에도 탭(<code>\\t</code>)이나 백스페이스(<code>\\b</code>)와 같은 다른 이스케이프 문자들도 있다.\n이스케이프 문자들에 대해서는 나중에 제대로 다룰 것이니 지금은 그런 것이 있다는 정도만 인식하고 넘어가면 된다.</p>\n<h1>6. printf의 출력</h1>\n<p><code>printf</code>는 절대 자동으로 줄바꿈을 넣어 주지 않는다.\n인수로 받은 문자열에 어떤 것도 추가하지 않고 그대로 출력해줄 뿐이다.\n다소 고지식하게 느껴지기도 한다.</p>\n<p>그러나 반면에 이런 점을 이용해 <code>printf</code>를 여러 번 호출하여 하나의 문자열을 나눠서 출력하는 것도 가능하다.\n하나의 문자열을 여러 번의 <code>printf</code>를 이용해 나눠서 출력하는 방식의 코드를 쓰면서 첫 글을 마친다.\n다음 코드를 실행할 시, <code>hello, world\\n</code> 가 아까와 같이 잘 출력되는 것을 볼 수 있을 것이다.</p>\n<pre><code class=\"language-c\">#include &#x3C;stdio.h>\n\nmain()\n{\n    printf(\"hello, wor\");\n    printf(\"ld\\n\");\n}\n</code></pre>",
    "excerpt": "1. 시작\n이번에 여름방학을 맞아 초심으로 돌아가 C언어를 복습하면서 블로그에 그 내용을 정리하기로 했다.\n다만 복습하면서 쓰는 것이므로 프로그래밍을 완전히 처음 시작하는 사람이 보기에는 배려가 부족할 수 있다.\n교재는 흔히 C언어의 바이블 중 하나라고 꼽히는 K&R을 사용할 것이며 내가 지금까지 주워들었던 지식들도 중간중간 서술할 예정이다.\n책 내용을 마무리하고 나면 링크드 리스트 등의 자료구조나, C언어로 구현할 만한 간단한 프로그램 등을 추가로 쓸 것이다.",
    "headingTree": [
      {
        "title": "1. 시작",
        "url": "#1-시작",
        "items": []
      },
      {
        "title": "2. C언어의 구성",
        "url": "#2-c언어의-구성",
        "items": []
      },
      {
        "title": "3. 첫 프로그램",
        "url": "#3-첫-프로그램",
        "items": []
      },
      {
        "title": "4. 첫 프로그램에 대한 설명",
        "url": "#4-첫-프로그램에-대한-설명",
        "items": []
      },
      {
        "title": "5. 이스케이프 문자",
        "url": "#5-이스케이프-문자",
        "items": []
      },
      {
        "title": "6. printf의 출력",
        "url": "#6-printf의-출력",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 122
    },
    "url": "/posts/clang-1-1",
    "thumbnail": {
      "local": "/thumbnails/clang-1-1-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-clang-1-1-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAaUlEQVR4nGNoampKS0urra1lYmZmZWX9////z58/////z1BbW+vu7r5kyZJt27adOHHiPwwwTJ482cfHp6mp6cGDB3BRkAQyB0Vi34GDu3bvPnToALqOmPik0LCwwsKCbdu2wW3+//8/AGImcC+cRdj6AAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "clang-1-2",
    "title": "C - 1.2. 두번째 예제",
    "date": "2021-07-02T00:00:00Z",
    "description": "C언어 1.2 두번째 예제",
    "tags": [
      "language"
    ],
    "html": "<h1>1. 두번째 프로그램</h1>\n<p>K&#x26;R에서는 바로 C언어의 문법을 가르치지 않는다. 간단한 프로그램을 짜 보면서 먼저 C언어에 대한 감부터 잡게\n하는 방식을 사용하고 있다. 따라서 우리는 본격적으로 C언어의 문법들을 세세하게 접하기 전에 복잡하지는\n않지만 감을 잡는 데에 충분히 도움이 될 만한 프로그램을 몇 가지 짜 보게 된다.</p>\n<p>이번 글에서는 그런 접근 방식을 따라서, 간단한 두 번째 프로그램을 작성하면서 C언어에 대한 감을 잡는다.\n두번째 프로그램은 바로 화씨를 섭씨로 환산한 값을 인쇄해 주는 프로그램이다.</p>\n<p>코드는 다음과 같다.</p>\n<pre><code class=\"language-c\">#include &#x3C;stdio.h>\n\n/* 화씨 0, 20, ... , 300도에 대해\n\t화씨 - 섭씨 표를 출력한다 */\n\nmain() {\n\tint fahr, celsius;\n\tint lower, upper, step;\n\n\tlower = 0;\n\tupper = 300;\n\tstep = 20;\n\tfahr = lower;\n\n\twhile (fahr &#x3C;= upper) {\n\t\tcelsius = 5 * (fahr - 32) / 9;\n\t\tprintf(\"%d\\t%d\\n\", fahr, celsius);\n\t\tfahr = fahr + step;\n\t}\n}\n</code></pre>\n<h1>2. 두번째 프로그램 설명</h1>\n<p>코드를 구성하는 요소를 하나씩 설명해 보자.</p>\n<p><code>#include &#x3C;stdio.h></code></p>\n<p>이는 지난 글에서 다루었으므로 생략한다. 입출력 함수를 다루게 해주는 라이브러리를 쓰게 해주는 부분이다.</p>\n<p><code>/* 화씨 0, 20, ... , 300도에 대해 화씨 - 섭씨 표를 출력한다 */</code></p>\n<p><code>/* */</code> 로 감싸인 부분은 주석이다. 이걸로 감싸인 부분은 코드를 컴파일할 때 무시된다.\n이런 주석은 프로그램의 수월한 이해를 위해서 쓰일 수 있다.\n공백, 탭, 개행이 들어올 수 있는 어느 위치에나 주석은 들어갈 수 있는데,\n이는 거의 코드의 어느 부분에서나 쓰일 수 있다는 것을 의미한다.</p>\n<p>주석을 쓰는 방법 중 하나는 충분히 작동하지만 지금은 쓰지 않는 코드를 통째로\n주석 처리해 놓는 것이다. 그렇게 하면 그 코드가 필요해질 때 언제든 주석을 해제하여 사용할 수 있다.</p>\n<p><code>int fahr, celsius; int lower, upper, step;</code></p>\n<p>다음 줄은 변수를 정의하는 부분이다. C언어에서 변수는 사용되기 전에 무조건 정의되어야 한다.\n변수는 간단히 생각하면 프로그램에서 쓸 어떤 값을 담아둘 공간이라고 생각하면 된다.</p>\n<p>그런데 우리는 변수를 쓰기 전에 그 변수에 어떤 종류의 값을 저장할 것인지\n얼만큼의 메모리를 할당할지 또 어떤 이름을 붙일지를 알려줘야 한다.\n변수의 정의는 우리가 알려줘야 할 정보들을 담은, 변수의 종류(타입)와 변수명들로 이루어진다.</p>\n<p>변수의 타입이란 것은 변수에 어떤 종류의 값을 저장할 것이며 그걸 위해 얼만큼의 메모리가 필요한지를\n컴파일러에 지시한다. 변수의 이름은 말 그대로 값을 저장할 공간의 이름이다.</p>\n<p>여기서는 int는 정수형이며 문자를 나타내는 char, 실수형을 나타내는 float, double등의\n다른 여러가지 타입들이 있다는 것만 짚고 넘어간다.</p>\n<hr>\n<div>\n<strong>NOTE</strong>\n<p></p>\n뒤에 다시 나오겠지만 변수의 타입은 변수가 저장될 메모리의 크기도 결정한다.\n그러나 표준에는 변수 타입별 메모리 크기의 대소관계만 정의할 뿐 정확한 크기는 정해주지 않는다.\n물론 현재의 실질적으로 쓰이는 대부분의 컴파일러는 int를 4바이트로 정의한다.\n그런데 The C programming language 의 저자 커니핸이 책을 쓸 당시에는 그렇지 않았다.\n따라서 K&#x26;R C에서는 16비트(즉, 2바이트)의 정수형도 흔하다고 설명한다...\n<p> </p>\n</div>\n<hr>\n<p>또한 이러한 타입들로 이루어진 배열(array), 구조체(structure), 공용체(union) 그리고\n관련된 포인터와 함수들도 존재한다. 이 시리즈를 진행하면서 하나하나 배워나갈 것이다.</p>\n<p>따라서 위의 코드는 int타입의 변수를 <code>fahr, celcius</code> 등의 이름으로 5개 정의한다고 설명할 수 있겠다.</p>\n<p><code>lower = 0; upper = 300; step = 20; fahr = lower;</code></p>\n<p>각 변수에 값을 할당하는 코드이다. 몇몇 변수에 0,300,20 등의 값을 대입하였으며\n<code>fahr=lower</code> 에서는 변수끼리 대입하기도 한다.</p>\n<p>이때 많은 온도들을 한번에 환산해야 하므로 우리는 반복문을 사용하기로 한다.\n반복문은 지금으로서는 그냥 비슷한 작업을 여러 번 반복하게 하는 의미라고 생각하자.</p>\n<p><code>c while (fahr &#x3C;= upper) {     ... } </code></p>\n<p><code>while</code> 은 반복에 쓰이는 문법이다.\n<code>while</code> 뒤의 소괄호 안의 문(여기서는 <code>fahr &#x3C;= upper</code>)이 참인지 테스트하여 참이면 중괄호 안의 문장을 실행한다.\n중괄호 안의 코드가 끝나면 다시 소괄호 안의 문이 참인지 테스트한다.\n이러한 동작을 반복하다가 소괄호 안의 문장이 거짓이 되면 반복문을 종료한다.</p>\n<p>이를 보여주는 예시를 들어보자. 다음 코드는\n<code>1 2 3 4 5</code>\n를 출력한다.</p>\n<pre><code class=\"language-c\">#include &#x3C;stdio.h>\n\nmain() {\n    int i;\n    i = 1;\n    while (i &#x3C;= 5) {\n        printf(\"%d \", i);\n        i = i + 1;\n    }\n}\n</code></pre>\n<p>이때 우리는 while 뒤의 중괄호 안의 코드를 모두 들여쓰기해 주었다.\n어떤 부분이 while 반복문 안에 들어 있는지 한눈에 알 수 있게 해주려는 목적이다.\n이러한 들여쓰기는 코드의 동작과는 연관성이 없지만 가독성을 매우 높여주기 때문에 대부분의 에디터에서 자동으로 해준다.</p>\n<p>만약 그렇지 않다면 들여쓰기는 가독성에 매우 큰 영향을 미치므로 신경써 주자.\n이렇게 코드를 가독성 좋게 짜는 것은 남과 같이 협업할 때도, 또 심지어 자신의 코드를 읽을 때도 도움이 된다.</p>\n<p>중괄호를 어떤 스타일로 쓰느냐도 사람들 간에 많은 논쟁이 있지만 그건 적절한 스타일을 택하기만 하면 된다.\n가독성을 높이는 이러한 조치들은 대부분의 에디터에서 이미 자동으로 해주므로, 알고만 있자.</p>\n<p><code>celsius = 5 * (fahr - 32) / 9; printf(\"%d\\t%d\\n\", fahr, celsius); fahr = fahr + step;</code></p>\n<p>화씨 온도에 적절한 환산식을 적용해서 섭씨 온도 변수에 대입해 주는 부분이다.\n그리고 화씨 온도와 그에 대응되는 섭씨 온도를 출력해 준다.</p>\n<p>이때 <code>(fahr - 32)</code> 에 $ 5/9 $ 를 곱해주는 것이 아니라 5를 곱한 후 9로 나누는 것에 주목하라.\n이는 C에서 정수 나눗셈의 몫은 무조건 정수가 되고 소수점은 버리므로 <code>5/9</code>의 값은 0이 되기 때문이다.\n따라서 의미있는 값을 얻기 위해서는 위와 같이 해야 한다.</p>\n<p>또한 위의 <code>printf</code> 가 들어간 문장은 <code>printf</code> 가 어떻게 동작하는지를 보여준다.\n<code>printf</code>의 첫번째 인자는 출력될 문자열이다. 이때 문자열에 <code>%</code>가 들어간 포맷 문자열이 있을 경우\n이는 다른 인수들의 값으로 치환된다. 이에 대해서는 후에 더 자세히 다룬다.</p>\n<p>그러나 <code>printf</code>는 C언어의 일부는 아니다. C언어 자체에는 입출력이 없다.\n그저 표준 라이브러리에 동작이 정의되어 있는 함수일 뿐이며 그 내부적인 구현은 구현체에 따라 조금씩 다르다.\n단 <code>printf</code>의 동작은 표준에 정의되어 있으므로 어느 컴파일러에서나 똑같이 동작한다.</p>\n<p>이러한 입출력 관련 문제들은 C언어 자체의 문법과는 큰 관련이 없으므로 마지막에 가서 자세히 다루기로 한다.</p>\n<h1>3. 몇 가지 개선</h1>\n<h2>3.1 출력 포맷</h2>\n<p>현재 코드의 문제는 출력이 오른쪽 정렬되지 않아서 못생겼다는 점이다.\n이는 출력 포맷을 적절히 조절하는 것으로 쉽게 해결할 수 있다.\n<code>%6d</code> 와 같이 출력 포맷의 알파벳 앞에 숫자를 붙이면 그 출력의 너비가 된다.\n그리고 출력은 그 너비 내에서 오른쪽 정렬된다.</p>\n<p>따라서 위의 출력을 다음과 같이 바꿀 수 있다.</p>\n<p><code>printf(\"%3d %6d\\n\", fahr, celsius);</code></p>\n<p>이러면 첫번째 숫자는 3의 너비 내에서 오른쪽 정렬되어 출력되고,\n두번째 숫자는 6의 너비 내에서 오른쪽 정렬되어 출력된다.\n한번 각자의 환경에서 실행해 보자.</p>\n<p>그러나 만약 <code>%2d</code>와 같이, 출력할 숫자의 길이보다 너비가 더 작게 설정되었을 시\n설정된 너비는 무시되고 그대로 출력된다.</p>\n<h2>3.2 실수형 값</h2>\n<p>현재는 출력이 모두 정수로만 이루어진다. 환산된 온도 값들의 소수점을 버렸기 때문이다.\n그러나 더 섭씨-화씨의 더 정확한 환산값을 구하고 싶을 수 있다.</p>\n<p>그러기 위해서는 환산식의 나눗셈에서 나오는 소수점을 버리지 않아야 한다.\n이를 위해서 실수 타입을 사용해 코드를 작성한다.</p>\n<pre><code class=\"language-c\">#include &#x3C;stdio.h>\n\n/* 화씨 0, 20, ... , 300도에 대해\n\t화씨 - 섭씨 표를 출력한다 - 실수형 버전 */\n\nmain() {\n\tfloat fahr, celsius;\n\tint lower, upper, step;\n\n\tlower = 0;\n\tupper = 300;\n\tstep = 20;\n\tfahr = lower;\n\n\twhile (fahr &#x3C;= upper) {\n\t\tcelsius = (5.0 / 9.0) * (fahr - 32.0);\n\t\tprintf(\"%3.0f %6.2f\\n\", fahr, celsius);\n\t\tfahr = fahr + step;\n\t}\n}\n</code></pre>\n<p>화씨와 섭씨 온도 변수가 실수 타입인 float 가 되었고 환산식이 조금 달라졌다.\n소수점을 버리는 정수형 나눗셈과 달리 실수형 숫자들 간의 나눗셈은 소숫점을 버리지 않으므로\n더 정확한 값을 구해서 출력하는 게 가능하다.</p>\n<p>환산식의 <code>(5.0 / 9.0)</code>도 비슷한 맥락이다. 아까는 정수형 나눗셈의 소수점 버리기 때문에\n<code>5/9</code>를 그대로 곱할 수 없었지만 <code>(5.0 / 9.0)</code> 은 실수형 나눗셈이므로 결과가 그대로 나온다.\n(실수를 이진수 저장할 때의 오차 때문에 완벽한 그대로는 아니지만, 정수형 나눗셈보다는 훨씬 정확한 결과다)</p>\n<p>이때 유의할 점은 덧셈이나 나눗셈 등의 2항 계산에서 두 항 다 같은 타입이면 그대로 연산되지만\n한쪽이 정수형, 한쪽이 실수형이면 나머지 한쪽이 묵시적으로 실수형으로 변환되어 연산된다는 점이다.\n그러나 가독성을 위해 보통 실수형 상수에는 소수점을 붙여 써 준다.</p>\n<p>이는 <code>fahr = lower;</code> 와 같은 대입연산이나 다른 비교연산에서도 마찬가지다.\n정수형인 <code>lower</code>가 실수형 변수에 대입될 때 그 값은 실수형으로 묵시적 형변환되어 대입된다.\n이에 대해서는 후에 더 자세히 다룬다.</p>\n<p>또한 아까의 너비 포매팅과 같이 소수점을 몇째 자리까지 출력할 것인지에 대한 포매팅도 존재한다.\n가령 <code>%.2f</code>라 하면 그 포맷에 해당되는 출력을 소수점 둘째 자리까지만 한다는 의미이다.</p>\n<p>위 코드에 있는 것처럼, 너비 포매팅과 같이 쓰는 것도 가능하다.\n<code>%6.2f</code>는 실수형의 포맷 인수를 너비 6으로, 소수점 둘째 자리까지 출력하겠다는 의미이다.</p>",
    "excerpt": "1. 두번째 프로그램\nK&R에서는 바로 C언어의 문법을 가르치지 않는다. 간단한 프로그램을 짜 보면서 먼저 C언어에 대한 감부터 잡게\n하는 방식을 사용하고 있다. 따라서 우리는 본격적으로 C언어의 문법들을 세세하게 접하기 전에 복잡하지는\n않지만 감을 잡는 데에 충분히 도움이 될 만한 프로그램을 몇 가지 짜 보게 된다.\n이번 글에서는 그런 접근 방식을 따라서, 간단한 두 번째 프로그램을 작성하면서 C언어에 대한 감을 잡는다.\n두번째 프로그램은 바로 화씨를 섭씨로 ",
    "headingTree": [
      {
        "title": "1. 두번째 프로그램",
        "url": "#1-두번째-프로그램",
        "items": []
      },
      {
        "title": "2. 두번째 프로그램 설명",
        "url": "#2-두번째-프로그램-설명",
        "items": []
      },
      {
        "title": "3. 몇 가지 개선",
        "url": "#3-몇-가지-개선",
        "items": [
          {
            "title": "3.1 출력 포맷",
            "url": "#31-출력-포맷",
            "items": []
          },
          {
            "title": "3.2 실수형 값",
            "url": "#32-실수형-값",
            "items": []
          }
        ]
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 164
    },
    "url": "/posts/clang-1-2",
    "thumbnail": {
      "local": "/thumbnails/clang-1-2-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-clang-1-2-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAfElEQVR4nGNYu3btokWLli1bFhwcLCsry8HBwcTEdObMGYa1a9f6+PjExsbW1tZu2bLlABi8f/+eYe/evSkpKUVgcPv27f/////+/fv///8M/5HAbxgASVy9dv3ChQtXr1x5/fo1siKGKdNm9fVPWLRo0YULF+Dm/P//HwB2tGu2s7iyuwAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "clang-1-3",
    "title": "C - 1.3. 두번째 예제의 개선",
    "date": "2021-07-31T00:00:00Z",
    "description": "C언어 1.3 두번째 예제의 개선",
    "tags": [
      "language"
    ],
    "html": "<h1>1. 개선한 코드</h1>\n<p>같은 동작을 하는 코드도 다양한 방식으로 짤 수 있다. 가령 아까와 똑같은 동작을 하는 코드를 for문을 이용하여 짜 보자.</p>\n<pre><code class=\"language-c\">#include &#x3C;stdio.h>\n\n/* 섭씨 - 화씨 온도 변환 표를 출력하는 코드 */\n\nmain() {\n    int fahr;\n\n    for (fahr = 0; fahr &#x3C;= 300; fahr = fahr + 20) {\n        printf(\"%3d %6.1f\\n\", fahr, (5.0 / 9.0) * (fahr - 32.0));\n    }\n}\n</code></pre>\n<p>이를 컴파일러를 통해 실행시켜 보면 1.2에서 작성했던, while문을 이용하는 코드와 같은 결과를 출력한다. 그러나 몇 가지의 변화가 있다.</p>\n<p>일단 화씨 온도를 나타내는 <code>fahr</code>변수를 제외하고는 모든 변수가 다 사라졌다. <code>lower</code> 와 <code>upper</code>변수를 for문에 집어넣고, 환산식도 계산해서 변수에 대입하는 것이 아니라 <code>printf</code>문의 인수로 직접 넣어 주었다.</p>\n<p>여기서 알 수 있는 하나의 사실은, 특정 타입의 변수의 값을 사용할 수 있는 곳에서는 그 결과가 같은 타입이면 어떤 복잡한 계산식이라도 들어갈 수 있다는 것이다. 가령 위 코드의 <code>printf</code>의 세번째 인수에는 실수형 값이 들어갔는데, 이게 단일 실수형 변수이든 아니면 여러 변수들을 조합하고 계산해 나온 실수형 값이든 상관없다.</p>\n<p>변수 개수를 줄인 것은, 이 정도로 메모리를 절약해야 하는 일은 거의 없기 때문에 성능상으로는 큰 의미가 없다. 하지만 코드가 많이 간단해졌다.</p>\n<p>물론 변수명에는 숫자의 용도를 나타내는 역할도 있다. 만약 <code>upper=300</code> 이라고 한다면 코드를 읽는 사람은 쉽게 300이 어떤 상한의 역할을 한다는 사실을 알 수 있다. 그런 부분을 생각하면 위와 같이 쓴 코드는 오히려 알아보기 힘들어졌다고 할 수도 있다.</p>\n<p>하지만 이 또한 뒤에서 나올 <code>#define</code> 을 사용하면 해결할 수 있는 문제이다.</p>\n<h1>2. for문에 대한 설명</h1>\n<p>위 코드에서 마지막으로 설명할 부분은 <code>for</code> 문에 관해서이다. <code>for</code>문은 또다른 반복문의 형태이다. <code> for</code>문의 의미는 다음과 같다.</p>\n<pre><code class=\"language-c\">for(초기화;지속조건;증가){\n    스텝마다 실행시킬 코드\n}\n</code></pre>\n<p>하나하나 살펴보면, 초기화 부분에서는 반복문의 초기 조건을 설정해 준다. 위에서는 <code>fahr=0</code>으로 화씨 온도를 0으로 설정한 부분이다</p>\n<p>지속조건에서는 반복문이 지속될 조건을 넣는다. 위에서는 <code>fahr&#x3C;=300</code>인데, 이 조건이 거짓이 되면 중괄호 속의 코드는 실행되지 않는다. 다르게 말하면 이 조건이 참인 동안은 계속 중괄호 내의 코드가 반복되어서 실행된다는 것이다.</p>\n<p>만약 증가 파트에서 무언가 제대로 해주지 않아서 <code>fahr</code>이 계속 300 이하라면(가령 fahr이 아닌 엉뚱한 변수를 증가시켜 주고 있다거나, <code>fahr</code>을 도리어 감소시켜주고 있다거나 하는 경우) 중괄호 내의 코드는 무한히 반복되어 실행된다.</p>\n<p>증가 부분에서는 스텝이 한번 실행될 때마다 어떤 동작을 해줄 것인지를 정한다. 위에서는 <code>fahr=fahr+20</code> 이다. 이는 스텝(즉, 중괄호 내부의 코드 1번 실행)마다 <code>fahr</code>변수를 20씩 증가시켜준다는 의미이다.</p>\n<p>증가라고 했지만 increment를 직역한 추상적인 용어일 뿐이고 실제로는 스텝이 한번 실행될 때마다 해줄 어떤 동작이든 상관없다. <code>fahr</code>를 감소시켜 준다거나 2를 곱해 준다거나 다른 변수를 대입해 준다거나 어떤 것이든 들어갈 수 있다. 다만 보통 반복문은 언젠가 종료되도록 짜는 것이 일반적이므로 언젠가는 종료 조건을 만족하게 될 수 있도록 코드를 짜야 할 것이다.</p>\n<p>정리하면 변수를 초기화시켜주고, 중괄호 내부의 코드가 1번 실행될 때마다 어떤 동작을 취해주고, 그 동작을 취하면서 종료조건에 가까워지도록 하는 것이 <code>for</code>반복문인 것이다.</p>\n<p><code>while</code>과 <code>for</code>중 어느 것을 쓸 것인지는 무조건 적용되는 원칙은 없다. 그저 더 명확하게 읽히고 이해되는 쪽으로 쓰면 된다.</p>",
    "excerpt": "1. 개선한 코드\n같은 동작을 하는 코드도 다양한 방식으로 짤 수 있다. 가령 아까와 똑같은 동작을 하는 코드를 for문을 이용하여 짜 보자.\n#include <stdio.h>\n\n/* 섭씨 - 화씨 온도 변환 표를 출력하는 코드 */\n\nmain() {\n    int fahr;\n\n    for (fahr = 0; fahr <= 300; fahr = fahr + 20) {\n        printf(\"%3d %6.1f\\n\", fahr, (5.0 / 9.0) * (f",
    "headingTree": [
      {
        "title": "1. 개선한 코드",
        "url": "#1-개선한-코드",
        "items": []
      },
      {
        "title": "2. for문에 대한 설명",
        "url": "#2-for문에-대한-설명",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 45
    },
    "url": "/posts/clang-1-3",
    "thumbnail": {
      "local": "/thumbnails/clang-1-3-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-clang-1-3-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAf0lEQVR4nGPYsWPH8uXLlyxZkp+fr6OjU11d/f///9+/fzOkpaWxsbEFBgbKy8v39fU9f/78PxgwbN26NSQkZMqUKZs2bXr37h1EFCRx7uzZ7u7uvr6+HTt2/P79GyFx9/79J0+ePH/+HFk5SGL+4uWz5sxZvXr1tWvXINZCJADMq214/3oO6AAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "clang-1-5",
    "title": "C - 1.5. 문자 입출력",
    "date": "2021-08-06T00:00:00Z",
    "description": "C언어 1.5. 문자 입출력",
    "tags": [
      "language"
    ],
    "html": "<h1>1. 문자 입출력</h1>\n<p>우리는 이제부터 문자 데이터를 다루는 프로그램에 대해 배울 것이다.\nC언어의 표준 라이브러리의 문자 입출력은 단순하다. 프로그램에는 다양한 입출력 스트림이 들어오고 그것을 처리하는 것이다.\n이러한 입력 또는 출력은 사용자의 키보드 입력과 상호작용하는 콘솔 창일 수도 있고, 어떤 파일일 수도 있다.\n입출력 스트림을 어디로 연결할 것인지에 대해서도 추후에 다룰 것이다.</p>\n<p>하지만 그 입출력이 어디 스트림에서 오고 어디서 가든 C언어의 입출력 함수는 그저 입출력을 처리할 뿐이다.\n이러한 입출력 함수 중 가장 간단한 것은 <code>getchar()</code> 와 <code>putchar(c)</code> 이다.\n두 함수는 각각 단 하나의 문자를 입력받고, 출력한다.</p>\n<p><code>getchar()</code>는 입력 스트림에서 하나의 문자를 입력받은 후 리턴한다. 그리고 <code>putchar(c)</code>는 보통은 하나의 문자를 나타내는 어떤 c를 받아서 출력 스트림에 출력한다. 이때 <code>putchar(c)</code> 와 우리가 썼던 <code>printf</code> 는 함께 쓰일 수 있다. 그냥 우리가 생각하는 대로, 호출이 일어나는 순서대로 출력된다.</p>\n<p>시험용으로 다음과 같은 코드를 짜본다.</p>\n<pre><code class=\"language-c\">#include &#x3C;stdio.h>\n\n/* putchar 와 printf를 함께 사용해 본다 */\nmain() {\n    char c='t';\n    putchar(c);\n    printf(\"est\\n\");\n}\n</code></pre>\n<p>위의 코드를 실행하면 <code>test</code> 와 개행이 출력된다. char형 변수 <code>c</code>에 담긴 <code>t</code> 한 글자가 <code>putchar</code>에 의해 출력된 이후 <code>printf</code>에 의해 다음 글자들이 출력되는 것이다. 출력 함수를 두 종류 사용했지만 딱히 충돌은 일어나지 않음을 확인할 수 있다.</p>\n<h1>2. 입력받은 대로 출력하기</h1>\n<p>고작 한 글자씩만 입력받고 또 출력하는 함수 <code>getchar()</code> 와 <code>putchar(c)</code>만을 배웠지만 이것만으로도 꽤 많은 예제를 실행시켜볼 수 있다. 예를 들어, 한 글자씩 입력받을 때마다 출력해 주는 프로그램을 만들어 볼 수 있다.</p>\n<p>가령 입력이 파일에서의 스트림으로부터 온다면 우리는 파일의 끝(End Of File, EOF)까지 입력을 받으면서 그대로 출력을 해준다고 생각할 수 있을 것이다. 추후에 입출력 리디렉션을 배우고 나면 그런 동작을 하는 코드를 실제로 작성해 볼 수 있다.</p>\n<p>또는, 나는 이 블로그 글을 치면서도 타이핑을 하고 있는데 만약 문서 프로그램이 키보드 입력만 받고 어떤 입력이 들어왔는지 출력해 주지 않는다면 매우 곤란할 것이다.</p>\n<p>물론 문서 프로그램이나, 실제로 쓰이는 즉시 출력 알고리즘은 우리가 짜는 예제보다 더 복잡한 코드와 최적화 따위가 들어가 있을 것이다. 하지만 기본적인 원리는 비슷함을 충분히 생각할 수 있다는 것이다.</p>\n<p>다음 코드는 EOF가 입력될 때까지 문자를 입력받아서 그대로 출력하는 코드이다.</p>\n<pre><code class=\"language-c\">#include &#x3C;stdio.h>\n\n/* 입력받은 내용을 EOF가 나올 때까지 그대로 출력해 준다 */\nmain() {\n    int c;\n\n    c = getchar();\n    while (c != EOF) {\n        putchar(c);\n        c = getchar();\n    }\n}\n</code></pre>\n<p>참고로 <code>!=</code>는 같지 않음을 뜻하는 것이다. 이 코드를 시험해 보면 EOF입력이 들어올 때까지 입력받은 대로 출력해 주는 것을 볼 수 있다. 이때 콘솔 창에서 어떻게 EOF를 입력할 수 있을지도 문젠데, 윈도우의 경우 <code>Ctrl+Z</code> 키를, 리눅스의 경우에는 <code>Ctrl+D</code> 키를 누르면 EOF를 콘솔창에 입력할 수 있다.</p>\n<p>그런데 이상한 점을 하나 찾을 수 있다. 우리는 분명 char, 즉 문자 하나를 다루는 함수들을 사용하였다. <code>getchar</code>와 <code>putchar</code> 라는 이름에서부터 char를 다룬다는 것이 느껴지지 않는가? 그런데 위 코드에서는<code>int</code>형으로 c를 선언하였다. 그리고 <code>getchar()</code> 함수의 명세를 찾아보아도 <code>int</code>형을 리턴한다는 것을 알 수 있다. 왜 그런 것일까?</p>\n<p>이는 우리가 EOF를 구분해야 하기 때문이다. C언어 표준의 EOF는 <code>&#x3C;stdio.h></code> 에 정의되어 있는 매크로 상수인데, 어떤 char형 문자와도 혼동되지 않을 숫자여야 한다고만 명시되어 있다. 흔히는 -1을 사용한다. 따라서 우리는 이러한 EOF 또한 다룰 수 있도록 <code>c</code>를 정수형 <code>int</code>으로 선언하는 것이다. 만약 우리가 <code>c</code>를 char형으로 선언했다면 여기에 EOF가 담기지 못할 수도 있었을 것이다.</p>\n<h1>3. 코드의 개선</h1>\n<p>우리는 <code>c=getchar()</code> 나 <code>a=3</code> 같은 할당문조차도 표현이며 값을 가진다는 것을 이용해, 위의 코드를 좀더 줄일 수 있다. 이때 할당문은 할당이 일어난 후 할당문 왼쪽의 값을 표현한다. 예를 들어 <code>a=3</code> 이라는 할당문이 있다면 이 할당문은 3이 할당되고 난 후에 a의 값, 즉 3을 표현한다.</p>\n<p>이러한 <code>c</code>의 할당이 <code>while</code> 문 내부로 들어가는 것으로 코드가 짧아진다.</p>\n<pre><code class=\"language-c\">#include &#x3C;stdio.h>\n\n/* 입력받은 내용을 EOF가 나올 때까지 그대로 출력해 준다\n 할당문을 이용해 간략화한 코드 */\nmain() {\n    int c;\n\n    while ((c = getchar()) != EOF) {\n        putchar(c);\n    }\n}\n</code></pre>\n<p><code>while</code> 문 내부에서 테스트가 진행되면서 <code>getchar()</code> 로 입력을 받고, 그 값을 <code>c</code>에 할당한 후 <code>c</code> 의 값을 EOF와 비교한다. 만약 <code>c</code>가 EOF가 아니면 <code>while</code>문 내부가 실행되고 EOF이면 반복문이 바로 종료될 것이다.</p>\n<p>이렇게 할당을 이용해서 짜는 코드는 경험이 풍부한 사람에게는 더 가독성이 좋기도 하다. 그러나 이렇게 코드를 간략화하는 걸 지나치게 남용한다면 당연히 가독성이 떨어질 수밖에 없으므로 주의해야 한다. 아주 똑똑하게 짜인 코드가 잘 짜인 코드가 아니라, 오히려 누가 보아도 쉽게 의미를 알 수 있고 단순하게 짜인 코드가 좋은 코드이고 어쩌면 더 짜기 어렵다. 그저 할당문 또한 값을 갖는 표현이라는 걸 안 것으로 만족하자.</p>\n<p>마지막으로,  <code>c = getchar()</code> 에 괄호를 씌워 준 것을 볼 수 있는데 이는 연산자 우선순위 때문이다. <code>!=</code>는 <code>=</code>  보다 우선순위가 높기 때문에 만약 저 할당문에 괄호를 씌워 주지 않으면 <code>c = getchar() != EOF</code> 는 <code>c = (getchar() != EOF)</code> 와 같은 결과를 도출할 것이다.</p>\n<p>이는 <code>getchar() != EOF</code> 의 결과에 따라 <code>c</code>에 0 또는 1(boolean true의 값은 보통 1이다) 만이 할당되는, 우리가 원하는 것과는 다른 결과를 낳게 된다.</p>\n<h2>3.1 할당문의 값에 대하여</h2>\n<p>C언어를 처음 배울 때 다음과 같은 실수를 흔히 하고는 한다.</p>\n<pre><code class=\"language-c\">#include &#x3C;stdio.h>\n\n/* a가 1이면 a가 1이라고 출력해 주려고 한 코드이다 */\nmain() {\n    int a = 2;\n\n    if (a = 1) {\n        printf(\"a is 1\");\n    }\n}\n</code></pre>\n<p>위 코드를 실행해 보면 a가 2로 할당되어 있는데도 <code>if</code> 문 내의 코드가 실행된다. 이는 우리가 원하는 결과가 아니다! 왜냐 하면 우리가 원하는 대로, a가 1과 같은지 비교하는 방법은 <code>a==1</code> 이기 때문이다. C언어를 조금이라도 잘 배운 사람이라면 이런 실수는 잡아낼 수 있을 것이다.</p>\n<p>하지만, 우리가 원하는 결과는 아니더라도 이 코드는 딱히 버그 없이 잘 실행되고 어떤 결과도 나온다. 이 이유까지 속시원히 답변하는 사람을 그렇게 많이 보지 못했다. 나도 그랬다.</p>\n<p>이 이유는 바로 위에서 설명한, C언어에서는 할당문에도 값이 있기 때문이다. 위의 코드 같은 경우 <code>a=1</code> 즉 a의 값인 1이 <code>if</code>문에 들어갔고 1은 무조건 참이므로 <code>if</code>문 내부의 코드가 실행된 것이다. 그리고 <code>a</code>에도 또한 1이 정상적으로 할당된다.</p>\n<p>할당문에도 값이 존재하는 것은 이렇게 실수를 불러일으키기도 하지만, 위의 <code>getchar()</code> 를 이용하는 코드와 같이 코드를 더 간략하게 만들어 주기도 한다.</p>",
    "excerpt": "1. 문자 입출력\n우리는 이제부터 문자 데이터를 다루는 프로그램에 대해 배울 것이다.\nC언어의 표준 라이브러리의 문자 입출력은 단순하다. 프로그램에는 다양한 입출력 스트림이 들어오고 그것을 처리하는 것이다.\n이러한 입력 또는 출력은 사용자의 키보드 입력과 상호작용하는 콘솔 창일 수도 있고, 어떤 파일일 수도 있다.\n입출력 스트림을 어디로 연결할 것인지에 대해서도 추후에 다룰 것이다.\n하지만 그 입출력이 어디 스트림에서 오고 어디서 가든 C언어의 입출력 함수는 그",
    "headingTree": [
      {
        "title": "1. 문자 입출력",
        "url": "#1-문자-입출력",
        "items": []
      },
      {
        "title": "2. 입력받은 대로 출력하기",
        "url": "#2-입력받은-대로-출력하기",
        "items": []
      },
      {
        "title": "3. 코드의 개선",
        "url": "#3-코드의-개선",
        "items": [
          {
            "title": "3.1 할당문의 값에 대하여",
            "url": "#31-할당문의-값에-대하여",
            "items": []
          }
        ]
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 151
    },
    "url": "/posts/clang-1-5",
    "thumbnail": {
      "local": "/thumbnails/clang-1-5-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-clang-1-5-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAfklEQVR4nGPYsGHD0qVL582bZ2Nj4+/vLyYmxs3N/eDBA4a1a9eGhYUVFhYuWrRo//79a9eu3b9///fv3xm2bNmSnJxcV1c/ZcqU/fv3/4cBBjjr////v8EAKnHtxs2LFy/evHnjzZs3yIoYZsyeN2nylKVLl168eBGiCSIBAE8cbbaULrQ4AAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "clang-1-4",
    "title": "C - 1.4. 두번째 예제 마무리",
    "date": "2021-08-05T00:00:00Z",
    "description": "C언어 1.4. 두번째 예제 마무리",
    "tags": [
      "language"
    ],
    "html": "<h1>1. 매크로 상수</h1>\n<p>1.3. 글에서 변수명은 숫자의 용도를 나타내주는 역할도 한다고 언급했었다. 그런데 1.3의 for문을 사용하는 코드에서 변수의 개수를 줄였으므로, 몇몇 숫자들의 용도를 쉽게 알 수 없게 되었다.</p>\n<p>물론 1.3에서 본 코드는 매우 짧으므로 잘 아는 사람이 본다면 누구나 <code>이 코드에서 300은 어떤 상한이며, 20은 각 스텝의 증분이구나!</code> 라고 쉽게 생각할 수 있다. 그러나 만약 코드가 길고 복잡해지면 이렇게 상수의 의도를 파악하는 게 쉽지 않다.</p>\n<p>이렇게 코드 내부에 특별한 이름 없이 그대로 쓰인 숫자를 '매직 넘버' 라고 하는데 실제로 이는 지양해야 할 습관이다.</p>\n<p>그럼 우리는 어떻게 이러한 매직 넘버들의 용도를 나타내 줄 수 있을까? <code>#define</code> 을 이용한 매크로를 사용하면 된다. 가령 <code>#define UPPER 300</code> 이라고 하면 <code>UPPER</code>라는 문구를 자동으로 300으로 바꿔 주는 매크로를 정의한다는 뜻이다. 즉, <code>UPPER</code> 라는 말을 컴파일러로 하여금 300으로 알아듣게 한다.</p>\n<p>구체적인 형식은 다음과 같다.</p>\n<pre><code class=\"language-c\">#define name replacement text\n</code></pre>\n<p>이러면 <code>name</code> 에 해당하는 게 나올 때마다 컴파일러에서는 <code>replacement text</code>의 내용으로 알아듣게 된다.</p>\n<hr>\n<p><strong>NOTE</strong></p>\n<p>구체적으로는 컴파일러가 동작하는 방식과 관련이 있다. 조금만 설명하면, 우리가 코드를 짜서 컴파일러에게 전달하면, 컴파일러에서는 코드를 읽어서 실행 파일을 만드는 동작을 하기 전에 코드에 대한 전처리를 시행한다. 이 부분에서는 헤더 파일의 내용 복사, 조건부 컴파일 처리 등등을 하는데 여기에는 매크로 처리도 있다.</p>\n<p>즉 컴파일러가 실제로 읽고 컴파일하게 되는 코드는 우리가 정의한 <code>#define</code> 매크로가 모두 처리된 상태라는 것이다. 따라서 이렇게 정의한 상수들은 메모리를 차지하지 않는다. 매크로로 함수를 정의하더라도 마찬가지다. 코드가 실제로 어떤 동작을 하도록 해준 것이 아니라, 단순히 텍스트 치환을 해준 것이기 때문이다.</p>\n<hr>\n<p><code>name</code>은 변수의 작명과 똑같은 규칙을 가진다. 문자와 숫자의 조합이어야 하고 문자로 시작해야 한다. 그리고 <code>replacement text</code>는 어떤 문자열이라도 상관없다. 꼭 숫자일 필요는 없다는 뜻이다. 이 글의 뒷부분에서 코드로 보일 것이다.</p>\n<h1>2. 매크로를 이용한 코드</h1>\n<p>그러면 이러한 매크로를 이용해서, 상수들에 의미있는 이름을 부여해 보자.</p>\n<pre><code class=\"language-c\">#include &#x3C;stdio.h>\n\n#define LOWER 0\n#define UPPER 300\n#define STEP 20\n\n/* 화씨 - 섭씨 표를 출력한다 */\nmain() {\n    int fahr;\n\n    for (fahr = LOWER; fahr &#x3C;= UPPER; fahr = fahr + STEP) {\n        printf(\"%3d %6.1f\\n\", fahr, (5.0 / 9.0) * (fahr - 32.0));\n    }\n}\n</code></pre>\n<p>이렇게 하면 <code>LOWER</code>, <code>UPPER</code>, <code>STEP</code>은 특정 숫자와 같으므로 실제 코드의 의미는 같다. 그러나 숫자들에 이름이 있기 때문에 사람이 알아보기 훨씬 편하다.</p>\n<p>매크로문을 쓸 때에 생각할 점은 매크로의 이름(<code>name</code>)은 보통 일반 변수명과 구별하기 위해 영어 대문자만으로 쓰는 것이 일반적이라는 것, 그리고 매크로문에는 세미콜론(<code>;</code>)이 붙지 않는다는 점이다.</p>\n<p>또한 <code>replacement text</code>에 붙은 이름은 꼭 하나일 필요 없다. 만약 300이라는 숫자가 프로그램의 다른 부분에서 다른 의미로 또 쓰이게 된다면, 이를테면 <code>#define STUDENT_ID 300</code> 과 같은 또다른 매크로를 정의해도 상관없다. 물론 같은 이름을 또 사용하는 건 안 된다.</p>\n<h1>3. 매크로의 활용</h1>\n<p>이 부분만 보면 그냥 변수를 사용하는 것과 무엇이 다른지 쉽게 알 수 없다. 물론 변수 할당에 드는 메모리를 절약할 수 있다고는 하지만 요즘은 거의 언제나 충분한 메모리가 있으므로 큰 의미는 없다.</p>\n<p>그래서 변수와는 다른 느낌으로 쓰인 매크로를 하나 보겠다.</p>\n<p>바로 위에서 쓴 코드에 있는 화씨-섭씨 환산식을 매크로로 대체할 수 있다.</p>\n<pre><code class=\"language-c\">#include &#x3C;stdio.h>\n\n#define LOWER 0\n#define UPPER 300\n#define STEP 20\n#define FAHR_TO_CELSIUS(x) (5.0/9.0)*(x-32.0)\n\n/* 화씨 - 섭씨 표를 출력한다 */\nmain() {\n    int fahr;\n\n    for (fahr = LOWER; fahr &#x3C;= UPPER; fahr = fahr + STEP) {\n        printf(\"%3d %6.1f\\n\", fahr, FAHR_TO_CELSIUS(fahr));\n    }\n}\n</code></pre>\n<p>어째서 위의 매크로에서는 <code>x</code> 에 대해서 정의한 매크로인데 <code>fahr</code> 에 대해서도 잘 작동하는지는 적당히 넘어가자. 중요한 건 코드가 잘 작동하고, 이런 식으로 매크로를 일종의 함수와 비슷한 동작을 하도록 만들 수 있다는 사실이다. 이건 우리가 지금까지 배운 일반적인 변수로는 할 수 없는 일이다.</p>\n<p>사실 우리나라에서는 화씨 온도를 잘 쓰지 않으므로 $ \\frac{5}{9} \\times (F - 32) $ 라는 환산식은 그리 익숙하지 않다. 하지만 저렇게 환산식에 이름을 부여하면, 저 함수를 쓰면 화씨 온도에서 섭씨 온도로 환산할 수 있다는 것을 훨씬 쉽게 알아볼 수 있는 것이다.</p>",
    "excerpt": "1. 매크로 상수\n1.3. 글에서 변수명은 숫자의 용도를 나타내주는 역할도 한다고 언급했었다. 그런데 1.3의 for문을 사용하는 코드에서 변수의 개수를 줄였으므로, 몇몇 숫자들의 용도를 쉽게 알 수 없게 되었다.\n물론 1.3에서 본 코드는 매우 짧으므로 잘 아는 사람이 본다면 누구나 이 코드에서 300은 어떤 상한이며, 20은 각 스텝의 증분이구나! 라고 쉽게 생각할 수 있다. 그러나 만약 코드가 길고 복잡해지면 이렇게 상수의 의도를 파악하는 게 쉽지 않다.\n",
    "headingTree": [
      {
        "title": "1. 매크로 상수",
        "url": "#1-매크로-상수",
        "items": []
      },
      {
        "title": "2. 매크로를 이용한 코드",
        "url": "#2-매크로를-이용한-코드",
        "items": []
      },
      {
        "title": "3. 매크로의 활용",
        "url": "#3-매크로의-활용",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 93
    },
    "url": "/posts/clang-1-4",
    "thumbnail": {
      "local": "/thumbnails/clang-1-4-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-clang-1-4-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAiElEQVR4nGNYu3bt5MmTe3p6PD09ZWVlOTg4mJiYzpw5w5CYmCQiIhIbG3v//v2dO3ceAIP3798zrFq1KiAgoKen58WLl79///4PAwx79+7Oz8+vra2dPn367du3////D5FmuHHr9v379x8/fvz+/Xu4cpDEpKkzu3v65s2bd+HCBbjy////AwAYamc97guG1QAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "cloudflare-make-subdomain",
    "title": "내 도메인에 서브도메인으로 페이지를 달기 위해 고생한 기록",
    "date": "2023-05-17T00:00:00Z",
    "description": "내가 구매한 도메인에 서브도메인을 달고 싶어졌다. 그래서 한번 알아보았다.",
    "tags": [
      "blog",
      "web",
      "tip"
    ],
    "html": "<p>어느 날, <code>witch.work</code> 도메인이 있지만 가령 <code>abc.witch.work</code>로 접속되는 페이지를 가지고 싶어졌다. 사람들에게 물어보니 서브도메인이라는 걸 달면 된다고 했다.</p>\n<h1>1. 무작정 레코드 달아보기</h1>\n<p>내 도메인인 <code>witch.work</code>는 cloudflare page에서 관리되고 있다. 따라서 cloudflare에서 서브도메인을 설정해야 한다.</p>\n<p>한번 무작정 설정해 보자. cloudflare dashboard에서 <code>witch.work</code>를 선택하고 들어간다. 그리고 메뉴에서 DNS를 선택한다.</p>\n<p><img src=\"/static/dns-menu-fdd4b5f8.png\" alt=\"dns-menu\"></p>\n<p>그리고 DNS 레코드 추가를 클릭한 후 유형을 CNAME으로 선택한 후 이름은 쓰고 싶은 서브도메인, 콘텐츠는 리다이렉트하고자 하는 페이지 주소로 설정한다. 또한 프록시는 켜놓는다.</p>\n<p><code>naver.witch.work</code>를 <code>https://naver.com</code>으로 리다이렉트하고 싶다면 다음과 같이 설정하면 된다.</p>\n<p><img src=\"/static/dns-naver-af2b0b54.png\" alt=\"dns-naver\"></p>\n<p>하지만 이렇게 해도, origin policy등에 의해서 완전히 동일한 페이지를 보는 것은 아니다. CORS 정책에 의해 자원 공유가 제한되기 때문이다.</p>\n<p>만약 특정 서브도메인으로 접속했을 시 다른 페이지의 주소로 완전히 넘어가고 싶다면, cloudflare page에서 제공하는 page rule이나 redirection rule을 적용해야 한다.(공식 문서를 보고 하면 별거 아니다)</p>\n<h1>2. 원리</h1>\n<p>네트워크의 내용을 깊이 들어가면 말할 게 수도 없지만 기본적인 부분만 살펴본다.</p>\n<p>네트워크 통신은 기본적으로 IP 기반으로 돌아간다. 만약 내 집의 컴퓨터에서 <code>www.naver.com</code>에 접속한다고 하자. 그러면 내 컴퓨터는 DNS(도메인 네임 서버)에 <code>www.naver.com</code>에 연결된 IP 정보를 조회한다.</p>\n<p>그렇게 DNS에서 전달받은 IP에 HTTP 요청을 보내게 되면 네이버에 접속된다.(중간중간 수많은 이야기들이 있지만 모두 생략. 자세한 이야기는 <a href=\"https://inpa.tistory.com/entry/WEB-%F0%9F%8C%90-DNS-%EA%B0%9C%EB%85%90-%EB%8F%99%EC%9E%91-%EC%99%84%EB%B2%BD-%EC%9D%B4%ED%95%B4-%E2%98%85-%EC%95%8C%EA%B8%B0-%EC%89%BD%EA%B2%8C-%EC%A0%95%EB%A6%AC\">여기</a>나 <a href=\"https://parksb.github.io/article/36.html\">여기</a>참고)</p>\n<p>그리고 이렇게 도메인 이름과 IP를 매핑하는 가장 기본적인 DNS 레코드가 A타입 레코드이다. <code>www.naver.com</code>에 접속 시 IP <code>223.130.200.104</code>에 연결해야 한다면, 이 둘을 연결시켜 주는 것이다.</p>\n<p><img src=\"/static/naver-access-01af9af3.png\" alt=\"naver-access\"></p>\n<p>이제 위에서 설정한 CNAME 레코드가 나온다. CNAME 레코드는 도메인을 다른 도메인의 별칭으로 설정할 경우 A레코드 대신 사용한다. CNAME인 이유도 Canonical Name의 약자이기 때문이다.</p>\n<p>DNS가 CNAME 레코드를 설정한 도메인에 도달할 시 해당 도메인에 연결된 CNAME 레코드 도메인을 찾아가서 다시 DNS를 조회하게 되고, 그렇게 A 레코드가 나올 때까지 조회한 후 해당 IP로 연결하게 된다.</p>\n<p>위에서 우리가 설정한 CNAME 레코드의 경우 <code>naver.witch.work</code>를 <code>naver.com</code>의 별칭으로 설정한 것이다. 따라서 naver.com에 연결된 DNS 레코드를 따라가게 된다.</p>\n<p>DNS조회가 한 번 더 이루어지므로 비효율적이기는 하겠지만.(하지만 사실 DNS 캐싱도 요즘 잘 되어 있고, 또한 DNS 조회는 빠르게 이루어지기 때문에 그렇게까지 비효율적이지도 않다)</p>\n<p><img src=\"/static/dns-cname-a-1f27976e.png\" alt=\"dns-cname-a\"></p>\n<p>그러나 위에서 언급했듯이, 이렇게 하면 완전히 동일한 페이지를 보게 되는 것은 아니다.</p>\n<p>내 컴퓨터에서 <code>naver.witch.work</code>에 접속하면 결과적으로 네이버의 IP에 HTTP 요청을 하게 되지만, 요청을 하는 출처는 <code>naver.witch.work</code> 그대로이다.</p>\n<p>하지만 네이버의 서버는 이 출처에서 온 요청을 허용하지 않는다. 따라서 CORS 정책에 의해서 네이버 페이지의 자원을 요청하는 것은 차단되고, 네이버 페이지의 일부만 표시된다.</p>\n<h1>3. vercel 페이지 연결하기</h1>\n<p>다시 돌아와서, 처음에 내가 서브도메인 페이지를 만들고자 한 건 네이버로 리다이렉트하는 주소를 갖고 싶어서는 당연히 아니었다. 뭔가 새로 만들고자 하는 페이지가 있었는데 거기로 연결되는 URL을 미리 만들어 놓고 싶어서였다.</p>\n<p>최근에 NextJS를 배운다고 배운다고 공식 문서의 튜토리얼을 따라한 일이 있었다. 이 페이지를 좀 개조해서 뭔가 컨텐츠를 넣어 놓고 싶었던 것이다.</p>\n<p>이 페이지는 현재 <a href=\"https://nextjs.org/docs/app/building-your-application/deploying\">NextJS 문서의 배포 가이드</a>를 따라 vercel로 배포되어 있다. <a href=\"https://nextjs-example-weld.vercel.app/\">여기</a>에 내가 만든 페이지를 배포해 놓았다. <code>cs.witch.work</code>가 여기로 리다이렉트되게 해보자.</p>\n<p>그럼 위에서 한 것처럼 하면 되겠지? CNAME 레코드의 이름을 <code>cs</code>로 설정하고 위의 주소를 내용으로 넣어본다.</p>\n<p><img src=\"/static/cname-direct-a66f68ff.png\" alt=\"cname-direct\"></p>\n<p>하지만 이렇게 하면 안 된다! <code>DEPLOYMENT_NOT_FOUND</code>라는 코드와 함께, 우리가 원하는 페이지와 연결이 안 되는 것을 볼 수 있다.</p>\n<p><img src=\"/static/deployment_not_found-dacd1605.png\" alt=\"dep-not-found\"></p>\n<p>이는 vercel 배포가 동작하는 방식 때문이다. vercel로 배포한 페이지는 A 레코드를 통해 IP <code>76.76.21.21</code>로 연결된다. 그리고 해당 IP 서버에서 요청을 한 도메인을 보고 적절한 페이지를 보내주는 방식으로 동작한다.</p>\n<p><img src=\"/static/vercel-dns-request-6a0c48d9.png\" alt=\"vercel-dns\"></p>\n<p>따라서, 우리가 아까 추가한 서브도메인 <code>cs.witch.work</code>으로 접속하게 되면 vercel 서버 <code>76.76.21.21</code>까지는 잘 접속된다. 하지만 vercel 서버에서 해당 도메인에 대해서 어떤 페이지를 보내 줄지 모르는 상태이다. 그래서 위처럼 <code>DEPLOYMENT_NOT_FOUND</code>라는 에러가 발생하는 것이다.</p>\n<p>이를 해결하기 위해서는 vercel 서버에 해당 도메인을 등록하면 된다. vercel dashboard로 가자. 거기서 <code>Domains</code> 메뉴를 선택한 후 <code>Add</code> 버튼을 누른다.</p>\n<p><img src=\"/static/vercel-domain-menu-70c5ad90.png\" alt=\"vercel-domain-menu\"></p>\n<p>그리고 <code>Add</code>을 누른 후 내가 배포한 프로젝트를 선택한다. 나는 <code>nextjs-example</code>프로젝트의 도메인을 추가하고 싶으므로 해당 프로젝트를 선택했다.</p>\n<p>그리고 continue를 누르면 내가 vercel 서버에 해당 프로젝트 도메인으로 추가하고 싶은 도메인을 선택하는 창이 뜬다. 거기에 내가 추가하고 싶은 도메인을 입력한다. 나는 <code>cs.witch.work</code>를 입력했다.</p>\n<p><img src=\"/static/add-project-domain-dd4945d8.png\" alt=\"add-domain\"></p>\n<p>이걸 완료하고 나면 해당 페이지를 vercel 서버에 추가하는 작업이 진행되는데, 거기까지 하고 나면 <code>cs.witch.work</code>에 접속할 시 내가 만든 프로젝트 페이지로 연결된다.</p>\n<p><img src=\"/static/dns-setting-slow-5ba76acf.png\" alt=\"dns-setting-slow\"></p>\n<h1>4. 1단계 개선</h1>\n<p>하지만 굳이 CNAME을 1번 거칠 필요는 없다. 내가 연결할 서브도메인을 곧장 vercel 서버에 연결하면 된다.</p>\n<p>물론 요즘은 DNS 조회가 그렇게 오래 걸리는 작업도 아니고, DNS 캐싱도 잘 이루어지기 때문에 획기적인 시간 개선이 되지는 않는다.</p>\n<p>하지만 원칙적으로 여러 번의 DNS 조회를 거쳐서 페이지에 도달하는 건 지양되는 게 맞다. 따라서 이를 개선해 보도록 하자.</p>\n<p>그냥 cloudflare에서 cs.witch.work 서브도메인의 내용을 설정할 때 A레코드로 설정한 후 바로 vercel 서버의 IP <code>76.76.21.21</code>을 입력하면 된다.</p>\n<p><img src=\"/static/dns-to-a-record-af71a04f.png\" alt=\"dns-to-a\"></p>\n<p>이제 <code>cs.witch.work</code>로 접속하면, 물론 똑같이 아까와 같은 페이지로 연결되지만 DNS 조회 1번이 줄어들게 된다.</p>\n<p><img src=\"/static/dns-setting-fast-de7386f5.png\" alt=\"dns-setting-fast\"></p>\n<p><a href=\"https://cs.witch.work/\">cs.witch.work</a> 서브도메인에 다른 페이지를 연결시키는 걸 완료했다.</p>\n<h1>5. 기타 - 아예 도메인을 이동하기</h1>\n<p>위처럼 하면 페이지 주소는 그대로지만 다른 페이지의 컨텐츠가 표시된다. 페이지 주소는 <code>cs.witch.work</code>로 표시되지만 사실 <a href=\"https://nextjs-example-weld.vercel.app/%EA%B3%BC\">https://nextjs-example-weld.vercel.app/과</a> 같은 컨텐츠가 표시되는 것이다.</p>\n<p>하지만 이런 식으로 다른 페이지의 컨텐츠만 표시하는 게 아니라, 아예 다른 도메인으로 넘어가고 싶을 수 있다. 대표적으로, www 서브도메인이 붙은 도메인을 apex 도메인(root도메인)으로 리다이렉트시키고 싶은 경우를 들 수 있겠다. 이렇게 같은 페이지로 오는 모든 요청을 apex 도메인으로 통일시키는 게 SEO나 조회수 집계 등에도 좋다.</p>\n<p>예를 들어, <code>www.witch.work</code>로 접속했을 때 <code>witch.work</code>로 아예 넘어가게 하고 싶다면?</p>\n<p>이럴 때는 cloudflare에서 redirection rule을 설정하면 된다. 혹은 page rule을 설정하거나, bulk redirect를 설정하면 된다. 뒤쪽으로 갈수록 닭 잡는 데에 소 잡는 칼을 쓰는 일이 된다고 본다.</p>\n<h2>5.1. redirection rule</h2>\n<p>일단 cloudflare dashboard에서 내 도메인 <code>witch.work</code>관련 페이지에 들어간 후 www 서브도메인에 A 레코드로 <code>192.0.2.1</code>을 추가하거나 AAAA 레코드로 <code>100::</code>을 추가한다.</p>\n<p>그 다음 <code>witch.work</code> 대시보드의 왼쪽 메뉴에서 <code>규칙(혹은 rules)</code> 메뉴를 찾고, 그곳의 서브메뉴에서 <code>리디렉션 규칙</code>을 선택한다.</p>\n<p>리디렉션 규칙을 생성하는 버튼을 누른 후 규칙 이름을 입력하고, 어떤 요청에 대해서 어떤 URL로 리디렉션할지를 설정한다.</p>\n<p><img src=\"/static/create-redirect-rule-6d71fc52.png\" alt=\"create-redirect-rule\"></p>\n<p>이를 저장하면 끝이다. 이렇게 하면 <a href=\"http://www.witch.work\">www.witch.work</a> 로 접속할 시 이는 A 레코드에 의해 cloudflare 서버에 연결되고, cloudflare 서버에서는 내가 설정한 리디렉션 규칙에 따라 witch.work로 리디렉션하라는 응답(코드 301)을 보내게 된다. 아예 다른 도메인으로 가는 것이다.</p>\n<h2>5.2. page rules</h2>\n<p>cloudflare dashboard에서 내 도메인 <code>witch.work</code>관련 페이지에 들어간 후 www 서브도메인에 A 레코드로 <code>192.0.2.1</code>을 추가하거나 AAAA 레코드로 <code>100::</code>을 추가하는 부분까지는 위와 동일하다.</p>\n<p>그 다음 <code>witch.work</code> 대시보드의 왼쪽 메뉴에서 <code>규칙(혹은 rules)</code> 메뉴를 찾고, 그곳의 서브메뉴에서 <code>페이지 규칙</code>을 선택한다.</p>\n<p>여기서 Page rule 생성을 선택한다.</p>\n<p><img src=\"/static/create-page-rule-3903cd19.png\" alt=\"create-page-rule\"></p>\n<p>그리고 똑같은 일을 하면 된다. URL은 내가 접속했을 시 다른 곳으로 리디렉션시키고 싶은 URL을 입력하면 된다. 나는 <code>www.witch.work</code>를 apex 도메인으로 리디렉션시키고 싶었으므로 <a href=\"http://www.witch.work\">www.witch.work</a> 를 입력했다.</p>\n<p>이때 URL 전체 중 해당 도메인이 포함되어 있을 경우 모두 리디렉션시키고 싶었기 때문에 <code>*</code>을 사용했다. 또한 그때의 동작은 URL을 이동하고 싶은 것이므로 '전달 URL'을 선택하고 <code>https://witch.work/</code>을 설정했다.</p>\n<p><img src=\"/static/create-page-rules-redirect-01ae424f.png\" alt=\"create-page-rule\"></p>\n<p>이렇게 하면 <a href=\"http://www.witch.work%EB%A1%9C\">www.witch.work로</a> 접속했을 시 witch.work로 리디렉션되는 것을 볼 수 있다. 역시 cloudflare 서버의 엣지에서 처리하는 부분이다.</p>\n<h2>5.3. bulk redirect</h2>\n<p>cloudflare dashboard에서 내 도메인 <code>witch.work</code>관련 페이지에 들어간 후 www 서브도메인에 A 레코드로 <code>192.0.2.1</code>을 추가하거나 AAAA 레코드로 <code>100::</code>을 추가하는 것은 역시 위와 동일하다.</p>\n<p><img src=\"/static/AAAA-record-e4b00732.png\" alt=\"AAAA-record\"></p>\n<p>그 다음 <code>witch.work</code> 대시보드의 왼쪽 메뉴에서 <code>규칙(혹은 rules)</code> 메뉴를 찾고, 그곳의 서브메뉴에서 <code>리디렉션 규칙</code>을 선택한다. 그리고 아래로 내려보면 <code>대량 리디렉션</code>메뉴가 있다.</p>\n<p><img src=\"/static/bulk-redirection-f0eeb64a.png\" alt=\"bulk-redirect\"></p>\n<p>그곳에서 <code>대량 리디렉션 목록 생성</code>을 택한 후 이름, 설명을 적당히 입력하고 다음을 누른다.</p>\n<p><img src=\"/static/www-to-apex-name-3be6c986.png\" alt=\"bulk-redirect-create\"></p>\n<p>다음 화면에서 URL 리디렉션 수동 추가를 택한 후 원본 URL(나같은 경우 <a href=\"http://www.witch.work\">www.witch.work</a> )과 대상 URL(나같은 경우 witch.work)를 입력한다. 대상 URL로 영구 리디렉션을 시킬 것이므로 상태는 301을 선택한다.</p>\n<p>매개변수 편집에서는 쿼리 문자열 유지, 하위 경로 일치, 경로 접미사 유지 를 선택한다. 그리고 <code>리디렉션 추가</code>를 누른다. 그리고 다음 버튼을 누르다 보면 대량 리디렉션 목록이 생성된다.</p>\n<p>이제 이 리디렉션 목록을 실현할 규칙을 만들면 된다. 대량 리디렉션 메뉴로 이동한 후 <code>대량 리디렉션 규칙 생성</code>을 선택. 그러면 규칙의 이름과 이 규칙에서 어떤 리디렉션 목록을 실현할지를 선택할 수 있다.</p>\n<p><img src=\"/static/bulk-redirection-rule-6a14e972.png\" alt=\"bulk-redirection-rule\"></p>\n<p>이를 적당히 선택하고 저장 및 배포를 누르면 된다.</p>\n<h1>참고</h1>\n<p><a href=\"https://alwnsxo.com/entry/Vercel%EC%97%90-%EB%82%B4-%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%A0%81%EC%9A%A9%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95-Next-JS-on-Vercel-with-Custom-Domain\">https://alwnsxo.com/entry/Vercel%EC%97%90-%EB%82%B4-%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%A0%81%EC%9A%A9%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95-Next-JS-on-Vercel-with-Custom-Domain</a></p>\n<p><a href=\"https://www.cloudflare.com/ko-kr/learning/dns/dns-records/dns-cname-record/\">https://www.cloudflare.com/ko-kr/learning/dns/dns-records/dns-cname-record/</a></p>\n<p><a href=\"https://vercel.com/docs/concepts/projects/domains/troubleshooting\">https://vercel.com/docs/concepts/projects/domains/troubleshooting</a></p>\n<p><a href=\"https://evan-moon.github.io/2020/05/21/about-cors/\">https://evan-moon.github.io/2020/05/21/about-cors/</a></p>\n<p><a href=\"https://developers.cloudflare.com/pages/how-to/www-redirect/\">https://developers.cloudflare.com/pages/how-to/www-redirect/</a></p>",
    "excerpt": "어느 날, witch.work 도메인이 있지만 가령 abc.witch.work로 접속되는 페이지를 가지고 싶어졌다. 사람들에게 물어보니 서브도메인이라는 걸 달면 된다고 했다.\n1. 무작정 레코드 달아보기\n내 도메인인 witch.work는 cloudflare page에서 관리되고 있다. 따라서 cloudflare에서 서브도메인을 설정해야 한다.\n한번 무작정 설정해 보자. cloudflare dashboard에서 witch.work를 선택하고 들어간다. 그리고 메뉴",
    "headingTree": [
      {
        "title": "1. 무작정 레코드 달아보기",
        "url": "#1-무작정-레코드-달아보기",
        "items": []
      },
      {
        "title": "2. 원리",
        "url": "#2-원리",
        "items": []
      },
      {
        "title": "3. vercel 페이지 연결하기",
        "url": "#3-vercel-페이지-연결하기",
        "items": []
      },
      {
        "title": "4. 1단계 개선",
        "url": "#4-1단계-개선",
        "items": []
      },
      {
        "title": "5. 기타 - 아예 도메인을 이동하기",
        "url": "#5-기타---아예-도메인을-이동하기",
        "items": [
          {
            "title": "5.1. redirection rule",
            "url": "#51-redirection-rule",
            "items": []
          },
          {
            "title": "5.2. page rules",
            "url": "#52-page-rules",
            "items": []
          },
          {
            "title": "5.3. bulk redirect",
            "url": "#53-bulk-redirect",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 321
    },
    "url": "/posts/cloudflare-make-subdomain",
    "thumbnail": {
      "local": "/static/dns-menu-fdd4b5f8.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-dns-menu-fdd4b5f8-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAICAIAAACzjdIrAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAW0lEQVR4nAFQAK//AAoCAB4YEf///wBISEuNjo////8ANTtBdHx+payuACsyOV9la4qQlQBucXTPz9Du7u4AeXyA6erp6uvrAFpdYqGho/Tz9ACLjZC7vL3u7u7AsCpgVpG1EQAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "clang-1-6",
    "title": "C - 1.6. 문자 입출력을 이용한 프로그램1",
    "date": "2021-08-15T00:00:00Z",
    "description": "C언어 1.6. 문자 입출력을 이용한 프로그램1",
    "tags": [
      "language"
    ],
    "html": "<h1>1. 입력받은 문자 개수 세기</h1>\n<p>문자 입출력을 이용해 만들어 볼 다음 프로그램은 문자 개수를 세는 프로그램이다.</p>\n<pre><code class=\"language-c\">#include &#x3C;stdio.h>\n\n/* 입력에 문자가 몇 개 있는지를 세어 준다 */\nmain() {\n    int count;\n\n    count = 0;\n    while (getchar() != EOF) {\n        ++count;\n    }\n    printf(\"%d\\n\", count);\n}\n</code></pre>\n<p>기본 원리는 1.5에서 다루었던 것과 같다. EOF가 나올 때까지 문자 입력을 받으면서 몇 개나 입력받았는지 세는 것이다.</p>\n<p>그런데 여기서 우리가 보지 못했던 연산자가 또 하나 나왔다. 바로 <code>++count</code> 에서 나온 전위 증감 연산자이다. <code>++count</code>는 <code>count</code>의 값을 1 증가시킨 후 변수의 값을 사용한다. 이는 <code>count=count+1</code> 과 같은 기능이다. 하지만 <code>++count</code> 가 더 간결하고 빠르기 때문에 1 을 증가시킬 경우 증감 연산자를 자주 쓴다.</p>\n<p>비슷한 방식으로 변수에서 1을 감소시키는 <code>--count</code> 가 있고 또 조금은 다른 방식으로 동작하는 <code>count++</code> <code>count--</code> 후위 증감 연산자가 있다. 이는 연산자에 관해 다룰 때 추후 더 자세히 다룰 것이다.</p>\n<hr>\n<div>\n<strong>NOTE</strong>\n<p></p>\n전위 연산자 `++i`와 후위 연산자 `i++` 중 어느 것을 쓰는 게 좋은지는 꽤 오래된 떡밥이다. 결론부터 말하자면 웬만한 부분은 모두 컴파일러에서 최적화해 주며 그런 자잘한 차이에 국한되지 않을 정도로 현대의 컴퓨터 속도는 발전하였다. 실제로 시간을 측정해 보면 컴퓨터 환경에 따라 엎치락뒤치락하는 정도의 속도이다. 따라서 일반적인 경우 그냥 취향껏 쓰면 될 것이다.\n<p>하지만 이론적으로는 전위 연산자 <code>++i</code>의 승리이다. 후위 연산자 <code>i++</code>의 경우 먼저 변수의 값을 사용한 후에 변수의 값을 1 증가시켜 준다. 가령 <code>arr[i++]=3</code> 과 같은 코드가 있다면 먼저 <code>arr[i]=3</code> 을 처리해 준 후 <code>i</code>를 1 증가시켜 주는 것이다. 하지만 <code>arr[++i]</code>의 경우 그냥 <code>i</code>를 1 증가시켜 준 후 <code>arr[i]</code> 에 대한 처리를 하면 된다.</p>\n<p>따라서 후위 연산자의 경우 <code>i</code>의 값을 저장할 임시 공간을 만들어야 하기 때문에 후위 연산자가 전위 연산자에 비해 이론적으로는 속도가 떨어진다.</p>\n<p>참고 : <a href=\"https://stackoverflow.com/questions/24901/is-there-a-performance-difference-between-i-and-i-in-c\">https://stackoverflow.com/questions/24901/is-there-a-performance-difference-between-i-and-i-in-c</a></p>\n</div>\n<hr>\n<h1>2. 다른 방식으로 짜보기</h1>\n<p>이때 <code>int</code>의 범위는 일반적으로 2^31-1, 약 21억까지이므로 문자 개수를 셀 때 있어서 부족할 일은 별로 없을 것이다.\n그러나 만약 어떤 엄청나게 큰 입력이 있어서 그 범위를 초과한다면 <code>double</code>형을 사용하여 정확도를 조금 포기하는 대신\n훨씬 큰 범위를 표현하게 할 수 있을 것이다.</p>\n<p>다른 종류의 반복문인 for문을 사용하여 그러한 코드를 짜 보자.</p>\n<pre><code class=\"language-c\">#include &#x3C;stdio.h>\n\n/* for문, double형을 이용해 입력받은 문자 개수를 세는 코드 */\nmain() {\n\tdouble count;\n\n\tfor (count = 0; getchar() != EOF; ++count);\n\t/* 초기화/테스트/증가로 필요한 모든 동작이 이루어지므로 for문의 body는 없어도 된다. */\n\tprintf(\"%.0f\\n\", count);\n}\n</code></pre>\n<p><code>double</code>형은 약 10^300 까지 나타낼 수 있으므로 위의 코드에서의 <code>count</code>변수의 오버플로우는 거의 걱정하지 않아도 될 것이다.\n그리고 <code>double</code> 형의 printf 출력 포맷 또한 <code>%f</code> 임을 알아 두자.</p>\n<p>또한 for문이 중괄호 body가 없어도 잘 동작한다는 것을 알아 두자.</p>\n<p>그런데 만약 이 프로그램에 입력이 아무것도 안 들어온다면 어떻게 될까? 입력에 아무 문자도 없고 바로 EOF가 입력되는 것이다.\n그때도 프로그램은 정상적으로 0을 출력한다. <code>count</code>를 증가시키는 부분이 전혀 실행되지 않기 때문이다.</p>\n<p>이렇게 for문 혹은 while문의 조건이 만족되지 않으면 반복문의 몸체(중괄호 내부)는 전혀, 한번도 실행되지 않고 종료된다.\n아무것도 입력되지 않는 것과 같은 이런 코너케이스를 처리하는 것은 프로그램을 탄탄하게 짤 때 매우 중요하다.</p>\n<h1>3. 줄 개수 세기</h1>\n<p>다음에 짜 볼 코드는 입력 속에 있는 개행을 세어 주는 코드이다.\n입력을 끝까지 받으면서 개행 문자가 들어오면 세어 주는 단순한 논리로 작동한다.</p>\n<pre><code class=\"language-c\">#include &#x3C;stdio.h>\n\n/* 입력에 있는 줄 수 세기 */\nmain() {\n\tint c, line_num;\n\n\tline_num = 0;\n\twhile ((c = getchar()) != EOF) {\n\t\tif (c == '\\n') {\n\t\t\tline_num++;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", line_num);\n}\n</code></pre>\n<p>이때 개행을 나타낼 때 쓰는 이스케이프 문자인 <code>\\n</code> 이 int형 변수인 c와 비교됨을 주의깊게 보자.\n작은따옴표로 나타낸 문자는 컴파일러에서 쓰는 character set에서 대응되는 특정 숫자와 같다.\n이를 문자 상수라고 부르며, 흔히 아스키 코드 셋으로 나타낸다.\n가령 대문자 알파벳 <code>A</code>는 아스키 코드로 65이다.</p>",
    "excerpt": "1. 입력받은 문자 개수 세기\n문자 입출력을 이용해 만들어 볼 다음 프로그램은 문자 개수를 세는 프로그램이다.\n#include <stdio.h>\n\n/* 입력에 문자가 몇 개 있는지를 세어 준다 */\nmain() {\n    int count;\n\n    count = 0;\n    while (getchar() != EOF) {\n        ++count;\n    }\n    printf(\"%d\\n\", count);\n}\n\n기본 원리는 1.5에서 다루었던 것과 같다. ",
    "headingTree": [
      {
        "title": "1. 입력받은 문자 개수 세기",
        "url": "#1-입력받은-문자-개수-세기",
        "items": []
      },
      {
        "title": "2. 다른 방식으로 짜보기",
        "url": "#2-다른-방식으로-짜보기",
        "items": []
      },
      {
        "title": "3. 줄 개수 세기",
        "url": "#3-줄-개수-세기",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 119
    },
    "url": "/posts/clang-1-6",
    "thumbnail": {
      "local": "/thumbnails/clang-1-6-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-clang-1-6-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAjElEQVR4nGPYtm3b0qVLZ8+e7eDgUF5e/v///9+/f////5+huLiYmZmZg4PDxMREQEAgMDAwOjra29ubYfbs2TY2NnFxcenp6e3t7UeOHDlw4MDOnTsZjhw50tDQsHDhwtra2nPnziGMunPv3sNHj548fvzlyxeIKAQwzFmweNqs2StWrLh48eJ/JAAAPdlgVU+QKpwAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "devtool-dollar-sign",
    "title": "개발자 도구의 $ 표시에 대해서",
    "date": "2022-12-28T00:00:00Z",
    "description": "개발자 도구의 $는 뭘까?",
    "tags": [
      "web",
      "tip"
    ],
    "html": "<h1>1. 시작</h1>\n<p>개발하다 보면 개발자 도구에서 <code>$</code> 표시를 볼 수 있다. Element 탭에서 내가 어떤 요소를 선택할 때마다 그 뒤에 <code>==$0</code>이 뜨는 등의 경우이다.</p>\n<p><img src=\"/static/dev-tool-05195d40.png\" alt=\"devtool\"></p>\n<p>그리고 element 탭에서 특정 요소를 선택한 후 개발자 도구의 콘솔 창으로 이동해서 <code>$0</code>을 입력하면 선택한 요소가 출력되는 것도 볼 수 있다. 개발자 도구에서 <code>$</code>를 사용하는 것은 대체 무엇을 의미하는 것일까?</p>\n<p>개발자 도구에서 <code>$</code>가 들어가는 편리한 표현들 그리고 다른 몇 가지 편의기능을 알아보자.</p>\n<h1>2. 기본</h1>\n<h2>2.1. <code>$_</code></h2>\n<p><code>$_</code>는 바로 직전에 실행한 명령의 결과값을 나타낸다. 예를 들어 <code>1 + 2</code>를 입력하고 <code>Enter</code>를 누르면 <code>3</code>이 출력된다. 이 때 <code>$_</code>를 입력하면 <code>3</code>이 출력된다.</p>\n<p>또한 그 결과값에 적용되는 프로퍼티나 메서드도 똑같이 적용할 수 있다. 아래 예시를 보면 <code>$_</code>에 <code>length</code>를 적용한 결과값이 출력된다. <code>toUpperCase()</code>와 같이 문자열에 적용할 수 있는 메소드라면 다른 것도 가능하다.</p>\n<p><img src=\"/static/underbar-057ee530.png\" alt=\"underbar\"></p>\n<h2>2.2. <code>$0</code>, <code>$1</code>, <code>$2</code>, ...</h2>\n<p><code>$0</code>, <code>$1</code>, <code>$2</code>, <code>$3</code>, <code>$4</code>는 각각 Element 탭에서 선택한 DOM 요소의 historical reference를 나타낸다. 커서를 통해 선택된 요소도 여기에 포함된다.</p>\n<p><code>$0</code>은 가장 최근에 선택한 요소를 나타내고, <code>$1</code>은 그 전에 선택한 요소를 나타낸다. <code>$2</code>는 그 전에 선택한 요소를 나타낸다. 이런 식으로 <code>$0</code>부터 <code>$4</code>까지 총 5개까지 선택한 요소의 역사를 나타낼 수 있다.</p>\n<p>이렇게 참조된 DOM 요소를 편집하는 것도 가능하다. 예를 들어서 내 블로그에서 프로필 사진을 선택해 본다.</p>\n<p>개발자 도구의 Select 커서를 이용하면 다음과 같이 내 프로필의 자기소개를 선택할 수 있다. p태그로 이루어져 있다.</p>\n<p><img src=\"/static/p-select-7d5e25ec.png\" alt=\"select\"></p>\n<p>이제 <code>$0</code>을 입력하면 선택한 태그를 확인할 수 있다. 만약 이 다음에 Element 패널에서 다른 요소를 선택한다면 기존의 <code>$0</code>은 <code>$1</code>이 되고 새로 선택한 요소는 <code>$0</code>이 된다.</p>\n<p><img src=\"/static/p-history-d9607999.png\" alt=\"p-history\"></p>\n<p>이제 <code>$0</code>에 <code>innerHTML</code>를 적용하면 내부에 써있는 메시지도 확인할 수 있다. 그리고 <code>$0</code>은 DOM 요소에 대한 참조 자체를 담고 있으므로 이를 통해서 편집도 가능하다.</p>\n<p><img src=\"/static/p-edit-915ca6b8.png\" alt=\"p-edit\"></p>\n<p>이렇게 편집 후 페이지를 보면 내 블로그의 자기소개 칸이 바뀐 것을 확인할 수 있다.</p>\n<p><img src=\"/static/p-edit-complete-c8cf90df.png\" alt=\"p-edit-complete\"></p>\n<h1>3. 다른 함수의 단축 표현</h1>\n<h2>3.1. document.querySelector</h2>\n<p><code>$(selector)</code>는 <code>document.querySelector(selector)</code>의 단축 표현이다. <code>document.querySelector</code>는 CSS 선택자를 통해 DOM 요소를 선택할 수 있다.</p>\n<p>따라서 개발자 도구에서 <code>$(선택자)</code>를 입력하면 document에서 해당 선택자에 해당하는 첫 DOM 요소를 선택할 수 있다. <code>$('p').innerHTML</code>과 같이 선택한 태그의 어트리뷰트를 확인할 수도 있다.</p>\n<p>또한 그렇게 출력된 DOM 요소를 우클릭하고 Reveal in Elements Panel를 선택하면 해당 요소가 선택된 상태로 Elements 패널이 열린다.</p>\n<p>그리고 이 함수는 2번째 인자를 받을 수도 있다. 이 2번째 인자는 <code>$</code>함수가 해당하는 선택자를 갖는 요소를 탐색할 때 어떤 노드에서부터 시작할지를 결정한다. 기본값은 <code>document</code>이다.</p>\n<p>주의할 점은 jQuery의 경우 <code>$</code>가 이미 있는 함수라는 것이다. 제이쿼리를 사용하는 경우 그 라이브러리의 <code>$</code>함수가 사용된다.</p>\n<h2>3.2. document.querySelectorAll</h2>\n<p><code>$$(selector)</code>는 <code>Array.from(document.querySelectorAll())</code>의 단축 표현이다. 주어진 CSS 선택자에 해당하는 모든 요소들을 담은 배열을 리턴해 주는 것이다.</p>\n<p>다음과 같이 페이지에서 <code>p</code>태그 요소들을 모두 담은 배열을 만들고 그 길이를 구하는 연산을 간단히 해볼 수 있다.</p>\n<p><img src=\"/static/selectAll-p-7a113bae.png\" alt=\"selectall\"></p>\n<p>이 함수 역시 2번째 인자를 받을 수 있다. 이 2번째 인자는 <code>$$</code>함수가 인자로 받은 CSS 선택자를 갖는 요소를 탐색할 때 어떤 노드에서부터 시작할지를 결정한다. 기본값은 <code>document</code>이다.</p>\n<h2>3.3. XPath expression</h2>\n<p><code>$x(path)</code>는 XPath expression을 통해 DOM 요소를 선택할 수 있다. XPath는 XML 문서를 탐색하기 위한 언어이다. HTML 문서도 XML 문서이기 때문에 XPath를 사용하여 HTML 문서를 탐색할 수 있다.</p>\n<p>예를 들어서 <code>$x('//p')</code>는 페이지에서 모든 <code>p</code>태그 요소를 선택한다고 한다. 또한 <code>$x('//p[a]')</code>는 페이지에서 <code>p</code>태그 요소 중에서 <code>a</code>태그를 포함하는 요소를 모두 선택한다. XML에서의 일종의 정규식과 같은 역할을 하는 것 같은데 후에 공부가 필요할 것 같다.</p>\n<p>이 함수 역시 2번째 인자를 받을 수 있다. 이 2번째 인자는 <code>$x</code>함수가 인자로 받은 XPath expression을 갖는 요소를 탐색할 때 어떤 노드에서부터 시작할지를 결정한다. 기본값은 <code>document</code>이다.</p>\n<h1>4. 그 외 기능들</h1>\n<p>개발자 도구 콘솔창에서 쓸 수 있는 그 외 기능들이다.</p>\n<h2>4.1. copy()</h2>\n<p><code>copy(object)</code>는 인자로 받은 요소의 string representation을 클립보드에 복사해 준다. <code>copy($0)</code>과 같이 사용할 수 있다.</p>\n<h2>4.2. debug(function)</h2>\n<p>위 기능을 사용하면 디버거가 실행되고 인자로 받은 함수 내에서 중단점을 잡아준다. 그리고 Sources 패널에서 디버거 기능을 활용해서 디버깅하도록 돕는다.</p>\n<p>이렇게 중단점을 잡는 기능은 Sources 패널에서 쓰면서 디버깅하는 게 더 나을 것 같긴 하다.</p>\n<p>undebug(function)을 통해 debug(function)으로 설정한 중단점을 제거한다.</p>\n<h2>4.3. dir(object)</h2>\n<p><code>dir(object)</code>는 인자로 받은 객체의 속성들을 출력해 준다. <code>dir($0)</code>과 같이 사용할 수 있다. console.dir과 같은 기능을 한다. 비슷하게 <code>dirxml(object)</code>도 있다.</p>\n<h2>4.4. inspect(object/function)</h2>\n<p>주어진 요소나 객체를 적절한 패널에서 보여준다. 예를 들어 <code>inspect($0)</code>, <code>inspect(document.body)</code>과 같이 주어진 인자가 DOM 요소라면 해당 요소가 선택된 상태로  Element 패널이 열릴 것이다.</p>\n<p>주어진 인자가 함수라면 Sources 패널에서 해당 함수가 정의된 곳으로 이동할 것이다.</p>\n<h2>4.5. getEventListeners(object)</h2>\n<p>해당 객체에 등록되어 있는 이벤트 리스너들의 객체를 출력해 준다. click, keydown 이벤트 등 각 이벤트마다 해당하는 리스너들의 배열이 객체에 매핑되어 있다.</p>\n<h2>4.6. keys(object)</h2>\n<p><code>keys(object)</code>는 인자로 받은 객체의 속성들을 리턴해 준다.</p>\n<pre><code class=\"language-js\">let info={\n  name:\"김성현\", \n  blog:\"witch.work\",\n}\n\nconsole.log(keys(info)) // [\"name\", \"blog\"]\n</code></pre>\n<p>객체의 속성 대신 속성에 매핑된 값들을 배열 형태로 리턴하는 함수로 <code>values(object)</code>도 있다.</p>\n<p><img src=\"/static/values-c8321e4b.png\" alt=\"values\"></p>\n<h2>4.7. monitorEvents(object[, events])</h2>\n<p><code>monitorEvents(object[, events])</code>는 인자로 받은 객체에 등록되어 있는 이벤트 리스너들을 모니터링한다. 이벤트 리스너가 호출되면 콘솔에 출력해 준다.</p>\n<pre><code class=\"language-js\">moniterEvents(document.body, [\"click\", \"keydown\"])\n</code></pre>\n<p>위와 같이 쓴다면 document.body에 등록되어 있는 click, keydown 이벤트 리스너들이 호출될 때마다 콘솔에 출력해 줄 것이다.</p>\n<p>또는 이벤트 타입을 통해서 이벤트를 모니터링할 수도 있다. 예를 들어서 document.body에 키 관련 이벤트들을 모두 모니터링하고 싶다면 <code>monitorEvents(document.body, \"key\")</code>처럼 쓰면 된다.</p>\n<p>이외에도 mouse, touch, control 이벤트 타입이 있다.</p>\n<p>unmonitorEvents(object[, events])를 쓰면 해당 객체에 대한 이벤트 리스너 모니터링을 해제할 수 있다. unmonitorEvents(object)와 같이 쓰면 해당 객체에 대한 모든 이벤트 모니터링을 해제할 수 있다.</p>\n<h2>4.8. monitor(function)</h2>\n<p><code>monitor(function)</code>는 인자로 받은 함수를 모니터링한다. 함수가 호출될 때마다 콘솔에 출력해 준다. 다음과 같이 monitor 설정한 함수가 출력될 때마다 그 함수가 출력되었다는 메시지와 인자를 출력해 준다.</p>\n<p><img src=\"/static/monitor-1ce4a0cb.png\" alt=\"monitor\"></p>\n<p>unmonitor(function)을 쓰면 해당 함수에 대한 모니터링을 해제할 수 있다.</p>\n<h2>4.9. queryObjects(constructor)</h2>\n<p><code>queryObjects(constructor)</code>는 인자로 받은 생성자 함수를 통해 생성된 객체들을 배열 형태로 리턴해 준다. 예를 들어서 <code>queryObjects(HTMLDivElement)</code>를 쓰면 HTMLDivElement 생성자 함수를 통해 생성된 객체들을 리턴해 줄 것이다.</p>\n<p>만약 <code>a</code>가 클래스명이라면 <code>queryObjects(a)</code>를 쓰면 <code>new a()</code>를 통해 생성된 모든 객체들을 리턴해 줄 것이다. Promise와 같은 내장 생성자 함수에도 사용할 수 있다.</p>\n<p><code>queryObjects(Promise)</code>를 쓰면 Promise 생성자 함수(<code>new Promise()</code>)를 통해 생성된 모든 객체들을 리턴해 줄 것이다.</p>\n<h2>4.10. table(data)</h2>\n<p>console.table()의 단축 표현이다. 주어진 객체를 테이블 형태로 출력해 준다. 다음과 같이 데이터 객체에 쓸 수 있다.</p>\n<pre><code class=\"language-js\">const data = [\n  { name: \"John\", age: 30, city: \"New York\" },\n  { name: \"Jane\", age: 25, city: \"San Francisco\" },\n];\ntable(data);\n</code></pre>\n<p>2번째 인자로는 columns 배열을 선택적으로 넣을 수 있다. 이 배열을 넣을 시에 주어진 객체의 키 중에서 columns 배열에 포함된 키만 출력해 준다.</p>\n<p><img src=\"/static/table-244dc6de.png\" alt=\"table\"></p>\n<h1>참고</h1>\n<p><code>$</code>에 관련된 스택오버플로우의 질문 <a href=\"https://stackoverflow.com/questions/11778477/variable-dollar-sign-in-chrome\">https://stackoverflow.com/questions/11778477/variable-dollar-sign-in-chrome</a></p>\n<p>구글 콘솔 유틸리티에 관한 문서 <a href=\"https://developer.chrome.com/docs/devtools/console/utilities/\">https://developer.chrome.com/docs/devtools/console/utilities/</a></p>",
    "excerpt": "1. 시작\n개발하다 보면 개발자 도구에서 $ 표시를 볼 수 있다. Element 탭에서 내가 어떤 요소를 선택할 때마다 그 뒤에 ==$0이 뜨는 등의 경우이다.\n\n그리고 element 탭에서 특정 요소를 선택한 후 개발자 도구의 콘솔 창으로 이동해서 $0을 입력하면 선택한 요소가 출력되는 것도 볼 수 있다. 개발자 도구에서 $를 사용하는 것은 대체 무엇을 의미하는 것일까?\n개발자 도구에서 $가 들어가는 편리한 표현들 그리고 다른 몇 가지 편의기능을 알아보자.\n2",
    "headingTree": [
      {
        "title": "1. 시작",
        "url": "#1-시작",
        "items": []
      },
      {
        "title": "2. 기본",
        "url": "#2-기본",
        "items": [
          {
            "title": "2.1. $_",
            "url": "#21-_",
            "items": []
          },
          {
            "title": "2.2. $0, $1, $2, ...",
            "url": "#22-0-1-2-",
            "items": []
          }
        ]
      },
      {
        "title": "3. 다른 함수의 단축 표현",
        "url": "#3-다른-함수의-단축-표현",
        "items": [
          {
            "title": "3.1. document.querySelector",
            "url": "#31-documentqueryselector",
            "items": []
          },
          {
            "title": "3.2. document.querySelectorAll",
            "url": "#32-documentqueryselectorall",
            "items": []
          },
          {
            "title": "3.3. XPath expression",
            "url": "#33-xpath-expression",
            "items": []
          }
        ]
      },
      {
        "title": "4. 그 외 기능들",
        "url": "#4-그-외-기능들",
        "items": [
          {
            "title": "4.1. copy()",
            "url": "#41-copy",
            "items": []
          },
          {
            "title": "4.2. debug(function)",
            "url": "#42-debugfunction",
            "items": []
          },
          {
            "title": "4.3. dir(object)",
            "url": "#43-dirobject",
            "items": []
          },
          {
            "title": "4.4. inspect(object/function)",
            "url": "#44-inspectobjectfunction",
            "items": []
          },
          {
            "title": "4.5. getEventListeners(object)",
            "url": "#45-geteventlistenersobject",
            "items": []
          },
          {
            "title": "4.6. keys(object)",
            "url": "#46-keysobject",
            "items": []
          },
          {
            "title": "4.7. monitorEvents(object[, events])",
            "url": "#47-monitoreventsobject-events",
            "items": []
          },
          {
            "title": "4.8. monitor(function)",
            "url": "#48-monitorfunction",
            "items": []
          },
          {
            "title": "4.9. queryObjects(constructor)",
            "url": "#49-queryobjectsconstructor",
            "items": []
          },
          {
            "title": "4.10. table(data)",
            "url": "#410-tabledata",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 222
    },
    "url": "/posts/devtool-dollar-sign",
    "thumbnail": {
      "local": "/static/dev-tool-05195d40.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-dev-tool-05195d40-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAoUlEQVR4nAGWAGn/ALq+w0lPXwgBEzUyOysqNzY1OykmLoCAiADCytCVmKAuLDgRBRpVSVG7xsuvucGkqa0A+Pj5z87TOTM8GRgnQDpJioWJjImPr6+0AP///9XU1jUsLj02OElBR1pPSGlgYsfHywD39/fw8PFjW10vKzlWVWNwbnafm6DIx8gA9/f3////wb2/mpaXhIWMhIWMlZSUy8vLgz9K/G/yAOMAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "css-cascade-layer",
    "title": "CSS의 캐스케이드 레이어에 관하여",
    "date": "2023-03-31T01:00:00Z",
    "description": "CSS의 캐스케이드 레이어 관리하기",
    "tags": [
      "web",
      "study",
      "front",
      "CSS"
    ],
    "html": "<p>여러 사람이 협업하여 CSS를 작성하다 보면 여러 CSS가 섞이게 된다. 하지만 이 모든 CSS 선언은 author style sheet origin에 속하게 된다. 따라서 CSS의 cascade에서 class, id 등 셀렉터의 구체성을 고려하여 작성해야 한다.</p>\n<p>하지만 어떤 사람은 class로 셀렉터를 구분할 수도 있고 어떤 사람은 id를 쓸 수도 있다. 이런 게 섞이다 보면 충돌은 금방 일어나고, 이런 걸 빨리 고치기 위해서 <code>!important</code> 태그를 쓰거나 그렇지 않더라도 조율에 많은 비용을 쓰게 된다.</p>\n<p>cascade layer를 사용하면 이런 문제를 해결할 수 있다. cascade 레이어는 cascade 알고리즘에 하나의 단계를 더 만듦으로써 각 스타일시트에 우선순위를 부여할 수 있게 한다. 이에 대해서 알아보자.</p>\n<p>먼저 앞서 언급된 cascade 알고리즘부터 짚고 넘어가자.</p>\n<h1>1. CSS cascade 알고리즘이란?</h1>\n<p>CSS는 Cascading Style Sheets의 약자이다. 여기서 Cascading이란 브라우저가 요소에 적용할 하나의 스타일을 결정하는 알고리즘이다. 같은 요소를 선택하는 선택자는 여러 개가 있을 수 있는데 이 중 어떤 선택자의 스타일을 적용할지에 관한 문제를 해결하는 것이다.</p>\n<p>그럼 이 cascade는 어떻게 작동할까?</p>\n<h2>1.1. cascade의 재료</h2>\n<p>cascade에는 속성-값의 쌍인 CSS 선언만이 쓰인다. <code>@font-face</code>와 같은 at-rule들은 cascade에 영향을 주지 않는다.</p>\n<h1>2. cascade 알고리즘의 고려 요소</h1>\n<p>cascade 알고리즘은 다음과 같은 조건들을 고려한다. 가장 우선적으로 고려되는 조건부터 나열하였다.</p>\n<h2>2.1. 유래와 importance</h2>\n<p>importance는 CSS 선언에 <code>!important</code>를 붙여서 선언했는지를 뜻한다. <code>!important</code>를 붙이면 cascade 알고리즘에서 우선순위가 가장 높아진다. 이를 붙이는 게 권장되는 건 아니라서 꼭 필요할 때만 붙여야 하지만.</p>\n<p>그럼 유래라는 것은 뭘까? cascade 알고리즘에서 고려하는 CSS 선언은 3곳에서 유래될 수 있는데 이 유래가 어느 곳인지에 따라 우선순위가 달라진다.</p>\n<h3>2.1.1. User agent style sheet</h3>\n<p>브라우저는 모든 요소에 대해 기본 스타일을 제공한다. 예를 들어서 <code>&#x3C;h1></code> 요소는 기본적으로 <code>font-size: 2em</code>을 가지고 있다.</p>\n<p>몇몇 브라우저는 스타일시트를 직접 사용하기도 하고 이런 기본 스타일링을 코드로 만들어내기도 하지만 최종 결과는 같다.</p>\n<p>이렇게 브라우저가 제공하는 기본 스타일을 User agent style sheet라고 한다.</p>\n<h3>2.1.2. Author style sheet</h3>\n<p>author style sheet는 페이지의 개발자가 직접 작성한 스타일이다. HTML 문서에 선언(link나 style 태그를 통해)된 CSS 스타일로써 프론트엔드 개발자가 직접 작성한 스타일을 author style sheet라고 한다.</p>\n<h3>2.1.3. User style sheet</h3>\n<p>브라우저의 사용자가 정의한 스타일이다. 예를 들어서 사용자가 브라우저의 설정에서 폰트 크기를 변경하면 이런 스타일이 적용된다. 브라우저의 스타일을 덮어쓰고 싶은 사용자가 작성해서 적용한 스타일을 뜻한다.</p>\n<h3>2.1.4. 우선순위 결정</h3>\n<p>유래와 importance를 고려하여 cascade 알고리즘은 다음과 같은 우선순위를 가진다. 가장 우선순위가 높은 것부터 낮은 것 순으로 나열하였다.</p>\n<ol>\n<li>User-Agent &#x26;&#x26; !important</li>\n<li>User &#x26;&#x26; !important</li>\n<li>Author &#x26;&#x26; !important</li>\n<li>CSS 애니메이션, @keyframes (예외적인 경우로, author style sheet에 속하지만 브라우저는 일반적인 author style sheet보다 애니메이션을 더 우선적으로 처리한다)</li>\n<li>Author</li>\n<li>User</li>\n<li>User-Agent</li>\n</ol>\n<h2>2.2. 셀렉터의 구체성(specifity)</h2>\n<p>개발자는 선언의 유래를 바꿀 수도 없고 <code>!important</code>를 붙이는 것도 그렇게 권장되지 않는다. 따라서 개발자가 cascade를 고려할 때는 대부분 이 부분에서 고려한다.</p>\n<p>셀렉터는 더 구체적일수록 더 우선적으로 고려되어 스타일이 적용된다. 이 순서는 이런 식이다.</p>\n<pre><code>인라인 스타일 > id 셀렉터> 클래스/어트리뷰트/가상 셀렉터 > 태그/가상 요소 셀렉터 > 전체 셀렉터 > 상위 요소에 의해 상속된 속성\n</code></pre>\n<p>만약 CSS 선언에서 같은 우선순위 선택자가 있다면, 셀렉터 숫자까지 고려된다. 만약 다음과 같이 쓴다면 두 선언은 모두 id 셀렉터를 가지고 있으므로 우선순위가 같지만, id 셀렉터의 개수가 더 많은 선언이 더 우선순위가 높아서 title 아이디를 갖는 태그는 보라색이 된다.</p>\n<pre><code class=\"language-css\">#title#title {\n  color: purple;\n}\n\n#title {\n  color: red;\n}\n</code></pre>\n<p>그리고 이는 높은 우선순위를 갖는 셀렉터의 숫자가 같을 때도 마찬가지다. 같은 요소를 가리키는 셀렉터 2개가 하나는 <code>#title.myclass1</code> 이고 하나는 <code>#title2.myclass1.myclass2</code>라면 클래스 셀렉터 숫자가 더 많은 후자를 우선한다.</p>\n<h2>2.3. 선언 순서</h2>\n<p>간단하다. 나중에 선언된 스타일이 더 우선순위가 높다.</p>\n<p>이는 link 태그를 통해 css 파일을 로드할 때도 적용된다. 나중에 쓰인 link 태그가 로드하는 css 파일이 더 우선적으로 적용된다.</p>\n<h2>2.4. 기본/상속 속성</h2>\n<p>요소에 해당하는 CSS 선언이 없을 경우에 영향을 미친다. color 등의 속성들은 부모 요소에서 기본적으로 상속되기 때문이다. 그리고 상속되지 않는 속성들에 대해서는 보통 기본값이 있다. 이를테면 <code>background-color</code>는 기본값이 <code>transparent</code>이다.</p>\n<h1>3. cascade layer 이론</h1>\n<p>cascade 알고리즘에서 사실 고려하는 게 하나 더 있다. 바로 cascade layer이다. importance와 origin을 고려한 후, 셀렉터의 구체성을 고려하기 전에 cascade layer를 고려한다.</p>\n<p>즉 cascade 알고리즘은 다음과 같은 순서로 CSS 선언들을 고려하는 것이다.</p>\n<ol>\n<li>유래와 importance</li>\n<li>cascade layer</li>\n<li>셀렉터의 구체성</li>\n<li>선언 순서</li>\n<li>기본/상속 속성</li>\n</ol>\n<h2>3.1. cascade layer의 우선순위</h2>\n<p>cascade layer는 모든 유래로부터 온 CSS 선언들에 대해 sub-origin 레벨을 만들어서 우선순위를 정할 수 있게 한다. 각 origin 레벨에 대해서 여러 개의 cascade layer가 있을 수 있고 이 레이어들간의 순서는 만들어진 순서에 따라 결정된다.</p>\n<p>normal origin 즉 !important가 없는 유래를 가진 CSS 선언들에 대해서, layer들은 선언된 순서대로의 우선순위를 갖는다. 즉 가장 나중에 선언된 레이어의 CSS 선언이 가장 우선적으로 고려된다. 또한 레이어가 없는 스타일이 레이어가 있는 스타일보다 우선적으로 고려된다.</p>\n<p>importance origin을 가진 CSS 선언들에서도 가장 처음 선언된 레이어의 CSS 선언이 가장 우선적으로 고려되는 것은 같다. 하지만 이때는 레이어가 있는 스타일이 레이어가 없는 스타일보다 더 우선적으로 고려된다.</p>\n<h2>3.2. 중첩 레이어</h2>\n<p>중첩 레이어 또한 만들 수 있는데 이는 특정 조건 하에서 다른 스타일링을 하고 싶을 때 유용하다. 예를 들어서 미디어 쿼리를 적용한다고 하자. 그러면 components 레이어를 만든 후, 그 내부에 화면 너비에 따라 달라질 스타일링을 넣은 여러 레이어를 만들고 그 레이어들을 조건에 따라 보여주거나 숨기면 된다.</p>\n<p>그리고 이렇게 중첩 레이어를 만들면 레이어의 이름 충돌에 관한 우려도 없어진다.</p>\n<h1>4. cascade layer 문법</h1>\n<h2>4.1. cascade layer 만들기</h2>\n<p>cascade layer는 다음과 같이 만들 수 있다.</p>\n<pre><code class=\"language-css\">// 1. components 레이어 선언\n@layer components;\n// 2. components 레이어에 속한 스타일링과 함께 선언\n@layer components {\n  .button {\n    color: red;\n  }\n}\n// style.css 파일을 components 레이어로 만들기\n@import url(style.css) layer(components);\n</code></pre>\n<p>위에 있는 3가지 방법들은 만약 해당 이름의 레이어가 아직 없다면 새로운 레이어를 만들고, 만약 해당 이름의 레이어가 이미 있다면 그 레이어에 속한 스타일링을 추가한다.</p>\n<p>그리고 이런 레이어 선언에 레이어 이름이 없다면 새로운 익명의 레이어가 만들어진다.</p>\n<p>그럼 레이어 생성 방법들을 좀 더 알아보자.</p>\n<h2>4.2. @layer로 이름 가진 레이어 생성하기</h2>\n<p>다음과 같이 하면 theme, layout, utilities 레이어가 만들어진다. 만약 해당 이름의 레이어가 없다는 가정 하에서 그렇다. 그리고 각 레이어의 우선순위는 선언된 순서를 따른다. 이 말은 나중에 선언된 레이어가 더 우선적이라는 것이다.</p>\n<pre><code class=\"language-css\">// theme &#x3C; layout &#x3C; utilities 순으로 우선순위\n@layer theme, layout, utilities;\n</code></pre>\n<p>이런 선언은 cascade layer를 정의하고 우선순위를 정할 때 쓰인다. 또한 CSS 파일의 첫 줄에 레이어 선언을 해놔서 우선순위를 제어하는 것도 좋다. 한번 그렇게 정해진 우선순위는 바뀌지 않기 때문이다.</p>\n<pre><code class=\"language-css\">// 이렇게 하면 style2가 더 나중에 선언된 레이어이므로 우선적으로 고려되어 h1 태그는 파란색으로 표시되게 된다.\n@layer style1 {\n  h1 {\n    color: red;\n  }\n}\n\n@layer style2 {\n  h1 {\n    color: blue;\n  }\n}\n</code></pre>\n<p>또한 앞서 이야기한 것처럼 레이어에 들어 있지 않은 스타일이 더 우선적으로 고려된다. 이는 레이어에 있지 않은 스타일이 어디 위치해 있는지와는 상관없다.</p>\n<pre><code class=\"language-css\">// unlayered h1 태그가 더 먼저 선언되었지만 레이어에 속한 스타일보다 우선적으로 고려되어 h1 태그는 보라색으로 표시된다.\nh1 {\n  color: purple;\n}\n\n@layer style1 {\n  h1 {\n    color: red;\n  }\n}\n</code></pre>\n<p>또한 위에서 본 것과 같이 <code>@layer</code> 선언 이후에 레이어 식별자와 스타일 블록이 따라오면 해당 식별자 이름을 가진 레이어가 만들어지고 그 블록의 스타일이 레이어에 추가된다.</p>\n<p>만약 식별자 없이 스타일 블록만 따라오면 해당 스타일 블록의 익명 레이어가 만들어진다. 당연히 익명 레이어에도 우선순위가 있고 이는 선언 순서를 따른다.</p>\n<pre><code class=\"language-css\">// layout 레이어를 만들고 스타일을 지정한다. layout 레이어가 이미 있다면 그 레이어에 스타일을 추가한다.\n@layer layout{\n  .container {\n    width: 100%;\n  }\n}\n</code></pre>\n<p>익명 레이어에 스타일을 연속해서 지정하면 하나의 익명 레이어에 스타일이 계속 추가되는 게 아니라 서로 다른 익명 레이어가 계속 생기는 것에 주의하자.</p>\n<h2>4.3. @import로 레이어 가져오기</h2>\n<p><code>@import</code>는 사용자가 다른 스타일시트를 가져올 때 사용할 수 있다. 이렇게 스타일시트를 가져올 때 <code>@import</code>는 어떤 CSS 스타일이나 <code>&#x3C;style></code> 블럭 이전에 위치해야 한다.</p>\n<p>하지만 <code>@layer</code>를 이용해서 레이어를 선언하는 것은 <code>@import</code> 블록 앞에 위치해도 상관없다. 단 이렇게 레이어를 생성할 때 스타일을 지정하는 것은 안 된다.</p>\n<p>아무튼 이 import를 사용해서, 이름이 있는 레이어에 스타일시트를 추가할 수 있다. 중첩 스타일시트에도 가능하다.</p>\n<pre><code class=\"language-css\">@import url(\"style.css\") layer(layer1);\n</code></pre>\n<p>중첩 레이어에도 스타일을 추가할 수 있다. 다음 코드는 style.css의 스타일시트를 layer1 레이어 내부에 있는 layer2 레이어에 추가한다.</p>\n<pre><code class=\"language-css\">@import url(\"style.css\") layer(layer1.layer2);\n</code></pre>\n<p>하나의 레이어에 여러 CSS 파일 추가도 가능하다.</p>\n<pre><code class=\"language-css\">@import url(\"style1.css\") layer(layer1);\n@import url(\"style2.css\") layer(layer1);\n</code></pre>\n<p>미디어 쿼리나 피쳐 쿼리를 사용해서 조건부로 레이어를 가져올 수도 있다.</p>\n<pre><code class=\"language-css\">@import url(\"style.css\") layer(layer1) (width&#x3C;30rem);\n</code></pre>\n<p>이렇게 <code>@import</code>를 써서 스타일시트를 레이어에 넣는 건 스타일시트에 @layer를 직접 선언하는 것을 할 수 없을 때 해야 한다.</p>\n<h2>4.4. 미디어 쿼리와 레이어</h2>\n<p>미디어 쿼리나 피쳐 쿼리(<code>@supports</code>)를 사용해서 레이어를 만들 수 있다. 이렇게 하면 미디어 쿼리가 만족될 때만 해당 레이어가 만들어진다.</p>\n<p>다음과 같이 하면 미디어 쿼리(화면 너비 최소 600px)가 만족될 때만 desktop 레이어가 만들어진다.</p>\n<pre><code class=\"language-css\">@media (min-width: 600px) {\n  @layer desktop {\n    .button {\n      color: red;\n    }\n  }\n}\n</code></pre>\n<h2>4.5. 중첩 레이어</h2>\n<p>중첩 레이어를 사용하면 레이어 이름의 충돌에 대한 걱정 없이 레이어를 계층적으로 구성할 수 있다.</p>\n<p>중첩 레이어를 선언하는 방법은 그냥 다른 레이어의 블록 내에 <code>@layer</code>를 선언하는 것이다.</p>\n<pre><code class=\"language-css\">@layer base {\n  @layer components {\n    .button {\n      color: red;\n    }\n  }\n}\n</code></pre>\n<p>또는 <code>@import</code>를 사용할 수도 있다.</p>\n<pre><code class=\"language-css\">@import url(\"style.css\") layer(base.components);\n</code></pre>\n<p>이러면 base 레이어 내에 components 레이어가 만들어지고 style.css에 선언된 레이어가 있다면 base.components 레이어에 추가된다.</p>\n<p>물론 중첩 레이어에 스타일을 추가할 수도 있는데 다음과 같이 하면 된다.</p>\n<pre><code class=\"language-css\">@layer base.components{\n  .my-button {\n    color: purple;\n  }\n}\n</code></pre>\n<h1>5. 레이어 우선순위, 다시</h1>\n<p>레이어들의 우선순위는 다음과 같이 정해진다. 우선순위가 높은, 즉 스타일에서 가장 먼저 고려되는 것부터 나열한다.</p>\n<ol>\n<li>트랜지션 스타일(transition-xxx)</li>\n<li>인라인 &#x26;&#x26; !important</li>\n<li>레이어가 있는 스타일 &#x26;&#x26; !important</li>\n<li>레이어에 속해 있지 않은 스타일 &#x26;&#x26; !important</li>\n<li>애니메이션 스타일(animation-xxx)</li>\n<li>인라인 스타일</li>\n<li>레이어에 속해 있지 않은 스타일</li>\n<li>레이어에 속해 있는 스타일</li>\n</ol>\n<p>같은 우선순위를 가진 스타일이 있다면, important가 아닌 normal style에서는 나중에 선언된 스타일이 더 우선적으로 적용된다.</p>\n<p>하지만 important 스타일에서는 먼저 선언된 스타일이 더 우선적으로 적용된다. 많은 것에서 normal 스타일과 important 스타일이 반대된다는 것을 기억하자.</p>\n<p>그리고 트랜지션 스타일은 모든 스타일보다 우선하지만 트랜지션이 일어날 동안만 적용되므로 일시적이다.</p>\n<p>따라서 인라인이면서 important인 스타일은 일시적인 스타일 외에는 더 우선인 스타일이 없으므로, 오버라이드할 수 없다. 따라서 주의해서 써야 한다.</p>\n<h2>5.1. 중첩 레이어의 우선순위</h2>\n<p>중첩 레이어의 경우에도 이러한 우선순위가 똑같이 적용된다.</p>\n<p>normal 스타일의 경우 non-nested 스타일이 더 우선적으로 고려된다. important 스타일의 경우에는 반대다. 그리고 선언 순서에 따른 우선순위도 반대다.</p>\n<pre><code class=\"language-css\">@layer base {\n  .button {\n    color: red;\n    font-size: 1rem !important;\n  }\n}\n\n@layer base.components {\n  .button {\n    color: blue;\n    font-size: 2rem !important;\n  }\n}\n\n@layer base.utilities {\n  .button {\n    color: green;\n    font-size: 3rem !important;\n  }\n}\n</code></pre>\n<p>normal style의 경우 unnested layer가 더 우선적으로 고려되므로 button 클래스의 color는 red가 된다.</p>\n<p>반면 important 스타일의 경우 nested layer가 우선적으로 고려된다. 그런데 여기서 nested layer의 font-size의 important 스타일은 2개 있다. base.components의 것과 base.utilities의 것이다.</p>\n<p>important 스타일의 경우에는 선언 순서가 먼저인 게 더 우선적으로 고려된다. 따라서 base.components의 font-size가 우선적으로 적용된다. 즉 font-size는 2rem이 된다.</p>\n<h1>참고</h1>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/CSS/Cascade\">https://developer.mozilla.org/ko/docs/Web/CSS/Cascade</a></p>\n<p>CSS cascade에 관하여 <a href=\"https://blog.logrocket.com/how-css-works-understanding-the-cascade-d181cd89a4d8/\">https://blog.logrocket.com/how-css-works-understanding-the-cascade-d181cd89a4d8/</a></p>\n<p><a href=\"https://wit.nts-corp.com/2022/05/24/6528\">https://wit.nts-corp.com/2022/05/24/6528</a></p>",
    "excerpt": "여러 사람이 협업하여 CSS를 작성하다 보면 여러 CSS가 섞이게 된다. 하지만 이 모든 CSS 선언은 author style sheet origin에 속하게 된다. 따라서 CSS의 cascade에서 class, id 등 셀렉터의 구체성을 고려하여 작성해야 한다.\n하지만 어떤 사람은 class로 셀렉터를 구분할 수도 있고 어떤 사람은 id를 쓸 수도 있다. 이런 게 섞이다 보면 충돌은 금방 일어나고, 이런 걸 빨리 고치기 위해서 !important 태그를 쓰거나",
    "headingTree": [
      {
        "title": "1. CSS cascade 알고리즘이란?",
        "url": "#1-css-cascade-알고리즘이란",
        "items": [
          {
            "title": "1.1. cascade의 재료",
            "url": "#11-cascade의-재료",
            "items": []
          }
        ]
      },
      {
        "title": "2. cascade 알고리즘의 고려 요소",
        "url": "#2-cascade-알고리즘의-고려-요소",
        "items": [
          {
            "title": "2.1. 유래와 importance",
            "url": "#21-유래와-importance",
            "items": [
              {
                "title": "2.1.1. User agent style sheet",
                "url": "#211-user-agent-style-sheet",
                "items": []
              },
              {
                "title": "2.1.2. Author style sheet",
                "url": "#212-author-style-sheet",
                "items": []
              },
              {
                "title": "2.1.3. User style sheet",
                "url": "#213-user-style-sheet",
                "items": []
              },
              {
                "title": "2.1.4. 우선순위 결정",
                "url": "#214-우선순위-결정",
                "items": []
              }
            ]
          },
          {
            "title": "2.2. 셀렉터의 구체성(specifity)",
            "url": "#22-셀렉터의-구체성specifity",
            "items": []
          },
          {
            "title": "2.3. 선언 순서",
            "url": "#23-선언-순서",
            "items": []
          },
          {
            "title": "2.4. 기본/상속 속성",
            "url": "#24-기본상속-속성",
            "items": []
          }
        ]
      },
      {
        "title": "3. cascade layer 이론",
        "url": "#3-cascade-layer-이론",
        "items": [
          {
            "title": "3.1. cascade layer의 우선순위",
            "url": "#31-cascade-layer의-우선순위",
            "items": []
          },
          {
            "title": "3.2. 중첩 레이어",
            "url": "#32-중첩-레이어",
            "items": []
          }
        ]
      },
      {
        "title": "4. cascade layer 문법",
        "url": "#4-cascade-layer-문법",
        "items": [
          {
            "title": "4.1. cascade layer 만들기",
            "url": "#41-cascade-layer-만들기",
            "items": []
          },
          {
            "title": "4.2. @layer로 이름 가진 레이어 생성하기",
            "url": "#42-layer로-이름-가진-레이어-생성하기",
            "items": []
          },
          {
            "title": "4.3. @import로 레이어 가져오기",
            "url": "#43-import로-레이어-가져오기",
            "items": []
          },
          {
            "title": "4.4. 미디어 쿼리와 레이어",
            "url": "#44-미디어-쿼리와-레이어",
            "items": []
          },
          {
            "title": "4.5. 중첩 레이어",
            "url": "#45-중첩-레이어",
            "items": []
          }
        ]
      },
      {
        "title": "5. 레이어 우선순위, 다시",
        "url": "#5-레이어-우선순위-다시",
        "items": [
          {
            "title": "5.1. 중첩 레이어의 우선순위",
            "url": "#51-중첩-레이어의-우선순위",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 2,
      "wordCount": 419
    },
    "url": "/posts/css-cascade-layer",
    "thumbnail": {
      "local": "/thumbnails/css-cascade-layer-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-css-cascade-layer-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAjUlEQVR4nGNYsmSJk5NTampqcHCwq6urg4NDZWWluro6Q1lZGScnZ0ZGxsOHD+/du3flypWHDx8eP36cYePGjR0dHbNnz16+fPmUKVO2b9/+HwwYzp07N2PG9L6+vsrKSoiKr1+/giTu3rt37979Fy9eQPhwwLB42ar5CxetX7fuypUr//////37N0QCACSqZIocJaFdAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "favicon",
    "title": "favicon에 대하여",
    "date": "2023-06-16T00:00:00Z",
    "description": "favicon은 어떻게 설정할 수 있을까?",
    "tags": [
      "front",
      "tip"
    ],
    "html": "<h1>1. 파비콘</h1>\n<p>파비콘은 웹 페이지를 대표하여 사용되는 작은 이미지다. 북마크에 추가되었을 때 사이트를 표시하는 이미지, 탭에 해당 페이지가 띄워졌을 때 사이트 제목 옆에 작게 뜨는 이미지 등으로 사용된다.</p>\n<h1>2. 설정 방법</h1>\n<p><code>&#x3C;head></code> 태그 안에 <code>&#x3C;link></code> 태그를 추가하여 설정할 수 있다.</p>\n<pre><code class=\"language-html\">&#x3C;link rel='icon' type='image/png' sizes='16x16' href='/favicon-16x16.png' />\n</code></pre>\n<p>하지만 하나의 svg 이미지 같은 걸로 모든 아이콘을 설정하는 건 좋지 않다. 물론 기술적으로는 좋을지도 모르지만 UI/UX 관점에서는 아니다.</p>\n<p>iOS에서는 모든 홈 스크린 아이콘이 모서리가 둥근 정사각형 모양이다. 그러나 안드로이드에서는 정사각이 아닌 아이콘도 흔한 등 플랫폼에 따라 차이가 있다. 따라서 각 플랫폼에 따라 다른 아이콘을 사용하는 게 좋다.</p>\n<h2>2.1. iOS 사파리</h2>\n<p>사파리는 터치 아이콘을 파비콘으로 쓴다. 일반적으로 180x180 PNG 파일을 사용한다. transparency는 사용하면 안된다.</p>\n<pre><code class=\"language-html\">&#x3C;link rel='apple-touch-icon' sizes='180x180' href='/apple-touch-icon.png' />\n</code></pre>\n<p>이는 많은 브라우저에서 기본 고화질 아이콘으로 사용되기 때문에 북마크 추가시 보이는 이미지 등에도 흔히 사용된다.</p>\n<h2>2.2. 안드로이드 크롬</h2>\n<p>크롬은 Web App Manifest를 사용한다고 한다. 이것이 크롬만을 위한 건 아니지만 현재 크롬에서 가장 주로 지원하고 있다.</p>\n<p>192x192 PNG 파일을 사용하며 transparency를 사용해도 된다. (권장되기도 한다)</p>\n<pre><code class=\"language-html\">&#x3C;link rel='manifest' href='/site.webmanifest' />\n</code></pre>\n<h2>2.3. IE</h2>\n<p><code>browserconfig.xml</code> 파일을 사용한다. 32x32 PNG 파일을 사용한다.</p>\n<p>그리고 배경색도 지정해야 한다.</p>\n<pre><code class=\"language-html\">&#x3C;meta name='msapplication-TileColor' content='#ffffff' />\n&#x3C;meta name=\"msapplication-config\" content=\"/browserconfig.xml\">\n</code></pre>\n<h2>2.4. 일반적인 브라우저</h2>\n<p><code>favicon.ico</code>파일을 사용해서 파비콘을 선언하는 건 전통적인 방식이다. 하지만 대부분의 최신 브라우저는 더 가벼운 PNG 파일을 사용하는 것을 지원한다. 혹은 ICO 파일을 제대로 지원하지 않기까지도 한다.</p>\n<p>따라서 이 모든 걸 선언해 주고 브라우저에서 택하도록 할 수 있다.</p>\n<pre><code class=\"language-html\">&#x3C;link rel=\"icon\" type=\"image/png\" sizes=\"32x32\" href=\"/favicon-32x32.png\">\n&#x3C;link rel=\"icon\" type=\"image/png\" sizes=\"16x16\" href=\"/favicon-16x16.png\">\n&#x3C;link rel=\"shortcut icon\" href=\"/favicon.ico\">\n</code></pre>\n<p>오페라에서는 228x228 PNG 파일을 사용하는 등 몇몇 다른 브라우저의 표준도 있다. 하지만 이들은 어차피 위의 방식으로도 충분히 지원할 수 있기에 굳이 특화 아이콘을 만들어줄 필요는 없다고 한다.</p>\n<p><a href=\"https://realfavicongenerator.net/\">realfavicongenerator.net</a>에서 사진을 통해 파비콘을 생성하거나, 내 페이지의 파비콘이 제대로 되어 있는지를 체크할 수 있다.</p>\n<h1>참고</h1>\n<p><a href=\"https://stackoverflow.com/questions/48956465/favicon-standard-2023-svg-ico-png-and-dimensions\">https://stackoverflow.com/questions/48956465/favicon-standard-2023-svg-ico-png-and-dimensions</a></p>",
    "excerpt": "1. 파비콘\n파비콘은 웹 페이지를 대표하여 사용되는 작은 이미지다. 북마크에 추가되었을 때 사이트를 표시하는 이미지, 탭에 해당 페이지가 띄워졌을 때 사이트 제목 옆에 작게 뜨는 이미지 등으로 사용된다.\n2. 설정 방법\n<head> 태그 안에 <link> 태그를 추가하여 설정할 수 있다.\n<link rel='icon' type='image/png' sizes='16x16' href='/favicon-16x16.png' />\n\n하지만 하나의 svg 이미지 같은 걸",
    "headingTree": [
      {
        "title": "1. 파비콘",
        "url": "#1-파비콘",
        "items": []
      },
      {
        "title": "2. 설정 방법",
        "url": "#2-설정-방법",
        "items": [
          {
            "title": "2.1. iOS 사파리",
            "url": "#21-ios-사파리",
            "items": []
          },
          {
            "title": "2.2. 안드로이드 크롬",
            "url": "#22-안드로이드-크롬",
            "items": []
          },
          {
            "title": "2.3. IE",
            "url": "#23-ie",
            "items": []
          },
          {
            "title": "2.4. 일반적인 브라우저",
            "url": "#24-일반적인-브라우저",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 114
    },
    "url": "/posts/favicon",
    "thumbnail": {
      "local": "/thumbnails/favicon-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-favicon-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAbUlEQVR4nGNoaWnx9PQMCwtTUFBQVlbm4ODo6Oj4//8/w+TJk+3t7bds2XLkyJEzZ84cOXLk/v37IImdO3cmJiZeuHDhPypgQOP//v0bKnHpytULFy5ev3799evXKDqmTJvV1z9h0aJFENPgOgD73HBoM7155AAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "form-client-validation",
    "title": "클라이언트 form 데이터의 검증과 관리",
    "date": "2023-08-20T01:00:00Z",
    "description": "폼의 데이터를 어떻게 다루어야 잘 했다고 소문이 날까",
    "tags": [
      "HTML"
    ],
    "html": "<h1>0. 시작</h1>\n<p>사용자가 작성한 값을 관리하다가 서버로 제출하는 페이지는 매우 흔하게 쓰인다.</p>\n<p>그리고 이런 사용자의 입력값을 클라이언트에서 검증하는 일도 많다. <code>비밀번호는 8자 이상에 특수문자를 하나 이상 입력해 주세요</code>와 같이 입력한 내용의 형식을 지적하는 메시지를 누구나 한 번쯤 본 적이 있다.</p>\n<p>이렇게 클라이언트에서 사용자의 입력을 받고 검증하고 제출하는 페이지를 만들면서 생각해 볼 만한 건 두 가지가 있다. 첫째는 사용자의 입력값을 어떻게 검증할 것인가에 대한 것이고 둘째는 사용자의 많은 입력값들을 어떻게 관리할 것인가에 대한 것이다.</p>\n<p>당연히 이를 위한 여러 방법들이 있다. 간단한 로그인, 회원가입 폼을 이리저리 가공해 보면서 이 두 가지에 대해서 알아보자.</p>\n<p><a href=\"https://jeonghwan-kim.github.io/dev/2022/03/29/react-form-and-formik.html\">추가적으로 수집한 부분도 있지만 전체적으로 김정환 님의 블로그 글에서의 접근 방식을 많이 참고하였다.</a> 그리고 글의 코드들은 react를 사용해서 작성하였다.</p>\n<h1>1. 클라이언트 데이터 검증이란</h1>\n<h2>1.1. 개요</h2>\n<p>회원가입과 같이, 어떤 값을 입력한 후 그것을 서버에 제출해야 하는 페이지를 생각해 보자. 인터넷을 사용하는 사람이라면 그런 폼을 직접 사용해 본 적이 몇 번은 있을 것이다.</p>\n<p>그러다 보면 흔히 이런 메시지를 보게 된다. <code>비밀번호는 8자 이상에 특수문자를 하나 이상 입력해 주세요</code>라거나 <code>이메일 형식에 맞게 입력해 주세요</code>와 같이 입력한 내용의 형식을 지적하는 메시지 말이다. 그리고 이런 메시지가 뜨면 폼 제출도 되지 않는다. 내용을 형식에 맞게 수정한 후에야 제출할 수 있다.</p>\n<p>이런 내용 검증은 어떻게 이루어지고 있는 걸까? <code>onChange</code> 핸들러 같은 걸 이용해서 내용이 바뀔 때마다 서버에 사용자가 입력한 내용을 전송하고 해당 데이터를 서버에서 검증한 결과를 따로 표시해 줄 수 있겠다. 회원가입 폼의 비밀번호라고 온 데이터의 형식이 맞는지를 서버에서 검증한 후 아니라면 아니라는 응답을 보내는 식이다.</p>\n<p>하지만 이렇게 하면 서버에 많은 부담이 간다. 그리고 실시간으로 검증을 하기 어렵다. 물론 디바운싱과 같은 테크닉을 이용해서 구현하지 못할 건 없다. 하지만 코드가 복잡해지고, 클라이언트 검증이라는 좋은 방식이 있는데 굳이 그런 고급 테크닉까지 쓰면서 이런 실시간 서버 검증을 구현할 것은 없다. 그래서 많은 경우 이런 실시간 내용 검증은 클라이언트 쪽에서 진행하는 경우가 많다.</p>\n<h2>1.2. 보안 관련</h2>\n<p>물론 정말 악의적인 데이터를 서버에 보내고자 마음먹은 해커에게는 이런 클라이언트 유효성 검사가 전혀 문제가 되지 않는다. postman 등을 통해서 직접 서버로 데이터를 보내면 되기 때문이다. 따라서 이런 클라이언트단의 입력값 유효성 검사만으로 입력값에 대한 보안을 해결할 수는 없다. 서버에서도 사용자가 제출한 값에 대한 유효성 검사를 따로 해야 한다.</p>\n<p>하지만 이런 클라이언트 단의 입력값 검사는 서버에 부담을 주지 않고 사용자에게 빠른 피드백을 주는 데에 꽤나 효과적이기에 애용되고 있다.</p>\n<h1>2. HTML을 이용</h1>\n<p>간단한 로그인 폼을 만든다고 해보자. 로그인을 위한 정보 입력 시에는 일반적으로 입력값에 대한 검증이 없거나 적게 이루어진다. 하지만 예시를 위해 최대한 간단한 양식을 생각하다가 로그인 폼으로 예시를 들기로 결정했다.</p>\n<p>HTML의 양식 요소, 특히 <code>&#x3C;input></code>태그는 기본적으로 유효성 검사 기능을 제공한다. <code>required</code>정도는 꽤나 자주 보인다. 하지만 이외에도 길이나 형식 등을 검사할 수 있다. JS 없이도 양식 제출과 검증까지도 해낼 수 있다!</p>\n<p><img src=\"/static/login-with-html-ab65538b.png\" alt=\"JS 없이도 양식 제출이 가능하다\"></p>\n<p>HTML의 유효성 검사 기능만을 이용해서 로그인 폼을 만든다고 해보자.</p>\n<h2>2.1. 로그인 폼 기본구조</h2>\n<p>사실 이건 react의 기능을 특별히 쓸 것도 없는 HTML 구조이다.</p>\n<pre><code class=\"language-tsx\">// src/App.tsx\nfunction App() {\n  return (\n    &#x3C;main>\n      &#x3C;form>\n        &#x3C;fieldset className=\"login-form\">\n          &#x3C;legend>로그인&#x3C;/legend>\n          &#x3C;div>\n            &#x3C;label htmlFor=\"id\">아이디&#x3C;/label>\n            &#x3C;input type=\"text\" id=\"id\" name=\"id\" />\n          &#x3C;/div>\n          &#x3C;div>\n            &#x3C;label htmlFor=\"password\">비밀번호&#x3C;/label>\n            &#x3C;input type=\"password\" id=\"password\" name=\"password\" />\n          &#x3C;/div>\n          &#x3C;button type=\"submit\">로그인&#x3C;/button>\n        &#x3C;/fieldset>\n      &#x3C;/form>\n    &#x3C;/main>\n  );\n}\n\nexport default App;\n</code></pre>\n<p><code>login-form</code> 클래스는 그냥 입력창을 세로로 배열하고 너비에 약간 제한을 두기 위한 것이다. 디자인이 중요한 건 아니므로 넘어가자.</p>\n<pre><code class=\"language-css\">// src/index.css\n.login-form {\n  display: flex;\n  flex-direction: column;\n  gap: 1rem;\n  width:10rem;\n}\n</code></pre>\n<h2>2.2. 기본적인 유효성 검사</h2>\n<p>HTML <code>&#x3C;input></code>태그에서 제공하는 유효성 검사에 관한 속성들은 다음과 같다. <code>&#x3C;input></code>태그가 더 궁금하다면 <a href=\"https://witch.work/posts/html-input-tag\">해당 태그를 자세히 다룬 글을 참고하자.</a></p>\n<ul>\n<li><code>minlength</code>, <code>maxlength</code>: 입력할 수 있는 최소/최대 글자 수를 지정한다.</li>\n<li><code>min</code>, <code>max</code>: 어떤 값을 갖는 input에서 입력할 수 있는 최소/최대 숫자를 지정한다.</li>\n<li><code>spellcheck</code>: 브라우저가 맞춤법 검사를 지원할 경우 입력한 텍스트의 맞춤법을 검사하도록 할 수 있다. 단 브라우저가 이를 지원하지 않을 수 있다.</li>\n<li><code>pattern</code>: 유효성 검사를 위한 정규식을 지정한다. 특정 규칙을 만족하는 텍스트만 입력 가능하도록 할 수 있다.</li>\n<li><code>required</code>: 폼 제출시 이 input의 값을 필수로 만들어서 이 input이 비어있으면 폼 제출이 되지 않도록 할 수 있다.</li>\n<li><code>type</code>: input의 타입을 지정한다. <code>number</code>, <code>email</code>등을 지정하면 input의 값에 대한 유효성 검사가 자동으로 진행된다.</li>\n</ul>\n<p>이를 이용해서 아이디와 비밀번호를 필수 입력으로 지정하고 아이디는 일정 길이 범위 내의 이메일 형식으로 입력하도록 하고, 사용자가 입력한 아이디가 이메일 형식이 맞는지 검증이 이루어지도록 할 수 있다. 다음과 같이 말이다.</p>\n<p><code>type=\"email\"</code>을 이용해서 이메일 형식에 대한 검증을 하도록 했고 <code>required</code>를 이용해서 필수 입력으로 지정했다. 그리고 <code>minlength</code>과 <code>maxlength</code>를 이용해서 입력값의 길이 범위를 제한했다.</p>\n<pre><code class=\"language-tsx\">function App() {\n  return (\n    &#x3C;main>\n      &#x3C;form>\n        &#x3C;fieldset className=\"login-form\">\n          &#x3C;legend>로그인&#x3C;/legend>\n          &#x3C;div>\n            &#x3C;label htmlFor=\"id\">아이디&#x3C;/label>\n            &#x3C;input \n              type=\"email\" \n              id=\"id\" \n              name=\"id\" \n              placeholder=\"이메일 형식으로 입력해주세요.\"\n              minLength={5}\n              maxLength={30}\n              required\n            />\n          &#x3C;/div>\n          &#x3C;div>\n            &#x3C;label htmlFor=\"password\">비밀번호&#x3C;/label>\n            &#x3C;input \n              type=\"password\" \n              id=\"password\" \n              name=\"password\"\n              minLength={5}\n              maxLength={20}\n              required\n            />\n          &#x3C;/div>\n          &#x3C;button type=\"submit\">로그인&#x3C;/button>\n        &#x3C;/fieldset>\n      &#x3C;/form>\n    &#x3C;/main>\n  );\n}\n</code></pre>\n<p>이렇게 하면 예를 들어서 아이디를 양식에 맞지 않게 입력하거나 충분한 길이로 입력하지 않으면 경고창이 뜨는 등 제출시에 검증이 이루어진다.</p>\n<p><img src=\"/static/email-html-validation-6853993b.png\" alt=\"HTML을 이용한 이메일 형식 검증 결과\"></p>\n<p>그리고 <code>&#x3C;input></code>태그는 정규식을 사용해서도 검증할 수 있다. <code>pattern</code> 속성에 사용하고 싶은 정규식을 넣으면 된다. 예를 들어서 미국의 전화번호 형식을 검증하고 싶다면 다음과 같이 할 수 있다. <a href=\"https://regexlib.com/\">여기 쓰인 정규식은 여러 정규식 예시를 제공하는 사이트</a>에서 가져왔다.</p>\n<pre><code class=\"language-html\">&#x3C;input \n  type=\"tel\" \n  id=\"id\" \n  name=\"id\" \n  placeholder=\"전화번호를 입력해 주세요\"\n  pattern=\"^[2-9]\\d{2}-\\d{3}-\\d{4}$\"\n  required\n/>\n</code></pre>\n<p>만약 해당 input의 값이 정규식을 만족하지 않는 상태로 폼을 제출하게 되면 <code>요청한 형식과 일치시키세요.</code>라는 경고창이 뜨면서 제출이 되지 않게 된다.</p>\n<p>하지만 이렇게 하는 것은 약간 부족한 느낌이 든다. 왜냐 하면 이렇게 하면 일단 경고창의 스타일링이 불가능하다. 그리고 더 큰 문제는 사용자가 유효성 검사 결과에 대한 메시지를 양식을 제출하는 시점에 보게 된다는 것이다.</p>\n<p>이러면 사용자는 자신의 입력값을 실시간으로 검증할 수 없게 된다. 또한 클라이언트 유효성 검사의 장점은 실시간으로 입력값에 대한 검증 결과를 확인할 수 있어 사용자가 입력값을 바로바로 고치기 수월하다는 점인데 이렇게 제출 시점에만 메시지를 볼 수 있다면 클라이언트 검증의 UX적 의미가 떨어진다.</p>\n<p>따라서 <code>Constraint Validation API</code>와 <code>:valid</code>, <code>:invalid</code>의사 클래스를 이용해서 유효성 검사를 좀더 커스텀해보자.</p>\n<h1>3. <code>Constraint Validation API</code></h1>\n<h2>3.1. API 소개</h2>\n<p>지금까지 한 것만 해도 형식에 대한 어느 정도의 검증이 가능하다. 하지만 경고 메시지의 내용이나 스타일도 바꾸고, 유효성 검사를 통과하거나 통과하지 못했을 때 어떤 동작을 취하게 하고 싶을 수도 있다.그리고 실제로 그런 식으로 디자인된 페이지도 많다. 하지만 지금까지 한 내용만으로는 그것이 불가능하다.</p>\n<p>이를 위해서는 <code>Constraint Validation API</code>를 사용해야 한다.</p>\n<p>이는 form 요소들에서 사용가능한 메서드와 속성들로 구성되어 유효성 검사에 실패했을 때의 메시지를 변경하거나 특정 동작을 하게 하거나, 스타일을 변경하는 데에 도움을 준다.</p>\n<p><code>Constraint Validation API</code>를 지원하는 DOM 요소는 다음과 같다. 즉 다음 요소들에서 유효성 검사에 관련된 <code>validity</code>같은 프로퍼티들을 사용할 수 있다.</p>\n<ul>\n<li><code>&#x3C;input></code>(HTMLInputElement)</li>\n<li><code>&#x3C;select></code>(HTMLSelectElement)</li>\n<li><code>&#x3C;button></code>(HTMLButtonElement)</li>\n<li><code>&#x3C;textarea></code>(HTMLTextAreaElement)</li>\n<li><code>&#x3C;fieldset></code>(HTMLFieldSetElement)</li>\n<li><code>&#x3C;output></code>(HTMLOutputElement)</li>\n</ul>\n<p>그리고 이 요소들에서는 입력값의 유효성 검사 여부에 따라서 <code>:valid</code>, <code>:invalid</code> CSS 의사 클래스를 사용할 수 있다. <code>Constraint Validation API</code>와도 자동으로 연동된다.</p>\n<h2>3.2. 유효성 검사 메시지 내용 바꾸기</h2>\n<p><code>Constraint Validation API</code>를 이용하면 폼의 유효성 검사 결과를 이용할 수 있다. 이는 몇 가지 장점이 있다.</p>\n<p>첫째는 <code>:valid</code>, <code>:invalid</code> 의사 클래스를 이용해 폼의 메시지를 CSS로 스타일링할 수 있다는 것이고 둘째는 폼의 메시지를 사용자에게 일관적으로 보여줄 수 있다는 것이다.</p>\n<p>기본 유효성 검사 메시지는 브라우저마다, 국가마다 내용도 디자인도 다르다. 그런데 JS로 이런 유효성 검사 메시지를 커스텀하면 사용자에게 일관적인 내용의 유효성 관련 메시지를 보여줄 수 있다. 그러니 이를 이용해서 커스텀 메시지를 보여줘보자.</p>\n<p>가장 간단한 건 메시지의 내용을 바꾸는 것이다. <code>setCustomValidity(message)</code> API를 이용하면 된다. 다음과 같이 유효성 검사 객체의 값에 따라 메시지를 설정하는 함수를 만들어서 <code>&#x3C;input></code>의 <code>onChange</code> 핸들러에 넘겨주면 된다.</p>\n<pre><code class=\"language-tsx\">const checkValidation = (e: React.ChangeEvent&#x3C;HTMLInputElement>) => {\n  const {validity}=e.target;\n  if(validity.typeMismatch){\n    e.target.setCustomValidity(\"이메일 형식 커스텀 메시지\")\n  }\n  else if(validity.tooShort){\n    e.target.setCustomValidity(\"최소길이 미만일 때 커스텀 메시지\")\n  }\n  else if(validity.tooLong){\n    e.target.setCustomValidity(\"최대길이 초과일 때 커스텀 메시지\")\n  }\n}\n\n&#x3C;input\n  type=\"email\"\n  id=\"id\"\n  name=\"id\"\n  placeholder=\"이메일 형식으로 입력해주세요.\"\n  minLength={5}\n  maxLength={30}\n  required\n  onChange={checkValidation}\n/>\n</code></pre>\n<p>만약 <code>setCustomValidity</code>의 인수를 빈 문자열로 전달했다면 사용자 입력이 유효한 것으로 판단된다.</p>\n<h2>3.3. API 속성들</h2>\n<p>더 많은 커스텀을 해보기 전에 <code>Constraint Validation API</code>는 어떤 속성들을 제공하는지 간략히 정리한다.</p>\n<p><code>willValidate</code>는 해당 요소가 폼 제출 시 유효성 검사가 진행되는 요소일 경우 true, 아니면 false를 반환한다.</p>\n<p><code>validity</code>는 요소의 유효성 검사 결과를 담은 <code>ValidityState</code> 객체이다. <code>validationMessage</code>는 요소가 유효하지 않을 경우 그 상태를 설명하는 메시지를 반환한다. 만약 유효하거나 요소의 <code>willValidate</code>가 false라면 빈 문자열을 반환한다.</p>\n<p>이 객체의 키들은 각각의 유효성 검사 결과에 따라서 불린값을 가진다. 가령 <code>pattern</code>유효성 검사에서 실패하면 <code>patternMismatch</code>가 true가 된다. <code>tooLong</code>, <code>tooShort</code>, <code>typeMismatch</code>, <code>valueMissing</code> 등의 객체 프로퍼티들이 더 있다.</p>\n<p>요소의 값의 전체 유효성 검사 결과를 반환하는 <code>checkValidity()</code> 메서드와 유효성 검사 결과를 조사하기만 하는 <code>reportValidity()</code>메서드가 간간이 쓰인다. 커스텀 에러 메시지를 설정하는 <code>setCustomValidity(message)</code>메서드도 존재한다.</p>\n<h2>3.4. 메시지 커스텀 고급</h2>\n<p><code>&#x3C;form></code> 요소에 <code>novalidate</code> 어트리뷰트를 주어서 기본 유효성 검사를 끈 후 아예 새로 메시지를 만들 수도 있다. 굳이 메시지가 말풍선으로 나올 필요는 없지 않은가?</p>\n<p>먼저 에러 메시지를 표시할 <code>&#x3C;span></code>태그를 각 input 아래에 배치한다. HTML 구조만 표현해 보면 다음과 같다.</p>\n<pre><code class=\"language-html\">&#x3C;main>\n  &#x3C;form noValidate>\n    &#x3C;fieldset className='login-form'>\n      &#x3C;legend>로그인&#x3C;/legend>\n      &#x3C;div>\n        &#x3C;label htmlFor='email'>이메일&#x3C;/label>\n        &#x3C;input \n          type='email'\n          id='email' \n          name='email' \n          placeholder='이메일'\n          required\n          minLength={5}\n          maxLength={30}\n        />\n        &#x3C;span className='error' aria-live='polite'>\n          여기 이메일 입력값 검증 메시지가 들어갈 것이다.\n        &#x3C;/span>\n      &#x3C;/div>\n\n      &#x3C;div>\n        &#x3C;label htmlFor='password'>비밀번호&#x3C;/label>\n        &#x3C;input \n          type='password' \n          id='password'\n          name='password'\n          placeholder='비밀번호'\n          required\n          minLength={5}\n          maxLength={20}\n        />\n        &#x3C;span className='error' aria-live='polite'>\n          여기 비밀번호 값 검증 메시지가 들어갈 것이다.\n        &#x3C;/span>\n      &#x3C;/div>\n      &#x3C;button type='submit'>로그인&#x3C;/button>\n    &#x3C;/fieldset>\n  &#x3C;/form>\n&#x3C;/main>\n</code></pre>\n<p><code>&#x3C;form></code>태그의 <code>novalidate</code> 속성을 설정한다고 해서 <code>&#x3C;input></code>태그의 유효성 검사가 사라지는 것도 아니고 <code>:valid</code>같은 CSS 의사 클래스 기능을 못 쓰게 되는 것도 아니다. 그냥 무시되고 있는 것 뿐이다. 따라서 <code>Constraint Validation API</code>를 이용해서 유효성 검사 메시지에 대한 커스텀을 진행하면 된다.</p>\n<p>다음과 같이 에러 메시지와 유효성 여부에 따른 테두리 색상 등을 스타일링해준다. 사용자 입력이 유효하지 않을 시 입력창에 빨간 테두리가 생기도록 하고 에러 메시지는 빨간색 작은 글자로 만드는 등이다.</p>\n<pre><code class=\"language-css\">.login-form {\n  display: flex;\n  flex-direction: column;\n  margin: 0 auto;\n  gap: 1rem;\n  width:15rem;\n}\n\ninput{\n  appearance: none;\n  border: 1px solid #ccc;\n  margin: 0;\n  margin-bottom:0.5rem;\n\n  box-sizing: border-box;\n}\n\ninput:invalid{\n  border: 1px solid red;\n}\n\n/* 입력창 포커스시 빨간 테두리가 사라지도록 */\ninput:focus:invalid{\n  border: 1px solid #ccc;\n  outline: none;\n}\n\n.error{\n  display:block;\n  width: 100%;\n  padding:0;\n\n  font-size:0.8rem;\n  color: red;\n}\n</code></pre>\n<p>그리고 다음과 같이 유효성 검사 여부에 따라서 에러 메시지를 바꿔주는 함수를 만들고 적용하자. 다음 함수는 이메일에 대한 유효성 검사 메시지를 관리하는 부분이다.</p>\n<pre><code class=\"language-tsx\">const [emailError, setEmailError] = useState('이메일을 입력해주세요.');\n\nconst emailValidation= (e: React.ChangeEvent&#x3C;HTMLInputElement>) => {\n  const {validity}=e.target;\n\n  if (validity.typeMismatch) {\n    setEmailError('이메일 형식이 아닙니다.');\n  }\n  else if (validity.tooShort) {\n    setEmailError('이메일은 5자 이상이어야 합니다.');\n  }\n  else if (validity.valueMissing) {\n    setEmailError('이메일을 입력해주세요.');\n  }\n  else {\n    setEmailError('');\n  }\n};\n</code></pre>\n<p>그리고 해당 함수를 <code>&#x3C;input></code>의 <code>onChange</code> 핸들러에 넘겨주고 에러 메시지를 표시할 <code>&#x3C;span></code>태그에는 <code>emailError</code>를 넣어주면 된다.</p>\n<pre><code class=\"language-tsx\">&#x3C;input \n  type='email'\n  id='email' \n  name='email' \n  placeholder='이메일'\n  required\n  minLength={5}\n  maxLength={30}\n  onChange={emailValidation}\n/>\n&#x3C;span className='error' aria-live='polite'>\n  {emailError}\n&#x3C;/span>\n</code></pre>\n<p>이러면 입력창의 값이 바뀜에 따라서 커스텀한 에러 메시지가 표시된다.</p>\n<p><img src=\"/static/login-validation-failure-983ecabc.png\" alt=\"유효성 검사 실패시\"></p>\n<p>단 지금 <code>&#x3C;form></code>의 <code>novalidate</code>속성을 활성화시켰으므로 이런 유효성 검사가 실패해도 제출이 가능하다. 따라서 유효성 검사 결과에 따라 제출을 막는 기능을 위해 다음과 같은 <code>handleSubmit</code>함수를 만들어서 <code>&#x3C;form></code>의 <code>onSubmit</code>핸들러에 넘겨주는 방법을 쓸 수도 있다.</p>\n<pre><code class=\"language-tsx\">const handleSubmit = (e: React.FormEvent&#x3C;HTMLFormElement>) => {\n  e.preventDefault();\n  /* \n  e.target.email.checkValidity(), \n  e.target.password.checkValidity()\n  와 같이 validation API를 이용해서 유효성 검사를 진행할 수도 있다. \n  */\n  if (emailError || passwordError) {\n    alert('이메일과 패스워드를 형식에 맞게 입력해 주세요.');\n    return;\n  }\n  // 아무튼 뭔가 제출하는 동작\n  alert('로그인 성공');\n};\n</code></pre>\n<h2>3.5. 이렇게 하는 이유</h2>\n<p>물론 이런 건 입력 요소에 <code>onChange</code>핸들러를 넣어서 직접 검사하는 방식으로도 구현할 수 있다. 예를 들어서 <code>isValid</code> 같은 상태를 하나 만든 후 <code>onChange</code> 핸들러에서 <code>e.target.value</code>값에 따라서 <code>isValid</code>값을 변경시켜 주는 방식을 생각할 수 있겠다.</p>\n<p>하지만 이렇게 하면 <code>:valid</code>, <code>:invalid</code> 의사 클래스도 사용할 수 없고 유효성 검사 결과를 나타내는 상태도 하나 더 생기며 코드도 복잡해진다. 길이에 대한 간단한 검사와 같은 것은 경우에 따라 따져보기는 해야겠지만 대부분 HTML의 기본 유효성 검사 기능을 이용하는 것이 훨씬 쉬운데 굳이 <code>onChange</code>핸들러까지 쓸 이유는 없다.</p>\n<h1>4. 정보를 깔끔하게 관리하기</h1>\n<h2>4.1. 정보 관리의 동기</h2>\n<p>이제 우리는 커스텀 유효성 검사 메시지를 만들 수 있고 유효성 검사 결과에 따라 뭔가를 할 수 있도록 하는 <code>Constraint Validation API</code>도 알았다.</p>\n<p>그럼 이제 사용자 입력을 받는 폼을 만드는 것이 별거 아니게 되었을까? 전혀 그렇지 않다. 유효성 검사 자체는 커스텀할 수 있게 되었지만 폼은 기본적으로 복잡한 형식의 데이터를 많이 담고 있는 편이고, 그런 형태의 데이터를 관리하는 건 언제나 프론트의 힘든 일 중 하나이기 때문이다.</p>\n<p>예시를 위해서 로그인 폼보다는 복잡한 폼을 한번 만들어 보도록 하자. 회원가입 폼을 만드는 것이다. 다음과 같이 간단한 편인 회원가입 폼을 예시로 들겠다.(이보다 더 간결한 회원가입 폼도 있기는 하다. 하지만 회원가입을 위한 폼 중에는 훨씬 더 많은 정보를 입력해야 하는 폼도 많다는 것을 인터넷에 익숙한 사람이라면 알 것이다)</p>\n<p><img src=\"/static/signup-form-basic-254d5049.png\" alt=\"기본적인 회원가입 폼\"></p>\n<p>글의 길이 조절과 혹시 이 글을 읽을 사람을 위해서라도 많은 생략을 해야 할 정도로 길고 반복이 많은 코드가 되어 버렸다.</p>\n<pre><code class=\"language-tsx\">function App() {\n  const [nameError, setNameError] = useState('이름을 입력해주세요');\n  const [emailError, setEmailError] = useState('이메일을 입력해주세요.');\n  const [passwordError, setPasswordError] = useState('비밀번호를 입력해주세요.');\n  const [passwordConfirmError, setPasswordConfirmError] = useState('비밀번호를 입력해주세요.');\n  const [phoneNumberError, setPhoneNumberError] = useState('전화번호를 입력해주세요.');\n\n  const nameValidation=(e: React.ChangeEvent&#x3C;HTMLInputElement>) => {\n    /* 이름 입력값 검증 로직 */\n  };\n\n  const emailValidation=(e: React.ChangeEvent&#x3C;HTMLInputElement>) => {\n    /* 이메일 입력값 검증 로직 */\n  };\n\n  const passwordValidation = (e: React.ChangeEvent&#x3C;HTMLInputElement>) => {\n    /* 비밀번호 입력값 검증 로직 */\n  };\n\n  const passwordConfirmValidation = (e: React.ChangeEvent&#x3C;HTMLInputElement>) => {\n    /* 비밀번호 확인 입력값 검증 로직 */\n  };\n\n  const phoneNumberValidation = (e: React.ChangeEvent&#x3C;HTMLInputElement>) => {\n    /* 전화번호 입력값 검증 로직 */\n  };\n\n  return (\n    &#x3C;main>\n      &#x3C;form noValidate>\n        &#x3C;fieldset className='signup-form'>\n          &#x3C;legend>회원가입&#x3C;/legend>\n          &#x3C;div>\n            &#x3C;label htmlFor='password'>이름&#x3C;/label>\n            &#x3C;input \n              type='text' \n              id='name'\n              name='name'\n              placeholder='이름'\n              required\n              minLength={5}\n              maxLength={20}\n              pattern={'[a-zA-Zㄱ-ㅎㅏ-ㅣ가-힣]+'}\n              onChange={nameValidation}\n            />\n            &#x3C;span className='error' aria-live='polite'>\n              {nameError}\n            &#x3C;/span>\n          &#x3C;/div>\n\n          {/* 이메일, 비밀번호, 비밀번호확인, 전화번호 입력창 코드...(생략) */}\n\n          &#x3C;button type='submit'>가입하기&#x3C;/button>\n        &#x3C;/fieldset>\n      &#x3C;/form>\n    &#x3C;/main>\n  );\n}\n</code></pre>\n<p>당연히 이런 수많은 로직을 모두 한 컴포넌트에 때려넣는 게 좋지 않다는 건 뻔하다. 심지어 지금은 유효성 검사 뿐 아니라 HTML 태그 구조 등등 모든 걸 하나의 컴포넌트에서 관리하고 있다.</p>\n<p><img src=\"/static/form-structure-1-1fce5ea6.png\" alt=\"첫번째 폼 구조\"></p>\n<p>어떻게든 분할하고 좀더 재사용 가능한 로직을 만들어 보도록 하자.</p>\n<h2>4.1. 컴포넌트 만들기</h2>\n<p>먼저 이런 입력창들을 컴포넌트로 만들어서 관리할 수 있겠다. HTML 구조를 잡는 부분을 다른 컴포넌트에 넘겨주는 것이다. 리액트 컴포넌트는 진짜 전설이다...(컴포넌트를 처음 제안한 게 리액트는 아니었지만 말이 그렇다는 것이다)다음과 같이 에러 메시지와 입력의 값이 바뀔 때마다 검증을 진행하는 함수 그리고 input이 가질 유효성 검사 속성들을 넘겨주는 방식을 생각해 볼 수 있다.</p>\n<pre><code class=\"language-tsx\">type InputProps = {\n  type: string;\n  title: string\n  id: string;\n  name: string;\n  placeholder: string;\n  error: string;\n  handleChange: (e: React.ChangeEvent&#x3C;HTMLInputElement>) => void;\n  validProps: Record&#x3C;string, number | boolean | string>;\n};\n\nfunction Input(props: InputProps) {\n  const {type, id, name, placeholder, handleChange, validProps, error}=props;\n  return (\n    &#x3C;div>\n      &#x3C;label htmlFor={props.id}>{props.title}&#x3C;/label>\n      &#x3C;input \n        type={type}\n        id={id} \n        name={name}\n        placeholder={placeholder}\n        onChange={handleChange}\n        {...validProps}\n      />\n      &#x3C;span className='error' aria-live='polite'>\n        {error}\n      &#x3C;/span>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<p>다음과 같이 쓸 수 있다. 물론 <code>handleChange</code>에 들어가는 핸들러에서 검증 로직을 직접 넣어주는 방식으로 설계하여 <code>validProps</code> props를 없애는 것도 가능하다. 이후 코드에서는 그렇게 할 것이다.</p>\n<pre><code class=\"language-tsx\">&#x3C;Input\n  type='text'\n  title='이름'\n  id='name'\n  name='name'\n  placeholder='이름'\n  error={nameError}\n  handleChange={nameValidation}\n  validProps={{\n    required: true,\n    minLength: 5,\n    maxLength: 20,\n    pattern: '[a-zA-Zㄱ-ㅎㅏ-ㅣ가-힣]+',\n  }}\n/>\n</code></pre>\n<p>아무튼 입력창을 만드는 부분이 폼 컴포넌트 외부로 넘어갔다.</p>\n<p><img src=\"/static/form-structure-2-5a47b615.png\" alt=\"두번째 폼 구조\"></p>\n<h2>4.2. 훅으로 만들기</h2>\n<p>현재는 <code>App</code> 컴포넌트에서 모든 것을 관리하고 있다는 것이 상태 관리를 더욱 복잡하게 만든다. 폼 자체를 관리하는 기능과 회원가입이라는 도메인 기능이 섞여 있어서 그렇다고 말할 수도 있겠다.</p>\n<p>따라서 이를 훅으로 분리해서 훅 내부에서 값과 유효성 검사를 관리하고 필요한 로직만 외부로 노출하여 <code>App</code>컴포넌트에서 사용하도록 하는 것을 생각해 볼 수 있겠다. 폼 데이터의 관리는 훅에 위임하고 <code>App</code>에서는 회원가입에 관련된 부분만 관리할 수 있게 하는 것이다. 따라서 다음과 같은 훅을 설계하였다. <code>useForm</code>라고 이름을 지어 봤지만 이름이 중요한 건 아니다.</p>\n<p>이런 입력 상태의 흐름에 관해서는 <a href=\"https://tech.devsisters.com/posts/functional-react-state-management/\">폼 데이터를 우아하게 관리하는 방법</a>에서 아이디어를 얻어 설계하였다.</p>\n<pre><code>useForm 훅의 설계\n\n훅에서 관리하는 정보\n- 폼 내부의 입력 값\n\n훅이 주입받는 정보\n- 훅의 입력값을 검증할 함수\n- 훅을 통해서 만들어질 입력창이 form을 통해 제출될 때 호출될 콜백 함수\n\n훅에서 외부에 전달하는 정보\n- 입력창의 현재 입력 값\n- 입력창의 현재 입력 값에 대한 유효성 검사 결과\n- 입력창이 받을 onChange 핸들러\n- 입력창이 받을 onSubmit 핸들러\n</code></pre>\n<p>이를 구현한 <code>useForm</code>훅을 다음과 같이 만들어 볼 수 있다. <code>Object.values</code> 메서드를 사용하기 위해 제네릭 T를 객체의 확장 타입으로 정의하였지만 다른 방식으로 에러 객체를 검사할 수도 있으므로 필수적인 부분은 아니다. 하지만 훅으로 정보 관리를 분리한다는 것이 중점이므로 굳이 튜닝을 하지는 않겠다.</p>\n<pre><code class=\"language-tsx\">// src/hooks/useForm.ts\nimport { useState } from 'react';\n\nfunction useForm&#x3C;T extends Record&#x3C;string, string>>(submitCallback: () => void, validate: (values: T) => T) {\n  const [values, setValues] = useState&#x3C;T>({} as T);\n  const [errors, setErrors] = useState&#x3C;T>({} as T);\n\n  const handleSubmit = (e: React.FormEvent&#x3C;HTMLFormElement>) => {\n    if (e) {\n      e.preventDefault();\n    }\n    // 모든 값이 유효하면, 즉 error의 모든 값이 falsy일 때 콜백을 실행한다.\n    if (Object.values(errors).every(x=>!x)) {\n      submitCallback();\n    }\n  };\n\n  const handleChange = (e: React.ChangeEvent&#x3C;HTMLInputElement>) => {\n    e.persist();\n    const currentValues={...values, [e.target.name]: e.target.value};\n    setValues(currentValues);\n    /* 실시간으로 현재 값에 대해 에러 검증 */\n    setErrors(validate(currentValues));\n  };\n\n  return {\n    values,\n    errors,\n    handleChange,\n    handleSubmit,\n  };\n}\n\nexport default useForm;\n</code></pre>\n<p>외부에서는 다음과 같이 제출 콜백과 유효성 검사 함수를 넘겨주면 된다.</p>\n<pre><code class=\"language-tsx\">const { values, errors, handleChange, handleSubmit }=useForm&#x3C;FormValues>(signUp, validate);\n</code></pre>\n<p>그리고 아마 이런 식으로 사용하여 폼을 좀 더 간결한 코드로 작성할 수 있겠다. 모든 <code>inputName</code>이 <code>&#x3C;input></code>태그의 타입으로 존재하지는 않으므로 <code>type={key}</code>와 같은 할당은 약간 문제가 될 수도 있겠지만 디폴트로 <code>type=\"text\"</code>를 넣어주는 등의 방식으로 해결할 수 있다.</p>\n<p><a href=\"https://jeonghwan-kim.github.io/dev/2022/03/29/react-form-and-formik.html#%EC%98%A4%EB%A5%98-%EB%A9%94%EC%84%B8%EC%A7%80%EB%A5%BC-%EB%8D%94-%EC%9D%BC%EC%B0%8D-%EB%B3%B4%EC%97%AC%EC%A3%BC%EA%B8%B0\">사용자가 값을 다 채우기도 전에 오류 메시지부터 보여준다면 사용자를 재촉하는 느낌이 들 수 있으므로 UX를 생각했을 때는 <code>onChange</code>가 아니라 <code>onBlur</code>이벤트에 값 검증을 진행하는 것도 좋을 것이다. 개발자의 선택이다.</a></p>\n<pre><code class=\"language-tsx\">const inputNames: FormValues={\n  name: '이름',\n  email: '이메일',\n  password: '비밀번호',\n  tel: '전화번호',\n};\n\n// ...\n\n// 입력창을 생성하는 부분\n{Object.keys(inputNames).map((key) => (\n  &#x3C;Input\n    key={key}\n    type={key}\n    id={key}\n    name={key}\n    title={inputNames[key]}\n    placeholder={`${inputNames[key]}을 입력하세요`}\n    error={errors[key] || ''}\n    value={values[key] || ''}\n    handleChange={handleChange}\n  />\n))}\n</code></pre>\n<p>그리고 validate 함수는 다음과 같은 형태가 될 것이다. 실제의 검증 로직은 훨씬 더 복잡하겠지만, 어쨌거나 각각의 입력 값들에 대해서 검증을 진행하여 각 데이터들에 대한 결과를 담은 객체를 리턴해 주는 함수이다.</p>\n<pre><code class=\"language-ts\">// src/utils/validate.ts\nfunction validate(values: FormValues) {\n  const errors: FormValues= {\n    email: '',\n    name: '',\n    password: '',\n  };\n\n  if (!values.name) {\n    errors.name = 'Name is required';\n  }\n  else if (values.name.length&#x3C;2) {\n    errors.name='Name must be at least 2 characters';\n  }\n  else {\n    errors.name='';\n  }\n\n  if (!values.email) {\n    errors.email = 'Email is required';\n  }\n  // ...\n  else {\n    errors.email='';\n  }\n\n  // 다른 key에 대한 검증 코드...\n\n  return errors;\n}\n</code></pre>\n<p>이제 폼은 이런 구조로 작동하게 된다.</p>\n<p><img src=\"/static/form-structure-3-b3330886.png\" alt=\"세번째 폼 구조\"></p>\n<p><a href=\"https://jeonghwan-kim.github.io/dev/2022/03/29/react-form-and-formik.html\">김정환님의 글에서도 비슷한 접근을 하고 있다. 여기서는 컨텍스트 API를 이용해서 더 재사용 가능한 로직으로 만드는 방법도 제공하고 있다.</a></p>\n<h2>4.3. 유효성 검사 함수 개선</h2>\n<p>복잡한 상태와 구조들을 중앙에서 모두 관리하는 데에 더불어 반복이 엄청나게 많던 코드에서 시작했다. 처음에는 HTML 구조를 만드는 부분을 컴포넌트로 분리했다. 그리고 폼 데이터와 유효성 검사 그리고 제출 시 검증하는 부분을 필요한 정보를 외부에서 주입받아서 관리해 주는 훅으로 분리했다.</p>\n<p>무언가 더 개선할 수 있을까? 아까 훅을 설계할 때 보았던 부분으로 다시 돌아가 보자. 이런 부분이 있었다.</p>\n<pre><code>훅이 주입받는 정보\n- 훅의 입력값을 검증할 함수\n- 훅을 통해서 만들어질 입력창이 form을 통해 제출될 때 호출될 콜백 함수\n</code></pre>\n<p>여기서 제출 시 호출할 콜백은 서버에 post요청으로 데이터를 보낸다거나 보내기 위한 전처리를 좀더 하는 작업이 될 듯 하다. 사용자가 서버와의 통신을 위해 사용하는 라이브러리나 좋아하는 구현 방식 등에 따라 크게 갈릴 부분이므로 일반화해서 개선하기는 힘들다고 생각한다.</p>\n<p>그럼 훅의 입력값을 검증할 함수는? 위의 <code>validate</code>함수와 같은 부분은 뭔가 개선할 수 없었을까?</p>\n<p>함수형을 하드하게 적용하지는 않을 것이지만 <a href=\"https://tech.devsisters.com/posts/functional-react-state-management/\">폼 데이터를 우아하게 관리하는 방법(데브시스터즈 기술 블로그는 반응형 폰트 크기 좀 개선해 줬으면 한다. 좁은 창으로 보기 힘들었다...)</a>에서 유효성 검사 함수를 개선할 아이디어를 얻을 수 있었다.</p>\n<p>해당 글을 쓰신 분은 함수형을 매우 좋아하시기에 <code>fp-ts</code>를 사용하였지만 여기서는 아이디어만 따와 흉내만 내보겠다. <a href=\"https://parksb.github.io/article/40.html\">함수형은 특정 라이브러리에서가 아니라 함수를 아주 일반적인 값과 같이 다룰 수 있는 데에서 시작되는 거 아니겠는가?</a></p>\n<p>입력값 검증 함수를 만들다 보면 반복되는 부분들이 있다. '값이 필수적으로 입력되어 있어야 한다'나 '특정 길이 이상이어야 한다'와 같은 규칙들은 자연스럽게 여러 필드가 공통으로 사용하게 된다. 따라서 이런 반복되는 작은 규칙들을 조합해서 검증 로직을 만들 수 있도록 하자. 그러기 위해서는 일단 규칙들을 만드는 함수가 필요하다. 대략 이런 함수들을 만들어 보았다.</p>\n<pre><code class=\"language-ts\">/* \n특정 조건이 충족되면 빈 문자열, 충족되지 않으면 조건 불일치 메시지를 반환하는 검증 규칙 함수를 생성하는 함수들\n*/\nconst minLength=(limit: number)=>{\n  return (name: string, value: string)=>{\n    if (value.length&#x3C;limit) {\n      return `${name} must be at least ${limit} characters`;\n    }\n    return '';\n  };\n};\n\nconst maxLength=(limit: number)=>{\n  return (name: string, value: string)=>{\n    if (value.length>limit) {\n      return `${name} must be at most ${limit} characters`;\n    }\n    return '';\n  };\n};\n\nconst mustContain=(char: string)=>{\n  return (name: string, value: string)=>{\n    if (!value.includes(char)) {\n      return `${name} must contain ${char}`;\n    }\n    return '';\n  };\n};\n\nconst required=()=>{\n  return (name: string, value: string)=>{\n    if (!value) {\n      return `${name} is required`;\n    }\n    return '';\n  };\n};\n\nconst testRegex=(regex: RegExp)=>{\n  return (name: string, value: string)=>{\n    if (!regex.test(value)) {\n      return `${name} is invalid`;\n    }\n    return '';\n  };\n};\n</code></pre>\n<p>그리고 해당 규칙 검증 함수들을 연쇄적으로 거치면서 검증을 진행하다가 검증이 실패하면 에러 메시지를 리턴하는 함수를 만들어 보자. 여러 작은 규칙들을 조합해서 검증 로직을 만들 수 있도록 말이다.</p>\n<pre><code class=\"language-ts\">const validatePipe=(name: string, value: string, validators: ((name: string, value: string) => string)[])=>{\n  for (const validator of validators) {\n    const error=validator(name, value);\n    if (error) {\n      return error;\n    }\n  }\n  return '';\n};\n</code></pre>\n<p>그러면 다음과 같이 검증 규칙들을 조합해서 특정 값에 대한 검증 함수를 만들 수 있다.</p>\n<pre><code class=\"language-ts\">const validateEmail=(value: string)=>{\n  return (\n    validatePipe('Email', \n      value, \n      [\n        required(), \n        minLength(2), \n        maxLength(30), \n        mustContain('@'), \n        testRegex(/^[a-zA-Z0-9+_.-]+@[a-zA-Z0-9.-]+$/)\n      ]\n    )\n  );\n};\n</code></pre>\n<p>이렇게 하면 최종 검증 함수도 이런 식으로 바뀔 것이다.</p>\n<pre><code class=\"language-ts\">function validate(values: FormValues) {\n  const errors: FormValues= {\n    email: '',\n    name: '',\n    password: '',\n    // 다른 입력값들 필드...\n  };\n\n  errors.name=validateName(values.name);\n  errors.email=validateEmail(values.email);\n  errors.password=validatePassword(values.password);\n\n  // 다른 입력값들에 대한 검증...\n\n  return errors;\n}\n</code></pre>\n<p>이런 식으로 하면 실제 코드 양은 늘어났을지도 모른다. 하지만 모든 검증 함수 로직이 작은 조각들의 조합으로 나타날 수 있게 되었기 때문에 새로운 규칙을 추가하거나 기존 규칙을 수정할 때도 훨씬 편리해진다. 또한 검증 규칙을 재사용할 수도 있게 되었다. 검증에 대한 책임도 잘게 쪼개어지고 위계를 가지게 되었으므로 코드를 파악하기도 수월해졌다.</p>\n<p>이런 식으로 작은 규칙들을 조합해서 검증기를 만들 수 있도록 지원하는 유명한 라이브러리로 <a href=\"https://github.com/jquense/yup\">yup</a>이라는 것도 존재한다.</p>\n<p>yup을 이용하면 여러가지 검증 규칙과 검증 규칙에 따라 보여줄 에러 메시지를 설정하고 조합해서 적용할 수 있다. 이후에 소개할 여러 폼 관리 라이브러리와 조합해서 사용하는 것도 각각의 공식 문서에서 많이 권장되고 있다.</p>\n<h2>4.4. 추가적인 개선?</h2>\n<p>복잡한 폼을 수월하게 관리하기 위해 HTML의 구조, 값 관리와 유효성 검사 로직, 그리고 유효성 검사 함수 그 자체의 책임을 분리하였다. 하지만 추가적인 개선을 생각해 볼 만한 게 한 가지 더 있다.</p>\n<p>어떤 방식으로 하든 나의 설계 능력으로는 책임을 적절하게 분배하지 못하고 하나의 훅이나 컴포넌트에 너무 많은 책임을 지우게 될 것 같아서 하지는 못했지만, 입력창을 렌더링하는 부분도 <code>App</code>컴포넌트에서 다른 곳으로 옮기는 것을 생각해볼 수 있다. 현재는 <code>App</code>에서 <code>Input</code>컴포넌트를 이용해서 입력창들을 렌더링하고 있는데 이를 다른 어딘가에 위임하는 것이다.</p>\n<p>먼저 아예 렌더링까지 <code>useForm</code>훅에 맡길 수도 있다. <code>renderForm()</code>과 같은 함수만 호출하면 알아서 폼 입력창들이 생기도록 말이다. 이렇게 커스텀 훅에서 렌더링까지 하려면 <a href=\"https://engineering.linecorp.com/ko/blog/line-securities-frontend-3\">React 컴포넌트를 커스텀 훅으로 제공하기</a>를 참고할 수 있다.</p>\n<p><code>Form</code>과 같은 컴포넌트를 만들고 <a href=\"https://patterns-dev-kr.github.io/design-patterns/render-props-pattern/\">render props 패턴을</a> 이용해서 사용할 input창 컴포넌트를 props로 주입해 주는 방식도 생각할 수 있겠다. 다음 섹션에서 다룰 Formik에서 이를 비슷하게 구현하고 있다.</p>\n<h1>5. 폼 라이브러리</h1>\n<p>벌써 글이 800줄이 넘어가고 있다. 그러고도 생략했거나 나의 부족한 실력으로 인해 소개하지 못한 방법들이 꽤 있다. 폼 데이터를 관리하는 건 이렇게 쉬운 일이 아니다.</p>\n<p>그럼 당연히 이런 상황을 해결하기 위한 라이브러리들도 아주아주 많다. <a href=\"https://blog.logrocket.com/react-form-validation-sollutions-ultimate-roundup/\">폼 유효성 검사를 위해 쓰일 수 있는 라이브러리를 소개하는 logrocket의 글에만 해도 10개의 라이브러리가 소개되어 있다.(소개된 라이브러리 간의 스타 갯수 차이를 보면 10개를 채우기 위해 몇 개는 억지로 넣은 느낌이 조금 들지만)</a></p>\n<p>이중 서로 다른 방식을 취하고 있으며 또한 가장 유명하기도 한 2개의 formik, react hook form을 간단히 소개한다. formik은 제어 컴포넌트로 폼 데이터를 관리하는 것을, react hook form은 비제어 컴포넌트로 폼 데이터를 관리하는 것을 추구하고 있다.</p>\n<p><a href=\"https://www.npmjs.com/package/redux-form\">redux form도 있지만 redux와 폼 데이터의 너무 강력한 결합을 만들기 때문에 추천되지 않고, 대신 react final form이나 formik을 사용하는 것이 권장되고 있다.</a> 이 react final form도 빠르게 성장하고 있는 라이브러리지만 기본적인 접근 방식이 formik과 유사하고 formik이 현재로서는 더 많이 쓰이고 있으므로 이 글에서는 생략한다.</p>\n<h2>5.1. Formik</h2>\n<h3>5.1.1. 모티베이션</h3>\n<p>위의 폼 데이터 검증 방식을 좀 더 추상화하고 재사용 가능하도록 만들 수는 없을까? 고차 컴포넌트를 만드는 것을 생각해 볼 수 있다. 위에서 만든 커스텀 훅이 받는 인자들을 받아서 커스텀 훅에 넘기고, 커스텀 훅의 리턴값들을 context API를 통해서 후손 컴포넌트에서 사용할 수 있도록 하는 것이다.</p>\n<p>또한 후손 컴포넌트들은 <code>useContext</code>를 이용해서 해당 값들을 받아 쓸 수 있도록 하고 말이다.</p>\n<p>예를 들어서 다음과 같이, useForm 훅으로 만든 값들(values, errors, handleSubmit 등)을 후손 컴포넌트들에서 쓸 수 있도록 하는 고차 컴포넌트를 만드는 것이다.</p>\n<pre><code class=\"language-tsx\">const FormContext=createContext({});\n\nfunction Form({children, ...restProps}) {\n  const formValue=useForm(restProps);\n\n  return (\n    &#x3C;FormContext.Provider value={formValue}>\n      &#x3C;form onSubmit={formValue.handleSubmit}>\n        {children}\n      &#x3C;/form>\n    &#x3C;/FormContext.Provider>\n  );\n}\n</code></pre>\n<p><code>Form</code>의 후손 컴포넌트들에서는 위에서 말했듯 <code>useContext</code>를 이용해서 <code>Form</code>의 context에서 제공하는 폼 데이터 관리를 위한 값들을 사용할 수 있도록 할 수 있다. 이런 식으로 말이다.</p>\n<pre><code class=\"language-tsx\">function Field({name, ...restProps}) {\n  const {values, errors, handleChange}=useContext(FormContext);\n\n  return (\n    &#x3C;div>\n      &#x3C;label htmlFor={name}>{name}&#x3C;/label>\n      &#x3C;input \n        id={name}\n        name={name}\n        value={values[name]}\n        onChange={handleChange}\n        {...restProps}\n      />\n      &#x3C;span className='error' aria-live='polite'>\n        {errors[name]}\n      &#x3C;/span>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<p>이렇게 하면 폼 컴포넌트와 입력 필드들을 이런 식으로 추상화해서 쓸 수 있을 것이다.</p>\n<pre><code class=\"language-tsx\">&#x3C;Form\n  onSubmit={handleSubmit}\n  validate={validate}\n>\n  &#x3C;Field\n    name='name'\n    placeholder='이름'\n  />\n  {/* 다른 필드들... */}\n  &#x3C;button type='submit'>가입하기&#x3C;/button>\n&#x3C;/Form>\n</code></pre>\n<p>위의 방식에서는 <code>Field</code> 컴포넌트 내에서 에러 메시지를 보여주기 위한 <code>&#x3C;span></code>태그를 관리하고 있는데 이를 <code>ErrorMessage</code>같은 컴포넌트로 따로 빼도록 할 수도 있겠다.</p>\n<p>이런 것을 구현한 라이브러리가 바로 Formik이다. 형식이 약간 다르고 잘 만들어진 라이브러리니까 이 글에서 구현한 것보다는 기능도 많지만, 지금까지 만들었던 <code>useForm</code> 커스텀 훅을 <code>useFormik</code>으로, <code>&#x3C;Form></code>컴포넌트를 <code>&#x3C;Formik></code>컴포넌트로 바꾸면 Formik 라이브러리의 사용법과 거의 비슷하다.</p>\n<p>폼의 상태를 확인하고, 유효성 검사와 거기에 따르는 에러 메시지를 관리하고 폼 제출을 위한 콜백을 관리하는 것-즉 우리가 지금까지 커스텀 훅을 통해서 해온 것-을 정형화시켜서 만든 것이 바로 <code>Formik</code>인 것이다.</p>\n<h3>5.1.2. Formik 사용법</h3>\n<p>Formik에서는 우리가 만들었던 <code>useForm</code>훅과 거의 비슷한 <code>useFormik</code>훅을 지원한다. <code>onSubmit</code>, <code>validate</code>, <code>initialValues</code>등을 key로 갖는 객체를 인자로 받아서 <code>handleSubmit</code>, <code>handleChange</code>, <code>values</code>, <code>errors</code>등을 리턴한다.</p>\n<p>그리고 이를 래핑한 컴포넌트인 <code>&#x3C;Formik></code>과 여기서 나온 값을 자동으로 받아서 사용하는 <code>&#x3C;Field></code>, <code>&#x3C;ErrorMessage></code>컴포넌트를 지원한다. <code>useFormik</code>을 쓰기보다는 이를 래핑한 <code>&#x3C;Formik></code>컴포넌트를 쓰는 것이 더 편리하며 공식 문서에서도 특별한 이유가 없다면 <code>&#x3C;Formik></code>을 사용하기를 권장한다.</p>\n<p>대략 이런 식으로 사용할 수 있다. <code>&#x3C;Field></code>와 <code>&#x3C;ErrorMessage></code> 컴포넌트에서는 <code>&#x3C;Formik></code>컴포넌트에서 props에 따라 자동으로 생성해 주는 <code>onChange</code>, <code>onBlur</code>, <code>value</code>, <code>checked</code>를 알아서 사용해 준다. 이 연결은 각 컴포넌트에 넘겨준 <code>name</code>를 통해서 이루어진다. (실제로는 <code>getFieldProps(name)</code>함수를 이용한다)</p>\n<pre><code class=\"language-tsx\">function App() {\n  return (\n    &#x3C;main>\n      &#x3C;Formik\n        initialValues={{\n          email: '',\n          name: '',\n          password: '',\n        }}\n        onSubmit= {(values) => {\n          console.log(values);\n        }}\n        validate={validate}\n      >\n        &#x3C;Form>\n          &#x3C;legend>회원가입&#x3C;/legend>\n          &#x3C;label htmlFor='email'>이메일&#x3C;/label>\n          &#x3C;Field name='email' type='email' />\n          &#x3C;ErrorMessage name='email' />\n\n          &#x3C;label htmlFor='name'>이름&#x3C;/label>\n          &#x3C;Field name='name' type='text' />\n          &#x3C;ErrorMessage name='name' />\n\n          &#x3C;label htmlFor='password'>비밀번호&#x3C;/label>\n          &#x3C;Field name='password' type='password' />\n          &#x3C;ErrorMessage name='password' />\n          &#x3C;button type='submit'>가입하기&#x3C;/button>\n        &#x3C;/Form>\n      &#x3C;/Formik>\n    &#x3C;/main>\n  );\n}\n</code></pre>\n<p>대략 이런 방식으로 초기값, 유효성 검사 함수, 제출 콜백을 넘겨주고 외부로 노출된 함수들을 통해 폼 데이터를 관리하고 제어하도록 해주는 라이브러리가 바로 Formik이다.</p>\n<p>React 제어 컴포넌트들을 이용해서 복잡한 폼 데이터를 관리하는 것을 극한까지 추상화해서 재사용 가능하도록 만들어 놓은 라이브러리라고 할 수 있겠다. <a href=\"https://formik.org/docs/tutorial\">공식 문서의 튜토리얼을 참고해서 더 깊이 알아볼 수 있다.</a></p>\n<p>참고로 앞에서 추상화된 작은 함수들을 조합해서 검증 함수를 만드는 것을 해보았는데, Formik에서도 비슷한 일이 가능하다. <code>validate</code>대신 <code>validationSchema</code> props를 사용하면 Yup과 같은 라이브러리를 통해 만들 수 있는 검증 스키마를 이용하여 입력값 검증을 할 수 있다.</p>\n<h2>5.2. react hook form</h2>\n<p>React에서는 폼의 사용자 입력창을 제어 컴포넌트로 만드는 것을 권장하고 있다. 사용자 입력창의 값을 컴포넌트에서 state로 가지고 있도록 하는 것이다. <code>value</code>와 <code>onChange</code> 핸들러를 전달함으로써 할 수 있다.</p>\n<p>하지만 HTML 만으로 폼 제출을 관리할 때를 생각해 보면 딱히 <code>&#x3C;input></code>의 값을 따로 관리하지는 않았다. 그냥 <code>&#x3C;form></code>태그가 알아서 <code>&#x3C;input></code>들의 name을 통해 데이터를 관리하다가 제출시에 알아서 데이터를 제출했다.</p>\n<p>HTML <code>&#x3C;form></code>컴포넌트의 접근 방식으로 폼을 관리하는 라이브러리가 바로 이 react hook form이다. 각 입력창은 비제어 컴포넌트이며 폼 내부에서 관리하다가 제출하게 되면 알아서 데이터를 갈무리해서 제출한다.</p>\n<p>다음과 같이 사용한다. <code>useForm</code>훅은 <code>defaultValues</code>만 넘기면 사용자 입력 컴포넌트에 넘길 <code>register</code>객체, 제출 콜백을 위한 <code>handleSubmit</code>함수 등을 리턴한다.</p>\n<pre><code class=\"language-tsx\">export default function App() {\n  const { register, handleSubmit, setValue } = useForm({\n    defaultValues: {\n      name:'',\n      email:'',\n      password:'',\n      // 다른 입력 필드들...\n    }\n  });\n  const onSubmit = data => {\n    // 제출 시 취할 동작\n    console.log(data)\n  };\n  \n  return (\n    &#x3C;form onSubmit={handleSubmit(onSubmit)}>\n      &#x3C;input {...register(\"name\")} />\n      &#x3C;input {...register(\"email\")} />\n      &#x3C;input {...register(\"password\")} />\n      {/* 다른 입력 필드들... */}\n      &#x3C;input type=\"submit\" />\n    &#x3C;/form>\n  );\n}\n</code></pre>\n<p>비제어 컴포넌트로 사용자 입력 컴포넌트들을 관리한다고 해서 값의 조회나 편집이 아예 안 되는 건 아니다. <code>useForm</code>훅에서 리턴하는 <code>watch</code>나 <code>getValues</code>(watch는 리렌더링을 하도록 하고 값의 편집에 반응한다는 점에서 차이가 있다. getValues는 호출 시점의 입력창 값을 정적으로 가져올 뿐이다)를 이용해서 값의 조회를 할 수 있고 <code>setValue</code>함수를 이용해서 값의 편집을 할 수 있다.</p>\n<p>HTML input의 validation과 같은 형식의 유효성 검사도 지원한다. <a href=\"https://www.react-hook-form.com/advanced-usage/#CustomHookwithResolver\">또한 앞서 언급한 Yup 등의 밸리데이션 스키마 라이브러리를 통한 검사도 할 수 있다.</a></p>\n<p>react hook form에 대해서 더 알아보고 싶다면 <a href=\"https://blog.logrocket.com/react-hook-form-complete-guide/\">logrocket의 가이드</a>나 <a href=\"https://www.react-hook-form.com/get-started\">공식 문서 튜토리얼</a>을 참고하자.</p>\n<h2>5.3. 비교</h2>\n<p>react hook form이 가지고 있는 장점이라면 성능이 있겠다. react hook form으로 폼 데이터를 관리하게 되면 사용자 입력 컴포넌트들을 비제어 컴포넌트로 관리하기 때문에 사용자 입력의 변화에 따른 렌더링을 덜 하게 되어서 퍼포먼스가 더 잘 나온다는 장점이 있다.</p>\n<p>폼 내부의 사용자 입력은 변화가 많이 일어나고 따라서 이를 React state로 관리할 시 렌더링이 매우 많이 일어나야 한다는 걸 생각하면 이는 꽤 큰 장점이 될 수 있다.</p>\n<p><a href=\"https://www.reason-to-code.com/blog/why-do-we-have-to-use-formik/\">Formik을 사용해야 하는 이유</a>라는 글에서는 <code>useEffect</code>를 이용해서 둘의 리렌더링 횟수를 비교하는데, react hook form이 더 적은 리렌더링을 한다는 것을 직접 확인할 수도 있다.</p>\n<p>또한 <a href=\"https://www.reason-to-code.com/blog/why-do-we-have-to-use-formik/\">react hook form은 dependency가 전혀 없다는 것도 장점이다. Formik은 8개의 dependency를 가지고 있다.</a></p>\n<p>반면 입력창들이 비제어 컴포넌트라서 입력창 데이터에 접근하여 어떤 조작을 가할 수 없다는 점은 단점이다. 그리고 Yup을 이용하거나 HTML의 내장 유효성 검사를 이용하지 않으면 커스텀 유효성 검사를 만들 수 없다는 점도 단점이다.</p>\n<p>반면 Formik은 제어 컴포넌트로 사용자 입력창을 관리하기 때문에 입력창 데이터에 접근하여 조작할 수 있다. 그리고 Yup이나 내장 유효성 검사 뿐 아니라 커스텀 유효성 검사를 쉽게 적용할 수 있다. 실제로 사용해 보면 Formik이 추상화 레벨도 더 높아서 라이브러리를 익혔다는 가정하에 좀더 쉽게쉽게 가져다 쓸 수 있다.</p>\n<p>다만 라이브러리에 내장된 유효성 검사가 따로 없으며 보일러플레이트 코드가 react hook form에 비해 많다는 단점이 있다. 8개나 되는 dependency도 단점이 될 수 있겠다.</p>\n<p>또 라이브러리의 기능과는 약간 관련이 없는 비교인데, react hook form이 좀더 관리가 잘 되고 있다는 느낌이 있다.</p>\n<p>둘의 github을 들어가 보면 느낄 수 있다. 2023년 8월 21일 현재 react hook form은 고작 6개의 이슈가 열려 있고 대부분이 버그 제보가 아니다. 36K가 넘는 별을 받은 라이브러리임을 생각해 볼 때 이는 굉장히 적은 수치다.</p>\n<p>반면 formik은 이슈가 666개 열려 있으며(6개와 666개...기분이 묘하다.) 버그 제보도 엄청나게 많고, 작년에 제보된 버그도 아직 열려 있는 이슈가 있다. 바로 지난주에도 커밋이 있었던 걸로 보아 그렇게까지 관리가 안 되고 있는 라이브러리는 아니지만 react hook form에 비해서는 관리가 잘 되고 있는 느낌은 아니다.</p>\n<h1>6. 정리</h1>\n<p>폼 데이터를 검증하고 관리하는 방법들을 소개했다. HTML의 내장 유효성 검사 기능을 이야기했고 좀 더 깊이 들어간 Constraint validation API를 소개했다. 그리고 이를 이용해서 폼 데이터를 검증하는 방법을 소개했다. 유효성 검사와 메시지를 적절히 커스텀하는 방법에 대해서도 소개했다.</p>\n<p>그 이후에는 복잡한 폼 데이터를 관리하는 방법을 이야기했다. 사용자 입력 컴포넌트의 구조, 정보의 관리와 유효성 검사에 대한 책임을 차례로 분산시켰고 유효성 검사도 함수들의 조합으로 만들 수 있도록 하는 방법을 소개했다.</p>\n<p>그리고 이를 추상화해서 재사용 가능하도록 만든 Formik과 react hook form을 소개했다. Formik은 제어 컴포넌트로 폼 데이터를 관리하는 것을 추구하고, react hook form은 비제어 컴포넌트로 폼 데이터를 관리하는 것을 추구한다.</p>\n<p>여기서 다룬 내용들이 누군가에게 전해져서 폼 데이터, 더 나아가서 복잡한 데이터를 관리하기 위한 인사이트와 무기를 얻는 데에 도움이 되었으면 좋겠다.</p>\n<h1>참고</h1>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation\">https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation</a></p>\n<p>constraint validation API <a href=\"https://web.dev/constraintvalidation/\">https://web.dev/constraintvalidation/</a></p>\n<p><a href=\"https://tech.osci.kr/introduce-react-hook-form/\">https://tech.osci.kr/introduce-react-hook-form/</a></p>\n<p>함수형으로 폼 데이터 우아하게 관리하기\n<a href=\"https://tech.devsisters.com/posts/functional-react-state-management/\">https://tech.devsisters.com/posts/functional-react-state-management/</a></p>\n<p><a href=\"https://inpa.tistory.com/entry/JS-%F0%9F%93%9A-FormData-%EC%A0%95%EB%A6%AC-fetch-api\">https://inpa.tistory.com/entry/JS-%F0%9F%93%9A-FormData-%EC%A0%95%EB%A6%AC-fetch-api</a></p>\n<p><a href=\"https://jeonghwan-kim.github.io/dev/2020/06/08/html5-form-validation.html\">https://jeonghwan-kim.github.io/dev/2020/06/08/html5-form-validation.html</a></p>\n<p>react에서 Constraint validation API 쓰기 <a href=\"https://omwri.medium.com/react-constraints-api-better-validations-d9adba6f6e63\">https://omwri.medium.com/react-constraints-api-better-validations-d9adba6f6e63</a></p>\n<p>커스텀 훅으로 폼 유효성 검사 관리하기 <a href=\"https://upmostly.com/tutorials/form-validation-using-custom-react-hooks\">https://upmostly.com/tutorials/form-validation-using-custom-react-hooks</a></p>\n<p>제네릭 useForm 훅 <a href=\"https://stackoverflow.com/questions/71358061/generic-useform-hook\">https://stackoverflow.com/questions/71358061/generic-useform-hook</a></p>\n<p>react hook form vs formik <a href=\"https://www.reason-to-code.com/blog/why-do-we-have-to-use-formik/\">https://www.reason-to-code.com/blog/why-do-we-have-to-use-formik/</a></p>\n<p>react로 form 다루기. 많은 참고가 되었다. <a href=\"https://jeonghwan-kim.github.io/dev/2022/03/29/react-form-and-formik.html\">https://jeonghwan-kim.github.io/dev/2022/03/29/react-form-and-formik.html</a></p>\n<p>react hook form guide <a href=\"https://blog.logrocket.com/react-hook-form-complete-guide/\">https://blog.logrocket.com/react-hook-form-complete-guide/</a></p>\n<p>React Forms - Formik vs. Hook-Form vs. Final-Form <a href=\"https://blog.appseed.us/react-forms-formik-vs-hookform-vs-finalform/\">https://blog.appseed.us/react-forms-formik-vs-hookform-vs-finalform/</a></p>",
    "excerpt": "0. 시작\n사용자가 작성한 값을 관리하다가 서버로 제출하는 페이지는 매우 흔하게 쓰인다.\n그리고 이런 사용자의 입력값을 클라이언트에서 검증하는 일도 많다. 비밀번호는 8자 이상에 특수문자를 하나 이상 입력해 주세요와 같이 입력한 내용의 형식을 지적하는 메시지를 누구나 한 번쯤 본 적이 있다.\n이렇게 클라이언트에서 사용자의 입력을 받고 검증하고 제출하는 페이지를 만들면서 생각해 볼 만한 건 두 가지가 있다. 첫째는 사용자의 입력값을 어떻게 검증할 것인가에 대한 것",
    "headingTree": [
      {
        "title": "0. 시작",
        "url": "#0-시작",
        "items": []
      },
      {
        "title": "1. 클라이언트 데이터 검증이란",
        "url": "#1-클라이언트-데이터-검증이란",
        "items": [
          {
            "title": "1.1. 개요",
            "url": "#11-개요",
            "items": []
          },
          {
            "title": "1.2. 보안 관련",
            "url": "#12-보안-관련",
            "items": []
          }
        ]
      },
      {
        "title": "2. HTML을 이용",
        "url": "#2-html을-이용",
        "items": [
          {
            "title": "2.1. 로그인 폼 기본구조",
            "url": "#21-로그인-폼-기본구조",
            "items": []
          },
          {
            "title": "2.2. 기본적인 유효성 검사",
            "url": "#22-기본적인-유효성-검사",
            "items": []
          }
        ]
      },
      {
        "title": "3. Constraint Validation API",
        "url": "#3-constraint-validation-api",
        "items": [
          {
            "title": "3.1. API 소개",
            "url": "#31-api-소개",
            "items": []
          },
          {
            "title": "3.2. 유효성 검사 메시지 내용 바꾸기",
            "url": "#32-유효성-검사-메시지-내용-바꾸기",
            "items": []
          },
          {
            "title": "3.3. API 속성들",
            "url": "#33-api-속성들",
            "items": []
          },
          {
            "title": "3.4. 메시지 커스텀 고급",
            "url": "#34-메시지-커스텀-고급",
            "items": []
          },
          {
            "title": "3.5. 이렇게 하는 이유",
            "url": "#35-이렇게-하는-이유",
            "items": []
          }
        ]
      },
      {
        "title": "4. 정보를 깔끔하게 관리하기",
        "url": "#4-정보를-깔끔하게-관리하기",
        "items": [
          {
            "title": "4.1. 정보 관리의 동기",
            "url": "#41-정보-관리의-동기",
            "items": []
          },
          {
            "title": "4.1. 컴포넌트 만들기",
            "url": "#41-컴포넌트-만들기",
            "items": []
          },
          {
            "title": "4.2. 훅으로 만들기",
            "url": "#42-훅으로-만들기",
            "items": []
          },
          {
            "title": "4.3. 유효성 검사 함수 개선",
            "url": "#43-유효성-검사-함수-개선",
            "items": []
          },
          {
            "title": "4.4. 추가적인 개선?",
            "url": "#44-추가적인-개선",
            "items": []
          }
        ]
      },
      {
        "title": "5. 폼 라이브러리",
        "url": "#5-폼-라이브러리",
        "items": [
          {
            "title": "5.1. Formik",
            "url": "#51-formik",
            "items": [
              {
                "title": "5.1.1. 모티베이션",
                "url": "#511-모티베이션",
                "items": []
              },
              {
                "title": "5.1.2. Formik 사용법",
                "url": "#512-formik-사용법",
                "items": []
              }
            ]
          },
          {
            "title": "5.2. react hook form",
            "url": "#52-react-hook-form",
            "items": []
          },
          {
            "title": "5.3. 비교",
            "url": "#53-비교",
            "items": []
          }
        ]
      },
      {
        "title": "6. 정리",
        "url": "#6-정리",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 6,
      "wordCount": 1604
    },
    "url": "/posts/form-client-validation",
    "thumbnail": {
      "local": "/static/login-with-html-ab65538b.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-login-with-html-ab65538b-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAADCAIAAAAhqtkfAAAACXBIWXMAAAsTAAALEwEAmpwYAAAATElEQVR4nGMI9fcWFRbesn795y9fnjx58h8Mvn37xpCWlpaUnJKSmpaTk7N+/fpv375B5BiOnzixb//+pcuW79y56+nTZxDR////AwAxWjWvGSRa0gAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "chrome-capture",
    "title": "크롬 페이지 전체 캡처하기",
    "date": "2022-11-19T00:00:00Z",
    "description": "크롬에서 페이지를 싹 다 캡처하는 법",
    "tags": [
      "tip"
    ],
    "html": "<h1>크롬 페이지 전체 캡처하기</h1>\n<p>발표 자료를 만들다가 페이지 전체를 캡처해야 할 일이 생겼다. 하지만 맥의 모니터에는 페이지 모두가 들어오지는 않는다. 예를 들어서 네이버 페이지 전체를 캡처해야 한다면? 일단 맥에서 기본 제공하는 <code>shift+command+3</code>을 눌러서 전체화면 캡처를 해본다. 하지만 이렇게 하면 네이버 페이지 전체가 아니라 맥의 전체 화면이 캡처된다.</p>\n<p><img src=\"/static/naver-a1b51a19.png\" alt=\"naver\"></p>\n<p><code>shift+command+4</code>를 이용해서 마우스로 드래그하면 상단 바 등을 제외하고 내가 선택한 부분을 캡처할 수도 있다. 스페이스바를 같이 누르면 특정 창을 캡처하기도 가능하다. 하지만 역시 내가 원하는, 페이지 전체 캡처는 안된다..</p>\n<p>오픈채팅방에서 조언을 구하니 신뢰의 애니프사를 한 사람이 답을 가르쳐 주었다.</p>\n<p><img src=\"/static/kakao_talk-a9b73d61.jpeg\" alt=\"kakao\"></p>\n<p><code>command + option + i</code>로 개발자 도구를 열고, <code>command + shift + p</code>로 command palette를 열어서 <code>capture full size screenshot</code>을 검색하면 된다.</p>\n<p><img src=\"/static/capture-10ec0a37.png\" alt=\"capture\"></p>\n<p>이렇게 하면 페이지 전체가 캡처된다.</p>\n<p>다운로드된 사진 파일을 보면 네이버 페이지가 정상적으로 전체 캡처된 것을 볼 수 있다.</p>\n<p><img src=\"/static/www.naver.com_-288c71ac.png\" alt=\"naver_full\"></p>",
    "excerpt": "크롬 페이지 전체 캡처하기\n발표 자료를 만들다가 페이지 전체를 캡처해야 할 일이 생겼다. 하지만 맥의 모니터에는 페이지 모두가 들어오지는 않는다. 예를 들어서 네이버 페이지 전체를 캡처해야 한다면? 일단 맥에서 기본 제공하는 shift+command+3을 눌러서 전체화면 캡처를 해본다. 하지만 이렇게 하면 네이버 페이지 전체가 아니라 맥의 전체 화면이 캡처된다.\n\nshift+command+4를 이용해서 마우스로 드래그하면 상단 바 등을 제외하고 내가 선택한 부분",
    "headingTree": [
      {
        "title": "크롬 페이지 전체 캡처하기",
        "url": "#크롬-페이지-전체-캡처하기",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 16
    },
    "url": "/posts/chrome-capture",
    "thumbnail": {
      "local": "/static/naver-a1b51a19.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-naver-a1b51a19-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAFCAIAAAD38zoCAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAiElEQVR4nAF9AIL/AGRqaVliYpCTkn2EhnOGg3CHg2hucnZ/gQDc3d2vw7vFzcvAwMXAz83G1czc29vl5OUAwL7MAA89Ex1LAAAyDyhVvMLK8Pf2+Pr6AOzu86+xwLKtr+Hg5OTi5oqMmHx9iuvs8AC519yisK8oJSOYpqOttrR7g4BrdXW5yse0mkrDM/kejgAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "front-bug-1",
    "title": "프로젝트 트러블 슈팅 - 사용자 프로필의 업데이트",
    "date": "2022-08-13T00:00:00Z",
    "description": "React에서 서버와 통신하면서 발생한 문제",
    "tags": [
      "web",
      "front",
      "react"
    ],
    "html": "<h1>1. 문제의 발생</h1>\n<p>현재 밴드 운영을 도울 수 있는 웹사이트를 제작하는 프로젝트를 진행하고 있다. 나는 프론트를 맡아서 제작하고 있다. 이때 프로젝트에서 다루는 사용자 프로필에서 활동 지역과 선호하는 음악 장르, 주로 활동하는 요일 등 밴드 활동을 하는 사람이라면 으레 가지고 있을 정보들을 적는 영역이 있다. 이 영역에 대한 정보도 당연히 사용자와 연관되어서 서버에 저장되어 있다. 이때 이 정보들을 수정하는 api를 구현하면서 문제가 발생했다.</p>\n<p>즉 특정 후보군 중 몇몇을 골라서 표시하는 필드일 때 사용자가 이 내용을 편집하고 서버에 저장할 수 있게 하는 기능을 구현하고 있었다. 이 글에서는 프로젝트에서 내가 맞닥뜨렸던 상황과 문제들을 구체적으로 서술하면서 일반적인 상황에 대한 해법을 찾은 과정을 정리해 둔다.</p>\n<h1>2. 프로젝트의 상황</h1>\n<p>밴드에 관련된 서비스이기 때문에 일반적으로 이 서비스의 사용자는 여러 음악 장르들 중 몇 개를 좋아할 것이다. 따라서 좋아하는 장르를 설정하고 보여줄 수 있는 필드를 만들었다. 그런데 이를 업데이트하고 싶은 상황이 있을 수 있다. 좋아하는 음악 장르가 바뀌는 건 많이 있는 일이다.</p>\n<p><img src=\"/static/editfield-11b41a82.png\" alt=\"editfield\"></p>\n<p>그래서 위와 같은 선호 장르를 편집하는 필드에서 K-POP 을 삭제하고 J-POP을 새로운 선호 장르로 추가하고 싶다고 하자. 그러면 유저는 화면에서 K-POP을 삭제한 후 J-POP을 추가하여 저장할 것이다.</p>\n<p>이 수정 내역의 저장이 일어날 때 서버에 가야 하는 요청은 2개이다.(유저가 편집 필드에서 수정하는 대로 서버에 반영되는 게 아니라, \"수정 완료\" 버튼을 누르면 한번에 수정이 완료되고 서버에 한꺼번에 반영된다)</p>\n<ol>\n<li>선호 장르에서 K-POP을 삭제한다.</li>\n<li>선호 장르에 J-POP을 추가한다.</li>\n</ol>\n<h1>3. 가장 단순한 해법 - 전부 따로 저장해 놓기</h1>\n<p>가장 단순한 해법을 생각했을 땐 삭제된 장르와 추가된 장르를 따로 저장해 놓은 후 서버에 저장되는 시점에 그 2개의 요청을 보내는 것을 생각할 수 있다.</p>\n<p>그러면 선호 장르를 관리하는 컴포넌트에서 deletedGenres, addedGenres 를 state로 만들어 둔 후 하위 컴포넌트에 props로 전달하게 된다. 선호 장르를 관리하는 컴포넌트가 <code>GenreField</code> 컴포넌트라면 그 컴포넌트에서 각 장르 아이템을 렌더링하는 <code>GenreItem</code>과 같은 컴포넌트와 장르 추가를 담당하는 <code>GenreAddButton</code>과 같은 컴포넌트가 있을 것이다.</p>\n<p>이 모든 컴포넌트들이 장르의 업데이트를 위해 deletedGenres, addedGenres를 props로 전달받아야 한다. 또한 서술한 하위 컴포넌트들은 선호 장르의 업데이트 또한 담당한다. 그러면 그 컴포넌트들은 deletedGenres, addedGenres를 업데이트하는 setDeletedGenres, setAddedGenres 함수까지 props로 받게 된다. 장르 업데이트 하나를 위해 props를 4개나 늘리고 또한 하위 컴포넌트로 drilling시키는 건 그렇게 좋은 전략이 아니라고 보인다.</p>\n<h1>4. 좀 더 생각한 해법 - 서버의 상태와 비교해 업데이트하기</h1>\n<p>결국 우리가 하고자 하는 것은 다음과 같다.</p>\n<pre><code>사용자의 선호 장르가 편집된 내용을 편집 완료 시점에 서버로 보내 저장한다.\n</code></pre>\n<p>그럼 편집된 내용은 무엇에 비해서 편집된 것인가? 당연히 기존에 서버에 저장되어 있던 사용자의 선호 장르다. 따라서 기존에 서버에 저장되어 있던 선호 장르와 사용자가 편집한 내용을 비교해서 서로 다른 부분에 대해서만 편집 완료 시점에 서버에 보내는 방식을 생각할 수 있다. 선호 장르를 서버에 추가하고, 삭제하는 API는 이미 있다. 또한 편집 필드의 경우 <code>사용자가 편집 중인 값</code>은 어차피 가지고 있어야 한다. 따라서 서버에 기존에 저장되어 있는 선호 장르를 저장하는 state만 가지고 있으면 된다.</p>\n<p>그 둘을 가지고 있다고 할 때, 편집 완료 시점(즉 수정 완료 버튼을 눌렀을 때)에 서버에 보내야 하는 요청은 다음과 같다.</p>\n<ol>\n<li>서버에 저장되어 있던 내용 중 사용자가 편집한 내용에 없는 부분을 서버에서 삭제한다.</li>\n<li>현재까지 사용자가 편집한 내용 중 서버에 없는 내용이 있으면 서버에 그 부분을 추가한다.</li>\n</ol>\n<p>이를 프로젝트에서 함수로 나타낸 결과는 다음과 같았다. 이때 <code>deleteUserGenre</code> 함수와 <code>addUserGenre</code> 함수는 axios로 서버와 통신한다.</p>\n<pre><code class=\"language-jsx\">function updateUserGenres(curUserGenres, serverUserGenres) {\n  for (const genre of serverUserGenres) {\n    // 기존에는 있었지만 사용자가 삭제한 장르를 서버에서도 삭제한다\n    if (curUserGenres.find((g) => g.id === genre.id) === undefined) {\n      UserProfileAPI.deleteUserGenre(genre.id);\n    }\n  }\n\n  for (const genre of curUserGenres) {\n    // 기존에는 서버에 없었지만 사용자가 추가한 장르를 서버에 추가한다\n    if (serverUserGenres.find((g) => g.id === genre.id) === undefined) {\n      UserProfileAPI.addUserGenre(genre.id);\n    }\n  }\n}\n</code></pre>\n<h1>5. 다 지운 후 새로 넣기 - race condition 발생과 해결</h1>\n<p>하지만 위와 같이 코드를 짤 경우 하나를 추가/삭제할 때마다 기존 요소들 중 그것이 존재하는지에 대해 모두 검색해야 하는 단점이 있다. 시간복잡도가 O(n^2)가 되는 것이다. 음악 장르의 개수가 몇만 개 급으로 많지 않을 것이고 사용자의 프로필 편집이 아주 자주 일어나는 연산이 아니기 때문에 큰 속도 지연은 없겠지만 비효율적인 코드이다.</p>\n<p>따라서 기존에 서버에 저장되어 있던 선호 장르를 다 지운 후 새로 넣는 방식을 사용하도록 해보았다. 이러면 시간복잡도가 O(n)이 된다. 해야 할 일은 다음과 같다.</p>\n<ol>\n<li>서버에 저장되어 있던 선호 장르를 다 지운다.</li>\n<li>사용자가 편집한 선호 장르의 내용 전체를 서버에 추가한다.</li>\n</ol>\n<p>이때 서버에 저장된 선호 장르를 다 지우는 것을 먼저 해야 한다. 만약 사용자가 편집한 선호 장르의 내용을 추가하는 것을 먼저 한 후 서버에 저장되어 있던 선호 장르를 지우는 경우, 사용자가 편집하지 않았기에 그대로 남아 있어야 하는 선호 장르도 지워져 버리기 때문이다. 따라서 await을 사용해서 순서를 강제해 주었다.</p>\n<pre><code class=\"language-jsx\">async function updateUserGenres(curUserGenres, serverUserGenres) {\n  // 사용자의 선호 장르를 서버와 동기화\n  const UserGenreDeletePromises = serverUserGenres.map((genre) => {\n    return UserProfileAPI.deleteUserGenres(genre.id);\n  });\n\n  const UserGenreAddPromises = curUserGenres.map((genre) => {\n    return UserProfileAPI.addUserGenres(genre.id);\n  });\n\n  await Promise.all(UserGenreDeletePromises);\n  await Promise.all(CurUserGenreAddPromises);\n}\n</code></pre>\n<p>이 코드를 짤 때는 서버에 저장되어 있는 선호 장르를 모두 지우는 동작에 대한 Promise들을 먼저 시행한 후 사용자의 편집 내역에 있는 선호 장르를 추가하는 동작에 대한 Promise를 실행하면 될 것이라 생각했다. 하지만 이렇게 할 경우 생각대로 동작하지 않았다. 자꾸 아무 편집도 하지 않은 내용이 지워지는 일이 발생했다.</p>\n<p>이는 내가 await을 사용해서 순서를 강제했다고 생각한 부분이 생각대로 동작하지 않았기 때문이다. 내가 짠 코드의 <code>UserProfileAPI.deleteUserGenres</code>와 <code>UserProfileAPI.addUserGenres</code>는 다음과 같이 구성되어 있었다.</p>\n<pre><code class=\"language-jsx\">addUserGenre: (genreID) => {\n  return request.post(`/api/users/${userID}/genres/${genreID}`, genreID);\n},\ndeleteUserGenre: (genreID) => {\n  return request.delete(`/api/users/${userID}/genres/${genreID}`);\n},\n</code></pre>\n<p>위에서 작성한 <code>updateUserGenres</code>함수의 코드에서 <code>UserGenreDeletePromises</code>와 <code>UserGenreAddPromises</code> 배열을 만들고 있는 시점에 <code>addUserGenre</code>와 <code>deleteUserGenre</code>함수의 리턴 Promise가 생성되면서 이미 axios의 요청이 서버로 전송되었던 것이다. 이때 이 axios 요청의 Promise들은 비동기로 처리된다. 따라서 서버에 저장된 선호 장르를 지우는 동작과 사용자의 편집 내역의 선호 장르를 서버에 추가하는 동작의 순서가 꼬이는 race condition이 발생할 수 있다.</p>\n<p>이 상황은 다음과 같이 코드를 작성하여 axios 요청 순서를 강제하는 방식으로 해결했다.</p>\n<pre><code class=\"language-jsx\">async function updateUserGenres(curUserGenres, serverUserGenres) {\n  try {\n    await Promise.all(\n      serverUserGenres.map((genre) => {\n        return UserProfileAPI.deleteUserGenre(genre.id);\n      })\n    );\n    await Promise.all(\n      curUserGenres.map((genre) => {\n        return UserProfileAPI.addUserGenre(genre.id);\n      })\n    );\n  } catch (err) {\n    console.log(err);\n  }\n}\n</code></pre>\n<p>위와 같이 코드를 짜면</p>\n<pre><code class=\"language-jsx\">serverUserGenres.map((genre) => {\n  return UserProfileAPI.deleteUserGenre(genre.id);\n});\n</code></pre>\n<p>이 api 요청들은 Promise.all로 인해서 하나의 Promise로 묶인다. 즉 deleteUserGenre 함수에서 일어나는 사용자의 기존 선호 장르 삭제 요청들이 하나로 묶여서 비동기적으로 실행되게 된다. 그리고 그 하나로 묶인 Promise가 resolve될 때까지 기다린 다음에 다른 코드를 실행하도록 하여 순서를 강제하는 역할을 await이 맡는다.</p>\n<p>사용자의 선호 장르를 삭제하는 요청이 모두 해결되고 난 다음 사용자의 선호 장르를 추가하는 요청을 보내야 한다. 이 순서를 강제하는 부분은 await이 맡는다. 사용자의 선호 장르를 삭제하는 요청들(Promise.all로 묶여 있다)이 모두 resolve 되고 난 후에야 다음 코드로 실행한다.</p>\n<p>그런데 선호 장르를 삭제하는 요청 각각, 그리고 사용자의 선호 장르를 추가하는 요청 각각은 순서대로 실행될 필요가 없다. 그럴 경우 실행 결과는 똑같은데 실행 시간만 길어지게 된다. 따라서 그 각각의 요청들은 Promise.all로 묶어서 각각의 요청들이 비동기로 실행되게 하였다.</p>\n<h1>6. 개선의 여지</h1>\n<p>하지만 이는 선호 장르를 추가, 삭제하는 api가 선호 장르 하나씩 추가, 삭제하는 것만 존재했기 때문에 했던 일이다. 사실 서버로는 사용자가 편집한 선호 장르 내역을 list로 한번에 보낸 후 서버에서 알아서 추가/삭제를 하도록 하는 게 좋다. 요청을 이렇게 여러 개 묶어서 보내게 되면 문제가 발생하기 너무 쉽고 서버 리퀘스트도 많아져서 좋지 않다.</p>",
    "excerpt": "1. 문제의 발생\n현재 밴드 운영을 도울 수 있는 웹사이트를 제작하는 프로젝트를 진행하고 있다. 나는 프론트를 맡아서 제작하고 있다. 이때 프로젝트에서 다루는 사용자 프로필에서 활동 지역과 선호하는 음악 장르, 주로 활동하는 요일 등 밴드 활동을 하는 사람이라면 으레 가지고 있을 정보들을 적는 영역이 있다. 이 영역에 대한 정보도 당연히 사용자와 연관되어서 서버에 저장되어 있다. 이때 이 정보들을 수정하는 api를 구현하면서 문제가 발생했다.\n즉 특정 후보군 중",
    "headingTree": [
      {
        "title": "1. 문제의 발생",
        "url": "#1-문제의-발생",
        "items": []
      },
      {
        "title": "2. 프로젝트의 상황",
        "url": "#2-프로젝트의-상황",
        "items": []
      },
      {
        "title": "3. 가장 단순한 해법 - 전부 따로 저장해 놓기",
        "url": "#3-가장-단순한-해법---전부-따로-저장해-놓기",
        "items": []
      },
      {
        "title": "4. 좀 더 생각한 해법 - 서버의 상태와 비교해 업데이트하기",
        "url": "#4-좀-더-생각한-해법---서버의-상태와-비교해-업데이트하기",
        "items": []
      },
      {
        "title": "5. 다 지운 후 새로 넣기 - race condition 발생과 해결",
        "url": "#5-다-지운-후-새로-넣기---race-condition-발생과-해결",
        "items": []
      },
      {
        "title": "6. 개선의 여지",
        "url": "#6-개선의-여지",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 212
    },
    "url": "/posts/front-bug-1",
    "thumbnail": {
      "local": "/static/editfield-11b41a82.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-editfield-11b41a82-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAACCAIAAADq9gq6AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAMklEQVR4nGPYCQaTJk1as2bNx48f////3zV1AoMYO8MaMJg0adL8+fMhEt3TJnEqigMALAAfDBu4QM4AAAAASUVORK5CYII="
    }
  },
  {
    "slug": "front-bug-2",
    "title": "프로젝트 트러블 슈팅 - 회원가입 폼의 제출 시점",
    "date": "2022-08-14T00:00:00Z",
    "description": "form의 default 제출 버튼 설정으로 인한 문제",
    "tags": [
      "web",
      "study",
      "front",
      "HTML",
      "react"
    ],
    "html": "<h1>1. 문제의 발생</h1>\n<p>react로 회원가입 폼을 제작하는 중에 발생한 문제이다. 많은 회원가입 폼 내부에는 2개 이상의 버튼이 있다. 하나는 회원가입 폼을 모두 작성한 후 누르는 회원가입 완료 버튼이다. 이 버튼을 누를 시 사용자가 입력한 회원가입 정보들에 대한 유효성 검사를 한 후 회원가입 정보를 서버로 전송해 줘야 한다.</p>\n<p>그리고 회원가입 폼에는 일반적으로 사용자가 사용하겠다고 입력한 아이디나 이메일이 기존 회원들의 것과 중복되지 않는지 확인해 주는 중복확인 버튼이 있다. 이외에도 약관 동의 버튼, 닉네임 중복확인 버튼 등 더 많은 버튼이 존재할 수 있다. 그러나 지금 하고 있는 작은 프로젝트에서는 이메일의 중복 확인, 그리고 회원가입 완료까지 2개의 버튼이 회원가입 폼에 존재했다.</p>\n<p>그런데 아이디 중복 확인 버튼을 누르자 회원가입 폼이 제출되어 버리는 일이 발생했다. 또한 다른 칸에서 엔터를 눌러도 아이디 중복 확인 동작이 실행되고 폼이 제출되어 버렸다.</p>\n<h1>2. 구조 설명</h1>\n<p>실제 프로젝트 코드에서는 더 많은 정보를 입력받긴 했지만 프로젝트에서 사용한 회원가입 폼을 단순화시켜 보면 다음과 같은 구조였다.</p>\n<pre><code class=\"language-jsx\">function SignUpForm() {\n  return (\n    &#x3C;form\n      className=\"signup-form\"\n      onSubmit={(e) => {\n        e.preventDefault();\n        alert(\"폼 제출됨\");\n      }}\n    >\n      &#x3C;h1>회원가입&#x3C;/h1>\n      &#x3C;label className=\"signup-field\" htmlFor=\"email-form\">\n        &#x3C;div style={{ width: \"100px\" }}>이메일 :&#x3C;/div>\n        &#x3C;input name=\"email\" />\n        &#x3C;button\n          onClick={() => {\n            alert(\"이메일 중복 확인 버튼 클릭\");\n          }}\n        >\n          중복확인\n        &#x3C;/button>\n      &#x3C;/label>\n      &#x3C;label className=\"signup-field\" htmlFor=\"password-form\">\n        &#x3C;div style={{ width: \"100px\" }}>비밀번호 :&#x3C;/div>\n        &#x3C;input name=\"password\" />\n      &#x3C;/label>\n      &#x3C;label className=\"signup-field\" htmlFor=\"password-confirm-form\">\n        &#x3C;div style={{ width: \"100px\" }}>비밀번호 확인 :&#x3C;/div>\n        &#x3C;input name=\"password-confirm\" />\n      &#x3C;/label>\n      &#x3C;button\n        style={{ width: \"100px\" }}\n        type=\"submit\"\n        onClick={() => {\n          alert(\"회원가입 버튼 클릭\");\n        }}\n      >\n        회원가입\n      &#x3C;/button>\n    &#x3C;/form>\n  );\n}\n</code></pre>\n<p>이 결과물은 react에서 다음과 같은 회원가입 폼을 만들어낸다. 실제로 위의 컴포넌트를 작성해 보면 따로 Css 때문에 간격 등이 약간 다르게 보일 수는 있지만 내용물은 모두 같을 것이다.</p>\n<p><img src=\"/static/signup-form-fd2560b4.png\" alt=\"signup\"></p>\n<h1>3. 문제의 원인</h1>\n<p>로그를 찍어 보니 문제는 아이디 중복 확인 버튼이 회원가입 폼의 제출 버튼처럼 취급된다는 것이었다. 하지만 위의 코드에서 아이디 중복 확인 버튼의 type은 딱히 지정되어 있지 않았다...</p>\n<p>찾아보니 HTML5부터는 form 태그의 기본 제출 버튼이 form의 DOM tree를 preorder로 순회했을 때 나오는 첫 submittable element(버튼 등등)으로 지정된다고 한다. 따라서 DOM 트리에서 가장 먼저 나오는 버튼인 아이디 중복 확인 버튼이 회원가입 폼 제출 버튼처럼 취급된 것이다.</p>\n<h1>4. 문제의 해결</h1>\n<p>아이디 중복 확인의 type이 명시적으로 지정되어 있으면 이 문제는 발생하지 않는다. 위의 코드에서는 아이디 중복 확인 버튼의 type이 딱히 없었기 때문에 중복확인 버튼이 자동으로 폼의 제출 버튼으로 취급되었다. 따라서 중복확인 버튼에 <code>type=\"button\"</code> 속성을 추가해 주면 된다. 물론 인위적으로 특정 버튼이 DOM 트리의 최상위로 오도록 조정할 수도 있다.</p>\n<pre><code class=\"language-jsx\">&#x3C;button\n  type=\"button\"\n  onClick={() => {\n    alert(\"이메일 중복 확인 버튼 클릭\");\n  }}\n>\n  중복확인\n&#x3C;/button>\n</code></pre>\n<h1>참고</h1>\n<p>스택오버플로우 질문답변 <a href=\"https://stackoverflow.com/questions/925334/how-is-the-default-submit-button-on-an-html-form-determined\">https://stackoverflow.com/questions/925334/how-is-the-default-submit-button-on-an-html-form-determined</a></p>\n<p>HTML 공식 문서의 해당 부분 <a href=\"https://html.spec.whatwg.org/multipage/forms.html#category-submit\">https://html.spec.whatwg.org/multipage/forms.html#category-submit</a></p>",
    "excerpt": "1. 문제의 발생\nreact로 회원가입 폼을 제작하는 중에 발생한 문제이다. 많은 회원가입 폼 내부에는 2개 이상의 버튼이 있다. 하나는 회원가입 폼을 모두 작성한 후 누르는 회원가입 완료 버튼이다. 이 버튼을 누를 시 사용자가 입력한 회원가입 정보들에 대한 유효성 검사를 한 후 회원가입 정보를 서버로 전송해 줘야 한다.\n그리고 회원가입 폼에는 일반적으로 사용자가 사용하겠다고 입력한 아이디나 이메일이 기존 회원들의 것과 중복되지 않는지 확인해 주는 중복확인 버튼",
    "headingTree": [
      {
        "title": "1. 문제의 발생",
        "url": "#1-문제의-발생",
        "items": []
      },
      {
        "title": "2. 구조 설명",
        "url": "#2-구조-설명",
        "items": []
      },
      {
        "title": "3. 문제의 원인",
        "url": "#3-문제의-원인",
        "items": []
      },
      {
        "title": "4. 문제의 해결",
        "url": "#4-문제의-해결",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 128
    },
    "url": "/posts/front-bug-2",
    "thumbnail": {
      "local": "/static/signup-form-fd2560b4.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-signup-form-fd2560b4-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAdUlEQVR4nF3NoREEIQyFYRqIoo9UgsHTBAVg6GZXoVJAFAqFikLhoqJQd3M7Z+4++8+85xARAEIIr1/Oew8AiGhm5xwzY+a9t6u1iggz3/e11uq9xxiJyKWUSin0mHOOMczsM5VzRkQiUtX9+AYRaa2p6t/5GyOMaUuebvCUAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "front-bug-3",
    "title": "프로젝트 트러블 슈팅 - react-router-dom child route 만들기",
    "date": "2022-08-19T00:00:00Z",
    "description": "React Router에서 nested route를 다루는 문제",
    "tags": [
      "web",
      "study",
      "front",
      "HTML",
      "react"
    ],
    "html": "<h1>1. 문제의 발생</h1>\n<p>진행하고 있는 프로젝트에서는 SPA인 리액트로 여러 페이지를 구성하기 위해 <code>react-router-dom</code>을 사용한다. 이때 비슷한 url을 가지는 여러 개의 라우트를 사용해야 하는 경우가 있다. 예를 들어서 계정에 관련된 라우트는 account로 시작하고 어떤 목적으로 쓰이는 페이지인지에 따라서 다른 URL을 가지게 할 것이다.</p>\n<p>즉 다음과 같은 라우트들이 있는 건 자연스럽다. 로그인 라우트, 가입한 이메일을 찾는 기능을 하는 라우트, 비밀번호를 찾는 라우트가 있다.</p>\n<pre><code class=\"language-jsx\">&#x3C;Routes>\n  &#x3C;Route path=\"account/login\" element={&#x3C;LoginPage />} />\n  &#x3C;Route path=\"account/find/email\" element={&#x3C;FindEmailPage />} />\n  &#x3C;Route path=\"account/find/password\" element={&#x3C;FindPasswordPage />} />\n&#x3C;/Routes>\n</code></pre>\n<p>그러나 분명 공통된 부분이 있는데 이 부분을 전혀 살리지 못하고 있다. 따라서 이렇게 다양한 라우트들을 묶는 방법을 정리한다.</p>\n<h1>2. 문제 해결의 시작 - Nested Route</h1>\n<p>먼저 예시를 위해 다음과 같은 <code>App.tsx</code> 코드를 작성하였다.</p>\n<pre><code class=\"language-jsx\">// BrowserRouter는 index.tsx에서 처리해 주었다\nimport { Routes, Route } from \"react-router-dom\";\n\nfunction MainPage() {\n  return &#x3C;div>메인 페이지&#x3C;/div>;\n}\n\nfunction LoginPage() {\n  return &#x3C;h1>로그인 페이지&#x3C;/h1>;\n}\n\nfunction FindEmailPage() {\n  return &#x3C;h1>이메일 찾기 페이지&#x3C;/h1>;\n}\n\nfunction FindPasswordPage() {\n  return &#x3C;h1>비밀번호 찾기 페이지&#x3C;/h1>;\n}\n\nfunction App() {\n  return (\n    &#x3C;Routes>\n      &#x3C;Route path=\"/\" element={&#x3C;MainPage />} />\n      &#x3C;Route path=\"account/login\" element={&#x3C;LoginPage />} />\n      &#x3C;Route path=\"account/find/email\" element={&#x3C;FindEmailPage />} />\n      &#x3C;Route path=\"account/find/password\" element={&#x3C;FindPasswordPage />} />\n    &#x3C;/Routes>\n  );\n}\n\nexport default App;\n</code></pre>\n<p>이렇게 하면 <code>/account</code>를 공통으로 갖는 라우트가 메인 페이지로부터 3개 생긴다. 이를 묶는 가장 간편한 방법은 공통되는 부분을 Route로 만들어 준 후 다음 URL을 그 Route 컴포넌트로 감싸는 것이다. 위 코드에서 <code>App</code>컴포넌트를 다음과 같이 바꾸는 것이다.</p>\n<pre><code class=\"language-jsx\">function App() {\n  return (\n    &#x3C;Routes>\n      &#x3C;Route path=\"/\" element={&#x3C;MainPage />} />\n      &#x3C;Route path=\"account\">\n        &#x3C;Route path=\"login\" element={&#x3C;LoginPage />} />\n        &#x3C;Route path=\"find/email\" element={&#x3C;FindEmailPage />} />\n        &#x3C;Route path=\"find/password\" element={&#x3C;FindPasswordPage />} />\n      &#x3C;/Route>\n    &#x3C;/Routes>\n  );\n}\n</code></pre>\n<p>좀 더 공통 부분을 묶고자 한다면 <code>find/</code> URL도 묶어서 다음과 같이 작성할 수도 있을 것이다.</p>\n<pre><code class=\"language-jsx\">function App() {\n  return (\n    &#x3C;Routes>\n      &#x3C;Route path=\"/\" element={&#x3C;MainPage />} />\n      &#x3C;Route path=\"account\">\n        &#x3C;Route path=\"login\" element={&#x3C;LoginPage />} />\n        &#x3C;Route path=\"find\">\n          &#x3C;Route path=\"email\" element={&#x3C;FindEmailPage />} />\n          &#x3C;Route path=\"password\" element={&#x3C;FindPasswordPage />} />\n        &#x3C;/Route>\n      &#x3C;/Route>\n    &#x3C;/Routes>\n  );\n}\n</code></pre>\n<h2>2-1. 가능한 이유</h2>\n<p>이게 가능한 이유는 Route 컴포넌트의 default element가 <code>&#x3C;Outlet /></code>이기 때문이다. 이 Outlet 컴포넌트는 route의 nesting이 일어날 때 자식 Route 컴포넌트를 어디에 보여줄지를 결정할 수 있도록 해준다.</p>\n<p>만약 위에서 URL prefix가 <code>account</code>인 라우트에 모두 <code>Account page</code>라는 문구를 넣어줘야 한다면 이렇게 할 수 있다. 먼저 다음과 같은 <code>AccountPage</code>컴포넌트를 작성한다.</p>\n<pre><code class=\"language-jsx\">function AccountPage() {\n  return (\n    &#x3C;div>\n      &#x3C;h1>Account Page&#x3C;/h1>\n      &#x3C;Outlet />\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<p>이 <code>AccountPage</code>컴포넌트는 Outlet 컴포넌트 위치를 통해서 이 컴포넌트를 element로 쓰는 라우트의 자식 컴포넌트로 들어갈 Route의 element가 어디에 들어갈지 설정해 준다. <code>AccountPage</code>에서는 h1태그의 위치 아래에 위치하도록 했다.</p>\n<p>만약 h1태그와 Outlet의 순서를 바꾸면 <code>Account page</code>문구가 위에 오게 된다.</p>\n<p>이러한 Outlet 태그가 Route 태그의 default element이기 때문에 우리가 굳이 element를 명시해 주지 않아도 nested Route는 우리 생각대로 잘 동작한다. 만약 element가 Outlet 자체라면 부모 Route는 일치하는 자식 Route의 element를 그대로 보여주면 되기 때문이다.</p>\n<h1>3. 좀더 복잡한 경우의 문제 - parent route도 다룰 경우</h1>\n<p>좀 더 복잡한 문제는 parent route의 URL에도 어떤 컴포넌트가 렌더링되어야 할 경우에 생긴다. 물론 부모 route와 자식 route에 어떤 공통 요소가 있고 자식 요소는 그저 부모 route에 어떤 요소를 더한 것일 경우에는 위에서 다룬 Outlet을 적절히 사용하면 된다. 그런데 그 둘이 전혀 다른 컴포넌트를 렌더링해야 한다면?</p>\n<p>만약 계정 찾기 페이지가 따로 있고, 여기서 이메일 찾기 페이지 혹은 비밀번호 찾기 페이지로 접근할 수 있다고 하자. 즉 이메일 찾기 페이지/비밀번호 찾기 페이지로 이동하기 전에 계정 찾기 페이지를 보여줘야 하는 것이다.</p>\n<p>(굳이 여기서 계정 찾기 페이지를 만들 필요는 없다. 프로젝트에서는 중간 역할을 하는 페이지가 있는 게 지금 예시보다 좀 더 자연스러운 경우였다. 하지만 예시의 일관성을 위해 계정 찾기 페이지로 똑같이 예시를 든다)</p>\n<p>그럼 <code>account/find</code> URL에서는 계정 찾기 페이지를 보여주고 <code>account/find/email</code>페이지에서는 이메일 찾기 페이지를, <code>account/find/password</code>에서는 비밀번호 찾기 페이지를 보여주면 된다.</p>\n<p>따라서 다음과 같이 라우트를 짜면 될 거라고 생각할 수 있다.</p>\n<pre><code class=\"language-jsx\">function App() {\n  return (\n    &#x3C;Routes>\n      &#x3C;Route path=\"/\" element={&#x3C;MainPage />} />\n      &#x3C;Route path=\"account\" element={&#x3C;AccountPage />}>\n        &#x3C;Route path=\"login\" element={&#x3C;LoginPage />} />\n        &#x3C;Route path=\"find\" element={&#x3C;FindAccountPage />}>\n          &#x3C;Route path=\"email\" element={&#x3C;FindEmailPage />} />\n          &#x3C;Route path=\"password\" element={&#x3C;FindPasswordPage />} />\n        &#x3C;/Route>\n      &#x3C;/Route>\n    &#x3C;/Routes>\n  );\n}\n</code></pre>\n<p>하지만 이렇게 하면 우리가 원하는 결과를 보여주지 않는다. <code>account/find</code>URL의 페이지는 <code>FindAccountPage</code>컴포넌트를 잘 보여준다. 하지만 <code>account/find/email</code>과 <code>account/find/password</code>에서는 우리가 element로 넣어준 컴포넌트가 제대로 렌더링되지 않는다.</p>\n<p>이는 부모 컴포넌트인 <code>&#x3C;Route path=\"find\" /></code>의 element에 들어간 <code>FindAccountPage</code>컴포넌트에 그 자식 라우트의 element를 어디 보여줄지를 결정하는 <code>Outlet</code>컴포넌트가 없기 때문이다. 자식 라우트를 렌더링하는 컴포넌트가 없는데 자식 라우트가 렌더링될 리가 있겠는가?</p>\n<h1>3.1 해결1 - 빈 URL 자식 컴포넌트를 만들기</h1>\n<p>이는 조금만 생각하면 쉬운 해결 방식이 하나 있다. 부모 라우트에는 element로 Outlet을 전달하고(즉 element를 명시적으로 Outlet으로 넣어 주거나 넣어 주지 않아서 default element로 쓰도록 하는 것) 자식 라우트만 적절히 작성해 주면 된다.</p>\n<p>즉 다음과 같이 App 컴포넌트를 써주면 된다.</p>\n<pre><code class=\"language-jsx\">function App() {\n  return (\n    &#x3C;Routes>\n      &#x3C;Route path=\"/\" element={&#x3C;MainPage />} />\n      &#x3C;Route path=\"account\" element={&#x3C;AccountPage />}>\n        &#x3C;Route path=\"login\" element={&#x3C;LoginPage />} />\n        &#x3C;Route path=\"find\" element={&#x3C;Outlet />}>\n          &#x3C;Route path=\"\" element={&#x3C;FindAccountPage />} />\n          &#x3C;Route path=\"email\" element={&#x3C;FindEmailPage />} />\n          &#x3C;Route path=\"password\" element={&#x3C;FindPasswordPage />} />\n        &#x3C;/Route>\n      &#x3C;/Route>\n    &#x3C;/Routes>\n  );\n}\n</code></pre>\n<p>그러나 빈 URL을 쓰는 게 그렇게 마음에 들지 않는다. 뭔가 좀 더 부모 라우트와 연관되어 있다는 것을 명시적으로 드러낼 수 있는 방법이 있었으면 좋겠다.</p>\n<h1>3.2 해결2 - index 사용하기</h1>\n<p>이는 Route에 index props를 사용하여 해결할 수 있다. index props가 붙은 Route는 default child route처럼 지정되어 부모 Route URL + '/'경로에 렌더링된다. 즉 3.1에서 작성한 App 컴포넌트는 다음과 같이 다시 쓸 수 있다.</p>\n<pre><code class=\"language-jsx\">function App() {\n  return (\n    &#x3C;Routes>\n      &#x3C;Route path=\"/\" element={&#x3C;MainPage />} />\n      &#x3C;Route path=\"account\" element={&#x3C;AccountPage />}>\n        &#x3C;Route path=\"login\" element={&#x3C;LoginPage />} />\n        &#x3C;Route path=\"find\" element={&#x3C;Outlet />}>\n          &#x3C;Route index element={&#x3C;FindAccountPage />} />\n          &#x3C;Route path=\"email\" element={&#x3C;FindEmailPage />} />\n          &#x3C;Route path=\"password\" element={&#x3C;FindPasswordPage />} />\n        &#x3C;/Route>\n      &#x3C;/Route>\n    &#x3C;/Routes>\n  );\n}\n</code></pre>\n<p>예상대로 <code>account/find</code>경로에는 <code>FindAccountPage</code>가 렌더링되고 자식 라우트의 요소들도 생각하던 대로 잘 렌더링된다. default child route라고 해서 잘못 이해할 수 있지만 index로 지정한 Route도 부모 Route URL + '/'경로 외에 다른 URL경로에는 아무것도 렌더링해주지 않는다. 예를 들어서 <code>account/find/123</code> 과 같은 경로에는 아무 Route URL도 일치하지 않으므로 그 URL에는 아무것도 없다.</p>\n<p>만약 하나의 부모 라우트에 index로 지정된 자식 라우트가 2개 이상 있다면 먼저 나온 것을 먼저 렌더링한다.</p>\n<p>또한 path props를 전달한 Route는 index로 지정할 수 없다. Route에 path props를 전달하는 순간 index props의 type이 false로 지정되어서 만약 path가 전달된 Route에 index props를 전달하려는 순간 에러가 뜬다(<code>Type 'true' is not assignable to type 'false'</code>). 다만 이는 type에 의한 것이니 당연히 타입스크립트 기준이다.</p>\n<h1>참고</h1>\n<p>리액트 라우터 공식문서의 Route 컴포넌트 <a href=\"https://reactrouter.com/docs/en/v6/components/route\">https://reactrouter.com/docs/en/v6/components/route</a>\n리액트 라우터 공식문서의 Outlet 컴포넌트 <a href=\"https://reactrouter.com/docs/en/v6/components/outlet\">https://reactrouter.com/docs/en/v6/components/outlet</a>\n스택오버플로우 질문답변 <a href=\"https://stackoverflow.com/questions/66266216/how-can-i-exactly-match-routes-nested-deeply-in-react-router-6\">https://stackoverflow.com/questions/66266216/how-can-i-exactly-match-routes-nested-deeply-in-react-router-6</a></p>",
    "excerpt": "1. 문제의 발생\n진행하고 있는 프로젝트에서는 SPA인 리액트로 여러 페이지를 구성하기 위해 react-router-dom을 사용한다. 이때 비슷한 url을 가지는 여러 개의 라우트를 사용해야 하는 경우가 있다. 예를 들어서 계정에 관련된 라우트는 account로 시작하고 어떤 목적으로 쓰이는 페이지인지에 따라서 다른 URL을 가지게 할 것이다.\n즉 다음과 같은 라우트들이 있는 건 자연스럽다. 로그인 라우트, 가입한 이메일을 찾는 기능을 하는 라우트, 비밀번호를",
    "headingTree": [
      {
        "title": "1. 문제의 발생",
        "url": "#1-문제의-발생",
        "items": []
      },
      {
        "title": "2. 문제 해결의 시작 - Nested Route",
        "url": "#2-문제-해결의-시작---nested-route",
        "items": [
          {
            "title": "2-1. 가능한 이유",
            "url": "#2-1-가능한-이유",
            "items": []
          }
        ]
      },
      {
        "title": "3. 좀더 복잡한 경우의 문제 - parent route도 다룰 경우",
        "url": "#3-좀더-복잡한-경우의-문제---parent-route도-다룰-경우",
        "items": []
      },
      {
        "title": "3.1 해결1 - 빈 URL 자식 컴포넌트를 만들기",
        "url": "#31-해결1---빈-url-자식-컴포넌트를-만들기",
        "items": []
      },
      {
        "title": "3.2 해결2 - index 사용하기",
        "url": "#32-해결2---index-사용하기",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 2,
      "wordCount": 458
    },
    "url": "/posts/front-bug-3",
    "thumbnail": {
      "local": "/thumbnails/front-bug-3-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-front-bug-3-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAoUlEQVR4nAGWAGn/AImJiTc3NyMjI29vbzo6OioqKlxcXI2NjQCJiYkoKChfX19JSUk/P0A/P0AaGhqpqakAhoaHCgoLTExMNDQ0Nzc3CQkJERER4uLiALOzsk9PT3l5eba2tsHBwaKiosXFxfv7+wCRk5Q+Pz9nZmevr6+srKyioqLMzMz///8AoaSopaWmsbCw09PT////+/v7+/v7////vDpJt4NIMUYAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "front-bug-4",
    "title": "프로젝트 트러블 슈팅 - 체크박스 이벤트 다루기",
    "date": "2022-08-23T00:00:00Z",
    "description": "체크박스의 이벤트 핸들링 그리고 기본 상태",
    "tags": [
      "web",
      "study",
      "front",
      "react"
    ],
    "html": "<h1>0. 선요약</h1>\n<p>프로젝트에서 체크박스를 다루면서 2가지 문제를 맞닥뜨렸다. 하나는 onClick과 onChange 둘 중 어떤 이벤트 핸들러 함수를 사용할지에 관한 것이었다. IE까지 고려한다면 onClick이 더 나았다. 하지만 IE의 서비스가 종료되고 점유율도 변변치 못한 지금 크게 신경쓸 문제는 아니었다. 하지만 체크박스의 값을 바꾸는 것은 결국 클릭 이벤트라는 것을 고려해서 onClick 이벤트 핸들러를 사용하기로 했다.</p>\n<p>이때 onClick을 사용할 시, 체크박스의 초기 상태를 지정하는 checked props를 사용하지 못한다는 문제가 생겼다. 따라서 defaultChecked를 사용하여 해결했다. 이 과정을 정리해 둔다.</p>\n<h1>1. onClick vs onChecked</h1>\n<p>체크박스의 체크 여부 변경에 따라 어떤 동작을 해줘야 하는 경우가 생길 수 있다. 진행한 프로젝트에서 그런 경우는 첫째로 약관 동의 체크박스를 사용하는 경우가 있었다. 그리고 하나의 페이지에서 다른 페이지로 넘어갈 때 다른 페이지로 전달되는 상태가 있었는데, 그 상태에 어떤 내용을 포함시킬지 정하는 체크박스를 다뤄야 했다.</p>\n<p>이때 체크박스가 체크되거나 체크 해제되는 이벤트를 다루기 위해 사용할 수 있는 핸들러 함수는 2개가 떠오른다. <code>onChange</code>와 <code>onClick</code>이다. 그럼 이 둘의 차이는 뭘까?</p>\n<p>App 컴포넌트에 다음과 같은 코드를 작성하였다.</p>\n<pre><code class=\"language-jsx\">function App() {\n  const handleClick = (e: React.MouseEvent&#x3C;HTMLInputElement>) => {\n    console.log(\"체크박스 클릭됨\" + e.currentTarget.checked);\n  };\n\n  const handleChange = (e: React.ChangeEvent&#x3C;HTMLInputElement>) => {\n    console.log(\"체크박스 변경됨\" + e.target.checked);\n  };\n\n  return (\n    &#x3C;div>\n      &#x3C;h1>체크박스 테스트&#x3C;/h1>\n      &#x3C;label htmlFor=\"onclick-checkbox\">onClick을 쓰는 체크박스&#x3C;/label>\n      &#x3C;input id=\"onclick-checkbox\" type=\"checkbox\" onClick={handleClick} />\n      &#x3C;label htmlFor=\"onchange-checkbox\">onChange 쓰는 체크박스&#x3C;/label>\n      &#x3C;input id=\"onchange-checkbox\" type=\"checkbox\" onChange={handleChange} />\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<p>두 체크박스는 크롬 환경에서는 완전히 똑같이 동작한다. 그러나 IE에서는 onChange가, 체크박스에서 focus가 벗어나는 시점에 이벤트가 발생한다고 한다(엣지 브라우저에서는 이런 문제가 없다). 이를 해결하기 위해 onClick을 사용하는 것이 좋다.</p>\n<h1>2. onClick에서 발생하는 문제</h1>\n<p>그런데 이 체크박스가 초기에 체크되어 있도록 하고 싶을 수 있다. 그러면 checked props를 사용하는 방식을 생각해 보자.</p>\n<pre><code class=\"language-jsx\">const [checked, setChecked] = useState(true);\n\nconst handleChange = (e: React.ChangeEvent&#x3C;HTMLInputElement>) => {\n  setChecked(!checked);\n};\n\n&#x3C;input\n  id=\"onchange-checkbox\"\n  type=\"checkbox\"\n  checked={checked}\n  onChange={handleChange}\n/>;\n</code></pre>\n<p>이러면 체크박스의 체크 여부를 나타내는 <code>checked</code> state가 초기에 true로 설정된다. 따라서 체크박스가 초반에 체크되어서 렌더링된다. 또한 onChange에서 checked를 반전시키는 역할도 해준다. onChange가 없으면 체크박스의 체크 여부를 바꿀 수 없다.</p>\n<p>그런데 onChange 대신 onClick을 사용하면?</p>\n<pre><code class=\"language-jsx\">const [checked, setChecked] = useState(true);\n\nconst handleClick = (e: React.MouseEvent&#x3C;HTMLInputElement>) => {\n  console.log(\"체크박스 클릭됨\" + e.currentTarget.checked);\n  setChecked(!checked);\n};\n\n&#x3C;input\n  id=\"onclick-checkbox\"\n  type=\"checkbox\"\n  checked={checked}\n  onClick={handleClick}\n/>;\n</code></pre>\n<p>이렇게 하면 에러가 발생한다. 에러 메시지는 다음과 같다.</p>\n<pre><code>Warning: You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.\n</code></pre>\n<p>이 에러를 해결하는 방법은 그냥 에러 메시지에서 시키는 대로 하면 된다. 어차피 우리는 체크박스가 처음에 체크되어 있기만 하면 되기 때문에 defaultChecked를 설정해 주는 것이다.</p>\n<pre><code class=\"language-jsx\">&#x3C;input\n  id=\"onclick-checkbox\"\n  type=\"checkbox\"\n  defaultChecked\n  onClick={handleClick}\n/>\n</code></pre>\n<p>이러면 에러 메시지도 사라지고 체크박스가 처음에 체크되어 있는 상태로 렌더링된다. onClick 이벤트도 잘 동작한다. 어떻게든 결과는 냈다. 그런데 이 에러는 왜 발생하는지 잠깐 알아보았다.</p>\n<h1>3. 에러의 발생 이유</h1>\n<p>리액트에는 폼(input도 포함)을 만드는 데 2가지 방법이 있다. Controlled component와 Uncontrolled Component이다. 이때 두 컴포넌트에는 요구되는 attribute들이 있는데 이것들을 제대로 설정해 주지 않았을 때 위의 에러가 발생한다.</p>\n<p>Controlled component는 <code>value</code>와 <code>onChange</code> attribute를 요구한다. 이때 체크박스나 라디오버튼 컴포넌트의 경우 <code>value</code> 대신 <code>checked</code> attribute를 요구한다.</p>\n<p>Controlled component의 경우 어떤 값을 제어하는 데 쓰이기 때문에 state 혹은 props로 된 값을 가져야 한다. 따라서 value 를 갖는 건 당연하다. 또한 이 값이 바뀌었을 경우 이벤트 핸들러를 통해 값이 변경되었고 리렌더링시 이를 반영해야 한다는 것을 React에 알려야 한다. onChange가 이를 수행한다. 이것이 Controlled component가 앞의 두 attribute를 요구하는 이유이다.</p>\n<p>Uncontrolled component의 경우 state/props와 이벤트 핸들러가 아니라 DOM 자체에서 관리되는 컴포넌트이다. 따라서 value, onChange 이벤트핸들러 같은 건 필요없다. 만약 이런 uncontrolled component의 값을 가져오고 싶다면 useRef 혹은 id를 통해서(getElementById 등의 사용) 가져와야 한다.</p>\n<p>이런 Uncontrolled component의 초기값을 설정해 주는 attribute는 defaultValue 혹은 위에서 사용한 defaultChecked(checkbox, radio type input에만)이다. 물론 이걸 통해 초기값을 제공해주는 게 필수는 아니다. controlled component의 value와 달리 핸들링도 안된다. 그저 초기값을 전달하는 것 뿐이다.</p>\n<p>위의 에러는 체크박스에 <code>checked</code> 를 전달함으로써 체크박스를 controlled component라고 리액트에 전달했지만 controlled component라면 같이 전달해 줘야 하는 <code>onChange</code> 를 전달해 주지 않았기 때문에 일어난 것이다.</p>\n<p>따라서 해결 방법은 위처럼 <code>checked</code>를 아예 지워서 Uncontrolled component로 만들고 초기값은 <code>defaultChecked</code>로 전달하고 값을 받아오는 작업은 <code>useRef</code>를 통해 진행하는 방법이 있을 수 있다. 체크박스의 값을 받아오는 것까지 작성하면 다음과 같이 된다.</p>\n<pre><code class=\"language-tsx\">function App() {\n  const checkedRef = useRef&#x3C;HTMLInputElement>(null);\n\n  const handleClick = () => {\n    if (checkedRef.current !== null) {\n      console.log(\"체크박스 클릭됨\" + checkedRef.current.checked);\n    }\n  };\n\n  return (\n    &#x3C;div>\n      &#x3C;h1>체크박스 테스트&#x3C;/h1>\n      &#x3C;label htmlFor=\"onclick-checkbox\">onClick을 쓰는 체크박스&#x3C;/label>\n      &#x3C;input\n        ref={checkedRef}\n        id=\"onclick-checkbox\"\n        type=\"checkbox\"\n        onClick={handleClick}\n        defaultChecked\n      />\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<p>체크박스를 Controlled component로 다루고 싶다면 <code>onClick</code> 대신 <code>onChange</code>로 이벤트를 핸들링하는 방법이 있다.</p>\n<h1>참고</h1>\n<p><a href=\"https://devlog.jwgo.kr/2018/11/28/checkbox-error-with-react/\">https://devlog.jwgo.kr/2018/11/28/checkbox-error-with-react/</a></p>\n<p>관련 스택오버플로우 질문답변 <a href=\"https://stackoverflow.com/questions/5575338/what-the-difference-between-click-and-change-on-a-checkbox\">https://stackoverflow.com/questions/5575338/what-the-difference-between-click-and-change-on-a-checkbox</a></p>\n<p><a href=\"https://stackoverflow.com/questions/70022781/react-checkbox-event-preventdefault-breaks-onchange-function-why\">https://stackoverflow.com/questions/70022781/react-checkbox-event-preventdefault-breaks-onchange-function-why</a></p>\n<p><a href=\"https://stackoverflow.com/questions/36715901/reactjs-error-warning\">https://stackoverflow.com/questions/36715901/reactjs-error-warning</a></p>\n<p>리액트 공식 문서의 Uncontrolled Component와 Controlled Component에 대한 설명\n<a href=\"https://reactjs.org/docs/uncontrolled-components.html\">https://reactjs.org/docs/uncontrolled-components.html</a>\n<a href=\"https://reactjs.org/docs/forms.html#controlled-components\">https://reactjs.org/docs/forms.html#controlled-components</a></p>",
    "excerpt": "0. 선요약\n프로젝트에서 체크박스를 다루면서 2가지 문제를 맞닥뜨렸다. 하나는 onClick과 onChange 둘 중 어떤 이벤트 핸들러 함수를 사용할지에 관한 것이었다. IE까지 고려한다면 onClick이 더 나았다. 하지만 IE의 서비스가 종료되고 점유율도 변변치 못한 지금 크게 신경쓸 문제는 아니었다. 하지만 체크박스의 값을 바꾸는 것은 결국 클릭 이벤트라는 것을 고려해서 onClick 이벤트 핸들러를 사용하기로 했다.\n이때 onClick을 사용할 시, 체",
    "headingTree": [
      {
        "title": "0. 선요약",
        "url": "#0-선요약",
        "items": []
      },
      {
        "title": "1. onClick vs onChecked",
        "url": "#1-onclick-vs-onchecked",
        "items": []
      },
      {
        "title": "2. onClick에서 발생하는 문제",
        "url": "#2-onclick에서-발생하는-문제",
        "items": []
      },
      {
        "title": "3. 에러의 발생 이유",
        "url": "#3-에러의-발생-이유",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 348
    },
    "url": "/posts/front-bug-4",
    "thumbnail": {
      "local": "/thumbnails/front-bug-4-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-front-bug-4-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAkElEQVR4nGOYOnWqq6urra1tbW1tcHCwk5NTWlrajBkzGIqKinR1da2trYuKinh4eAwMDIyNjeXk5Bg2b95cWlp68uTJS5cubd68+dq1a8+ePbt06RLDubNn582bd+HChW1g8ObNm/9gwHD/0eOHjx7dv3///fv3//////PnD1Ri6co1ixcv2bx5840bN5AlAJwMX8/L24OLAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "geultto-coffee-chat-inter",
    "title": "글또 커피챗 중간 회고록",
    "date": "2024-03-08T00:00:00Z",
    "description": "글또의 반이 넘게 지나왔다. 그동안의 커피챗 이야기",
    "tags": [
      "life"
    ],
    "html": "<p><img src=\"/static/image-656ad713.png\" alt=\"커피챗 썸네일\"></p>\n<h1>시작</h1>\n<p>작년 말부터 친구가 추천했던 <a href=\"https://bit.ly/geultto_intro\">글또 9기</a>에 참여하여 활동하고 있다. 거기서 커피챗을 꽤 많이 했다. 오늘 세어 보니 지금까지 22명과 1대1 커피챗을 했고, 단체로 만난 분까지 합치면 30명은 거뜬히 넘는다. 글또에서 가장 많은 커피챗을 한 사람은 아니지만 내가 상위권인 건 분명하다고 생각한다.</p>\n<p>그러다가 최근에 한 커피챗에서 한 분이 \"커피챗을 많이 하면서 느꼈던 게 뭐가 있어요?\"라고 물어오셨다. 파편화된 생각들은 많았지만 나도 그렇게 물음을 받고 제대로 고민해 보지는 않았었다.</p>\n<p>또한 그 질문을 던져 주신 상대분이 내가 느끼기에는 아주 편안하게 말하도록 분위기를 만들어 주시는 분이었다. 그래서 나도 혼자 생각했다면 놓쳤을 수도 있는 것들을 더 잘 떠올릴 수 있었다. 그래서 그 기억이 남아 있을 때 커피챗을 하면서 느꼈던 것들을 간략히 정리해 보려고 한다. 여러 커피챗에서 공통적으로 했던 얘기들 그리고 내가 느꼈던 것들을 정리하는 글이다.</p>\n<h1>커피챗을 시작한 계기</h1>\n<p>나는 글또 극초반에 \"자유로운담소\" 채널에서 상당한 어그로를 끌었다. 이렇게 공개적으로 사람들에게 커피챗을 제안했던 것이다.</p>\n<p><img src=\"/static/my-aggro-ac093791.png\" alt=\"당시의 커피챗 제안 글\"></p>\n<p>내 생각보다도 훨씬 많은 분들이 호응해 주셨다. 위의 메시지를 보면 이모지가 70개가 넘게 눌려 있다. 호응을 받는 게 익숙한 사람은 아니라서 어색하기는 했다. 아무튼 호응에 보답하기 위해서라도 자연스레 많은 사람을 만나게 되었다. 원래도 이걸 계기로 사람을 좀더 만나고 싶었으니 좋았다.</p>\n<p>하지만 나는 원래 MBTI도 I고, 새로운 사람 만나는 것도 그렇게 좋아하지 않는다. 이렇게 어그로를 끈 이유는 그냥 남의 흉내였다.</p>\n<p>나는 소프트웨어 마에스트로라는 곳의 13기 출신이다. 거기서는 홈커밍데이라고 해서 이전 기수 사람들을 모아 네트워킹하게 해주는 행사가 있다. 거기에 갔는데 자유 네트워킹 시간이 있었다.</p>\n<p>그 시간에 사람들이 삼삼오오 모여서 떠들고 있었는데 한 사람이 갑자기 단상에 나가서 꺼진 마이크를 켜더니 갑자기 자기소개를 했다! 자기 이름은 뭐고 무엇에 관심이 있으며 지금 이직 준비 중이고 등등 그런 걸 이야기했다.</p>\n<p>엄청난 깡이었고 아주 인상적이었다. 소프트웨어 마에스트로는 제법 오래된 프로그램인 만큼 거기에는 많은 사람들이 만나고 싶어할 유명 시니어 분들도 조금은 계셨다. 하지만 감히 판단하건대 거기 있던 어떤 시니어, 어떤 연차의 개발자도 그 단상에 올라간 분만큼 그 자리에서 임팩트를 주지 못했다. 단상에 올라간 그분은 주니어에서 중니어 정도 연차였음에도 불구하고 말이다.</p>\n<p>이 글또라는 프로그램에서 나도 그런 걸 재현해 볼 기회가 왔다. 심지어 단상에도 안 올라가도 되고 슬랙에 메시지만 쓰면 되는데, 보는 사람은 더 많다. 그래서 그런 기회를 잡아보자고 생각했다. 많은 고민을 했지만 난 이렇게 인상적이었던 남의 행동을 흉내내서 무언가를 한 적이 꽤 많았고 그 결과는 다 그렇게 나쁘지 않았다. 그래서 이번에도, 흉내를 내보았던 것이다.</p>\n<h2>또다른 목적</h2>\n<p>난 사실 프론트 개발자들을 잘 모른다. 나는 알고리즘과 함께 프로그래밍을 시작한 사람이고 알고리즘 학회에서 개발자의 길을 걷게 되었으며 주변 대부분은 컴퓨터공학 전공자다. 그리고 그런 사람들은 대부분 백엔드 개발자가 된다...</p>\n<p>내게 프론트 개발을 하는 지인이라고 할 만한 사람은 주로 <a href=\"https://github.com/CreeJee\">CreeJee</a>와 풀스택 개발을 하는 <a href=\"https://xo.dev/\">이창희</a>정도였고 나보다는 훨씬 연차가 높다. 나와 비슷한 연차와 처지라고 할 만한 사람은 딱히 없었다. 소마를 하면서 몇 명 얼굴을 튼 정도?</p>\n<p>그래서 글또를 통해서 이런저런 프론트 개발자들을 만나고 싶은 마음이 컸다. 어떤 평행세계에선 내가 위 메시지처럼 어그로를 끌지 않았을지도 모르고 이렇게 많은 커피챗을 하지 않았을지도 모르지만 그래도 소소하게 다른 개발자들을 만나고 다니긴 했을 듯 하다.</p>\n<h1>사람들을 만나며</h1>\n<p>커피챗에서 사람들을 만나며 느낀 건 \"아, 그래도 개발자를 해서 이런 사람들을 만났구나.\"라는 게 컸다. 난 다른 사람들이 어떻게 하고 있는지, 어떤 고민을 하고 무엇을 통해서 삶을 채워나가고 있는지가 궁금했다.</p>\n<p>또 프론트 개발자들은 다른 개발분야에 비해 전공자가 많지 않고 다채로운 출신들이 있어서(통계적으로 정확한지는 모르겠지만 느낌이 그랬다) 더 궁금했다. 나는 상당히 재미없게 살아온 사람이니까.</p>\n<p>그래서 다른 사람들을 만났고 그들의 이야기를 들었다. 재미있었다. 원래였다면 이런 재밌고 다채로운 사람들과 나는 섞일 일도 거의 없었을 것이다. 나는 기계공학과의 어떤 아싸로, 그 사람들은 원래 출신(디자이너라든지, 패션 쪽의 어떤 직업이라든지 등등)으로 만날 일이 없었을 테니까. 또 공통점이란 게 없으니 만나도 대화가 쉽지 않았겠지.</p>\n<p>하지만 우린 개발자가 되었고 개발을 공통 주제로 대화를 나눌 수 있었다..좋았다.</p>\n<p>물론 그게 아쉬운 점도 있었지만 그건 다음 문단에서 다시.</p>\n<h1>커피챗의 사람들</h1>\n<p>사실 사람을 대하는 게 아직 어렵다. 커피챗을 많이 하다 보니 1번의 만남 정도는 어떻게든 할 것 같지만 난 그건 원래부터 꽤 잘하는 사람이었다. 하지만 그 다음부터가 문제다. 글또에서 분명 더 친해지고 싶은 사람들이 생각보다도 더 많았는데 어떻게 할지 잘 모르겠다...</p>\n<p>내 인생에서 가장 많은 사람을 만난 시기 중 하나였다.</p>\n<p>사람들이 생각하는 \"진짜 개발자\"의 어떤 상이 있는 걸 안다. 계속 발전하려고 노력하고 새로운 기술을 배우려고 하고 꾸준히 개발을 좋아하고 시간을 투자하는 등등. 물론 나도 그 사람들을 멋있다고 생각하지만 나는 이미 그런 사람들을 많이 보았다. 내가 이제 보고 싶어하는 건 재미없게 살아온 나에게 다채로움과 뭔가 인간의 매력이라는 걸 보여줄 수 있는 사람이었다.</p>\n<p>공연도 다니고, 취미도 있고 옷도 후드티 같은 것보다는 셔츠나 크롭티를 입으며 피어싱도 하고 말도 잘하고 뭐 아무튼 개성과 매력이 넘치는 사람. 그냥 일상적인 표현으로 말하자면, 누군가 내게 소개팅을 부탁했을 때 적어도 머리에 후보군으로 한번쯤 지나갈 만한 매력 쩌는 사람. 나는 그런 사람이 보고 싶었고 그렇게 되는 법을 배우고 싶었다.</p>\n<p>왜냐면 나는 그런 \"진짜 개발자\"들이 생각보다 그렇게 행복하지 않고, 그런 사람들은 오히려 평범하게 놀러 다니고 연애하고 그럴 \"수 있는\"(나도 그런 너드의 세계의 발을 걸치고 있으니 하는 말이지만 나를 포함한 이 너드들은 놀러다니고 자연스럽게 연애도 하고 그런 방법을 \"모른다\". 막상 놀라고 해도 뭘 즐길 줄 모를 것이다)사람들을 부러워한다는 걸 시간을 통해 알았기 때문이다.</p>\n<h1>관계의 거래</h1>\n<h2>접근은 생각보다 귀하다</h2>\n<p>아까 말했듯이 70명이 넘는 사람들이 연락을 받을 의향이 있다며 내 메시지에 이모지를 눌러주셨다. 하지만 내게 먼저 연락을 주신 분이 몇 명이나 될까? 몇 명에게 이 질문을 했었는데, 대부분은 \"당연히 70명보다는 훨씬 적겠지만 두 자릿수 정도는 되지 않을까\"라는 대답을 하셨다.</p>\n<p>기준에 따라 카운팅이 달라지지만 지금까지 2~3명이 연락을 주셨다. 많은 사람들의 생각보다도 훨씬 적은 숫자다. 먼저 연락을 하고 안 하고가 그 사람의 좋고 나쁨을 대변한다고 생각하지는 않는다. 하지만 70명 중 3명이라는 건 굉장히 적은 비율이고, 사람인 이상 연락을 먼저 해주시는 분께 더 마음이 가는 건 당연하다고 생각한다.</p>\n<p>만약 3/70, 그러니까 글또에서 무작위로 뽑은 23명 중 가장 개발을 잘하는 사람이 되겠다고 한다면 그건 꽤 힘들 것이다. 하지만 연락을 주는 것만으로도 23명 중 1명 꼴로 어디에선가 돋보일 수 있다면 어떤가? 그건 꽤 쉬운 일이 아닐까?</p>\n<p>물론 내가 훨씬 더 잘났다면 더 많은 사람들이 연락을 주셨으리라 생각한다. 하지만 나는 결과적으로 '내게 연락하는 사람'이 늘어났을 거라 생각한다. '내게 먼저 연락하는 사람 / 나를 한번쯤 만나볼 의향이 있는 사람'의 비율이 드라마틱하게 증가할 거라고 보지는 않는다.</p>\n<h2>관계의 거래</h2>\n<p>글또라는 집단에 들어왔다는 것 자체가 일단 2주에 하나씩은 블로그 글을 쓰려고 하고, 어느 정도의 성실함을 갖췄다는 의미라고 생각한다. 그래서 내가 보았던 분들은 전부 각자 다른 색으로 반짝반짝 빛나는 분들이었다. 솔직히 커피챗으로 만난 개발자가 아닌 친구가 되고 싶은 분들이었고 만약 개중 누군가 내게 친구가 되자는 식의 행동을 취하면 나는 정말 기쁠 것이다.</p>\n<p>하지만 여러가지 이유로, 나는 그 모두와 친구가 될 수는 없다. 원래 있던 인간관계들도 생각하면 그 중에서 굉장히 소수만이 나와 지속적인 관계를 유지하게 될 것이다. 커피챗을 하는 상대방도 마찬가지다.</p>\n<p>이 개발의 세상이 생각보다 좁아서 몇 다리 건너면 다 안다는 걸 생각할 때, 그럴 거라면 이왕이면 내가 투자한 1번의 커피챗에 비해서 좋은 이미지와 인상을 주어서 이득을 보는 게 좋지 않을까?</p>\n<p>예를 들어서 나는 벌써 22번의 커피챗을 했고 앞으로 더 많은 커피챗을 하러 다닐 것이다. 모두가 특별한 분들이라 말했지만 솔직히 내 마음속에서 대부분은 one of them일 수밖에 없다. 기억하라면 훌륭하다 기억하지만, 남들보다 특별하냐 하면 그건 사실 쉽지 않은.</p>\n<p>내가 커피챗한 상대는 커피챗을 한두 번밖에 안했다면? 적어도 나보다는 적게 했다면? 나는 거의 이득이다. 우리는 서로 좋은 이미지를 받았지만, 그 사람의 커피챗-세상에서 나는 꽤 큰 존재일 것이다. 또한 나는 여러 가지 장치를 통해서 좋은 이미지를 줬을 가능성이 높고.</p>\n<h2>솔직함은 생각보다 가치가 있다</h2>\n<p>여기까지 글을 읽으신 분이라면 지금까지 글을 읽으면서 어떤 생각이 들었는지 모르겠다. 속물이라고 생각할까? 내 이미지가 오히려 상했을까? 그럴 수도 있다. 하지만 나는 여기까지 읽은 사람이라면 내게 꽤 솔직하고, 괜찮은 인상을 받지 않았을까 생각한다. 그래서 여기까지 읽었을 테니까.</p>\n<p>그런데 내가 좋은 이야기를 많이 했나? 굳이 뜯어보자면 사람들이 생각하는 멋진 개발자와 소프트스킬을 가진 멋지고 영웅적인 개발자의 이야기는 아니라고 생각한다...그래도 오히려 그게 좋은 모습을 주는 것이다. 이 솔직했던 말들이 엄청나게 나쁜 것도 아니고, 아주 훌륭한 생각은 아니지만 할 만한 생각이니까.</p>",
    "excerpt": "\n시작\n작년 말부터 친구가 추천했던 글또 9기에 참여하여 활동하고 있다. 거기서 커피챗을 꽤 많이 했다. 오늘 세어 보니 지금까지 22명과 1대1 커피챗을 했고, 단체로 만난 분까지 합치면 30명은 거뜬히 넘는다. 글또에서 가장 많은 커피챗을 한 사람은 아니지만 내가 상위권인 건 분명하다고 생각한다.\n그러다가 최근에 한 커피챗에서 한 분이 \"커피챗을 많이 하면서 느꼈던 게 뭐가 있어요?\"라고 물어오셨다. 파편화된 생각들은 많았지만 나도 그렇게 물음을 받고 제대로",
    "headingTree": [
      {
        "title": "시작",
        "url": "#시작",
        "items": []
      },
      {
        "title": "커피챗을 시작한 계기",
        "url": "#커피챗을-시작한-계기",
        "items": [
          {
            "title": "또다른 목적",
            "url": "#또다른-목적",
            "items": []
          }
        ]
      },
      {
        "title": "사람들을 만나며",
        "url": "#사람들을-만나며",
        "items": []
      },
      {
        "title": "커피챗의 사람들",
        "url": "#커피챗의-사람들",
        "items": []
      },
      {
        "title": "관계의 거래",
        "url": "#관계의-거래",
        "items": [
          {
            "title": "접근은 생각보다 귀하다",
            "url": "#접근은-생각보다-귀하다",
            "items": []
          },
          {
            "title": "관계의 거래",
            "url": "#관계의-거래-1",
            "items": []
          },
          {
            "title": "솔직함은 생각보다 가치가 있다",
            "url": "#솔직함은-생각보다-가치가-있다",
            "items": []
          }
        ]
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 6
    },
    "url": "/posts/geultto-coffee-chat-inter",
    "thumbnail": {
      "local": "/static/image-656ad713.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-image-656ad713-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAYElEQVR4nGWNMQrAIAxFAxk9s+DoKTyEd8jqlF0ICIK7IARSRFpK+9bH/w/sRl+YGahq733O+ei11ha1VkQMIRBRzpmZU0pjDGitOedijCJSSiEi772IwJl/Svvqnz3iAsqkfjfpcPhyAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "html-dom-missing-element",
    "title": "HTML의 DOM 인터페이스가 없는 요소들",
    "date": "2023-08-11T01:00:00Z",
    "description": "어떤 HTML 요소들은 따로 DOM 인터페이스가 있고 어떤 건 없다. 왜 그럴까?",
    "tags": [
      "HTML"
    ],
    "html": "<h1>들어가면서</h1>\n<p>며칠에 걸쳐 조사를 진행했으나 솔직히 이 글에서 제기하는 작은 의문에 대해서 완전히 속시원한 대답을 찾지는 못했다. 대부분은 설명할 수 있었지만 몇 가지는 하지 못했다. 웹 스펙의 역사적인 이유라고밖에는 설명할 수 없을 것들이라고 생각한다.</p>\n<p>혹시 누군가가 HTML의 어떤 요소는 왜 HTMLElement이고, 어떤 요소는 특별한 추가 요구사항이 없는데도 HTML 요소의 인터페이스가 따로 존재하는지에 대한 명쾌한 기준을 알고 있거나 이 역사를 알고 있다면 제발 댓글로 알려주기를 바라고 있다.</p>\n<p>아래에서도 나름의 기준을 찾아냈으나, 이를 벗어나는 부분들에 대해서 통합적인 명쾌한 설명을 하지 못했다.</p>\n<h1>1. 의문</h1>\n<p>TS를 쓰다 보면 간간이 HTML의 DOM Element 타입을 사용하게 된다. 가령 React에서는 <code>ChangeEvent</code>를 제네릭 타입으로 제공하는데 이럴 때 이런 타이핑을 하게 된다.</p>\n<pre><code class=\"language-tsx\">const handleChange = (event: React.ChangeEvent&#x3C;HTMLInputElement>)=>{\n  setValue(event.target.value)\n}\n</code></pre>\n<p>그런데 코드를 짜다가 정확히 어떤 상황이었는지는 잘 기억나지 않지만 <code>&#x3C;section></code>태그 요소의 타이핑을 해야 했다. 하지만 찾아보니 section에 대한 DOM 인터페이스는 없었고 당연히 대응하는 타입도 없었다. section의 타이핑은 <code>HTMLElement</code>로 해야 한다.</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/section\">MDN 문서를 보아도 <code>&#x3C;section></code>의 인터페이스는 <code>HTMLElement</code>이다.</a> 어째서 이런 자주 쓰이는 태그에 고유 인터페이스 하나 없을까?</p>\n<h1>2. 탐구</h1>\n<p>이런 의문을 가진 사람이 내가 처음이었을 리는 없다. 그래서 찾아보니 누군가가 비슷한 의문을 제시해 놓았다. <a href=\"https://stackoverflow.com/questions/65721709/why-is-there-no-htmlsectionelement-and-no-htmlarticleelement-in-javascript\">왜 HTMLSectionElement와 HTMLArticleElement는 없는 것인가?</a></p>\n<p>질문에서도 이야기하고 또한 HTML 명세를 보아도 그렇지만, 꽤 많이 쓰이는 HTML 요소인데 따로 DOM 인터페이스가 없는 요소들은 다음과 같이 있다.</p>\n<ul>\n<li><code>&#x3C;nav></code></li>\n<li><code>&#x3C;header></code></li>\n<li><code>&#x3C;main></code></li>\n<li><code>&#x3C;footer></code></li>\n<li><code>&#x3C;aside></code></li>\n<li><code>&#x3C;section></code></li>\n<li><code>&#x3C;article></code></li>\n</ul>\n<p>그럼 어떤 요소가 <code>HTMLElement</code>가 될까? HTML 명세에서는 다음과 같이 설명한다.</p>\n<blockquote>\n<p>The basic interface, from which all the HTML elements' interfaces inherit, and which must be used by elements that have no additional requirements, is the HTMLElement interface.</p>\n<p><a href=\"https://html.spec.whatwg.org/multipage/dom.html#elements-in-the-dom\">HTML5 spec, 3.2.2. Elements in the DOM</a></p>\n</blockquote>\n<p>좀더 오래된 명세에도 이것이 포함되어 있다.</p>\n<blockquote>\n<p>Elements that only expose the HTML core attributes are represented by the base HTMLElement interface.</p>\n<p><a href=\"https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-798055546\">HTML4.01 spec, 1.6.4. The HTMLElement interface</a></p>\n</blockquote>\n<p>즉, 위의 요소들은 추가적인 인터페이스 요구사항이 없기 때문에 <code>HTMLElement</code>인터페이스가 된 것이다. 그럼 여기서의 추가적인 요구사항이란 무엇일까? 우리가 흔히 말하는 HTML 요소의 프로퍼티를 말함이다. 가령 <code>&#x3C;input></code>요소의 <code>name</code>같은 것들 말이다.</p>\n<p>예를 들어서 <code>&#x3C;button></code> 요소의 DOM 인터페이스인 <code>HTMLButtonElement</code>의 인터페이스 명세는 다음과 같다.</p>\n<pre><code class=\"language-webidl\">[Exposed=Window]\ninterface HTMLButtonElement : HTMLElement {\n  [HTMLConstructor] constructor();\n\n  [CEReactions] attribute boolean disabled;\n  readonly attribute HTMLFormElement? form;\n  [CEReactions] attribute USVString formAction;\n  [CEReactions] attribute DOMString formEnctype;\n  [CEReactions] attribute DOMString formMethod;\n  [CEReactions] attribute boolean formNoValidate;\n  [CEReactions] attribute DOMString formTarget;\n  [CEReactions] attribute DOMString name;\n  [CEReactions] attribute DOMString type;\n  [CEReactions] attribute DOMString value;\n\n  readonly attribute boolean willValidate;\n  readonly attribute ValidityState validity;\n  readonly attribute DOMString validationMessage;\n  boolean checkValidity();\n  boolean reportValidity();\n  undefined setCustomValidity(DOMString error);\n\n  readonly attribute NodeList labels;\n};\nHTMLButtonElement includes PopoverInvokerElement;\n</code></pre>\n<p><code>&#x3C;button></code>요소가 필요로 하는 프로퍼티인 <code>form</code>등이 명시되어 있는 것을 볼 수 있다. <a href=\"https://witch.work/posts/html-form-tag#6.5.-button\">이런 속성들이 자세히 정리된 내용은 이전에 폼 요소들을 정리했던 글을 참고할 수 있다.</a></p>\n<p>이런 식으로 추가적인 요구사항이 있는 요소들은 DOM 인터페이스가 따로 존재한다. 다른 요소와 별로 다를 바 없어 보이는 <code>&#x3C;div></code>의 <code>HTMLDivElement</code>도 주변 맥락에 대한 요소 컨텐츠의 정렬 위치를 나타내는 <code>align</code> 속성이 있었다. 이는 꽤 오래전에 deprecated되었지만 호환성을 위해 남아있는 것이다.</p>\n<pre><code class=\"language-webidl\">partial interface HTMLDivElement {\n  [CEReactions] attribute DOMString align;\n};\n</code></pre>\n<p><strong>반면에 위에서 보았던 <code>&#x3C;section></code>와 같은 요소들은 기본 DOM 인터페이스에 비해 추가적인 요구사항이 없기 때문에 그냥 <code>HTMLElement</code>가 된 것이다.</strong></p>\n<p>이를 뒷받침하듯이, HTML5에서 도입된 시맨틱 태그들은 대부분 따로 DOM 인터페이스가 없다. 해당 태그들은 대부분 말 그대로 사이트의 의미적 구조를 나타내고 구획하는 데에 쓰이기 때문이다. 위에서 언급된 것들도 시맨틱 태그이고 <code>&#x3C;figcaption></code>, <code>&#x3C;figure></code>, <code>&#x3C;mark></code>, <code>&#x3C;summary></code>와 같은 시맨틱 요소들도 <code>HTMLElement</code>만을 DOM 인터페이스로 가진다.</p>\n<p>물론 이런 시맨틱 태그들이 모두 고유한 DOM 인터페이스가 없는 건 아니다. 따로 요구사항이 필요한 경우에는 고유 DOM 인터페이스를 가지고 있다. 다만 중요한 건 요구사항이 없을 경우 <code>HTMLElement</code>가 된다는 것이다.</p>\n<p>HTML5 요소가 아니라도 이는 마찬가지이다. <code>&#x3C;dl></code>, <code>&#x3C;dt></code>, <code>&#x3C;dd></code>, <code>&#x3C;bdo></code>, <code>&#x3C;cite></code>, <code>&#x3C;em></code>와 같은 요소들도 매우 오래전부터 있었지만 추가적인 인터페이스 요구사항이 없기 때문에 <code>HTMLElement</code>이다. <a href=\"https://html.spec.whatwg.org/multipage/indices.html#element-interfaces\">또 HTMLElement 인터페이스를 갖는 요소는 HTML 스펙에서 볼 수 있다.</a></p>\n<p>참고로 DOM 인터페이스 요구사항이 있는 시맨틱 요소의 예시를 들자면, <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/details\"><code>&#x3C;details></code>요소의 경우 open 속성을 가지고 있기에 따로 DOM 인터페이스를 가진다.</a> 열고 닫히는 요소이므로 요구 사항을 추가하여 고유 DOM 인터페이스를 만드는 게 맞았을 거라 생각한다. <code>&#x3C;time></code>요소도 마찬가지로 <code>datetime</code> 속성을 가지고 있기에 고유 DOM 인터페이스를 가진다.</p>\n<h1>3. 반례들에 대한 약간의 탐구</h1>\n<p>하지만 시원하게 이 의문을 해결하는 것을 방해하는 몇 가지 사실들이 남아 있다. 추가적인 요구사항이 없는 요소들이라고 해서 모두 <code>HTMLElement</code>가 되는 것은 아니다. 예를 들어서 <code>&#x3C;span></code>요소는 <code>HTMLSpanElement</code>라는 고유 DOM 인터페이스를 가지고 있다.</p>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/API/HTMLSpanElement\"><code>HTMLSpanElement</code>는 <code>&#x3C;span></code>요소를 나타낼 뿐 부가적인 프로퍼티나 메서드가 없다.</a> <a href=\"https://html.spec.whatwg.org/multipage/text-level-semantics.html#htmlspanelement\">스펙에서도 global attribute와 함께 쓰였을 때 유용할 수 있다고만 되어 있다.</a></p>\n<p>옛날의 HTML 표준이야 어차피 아무도 안 지키는 걸로 유명했고 지금은 없던 무언가 여러가지가 있던 시절이었으니 그럴 수도 있다.</p>\n<p><img src=\"/static/your-opposite-cae67b70.png\" alt=\"웹 개발자들은 HTML 표준을 안 지키기로 유명하다\">\n<a href=\"https://gigglehd.com/gg/bbs/13526687\">사진 출처</a></p>\n<p>하지만 상대적으로 꽤 최근이고 표준도 안정화된 HTML5에서 도입된 <code>&#x3C;picture></code> 요소는 어떤가? 이 요소 또한 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/HTMLPictureElement\">HTMLPictureElement라는 DOM 인터페이스를 따로 가지지만 HTMLElement에 비해 특별한 인터페이스 요구사항을 가지고 있지는 않다.</a> 시간이 부족해서 찾지는 못했지만 분명 추가적인 요구사항이 없지만 DOM 인터페이스를 가지는 요소들이 더 있을 것이다.</p>\n<p>그럼 이것들은 왜 따로 요소들을 가지고 있을까? 시원한 해설은 찾지 못했으나, 조사를 통해 <code>&#x3C;span></code>과 <code>&#x3C;picture></code>에 대해서만 추측해보았다. 결론적으로는 어떤 상황에 대한 대비책으로 만들어 놓았다고 생각한다.</p>\n<h2>3.1. picture</h2>\n<p><code>&#x3C;picture></code>요소는 여러 여러 source를 감싸도록 하여 브라우저가 고를 수 있는 사진 소스들을 제공한다. 이를 다루는 내용은 <a href=\"https://witch.work/posts/html-responsive-image#3.-%EC%95%84%ED%8A%B8-%EB%94%94%EB%A0%89%EC%85%98-%EB%AC%B8%EC%A0%9C%EC%99%80-picture\">HTML로 반응형 이미지 가져오기</a>나 MDN 문서를 참고할 수 있다.</p>\n<p>이는 물론 특별한 DOM 인터페이스 요구사항이 없어서 <code>HTMLElement</code>에 비해 다를 바가 없지만, 이미지를 다룬다는 점에서 충분히 새로운 요구사항이 생길 수 있고 이를 대비해서 만든 것으로 보인다.</p>\n<p>실제로 이에 대한 제안이 있었다. <code>&#x3C;picture></code>에 대응하는 <code>HTMLPictureElement</code>를 만들고 내부의 이미지를 제어하는 어떤 프로퍼티나 이벤트를 넣자는 것이었다. 그리고 이 제어 로직은 쉐도우 DOM에 넣고 말이다. <code>&#x3C;picture></code>의 자식으로 <code>&#x3C;img></code>를 필수적으로 넣게 하자는 이야기도 해당 흐름에서 나왔다.</p>\n<blockquote>\n<p>Can we hide the \"controlling\" <code>&#x3C;img></code> in shadow DOM? And make<br>\nHTMLPictureElement the interface that proxies relevant properties/events<br>\nto the internal <code>&#x3C;img></code>?</p>\n<p>W3C Mailing List, [whatwg] <code>&#x3C;picture></code> redux\n<a href=\"https://lists.w3.org/Archives/Public/public-whatwg-archive/2013Nov/0295.html\">https://lists.w3.org/Archives/Public/public-whatwg-archive/2013Nov/0295.html</a></p>\n</blockquote>\n<p>물론 이 제안은 <code>HTMLPictureElement</code>에 추가 인터페이스가 없는 것을 보아 기각당한 듯 하지만 이런 식으로 picture 요소에도 무언가를 추가하려는 시도가 분명 있었다. 이런 시도들로 말미암아 어떤 가능성에 대비하는 개념으로 <code>HTMLPictureElement</code>가 만들어진 것으로 추측해 본다.</p>\n<h2>3.2. span</h2>\n<p>span은 언제쯤부터 사용되기 시작했을까? <a href=\"https://caniuse.com/?search=span\">caniuse</a>를 참고하면 2010년대에 들어서서야 대부분 지원되기 시작했고 지원된다고 해서 바로 대중적으로 쓰이지는 않는 특성상 2010년대 초반은 지나서야 많이 쓰이기 시작했을 거라고 추측한다.</p>\n<p>그러면 그때 웹에는 무슨 일이 있었을까? 웹 컴포넌트가 핫하게 떠오르고 있었다. React나 여러 컴포넌트 기반의 프레임워크들이 나오면서 비즈니스가 특정 기술에 묶여 버리게 되었고 웹 컴포넌트가 이를 극복하기 위한 기술로써 주목받고 있었다.</p>\n<p>자세한 내용은 나중에 기회가 되면 글을 쓰겠지만, 마치 예전의 React class component와 비슷하게 HTMLElement를 확장한 클래스를 이용해 JS를 HTML처럼 쓸 수 있게 해주는 개념이었다.</p>\n<pre><code class=\"language-js\">class XSearch extends HTMLElement {\n  connectedCallback() {\n    const mountPoint = document.createElement('span');\n    this.attachShadow({ mode: 'open' }).appendChild(mountPoint);\n\n    const name = this.getAttribute('name');\n    const url = 'https://www.google.com/search?q=' + encodeURIComponent(name);\n    const root = ReactDOM.createRoot(mountPoint);\n    root.render(&#x3C;a href={url}>{name}&#x3C;/a>);\n  }\n}\ncustomElements.define('x-search', XSearch);\n</code></pre>\n<p>이렇게 만들어 놓으면 다음과 같이 쓸 수 있었다.</p>\n<pre><code class=\"language-html\">&#x3C;x-search name=\"Web Components\">&#x3C;/x-search>\n</code></pre>\n<p>이는 React나 Vue같은 다른 프레임워크와 함께 쓸 수도 있었고 나름대로 여러가지 장점이 있는 기술이었다. 그런데 문제는 IE11보다 낮은 버전의 브라우저에서는 이 기술을 사용할 수 없었다. 그렇게 될 경우 그대로 내부 HTML을 렌더링하게 되었었다.</p>\n<p>이럴 땐 레거시 브라우저가 custom element를 이해하지 못할 때 이를 취급하는 인터페이스인 <code>HTMLUnknownElement</code>에도 스타일을 입힐 수 있으므로 fallback HTML을 자식으로 넣어두는 방식을 쓸 수 있었다.(물론 레거시 브라우저를 고려해야 할 때의 이야기다)</p>\n<pre><code class=\"language-html\">&#x3C;current-time>\n    /* fallback html */\n    13:00\n&#x3C;/current-time>\n</code></pre>\n<p>이때 fallback HTML로 잘 쓸 수 있었던 것이 <code>&#x3C;span></code>요소였다. custom element를 지원하지 않는 레거시 브라우저에서는 해당 요소가 <code>HTMLUnknownElement</code>로 취급되었는데 이는 <code>HTMLElement</code>를 상속하고 있었고 따라서 <code>HTMLElement</code>의 display 기본값인 <code>inline</code>을 가지고 있었다.</p>\n<p>그런데 custom element의 fallback HTML로 그냥 <code>HTMLElement</code>를 상속하는 요소를 아무거나 쓰기는 어려웠다.</p>\n<p>예를 들어 <code>&#x3C;b></code>와 같은 태그도 <code>HTMLElement</code>이지만 굵은 글씨 스타일이 기본적으로 적용되었기 때문에 fallback HTML로 쓰려면 해당 스타일을 따로 만져 줘야 해서 번거로웠을 것이다.</p>\n<p>당시 개발자들이 생각하기에 fallback HTML로 가장 적절했던 태그가 <code>&#x3C;span></code>이 아니었을까 하고 나는 생각한다. <code>HTMLSpanElement</code>도 custom element처럼 <code>HTMLElement</code>를 상속하며, <code>display:inline</code>값을 가지는 인터페이스이며 심지어 <a href=\"https://caniuse.com/?search=htmlspanelement\">IE11 이하에서도 사용 가능하기 때문이다.</a></p>\n<p><a href=\"https://stackoverflow.com/questions/6854757/custom-tags-not-working-in-ie8/6854813#6854813\">그리고 사실 IE8 미만의 브라우저에서는 이런 custom element를 만들 수는 있었지만 지원이 끔찍했기 때문에 custom element 대신 <code>&#x3C;span></code>요소를 쓰는 것이 권장되고 있었다.</a></p>\n<p>custom element의 레거시 브라우저 지원을 위한 fallback HTML 역할도 잘 수행하고, 심지어 그 대체품 역할까지 해내는 게 <code>&#x3C;span></code>이었다. 이 정도면 다른 태그들에 비해서 뭔가 좀 더 추가될 가능성이 있었기에 미래의 어떤 가능성에 대비해서 따로 DOM 인터페이스를 만들어 놓았던 것이 아닐까 하고 추측한다.</p>\n<h2>3.3. 여담</h2>\n<p>W3C의 메일링 아카이브에는 이런 추가적인 DOM 인터페이스에 대한 몇 가지 논의가 있었다. 지금 보면 신기한 것들도 있다.</p>\n<p><a href=\"https://lists.w3.org/Archives/Public/public-whatwg-archive/2004Nov/0095.html\">예를 들어서 <code>&#x3C;section></code>의 DOM 인터페이스를 제안하는 것이 있었는데 여기서는 <code>HTMLSectionElement</code>라는 DOM 인터페이스를 제안하며 해당 section의 제목을 나타내는 <code>headingElement</code>이라는 프로퍼티를 가지도록 하자는 논의가 있었다. 물론 기각당했다.</a></p>\n<h1>참고</h1>\n<p><a href=\"https://stackoverflow.com/questions/65721709/why-is-there-no-htmlsectionelement-and-no-htmlarticleelement-in-javascript\">https://stackoverflow.com/questions/65721709/why-is-there-no-htmlsectionelement-and-no-htmlarticleelement-in-javascript</a></p>\n<p><a href=\"https://stackoverflow.com/questions/36268712/htmlspanelement-vs-htmlunknownelement\">https://stackoverflow.com/questions/36268712/htmlspanelement-vs-htmlunknownelement</a></p>\n<p><a href=\"https://stackoverflow.com/questions/6854757/custom-tags-not-working-in-ie8\">https://stackoverflow.com/questions/6854757/custom-tags-not-working-in-ie8</a></p>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/API/HTMLDivElement\">https://developer.mozilla.org/ko/docs/Web/API/HTMLDivElement</a></p>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/API/HTMLSpanElement\">https://developer.mozilla.org/ko/docs/Web/API/HTMLSpanElement</a></p>\n<p>커스텀 요소 만들기 <a href=\"https://ui.toast.com/posts/ko_20170609\">https://ui.toast.com/posts/ko_20170609</a></p>\n<p><a href=\"https://meetup.nhncloud.com/posts/115\">https://meetup.nhncloud.com/posts/115</a></p>\n<p>W3C 퍼블릭 메일링 아카이브 <a href=\"https://lists.w3.org/Archives/Public/\">https://lists.w3.org/Archives/Public/</a></p>\n<p><a href=\"https://lists.w3.org/Archives/Public/public-whatwg-archive/2013Nov/0296.html\">https://lists.w3.org/Archives/Public/public-whatwg-archive/2013Nov/0296.html</a></p>\n<p><a href=\"https://yozm.wishket.com/magazine/detail/1193/\">https://yozm.wishket.com/magazine/detail/1193/</a></p>\n<p><a href=\"https://legacy.reactjs.org/docs/web-components.html\">https://legacy.reactjs.org/docs/web-components.html</a></p>",
    "excerpt": "들어가면서\n며칠에 걸쳐 조사를 진행했으나 솔직히 이 글에서 제기하는 작은 의문에 대해서 완전히 속시원한 대답을 찾지는 못했다. 대부분은 설명할 수 있었지만 몇 가지는 하지 못했다. 웹 스펙의 역사적인 이유라고밖에는 설명할 수 없을 것들이라고 생각한다.\n혹시 누군가가 HTML의 어떤 요소는 왜 HTMLElement이고, 어떤 요소는 특별한 추가 요구사항이 없는데도 HTML 요소의 인터페이스가 따로 존재하는지에 대한 명쾌한 기준을 알고 있거나 이 역사를 알고 있다면",
    "headingTree": [
      {
        "title": "들어가면서",
        "url": "#들어가면서",
        "items": []
      },
      {
        "title": "1. 의문",
        "url": "#1-의문",
        "items": []
      },
      {
        "title": "2. 탐구",
        "url": "#2-탐구",
        "items": []
      },
      {
        "title": "3. 반례들에 대한 약간의 탐구",
        "url": "#3-반례들에-대한-약간의-탐구",
        "items": [
          {
            "title": "3.1. picture",
            "url": "#31-picture",
            "items": []
          },
          {
            "title": "3.2. span",
            "url": "#32-span",
            "items": []
          },
          {
            "title": "3.3. 여담",
            "url": "#33-여담",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 2,
      "wordCount": 517
    },
    "url": "/posts/html-dom-missing-element",
    "thumbnail": {
      "local": "/static/your-opposite-cae67b70.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-your-opposite-cae67b70-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAADCAIAAAAhqtkfAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAU0lEQVR4nGOoaGqrLMxXVNM2MjLg5+cXFBTk4eFhYGBgOHPv3v+n2y11NTOzc1NSUpydnWVlZbm4uBgkeLnSfFylpaSsra3t7e01NDRkZWWFhIQA6n8RqVa2l9oAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "html-form-styling",
    "title": "폼 요소 스타일링하기",
    "date": "2023-08-15T03:00:00Z",
    "description": "폼 요소는 어떻게 스타일링해야 할까?",
    "tags": [
      "HTML"
    ],
    "html": "<h1>1. 역사</h1>\n<p>1995년 HTML2 표준이 form 요소를 도입하였다. 하지만 CSS는 1996년에 나왔고, 나온 이후에도 대부분의 브라우저가 이를 당장 지원하지는 않았다.</p>\n<p>그리고 이미 브라우저들에서는 form 요소를 자체적으로 렌더링하고 있었기 때문에 초기에는 form 요소에 CSS를 적용 가능하게 하는 것에 의욕적이지 않았다.</p>\n<p>하지만 시간이 지나면서 form 요소들도 몇몇을 제외하고는 대부분 스타일링 가능하게 되었다.</p>\n<p>물론 color picker와 같이 CSS만으로는 스타일링하기 힘든 것들도 아직 있다. CSS로 쉽게 스타일링할 수 있는 것부터 시작해서, form 요소들의 스타일링을 정복해보자.</p>\n<h1>2. 스타일링이 쉬운 요소들</h1>\n<p>다음과 같은 요소들은 쉽게 스타일링할 수 있다.</p>\n<p><code>&#x3C;form></code>, <code>&#x3C;fieldset></code>, <code>&#x3C;legend></code>, <code>&#x3C;input>(type=\"search\" 제외)</code>, <code>&#x3C;textarea></code>, <code>&#x3C;button></code>, <code>&#x3C;label></code>, <code>&#x3C;output></code></p>\n<p>체크박스와 라디오버튼, <code>&#x3C;input type=\"search\"></code>는 스타일링하려면 약간 복잡한 CSS를 써야 한다. <code>&#x3C;select></code>와 일부 input type들은 브라우저마다 매우 다른 기본 스타일을 가지고 있고 어느 정도 스타일링이 가능하지만 원천적으로 스타일링 불가능한 부분들도 있다.</p>\n<p>상황에 따라서는 스타일링이 상대적으로 쉬운 다른 컴포넌트들을 이용해서 같은 기능을 구현하는 게 더 나은 선택일 수 있다. 하지만 브라우저별로 생길 약간의 차이를 감수할 수 있다면 크기, 배경 등의 몇 가지 스타일링은 할 수 있다.</p>\n<p>쉽게 할 수 있는 요소들은 넘어가고, 어려운 것들만 알아보자. 그리고 우리가 무엇을 할 수 있고 무엇을 할 수 없는지 알아보자.</p>\n<h1>3. 사전 작업</h1>\n<p>CSS 폰트 관련 CSS는 어떤 요소에서든 쉽게 사용할 수 있다. 하지만 몇몇 폼 요소에서 <code>font-family</code>와 <code>font-size</code>를 부모로부터 상속하지 않는 브라우저들이 있다. 많은 브라우저가 이 요소들에서 시스템의 기본 폰트를 사용하도록 한다.</p>\n<p>따라서 다음처럼 폼 요소들의 스타일을 지정해 준다.</p>\n<pre><code class=\"language-css\">button,\ninput,\nselect,\ntextarea {\n  font-family: inherit;\n  font-size: 100%;\n}\n</code></pre>\n<p><code>&#x3C;input type=\"submit\"></code>이 예외적으로 <code>font-family</code>를 상속하지 않는 브라우저가 있다. 이런 부분을 대비하기 위해서는 <code>&#x3C;button></code> 태그를 사용하자.</p>\n<p>그리고 각 폼 요소들은 각자의 기본적인 테두리, 패딩, 마진 규칙이 있기 때문에 이를 초기화해주는 것도 좋다. 물론 시스템의 기본 스타일을 사용하는 게 좋은지 아니면 커스텀하는 게 좋은지는 많은 토의가 있기 때문에 어느 정도는 개발자의 결정이다.</p>\n<pre><code class=\"language-css\">input,\ntextarea,\nselect,\nbutton {\n  padding: 0;\n  margin: 0;\n  box-sizing: border-box;\n}\n</code></pre>\n<h2>3.1. appearance</h2>\n<p>이 CSS는 운영체제에 기반한 UI의 기본 스타일을 적용할지를 결정한다.</p>\n<pre><code class=\"language-css\">appearance: none;\nappearance: auto;\n</code></pre>\n<p>보통은 <code>none</code> 값으로만 지정할 것이다. 이렇게 지정하면 시스템의 스타일링을 무력화하고 내가 원하는 스타일링을 적용할 수 있다. 아예 디자인을 백지로 만드는 거라고 생각하면 된다.</p>\n<h1>4. 몇몇 요소들의 스타일링</h1>\n<h2>4.1. search box 스타일링</h2>\n<p>검색 박스를 보자.</p>\n<pre><code class=\"language-html\">&#x3C;input type=\"search\" />\n</code></pre>\n<p>사파리에서는 이러한 검색 박스에 대해 몇 가지 스타일링 제한이 있다. 가령 높이나 글씨 크기를 마음대로 바꿀 수 없다.</p>\n<p>이를 해결하기 위해서는 <code>appearance</code> 속성을 <code>none</code>으로 지정해야 한다. 이렇게 하고 나서 스타일링해주면 된다.</p>\n<pre><code class=\"language-css\">input[type=\"search\"] {\n  appearance: none;\n}\n</code></pre>\n<p>혹은 border나 background CSS를 지정해주는 것도 이런 스타일링 제한 문제를 해결하는 방법이다.</p>\n<h2>4.2. 체크박스, 라디오버튼 스타일링</h2>\n<p>체크박스, 라디오버튼의 사이즈는 기본적으로 조절이 안 되도록 되어 있다. 이를 조절하려고 할 시 브라우저에서 해당 요소를 어떻게 렌더링하는지는 브라우저마다 매우 다르다.</p>\n<p>조절할 수 있는 건 활성화되었을 때의 색 정도인데, 이는 <code>accent-color</code> CSS 속성을 통해서 조절할 수 있다. 하지만 본격적으로 스타일을 바꾸려고 하면 <code>appearance</code> 속성을 <code>none</code>으로 지정하고 처음부터 스타일링을 해야 한다.</p>\n<p>먼저 예시 HTML을 다음과 같이 작성하였다.</p>\n<pre><code class=\"language-html\">&#x3C;form>\n  &#x3C;fieldset>\n    &#x3C;legend>체크박스와 라디오 버튼&#x3C;/legend>\n    &#x3C;p>\n      주문할 케이크 고르기\n    &#x3C;/p>\n    &#x3C;input type=\"checkbox\" name=\"cake\" value=\"choco\" id=\"choco\" />\n    &#x3C;label for=\"choco\">초코&#x3C;/label>\n    &#x3C;input type=\"checkbox\" name=\"cake\" value=\"strawberry\" id=\"strawberry\" />\n    &#x3C;label for=\"strawberry\">딸기&#x3C;/label>\n    &#x3C;input type=\"checkbox\" name=\"cake\" value=\"vanilla\" id=\"vanilla\" />\n    &#x3C;label for=\"vanilla\">바닐라&#x3C;/label>\n\n    &#x3C;p>\n      케이크와 함께 주문할 커피 고르기\n    &#x3C;/p>\n\n    &#x3C;input type=\"radio\" name=\"coffee\" value=\"americano\" id=\"americano\" />\n    &#x3C;label for=\"americano\">아메리카노&#x3C;/label>\n    &#x3C;input type=\"radio\" name=\"coffee\" value=\"latte\" id=\"latte\" />\n    &#x3C;label for=\"latte\">라떼&#x3C;/label>\n    &#x3C;input type=\"radio\" name=\"coffee\" value=\"mocha\" id=\"mocha\" />\n    &#x3C;label for=\"mocha\">모카&#x3C;/label>\n  &#x3C;/fieldset>\n&#x3C;/form>\n</code></pre>\n<p>기본적으로 appearance 속성을 none으로 지정.</p>\n<pre><code class=\"language-css\">input[type=\"checkbox\"],\ninput[type=\"radio\"] {\n  appearance: none;\n}\n</code></pre>\n<p>이러면 체크박스 혹은 라디오버튼이 있어야 할 자리에 아무것도 뜨지 않는다. 이제 한번 스타일링을 해보자.</p>\n<p>체크박스의 경우 체크가 된 박스에 체크 표시를, 라디오버튼의 경우 선택된 항목에 원을 그린다. 이를 구현하면 된다.</p>\n<p>여러가지 방법이 있겠지만, <code>::before</code>를 사용하여 요소를 하나 만들고, 여기의 content에 유니코드를 넣어서 체크 여부에 따라 표시되고 아니고를 결정하도록 하였다.</p>\n<p>레이아웃이 다시 계산되는 것을 막기 위해서 <code>display:none</code> 대신 <code>visibility: hidden</code>을 사용하였다. 다음과 같이 CSS를 작성한다. CSS를 깔끔하게 작성한다는 면에서도, 디자인 면에서도 그렇게 잘 짜인 코드는 아니다. 하지만 요점은 이런 식으로 체크박스와 라디오버튼을 기초부터 스타일링이 가능하다는 것이다.</p>\n<pre><code class=\"language-css\">input[type=\"checkbox\"],\ninput[type=\"radio\"] {\n  appearance: none;\n  position: relative;\n  width: 1.5rem;\n  height: 1.5rem;\n  border: 1px solid #ccc;\n  cursor: pointer;\n  vertical-align: -2px;\n  color:violet;\n}\n\ninput[type=\"checkbox\"]::before,\ninput[type=\"radio\"]::before {\n  position: absolute;\n  font-size: 1.2rem;\n  right: 1px;\n  top: -10px;\n  visibility: hidden;\n}\n\ninput[type=\"checkbox\"]:checked::before,\ninput[type=\"radio\"]:checked::before {\n  visibility: visible;\n}\n\ninput[type=\"checkbox\"]{\n  border-radius: 5px;\n}\n\ninput[type=\"radio\"]{\n  border-radius: 50%;\n}\n\ninput[type=\"checkbox\"]::before {\n  content: \"✔\";\n  top: -2px;\n}\n\ninput[type=\"radio\"]::before {\n  content: \"●\";\n  font-size: 2rem;\n}\n</code></pre>\n<p>이렇게 스타일링한 결과는 다음과 같다.</p>\n<p><img src=\"/static/checkbox-radio-style-238f3fdb.png\" alt=\"체크박스와 라디오버튼 스타일링 결과\"></p>\n<h2>4.3. select</h2>\n<p>select의 스타일링에 문제되는 부분은 2가지가 있다. 이를 알아보기 위해서 먼저 커피를 고르는 select 요소를 한번 만들어 보자.</p>\n<pre><code class=\"language-html\">&#x3C;form>\n  &#x3C;fieldset>\n    &#x3C;legend>Select&#x3C;/legend>\n    &#x3C;label for=\"coffeeSelection\">커피 고르기&#x3C;/label>\n    &#x3C;select id=\"coffeeSelection\">\n      &#x3C;option value=\"americano\">아메리카노&#x3C;/option>\n      &#x3C;option value=\"latte\">라떼&#x3C;/option>\n      &#x3C;option value=\"mocha\">모카&#x3C;/option>\n    &#x3C;/select>\n&#x3C;/form>\n</code></pre>\n<p>첫째는 select가 드롭다운으로 작동함을 나타내는 화살표를 스타일링하는 부분이다. 이 화살표는 브라우저마다 다르며 select 박스의 크기가 변할 때마다 바뀌거나 이상하게 리사이징될 수 있다.</p>\n<p>이 문제는 <code>appearance: none</code>으로 기본 화살표를 없앤 후 새로 만드는 것으로 어느 정도 해결할 수 있다. 하지만 따로 화살표 아이콘을 사용하고 싶다든가, 화살표 영역까지 클릭하도록 하는 등의 조작이 필요하다면 순수 CSS로는 무리이며 JS를 사용하거나 select에 해당하는 요소를 직접 제작해야 한다.</p>\n<p>우리가 할 수 있는 것을 해보자. 일단 아이콘을 없애기 위해 <code>appearance: none</code>을 지정한다. 그러면 화살표 아이콘과 마진 등이 사라진다.</p>\n<p>그다음 직접 아이콘을 만들자. 이를 위해서 <code>::before</code>과 <code>::after</code>를 사용할 것인데 그러려면 div 등의 태그로 select의 래퍼를 만들어 주어야 한다.</p>\n<p>이는 <code>::after</code>와 같은 요소들은 요소의 포매팅 박스에 상대적으로 배치되는데 select는 <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/Replaced_element\">replaced element</a>처럼 작동하여 document style이 아니라 브라우저에 의해서 배치되고 따라서 이러한 포매팅 박스를 가지고 있지 않기 때문이다.</p>\n<p>래퍼를 만들어 주고 여기에 <code>::after</code>를 적용해서 스타일링하자.</p>\n<pre><code class=\"language-html\">&#x3C;form>\n  &#x3C;fieldset>\n    &#x3C;legend>Select&#x3C;/legend>\n    &#x3C;label for=\"coffeeSelection\">커피 고르기&#x3C;/label>\n    &#x3C;div class=\"select-wrapper\">\n      &#x3C;select class=\"select\" id=\"coffeeSelection\">\n        &#x3C;option value=\"americano\">아메리카노&#x3C;/option>\n        &#x3C;option value=\"latte\">라떼&#x3C;/option>\n        &#x3C;option value=\"mocha\">모카&#x3C;/option>\n      &#x3C;/select>\n    &#x3C;/div>\n&#x3C;/form>\n</code></pre>\n<pre><code class=\"language-css\">select{\n  appearance:none;\n  width:100%;\n  height:100%;\n}\n\n.select-wrapper{\n  position:relative;\n  width:100px;\n  height:30px;\n}\n\n.select-wrapper::after{\n  content: \"▼\";\n  font-size: 1rem;\n  top: 6px;\n  right: 10px;\n  position: absolute;\n  color: violet;\n}\n</code></pre>\n<p>이러면 아래 방향의 삼각형 화살표가 보라색으로 새로 생긴다.</p>\n<p>두번째 문제는 select를 눌렀을 때 나오는, option들이 들어간 박스를 커스텀할 수 없다는 문제이다. 부모로부터 폰트는 상속하도록 할 수 있지만 간격이나 글씨 색상 등을 조절할 수는 없다. 참고로 이는 <code>&#x3C;datalist></code> 태그에 대해서도 마찬가지다.</p>\n<p>이 부분은 <code>&#x3C;select></code> 요소에서 해결할 수 없다. 이 부분을 해결하고 싶다면 커스텀 select를 지원하는 라이브러리를 쓰거나, 선택 상자를 직접 만들어야 한다.</p>\n<h2>4.4. file input</h2>\n<pre><code class=\"language-html\">&#x3C;form>\n  &#x3C;fieldset>\n    &#x3C;legend>File Input&#x3C;/legend>\n    &#x3C;label class=\"fileInputLabel\" for=\"fileInput\">파일 고르기&#x3C;/label>\n    &#x3C;input type=\"file\" id=\"fileInput\" />\n  &#x3C;/fieldset>\n&#x3C;/form>\n</code></pre>\n<p>file input의 문제는 파일 탐색기를 여는 버튼이 완전히 스타일링 불가능하다는 것이다. 사이즈 조절이나 색, 폰트조차 변경이 불가능하다.</p>\n<p>따라서 이를 스타일링하기 위해서는 input의 label도 input과 연관되어 작동한다는 것을 이용하자. input에 대응되는 label을 스타일링하고, input을 숨겨버리자.</p>\n<p>label에 class를 준 것에 주의하자.</p>\n<pre><code class=\"language-css\">input[type=\"file\"]{\n  display: none;\n}\n\n.fileInputLabel{\n  box-shadow: 1px 1px 3px #ccc;\n  border: 1px solid #ccc;\n  border-radius: 3px;\n  text-align: center;\n  line-height: 1.5;\n  padding: 10px 20px;\n}\n\n.fileInputLabel:hover{\n  cursor: pointer;\n  background-color: #eee;\n}\n</code></pre>\n<p>이러면 못생긴 파일 올리기 버튼이 아니라 <code>파일 고르기</code>라고 쓰인 흰색 버튼이 나오고 그걸 눌렀을 때 파일 탐색기가 뜨는 것을 볼 수 있다.</p>\n<h2>4.5. range input</h2>\n<p>range input의 bar를 스타일링하는 건 쉬운 일이지만 handle을 스타일링하는 건 매우 어렵다. 다음과 같은 HTML을 먼저 보자.</p>\n<pre><code class=\"language-html\">&#x3C;form>\n  &#x3C;fieldset>\n    &#x3C;legend>Range Input&#x3C;/legend>\n    &#x3C;label class=\"rangeLabel\" for=\"range\">범위 입력기&#x3C;/label>\n    &#x3C;input type=\"range\" id=\"range\" />\n  &#x3C;/fieldset>\n&#x3C;/form>\n</code></pre>\n<p>그리고 bar는 다음과 같이 스타일링할 수 있다.</p>\n<pre><code class=\"language-css\">input[type=\"range\"]{\n  appearance: none;\n  background: violet;\n  height:3px;\n  padding: 0;\n  border:1px solid transparent;\n}\n</code></pre>\n<p>이렇게 하면 범위 입력은 보라색 bar에서 이루어지게 된다. handle을 스타일링하려면 <code>::-webkit-slider-thumb </code>과 같은 브라우저에서 자체적으로 지원하는 의사 요소를 사용해야 한다.</p>\n<p>이다음 CSS는 <a href=\"https://css-tricks.com/styling-cross-browser-compatible-range-inputs-css/\">Styling Cross-Browser Compatible Range Inputs with CSS</a>를 참고하여 작성되었다.</p>\n<pre><code class=\"language-css\">/* range input bar\n크로스 브라우징을 위해서는\n::webkit-slider-runnable-track\n::-moz-range-track\n::-ms-track 등에도 같은 속성 적용\n*/\ninput[type=\"range\"]{\n  appearance: none;\n  background: red;\n  height: 2px;\n  padding:0;\n  border:1px solid transparent;\n}\n\n/* range input의 thumb(handle) - Webkit */\n/*\nfirefox는 ::-moz-range-thumb\nIE는 ::-ms-thumb\n*/\ninput[type=\"range\"]::-webkit-slider-thumb {\n  appearance: none;\n  border:none;\n  height: 20px;\n  width: 15px;\n  border-radius: 3px;\n  background: palevioletred;\n  cursor: pointer;\n  box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d;\n}\n</code></pre>\n<h1>5. 스타일링이 불가능한 요소들</h1>\n<h2>5.1. date input</h2>\n<p>input 태그의 <code>type=\"datetime-local\"</code>, <code>type=\"time\"</code>, <code>type=\"week\"</code>, <code>type=\"month\"</code>와 같이 날짜와 시간을 입력하는 input들은 다른 input과 같이 기본 input box 스타일링은 쉽다. 박스의 크기, 색깔 등 말이다.</p>\n<p>하지만 input을 클릭시 나오는 datepicker, timepicker는 아예 스타일링을 따로 할 수 없고, 브라우저마다 기본 스타일링이 조금씩 다르며 <code>appearance:none</code>으로 스타일링을 제거할 수도 없다.</p>\n<p>따라서 picker 부분을 스타일링하고 싶다면 직접 이를 만들어야 한다.</p>\n<h2>5.2. number input</h2>\n<p>number input은 spinner를 기본적으로 제공하고, 이는 위의 date input과 같은 문제로 스타일링이 불가능하다.</p>\n<p>하지만 데이터가 숫자로 제한되는 비슷한 input인 <code>type=\"tel\"</code>을 사용하면 된다. 이를 쓰면 같은 text input을 제공하면서 숫자로 데이터를 제한하고, 모바일 디바이스에서 숫자 키패드를 제공한다.</p>\n<h2>5.3. color input</h2>\n<p>border, padding 등은 없앨 수 있지만 color picker는 원천적으로 스타일링 불가능하다.</p>\n<h2>5.4. meter, progress</h2>\n<p>이 요소들은 잘 쓰이지도 않으면서 스타일링은 끔찍하게 어렵다. 이걸 스타일링하는 것보다는 직접 비슷한 요소를 만드는 게 좋은 선택이다.</p>\n<p>이런 요소들을 위해 커스텀 요소를 직접 만드는 법을 이후에 다룰 것이다.</p>\n<h1>6. 의사 클래스 셀렉터를 이용한 스타일링</h1>\n<p>CSS를 다뤄보았다면 <code>:hover</code>, <code>:focus</code>와 같은 의사 클래스 셀렉터에 대해서는 이미 알고 있을 것이다. 그러나 폼 요소들에 쓰이는 다른 의사 클래스 셀렉터들도 있다. 이들을 사용례를 통해서 알아보자.</p>\n<h2>6.1. 필수 제출 요소 나타내기</h2>\n<p>회원가입 요소를 만든다고 가정하자. 이때 필수로 제출해야 하는 요소들이 있다. 이를 나타내기 위해서는 <code>required</code> 속성을 사용한다.</p>\n<pre><code class=\"language-html\">&#x3C;form>\n  &#x3C;fieldset>\n    &#x3C;legend>회원 가입&#x3C;/legend>\n      &#x3C;div>\n        &#x3C;label for=\"email\">Email&#x3C;/label>\n        &#x3C;input type=\"email\" id=\"email\" required/>\n      &#x3C;/div>\n      &#x3C;div>\n        &#x3C;label for=\"password\">Password&#x3C;/label>\n        &#x3C;input type=\"password\" id=\"password\" required/>\n      &#x3C;/div>\n      &#x3C;div>\n        &#x3C;label for=\"password-check\">Password 확인&#x3C;/label>\n        &#x3C;input type=\"password\" id=\"password-check\" required />\n      &#x3C;/div>\n      &#x3C;div>\n        &#x3C;label for=\"name\">이름&#x3C;/label>\n        &#x3C;input type=\"text\" id=\"name\" />\n      &#x3C;/div>\n\n      &#x3C;div>\n        &#x3C;label for=\"birth\">생년월일&#x3C;/label>\n        &#x3C;input type=\"date\" id=\"birth\" />\n      &#x3C;/div>\n      \n      &#x3C;button type=\"submit\">회원가입&#x3C;/button>\n  &#x3C;/fieldset>\n&#x3C;/form>\n</code></pre>\n<p>이러면 <code>:required</code>와 <code>:optional</code> 의사 클래스 셀렉터를 사용할 수 있다. 이를 통해서 필수 제출 요소와 선택 제출 요소를 구분할 수 있다.</p>\n<pre><code class=\"language-css\">input:required{\n    border: 1px solid green;\n}\n\ninput:optional{\n    border: 1px solid red;\n}\n</code></pre>\n<p>이렇게 하면 필수 제출 요소는 초록색 테두리가 생기고, 선택 제출 요소는 빨간색 테두리가 생긴다. 하지만 이렇게 하면 접근성도 떨어지고, 필수 제출 요소를 나타내는 일반적인 컨벤션은 <code>*</code>을 사용하거나 <code>required</code>라는 텍스트를 붙이는 것임을 생각할 때 그렇게 좋은 방식도 아니다.</p>\n<p>따라서 <code>::after</code> 의사 요소를 이용하여 필수 제출 요소를 나타내는 것이 좋다.</p>\n<p>일단 <code>::after</code>의사 요소는 요소의 box에 상대적으로 배치되는데 input 요소도 replaced element에 가깝게 동작하기 때문에 box가 없고 따라서 <code>::after</code>를 제대로 사용하기 위한 span을 더해주자. 이를테면 다음과 같이.</p>\n<pre><code class=\"language-html\">&#x3C;div>\n  &#x3C;label for=\"email\">Email&#x3C;/label>\n  &#x3C;input type=\"email\" id=\"email\" required/>\n  &#x3C;span>&#x3C;/span>\n&#x3C;/div>\n</code></pre>\n<p>그리고 다음과 같이 필수 제출 요소의 뒤에 오는 span 요소에 <code>::after</code>를 사용하여 <code>required</code>문구를 추가할 수 있다. 배치에는 <code>position: absolute</code>를 사용하였다.</p>\n<pre><code class=\"language-css\">input:required{\n    border: 1px solid green;\n}\n\ninput:optional{\n    border: 1px solid red;\n}\n\ninput + span {\n  position: relative;\n}\n\ninput:required + span::after {\n  font-size: 0.7rem;\n  position: absolute;\n  content: \"required\";\n  color: white;\n  background-color: black;\n  padding: 2px 10px;\n  left: 10px;\n}\n</code></pre>\n<p>이러면 좀 못생긴 <code>required</code>라는 텍스트가 필수 제출 요소 뒤에 나타나게 된다.</p>\n<h2>6.2. 데이터 유효성 스타일링</h2>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Constraint_validation\">https://developer.mozilla.org/en-US/docs/Web/HTML/Constraint_validation</a></p>\n<p>폼 요소의 데이터가 유효한지에 따라 스타일링하는 것도 자주 쓰인다. HTML5에서 도입된 새로운 input type들로 인해 유효성 검증도 좀더 쉬워졌다.</p>\n<p>예를 들어서 <code>&#x3C;input type=\"email\"></code>의 경우 이메일 형식이 아니면 데이터가 유효하지 않다고 판단할 수 있다. 이런 경우 <code>:valid</code>와 <code>:invalid</code> 의사 클래스 셀렉터를 사용할 수 있다.</p>\n<p>이 역시 다른 셀렉터들과 같이 사용할 수 있는데, 예를 들어 <code>::after</code>를 이용해서 현재 유효 상태를 나타낼 수 있다. 이를 제대로 쓰기 위해서 위에서 했던 것처럼 빈 <code>&#x3C;span></code>태그를 사용했다.</p>\n<pre><code class=\"language-css\">input + span {\n  position: relative;\n}\n\ninput + span::before{\n  position: absolute;\n  right: -20px;\n}\n\ninput:invalid{\n  border: 1px solid red;\n}\n\ninput:invalid + span::before{\n  content: \"✖\";\n  color: red;\n}\n\ninput:valid + span::before {\n  content: \"✓\";\n  color: green;\n}\n</code></pre>\n<p>비슷한 의사 클래스로 <code>:in-range</code>, <code>:out-of-range</code>가 있다. <code>min</code>, <code>max</code> 속성을 갖는 numeric input에서 유효성 검사에 따른 스타일링에 쓸 수 있다. <code>:valid</code>와 비슷하게 쓰이지만 사용자에게 '유효하지 않은 숫자'라는 것보다 더 많은 정보를 제공해서 사용자 경험을 향상시키고 싶을 때 쓸 수 있다.</p>\n<h2>6.3. 폼 요소의 상태에 따른 스타일링</h2>\n<p>활성화 상태인 폼 요소에만, 혹은 비활성화 상태인 폼 요소에만 스타일링을 할 때 <code>:enabled</code>와 <code>:disabled</code> 의사 클래스 셀렉터를 사용할 수 있다.</p>\n<p>예를 들어서 이미 제출된 정보에 대해서 요소를 disabled 처리한 후 <code>:disabled</code> 셀렉터로 비활성화된 요소를 스타일링할 수 있다.</p>\n<p>비슷하지만 다른 용도로 <code>:read-only</code> 셀렉터가 있다. 사용자가 편집할 수는 없지만 폼이 제출될 때 함께 제출되기는 하는 요소를 스타일링한다. 반대되는 의사 클래스 셀렉터로 <code>:read-write</code>가 있다.</p>\n<p>폼 요소 중에 <code>disabled</code> 나 <code>readonly</code>를 설정할 수 있는 것들이 있는데 이들에 쓴다. 기본값에 해당하는 <code>:enabled</code>와 <code>:read-write</code>는 잘 사용되지 않는 셀렉터이다.</p>\n<h2>6.4. 기타 의사 클래스 셀렉터</h2>\n<p>다음 의사 클래스 셀렉터들은 유용할 수도 있지만 브라우저 지원이 제대로 되지 않을 수 있다.</p>\n<p>focus상태인 요소가 내부에 있는지를 판단하는 <code>:focus-within</code>, 키보드 조작을 통해서 focus된 요소를 판단하는 <code>:focus-visible</code> 등의 의사 클래스 셀렉터도 있다.</p>\n<p><code>:placeholder-shown</code>은 placeholder가 보이는지를 판단하는 의사 클래스 셀렉터이다. 이를 이용해서 placeholder가 보이는 동안은 다른 스타일을 적용할 수 있다.</p>\n<p>자식이 없는 요소를 선택하는 <code>:empty</code>도 있다.</p>\n<h1>7. 요소 커스텀하기</h1>\n<p>기존의 폼 요소들이 부족하게 느껴질 때가 있을 수 있다. 혹은 나만의 어떤 양식 요소를 만들고 싶을 수도 있고. 이럴 때는 커스텀 요소를 만들어서 사용할 수 있다. 단 모든 부분에서 적절하게 동작하는 양식 요소를 직접 만드는 것은 매우 번거롭고 생각할 게 많은 작업이므로 웬만하면 기존의 요소를 활용하거나 서드파티 라이브러리를 사용하는 게 좋다.</p>\n<p>하지만 해야 할 때가 있을 수 있으므로 여기서는 스타일링이 정말 힘든 요소 중 하나인 <code>&#x3C;select></code>를 커스텀해 보면서 어떻게 커스텀 요소를 만들고 사용하는지 알아보자.</p>\n<p>이를 위해서는 기존의 폼 요소가 어떻게 동작하는지를 살펴보는 게 큰 도움과 참고가 된다는 걸 기억하자.</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Learn/Forms/How_to_build_custom_form_controls#design_structure_and_semantics\">https://developer.mozilla.org/en-US/docs/Learn/Forms/How_to_build_custom_form_controls#design_structure_and_semantics</a></p>\n<h2>7.1. 분석</h2>\n<p>기존 <code>&#x3C;select></code> 요소는 마우스 혹은 키보드로 사용할 수 있어야 하고 스크린 리더와도 호환 가능해야 한다. 이를 조건으로 <code>&#x3C;select></code>의 동작에 대한 분석을 해보자.</p>\n<p><code>&#x3C;select></code>는 다음과 같은 경우 normal state이다.</p>\n<ul>\n<li>처음 로딩될 때</li>\n<li>active였다가 사용자가 외부를 클릭했을 때</li>\n<li>active였다가 사용자가 키보드로 다른 곳을 focus했을 때</li>\n</ul>\n<p><code>&#x3C;select></code>는 다음과 같은 경우 active state이다.</p>\n<ul>\n<li>사용자가 요소를 클릭했거나 터치스크린에서 터치했을 때</li>\n<li>사용자가 키보드로 요소를 focus했을 때</li>\n<li>요소가 open 상태였다가 사용자가 클릭했을 때</li>\n</ul>\n<p><code>&#x3C;select></code>는 다음과 같은 경우 open state이다.</p>\n<ul>\n<li>다른 어떤 상태에 있다가 사용자가 클릭했을 때</li>\n</ul>\n<p>그리고 언제 요소의 선택값이 바뀌는지도 분석해야 한다. 물론 UI적으로 들어가면 위/아래 방향키 반응 등 분석할 게 수도 없겠지만...일단은 분석이 중요하다는 것 정도만 보고 넘어가자.</p>\n<p>만약 정말 새로운 요소를 만들어야 한다면 모든 경우에 대한 대응과 분석이 정말 중요해진다. 새로운 요소를 만드는 건 정말 쉽지 않다! 이왕이면 새로운 상호작용 요소를 만들지 말자.</p>\n<p>아무튼 이대로 한번 커스텀 select를 만들어보자. 하지만 이게 그대로 사용될 수 있는 코드는 아니고 그냥 시범용이다.</p>\n<h2>7.2. HTML 구조</h2>\n<p>다음과 같이 기초 구조를 잡고 클래스명으로 각각의 역할을 나타냈다. 키보드 접근을 위해 <code>tabindex</code>, 접근성을 위해 <code>role</code>속성을 부여하였다. <code>&#x3C;div></code>에는 <code>role</code>을 가진 각 자식 요소를 묶는 역할을 뜻하는 <code>listbox</code>를 부여했고 <code>&#x3C;ul></code>의 list role을 덮어씌우기 위해서는 특별한 의미는 없고 정보를 보여주는 데에 쓰인다는 의미의 <code>presentation</code> role을 부여했다.</p>\n<pre><code class=\"language-html\">&#x3C;h1>메뉴를 골라보자&#x3C;/h1>\n&#x3C;div class=\"select\" tabindex=\"0\" role=\"listbox\">\n  &#x3C;span class=\"value\">아메리카노&#x3C;/span>\n  &#x3C;ul class=\"option-list hidden\" role=\"presentation\">\n    &#x3C;li role=\"option\" class=\"option\">아메리카노&#x3C;/li>\n    &#x3C;li role=\"option\" class=\"option\">카페라떼&#x3C;/li>\n    &#x3C;li role=\"option\" class=\"option\">카페모카&#x3C;/li>\n    &#x3C;li role=\"option\" class=\"option\">카푸치노&#x3C;/li>\n    &#x3C;li role=\"option\" class=\"option\">바닐라라떼&#x3C;/li>\n    &#x3C;li role=\"option\" class=\"option\">헤이즐넛라떼&#x3C;/li>\n    &#x3C;li role=\"option\" class=\"option\">카라멜마끼아또&#x3C;/li>\n  &#x3C;/ul>\n&#x3C;/div>\n</code></pre>\n<h2>7.3. CSS</h2>\n<p>select와 같은 작동을 위해서 다음과 같은 CSS를 작성한다. <code>.select::after</code>를 보면 select 요소의 아래 화살표를 <code>::after</code>선택자의 <code>content</code> 속성을 이용해 표현한 것을 볼 수 있다.</p>\n<pre><code class=\"language-css\">.select{\n  position:relative;\n  /* 요소가 text flow의 일부가 되고 크기 조절도 가능하도록 */\n  display:inline-block;\n}\n\n.select.active,\n.select:focus{\n  outline:none;\n  box-shadow:0 0 3px 1px #227755;\n}\n\n.select .option-list{\n  position:absolute;\n  top:100%;\n  left:0;\n}\n\n/* hidden이 되면 높이를 0으로 만들고 숨긴다 */\n.select .option-list.hidden{\n  max-height:0;\n  visibility:hidden;\n}\n\n/* 여기부터는 장식 CSS */\n.select{\n  font-size:1rem;\n  box-sizing:border-box;\n  padding:0.5rem 1rem;\n\n  width:10rem;\n\n  border:1px solid #227755;\n  border-radius:4px;\n  box-shadow:0 0 3px 1px #227755;\n\n  background-color:#fff;\n}\n\n.select .value{\n  display:inline-block;\n  width:100%;\n  overflow:hidden;\n  \n  white-space:nowrap;\n  text-overflow:ellipsis;\n  vertical-align:top;\n}\n\n.select::after{\n  content: \"▼\";\n  position:absolute;\n  top:0;\n  right:0;\n  z-index:1;\n\n  box-sizing:border-box;\n\n  height:100%;\n  width:2rem;\n  padding-top:0.3rem;\n\n  border-left:1px solid #227755;\n  border-radius:0 4px 4px 0;\n\n  background-color:#000;\n  color:#fff;\n  text-align:center;\n}\n\n.select .option-list{\n  z-index:2;\n\n  list-style:none;\n  margin:0;\n  padding:0;\n\n  box-sizing:border-box;\n\n  min-width:100%;\n\n  max-height:10rem;\n  overflow-y:auto;\n  overflow-x:hidden;\n\n  border:1px solid #227755;\n  box-shadow:0 0 3px 1px #227755;\n  background-color:#fff;\n}\n\n.select .option{\n  padding:0.5rem 1rem;\n}\n\n.select .highlight{\n  background-color:#227755;\n  color:#fff;\n}\n</code></pre>\n<h2>7.4. JS</h2>\n<p>JS는 다음과 같이 작성한다.</p>\n<pre><code class=\"language-js\">/* 인수로 받은 select를 hidden 상태로 바꾼다 */\nfunction deactivateSelect(select){\n  if(!select.classList.contains('active')){return;}\n\n  const optionList = select.querySelector('.option-list');\n  optionList.classList.add('hidden');\n  optionList.classList.remove('active');\n}\n\n// select를 selectList중에서 활성화시킨다\nfunction activateSelect(select, selectList){\n  if(select.classList.contains('active')){return;}\n\n  selectList.forEach(deactivateSelect);\n\n  select.classList.add('active');\n}\n\n// select의 optionList hidden 속성을 토글한다\nfunction toggleOptionList(select){\n  const optionList = select.querySelector('.option-list');\n  optionList.classList.toggle('hidden');\n}\n\n// select의 optionList에서 option을 highlight한다\n// 옵션에 마우스가 올라갈 때 하이라이트를 위함\nfunction highlightOption(select, option){\n  const optionList = select.querySelectorAll('.option');\n\n  optionList.forEach(other => {\n    other.classList.remove('highlight');\n  });\n\n  option.classList.add('highlight');\n}\n\n// select의 value를 업데이트하고 aria-selected 업데이트\nfunction updateValue(select, index){\n  const value=select.querySelector('.value');\n  const optionList = select.querySelectorAll('.option');\n\n  optionList.forEach(other=>{\n    other.setAttribute('aria-selected', \"false\");\n  });\n\n  optionList[index].setAttribute('aria-selected', \"true\");\n\n  value.innerHTML = optionList[index].innerHTML;\n  highlightOption(select, optionList[index]);\n}\n\n// 이벤트 리스너에 달기\nwindow.addEventListener('load', ()=>{\n  const selectList = document.querySelectorAll('.select');\n  \n  selectList.forEach(select => {\n    const optionList = select.querySelectorAll('.option');\n\n    select.tabIndex = 0;\n\n    optionList.forEach((option, index) => {\n      option.addEventListener('click', ()=>{\n        updateValue(select, index);\n      });\n    });\n\n    optionList.forEach(option => {\n      option.addEventListener('mouseover', ()=>{\n        highlightOption(select, option);\n      })\n    })\n\n    select.addEventListener('click', (e)=>{\n      toggleOptionList(select);\n    });\n\n    select.addEventListener('focus', (e)=>{\n      activateSelect(select, selectList);\n    });\n\n    select.addEventListener('blur', (e)=>{\n      deactivateSelect(select);\n    });\n\n    select.addEventListener('keyup', (e)=>{\n      if(e.key===\"Escape\"){\n        deactivateSelect(select);\n      }\n      if(e.key===\"ArrowDown\" &#x26;&#x26; index &#x3C; optionList.length - 1){\n        index++;\n      }\n      if(e.key===\"ArrowUp\" &#x26;&#x26; index > 0){\n        index--;\n      }\n      updateValue(select, index);\n    });\n\n  });\n})\n</code></pre>\n<h2>7.5. 작동하지 않을 때</h2>\n<p>요즘은 거의 없는 일이지만 사용자가 JS 사용 기능을 껐을 수 있다.</p>\n<p>그리고 가장 흔한 경우는 스크립트가 어떤 네트워크 문제로 인해 로딩되지 않았거나, 스크립트에 버그가 있거나 서드파티 라이브러리 혹은 브라우저 확장과 충돌이 일어났을 수 있다.</p>\n<p>또한 브라우저가 낡은 브라우저라서 스크립트가 사용하는 문법 중 일부를 지원하지 않아서 작동하지 않을 수도 있다.</p>\n<p>JS가 로드되고 실행되기 전에 요소와 상호작용을 시도해서 안되는 것일 수도 있다.</p>\n<p>이럴 때를 대비해서 그냥 <code>&#x3C;select></code> 태그를 fallback으로 만들어 두는 방법을 취할 수 있다. 이럴 때는 만약 커스텀 select가 로드되었다면 기본 <code>&#x3C;select></code>를 숨기고 커스텀 select를 표시하도록 한다.</p>\n<pre><code class=\"language-js\">window.addEventListener(\"load\", () => {\n  document.body.classList.remove(\"no-widget\");\n  document.body.classList.add(\"widget\");\n});\n</code></pre>",
    "excerpt": "1. 역사\n1995년 HTML2 표준이 form 요소를 도입하였다. 하지만 CSS는 1996년에 나왔고, 나온 이후에도 대부분의 브라우저가 이를 당장 지원하지는 않았다.\n그리고 이미 브라우저들에서는 form 요소를 자체적으로 렌더링하고 있었기 때문에 초기에는 form 요소에 CSS를 적용 가능하게 하는 것에 의욕적이지 않았다.\n하지만 시간이 지나면서 form 요소들도 몇몇을 제외하고는 대부분 스타일링 가능하게 되었다.\n물론 color picker와 같이 CSS만",
    "headingTree": [
      {
        "title": "1. 역사",
        "url": "#1-역사",
        "items": []
      },
      {
        "title": "2. 스타일링이 쉬운 요소들",
        "url": "#2-스타일링이-쉬운-요소들",
        "items": []
      },
      {
        "title": "3. 사전 작업",
        "url": "#3-사전-작업",
        "items": [
          {
            "title": "3.1. appearance",
            "url": "#31-appearance",
            "items": []
          }
        ]
      },
      {
        "title": "4. 몇몇 요소들의 스타일링",
        "url": "#4-몇몇-요소들의-스타일링",
        "items": [
          {
            "title": "4.1. search box 스타일링",
            "url": "#41-search-box-스타일링",
            "items": []
          },
          {
            "title": "4.2. 체크박스, 라디오버튼 스타일링",
            "url": "#42-체크박스-라디오버튼-스타일링",
            "items": []
          },
          {
            "title": "4.3. select",
            "url": "#43-select",
            "items": []
          },
          {
            "title": "4.4. file input",
            "url": "#44-file-input",
            "items": []
          },
          {
            "title": "4.5. range input",
            "url": "#45-range-input",
            "items": []
          }
        ]
      },
      {
        "title": "5. 스타일링이 불가능한 요소들",
        "url": "#5-스타일링이-불가능한-요소들",
        "items": [
          {
            "title": "5.1. date input",
            "url": "#51-date-input",
            "items": []
          },
          {
            "title": "5.2. number input",
            "url": "#52-number-input",
            "items": []
          },
          {
            "title": "5.3. color input",
            "url": "#53-color-input",
            "items": []
          },
          {
            "title": "5.4. meter, progress",
            "url": "#54-meter-progress",
            "items": []
          }
        ]
      },
      {
        "title": "6. 의사 클래스 셀렉터를 이용한 스타일링",
        "url": "#6-의사-클래스-셀렉터를-이용한-스타일링",
        "items": [
          {
            "title": "6.1. 필수 제출 요소 나타내기",
            "url": "#61-필수-제출-요소-나타내기",
            "items": []
          },
          {
            "title": "6.2. 데이터 유효성 스타일링",
            "url": "#62-데이터-유효성-스타일링",
            "items": []
          },
          {
            "title": "6.3. 폼 요소의 상태에 따른 스타일링",
            "url": "#63-폼-요소의-상태에-따른-스타일링",
            "items": []
          },
          {
            "title": "6.4. 기타 의사 클래스 셀렉터",
            "url": "#64-기타-의사-클래스-셀렉터",
            "items": []
          }
        ]
      },
      {
        "title": "7. 요소 커스텀하기",
        "url": "#7-요소-커스텀하기",
        "items": [
          {
            "title": "7.1. 분석",
            "url": "#71-분석",
            "items": []
          },
          {
            "title": "7.2. HTML 구조",
            "url": "#72-html-구조",
            "items": []
          },
          {
            "title": "7.3. CSS",
            "url": "#73-css",
            "items": []
          },
          {
            "title": "7.4. JS",
            "url": "#74-js",
            "items": []
          },
          {
            "title": "7.5. 작동하지 않을 때",
            "url": "#75-작동하지-않을-때",
            "items": []
          }
        ]
      }
    ],
    "metadata": {
      "readingTime": 5,
      "wordCount": 1378
    },
    "url": "/posts/html-form-styling",
    "thumbnail": {
      "local": "/static/checkbox-radio-style-238f3fdb.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-checkbox-radio-style-238f3fdb-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAIAAAA8r+mnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAVklEQVR4nGNwdXOVkJAICwu7ffv2JSTA0NPV09bWtmrlqlOnTv2Hgbdv3zLU1dWpq6mbGZulpaW9ffv2Gxg8efKEYceOHY0NjfPnzl+/fv2pU6duwwAAO0xCarScJJwAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "html-form-tag",
    "title": "HTML의 폼 관련 태그들",
    "date": "2023-07-16T00:00:00Z",
    "description": "HTML 폼에 쓰이는 요소들을 알아보자",
    "tags": [
      "HTML"
    ],
    "html": "<h1>1. 시작</h1>\n<p>HTML 폼은 사용자가 웹사이트와 상호작용할 수 있는 많은 기능을 제공한다. 회원가입이나 로그인 등에 필요한 get, post 요청도 날릴 수 있다. 하지만 이런 트윗이 올라올 정도로 그렇게 주목받지 못하고 있다. 솔직히 나도 몇 번 써본 적이 없다.</p>\n<p><img src=\"/static/login-with-html-ab65538b.png\" alt=\"html-form\"></p>\n<p>따라서 <a href=\"https://developer.mozilla.org/ko/docs/Learn/Forms\">MDN의 HTML 폼 가이드</a>와 그간 주워들은 몇 가지를 정리하는 시간을 가지고자 한다. 만약 이 글을 읽게 되는 사람이 있다면 기본적인 HTML 지식과 약간의 개발 경험이 있다고 간주한다.</p>\n<h1>2. 간단한 서버 열기</h1>\n<p><code>express-server</code>라는 폴더를 만들고 내부에서 <code>npm init</code></p>\n<p>그리고 express와 body-parser를 설치한다.</p>\n<pre><code class=\"language-bash\">npm install express --save\nnpm install body-parser\n</code></pre>\n<p>폴더 내부의 <code>index.js</code> 파일을 다음과 같이 작성한다.</p>\n<pre><code class=\"language-js\">const express = require('express');\nconst bodyParser = require('body-parser')\nconst app = express();\nconst port = 8080;\n\napp.use(bodyParser.urlencoded({ extended: false }))\n\n// parse application/json\napp.use(bodyParser.json())\n\napp.get('/', (req, res) => res.send('Hello World!'));\n\napp.post('/', (req, res) => {\n  console.log(req.body);\n  res.send('Got a POST request');\n});\n\napp.listen(port, () => console.log(`Example app listening on port ${port}!`));\n</code></pre>\n<p>이제 <code>node index.js</code>를 실행하면 <code>localhost:8080</code>으로 서버에 접속할 수 있다. 그리고 <code>localhost:8080</code>에서는 get, post 요청을 처리할 수 있게 될 것이다.</p>\n<h1>3. HTML 폼 기본</h1>\n<p>다음과 같이 <code>localhost:8080</code>으로 post 요청을 보내는 폼을 만들어보자. 간단한 로그인 폼이다.</p>\n<pre><code class=\"language-html\">&#x3C;form action=\"http://localhost:8080/\" method=\"post\">\n  &#x3C;label for=\"userid\">아이디&#x3C;/label>\n  &#x3C;input type=\"text\" id=\"userid\" name=\"userid\" placeholder=\"id\" />\n  &#x3C;label for=\"userpw\">비밀번호&#x3C;/label>\n  &#x3C;input type=\"password\" id=\"userpw\" name=\"userpw\" placeholder=\"pw\" />\n  &#x3C;button type=\"submit\">로그인&#x3C;/button>\n&#x3C;/form>\n</code></pre>\n<p>form의 action 속성은 데이터를 보낼 URL을, method 속성은 어떤 HTTP 메서드를 사용할지를 지정하는 데 쓰인다.</p>\n<p>이 폼을 만들고 제출하게 되면 <code>localhost:8080</code>에서는 다음과 같은 로그가 출력될 것이다.</p>\n<pre><code class=\"language-bash\">{ userid: '입력한 id', userpw: '입력한 비밀번호' }\n</code></pre>\n<p>input에 지정한 name은 서버에서 받을 때 사용할 key가 된 것을 알 수 있다.</p>\n<h1>4. 폼 구조화 태그</h1>\n<p>사용자 폼을 만들기 위한 태그들은 꽤 많고, form 태그를 써본 적 없는 사람이라도 한번쯤은 써봤을 많은 유명한 태그들이 있다.</p>\n<p>예를 들어서 <code>&#x3C;input></code>이나 <code>&#x3C;button></code>과 같은 태그들은 <a href=\"https://developer.mozilla.org/ko/docs/Web/HTML/Element#%EC%96%91%EC%8B%9D\">사실 폼 관련 태그로 분류된다.</a> 이들은 모두 form 태그 바깥에서도 사용할 수 있기 때문에 다른 곳에서도 쓰이는 경우가 많다. 그 경우 해당 요소들은 폼과 관련이 없으며 JS로 관련 동작을 정의해 주게 된다.</p>\n<p>하지만 우린 지금 폼에 대해서 알아보고 있으므로, 이 요소들을 폼과 관련해서 간략히 알아보도록 하자.</p>\n<h2>4.1. form</h2>\n<p>form 태그는 폼을 정의하는 태그이다. HTML로 폼을 정의할 때는 언제나 이 요소로 시작해야 한다. 단 form을 다른 form 태그로 둘러싸는 것은 제한되어 있으며 그렇게 할 경우 예측할 수 없는 방식으로 작동할 수 있다.</p>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/HTML/Element/form#%ED%8A%B9%EC%84%B1\">가질 수 있는 속성</a>들은 다음과 같다.</p>\n<ul>\n<li><code>accept-charset</code>: 폼을 서버로 제출할 때 사용할 문자 인코딩을 지정한다. 기본값은 <code>unknown</code>이다.</li>\n<li><code>action</code>: 폼을 통해서 서버로 정보를 전송할 때 사용할 URL을 지정한다.</li>\n<li><code>autocomplete(기본값은 on)</code>: 브라우저가 form 항목을 사용자의 과거 입력값에 기반하여 채워넣을 수 있는지. 기본값은 on</li>\n<li><code>enctype</code>: 폼을 전송할 때 사용할 콘텐츠 MIME 타입을 지정한다. 기본값은 <code>application/x-www-form-urlencoded</code></li>\n<li><code>method</code>: 폼을 전송할 때 사용할 HTTP 메서드를 지정한다. 기본값은 get</li>\n<li><code>name</code>: 폼의 이름을 지정한다. 반드시 문서 폼 가운데 고유해야 한다.</li>\n<li><code>novalidate</code>: 폼을 서버로 제출할 때 유효성 검사를 하지 않도록 지정한다. 기본값은 false</li>\n<li><code>target</code>: 폼 요청 전송 후 응답을 어떻게 받을지를 지정한다. 기본값은 <code>_self</code></li>\n</ul>\n<h3>4.1.1. enctype</h3>\n<p>이 속성 중 <code>enctype</code>은 폼 데이터를 어떻게 인코딩해서 폼을 제출할지를 결정한다.</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURI\">UTF-8 유니코드로 문자를 인코딩하는 encodeURI</a>를 사용하는 <code>application/x-www-form-urlencoded</code>가 기본값이다.</p>\n<p><code>multipart/form-data</code>는 FormData API를 사용해서 폼을 제출하며 Ajax로 전송된다. 폼을 이용할 때는 반드시 이 enctype을 사용해야 한다.</p>\n<p><code>text/plain</code>은 폼을 제출할 때 폼 데이터를 인코딩하지 않고 일반 텍스트로 전송한다. HTML5에서 디버깅 용도로 추가되었으며 실제로 디버깅 용도로 대부분 사용된다.</p>\n<h2>4.2. fieldset, legend</h2>\n<p><code>&#x3C;fieldset></code>은 같은 목적을 가진 폼 요소들을 묶을 때 사용된다. <code>&#x3C;legend></code>는 부모 <code>&#x3C;fieldset></code>의 요소를 설명하는 데에 쓰인다.</p>\n<p>대부분의 스크린 리더들 또한 이를 인식하여 fieldset 내용을 읽기 전 legend를 읽어준다.</p>\n<p>위의 로그인 폼을 이 요소들을 사용해서 보강해 보자.</p>\n<pre><code class=\"language-html\">&#x3C;form action=\"http://localhost:8080/\" method=\"post\">\n  &#x3C;fieldset>\n    &#x3C;legend>로그인&#x3C;/legend>\n    &#x3C;label for=\"userid\">아이디&#x3C;/label>\n    &#x3C;input type=\"text\" id=\"userid\" name=\"userid\" placeholder=\"id\" />\n    &#x3C;label for=\"userpw\">비밀번호&#x3C;/label>\n    &#x3C;input type=\"password\" id=\"userpw\" name=\"userpw\" placeholder=\"pw\" />\n    &#x3C;button type=\"submit\">로그인&#x3C;/button>\n  &#x3C;/fieldset>\n&#x3C;/form>\n</code></pre>\n<p>이렇게 하면 fieldset과 legend가 묶인 폼이 만들어진다. 아무 CSS를 넣지 않았지만 누가 보아도 묶인 form이라는 것을 알 수 있다.</p>\n<p><img src=\"/static/fieldset-legend-c548aef5.png\" alt=\"fieldset-legend\"></p>\n<p>이런 분류를 이용해서 <code>&#x3C;fieldset></code>으로 폼의 섹션을 나누고 <code>&#x3C;legend></code>로 섹션의 제목을 붙이는 것도 가능하다. 이는 MDN에서도 중요한 예제로 취급하는 유스케이스이다. 물론 남용하면 안 되겠지만.</p>\n<p>fieldset 요소에 disabled 속성을 지정할 경우 일반적으로 회색으로 표시되며, 자손 컨트롤을 비활성화한다. 또한 모든 브라우저 이벤트를 받지 않게 된다. 예외적으로 <code>&#x3C;legend></code>안의 폼은 비활성화되지 않는다.</p>\n<p>그리고 fieldset은 블록 레벨 요소이고, legend도 블록 레벨 요소이다.</p>\n<p>이때 <a href=\"https://github.com/w3c/csswg-drafts/issues/321\">엣지, 크롬 브라우저에선 현재 fieldset 내부에서 flex, grid 디스플레이를 사용할 수 없는 버그가 존재한다.</a></p>\n<h2>4.3. label</h2>\n<p>label로 폼 내 UI의 설명을 나타낼 수 있다. <code>for</code>속성으로 지정한 id의 UI와 묶여진다.</p>\n<p>이렇게 UI를 연관시키면 사용자가 label을 누를 시 해당하는 UI가 활성화되고 click 이벤트도 동작한다. 체크박스나 라디오버튼을 쓸 때 버튼의 영역보다 넓은 영역을 '버튼 선택을 위해 눌러야 하는 영역'으로 사용할 수 있어 특히 유용하다.</p>\n<p>물론 label로 해당 UI를 둘러싸는 방식으로 둘을 연관시킬 수도 있다. 다음과 같이 말이다.</p>\n<pre><code class=\"language-html\">&#x3C;label>\n  &#x3C;input type=\"checkbox\" name=\"agree\" />\n  동의합니다.\n&#x3C;/label>\n</code></pre>\n<p>하지만 이런 방식으로 label과 UI를 연관시킬 경우 몇 가지 종류의 보조 기술이 <code>label</code>과 해당 UI의 관계를 이해하지 못할 수 있어 <code>for</code> 속성으로 id를 지정하는 게 좋다. 위의 로그인 폼에서도 <code>for</code>속성을 사용하였다.</p>\n<p>접근성을 고려할 때 label 내부에 button 같은 인터랙티브 요소를 배치하지 않는 게 좋다.</p>\n<p>label은 인라인 요소이다.</p>\n<p>여러 개의 라벨을 하나의 요소에 연결하는 건 좋지 않으며 그럴 경우 label 내부에 <code>span</code> 태그를 넣어서 해결하자.</p>\n<p>또한 특별히 읽어져야 하는 요소가 있다면 <code>aria-label</code> 속성을 사용한다. 아래 같은 경우 필수 요소라는 의미를 갖는 <code>*</code>에 <code>aria-label</code>을 설정하였다.</p>\n<pre><code class=\"language-html\">&#x3C;label for=\"username\">Name: &#x3C;span aria-label=\"required\">*&#x3C;/span>&#x3C;/label>\n&#x3C;input id=\"username\" type=\"text\" name=\"username\" required />\n</code></pre>\n<h2>4.4. output</h2>\n<p>사용자의 입력을 받아서 계산 출력을 보여주는 데 사용된다. <code>for</code> 속성으로 다른 요소의 id를 지정하여 어떤 요소의 출력인지를 지정할 수 있다.</p>\n<p>예를 들어서 사용자가 입력한 ID를 위의 로그인 폼에서 실시간으로 보여주고 싶다면 다음과 같이 한다.</p>\n<pre><code class=\"language-html\">&#x3C;form \n  action=\"http://localhost:8080/\" \n  method=\"post\" \n  id=\"loginForm\"\n  oninput=\"result.value='사용자가 입력한 ID '+userid.value\"\n>\n  &#x3C;fieldset form=\"loginForm\">\n    &#x3C;legend>로그인&#x3C;/legend>\n    &#x3C;label for=\"userid\">아이디&#x3C;/label>\n    &#x3C;input type=\"text\" id=\"userid\" name=\"userid\" placeholder=\"id\" />\n    &#x3C;label for=\"userpw\">비밀번호&#x3C;/label>\n    &#x3C;input type=\"password\" id=\"userpw\" name=\"userpw\" placeholder=\"pw\" />\n    &#x3C;output name=\"result\" for=\"loginForm\">사용자가 입력한 ID &#x3C;/output>\n  &#x3C;/fieldset>\n  &#x3C;button type=\"submit\" form=\"loginForm\">로그인&#x3C;/button>\n&#x3C;/form>\n</code></pre>\n<p>사용자의 ID 인풋 값만 보여주면 되니까 input에 for를 지정해도 된다.</p>\n<pre><code class=\"language-html\">&#x3C;form \n  action=\"http://localhost:8080/\" \n  method=\"post\" \n  id=\"loginForm\"\n  oninput=\"result.value=userid.value\"\n>\n  &#x3C;fieldset form=\"loginForm\">\n    &#x3C;legend>로그인&#x3C;/legend>\n    &#x3C;label for=\"userid\">아이디&#x3C;/label>\n    &#x3C;input type=\"text\" id=\"userid\" name=\"userid\" placeholder=\"id\" />\n    &#x3C;label for=\"userpw\">비밀번호&#x3C;/label>\n    &#x3C;input type=\"password\" id=\"userpw\" name=\"userpw\" placeholder=\"pw\" />\n    &#x3C;output name=\"result\" for=\"userid\">&#x3C;/output>\n  &#x3C;/fieldset>\n  &#x3C;button type=\"submit\" form=\"loginForm\">로그인&#x3C;/button>\n&#x3C;/form>\n</code></pre>\n<p><a href=\"https://css-tricks.com/the-output-element/\">https://css-tricks.com/the-output-element/</a></p>\n<h2>4.5. 폼 구조</h2>\n<p>앞서 말했듯이 폼 구조는 HTML만으로도 만들 수 있다.</p>\n<p>몇 가지 사용례가 있다. <code>ul</code>이나 <code>ol</code> 태그 내부의 <code>li</code> 요소들을 통해서 폼 요소들을 감싸거나, <code>p</code>, <code>div</code>요소들도 흔한 래퍼로 쓰인다. 리스트는 체크박스나 라디오버튼을 묶을 때 흔히 쓰인다.</p>\n<p>그리고 fieldset 내부에 복잡한 양식이 있을 때는 section 요소로 요소들을 분류하고 제목 태그를 다는 것도 흔하다. 폼 안에 여러 기능을 하는 섹션이 있다면 section으로 분류해주자.</p>\n<h1>5. input</h1>\n<p>사용자의 데이터를 받을 수 있는 요소를 생성한다. <code>type</code> 속성으로 어떤 종류의 데이터를 받을지를 지정할 수 있고 이외에도 다양한 특성을 가지고 있다.</p>\n<p><a href=\"https://witch.work/posts/html-input-tag\">너무 길어져서 글을 분리하였다. HTML input tag</a></p>\n<h1>6. 기타 폼 요소</h1>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Learn/Forms/Other_form_controls\">기타 폼 요소 MDN 글</a></p>\n<h2>6.1. textarea</h2>\n<p>줄바꿈을 포함하는 여러 줄의 일반 텍스트를 입력할 수 있는 컨트롤을 생성한다. <code>&#x3C;input></code>태그는 한 줄의 텍스트만 입력 가능했다. 오직 텍스트 콘텐츠만 받기 때문에 어떤 콘텐츠를 넣어도 텍스트로 렌더링된다.</p>\n<p><code>cols</code>와 <code>rows</code> 속성으로 컨트롤의 크기를 지정할 수 있고 <code>wrap</code> 속성으로 줄바꿈 방식을 지정할 수 있다.</p>\n<p><code>&#x3C;textarea></code>태그 사이에 텍스트를 넣으면 콘텐츠의 기본값이 된다. <code>value</code>요소를 사용하는 <code>input</code>보다 기본값 지정이 간단하다.</p>\n<p><code>minlength</code>와 <code>maxlength</code> 속성으로 입력할 수 있는 문자의 최소, 최대 길이를 지정할 수 있다.</p>\n<pre><code class=\"language-html\">&#x3C;textarea\n  rows=\"5\"\n  cols=\"10\"\n  minlength=\"10\"\n  maxlength=\"100\"\n  name=\"message\"\n>\n  메시지를 입력하세요\n&#x3C;/textarea>\n</code></pre>\n<p><code>resize</code> CSS로 textarea의 크기 조절 방식을 지정할 수 있다. 기본값은 가로, 세로 모두 크기가 조절되는 <code>both</code>이다.</p>\n<h2>6.2. select</h2>\n<p><code>&#x3C;select></code>와 <code>&#x3C;option></code>요소로 선택지들 중 하나를 고르는 상자를 만들 수 있다. 폼 제출시 <code>&#x3C;select></code>요소의 value는 선택된 <code>&#x3C;option></code>의 value 값이 된다.</p>\n<p>그리고 <code>&#x3C;optgroup></code>요소로 option들을 그룹화할 수 있다. <code>&#x3C;optgroup></code>태그가 갖는 label 속성의 값은 해당 태그에 싸인 선택지들의 위에 표기된다.</p>\n<p><code>&#x3C;optgroup></code>가 disabled 속성을 통해 비활성화되면 거기 속한 옵션들도 모두 비활성화된다.</p>\n<pre><code class=\"language-html\">&#x3C;form>\n  &#x3C;p>\n    &#x3C;label for=\"coffeeMenu\">주문할 커피를 고르세요&#x3C;/label>\n    &#x3C;select id=\"coffeeMenu\" name=\"coffee\">\n      &#x3C;!-- There is a trick here you think you'll pick\n          a banana but you'll eat an orange >:-) -->\n      &#x3C;option value=\"카라멜마끼아또\">카라멜마끼아또&#x3C;/option>\n      &#x3C;option value=\"카페라떼\">카페라떼&#x3C;/option>\n      &#x3C;optgroup label=\"아메리카노\">\n        &#x3C;option>아메리카노&#x3C;/option>\n        &#x3C;option>꿀아메리카노&#x3C;/option>\n        &#x3C;option>헤이즐넛아메리카노&#x3C;/option>\n      &#x3C;/optgroup>\n    &#x3C;/select>\n  &#x3C;/p>\n&#x3C;/form>\n</code></pre>\n<p>이렇게 선택된 선택지는 <code>select</code>에 지정된 name 속성을 키로 하고 선택된 <code>option</code>의 value 속성을 값으로 하는 객체로 전송된다. 위의 경우 카페라떼가 선택되었다면, <code>{ coffee: '카페라떼' }</code>가 전송된다.</p>\n<p>따라서 모든 option은 <code>value</code> 속성을 가져야 하는데 이를 생략시 option 태그 내부의 텍스트 콘텐츠를 <code>value</code>로 사용한다. option에 <code>selected</code> 속성 지정시 해당 option이 선택된 상태로 페이지가 렌더링된다.</p>\n<p>select에 multiple 속성 지정시 다수 항목이 선택 가능하며(이 경우 더이상 선택 상자가 드롭다운으로 나오지 않는다) size 속성을 통해 select 요소가 focus상태가 아닐 경우 한 번에 노출되는 항목 수도 지정 가능하다.</p>\n<p><code>form</code> 속성을 통해 select와 연결할 form 요소도 지정 가능하다. form 바깥에 있어도 해당 폼과 연결이 가능해지는 것이다.</p>\n<h3>6.2.1. CSS 스타일링</h3>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/HTML/Element/select#css_%EC%8A%A4%ED%83%80%EC%9D%BC%EB%A7%81\">select 속성은 CSS 스타일링이 어렵기로 유명하다. </a><code>appearance</code> 등으로 기본 외형을 제거할 수도 있고 몇몇 속성은 잘 적용되지만 내부 구조도 복잡하고 일관적이지 않은 결과가 나올 수 있다.</p>\n<p>따라서 일관된 스타일링이 중요하다면 JS와 WAI-ARIA 등을 이용해 별도의 드롭다운 메뉴를 만드는 것도 고려 가능한 옵션이다.</p>\n<h2>6.3. datalist</h2>\n<p>이 요소를 이용해서 폼 요소 입력 시 자동완성에 대한 선택지를 제공할 수 있다. 사용자가 직접 값을 입력할 시 이는 무시된다.</p>\n<p><code>&#x3C;datalist></code>는 다른 제어 요소에서 고를 수 있는 선택지를 나타내는 <code>&#x3C;option></code> 요소 여러 개를 담고, <code>&#x3C;input></code> 요소 등의 <code>list</code> 속성에 연결하고자 하는 <code>&#x3C;datalist></code> 태그의 id를 지정하면 연결된다.</p>\n<p><code>list</code> 속성으로 이게 연결되면 <code>input</code>요소 등에서 입력시 datalist의 option들이 자동 완성으로 나타난다. 보통은 드롭다운 박스로 나타난다.</p>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/HTML/Element/datalist#%EC%98%88%EC%A0%9C\">MDN에서 제공하는 예제</a></p>\n<p>이외에도 <code>&#x3C;input type=\"color\"></code>에 연결할 경우 색상을 선택 가능한 팔레트가 나타나게 하는 등의 동작을 할 수 있다.</p>\n<h3>6.3.1. fallback</h3>\n<p>대부분의 브라우저에서 <code>&#x3C;datalist></code>를 지원하지만 IE의 낮은 버전이나, 안드로이드 파이어폭스의 2020년 이전 버전과 같은 낡은 브라우저에서는 지원하지 않는 경우도 있다.</p>\n<p>이럴 땐 <code>&#x3C;datalist></code>가 제대로 작동할 시 내부 요소 중 <code>&#x3C;option></code>이 아닌 요소들은 모두 무시한다는 점을 이용해서 <code>&#x3C;select></code> 요소를 이용한 fallback을 만들 수 있다.</p>\n<pre><code class=\"language-html\">&#x3C;datalist id=\"coffeeList\">\n  &#x3C;label for=\"suggestion\">Pick Menu&#x3C;/label>\n  &#x3C;select id=\"suggestion\" name=\"altCoffee\">\n    &#x3C;option>아메리카노&#x3C;/option>\n    &#x3C;option>카페라떼&#x3C;/option>\n    &#x3C;option>카페모카&#x3C;/option>\n  &#x3C;/select>\n&#x3C;/datalist>\n</code></pre>\n<p><code>&#x3C;datalist></code>가 작동할 시 label, select는 무시되고 option들만 표시될 것이고 작동하지 않을 시 선택 상자가 나올 것이다.</p>\n<h2>6.4. meter, progress</h2>\n<p><code>&#x3C;meter></code> 요소는 하나의 값이 최소와 최댓값 사이에서 상대적으로 어느 정도 위치를 점하는지를 나타낸다.</p>\n<pre><code class=\"language-html\">&#x3C;form>\n  &#x3C;label for=\"percent\">비율&#x3C;/label>\n  &#x3C;meter\n  id=\"percent\"\n  value=\"60\"\n  min=\"0\"\n  max=\"100\"\n  >\n  60%\n  &#x3C;/meter>\n&#x3C;/form>\n</code></pre>\n<p><code>&#x3C;progress></code> 요소는 0부터 <code>max</code>까지 중 어느 작업의 완료 정도를 나타낸다. 따라서 최솟값은 항상 0이며 <code>max</code> 미만의 <code>value</code> 속성 값에 따라서 프로그레스 바가 채워진다.</p>\n<h2>6.5. button</h2>\n<p><code>&#x3C;button></code> 요소는 클릭 가능한 버튼을 나타낸다. form 외부에도 얼마든지 배치할 수 있다.</p>\n<p>type은 <code>submit</code>, <code>reset</code>, <code>button</code>이 있다. 지정하지 않은 경우 <code>submit</code>이 기본값이며 제출 동작을 안 하게 하고 싶다면 <code>type=\"button\"</code>을 지정하자.</p>\n<p>또한 submit 속성을 지정한 <code>input</code>요소에서 그랬던 것과 같이 formaction, formenctype, formmethod, formnovalidate, formtarget 속성을 사용하여 form의 속성을 오버라이딩할 수 있다.</p>\n<h3>6.5.1. button과 input</h3>\n<p>한때 <code>&#x3C;button></code> 태그는 <code>&#x3C;input type=\"button\"></code> 태그에 비해 덜 쓰였다. 이는 IE6, IE7에서의 버그 때문이었다.</p>\n<p>이 버그는 <code>&#x3C;button></code> 태그의 <code>name</code>과 <code>value</code>를 지정하고 폼을 제출하면 <code>value</code>가 전송되는 대신 버튼의 raw content를 전송하는 버그였다. 따라서 사람들은 이 버그를 방지하기 위해 <code>&#x3C;input></code>을 사용하였다.</p>\n<p>그러나 IE8부터는 이 버그가 고쳐졌기 때문에 <code>&#x3C;button></code>을 마음놓고 사용하면 된다. <code>&#x3C;button></code>은 <code>&#x3C;input></code>에 비해 내부에 HTML 컨텐츠도 넣을 수 있으므로 스타일링도 편하다.</p>\n<h1>7. 폼 밖에서 폼 연관시키기</h1>\n<p>HTML을 하다 보면 <code>&#x3C;button></code>과 같은 요소들을 폼과 관련 없는 부분에서도 사용할 때가 많다. 그러면 이들을 폼과 연관시키기 위해서는 어떤 방법이 필요할까?</p>\n<p>폼 내부에 버튼을 포함시키면 된다. 하지만 그럴 수 없다면? 그럴 때 <code>form</code> 속성이 등장한다.</p>\n<p><code>form</code> 속성은 폼과 연관시킬 수 있는 요소들에 사용할 수 있다. 이 속성은 폼의 id를 가리키는데, 이를 통해서 폼과 연관시킬 수 있다. 가령 button 요소를 form 안에 넣지 않고 폼과 연관시켜 보겠다.</p>\n<pre><code class=\"language-html\">&#x3C;form action=\"http://localhost:8080/\" method=\"post\" id=\"loginForm\">\n  &#x3C;fieldset>\n    &#x3C;legend>로그인&#x3C;/legend>\n    &#x3C;label for=\"userid\">아이디&#x3C;/label>\n    &#x3C;input type=\"text\" id=\"userid\" name=\"userid\" placeholder=\"id\" />\n    &#x3C;label for=\"userpw\">비밀번호&#x3C;/label>\n    &#x3C;input type=\"password\" id=\"userpw\" name=\"userpw\" placeholder=\"pw\" />\n  &#x3C;/fieldset>\n&#x3C;/form>\n&#x3C;button type=\"submit\" form=\"loginForm\">로그인&#x3C;/button>\n</code></pre>\n<p>이는 form 바깥에 있는 fieldset 요소를 폼에 포함해야 할 때도 사용할 수 있다. fieldset 요소에 연결할 form 요소 id를 <code>form</code> 속성에 지정하면 된다.</p>\n<p><code>&#x3C;label></code> 요소도 form 속성을 통해서 외부에 있는 폼과 연관시킬 수 있다. 이렇게 하면 <code>label</code>이 폼 요소 내부에 있지 않아도 어디에서나 폼과 연관시킬 수 있다.</p>\n<h1>8. 레거시 브라우저의 폼</h1>\n<p>IE나 오래된 스마트폰의 브라우저와 같은 레거시 브라우저를 지원하는 건 쉽지 않다. <code>&#x3C;input></code>태그의 특정 <code>type</code>속성을 지원하지 않는 브라우저의 경우 <code>type=\"text\"</code>로 자동으로 변환되는 등의 지원이 있긴 하지만 기본적으로는 쉽지 않다. <a href=\"https://developer.mozilla.org/en-US/docs/Learn/Forms/HTML_forms_in_legacy_browsers\">이런 상황을 위한 조언이 MDN에 있다.</a></p>\n<p>스타일링은 레거시 브라우저 지원이 더 힘들다. <a href=\"https://developer.mozilla.org/en-US/docs/Learn/Forms/Property_compatibility_table_for_form_controls\">폼 요소의 프로퍼티 호환성 표</a>같은 것을 보면 이를 확실히 느낄 수 있다. 이럴 때는 CSS의 <code>@supports</code> 쿼리를 이용해서 레거시 브라우저를 위한 스타일링을 따로 지정해주는 것도 좋다.</p>\n<p>레거시 브라우저에서는 지원하지 않는 API를 폴리필을 통해 사용하는 경우도 있는데 레거시 브라우저의 엔진은 일반적으로 더 느리기까지 하다. 그러면 레거시 브라우저는 폴리필을 사용하는 것뿐 아니라 느린 엔진의 문제까지 겹쳐서 더 큰 UI 문제를 발생시킨다. <a href=\"https://developer.mozilla.org/en-US/docs/Learn/Forms/HTML_forms_in_legacy_browsers#unobtrusive_javascript\">HTML/CSS와 같은 구조와 JS동작을 엄격히 분리하는 unobtrusive JS 방법론을 이용해서 JS가 없이도 최소한의 기능과 접근성을 보장하는 방법을 고려해볼 수 있다.</a></p>\n<p>혹은 커스텀 위젯을 직접 만드는 것도, 매우 큰 비용과 시간을 감수할 만하다면 시도해 볼 수 있다.</p>\n<h1>참고</h1>\n<p>HTML 참고서, 양식 부분 <a href=\"https://developer.mozilla.org/ko/docs/Web/HTML/Element#%EC%96%91%EC%8B%9D\">https://developer.mozilla.org/ko/docs/Web/HTML/Element#%EC%96%91%EC%8B%9D</a></p>\n<p>HTML 폼 가이드 <a href=\"https://developer.mozilla.org/ko/docs/Learn/Forms\">https://developer.mozilla.org/ko/docs/Learn/Forms</a></p>\n<p>express 공식 문서 <a href=\"https://expressjs.com/ko/starter/hello-world.html\">https://expressjs.com/ko/starter/hello-world.html</a></p>\n<p>express와 body-parser <a href=\"https://expressjs.com/en/resources/middleware/body-parser.html\">https://expressjs.com/en/resources/middleware/body-parser.html</a></p>\n<p><a href=\"https://tech.devsisters.com/posts/functional-react-state-management/\">https://tech.devsisters.com/posts/functional-react-state-management/</a></p>\n<p><a href=\"https://dev.to/dailydevtips1/submit-button-outside-the-form-2m6f\">https://dev.to/dailydevtips1/submit-button-outside-the-form-2m6f</a></p>\n<p>output element <a href=\"https://css-tricks.com/the-output-element/\">https://css-tricks.com/the-output-element/</a></p>\n<p>레거시 브라우저에서의 폼 <a href=\"https://developer.mozilla.org/en-US/docs/Learn/Forms/HTML_forms_in_legacy_browsers\">https://developer.mozilla.org/en-US/docs/Learn/Forms/HTML_forms_in_legacy_browsers</a></p>",
    "excerpt": "1. 시작\nHTML 폼은 사용자가 웹사이트와 상호작용할 수 있는 많은 기능을 제공한다. 회원가입이나 로그인 등에 필요한 get, post 요청도 날릴 수 있다. 하지만 이런 트윗이 올라올 정도로 그렇게 주목받지 못하고 있다. 솔직히 나도 몇 번 써본 적이 없다.\n\n따라서 MDN의 HTML 폼 가이드와 그간 주워들은 몇 가지를 정리하는 시간을 가지고자 한다. 만약 이 글을 읽게 되는 사람이 있다면 기본적인 HTML 지식과 약간의 개발 경험이 있다고 간주한다.\n2.",
    "headingTree": [
      {
        "title": "1. 시작",
        "url": "#1-시작",
        "items": []
      },
      {
        "title": "2. 간단한 서버 열기",
        "url": "#2-간단한-서버-열기",
        "items": []
      },
      {
        "title": "3. HTML 폼 기본",
        "url": "#3-html-폼-기본",
        "items": []
      },
      {
        "title": "4. 폼 구조화 태그",
        "url": "#4-폼-구조화-태그",
        "items": [
          {
            "title": "4.1. form",
            "url": "#41-form",
            "items": [
              {
                "title": "4.1.1. enctype",
                "url": "#411-enctype",
                "items": []
              }
            ]
          },
          {
            "title": "4.2. fieldset, legend",
            "url": "#42-fieldset-legend",
            "items": []
          },
          {
            "title": "4.3. label",
            "url": "#43-label",
            "items": []
          },
          {
            "title": "4.4. output",
            "url": "#44-output",
            "items": []
          },
          {
            "title": "4.5. 폼 구조",
            "url": "#45-폼-구조",
            "items": []
          }
        ]
      },
      {
        "title": "5. input",
        "url": "#5-input",
        "items": []
      },
      {
        "title": "6. 기타 폼 요소",
        "url": "#6-기타-폼-요소",
        "items": [
          {
            "title": "6.1. textarea",
            "url": "#61-textarea",
            "items": []
          },
          {
            "title": "6.2. select",
            "url": "#62-select",
            "items": [
              {
                "title": "6.2.1. CSS 스타일링",
                "url": "#621-css-스타일링",
                "items": []
              }
            ]
          },
          {
            "title": "6.3. datalist",
            "url": "#63-datalist",
            "items": [
              {
                "title": "6.3.1. fallback",
                "url": "#631-fallback",
                "items": []
              }
            ]
          },
          {
            "title": "6.4. meter, progress",
            "url": "#64-meter-progress",
            "items": []
          },
          {
            "title": "6.5. button",
            "url": "#65-button",
            "items": [
              {
                "title": "6.5.1. button과 input",
                "url": "#651-button과-input",
                "items": []
              }
            ]
          }
        ]
      },
      {
        "title": "7. 폼 밖에서 폼 연관시키기",
        "url": "#7-폼-밖에서-폼-연관시키기",
        "items": []
      },
      {
        "title": "8. 레거시 브라우저의 폼",
        "url": "#8-레거시-브라우저의-폼",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 3,
      "wordCount": 836
    },
    "url": "/posts/html-form-tag",
    "thumbnail": {
      "local": "/static/login-with-html-ab65538b.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-login-with-html-ab65538b-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAADCAIAAAAhqtkfAAAACXBIWXMAAAsTAAALEwEAmpwYAAAATElEQVR4nGMI9fcWFRbesn795y9fnjx58h8Mvn37xpCWlpaUnJKSmpaTk7N+/fpv375B5BiOnzixb//+pcuW79y56+nTZxDR////AwAxWjWvGSRa0gAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "html-form-validation",
    "title": "HTML form의 데이터 검증",
    "date": "2023-08-03T00:00:00Z",
    "description": "HTML 폼 요소에서도 데이터 검증을 지원한다",
    "tags": [
      "HTML"
    ],
    "html": "<p>앞서 HTML로 폼 요소를 만들 때 쓰일 수 있는 요소들을 알아보았다. 그런데 폼의 기본적인 목적은 데이터를 제대로 제출하는 것이다. 따라서 폼의 데이터를 어떻게 다룰지에 대한 방법도 여러가지 나와 있다. 이를 알아보자.</p>\n<h1>1. 폼 유효성 검사</h1>\n<p>앞에서 본 <code>&#x3C;input type=\"email\"></code>과 같이 HTML5에서 도입된 새로운 input type들은 브라우저에서 자체적으로 유효성 검사를 해준다. 이런 것을 클라이언트 유효성 검사라 한다.</p>\n<p>물론 이는 postman 등을 통해서 서버에 직접 요청을 보낼 수 있는 방법이 있기 때문에 얼마든지 회피할 수 있다. 따라서 이런 클라이언트 사이드의 유효성 검사를 보안 목적으로 사용할 수는 없다. 서버에서도 따로 제출된 폼의 유효성 검사를 해줘야 한다.</p>\n<p>하지만 클라이언트 유효성 검사는 사용자 경험을 향상시키는 데에는 좋은 방법이다. 사용자가 잘못된 데이터를 입력하면 바로 알려줄 수 있고 속도도 빠르기 때문이다.</p>\n<p>이런 클라이언트 유효성 검사에는 input의 속성 등을 이용하는 빌트인 방식과 JS를 이용해서 커스터마이징한 유효성 검사가 있다. <code>pattern</code>을 이용해서 정규식을 통해 유효성을 검사하는 것도 빌트인 방식으로 친다.</p>\n<h2>1.1. JS로 유효성 검사 개요</h2>\n<p>빌트인 속성을 이용한 유효성 검사를 할 때 쓰는 <code>maxlength</code>등의 속성은 <a href=\"https://witch.work/posts/html-input-tag\">input 태그에 대한 글</a>에 거의 다 나와 있다. 따라서 JS로 만드는 유효성 검사를 알아보자.</p>\n<p>이를 <code>Constraint Validation API</code>라 하는데 이는 form 요소들에서 사용가능한 메서드와 속성들로 구성된다. 참고로 이들을 지원하는 DOM 요소는 다음과 같다.</p>\n<ul>\n<li><code>&#x3C;input></code>(HTMLInputElement)</li>\n<li><code>&#x3C;select></code>(HTMLSelectElement)</li>\n<li><code>&#x3C;button></code>(HTMLButtonElement)</li>\n<li><code>&#x3C;textarea></code>(HTMLTextAreaElement)</li>\n<li><code>&#x3C;fieldset></code>(HTMLFieldSetElement)</li>\n<li><code>&#x3C;output></code>(HTMLOutputElement)</li>\n</ul>\n<p><code>willValidate</code>는 해당 요소가 폼 제출 시 유효성 검사가 진행되는 요소일 경우 true, 아니면 false를 반환한다.</p>\n<p><code>validity</code>는 요소의 유효성 검사 결과를 담은 <code>ValidityState</code> 객체이다. <code>validationMessage</code>는 요소가 유효하지 않을 경우 그 상태를 설명하는 메시지를 반환한다. 만약 유효하거나 요소의 <code>willValidate</code>가 false라면 빈 문자열을 반환한다.</p>\n<p>이 객체의 키들은 각각의 유효성 검사 결과에 따라서 불린값을 가진다. 가령 <code>pattern</code>유효성 검사에서 실패하면 <code>patternMismatch</code>가 true가 된다. <code>tooLong</code>, <code>tooShort</code>, <code>typeMismatch</code>, <code>valueMissing</code> 등의 객체 프로퍼티들이 더 있다.</p>\n<p>요소의 값의 전체 유효성 검사 결과를 반환하는 <code>checkValidity()</code> 메서드와 유효성 검사 결과를 조사하기만 하는 <code>reportValidity</code>메서드가 간간이 쓰인다. 커스텀 에러 메시지를 설정하는 <code>setCustomValidity(message)</code>메서드도 존재한다.</p>\n<h2>1.2. 유효성 검사 메시지 내용 커스텀</h2>\n<p>위 API를 이용하면 폼의 유효성 검사에 따라서 커스텀 메시지를 보여줄 수 있다. 이는 몇 가지 장점이 있는데 첫째는 폼의 메시지를 CSS로 스타일링할 수 있다는 것이고, 둘째는 폼의 메시지를 다국어로 제공할 수 있다는 것이다.</p>\n<p>기본 유효성 검사 메시지는 브라우저마다, 국가마다 내용도 디자인도 다른데 JS로 이런 유효성 검사 메시지를 커스텀하면 이를 통일시킬 수 있는 방법이 되는 것이다.</p>\n<p>이제 JS를 이용해서 커스텀 에러 메시지를 만들어 보자. 먼저 간단한 로그인 폼을 만든다.</p>\n<pre><code class=\"language-html\">&#x3C;form>\n  &#x3C;fieldset>\n    &#x3C;legend>회원 로그인&#x3C;/legend>\n      &#x3C;label for=\"email\">이메일&#x3C;/label>\n      &#x3C;input type=\"email\" id=\"email\" name=\"email\" required />\n      &#x3C;label for=\"password\">비밀번호&#x3C;/label>\n      &#x3C;input type=\"password\" id=\"password\" name=\"password\" required />\n      &#x3C;button type=\"submit\">로그인&#x3C;/button>\n  &#x3C;/fieldset>\n&#x3C;/form>\n</code></pre>\n<p>그리고 <code>&#x3C;script></code> 태그를 통해서 JS파일을 불러온다.</p>\n<p>이 JS파일은 다음과 같이 작성한다. emailInput의 <code>typeMismatch</code>검증 결과가 false이면 <code>setCustomValidity</code>를 통해서 에러 메시지를 빈 문자열로 설정한다. 이는 유효성 검사가 통과했음을 의미한다. 반면 <code>setCustomValidity</code>를 통해서 에러 메시지를 설정하면 유효성 검사가 실패했음을 의미한다. 그리고 설정된 에러 메시지는 형태는 브라우저마다 다르지만 input의 아래에 출력되게 된다.</p>\n<pre><code class=\"language-js\">// main.js\nconst emailInput= document.getElementById('email');\n\nemailInput.addEventListener('input', function(event) {\n  if(emailInput.validity.typeMismatch) {\n    emailInput.setCustomValidity('이메일 형식에 맞춰 입력해 주세요.');\n  }\n  else{\n    emailInput.setCustomValidity('');\n  }\n});\n</code></pre>\n<p><img src=\"/static/email-typemismatch-bedcd40d.png\" alt=\"이메일 형식 불일치\"></p>\n<h2>1.3. 유효성 검사 메시지창 커스텀</h2>\n<p>form 요소에 <code>novalidate</code> 어트리뷰트를 주면 브라우저의 자동 유효성 검사가 꺼진다. 하지만 이것이 constraint validation API나 <code>:valid</code>같은 CSS 의사 클래스 기능을 못 쓰게 된다는 건 아니다. 우린 이걸 이용해서 우리의 커스텀 유효성 검사와 커스텀 유효성 메시지 표시 방식을 적용한 form을 만들 수 있다.</p>\n<p>먼저 이메일 입력창에 유효성 검사를 위한 어트리뷰트를 지정한다. <code>type=\"email\"</code>에서 이메일 형식에 대한 검증은 진행하므로 최소 길이 8 제한만 걸었다.</p>\n<p>에러 메시지는 이메일 input 아래에 span 태그를 만들고 valid 상태에 따라서 에러 메시지를 출력하도록 한다. 이때 <code>aria-live=\"polite\"</code>를 주면 스크린 리더가 에러 메시지를 읽어준다. 단 스크린 리더 우선순위가 그렇게 높지는 않다.</p>\n<pre><code class=\"language-html\">&#x3C;!-- 폼의 기본 유효성 검사 끄기 -->\n&#x3C;form novalidate>\n  &#x3C;fieldset>\n    &#x3C;legend>회원 로그인&#x3C;/legend>\n      &#x3C;label for=\"email\">이메일&#x3C;/label>\n      &#x3C;input type=\"email\" id=\"email\" name=\"email\" required minlength=\"8\" />\n      &#x3C;span id=\"email-error-message\" class=\"error\" aria-live=\"polite\">&#x3C;/span>\n      &#x3C;label for=\"password\">비밀번호&#x3C;/label>\n      &#x3C;input type=\"password\" id=\"password\" name=\"password\" required />\n      &#x3C;button type=\"submit\">로그인&#x3C;/button>\n  &#x3C;/fieldset>\n&#x3C;/form>\n</code></pre>\n<p>CSS는 상황에 따라서 에러 메시지를 보여주는 것에 대한 것이므로 <code>error</code>클래스가 기본적으로 보이지 않는 상태로 설정해야 한다는 것 외에는 적당히 만들면 된다.</p>\n<p>중요한 건 다음과 같이 validity 체크에 따라서 에러 메시지를 보여주는 JS를 작성하는 것이다. 이메일 입력창 값이 바뀌는 이벤트가 발생할 때마다 유효성 검사를 진행하고, 유효하지 않으면 에러 메시지를 출력하고, 유효하면 에러 메시지를 지운다.</p>\n<pre><code class=\"language-js\">const form = document.querySelector('form');\nconst emailInput= document.getElementById('email');\nconst emailError = document.getElementById('email-error-message');\n\nfunction showError() {\n  if(emailInput.validity.valueMissing) {\n    emailError.textContent = '이메일 주소를 입력해 주세요.';  \n  }\n  else if(emailInput.validity.typeMismatch) {\n    emailError.textContent = '이메일 형식에 맞게 입력해 주세요.';\n  }\n  else if(emailInput.validity.tooShort) {\n    emailError.textContent = `이메일은 ${ emailInput.minLength }자 이상 입력해 주세요.`;\n  }\n\n  emailError.className = 'error active';\n}\n\nemailInput.addEventListener('input', function(event) {\n  if(emailInput.validity.valid) {\n    emailError.textContent = '';\n    emailError.className = 'error';\n  }\n  else{\n    showError();\n  }\n});\n\nform.addEventListener('submit', function(event) {\n  if(!emailInput.validity.valid) {\n    showError();\n    event.preventDefault();\n  }\n});\n</code></pre>\n<h2>1.4. 빌트인 API 없이 유효성 검증</h2>\n<p>form에 관련된 컴포넌트를 커스텀하는 경우 이런 constraint validation API를 사용하지 못할 수 있다. 이럴 때 유효성 검증을 위해서는 JS를 이용해서 직접 검증 로직을 짜야 한다.</p>\n<p>어떤 유효성을 검증할 건지, 그리고 유효성 검사를 통과하지 못할 때 어떤 동작을 할 건지 그리고 사용자가 이를 정정하도록 어떻게 도울 것인지를 고민해야 한다. 이는 UI 분야의 일이다. <a href=\"https://www.nngroup.com/articles/errors-forms-design-guidelines/\">도움이 될 만한 링크를 MDN에서 제공한다.</a></p>\n<p>그리고 <a href=\"https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation#validating_forms_without_a_built-in_api\">이를 실제로 구현한 코드도 제공한다.</a></p>\n<h1>2. 폼 데이터 보내기</h1>\n<p>데이터를 잘 검증했다면(물론 서버에서 한 번 더 검증해야 하지만)이제 HTTP 프로토콜로 폼을 제출하면 된다. <code>&#x3C;form></code>요소에서는 사용자가 제출 버튼을 눌렀을 때 어떻게 데이터 전송이 동작할지를 <code>action</code>과 <code>method</code> 속성으로 지정할 수 있다.</p>\n<p>간단히 얘기하면 파일이 아닌 폼 제어 요소의 값들은 <code>name=요소 value</code>형태로 인코딩되어 <code>action</code>에 지정된 URL로 전송된다. 이때 <code>method</code>에 지정된 HTTP 메서드로 전송된다. 만약 <code>method</code>가 지정되지 않으면 기본값인 GET으로 전송된다.</p>\n<h2>2.1. action과 method</h2>\n<p><code>action</code>은 폼 데이터를 전송할 URL을 지정한다. 절대 URL, 상대 URL을 모두 쓸 수 있으며 생략하면 현재 폼이 속한 페이지로 전송한다. 만약 폼이 HTTPS 페이지에 있고 <code>action</code>에 HTTP URL을 지정하면 브라우저는 경고를 띄운다.</p>\n<p>단 폼이 HTTP 페이지에 있고 <code>action</code>에 HTTPS URL을 지정하면 브라우저는 데이터를 암호화해서 전송한다.</p>\n<p><code>method</code>는 폼 데이터를 전송할 HTTP 메서드를 지정한다. \"GET\"이나 \"POST\"가 많이 쓰인다. 해당 메서드가 궁금하다면 <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview\">MDN HTTP 원리</a> 참고.</p>\n<p>GET으로 데이터 전송시 request body가 비어 있으므로 서버에 보내는 데이터는 URL에 쿼리스트링으로 저장된다. GET이 기본 <code>method</code> 값이다.</p>\n<p>반면 POST로 전송시 request body에 데이터가 담겨서 전송된다. 개발자 도구 네트워크 탭에서 request body에 든 form 데이터를 확인할 수도 있다.</p>\n<h2>2.2. 파일 보내기</h2>\n<p>HTML 폼으로 파일을 보내는 건 일반적인 텍스트를 보내는 것과는 다르게 이루어져야 한다. 파일은 이진 데이터인데 HTTP 프로토콜은 텍스트 기반 프로토콜이므로 파일을 전송할 때는 좀 다른 처리가 필요하다.</p>\n<p>이는 <code>enctype</code>어트리뷰트로 해결할 수 있다. 이 어트리뷰트는 request header의 <code>Content-Type</code>을 지정한다. 이 타입은 서버에 어떤 종류의 데이터가 전송되는지를 알려준다. 기본값은 <code>application/x-www-form-urlencoded</code>이다. 이는 폼 데이터를 URL 파라미터에 인코딩한 것이다.</p>\n<p>파일을 지정할 때는 일단 파일 컨텐츠가 URL 파라미터에 들어가지 않게 <code>method</code>를 POST로 지정하고 <code>enctype</code>을 <code>multipart/form-data</code>로 지정한다. 데이터가 여러 부분으로 나누어져 전송될 것이기 때문이다.</p>\n<p>사용자의 파일 지정을 위해서는 <code>&#x3C;input type=\"file\"></code>을 사용한다.</p>\n<h2>2.3. 보안</h2>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Learn/Forms/Sending_and_retrieving_form_data#be_paranoid_never_trust_your_users\">https://developer.mozilla.org/en-US/docs/Learn/Forms/Sending_and_retrieving_form_data#be_paranoid_never_trust_your_users</a></p>\n<p>HTML 폼은 서버 공격이 가장 흔하게 일어나는 지점이다. 보안 문제는 흔히 서버에서 데이터를 어떻게 다루는지에서 일어나기 때문이다. 가령 SQL 인젝션이라든지.</p>\n<p>이후에 보안 부분을 또 공부하겠지만 가장 중요한 건 사용자 입력을 믿지 않는 것이다. 신뢰할 수 있는 사용자이더라도 컴퓨터를 하이재킹당했을 수 있다. 따라서 무조건 잠재적인 위협이 있는 문자들을 거르고 또한 들어오는 데이터의 양과 종류를 제한하는 게 좋다. 업로드된 파일은 다른 곳에 저장하는 게 좋다.</p>\n<h1>참고</h1>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation\">https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation</a></p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Learn/Forms/Sending_and_retrieving_form_data\">https://developer.mozilla.org/en-US/docs/Learn/Forms/Sending_and_retrieving_form_data</a></p>",
    "excerpt": "앞서 HTML로 폼 요소를 만들 때 쓰일 수 있는 요소들을 알아보았다. 그런데 폼의 기본적인 목적은 데이터를 제대로 제출하는 것이다. 따라서 폼의 데이터를 어떻게 다룰지에 대한 방법도 여러가지 나와 있다. 이를 알아보자.\n1. 폼 유효성 검사\n앞에서 본 <input type=\"email\">과 같이 HTML5에서 도입된 새로운 input type들은 브라우저에서 자체적으로 유효성 검사를 해준다. 이런 것을 클라이언트 유효성 검사라 한다.\n물론 이는 postman ",
    "headingTree": [
      {
        "title": "1. 폼 유효성 검사",
        "url": "#1-폼-유효성-검사",
        "items": [
          {
            "title": "1.1. JS로 유효성 검사 개요",
            "url": "#11-js로-유효성-검사-개요",
            "items": []
          },
          {
            "title": "1.2. 유효성 검사 메시지 내용 커스텀",
            "url": "#12-유효성-검사-메시지-내용-커스텀",
            "items": []
          },
          {
            "title": "1.3. 유효성 검사 메시지창 커스텀",
            "url": "#13-유효성-검사-메시지창-커스텀",
            "items": []
          },
          {
            "title": "1.4. 빌트인 API 없이 유효성 검증",
            "url": "#14-빌트인-api-없이-유효성-검증",
            "items": []
          }
        ]
      },
      {
        "title": "2. 폼 데이터 보내기",
        "url": "#2-폼-데이터-보내기",
        "items": [
          {
            "title": "2.1. action과 method",
            "url": "#21-action과-method",
            "items": []
          },
          {
            "title": "2.2. 파일 보내기",
            "url": "#22-파일-보내기",
            "items": []
          },
          {
            "title": "2.3. 보안",
            "url": "#23-보안",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 381
    },
    "url": "/posts/html-form-validation",
    "thumbnail": {
      "local": "/static/email-typemismatch-bedcd40d.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-email-typemismatch-bedcd40d-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAABCAIAAABsYngUAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAHklEQVR4nGMQFeRSUFbz8QvYtGnT8ePHN23a9BkMAHeiDbdkN+FzAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "html-index",
    "title": "블로그 내의 HTML 정보사전",
    "date": "2023-08-15T00:00:00Z",
    "description": "블로그 내 HTML 사전",
    "tags": [
      "HTML"
    ],
    "html": "<h1>들어가면서</h1>\n<p>HTML 마스터가 될 필요는 없다. 하지만 div와 5가지 정도 되는 기본 태그만으로 모든 걸 해결하는 건 탈피해야겠다고 생각해서 HTML에 대한 정리와 분류를 시작한다. 온전히 HTML에 관한 내용만은 아니지만..</p>\n<p>그리고 프론트의 경우 테스트를 할 때 사용자의 경험과 같은 방식으로 테스트하는 것이 권장되는데 이것에서도 HTML의 의미를 생각해 가며 사용하는 것이 중요하다.</p>\n<p>HTML 태그들에는 공식 role이 정해져 있는데 이를 지키면서 페이지를 작성하고 테스트하라는 것이다. <code>getByRole</code>등의 함수를 참고하면 쉽게 알 수 있다.</p>\n<p>아무튼 그래서 이렇게 HTML에 관해 작성한 글들을 정리하기 시작한다.</p>\n<h1>1. HTML이란</h1>\n<p>HTML은 웹 페이지와 그 컨텐츠를 구조화하고 해당 구조를 브라우저로 하여금 알 수 있게 하는 데 쓰이는 마크업 언어이다. 컨텐츠의 서로 다른 부분들을 다른 형식으로 보이게 하거나 하이퍼링크와 같이 특정 방식으로 동작하게 하기도 한다.</p>\n<p>각 HTML 요소는 여는 태그와 닫는 태그, 내용, 속성으로 구성된다. 태그와 요소는 다른데, 태그는 소스코드에서 요소의 시작과 끝을 표시하는 데에 쓰이는 것이고 요소는 DOM의 일부이다.</p>\n<h2>1.1. HTML 요소들의 의미</h2>\n<p>HTML 요소들 중 대부분이 그 자체로 페이지 구조 내에서 의미를 가진다. 예를 들어서 <code>&#x3C;p></code>태그는 paragraph의 약자로 단락을 나타내고, <code>&#x3C;table></code>태그는 말 그대로 표를 나타낸다. 이러한 요소들은 브라우저에게 콘텐츠의 의미와 구조를 알려준다.</p>\n<p>하지만 내가 만들어온 페이지들을 포함한 많은 페이지들이 <code>&#x3C;div></code>태그만 엄청나게 써가며 CSS로 시각적인 구분만을 만든다.</p>\n<p>이는 HTML의 의미를 완전히 무시한 것이며 스크린 리더 등으로 페이지를 볼 때 그리고 SEO 등에서 문제가 생길 수 있다.</p>\n<p>물론 CSS나 폰트 크기를 통해서 사이트의 각 파트를 구분하고 표시할 수도 있다. 하지만 아예 스크린 리더를 사용하거나 혹은 색을 통해서 구분할 수 없는 정도의 사용자도 많다.</p>\n<p>약 8%의 남자와 0.5%의 여자가 색맹(colorblind)이다. 세계의 약 4~5%가 색맹인 것이다. 이는 우리가 그렇게 지원하려고 노력하는 레거시 브라우저 사용자들보다도 많은 수치이지만 많은 경우 색맹 이용자들은 레거시 브라우저 사용자들에 비해 간과된다.</p>\n<p>이럴 때 각각의 의미를 생각해가며 HTML 태그들을 사용하는 것은 사이트 구조를 명백하게 드러내는 데 도움이 된다. 이는 스크린 리더 사용자들이 페이지를 명확히 구분하여 이용하도록 해준다.</p>\n<h1>2. HTML 요소의 구분</h1>\n<p>구체적으로 요소들을 알아보기 전에, HTML의 모든 요소는 블록 요소와 인라인 요소로 나뉜다는 것을 알고 가자.</p>\n<h2>2.1. 블록 레벨 요소</h2>\n<p>웹페이지 상에 블록을 만들고 공간을 차지하는 요소이다. 앞뒤 요소 사이에 새로운 줄을 만들며, 페이지의 구조적 요소를 나타낸다. 예를 들어서 p 태그, div 태그 등이 있다. 일반적으로 공간을 차지해야 한다고 생각되는 요소들이다.</p>\n<p>블록 요소는 블록 요소 내부에 중첩될 수 있지만 인라인 요소 내부에는 중첩될 수 없다. 예를 들어서 a태그 내에 div 태그가 중첩될 수 없다.</p>\n<h2>2.2. 인라인 요소</h2>\n<p>항상 블록 레벨 요소 내에 포함되어 있다. 한 단락과 같이 큰 범위에는 적용될 수 없다. 대신 문장이나 단어와 같은 작은 부분에 적용되며 새로운 줄을 만들지 않고 단락 내에 나타난다. a태그, strong 태그 등이 있다.</p>\n<p>이렇게 구분되는 HTML 요소들은 head, title 등 여러 가지 요소들이 있는데 <a href=\"https://developer.mozilla.org/ko/docs/Web/HTML/Element\">전체는 HTML 참고서에서 확인할 수 있다.</a> 이 글에서는 자주 쓰이는 태그들을 중심으로 다룰 것이다.</p>\n<h2>2.3. 주의</h2>\n<p>여기의 블록 요소, 인라인 요소는 CSS의 <code>display</code>속성과는 다르다. 상관관계가 없지는 않지만 CSS의 display 속성을 변경하더라도 HTML 요소의 기본 분류는 변경되지 않는다.</p>\n<p>가령 <code>&#x3C;h1></code>요소를 <code>display:inline;</code>으로 설정하더라도 HTML에선 여전히 블록 요소로 취급되며 요소가 포함할 수 있는 요소, 포함될 수 있는 요소 등의 표준은 똑같이 블록 레벨 요소로 적용된다.</p>\n<p><a href=\"https://html.spec.whatwg.org/multipage/indices.html#element-content-categories\">HTML5에서는 이런 혼동을 막기 위해 블록, 인라인 용어를 삭제하고 새롭고 더 엄밀한 구분을 도입하였다.</a></p>\n<h1>3. 주석</h1>\n<p><code>&#x3C;!-- 주석 --></code> 형태로 작성한다. 주석은 브라우저에 표시되지 않는다. 주석은 코드를 설명하거나 코드를 임시로 비활성화할 때 사용한다.</p>\n<h1>4. 문서 메타데이터 태그</h1>\n<p><a href=\"https://witch.work/posts/html-metadata-tag\">HTML의 문서 메타데이터 태그</a> 글에서 다루었다.</p>\n<h1>5. 콘텐츠 구획 태그</h1>\n<p><a href=\"https://witch.work/posts/html-section-tag\">HTML의 콘텐츠 구획 태그</a> 글에서 다루었다.</p>\n<h1>6. 텍스트 콘텐츠 태그</h1>\n<p><a href=\"https://witch.work/posts/html-text-tag\">HTML 텍스트 태그</a> 글에서 다루었다.</p>\n<p><a href=\"https://witch.work/posts/html-link-tag\">HTML의 링크 태그를 따로 다룬 글도 썼다.</a></p>\n<h1>7. 멀티미디어 임베딩</h1>\n<p><a href=\"https://witch.work/posts/html-multimedia-tag\">HTML 멀티미디어 임베딩</a> 글에서 다루었다.</p>\n<p><a href=\"https://witch.work/posts/html-responsive-image\">HTML에서 반응형 이미지 삽입하기</a></p>\n<p><a href=\"https://witch.work/posts/mdn-simple-page-test\">간단한 페이지에 미디어를 삽입하는 예제</a></p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/Guide/Audio_and_video_delivery\">오디오, 비디오 전송</a>도 참고할 만 하다.</p>\n<h1>8. 표 컨텐츠</h1>\n<p>표 형식 데이터를 생성하고 처리할 때 사용한다.</p>\n<p><code>&#x3C;caption></code>, <code>&#x3C;col></code>, <code>&#x3C;colgroup></code>, <code>&#x3C;table></code>, <code>&#x3C;tbody></code>, <code>&#x3C;td></code>, <code>&#x3C;tfoot></code>, <code>&#x3C;th></code>, <code>&#x3C;thead></code>, <code>&#x3C;tr></code> 태그를 포함한다.</p>\n<p><a href=\"https://witch.work/posts/html-table-tags\">HTML로 표 만들기</a>글에서 다루었다.</p>\n<h1>9. 양식</h1>\n<p>여러 입력 가능한 요소를 제공한다.</p>\n<p><code>&#x3C;button></code>, <code>&#x3C;datalist></code>, <code>&#x3C;fieldset></code>, <code>&#x3C;form></code>, <code>&#x3C;input></code>, <code>&#x3C;label></code>, <code>&#x3C;legend></code>, <code>&#x3C;meter></code>, <code>&#x3C;optgroup></code>, <code>&#x3C;option></code>, <code>&#x3C;output></code>, <code>&#x3C;progress></code>, <code>&#x3C;select></code>, <code>&#x3C;textarea></code> 태그를 포함한다.</p>\n<p><a href=\"https://witch.work/posts/html-form-tag\">기본적인 HTML 폼 요소 정보</a>\n<a href=\"https://witch.work/posts/html-input-tag\">input태그 같은 경우 따로 글을 작성하였다.</a></p>\n<p><a href=\"https://witch.work/posts/html-form-validation\">HTML 폼 유효성 검사</a>\n<a href=\"https://witch.work/posts/html-form-styling\">HTML 폼 요소 스타일링</a></p>\n<h1>10. 스크립트</h1>\n<p>HTML 문서에 스크립트(특히 JS)를 포함할 수 있게 해준다.</p>\n<p><code>&#x3C;canvas></code>, <code>&#x3C;noscript></code>, <code>&#x3C;script></code> 태그를 포함한다.</p>\n<h1>여담</h1>\n<h2>엔티티</h2>\n<p>살펴보았다시피 HTML 태그에는 속성값을 쓸 수 있다. 예를 들어 다음과 같은 것이다.</p>\n<pre><code class=\"language-html\">&#x3C;a href=\"https://www.naver.com/\" title=\"naver\">naver&#x3C;/a>\n</code></pre>\n<p>이때 속성값은 모두 따옴표로 감싸 주는 게 권장된다. 그런데 이 따옴표로 표시된 속성값 안에 따옴표를 쓰고 싶으면 어떻게 할까?</p>\n<p>HTML에서 미리 예약된 이런 따옴표같은 문자들이 있는데 이런 문자들을 기존 의미 그대로 표시하기 위해서 별도로 사용하는 문제 셋이 있다. 이를 엔티티라고 부른다.</p>\n<p>사용 예시를 들자면, HTML 요소의 내용에서 공백을 아무리 많이 사용해도 HTML 파서가 모두 단일 공백으로 바꿔버린다. 이럴 때 공백을 연속해 사용하려면 <code>&#x26;nbsp;</code> 엔티티를 사용하면 된다.</p>\n<p>엔티티들 중 대표적인 건 다음과 같다.</p>\n<ul>\n<li><code>&#x26;lt;</code> : &#x3C;</li>\n<li><code>&#x26;gt;</code> : ></li>\n<li><code>&#x26;amp;</code> : &#x26;</li>\n<li><code>&#x26;quot;</code> : \"</li>\n<li><code>&#x26;apos;</code> : '</li>\n<li><code>&#x26;nbsp;</code> : 공백</li>\n<li><code>&#x26;copy;</code> : 저작권 표시</li>\n</ul>\n<p>이런 방식으로 표현할 수 있는 문자들은 더 많다. <a href=\"http://www.tcpschool.com/html/html_text_entities\">발음 구별 부호, 심볼 특수문자 등이 있다.</a></p>\n<pre><code class=\"language-html\">&#x3C;p>In HTML, you define a paragraph using the &#x26;lt;p&#x26;gt; element.&#x3C;/p>\n</code></pre>\n<h2>기타 태그들</h2>\n<p>텍스트의 특정 부분이 수정되었다는 것을 표시해 주는 <code>&#x3C;del></code>, <code>&#x3C;ins></code> 태그가 있다.</p>\n<p>상호작용 가능한 UI 객체를 만드는 데에 사용하는 <code>&#x3C;details></code>, <code>&#x3C;dialog></code>, <code>&#x3C;summary></code> 태그가 있다.</p>\n<p>웹 컴포넌트 요소를 만드는 데에 사용하는 <code>&#x3C;slot></code>, <code>&#x3C;template></code> 태그가 있다. 앞으로 여러 글들을 통해 살펴볼 것이다.</p>\n<p>참고로, HTML 요소는 태그(&#x3C;태그이름>)를 사용해서 문서의 다른 텍스트와 구분되며 태그 안의 요소 이름은 대소문자 구분을 하지 않는다. <code>&#x3C;div></code>로 작성하나 <code>&#x3C;Div></code>로 작성하나 상관없다는 것이다.</p>\n<h2>유효성 검사</h2>\n<p><a href=\"https://validator.w3.org/#validate_by_upload\">HTML 유효성 검사 사이트</a>를 통해 HTML 문서를 검사하고 디버깅할 수 있다. 웹페이지 주소를 올리거나 파일을 올리거나 HTML 코드를 직접 올리는 등의 방법을 사용할 수 있다.</p>\n<p>HTML 표준에 맞는지 다 검사해 준다.</p>\n<h2>DOM 인터페이스가 없는 요소</h2>\n<p><a href=\"https://witch.work/posts/html-dom-missing-element\">어떤 HTML 요소들은 따로 DOM 인터페이스가 존재하지 않는다. 이에 대해 탐구해 보았다.</a></p>\n<h1>참고</h1>\n<p>HTML 기본 <a href=\"https://developer.mozilla.org/ko/docs/Learn/Getting_started_with_the_web/HTML_basics\">https://developer.mozilla.org/ko/docs/Learn/Getting_started_with_the_web/HTML_basics</a></p>\n<p>MDN HTML 입문서 - HTML 시작하기 <a href=\"https://developer.mozilla.org/ko/docs/Learn/HTML/Introduction_to_HTML/Getting_started\">https://developer.mozilla.org/ko/docs/Learn/HTML/Introduction_to_HTML/Getting_started</a></p>\n<p>모질라 재단 HTML 사이트 <a href=\"https://developer.mozilla.org/ko/docs/Web/HTML\">https://developer.mozilla.org/ko/docs/Web/HTML</a></p>\n<p>HTML 소개 <a href=\"https://developer.mozilla.org/ko/docs/Learn/HTML/Introduction_to_HTML\">https://developer.mozilla.org/ko/docs/Learn/HTML/Introduction_to_HTML</a></p>\n<p>HTML 요소 참고서 <a href=\"https://developer.mozilla.org/ko/docs/Web/HTML/Element\">https://developer.mozilla.org/ko/docs/Web/HTML/Element</a></p>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Glossary/Doctype\">https://developer.mozilla.org/ko/docs/Glossary/Doctype</a></p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Quirks_Mode_and_Standards_Mode\">https://developer.mozilla.org/en-US/docs/Web/HTML/Quirks_Mode_and_Standards_Mode</a></p>\n<p><a href=\"https://happycording.tistory.com/entry/HTML-Role-%EC%99%9C-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC%EB%A7%8C-%ED%95%98%EB%8A%94%EA%B0%80\">https://happycording.tistory.com/entry/HTML-Role-%EC%99%9C-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC%EB%A7%8C-%ED%95%98%EB%8A%94%EA%B0%80</a></p>\n<p><a href=\"https://discourse.mozilla.org/t/marking-up-a-letter-assessment/24676\">https://discourse.mozilla.org/t/marking-up-a-letter-assessment/24676</a></p>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Learn/HTML/Introduction_to_HTML/Document_and_website_structure\">https://developer.mozilla.org/ko/docs/Learn/HTML/Introduction_to_HTML/Document_and_website_structure</a></p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/track\">https://developer.mozilla.org/en-US/docs/Web/HTML/Element/track</a></p>\n<p><a href=\"https://medium.com/harrythegreat/%ED%94%8C%EB%9E%98%EC%8B%9C%EC%9D%98-%EB%AA%B0%EB%9D%BD%EC%9C%BC%EB%A1%9C-%EB%B3%B4%EB%8A%94-%EC%9B%B9%EC%9D%98-%EC%97%AD%EC%82%AC-ce6e387b60f\">https://medium.com/harrythegreat/%ED%94%8C%EB%9E%98%EC%8B%9C%EC%9D%98-%EB%AA%B0%EB%9D%BD%EC%9C%BC%EB%A1%9C-%EB%B3%B4%EB%8A%94-%EC%9B%B9%EC%9D%98-%EC%97%AD%EC%82%AC-ce6e387b60f</a></p>\n<p><a href=\"https://kkamagistory.tistory.com/808\">https://kkamagistory.tistory.com/808</a></p>\n<p>embed와 object <a href=\"https://stackoverflow.com/questions/1244788/embed-vs-object\">https://stackoverflow.com/questions/1244788/embed-vs-object</a></p>\n<p>SVG에 관한 더 많은 정보 <a href=\"https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Getting_Started\">https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Getting_Started</a></p>\n<p><a href=\"https://frontdev.tistory.com/entry/strong-%ED%83%9C%EA%B7%B8%EC%99%80-em-%ED%83%9C%EA%B7%B8%EC%9D%98-%EC%B0%A8%EC%9D%B4\">https://frontdev.tistory.com/entry/strong-%ED%83%9C%EA%B7%B8%EC%99%80-em-%ED%83%9C%EA%B7%B8%EC%9D%98-%EC%B0%A8%EC%9D%B4</a></p>",
    "excerpt": "들어가면서\nHTML 마스터가 될 필요는 없다. 하지만 div와 5가지 정도 되는 기본 태그만으로 모든 걸 해결하는 건 탈피해야겠다고 생각해서 HTML에 대한 정리와 분류를 시작한다. 온전히 HTML에 관한 내용만은 아니지만..\n그리고 프론트의 경우 테스트를 할 때 사용자의 경험과 같은 방식으로 테스트하는 것이 권장되는데 이것에서도 HTML의 의미를 생각해 가며 사용하는 것이 중요하다.\nHTML 태그들에는 공식 role이 정해져 있는데 이를 지키면서 페이지를 작성",
    "headingTree": [
      {
        "title": "들어가면서",
        "url": "#들어가면서",
        "items": []
      },
      {
        "title": "1. HTML이란",
        "url": "#1-html이란",
        "items": [
          {
            "title": "1.1. HTML 요소들의 의미",
            "url": "#11-html-요소들의-의미",
            "items": []
          }
        ]
      },
      {
        "title": "2. HTML 요소의 구분",
        "url": "#2-html-요소의-구분",
        "items": [
          {
            "title": "2.1. 블록 레벨 요소",
            "url": "#21-블록-레벨-요소",
            "items": []
          },
          {
            "title": "2.2. 인라인 요소",
            "url": "#22-인라인-요소",
            "items": []
          },
          {
            "title": "2.3. 주의",
            "url": "#23-주의",
            "items": []
          }
        ]
      },
      {
        "title": "3. 주석",
        "url": "#3-주석",
        "items": []
      },
      {
        "title": "4. 문서 메타데이터 태그",
        "url": "#4-문서-메타데이터-태그",
        "items": []
      },
      {
        "title": "5. 콘텐츠 구획 태그",
        "url": "#5-콘텐츠-구획-태그",
        "items": []
      },
      {
        "title": "6. 텍스트 콘텐츠 태그",
        "url": "#6-텍스트-콘텐츠-태그",
        "items": []
      },
      {
        "title": "7. 멀티미디어 임베딩",
        "url": "#7-멀티미디어-임베딩",
        "items": []
      },
      {
        "title": "8. 표 컨텐츠",
        "url": "#8-표-컨텐츠",
        "items": []
      },
      {
        "title": "9. 양식",
        "url": "#9-양식",
        "items": []
      },
      {
        "title": "10. 스크립트",
        "url": "#10-스크립트",
        "items": []
      },
      {
        "title": "여담",
        "url": "#여담",
        "items": [
          {
            "title": "엔티티",
            "url": "#엔티티",
            "items": []
          },
          {
            "title": "기타 태그들",
            "url": "#기타-태그들",
            "items": []
          },
          {
            "title": "유효성 검사",
            "url": "#유효성-검사",
            "items": []
          },
          {
            "title": "DOM 인터페이스가 없는 요소",
            "url": "#dom-인터페이스가-없는-요소",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 382
    },
    "url": "/posts/html-index",
    "thumbnail": {
      "local": "/thumbnails/html-index-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-html-index-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAeUlEQVR4nGPw8fFRUFCora2VlZWFsCsrK////8/g5OTExMQkLi5eVFT0+PHjAwcOXLlyBSTR0dFhY2Mzffr0169f//////fv3//BgGHv3r2VlZVbtmyBi0JIhhu3bt+7f//27dsQHXDAMGnqzL7+CfPmzbtw4QKyUQBM3WbnaHYfHwAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "html-input-tag",
    "title": "HTML input 태그",
    "date": "2023-07-06T00:00:00Z",
    "description": "사용자 데이터를 받는 input 태그는 강력하고 기능도 많다.",
    "tags": [
      "HTML"
    ],
    "html": "<p><a href=\"https://witch.work/posts/dev/html-form\">HTML의 폼 양식 만들기</a>글을 작성하는 중 input 태그에 관한 정리가 너무 길어져 글을 분리하였다.</p>\n<h1>1. HTML의 input 태그</h1>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/HTML/Element/input\">MDN의 input 태그 문서</a>, <a href=\"https://developer.mozilla.org/ko/docs/Learn/Forms/How_to_structure_a_web_form#the_input_element\">더 간략히 정리된 표</a>, <a href=\"https://developer.mozilla.org/en-US/docs/Learn/Forms/Basic_native_form_controls\">기본 폼 위젯</a> 참고.</p>\n<p>HTML input 태그는 다양한 타입의 사용자 데이터를 받을 수 있는 요소를 생성한다. <code>type</code> 속성으로 어떤 종류의 데이터를 받을지를 지정할 수 있고 이외에도 다양한 특성을 가지고 있다.</p>\n<p>이 요소의 동작 방식은 <code>type</code>에 따라 매우 달라지기 때문에 먼저 각 타입별로 간략히 정리해 보았다. 위의 참고한 링크들을 참고하면 더 많은 정보를 얻을 수 있다.</p>\n<h1>2. type=\"text\"</h1>\n<p>한 줄로 텍스트를 입력받을 수 있는 인터페이스를 제공한다. input 태그의 type을 생략했을 때 혹은 입력한 type값을 브라우저에서 지원하지 않을 때(<code>type=\"week\"</code>와 같은 타입 input은 지원하지 않는 브라우저가 꽤 있다) 사용되는 기본값이다. plain text만 입력 가능하다.</p>\n<p>앞으로도 많이 반복될 다음과 같은 속성들을 지정할 수 있다.</p>\n<ul>\n<li><code>name</code>: 폼 데이터를 전송할 때 이 input의 이름을 지정한다. 이 이름은 서버에서 폼 데이터를 받을 때 사용된다.</li>\n<li><code>value</code>: input의 기본값을 지정한다. 사용자가 직접 입력하면 이 값은 무시된다.</li>\n<li><code>readonly</code>: input의 값을 사용자가 직접 수정할 수 없도록 한다. 폼 제출시 데이터에는 포함된다.</li>\n<li><code>disabled</code>: input을 비활성화하여 수정될 수 없도록 한다. 폼 제출시 데이터에도 포함되지 않는다.</li>\n<li><code>placeholder</code>: 텍스트 입력 박스 내에 나타나서 사용자에게 힌트를 제공한다.</li>\n<li><code>size</code>: 텍스트 입력 박스의 너비를 지정한다. 글자 수 단위로 지정한다.</li>\n<li><code>minlength</code>, <code>maxlength</code>: 입력할 수 있는 최소/최대 글자 수를 지정한다.</li>\n<li><code>spellcheck</code>: 브라우저가 맞춤법 검사를 지원할 경우 입력한 텍스트의 맞춤법을 검사하도록 할 수 있다.</li>\n<li><code>pattern</code>: 유효성 검사를 위한 정규식을 지정한다. 특정 규칙을 만족하는 텍스트만 입력 가능하도록 할 수 있다.</li>\n<li><code>required</code>: 폼 제출시 이 input의 값을 필수로 만들어서 이 input이 비어있으면 폼 제출이 되지 않도록 할 수 있다.</li>\n</ul>\n<h1>3. type=\"password\"</h1>\n<p>비밀번호를 입력받는 창을 제공하며 입력된 텍스트를 보여주는 대신 <code>*</code>과 같이 마스킹한다. <code>pattern</code> 속성을 활용해서 정규식으로 값을 검증할 수 있다.</p>\n<p>단 이렇게 마스킹되는 건 인터페이스상 그런 것일 뿐이고 폼을 제출하면 그대로 평문으로 전송된다. 따라서 보안상 문제가 될 수 있는 비밀번호 같은 값은 암호화되어 전송되도록 <code>HTTPS</code>로 전송해야 한다.</p>\n<h1>4. type=\"hidden\"</h1>\n<p>사용자에게 보이지는 않지만 폼이 제출되었을 때 전송되어야 할 데이터를 넣어야 할 때 사용한다.</p>\n<h2>4.1. 폼 컨텐츠 ID 전송</h2>\n<p>예를 들어서 편집되고 있는 컨텐츠의 ID를 서버에 전송할 때 사용할 수 있다.</p>\n<pre><code class=\"language-html\">&#x3C;form \n  action=\"서버URL\" \n  method=\"post\" \n>\n  &#x3C;div>\n    뭔가 편집하고 있는 컨텐츠\n  &#x3C;/div>\n  &#x3C;button type=\"submit\" form=\"loginForm\">편집 완료&#x3C;/button>\n  &#x3C;input type=\"hidden\" id=\"contentID\" name=\"contentID\" value=\"1234\" />\n&#x3C;/form>\n</code></pre>\n<p>이렇게 하면 서버에 컨텐츠 ID가 함께 전송되기 때문에 서버는 이를 이용해 어떤 컨텐츠가 편집되었는지 알 수 있다.</p>\n<p>비슷한 방식으로 타임스탬프를 전송한다든지 할 수 있다. 스크린 리더에도 읽히지 않고 focus도 불가능하기 때문에 사용자에게 보이지 않는 데이터를 전송할 때 쓰기 좋다.</p>\n<h2>4.2. 체크박스 기본값 제공</h2>\n<p>위에서 체크박스의 <code>name</code> 과 <code>value</code>를 이용해서 체크박스가 체크된 상태로 폼이 제출되었을 때 서버에 전달되는 값을 지정할 수 있다고 했다.</p>\n<p>그런데 만약 체크박스가 체크되어 있지 않은 상태로 폼이 제출되었을 때 서버에 전달되는 값을 지정하고 싶다면 이때 <code>type=\"hidden\"</code>을 사용할 수 있다.</p>\n<pre><code class=\"language-html\">&#x3C;form \n  action=\"서버URL\" \n  method=\"post\" \n>\n  &#x3C;input type = \"checkbox\" id=\"checkboxValue\" name=\"checkboxName\" value=\"checkboxValue\"/>\n  &#x3C;button type=\"submit\">제출&#x3C;/button>\n  &#x3C;input type=\"hidden\" id=\"defaultInput\" name=\"checkboxName\" value=\"checkboxDefault\" />\n&#x3C;/form>\n</code></pre>\n<p>위처럼 하면 체크박스가 체크되지 않은 채 폼이 제출되어도 서버에는 <code>checkboxName:checkboxDefault</code>가 전달된다.</p>\n<h2>4.3. 주의사항</h2>\n<p>단 hidden input의 값은 개발자 도구 등을 통해서 접근 자체는 가능하므로, 보안상 문제가 될 수 있는 값을 여기에 노출시켜서는 안된다.</p>\n<h1>5. type=\"checkbox\"</h1>\n<p>클릭에 따라서 상태를 바꿀 수 있는 체크박스를 렌더링한다. 스타일은 브라우저마다 다를 수 있다.</p>\n<p><code>name</code>, <code>value</code> 속성이 있는데, 이는 체크박스의 데이터가 서버에 전달될 때 부여되는 값이다. 예를 들어 다음과 같은 체크박스 input을 생각하자.</p>\n<pre><code class=\"language-html\">&#x3C;input type=\"checkbox\" name=\"nickname\" value=\"witch\" />\n</code></pre>\n<p>그러면 해당 체크박스가 체크된 채로 들어 있는 폼이 제출되었을 때 폼을 통해 전달되는 데이터에는 <code>nickname:witch</code>가 들어 있게 된다. 만약 value가 생략되면 기본값은 <code>on</code>이다.</p>\n<p>체크박스가 체크되어 있지 않은 상태로 폼이 제출되면 값 자체가 서버에 전달되지 않는다.</p>\n<p><code>checked</code> 프로퍼티는 현재 체크박스가 체크된 상태인지를 나타내는 것이 <strong>아니다.</strong> 이는 체크박스가 기본적으로 체크된 상태로 보여질지를 결정한다.</p>\n<h2>5.1. indeterminate</h2>\n<p>체크박스는 <code>indeterminate</code>라는 제3의 상태를 가질 수 있다. 예를 들어서 전체 약관 동의가 체크되었는지를 표시하는 체크박스가 있을 때, 가령 동의할 약관이 3개라면 그 중에 3개 미만에 체크되었을 때 이 체크박스는 indeterminate 상태로 만드는 등의 용도로 쓸 수 있다.</p>\n<p>이는 <code>HTMLInputElement</code>의 indeterminate 프로퍼티를 통해 쓸 수 있다. HTML만을 통해서 쓸 수는 없다.</p>\n<pre><code class=\"language-html\">&#x3C;input type=\"checkbox\" name=\"agreement\" id=\"agreement\" />\n&#x3C;label for=\"agreement\">전체 약관 동의&#x3C;/label>\n</code></pre>\n<pre><code class=\"language-js\">const agreement = document.getElementById(\"agreement\");\nagreement.indeterminate = true;\n</code></pre>\n<h2>5.2. 배치</h2>\n<p>사용성과 접근성을 위해서, 연관된 체크박스들은 설명을 위한 <code>&#x3C;legend></code>가 들어 있는 <code>&#x3C;fieldset></code>으로 묶어주는 것이 좋다.</p>\n<p>그리고 연관된 <code>&#x3C;label></code>을 각 체크박스마다 넣어주자. 그러면 사용자가 라벨 클릭을 통해서도 체크박스를 클릭할 수 있게 되어 사용성이 좋아진다.</p>\n<h2>5.3. name 중복</h2>\n<p>만약 중복된 name을 가진 체크박스 input이 여러 개 있다면 어떨까? 다음과 같이 HTML을 작성했다면, cake를 name으로 가지는 체크박스가 2개다. 만약 이 2개에 모두 체크가 된 상태에서 폼이 제출된다면?</p>\n<pre><code class=\"language-html\">&#x3C;form>\n  &#x3C;fieldset>\n    &#x3C;legend>주문할 케이크 고르기&#x3C;/legend>\n    &#x3C;input type=\"checkbox\" name=\"cake\" value=\"choco\" id=\"choco\" />\n    &#x3C;label for=\"choco\">초코&#x3C;/label>\n    &#x3C;input type=\"checkbox\" name=\"cake\" value=\"strawberry\" id=\"strawberry\" />\n    &#x3C;label for=\"strawberry\">딸기&#x3C;/label>\n  &#x3C;/fieldset>\n&#x3C;/form>\n</code></pre>\n<p>그러면 모든 체크박스의 값이 서버에 전달된다. 이를 array 등의 형태로 파싱하는 것은 서버에서 할 일이다. 예를 들어서 위의 폼의 경우 다음과 같은 쿼리스트링이 서버에 전달될 것이다.</p>\n<pre><code>cake=choco&#x26;cake=strawberry\n</code></pre>\n<p>같은 cake로 2개의 쿼리가 전달되는 것을 볼 수 있다. 마지막 값만 반영되는 등의 동작이 일어나는 게 아니라, 모든 value가 전달되는 것이다.</p>\n<h1>6. type=\"radio\"</h1>\n<p>라디오버튼 그룹에 사용한다. <code>name</code> 특성으로 그룹을 지정하고 <code>value</code> 특성으로 라디오버튼의 값들을 지정한다. 같은 <code>name</code>을 가진 라디오버튼들 중 하나만 선택될 수 있으며 선택된 라디오버튼의 <code>value</code>만 name에 대응되어서 폼 데이터로 전송된다.</p>\n<pre><code class=\"language-html\">&#x3C;input type=\"radio\" name=\"coffee\" value=\"아메리카노\" id=\"americano\" checked>\n&#x3C;label for=\"americano\">아메리카노&#x3C;/label>\n&#x3C;input type=\"radio\" name=\"coffee\" value=\"카페라떼\" id=\"latte\">\n&#x3C;label for=\"latte\">카페라떼&#x3C;/label>\n&#x3C;input type=\"radio\" name=\"coffee\" value=\"카페모카\" id=\"mocha\">\n&#x3C;label for=\"mocha\">카페모카&#x3C;/label>\n</code></pre>\n<p><code>value</code>는 사용자에게 보이지 않으므로 일반적으로 <code>label</code> 요소를 사용해서 라디오버튼의 라벨을 지정한다. <code>value</code> 특성을 생략하면 기본값은 뜬금없는 <code>on</code>이므로 <code>value</code>를 지정하는 것을 잊지 말자.</p>\n<p>어떤 라디오버튼도 선택되지 않은 경우 제출된 폼 데이터에 해당 라디오버튼 그룹의 데이터는 전혀 포함되지 않는다.</p>\n<p>이를 방지하기 위해서는 <code>required</code> 속성을 넣고 <code>checked</code> 속성을 하나의 라디오버튼에 넣어서 기본적으로 선택된 요소를 지정해야 한다. 한번 라디오버튼 중 하나가 선택되면 폼을 reset하는 것 외에 사용자가 선택을 해제할 수 있는 방법은 없다.</p>\n<p>그럼 만약 같은 <code>name</code> 을 가진 여러 라디오버튼에 <code>checked</code> 속성을 넣으면 어떻게 될까? 이 경우에는 <code>checked</code>가 지정된 라디오버튼 중 마지막에 나오는 라디오버튼이 선택된다. 라디오버튼 그룹 중에 하나만 선택될 수 있기 때문에 마지막 <code>checked</code> 버튼 외에 나머지는 모두 선택 해제된다.</p>\n<h1>7. 버튼 타입들</h1>\n<p>이 3가지 타입들은 버튼 역할을 하며, <code>&#x3C;button></code> 태그에도 type으로 지정될 수 있다. <code>button</code> 태그가 내부 컨텐츠도 넣을 수 있는 등 더 스타일링이 쉽다는 등의 장점이 있다.</p>\n<h2>7.1. type=\"submit\"</h2>\n<p>폼을 제출하는 버튼을 만든다. <code>value</code> 특성으로 버튼의 라벨을 지정할 수 있다. <code>value</code> 생략시 제출에 해당하는 기본 라벨(브라우저마다 조금 다르다)이 붙는다.</p>\n<p>역시 formaction, formenctype, formmethod, formnovalidate, formtarget 속성을 사용하여 <code>&#x3C;form></code>에 사용된 대응하는 속성을 오버라이딩할 수 있다.</p>\n<p><code>&#x3C;button></code> 속성의 type을 지정하지 않고 쓸 경우 이 input과 같은 역할을 하게 된다.</p>\n<h2>7.2. type=\"reset\"</h2>\n<p>폼의 모든 값을 기본값으로 초기화하는 버튼을 만든다. <code>value</code> 특성으로 버튼의 라벨을 지정할 수 있다. <code>value</code> 생략시 초기화에 해당하는 기본 라벨(브라우저마다 조금 다르다)이 붙는다. 그다지 사용이 권장되지 않는다.</p>\n<h2>7.3. type=\"button\"</h2>\n<p>특별한 기능은 없는 푸시 버튼을 렌더링한다. 물론 <code>onclick</code> 특성을 통해 클릭 이벤트를 지정할 수는 있다.</p>\n<pre><code class=\"language-html\">&#x3C;input type=\"button\" value=\"버튼의 라벨로 사용할 문자열\" />\n</code></pre>\n<p>요즘은 이미지도 포함할 수 있고 더 직관적이라는 장점 때문에 <code>button</code> 요소를 사용하는 것이 더 선호되지만 <code>input</code> 요소의 <code>button</code> 타입을 쓰는 것도 전혀 문제없다.</p>\n<p><code>accesskey</code> 특성을 사용해서 단축키를 지정할 수 있다. 단 지정한 키를 그대로 사용하는 건 아니고 특정 키를 같이 눌러야 할 수 있다. 이는 <a href=\"https://developer.mozilla.org/ko/docs/Web/HTML/Global_attributes/accesskey\">accesskey 전역 특성</a>문서의 활성화 방법을 참고하자.</p>\n<p>그러나 이는 접근성이나 다른 보조 기술 기능과의 충돌 문제 등으로 인해 단축키 지정은 일반적으로 권장되지 않는다.</p>\n<p><code>disabled</code>속성으로 간단히 비활성화 가능하다.</p>\n<h1>8. type=\"image\"</h1>\n<p>이미지가 들어간 제출 버튼을 만들고 싶을 때 사용한다. <code>src</code> 특성으로 이미지를 지정하고 <code>alt</code> 특성으로 대체 텍스트를 지정할 수 있다. <code>value</code> 속성은 받지 않는다.</p>\n<p><code>&#x3C;img></code> 태그와 같은 종류의 어트리뷰트에 더해서 다른 폼 버튼들이 가지고 있는 어트리뷰트들도 사용할 수 있다.</p>\n<pre><code class=\"language-html\">&#x3C;input type=\"image\" id=\"imageInput\" alt=\"Login Button\" src=\"/login-button-image.png\" />\n</code></pre>\n<p>src, alt 속성은 필수로 지정해 주어야 한다.</p>\n<h2>8.1. formaction 속성</h2>\n<p><code>formaction</code> 속성은 이 버튼을 눌렀을 때 어떤 URL로 데이터가 제출될지를 지정한다. 이 input을 소유하고 있는 form의 <code>action</code>보다 더 우선적으로 적용된다.</p>\n<h2>8.2. formenctype 속성</h2>\n<p><code>formenctype</code>은 폼 데이터를 인코딩할 때 어떤 방식을 사용할지 결정하며 <a href=\"https://witch.work/posts/dev/html-form#4.1.1.-enctype\">form의 enctype 속성</a>과 같은 역할을 한다.</p>\n<p>역시 <code>form</code>의 enctype보다 우선적으로 적용된다.</p>\n<h2>8.3. formmethod</h2>\n<p>어떤 HTTP 메서드로 폼 데이터를 전송할지를 결정한다. <code>form</code>의 <code>method</code> 속성과 같은 역할을 한다. 기본값은 역시 <code>get</code> 이다.</p>\n<p><code>dialog</code> 라는 값도 있는데 이는 이 버튼이 input이 연관되어 있는 <code>&#x3C;dialog></code>를 닫는다는 의미이다.</p>\n<h2>8.4. 기타</h2>\n<p>formnovalidate, formtarget 속성도 있는데 이는 form의 <a href=\"https://witch.work/posts/dev/html-form#4.1.-form\">novalidate, target 속성</a>과 같은 역할을 한다.</p>\n<p>이들은 모두 <code>form</code>의 속성보다 우선적으로 적용된다.</p>\n<p>그리고 이 input이 폼 제출 용도로 쓰였을 경우, 버튼에 지정한 <code>value</code>는 양식에 전송되지 않는다. 대신 제출할 때 클릭한 위치의 좌표(이미지의 왼쪽 위를 <code>(0,0)</code>이라 할 때의 좌표)가 <code>x</code>, <code>y</code>라는 프로퍼티로(즉 버튼에 지정한 <code>name</code>이 <code>prop</code>이라면 <code>prop.x</code>, <code>prop.y</code>로 전송된다는 뜻이다) 전송된다.</p>\n<p>예를 들어서 <code>formmethod</code>가 <code>get</code>인 상태로 폼이 제출되면 다음과 같은 URL이 생성된다. 버튼의 이름이 <code>prop</code>이라고 가정하였다.</p>\n<pre><code>https://example.com/?prop.x=10&#x26;prop.y=20\n</code></pre>\n<h1>9. type=\"file\"</h1>\n<p>저장장치 파일 하나 혹은 여러 개(<code>multiple</code> 속성 사용시)를 선택할 수 있다. 그후 폼을 제출하거나 <a href=\"https://developer.mozilla.org/ko/docs/Web/API/File_API/Using_files_from_web_applications\">File API</a>로 조작 가능하다.</p>\n<p><code>value</code>는 선택한 파일 중 첫번째의 경로를 나타내는 DOMString을 담는다.</p>\n<p><code>accept</code> 속성을 이용해 허용할 파일 유형을 정할 수 있다. <code>multiple</code> 속성을 지정 시 쉼표로 구분해서 여러 파일 유형 지정도 가능.</p>\n<pre><code class=\"language-html\">&#x3C;input type=\"file\" name=\"file\" id=\"file\" accept=\"image/*\" multiple />\n</code></pre>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/HTML/Element/input/file#%EC%98%88%EC%A0%9C\">예제도 있다.</a> 특히 시각적으로는 input을 숨긴 후 해당 input에 대응하는 label을 스타일링해서 파일 업로드를 위한 버튼처럼 쓰는 게 인상깊다. 이외에도 파일 이름/크기 가져오기 등 참고할 부분이 많았다.</p>\n<p>몇몇 모바일 장치에서는 이 input이 장치의 카메라나 마이크에 직접 접근해서 사진이나 동영상을 찍어서 올릴 수 있게 해주기도 한다.</p>\n<pre><code class=\"language-html\">&#x3C;input type=\"file\" accept=\"image/*;capture=camera\" />\n&#x3C;input type=\"file\" accept=\"video/*;capture=camcorder\" />\n&#x3C;input type=\"file\" accept=\"audio/*;capture=microphone\" />\n</code></pre>\n<h1>10. 공통 속성</h1>\n<p>모든 폼(양식) 요소들에 공통으로 들어가는 속성들이 몇 가지 있다. 당연히 <code>&#x3C;input></code>에도 들어간다. 이 중 일부를 간단히 알아보자.</p>\n<h2>10.1. name</h2>\n<p>폼 요소가 제출될 때 해당 요소의 value에 대응되는 이름을 지정한다. 이 이름은 서버에서 폼 데이터를 받을 때 사용된다.</p>\n<h2>10.2. value</h2>\n<p>폼 요소의 기본값을 지정한다. 사용자가 직접 입력하면 이 값은 무시된다.</p>\n<h2>10.3. disabled</h2>\n<p>폼 요소를 비활성화하여 사용자가 해당 요소와 상호작용할 수 없도록 한다. 만약 이 속성이 명시되지 않으면 부모로부터 상속한다.</p>\n<p>예를 들어서 <code>&#x3C;fieldset></code> 요소에 <code>disabled</code> 속성을 지정하면 그 하위의 모든 폼 요소들이 비활성화된다.</p>\n<h2>10.4. form</h2>\n<p>해당 양식 요소와 연관되어 있는 <code>&#x3C;form></code> 요소의 id를 지정한다. <code>&#x3C;form></code>에 감싸여 있지 않은 요소들에 사용하며, 이렇게 연관시키는 <code>&#x3C;form></code>은 해당 요소와 같은 문서 내에 있어야 한다.</p>\n<h2>10.5. autofocus</h2>\n<p>페이지가 로드되었을 때 해당 요소에 자동으로 포커스를 준다. 페이지 내에 하나의 요소만 <code>autofocus</code>를 지정할 수 있다.</p>\n<h2>10.6. autocomplete</h2>\n<p>사용자가 이전에 입력한 값들을 자동완성으로 제공할지를 결정한다(보통은 그렇지만, 기본적으로 자동완성으로 제안하는 값들은 브라우저에서 선택한다).</p>\n<p><code>on</code>이면 자동완성을 제공하고, <code>off</code>면 제공하지 않는다. 지정하지 않으면 연관된 <code>&#x3C;form></code>의 값을 사용한다.</p>\n<p><code>on</code>, <code>off</code> 외에도 <code>email</code> 이나 <code>username</code> 등의 특정한 값들을 지정할 수 있다. 이는 브라우저가 해당 값에 맞는 자동완성을 제공한다는 의미이다.</p>\n<h1>11. type=\"email\"</h1>\n<p><strong>여기부터는 HTML5에서 추가된 input 타입들이다. 대부분의 타입들이 거의 모든 브라우저에서 지원하나 예외도 가끔씩 있다. 몇몇 주요 브라우저에서 지원하지 않는 type=\"week\"등이 좋은 예시다.</strong></p>\n<p>이메일 혹은 이메일들을 입력받을 수 있는 인터페이스를 제공한다.</p>\n<pre><code class=\"language-html\">&#x3C;input type=\"email\" name=\"email\" id=\"email\" />\n</code></pre>\n<p>입력되는 값들은 비어 있거나 이메일 형식을 갖추고 있는지 자동으로 유효성 검사를 거친다. 만약 유효성 검사를 통과하지 못하는 값이 들어 있는 채로 폼이 제출될 경우 브라우저가 경고를 띄우고 폼 제출을 막는다.</p>\n<p>현재 필드에 있는 값이 유효한 이메일인지에 따라서 <code>:valid</code> 혹은 <code>:invalid</code> 유사 클래스 CSS 선택자가 활성화된다.</p>\n<p>그리고 스마트폰과 같은 기기에서는 <code>@</code>가 포함되어 있어 이메일 입력을 더 쉽게 할 수 있는 키보드가 보이는 등의 동작이 기본적으로 지원될 수 있다.</p>\n<p>주의할 점은, 이 input 태그의 유효성 검사를 보안상의 데이터 검증 목적으로 쓰면 안된다는 사실이다. 폼에서 제출된 데이터는 언제나 서버사이드에서도 유효성 검사가 이루어져야 한다.</p>\n<p>클라이언트 사이드 유효성 검사는 너무 우회하기 쉽기 때문이다. 사용자는 개발자 도구를 이용해서 HTML을 변조하거나 postman 등을 통해서 서버에 직접 데이터를 전송할 수도 있는데 이러면 클라이언트의 유효성 검사를 우회할 수 있다.</p>\n<h2>11.1. list 속성</h2>\n<p><code>&#x3C;datalist></code> 요소의 id를 <code>list</code> 속성으로 전달하여 사용자에게 선택지를 제공할 수 있다. 단 이는 사용자에게 제안하는 것이지 사용자는 이렇게 제안된 값들 중 하나를 선택하지 않아도 된다.</p>\n<pre><code class=\"language-html\">&#x3C;input type=\"email\" name=\"email\" list=\"emailList\">\n&#x3C;datalist id=\"emailList\">\n  &#x3C;option value=\"soakdma37@gmail.com\">&#x3C;/option>\n  &#x3C;option value=\"foo@unknown.net\">&#x3C;/option>\n&#x3C;/datalist>\n</code></pre>\n<h2>11.2. 다른 속성들</h2>\n<p><code>minlength</code>, <code>maxlength</code>, <code>placeholder</code>, <code>size</code>, <code>pattern</code> 속성 등 사용 가능.</p>\n<p><code>multiple</code> 속성 지정시 유저가 쉼표 혹은 스페이스로 구분된 여러 개의 이메일을 입력할 수 있게 된다.</p>\n<pre><code class=\"language-html\">&#x3C;input id=\"email\" type=\"email\" multiple />\n</code></pre>\n<p>주의할 점이 있다. <code>multiple</code> 속성을 지정하게 되면 빈 문자열조차 유효한 값이 되는데, 이렇게 되면 <code>required</code>속성을 지정해도 빈 문자열이 유효성 검사를 통과하게 된다. 따라서 최소 하나의 이메일을 받아야 할 때는 정규식 등을 통해 유효성 검사를 직접 하거나 <code>multiple</code> 을 쓰지 말자.</p>\n<h1>12. type=\"search\"</h1>\n<p>검색어를 입력받을 수 있는 인터페이스를 제공한다. 기능적으로는 <code>text</code> type과 같지만 브라우저마다 조금 다르게 스타일링될 수 있다.</p>\n<p>폼에서 검색어 쿼리를 날리는 용도이기 때문에 <code>name</code>으로 <code>q</code>가 많이 사용된다.</p>\n<pre><code class=\"language-html\">&#x3C;input type=\"search\" name=\"q\" />\n</code></pre>\n<p>역시 text type input과 같이 list, minlength, maxlength, pattern, placeholder, readonly, required, size, spellcheck 특성을 사용할 수 있다.</p>\n<h2>12.1. text type과의 차이</h2>\n<p>브라우저에 따라서 둥근 모서리를 가진 창으로 렌더링될 수 있고, 검색어를 지울 수 있는 <code>X</code> 버튼이 표시될 수 있다. 이는 <code>text</code> type에서는 지원되지 않는다.(CSS 스타일링을 하지 않았다고 할 때) 그리고 스마트폰 등 키보드가 동적인 기기에서는 키보드에 <code>검색</code>키가 포함되어 나올 수 있다.</p>\n<p>그리고 몇몇 최신 브라우저에서는 최근 검색어를 저장하고 이를 자동완성으로 제공한다.</p>\n<h2>12.2. 접근성</h2>\n<p>다음과 같이 검색 폼을 만드는 경우가 많다. <code>placeholder</code>로 검색창임을 나타내는 것이다.</p>\n<pre><code class=\"language-html\">&#x3C;form>\n  &#x3C;div>\n    &#x3C;input\n      type=\"search\"\n      id=\"mySearch\"\n      name=\"q\"\n      placeholder=\"사이트 내 검색\" \n    />\n    &#x3C;button>검색&#x3C;/button>\n  &#x3C;/div>\n&#x3C;/form>\n</code></pre>\n<p>하지만 이렇게 되면 몇몇 스크린 리더는 placeholder를 읽지 않기 때문에 검색창이 무엇인지 알 수 없다. 따라서 <code>&#x3C;form></code>태그의 role과 <code>aria-label</code>을 사용해서 검색창임을 알려줘야 한다.</p>\n<pre><code class=\"language-html\">&#x3C;form role=\"search\">\n  &#x3C;div>\n    &#x3C;input\n      type=\"search\"\n      id=\"mySearch\"\n      name=\"q\"\n      placeholder=\"사이트 내 검색\"\n      aria-label=\"검색어 입력창\"\n    />\n    &#x3C;button>검색&#x3C;/button>\n  &#x3C;/div>\n&#x3C;/form>\n</code></pre>\n<p>이렇게 하면 보이는 디자인에는 차이가 없지만 접근성이 향상된다.</p>\n<h1>13. type=\"tel\"</h1>\n<p>전화번호를 입력받을 수 있는 인터페이스를 제공한다. 나라마다 전화번호의 표기 방식이 다르기 때문에 기본 유효성 검사가 제공되지는 않는다. 대신 <code>pattern</code> 속성을 사용해서 정규식으로 값을 검증할 수 있다.</p>\n<pre><code class=\"language-html\">&#x3C;input type=\"tel\" id=\"tel\" name=\"tel\" />\n</code></pre>\n<p>MDN에서는 <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/tel#examples\">몇몇 지역에 대해 선택지를 주고 선택한 지역의 전화번호 형식을 검증하는 예제를 제공한다.</a></p>\n<p>text type과 같아 보이지만 유용한 점도 있다. 예를 들어서 이 타입의 input을 지원하는 모바일 브라우저에서는 전화번호 입력에 최적화된 동적 키보드를 제공한다. 물론 지원하지 않는 모바일 브라우저에서는 <code>type=\"text\"</code>가 된다.</p>\n<p>단 모바일 브라우저 중 가장 늦게 이를 지원하기 시작한 웹뷰 안드로이드 브라우저에서조차 2014년 9월 3일부터 <code>type=\"tel\"</code>을 지원하므로 대부분의 브라우저에서 된다고 보는 게 맞을 것 같다.</p>\n<h1>14. type=\"url\"</h1>\n<p>URL을 입력받을 수 있는 인터페이스를 제공한다. <code>http:</code> 같은 프로토콜을 갖췄는지 등, 제대로 URL 포맷을 갖춘 문자열인지에 대한 유효성 검사를 자동으로 진행한다. 빈 문자열도 유효하다(빈 문자열을 안 받으려면 <code>required</code> 속성 설정).</p>\n<p>단 이것은 문자열 포맷에 대한 검사이지, 실제로 URL 주소에 대한 페이지가 존재하는지에 대한 검사가 아닌 것을 주의하자. 이 URL의 양식에 대해서는 <a href=\"https://developer.mozilla.org/ko/docs/Learn/Common_questions/Web_mechanics/What_is_a_URL\">MDN - URL이란?</a> 참고.</p>\n<p>동적 키보드를 지원하는 브라우저에서는 URL 입력에 유용한 키들을 포함한 동적 키보드를 제공한다. 물론 지원 안하는 브라우저에선 역시 <code>type=\"text\"</code>가 된다.</p>\n<p><code>pattern</code> 속성을 사용해서 정규식으로 값을 검증할 수 있다. 특정 URL만 받고 싶은 등 단순한 URL 포맷 검증 이상의 검증이 필요할 때 사용할 수 있다.</p>\n<h1>15. type=\"number\"</h1>\n<p>텍스트 필드처럼 보이지만 숫자만 입력받을 수 있는 인터페이스를 제공하며 숫자가 아닌 값들을 거부하는 유효성 검사를 한다. 이 또한 동적 키보드 디바이스에서는 숫자 입력에 최적화된 키패드를 제공할 때가 있다.</p>\n<p>그리고 일반적으로 사용자가 숫자를 늘이거나 줄일 수 있도록 위/아래 화살표 버튼(스피너라고 한다)을 제공한다. 이 화살표에 따라 숫자가 얼마나 증가/감소할지는 <code>step</code> 특성으로 지정할 수 있다.</p>\n<p><code>min+step*i</code> 꼴이면서 <code>max</code> 미만인 숫자만 입력할 수 있는데, 기본 <code>step</code> 값은 1이므로 이 경우 소숫점 미만 자릿수는 입력할 수 없다. 소숫점 미만을 취급하고 싶다면 <code>step</code> 특성을 0.1같은 최소 단위나 <code>any</code> 등으로 지정하면 된다.</p>\n<p><code>list</code> 속성으로 <code>&#x3C;datalist></code>와 연결해서 선택지 지정 가능.</p>\n<p>사람의 나이나 키 같은, 어느 정도 제한이 있는 범위 내에서의 숫자를 사용할 때 유용하다. 만약 범위가 너무 크다면 <code>tel</code> 과 같은 다른 옵션을 고려해볼 수 있다.</p>\n<h2>15.1. 접근성</h2>\n<p><code>&#x3C;input type=\"number\"></code>태그의 role은 <code>spinbutton</code>으로 지정되어 있다. 만약 <code>spinbutton</code>이 양식에서 중요하지 않다면 이 태그 대신 <code>inputmode=\"numeric\"</code>을 쓰고 <code>pattern</code> 속성으로 숫자만 받도록 하는 것이 낫다.</p>\n<p>사용자가 다른 작업을 하다가 의도하지 않게 숫자를 증가/감소시킬 수도 있고 숫자가 아닌 것을 입력했을 때 명시적인 피드백도 없기 때문이다.</p>\n<p>또한 <a href=\"https://developer.mozilla.org/ko/docs/Web/HTML/Attributes/autocomplete\">autocomplete</a>속성을 사용해서 사용자가 더 빨리 폼을 완성하도록 도울 수 있다.</p>\n<h1>16. type=\"range\"</h1>\n<p>슬라이더로 숫자 범위를 입력받을 수 있는 인터페이스를 제공한다. <code>min</code>, <code>max</code>, <code>step</code> 특성을 사용할 수 있다. <code>value</code> 특성은 기본값으로 사용되며 <code>min</code>과 <code>max</code> 사이에 있어야 한다.</p>\n<p>이 슬라이더는 마우스, 터치패드, 키보드 방향키(슬라이더가 focus되어 있을 경우)로 조작할 수 있다.</p>\n<p>텍스트 필드에 비해서 입력이 덜 정확하기 때문에 그렇게까지 정확하지 않은 범위를 입력받을 때 쓸 수 있다.</p>\n<p><code>list</code>속성으로 <code>&#x3C;datalist></code>를 연결시켜 tick mark를 표시하는 것으로 대략적인 범위를 표시하거나 <code>&#x3C;output></code>으로 현재 값을 보여주는 등의 일이 가능은 하지만 기본적으로 사용자가 range input을 통해서 쉽게 정확한 값을 입력하기는 힘들기 때문이다.</p>\n<h1>17. 날짜와 시간 입력</h1>\n<p>날짜, 시간 입력을 받는 건 언제나 웹 개발자들에게 힘든 일이었다. datepicker와 timepicker의 크로스 브라우징과 같은 건 아직까지도 이슈다!</p>\n<p>HTML에선 완벽하진 않지만 이런 부분을 해결하기 위한 input type을 제공한다. 단 아직 몇몇 브라우저에서 지원되지 않는 input type들도 있는데 이런 input들은 <code>type=\"text\"</code>로 자동 변환된다.</p>\n<p>그런데 그렇게 되면 기존에 이 input들에서 지원하던 유효성 검사가 전혀 작동하지 않는다. 따라서 크로스 브라우징이 중요한 환경이라면 이제 소개할 날짜, 시간 입력을 위한 HTML input type을 믿기보다는 잘 알려진 라이브러리를 쓰거나 직접 구현하는 게 낫다.</p>\n<p>해당 input type이 지원되는 브라우저들에서도 디자인이 다르기도 하다. 더욱더 라이브러리 혹은 직접 구현이 권장되는 부분...</p>\n<p>다음 날짜/시간 입력 필드들은 모두 <code>min</code>, <code>max</code>, <code>step</code> 특성을 사용할 수 있다. <code>list</code>, <code>readonly</code> 속성도 사용가능. 이때 <code>max >= min</code>이어야 한다.</p>\n<h2>17.1. type=\"datetime-local\"</h2>\n<p>연, 월, 일 그리고 시간(시/분)을 입력받을 수 있는 인터페이스를 제공한다.</p>\n<p>이는 시간을 입력받는 데 쓰이지만 그것이 꼭 사용자가 있는 장소의 시간을 의미하는 것은 아니다. 특정한 time zone의 정보에 상관없이 그저 시간을 입력받을 뿐이다. 따라서 사용자가 있는 곳에서는 불가능한 시간을 입력할 수도 있다.</p>\n<h2>17.2. type=\"month\"</h2>\n<p>연, 월을 입력받을 수 있는 인터페이스를 제공한다. value는 <code>YYYY-MM</code> 형태를 한다. 단 실제 input에서는 <code>2023년 7월</code>과 같이 사용자의 지역에 따른 적당한 표현으로 연, 월을 표현한다.</p>\n<p>크로스 브라우징을 위해서 <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/month#examples\">직접 구현하는 예제가 있다.</a></p>\n<h2>17.3. type=\"time\"</h2>\n<p>시간을 입력받을 수 있는 인터페이스를 제공한다. <code>value</code> 특성은 <code>HH:MM</code> 형태를 한다. 초까지 포함하는 시간이라면 <code>HH:MM:SS</code>.</p>\n<p>크로스 브라우징 지원이 아직 완벽하지 않고 브라우저마다 timepicker의 디자인이 다르다. 따라서 완전한 크로스 브라우징을 위해서는 직접 구현하는 게 낫다.</p>\n<h2>17.4. type=\"week\"</h2>\n<p>연도와 주를 입력받을 수 있는 인터페이스를 제공한다. 나온지 꽤 되었는데도 Firefox, Safari에서 지원하지 않는 등 널리 쓰이지는 않는 것 같다. 이런 게 필요하면 직접 만들도록 하자.</p>\n<h2>17.5. type=\"date\"</h2>\n<p>날짜 유효성을 검증하는 텍스트 상자 혹은 날짜 선택을 할 수 있는 인터페이스를 제공한다. 연, 월, 일만 포함한다. 시간+날짜 조합은 앞에서 본 <code>time</code> 과 <code>datetime-local</code> 타입 input에서 지원한다.</p>\n<h1>18. type=\"color\"</h1>\n<p>사용자가 색상을 선택할 수 있는 인터페이스를 제공한다. color picker와 RGB값 입력을 제공한다. value는 <code>#rrggbb</code>와 같은 색상 코드이며 소문자로 저장된다.</p>\n<pre><code class=\"language-html\">&#x3C;input type=\"color\" name=\"color\" id=\"color\" />\n</code></pre>\n<h1>19. 기타 속성들</h1>\n<p>type에 따라 쓰이는 속성이 다른데 <a href=\"https://developer.mozilla.org/ko/docs/Web/HTML/Element/input\">MDN 문서</a>를 참고해서 필요할 때 갖다 쓰자.</p>\n<h1>참고</h1>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/HTML/Element/input\">https://developer.mozilla.org/ko/docs/Web/HTML/Element/input</a></p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Learn/Forms/Basic_native_form_controls\">https://developer.mozilla.org/en-US/docs/Learn/Forms/Basic_native_form_controls</a></p>",
    "excerpt": "HTML의 폼 양식 만들기글을 작성하는 중 input 태그에 관한 정리가 너무 길어져 글을 분리하였다.\n1. HTML의 input 태그\nMDN의 input 태그 문서, 더 간략히 정리된 표, 기본 폼 위젯 참고.\nHTML input 태그는 다양한 타입의 사용자 데이터를 받을 수 있는 요소를 생성한다. type 속성으로 어떤 종류의 데이터를 받을지를 지정할 수 있고 이외에도 다양한 특성을 가지고 있다.\n이 요소의 동작 방식은 type에 따라 매우 달라지기 때문에 ",
    "headingTree": [
      {
        "title": "1. HTML의 input 태그",
        "url": "#1-html의-input-태그",
        "items": []
      },
      {
        "title": "2. type=\"text\"",
        "url": "#2-typetext",
        "items": []
      },
      {
        "title": "3. type=\"password\"",
        "url": "#3-typepassword",
        "items": []
      },
      {
        "title": "4. type=\"hidden\"",
        "url": "#4-typehidden",
        "items": [
          {
            "title": "4.1. 폼 컨텐츠 ID 전송",
            "url": "#41-폼-컨텐츠-id-전송",
            "items": []
          },
          {
            "title": "4.2. 체크박스 기본값 제공",
            "url": "#42-체크박스-기본값-제공",
            "items": []
          },
          {
            "title": "4.3. 주의사항",
            "url": "#43-주의사항",
            "items": []
          }
        ]
      },
      {
        "title": "5. type=\"checkbox\"",
        "url": "#5-typecheckbox",
        "items": [
          {
            "title": "5.1. indeterminate",
            "url": "#51-indeterminate",
            "items": []
          },
          {
            "title": "5.2. 배치",
            "url": "#52-배치",
            "items": []
          },
          {
            "title": "5.3. name 중복",
            "url": "#53-name-중복",
            "items": []
          }
        ]
      },
      {
        "title": "6. type=\"radio\"",
        "url": "#6-typeradio",
        "items": []
      },
      {
        "title": "7. 버튼 타입들",
        "url": "#7-버튼-타입들",
        "items": [
          {
            "title": "7.1. type=\"submit\"",
            "url": "#71-typesubmit",
            "items": []
          },
          {
            "title": "7.2. type=\"reset\"",
            "url": "#72-typereset",
            "items": []
          },
          {
            "title": "7.3. type=\"button\"",
            "url": "#73-typebutton",
            "items": []
          }
        ]
      },
      {
        "title": "8. type=\"image\"",
        "url": "#8-typeimage",
        "items": [
          {
            "title": "8.1. formaction 속성",
            "url": "#81-formaction-속성",
            "items": []
          },
          {
            "title": "8.2. formenctype 속성",
            "url": "#82-formenctype-속성",
            "items": []
          },
          {
            "title": "8.3. formmethod",
            "url": "#83-formmethod",
            "items": []
          },
          {
            "title": "8.4. 기타",
            "url": "#84-기타",
            "items": []
          }
        ]
      },
      {
        "title": "9. type=\"file\"",
        "url": "#9-typefile",
        "items": []
      },
      {
        "title": "10. 공통 속성",
        "url": "#10-공통-속성",
        "items": [
          {
            "title": "10.1. name",
            "url": "#101-name",
            "items": []
          },
          {
            "title": "10.2. value",
            "url": "#102-value",
            "items": []
          },
          {
            "title": "10.3. disabled",
            "url": "#103-disabled",
            "items": []
          },
          {
            "title": "10.4. form",
            "url": "#104-form",
            "items": []
          },
          {
            "title": "10.5. autofocus",
            "url": "#105-autofocus",
            "items": []
          },
          {
            "title": "10.6. autocomplete",
            "url": "#106-autocomplete",
            "items": []
          }
        ]
      },
      {
        "title": "11. type=\"email\"",
        "url": "#11-typeemail",
        "items": [
          {
            "title": "11.1. list 속성",
            "url": "#111-list-속성",
            "items": []
          },
          {
            "title": "11.2. 다른 속성들",
            "url": "#112-다른-속성들",
            "items": []
          }
        ]
      },
      {
        "title": "12. type=\"search\"",
        "url": "#12-typesearch",
        "items": [
          {
            "title": "12.1. text type과의 차이",
            "url": "#121-text-type과의-차이",
            "items": []
          },
          {
            "title": "12.2. 접근성",
            "url": "#122-접근성",
            "items": []
          }
        ]
      },
      {
        "title": "13. type=\"tel\"",
        "url": "#13-typetel",
        "items": []
      },
      {
        "title": "14. type=\"url\"",
        "url": "#14-typeurl",
        "items": []
      },
      {
        "title": "15. type=\"number\"",
        "url": "#15-typenumber",
        "items": [
          {
            "title": "15.1. 접근성",
            "url": "#151-접근성",
            "items": []
          }
        ]
      },
      {
        "title": "16. type=\"range\"",
        "url": "#16-typerange",
        "items": []
      },
      {
        "title": "17. 날짜와 시간 입력",
        "url": "#17-날짜와-시간-입력",
        "items": [
          {
            "title": "17.1. type=\"datetime-local\"",
            "url": "#171-typedatetime-local",
            "items": []
          },
          {
            "title": "17.2. type=\"month\"",
            "url": "#172-typemonth",
            "items": []
          },
          {
            "title": "17.3. type=\"time\"",
            "url": "#173-typetime",
            "items": []
          },
          {
            "title": "17.4. type=\"week\"",
            "url": "#174-typeweek",
            "items": []
          },
          {
            "title": "17.5. type=\"date\"",
            "url": "#175-typedate",
            "items": []
          }
        ]
      },
      {
        "title": "18. type=\"color\"",
        "url": "#18-typecolor",
        "items": []
      },
      {
        "title": "19. 기타 속성들",
        "url": "#19-기타-속성들",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 3,
      "wordCount": 711
    },
    "url": "/posts/html-input-tag",
    "thumbnail": {
      "local": "/thumbnails/html-input-tag-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-html-input-tag-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAeUlEQVR4nGMoLCzk5eVNTknR1dU1NDSUlJRsbW39//8/w7Rp05ycnEJDQ62trRcvXnzq1KknT56AJNavX19YWFhaWnbw4KHfv3//hwEGOOv///+/wQAqcf7ipVOnTl04d+7ly5fIihha2rsbGpumTZt26tQpiCaIBAC9NWqHc9J9DQAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "html-link-tag",
    "title": "HTML의 링크 태그에 관하여",
    "date": "2023-06-28T01:00:00Z",
    "description": "HTML의 하이퍼링크 태그",
    "tags": [
      "HTML"
    ],
    "html": "<p>a태그는 다른 페이지로 이동하는 것 외에도 여러가지를 할 수 있다.</p>\n<h1>1. 기본</h1>\n<p>a 태그는 anchor로 다른 페이지 혹은 같은 페이지의 특정 위치, 파일 등 어떤 URL로의 하이퍼링크를 나타낸다. href(hypertext reference의 약자) 특성을 통해 링크의 목적지를 지정할 수 있다.</p>\n<p>이때 웹 상의 어떤 페이지로 이동할 때 쓰이는 텍스트 문자열은 URL이라 하고 Uniform Resource Locator의 약자이다. 그리고 그 내부의 특정 파일을 찾을 때 사용되는 경로 문자열이 path다.</p>\n<p>예를 들어 <code>https://www.naver.com/index.html</code>에서 <code>https://www.naver.com</code>은 URL이고 <code>/index.html</code>은 path다.</p>\n<pre><code class=\"language-html\">&#x3C;a href=\"https://www.google.com\">구글&#x3C;/a>\n</code></pre>\n<p>위의 a태그 내에 <code>구글</code>이라고 작성했듯이, a태그 내의 콘텐츠는 접근성을 위해 링크 목적지의 설명을 나타내야 한다.</p>\n<p>그리고 <code>target=\"_blank\"</code>로 새 창을 열거나 다운로드를 시작하는 링크의 경우 링크 클릭시 발생하는 일을 링크 텍스트에 명시하는 게 좋다.</p>\n<pre><code class=\"language-html\">&#x3C;a href=\"https://www.google.com\" target=\"_blank\">구글(새 탭에서 열림)&#x3C;/a>\n&#x3C;a href=\"https://www.youtube.com/watch?v=QH2-TGUlwu4\">노래 듣기(동영상 재생)&#x3C;/a>\n</code></pre>\n<p>링크 텍스트를 쓸 때에 지켜야 할 다른 원칙으로는 URL을 링크 텍스트의 일부로 반복하지 말기, <code>여기를 클릭</code>같은 의미없는 링크 텍스트를 사용하지 말기(스크린 리더는 사용자에게 링크의 존재를 알려주고, 또한 시각적으로도 링크는 구분되기 때문), 짧은 링크 텍스트 쓰기 등이 있다.</p>\n<h2>1.1. 블록 레벨 링크</h2>\n<p>블록 레벨 요소라도 <code>&#x3C;a></code>태그로 감싸서 링크로 만들 수 있다. 다음과 같이 하면 제목 태그를 링크로 만들 수 있다.</p>\n<pre><code class=\"language-html\">&#x3C;a href=\"https://witch.work/\">\n  &#x3C;h1>내 블로그&#x3C;/h1>\n&#x3C;/a>\n</code></pre>\n<p>이미지 또한 <code>&#x3C;img></code>태그를 <code>&#x3C;a></code>로 감싸면 링크가 된다. 단 a 태그 내에 이미지 등을 넣어 링크의 행동을 나타낼 땐 img 태그에 alt 텍스트를 꼭 지정하자.</p>\n<h1>2. URL 지정</h1>\n<h2>2.1. 외부 URL</h2>\n<p>앞서 본 것처럼 href 속성에 URL을 넣으면 된다.</p>\n<pre><code class=\"language-html\">&#x3C;a href=\"https://www.google.com\">구글&#x3C;/a>\n</code></pre>\n<p>상대 URL을 넣을 수도 있다. 혹은 <code>href=\"../projects/index.html\"</code>과 같이 파일 상대 경로를 지정할 수도 있다.</p>\n<h2>2.2. 같은 페이지의 문서 조각</h2>\n<p>문서 조각이란 문서 내의 특정 위치를 가리키는 것이다. 문서 조각은 <code>#</code>으로 시작하며, 문서 내의 특정 id를 가리킨다.</p>\n<p>다음과 같이 하면 문서 내의 <code>id=\"section-1\"</code>을 가진 요소로 이동한다.</p>\n<pre><code class=\"language-html\">&#x3C;a href=\"#section-1\">섹션 1로 이동&#x3C;/a>\n</code></pre>\n<p>물론 이는 다른 페이지에도 가능하다. 가령 <code>https://www.google.com</code>의 <code>#section-1</code>로 이동하고 싶다면 다음과 같이 하면 된다.</p>\n<pre><code class=\"language-html\">&#x3C;a href=\"https://www.google.com#section-1\">구글의 섹션 1로 이동&#x3C;/a>\n</code></pre>\n<h2>2.3. 다운로드 링크</h2>\n<p>브라우저에서 페이지를 여는 것이 아니라 다운로드할 리소스에 연결할 경우 <code>download</code> 특성을 사용하여 다운로드될 파일의 기본 이름을 지정할 수 있다.</p>\n<pre><code class=\"language-html\">&#x3C;a href=\"다운로드 링크\" download=\"blabla.pdf\">구글 다운로드&#x3C;/a>\n</code></pre>\n<h2>2.4. 이메일 주소</h2>\n<p>href 속성에 <code>mailto:</code>를 사용하여 이메일 주소를 지정할 수 있다.</p>\n<pre><code class=\"language-html\">&#x3C;a href=\"mailto:soakdma37@gmail.com\">블로그 주인에게 이메일&#x3C;/a>\n</code></pre>\n<p>사실 이메일 주소도 지정하지 않을 수 있는데 이를 생략하면 브라우저는 그냥 사용자의 메일 클라이언트를 이용해 새로운 메일 보내기 창을 띄운다.</p>\n<p>또한 속성도 몇 개 지정할 수 있는데 subject(제목), cc(참조), bcc(숨은 참조), body(본문) 등을 지정할 수 있다. 이는 URL 쿼리스트링 형식과 같이 쓴다.</p>\n<p><code>?</code>를 사용하고 <code>&#x26;</code>로 구분하여 입력하면 된다.</p>\n<pre><code class=\"language-html\">&#x3C;a href=\"mailto:soakdma37@gmail.com?\ncc=참조메일주소1, 참조메일주소2&#x26;\nbcc=숨은참조메일주소1, 숨은참조메일주소2&#x26;\nsubject=메일제목&#x26;\nbody=메일본문\">형식을 지정한 이메일 링크&#x3C;/a>\n</code></pre>\n<h2>2.5. 전화번호</h2>\n<p>href 속성에 <code>tel:</code>을 사용하여 전화번호를 지정할 수 있다.</p>\n<pre><code class=\"language-html\">&#x3C;a href=\"tel:010-1234-5678\">블로그 주인에게 전화&#x3C;/a>\n</code></pre>\n<p>이 링크는 장치에 따라 동작이 바뀐다. 휴대전화에선 번호를 자동으로 입력하며 데스크톱에선 Skype등 전화를 걸 수 있는 프로그램을 실행한다.</p>\n<h1>3. 상대 링크 vs 절대 링크</h1>\n<p>링크 목적지를 만들 때 상대 URL, 절대 URL 중 어느 것을 사용하는 것이 좋을까?</p>\n<p>문서의 구조가 바뀌면 상대 URL을 사용한 링크는 더 이상 제대로 작동하지 않을 수 있다. 따라서 절대 URL을 사용하는 것이 좋다고 생각할 수 있다.</p>\n<p>하지만 동일한 사이트 내의 다른 위치에 연결할 때는 가능한 상대 링크를 사용하는 것이 좋다. 이유는 2가지가 있다.</p>\n<p>첫째로 상대 링크가 일반적으로 더 짧기 때문에 코드를 읽기 쉽다.</p>\n<p>둘째로 성능이 좋아진다. 절대 URL을 사용시 브라우저가 새로운 페이지를 불러오기 위해 DNS 서버에 쿼리를 날리고 해당 서버에서 요청된 파일을 찾는 작업을 하게 된다(사실 동일한 페이지에 있는 링크라면 이럴 필요가 없는데도!).</p>\n<p>반면 상대 URL 사용시 브라우저는 같은 서버에서 해당 URL을 탐색하기만 하면 되기 때문에 성능이 좋아진다. 절대 URL을 사용하면 브라우저가 추가 작업을 해야 하기 때문에 성능이 떨어진다.</p>\n<h1>4. 부가기능</h1>\n<h2>4.1. title</h2>\n<p>title 속성을 넣어서 마우스 호버 시 나오는 링크 제목을 지정할 수 있다.</p>\n<pre><code class=\"language-html\">&#x3C;a href=\"https://www.google.com\" title=\"구글로 이동\">구글&#x3C;/a>\n</code></pre>\n<p>단 title에 지정된 정보가 정말로 중요하다면 해당 정보를 링크 태그의 컨텐츠에 넣어 주어야 한다. 이렇게 지정한 <code>title</code>은 키보드로만 페이지를 탐색하는 사용자가 접근할 수 없기 때문이다.</p>\n<h2>4.2. 가짜 버튼</h2>\n<p>권장되는 방식은 아니지만 a 태그를 버튼처럼 사용할 수도 있다. 어차피 role을 무시하고 사용하는 시점에서 굳이 할 필요 없을 수도 있지만, <code>role=\"button\"</code>을 지정해 주어야 한다.</p>\n<p>href를 <code>javascript:void(0)</code>으로 지정하면 클릭 시 아무런 일도 일어나지 않는다. 그리고 여기 click 이벤트 핸들러를 등록하면 버튼이 된다.</p>\n<pre><code class=\"language-html\">&#x3C;a href=\"javascript:void(0)\" role=\"button\">구글&#x3C;/a>\n</code></pre>\n<p>하지만 당연하게도 링크의 복사/드래그, 링크를 열 때, 스크립트 오류가 발생했을 때 등의 상황에 예측되지 않는 동작을 발생시킬 수 있고 접근성도 떨어진다. <code>button</code> 태그를 사용하는 게 올바른 선택이다.</p>\n<h2>4.3. URL 표시 위치</h2>\n<p><code>target=\"_blank\"</code>를 설정하면 링크의 목적지가 새로운 브라우징 맥락에서 표시되는 건 유명하다. 여기서 발생하는 <a href=\"https://witch.work/posts/misc/security-of-link-tag\">보안 문제도 있다.</a></p>\n<p>아무튼 target 속성을 이용해서 링크한 URL을 표시할 위치를 지정할 수 있다.</p>\n<p>기본값은 <code>_self</code>이며 현재 브라우징 맥락에 링크 목적지를 표시하는 것이. 그리고 앞서 말한 <code>_blank</code>는 새 브라우징 맥락에 링크 목적지를 표시한다.</p>\n<p><code>_parent</code>는 URL을 현재 브라우징 맥락의 부모에 표시한다. 부모가 없을 시 <code>_self</code>와 같이 동작.</p>\n<p><code>_top</code>은 URL을 최상위 브라우징 맥락에 표시한다. 부모가 없을 시 <code>_self</code>와 같이 동작.</p>\n<h1>참고</h1>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Learn/HTML/Introduction_to_HTML/Creating_hyperlinks#%EC%9D%B4%EB%A9%94%EC%9D%BC_%EB%A7%81%ED%81%AC\">https://developer.mozilla.org/ko/docs/Learn/HTML/Introduction_to_HTML/Creating_hyperlinks#%EC%9D%B4%EB%A9%94%EC%9D%BC_%EB%A7%81%ED%81%AC</a></p>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Learn/HTML/Introduction_to_HTML/Creating_hyperlinks\">https://developer.mozilla.org/ko/docs/Learn/HTML/Introduction_to_HTML/Creating_hyperlinks</a></p>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/HTML/Element/a#%EC%A0%88%EB%8C%80_url%EB%A1%9C_%EC%97%B0%EA%B2%B0\">https://developer.mozilla.org/ko/docs/Web/HTML/Element/a#%EC%A0%88%EB%8C%80_url%EB%A1%9C_%EC%97%B0%EA%B2%B0</a></p>",
    "excerpt": "a태그는 다른 페이지로 이동하는 것 외에도 여러가지를 할 수 있다.\n1. 기본\na 태그는 anchor로 다른 페이지 혹은 같은 페이지의 특정 위치, 파일 등 어떤 URL로의 하이퍼링크를 나타낸다. href(hypertext reference의 약자) 특성을 통해 링크의 목적지를 지정할 수 있다.\n이때 웹 상의 어떤 페이지로 이동할 때 쓰이는 텍스트 문자열은 URL이라 하고 Uniform Resource Locator의 약자이다. 그리고 그 내부의 특정 파일을 찾",
    "headingTree": [
      {
        "title": "1. 기본",
        "url": "#1-기본",
        "items": [
          {
            "title": "1.1. 블록 레벨 링크",
            "url": "#11-블록-레벨-링크",
            "items": []
          }
        ]
      },
      {
        "title": "2. URL 지정",
        "url": "#2-url-지정",
        "items": [
          {
            "title": "2.1. 외부 URL",
            "url": "#21-외부-url",
            "items": []
          },
          {
            "title": "2.2. 같은 페이지의 문서 조각",
            "url": "#22-같은-페이지의-문서-조각",
            "items": []
          },
          {
            "title": "2.3. 다운로드 링크",
            "url": "#23-다운로드-링크",
            "items": []
          },
          {
            "title": "2.4. 이메일 주소",
            "url": "#24-이메일-주소",
            "items": []
          },
          {
            "title": "2.5. 전화번호",
            "url": "#25-전화번호",
            "items": []
          }
        ]
      },
      {
        "title": "3. 상대 링크 vs 절대 링크",
        "url": "#3-상대-링크-vs-절대-링크",
        "items": []
      },
      {
        "title": "4. 부가기능",
        "url": "#4-부가기능",
        "items": [
          {
            "title": "4.1. title",
            "url": "#41-title",
            "items": []
          },
          {
            "title": "4.2. 가짜 버튼",
            "url": "#42-가짜-버튼",
            "items": []
          },
          {
            "title": "4.3. URL 표시 위치",
            "url": "#43-url-표시-위치",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 259
    },
    "url": "/posts/html-link-tag",
    "thumbnail": {
      "local": "/thumbnails/html-link-tag-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-html-link-tag-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAeElEQVR4nGPo6+tzcnKKjY0NCQlJTk728/MzNzfv7u5mKCoqYmNjCwwMvHbt2oULFyDkgwcPGJYvX97e3v7gwYP/qIDhxIkTs2fPvnXr1v///3///g0nGe7cvXcXhO6+e/cORcf8xcvnzJu3bt26a9euwZX///8fAKI9bSCfYLjUAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "html-metadata-tag",
    "title": "HTML의 문서 메타데이터 태그",
    "date": "2023-08-13T01:00:00Z",
    "description": "문서의 메타데이터를 나타내는 태그들",
    "tags": [
      "HTML"
    ],
    "html": "<h1>1. 간단한 문서 예시</h1>\n<p>가장 먼저 간단한 HTML 문서를 작성해 본다. 여기서 다루는 태그들은 아주 기본적인 태그들인데, 여기서 <code>&#x3C;body></code>내부의 태그들은 제외하고 먼저 문서의 메타데이터를 다루는 태그들을 알아보자.</p>\n<pre><code class=\"language-html\">&#x3C;!DOCTYPE html>\n&#x3C;html>\n  &#x3C;head>\n    &#x3C;meta charset=\"utf-8\">\n    &#x3C;title>HTML 문서&#x3C;/title>\n  &#x3C;/head>\n  &#x3C;body>\n    &#x3C;h1>HTML 문서&#x3C;/h1>\n    &#x3C;p>HTML 문서입니다.&#x3C;/p>\n  &#x3C;/body>\n&#x3C;/html>\n</code></pre>\n<p>이 문서의 요소들을 하나씩 살펴보자.</p>\n<h1>2. DOCTYPE 선언</h1>\n<p>이 선언은 웹 페이지를 호환 모드나 표준 모드 중 무엇으로 렌더링할지 결정할 때 사용된다. DOCTYPE 선언이 있으면 웹 페이지가 표준 모드로 렌더링된다. 이는 좋은 HTML로 인정받기 위해서 HTML 페이지가 따라야 할 규칙과의 연결 통로로 쓰였다.</p>\n<p>그리고 만약 우리의 페이지가 Content-Type HTTP 헤더를 <code>application/xhtml+xml</code> MIME 타입으로 설정함으로써 XHTML로 제공된다면 브라우저는 항상 페이지를 표준 모드로 렌더링하기 때문에 DOCTYPE 선언이 필요 없다.</p>\n<p>W3C에서 웹 표준을 제정할 당시 대부분의 웹사이트들은 새로운 표준을 지키지 않고 있었다. 때문에 브라우저들은 새로운 표준을 지키지 않는 웹사이트들을 렌더링할 때 기존의 방식대로 렌더링하도록 했다. 이를 호환 모드(Quirks Mode)라고 한다.</p>\n<p>요즘은 거의 표준 모드만 쓰이고 있지만 원래 웹브라우저에선 호환 모드, 거의 표준 모드, 표준 모드의 3가지 방식의 레이아웃 엔진을 지원한다.</p>\n<p>호환 모드에서는 웹 표준을 지키지 않는 웹사이트들을 렌더링할 때 기존의 방식대로 렌더링하도록 했다. 또한 완전 표준 모드에서는 HTML, CSS에 의해서만 웹 페이지가 표시된다. 거의 표준 모드에선 몇 가지 호환 모드 요소만 지원한다.</p>\n<h1>3. 메인 루트</h1>\n<p>문서의 최상단 요소로서, 문서의 전체 내용을 감싼다. 메인 루트는 늘 <code>&#x3C;html></code>태그이며 모든 다른 요소는 <code>&#x3C;html></code> 요소의 후손이어야 한다. 즉 메인 루트 요소는 HTML 태그 트리의 최상단에 위치해야 한다. 이 요소는 두 개의 자식 요소를 가지는데 head와 그 뒤를 따르는 body 요소이다.</p>\n<p>lang 특성을 지정할 수 있는데 이를 유효한 특성으로 지정할 시 스크린 리더가 음성 표현에 사용할 언어를 선택할 때 도움이 된다. 그리고 이렇게 유효한 lang 선언을 해야 title과 같이 중요한 메타데이터를 정확한 발음으로 표현할 수 있다.</p>\n<pre><code class=\"language-html\">&#x3C;html lang=\"ko\">\n</code></pre>\n<h1>4. base</h1>\n<p><code>base</code>요소는 문서의 모든 상대 URL이 사용할 기준 절대 URL을 지정한다. 따라서 문서엔 하나의 <code>base</code>요소만 존재 가능하다. 반드시 <code>&#x3C;head></code>태그 내에서 사용되어야 한다는 점에 유의한다.</p>\n<pre><code class=\"language-html\">&#x3C;base href=\"https://developer.mozilla.org/\" target=\"_blank\">\n</code></pre>\n<p>href는 상대 URL이 사용할 base URL을 설정하고 target은 해당 속성을 명시하지 않은 a, area, form 요소가 탐색을 할 때 그 결과를 보여줄 맥락을 지정한다. 예를 들어 <code>_blank</code>로 지정하면 결과를 새로운 브라우징 맥락에 보여준다.</p>\n<p><code>base</code> 태그 여러 개를 지정할 시 첫 번째 것만 사용되며 <code>og</code>태그에는 영향을 주지 않는다.</p>\n<h1>5. head</h1>\n<p><code>html</code>태그의 첫번째 자식 태그로 배치되며 사용자에게 보여지는 데이터가 아니라 브라우저가 식별할 수 있는 문서 메타데이터를 담는다. 제목, 스크립트, 사용할 스타일시트 파일 등을 담을 수 있다.</p>\n<pre><code class=\"language-html\">&#x3C;head>\n  &#x3C;title>HTML 문서&#x3C;/title>\n&#x3C;/head>\n</code></pre>\n<h1>6. link</h1>\n<p>현재 문서와 외부 리소스의 관계를 명시한다. CSS 스타일 시트 연결, <a href=\"https://witch.work/posts/favicon\">파비콘 설정</a> 등에 사용된다.</p>\n<pre><code class=\"language-html\">&#x3C;link rel=\"stylesheet\" href=\"style.css\">\n&#x3C;link rel=\"icon\" href=\"favicon.ico\">\n&#x3C;link rel='apple-touch-icon' sizes='180x180' href='/apple-touch-icon.png' />\n</code></pre>\n<p><code>media</code> 프로퍼티를 사용해서 미디어 쿼리에 따라 리소스를 불러오도록 할 수 있다.</p>\n<pre><code class=\"language-html\">&#x3C;link rel=\"stylesheet\" href=\"print.css\" media=\"print\">\n</code></pre>\n<h1>7. meta</h1>\n<p><code>meta</code>태그는 script, title 등 다른 메타 관련 요소로 나타낼 수 없는 문서의 메타데이터를 나타낸다. 가령 문서의 제작자, 설명, 키워드 등을 나타낼 수 있다.</p>\n<p><code>&#x3C;meta charset=\"utf-8\"></code>은 문서가 사용해야 할 문자 집합을 utf-8 유니코드로 설정한다. 다른 문자 집합을 사용하도록 할 수도 있다. utf-8이 일반적이긴 하지만 말이다.</p>\n<p>head 태그 내에 위치해야 하며 name, http-equiv, charset, itemprop 특성을 가질 수 있다.</p>\n<p>그리고 name을 메타데이터 이름으로, content를 값으로 하여 문서 메타데이터를 이름-값 쌍 형태로 제공할 수 있다. 다음과 같이 사용하는 것이다.</p>\n<pre><code class=\"language-html\">&#x3C;meta name=\"author\" content=\"김성현\">\n&#x3C;meta name=\"description\" content=\"HTML 문서입니다.\">\n</code></pre>\n<p>여기서 제공되는 표준 메타데이터 이름은 <a href=\"https://developer.mozilla.org/ko/docs/Web/HTML/Element/meta/name\">이곳</a>에서 볼 수 있다. viewport등 다양한 메타데이터를 제공할 수 있다.</p>\n<p>그리고 creator, robots등 다양한 비표준 메타데이터도 존재하는데 이 역시 meta 태그를 이용해 지정한다.</p>\n<p>한때는 <code>&#x3C;meta name=\"keywords\" content=\"...\"></code> 처럼 검색 엔진에 키워드를 제공하는 기능 등도 있었지만 이는 스팸에서 키워드 목록에 수백 개의 키워드를 채워버리는 등의 악용 사례가 있었기 때문에 이제는 많은 검색 엔진에서 이를 무시한다.</p>\n<p>단 <code>og:image</code>처럼 여전히 많이 사용하는 메타데이터도 존재한다. <code>og:</code>나 <code>twitter:</code>와 같은 메타데이터들은 여러 기업에서 더 풍부한 메타데이터 제공을 위해 발명한 메타데이터 프로토콜이다.</p>\n<h1>8. style</h1>\n<p>이 태그는 문서나 문서 일부에 대한 스타일 정보를 포함한다. 일반적으로는 외부 스타일시트에 작성하고 <code>link</code>로 연결하는 편이 좋지만 <code>style</code> 태그를 이용한 문서 스타일링도 가능하다.</p>\n<p><code>type=\"text/css\"</code>와 미디어 쿼리를 의미하는 <code>media</code>속성 등을 가질 수 있다.</p>\n<h1>9. title</h1>\n<p>title 태그는 브라우저의 제목 표시줄이나 페이지 탭에 보이는 문서의 제목을 나타낸다. title 태그는 head 태그 내에 있어야 한다. 그리고 head 요소에 딱 하나만 포함될 수 있다.</p>\n<p>이 태그 내용은 검색 결과에도 표시되고 사이트를 북마크할 때 추천되는 북마크 이름으로도 사용된다. SEO를 잘 수행하려면 문서를 잘 설명하는 제목을 짓는 것이 중요하다.</p>\n<p>제목의 의미를 가지는 h1 태그와는 다르며 다른 태그를 포함할 수 없다. 텍스트만 포함 가능하며 포함된 다른 태그는 무시된다.</p>\n<h1>10. body</h1>\n<p>사용자들에게 보여주길 원하는 모든 컨텐츠를 포함한다. 문서의 내용을 나타내는 것이다. 그리고 html 요소의 2번째 자식 요소여야 한다.</p>\n<h1>참고</h1>\n<p>HTML 기본 <a href=\"https://developer.mozilla.org/ko/docs/Learn/Getting_started_with_the_web/HTML_basics\">https://developer.mozilla.org/ko/docs/Learn/Getting_started_with_the_web/HTML_basics</a></p>",
    "excerpt": "1. 간단한 문서 예시\n가장 먼저 간단한 HTML 문서를 작성해 본다. 여기서 다루는 태그들은 아주 기본적인 태그들인데, 여기서 <body>내부의 태그들은 제외하고 먼저 문서의 메타데이터를 다루는 태그들을 알아보자.\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <title>HTML 문서</title>\n  </head>\n  <body>\n    <h1>HTML 문서</h1>\n    <p>HTML 문",
    "headingTree": [
      {
        "title": "1. 간단한 문서 예시",
        "url": "#1-간단한-문서-예시",
        "items": []
      },
      {
        "title": "2. DOCTYPE 선언",
        "url": "#2-doctype-선언",
        "items": []
      },
      {
        "title": "3. 메인 루트",
        "url": "#3-메인-루트",
        "items": []
      },
      {
        "title": "4. base",
        "url": "#4-base",
        "items": []
      },
      {
        "title": "5. head",
        "url": "#5-head",
        "items": []
      },
      {
        "title": "6. link",
        "url": "#6-link",
        "items": []
      },
      {
        "title": "7. meta",
        "url": "#7-meta",
        "items": []
      },
      {
        "title": "8. style",
        "url": "#8-style",
        "items": []
      },
      {
        "title": "9. title",
        "url": "#9-title",
        "items": []
      },
      {
        "title": "10. body",
        "url": "#10-body",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 188
    },
    "url": "/posts/html-metadata-tag",
    "thumbnail": {
      "local": "/thumbnails/html-metadata-tag-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-html-metadata-tag-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAfklEQVR4nGNobGxUVla2tLS0sbEJDg4WFBQUERFhYmJiCAgIsLS0vH379hkwOAEGe/fuZVi1apWPj09/f//evXv/////+/fv/2DAsHfv3paWltra2mXLlkEkIIDhxq1b9+7ff/z48efPnyFqoTomTZ3Z1z9h3rx5Z86cQTYKAGVjZHAfe++3AAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "html-misc-tags",
    "title": "HTML의 기타 태그들",
    "date": "2023-06-28T02:00:00Z",
    "description": "HTML의 잡다한 태그들 간략한 목록",
    "tags": [
      "HTML"
    ],
    "html": "<p><a href=\"https://witch.work/posts/html-basic-tag\">자주 쓰이는 주요한 태그들은 여기로</a></p>\n<h1>1. 인라인 텍스트 시맨틱 태그</h1>\n<h2>1.1. abbr</h2>\n<p>abbr 태그는 abbreviation의 약자로 약어를 나타낸다. title 특성을 통해 약어의 전체 내용을 제공할 수 있다. title 속성은 다른 내용을 포함하면 안된다.</p>\n<pre><code class=\"language-html\">&#x3C;abbr title=\"HyperText Markup Language\">HTML&#x3C;/abbr>\n</code></pre>\n<p>acronym 태그도 abbr 태그와 같은 기능을 한다. 하지만 acronym은 더 이상 사용되지 않는다. 따라서 abbr을 사용하도록 하자.</p>\n<h2>1.2. b</h2>\n<p>굵은 글씨를 나타낼 수 있다. <code>&#x3C;strong></code>과 달리 <code>&#x3C;b></code>콘텐츠에는 특별한 중요도가 부여되지는 않는다. CSS를 쓸 수 없는 브라우저에서 굵은 글씨를 나타낼 때 사용하였으나 이제는 거의 쓰이지 않는다.</p>\n<h2>1.3. bdi</h2>\n<p>이 태그에 포함된 텍스트를 주변 텍스트와 분리해서 처리하도록 브라우저에 지시한다.</p>\n<p>대부분의 언어는 왼쪽에서 오른쪽으로 써지지만, 아랍어와 같은 일부 언어는 오른쪽에서 왼쪽으로 쓴다. 브라우저는 이를 특정 알고리즘으로 처리하는데, 이 태그를 사용하면 브라우저가 해당 텍스트 방향성을 주변 텍스트와 별개로 처리하게 된다.</p>\n<p>텍스트 방향성을 미리 알 수 없는 콘텐츠 등을 문서에 포함시킬 때 사용된다.</p>\n<h2>1.4. bdo</h2>\n<p>현재 텍스트 쓰기 방향을 덮어쓰고 다른 방향으로 렌더링한다. dir 속성으로 방향을 지정할 수 있는데 ltr(왼쪽에서 오른쪽), rtl(오른쪽에서 왼쪽)을 지정할 수 있다.</p>\n<pre><code class=\"language-html\">&#x3C;bdo dir=\"rtl\">This text will be written from right to left&#x3C;/bdo>\n</code></pre>\n<h2>1.5. data</h2>\n<p>HTML data 태그는 콘텐츠를 기계가 읽을 수 있는 해석본과 연결한다. 상품 가격이나 상품 번호 등을 기계가 읽을 수 있도록 표시할 수 있다.</p>\n<p>시간 혹은 날짜 정보라면 <code>&#x3C;time></code> 태그를 사용하는 것이 더 좋다.</p>\n<h2>1.6. dfn</h2>\n<p>현재 맥락이나 문장에서 정의하고 있는 용어를 나타낸다. 가장 가까운 <code>&#x3C;p></code>, <code>&#x3C;dt>, &#x3C;dd></code>, <code>&#x3C;section></code> 조상 요소를 찾아서 그 안에서 정의하고 있는 용어를 나타낸다.</p>\n<pre><code class=\"language-html\">&#x3C;p>\n  &#x3C;dfn id=\"def-me\">마녀&#x3C;/dfn>는 이 블로그 주인의 닉네임이다.\n&#x3C;/p>\n</code></pre>\n<p>내부에 <code>&#x3C;abbr></code>태그를 넣으면 그 준말에 해당하는 정의를 하고 있음을 나타낸다.</p>\n<h2>1.7. kbd</h2>\n<p>키보드 입력 등 사용자의 입력을 나타낸다. 보통 키보드 입력을 나타내기 위해 사용한다.</p>\n<pre><code class=\"language-html\">&#x3C;p>Press &#x3C;kbd>Ctrl&#x3C;/kbd> + &#x3C;kbd>C&#x3C;/kbd> to copy the text.&#x3C;/p>\n</code></pre>\n<p><code>&#x3C;kbd></code>요소를 중첩해 사용하여 하나의 입력 안에 작은 부분 입력을 나타낼 수 있다.</p>\n<h2>1.8. rp, rt, ruby</h2>\n<p>동아시아 문자 발음을 표기하는 루비 주석을 나타내는 데 쓰인다.</p>\n<h2>1.9. s</h2>\n<p>글자에 취소선을 그린다. 단 편집 기록을 나타내야 한다면 del, ins를 대신 사용하는 게 맞다.</p>\n<h2>1.10. samp</h2>\n<p>컴퓨터 프로그램 출력의 예시(혹은 인용문)를 나타낸다.</p>\n<p>kbd 요소를 samp 요소 안에 배치하면 시스템이 재출력한 입력을 나타낼 수 있다.</p>\n<h2>1.11. small</h2>\n<p>덧붙이는 글이나 저작권 표시 등 작은 텍스트 표현. 푸터 등에 많이 쓴다.</p>\n<h2>1.12. sub, sup</h2>\n<p><code>&#x3C;sub></code>는 아래 첨자로 나타낼 인라인 텍스트를 지정한다. 기존의 관례상 아래 첨자로 나타나는 각주, 수학 변수의 숫자표기, 화학식 원소를 나타낼 때 등에 쓴다.</p>\n<p><code>&#x3C;sup></code>는 위 첨자로 나타낼 인라인 텍스트를 지정한다. 지수 표기, 4th와 같은 서수 표기 등에 사용한다.</p>\n<h2>1.13. u</h2>\n<p>글자로 표현하지 않는 주석을 가진 것으로 나타낼 텍스트를 나타낸다.</p>\n<p>브라우저에서는 단순한 밑줄로 나타나는데, 이를 밑줄 추가를 위해 사용해서는 안된다. 단순 밑줄을 위해서는 <code>text-decoration</code> CSS를 써야 한다.</p>\n<p>철자 오류가 있는 부분을 나타내는 등의 용도로 사용할 수 있다.</p>\n<pre><code class=\"language-html\">&#x3C;p>이런 방법을 시도해 봤는데 &#x3C;u>안됬어요&#x3C;/u>.&#x3C;/p>\n</code></pre>\n<p>하지만 대부분의 경우 em, mark, strong, cite, i 등 다른 태그를 사용하는 게 더 좋다.</p>\n<h2>1.14. var</h2>\n<p>수학 표현 등에서 변수명을 나타낸다.</p>\n<h2>1.15. wbr</h2>\n<p>현재 요소의 줄 바꿈 규칙을 무시하고 브라우저가 줄을 바꿀 수 있는 위치를 나타낸다. 쓸 일은 별로 없지 않을까...</p>",
    "excerpt": "자주 쓰이는 주요한 태그들은 여기로\n1. 인라인 텍스트 시맨틱 태그\n1.1. abbr\nabbr 태그는 abbreviation의 약자로 약어를 나타낸다. title 특성을 통해 약어의 전체 내용을 제공할 수 있다. title 속성은 다른 내용을 포함하면 안된다.\n<abbr title=\"HyperText Markup Language\">HTML</abbr>\n\nacronym 태그도 abbr 태그와 같은 기능을 한다. 하지만 acronym은 더 이상 사용되지 않는다. 따",
    "headingTree": [
      {
        "title": "1. 인라인 텍스트 시맨틱 태그",
        "url": "#1-인라인-텍스트-시맨틱-태그",
        "items": [
          {
            "title": "1.1. abbr",
            "url": "#11-abbr",
            "items": []
          },
          {
            "title": "1.2. b",
            "url": "#12-b",
            "items": []
          },
          {
            "title": "1.3. bdi",
            "url": "#13-bdi",
            "items": []
          },
          {
            "title": "1.4. bdo",
            "url": "#14-bdo",
            "items": []
          },
          {
            "title": "1.5. data",
            "url": "#15-data",
            "items": []
          },
          {
            "title": "1.6. dfn",
            "url": "#16-dfn",
            "items": []
          },
          {
            "title": "1.7. kbd",
            "url": "#17-kbd",
            "items": []
          },
          {
            "title": "1.8. rp, rt, ruby",
            "url": "#18-rp-rt-ruby",
            "items": []
          },
          {
            "title": "1.9. s",
            "url": "#19-s",
            "items": []
          },
          {
            "title": "1.10. samp",
            "url": "#110-samp",
            "items": []
          },
          {
            "title": "1.11. small",
            "url": "#111-small",
            "items": []
          },
          {
            "title": "1.12. sub, sup",
            "url": "#112-sub-sup",
            "items": []
          },
          {
            "title": "1.13. u",
            "url": "#113-u",
            "items": []
          },
          {
            "title": "1.14. var",
            "url": "#114-var",
            "items": []
          },
          {
            "title": "1.15. wbr",
            "url": "#115-wbr",
            "items": []
          }
        ]
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 100
    },
    "url": "/posts/html-misc-tags",
    "thumbnail": {
      "local": "/thumbnails/html-misc-tags-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-html-misc-tags-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAf0lEQVR4nGOoqalRUlKytLRMSkry9PTU0NDg4+OrqKhgWLduXXx8fGFhYU1NTWlp6b59+3bt2nXu3DmGd+/e3bp169GjR7du3bp27drnz5//gwEDhEIGv3//BklcvnrtwsWL165dffXqFbI0Q+/EKZ1d3fPmzT137hxc+f///wEAw2wLh3dsQAAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "html-multimedia-tag",
    "title": "HTML로 멀티미디어 다루기",
    "date": "2023-08-15T01:00:00Z",
    "description": "텍스트만 있는 따분한 페이지 벗어나기",
    "tags": [
      "HTML"
    ],
    "html": "<p>웹이 발전하면서 페이지에 이미지나 비디어 등의 멀티미디어를 넣을 수 있게 되었다. 어떻게 하는지 알아보자.</p>\n<h1>1. img</h1>\n<p>HTML에서 이미지를 넣기 위해서는 img태그를 사용한다. img태그는 내부 내용이나 닫는 태그가 없는 빈 태그이지만 src 속성 하나는 사용되어야 한다. 물론 대체 텍스트를 나타내는 <code>alt</code>속성도 지정해 주는 게 좋다.</p>\n<p>이때 src 속성에는 사용자 에이전트가 지원하는 파일 형식을 제공해야 한다. <a href=\"https://developer.mozilla.org/en-US/docs/Web/Media/Formats/Image_types\">웹 브라우저의 지원 이미지 형식 안내서</a></p>\n<p>src 속성은 삽입할 이미지의 경로를 나타내는데, 이는 절대경로, 상대경로, 또는 URL로 표현할 수 있다. 몇몇 검색 엔진은 이미지 파일 이름도 읽고 SEO에 포함시키므로 가능하면 파일 이름에도 의미를 담자. <code>img234395.jpg</code>보다는 <code>profile.jpg</code>가 낫다는 것이다.</p>\n<pre><code class=\"language-html\">&#x3C;img src=\"assets/profile.jpg\">\n</code></pre>\n<p>단 이때 <code>src</code>에 다른 웹사이트 주소를 바로 담는 것은 좋지 않다. 이를 hotlinking이라 하는데 이는 다른 사람의 bandwidth를 쓰는 것이므로 비도덕적이며 또한 웹사이트가 사라지거나 이미지가 삭제되는 등에 대한 제어를 전혀 할 수 없다는 단점도 있다.</p>\n<p>이미지는 inline 요소이지만 기본적으로 이미지 크기를 차지하므로 <code>inline-block</code>요소처럼 보인다.</p>\n<p><code>&#x3C;img></code>는 <a href=\"https://developer.mozilla.org/ko/docs/Web/CSS/Replaced_element\">대체 요소</a>이다. 현재 문서 스타일 영향을 받지 않으며 표현 결과가 CSS 서식 모델과 분리되어 외부 객체로 취급된다는 것이다. <code>div</code>등의 박스에 넣고 <code>object-fit</code>속성 등으로 제어하는 게 낫다.</p>\n<h2>1.1. alt 속성</h2>\n<p>img 태그의 alt 속성에 문자열을 할당해서 이미지가 로드되지 않았을 때 대체 텍스트를 넣을 수 있다. 이는 path나 파일명을 잘못 적거나 로드가 실패했을 때 표시된다.</p>\n<p>또한 스크린 리더는 alt 속성을 읽어주므로, 이미지가 아닌 텍스트로 표현할 수 있는 경우 alt 속성을 사용하는 도움이 된다. 그리고 검색 엔진은 alt 속성을 읽어서 SEO에 포함시키므로 검색 최적화에도 도움이 된다.</p>\n<p>Lynx와 같은 브라우저는 텍스트만 지원하므로 이런 브라우저의 사용자에게도 alt 속성이 필요하다.</p>\n<p>따라서 alt 속성에는 이미지가 나타나지 않을 때 사용자에게 대신 제공할 수 있는 설명을 넣어주자. 이미지가 쓰이는 목적을 설명하거나, 이미지에 포함된 텍스트를 대체할 수 있는 설명을 넣는 것이다.</p>\n<pre><code class=\"language-html\">&#x3C;img src=\"assets/profile.jpg\" alt=\"프로필 사진\">\n</code></pre>\n<p>alt 특성을 아예 지정하지 않은 경우 이미지가 콘텐츠의 중요 부분이 아니거나 텍스트로 표현될 수 없음을 의미한다.</p>\n<p>빈 문자열로 지정한 경우에도 이미지가 콘텐츠의 중요 부분이 아니라는 것을 나타낸다.</p>\n<h2>1.2. 다른 속성들</h2>\n<p>width, height 속성으로 이미지의 크기를 지정할 수 있다. 제공하는 숫자에는 단위가 없지만 픽셀 단위로 해석된다. <code>width=\"100\"</code>은 너비를 100px로 지정하는 것과 같다. 이렇게 이미지 크기를 미리 지정해 놓으면 브라우저가 이미지를 다운로드하기 전부터 해당 이미지가 어느 크기로 렌더링될지를 알고 있으므로 layout shift를 줄여서 UX를 향상시킬 수 있다.</p>\n<p>하지만 HTML 속성을 통해 이미지 크기를 지정하는 것보다는 CSS를 통해 지정하는 것이 좋다. 혹은 이미지 편집기를 쓰거나.</p>\n<p>title 속성으로 이미지 제목을 설정할 수 있다. 그러면 이미지에 마우스 호버 시 이미지 제목이 나타난다. 다만 이 속성은 많은 스크린 리더가 읽어주지 않으므로 이미지에 대한 설명이 사용자에게 중요한 정보를 포함한다면 alt 속성을 사용하는 게 좋다.</p>\n<p>참고로 이미지의 저작권에 대해서는 <a href=\"https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Images_in_HTML#searching_for_permissively-licensed_images\">MDN 문서 일부</a>에서 도움될 만한 내용을 찾을 수 있다. 무료 이미지 사이트 등을 알려준다.</p>\n<h2>1.3. figcaption으로 캡션 달기</h2>\n<p>이미지에 캡션을 달 때, div 태그로 감싼 후 div태그 내부에 img 태그와 p 태그를 넣어줄 수도 있다.</p>\n<p>하지만 이렇게 하면 특정 이미지에 캡션을 연결해 주는 의미가 전달되지 않는다. 따라서 HTML5의 figure와 figcaption 태그를 사용할 수 있다.</p>\n<p>이 태그는 이미지에 캡션을 다는 역할을 수행한다.</p>\n<pre><code class=\"language-html\">&#x3C;figure>\n  &#x3C;img src=\"assets/profile.jpg\">\n  &#x3C;figcaption>내 프로필 사진&#x3C;/figcaption>\n&#x3C;/figure>\n</code></pre>\n<p>이때 figure 태그내의 요소가 꼭 이미지일 필요는 없다. 동영상이나 표, 코드 등이 올 수 있다.</p>\n<p>이미지를 넣을 때 CSS의 background-image 속성 등을 사용할 수도 있다. 하지만 그렇게 하면 이미지를 사용할 수는 있어도 이미지에 어떤 의미를 페이지 자체에서 부여할 수는 없다. 이미지를 정말 장식의 의미로만 사용하는 것이 아니라면 시맨틱을 위해서 img 태그로 이미지를 넣는 것이 좋다.</p>\n<h2>1.4. 이미지를 가져올 수 없을 때</h2>\n<p>src 속성이 비거나 null이거나 현재 URL과 같을 때, 혹은 이미지 자체나 메타데이터의 손상, 지원하지 않는 이미지 형식 등의 이유로 이미지를 불러올 수 없을 때 오류가 발생한다.</p>\n<p><code>onerror</code>(전역 속성)에 오류 핸들러를 등록했다면 위와 같은 오류가 발생했을 때 해당 핸들러가 호출된다.</p>\n<h1>2. map, area</h1>\n<p><code>&#x3C;map></code>은 <code>&#x3C;area></code>와 함께 쓰여서 클릭 가능한 이미지 맵을 정의한다. <code>&#x3C;map></code> 내부에 area 태그 여러 개가 있으며, img의 <code>usemap</code> 속성을 이용해서 map과 이미지를 연결한다.</p>\n<p><code>&#x3C;map></code> 태그에는 반드시 name 속성이 있어야 한다. 이는 모든 문서 내의 map에서 유일해야 하며 id 특성이 있을 경우 name과 동일해야 한다.</p>\n<p><code>&#x3C;area></code> 요소는 map 요소 안에서만 사용 가능하며 이미지 영역을 정의하고 하이퍼링크를 추가할 수 있다.</p>\n<p><a href=\"https://imagemap.org/\">imagemap.org</a>라는 사이트에서 이미지에 해당하는 map 태그를 생성할 수 있다.</p>\n<h1>3. audio</h1>\n<p><code>&#x3C;audio></code> 태그를 사용하면 오디오 파일을 페이지에 삽입할 수 있다. src 속성 또는 내부의 source 요소를 삽입해서 오디오 소스를 지정할 수 있다. 다수의 오디오 소스를 지정한 경우 가장 적절한 소스를 브라우저가 고른다.</p>\n<pre><code class=\"language-html\">&#x3C;audio controls>\n  &#x3C;source src=\"assets/audio.mp3\" type=\"audio/mpeg\">\n  &#x3C;source src=\"assets/audio.ogg\" type=\"audio/ogg\">\n  &#x3C;!-- 여기에 fallback content가 들어갈 수도 있다. -->\n&#x3C;/audio>\n</code></pre>\n<p>오디오 태그는 보여줄 시각 컨텐츠가 없으므로 width, height 속성을 사용할 수 없다. 같은 이유로 poster 속성도 지원하지 않는다.</p>\n<p>그런데 접근성을 생각하면 오디오 또한 캡션과 자막을 제공하는 게 맞다. 문제는 audio 태그가 WebVTT를 현재로서는 제공하지 않는다는 것이다. 따라서 이를 제공하는 라이브러리를 찾거나 직접 구현해야 한다.</p>\n<p>혹은 video 태그를 사용해서 audio를 제공하는 것도 방법이다. 오디오 소스는 audio 태그를 이용하는 게 사용자 경험이 더 낫긴 하지만.</p>\n<h1>4. video</h1>\n<p><code>&#x3C;video></code>태그를 쓰면 동영상을 페이지에 삽입할 수 있다. 이 태그는 src 속성을 가지는데 이는 img 태그에서와 같이 넣을 동영상의 경로를 지정한다.</p>\n<p>controls 속성을 지정하면 사용자에게 비디오 되감기, 볼륨 조절, 탐색 등의 인터페이스를 제공할 수 있다. 이를 사용하면 비디오 플레이어의 모든 컨트롤 요소가 표시된다.</p>\n<pre><code class=\"language-html\">&#x3C;video src=\"assets/video.mp4\" controls>&#x3C;/video>\n</code></pre>\n<p>controls 속성을 사용하지 않고 JS의 HTMLMediaElement API를 사용하여 컨트롤 요소를 직접 만들 수도 있다.</p>\n<p>video 태그 안에 p 태그 등을 넣어서 비디오가 지원되지 않는 브라우저에 대비할 수도 있다. 비디오가 표시되지 않을 때 사용자에게 보여줄 일종의 fallback content를 만드는 것이다. 비디오로 가는 링크를 넣는다거나 하는 것이다.</p>\n<pre><code class=\"language-html\">&#x3C;video src=\"assets/witch.mp4\" controls>\n  &#x3C;p>\n    이 브라우저는 비디오가 지원되지 않습니다. &#x3C;a href=\"assets/witch.mp4\">비디오 링크&#x3C;/a>를 통해서 감상해주세요.\n  &#x3C;/p>\n&#x3C;/video>\n</code></pre>\n<h2>4.1. 여러 비디오 소스 제공하기</h2>\n<p>브라우저에 따라서 지원하는 비디오 포맷이 다르기 때문에 우리가 제공한 source의 비디오가 재생되지 않을 수 있다.</p>\n<p>우리는 <code>audio</code>나 <code>picture</code> 등에서 한 것처럼 이런 문제를 보완하기 위해 여러 소스를 제공하여 브라우저가 지원하는 포맷을 찾아 재생할 수 있도록 할 수 있다. source 태그를 쓸 수 있다.</p>\n<pre><code class=\"language-html\">&#x3C;video controls>\n  &#x3C;source src=\"assets/video.mp4\" type=\"video/mp4\">\n  &#x3C;source src=\"assets/video.webm\" type=\"video/webm\">\n  &#x3C;source src=\"assets/video.ogv\" type=\"video/ogg\">\n&#x3C;/video>\n</code></pre>\n<p>지금까지는 video 태그의 src 속성에 비디오 파일의 경로를 넣었는데, 이제는 source 태그를 사용하여 여러 소스를 제공한다. 이렇게 하면 브라우저는 source 태그들의 src를 훑으면서 브라우저가 지원하는 코덱을 가진 첫 비디오를 찾아 재생한다.</p>\n<p>이렇게 여러 소스를 제공하는 데에 쓸 수 있는 source 태그는 picture, audio, video 태그에 모두 쓸 수 있다.</p>\n<p>그리고 source 태그에는 type 속성을 이용해서 파일의 미디어 타입(MIME 타입)을 명시할 수 있다. 이렇게 하면 브라우저가 지원하지 않는 비디오 코덱 타입을 바로 넘어가도록 할 수 있다.</p>\n<p>만약 type 속성을 지정하지 않으면 브라우저는 파일을 로드하고 코덱을 확인한 후 재생할 수 있는지를 판단한다. 이는 시간이 걸리기 때문에 type 속성을 명시하는 게 좋다.</p>\n<p>가장 적절한 비디오 코덱을 찾기 위해서는 <a href=\"https://developer.mozilla.org/en-US/docs/Web/Media/Formats\">미디어 타입, 포맷 가이드</a>를 참고할 수 있다.</p>\n<h2>4.2. video 기타 속성</h2>\n<p>그 외에도 width, height 태그도 있다. 이 속성을 사용하면 비디오의 크기를 지정할 수 있지만 aspect ratio는 유지된다. 만약 ratio가 다른 높이/너비를 지정한다면 비디오는 가로로 늘어나서 화면을 채울 것이고 안 채워진 부분은 기본 배경색으로 채워진다.</p>\n<p>autoplay, loop, muted 속성도 있다. autoplay는 비디오를 자동으로 재생하고, loop는 비디오를 반복 재생하고, muted는 음소거한다.</p>\n<p>poster 속성은 비디오가 로드되기 전에 보여줄 이미지를 지정한다. preload는 버퍼링 관련 속성이다.</p>\n<h2>4.3. 비디오에 자막 넣기</h2>\n<p>귀가 잘 들리지 않는 사람이나 시끄러운 환경에 있는 사람, 영상의 언어를 모르는 사람 같은 경우 자막이 필요할 수 있다.</p>\n<p>이런 사람에게 자막을 제공할 수 있다. webVTT파일과 <code>&#x3C;track></code> 태그를 사용하면 된다.</p>\n<p>webVTT 파일은 간단히 말해서 자막 파일이다. 여러 줄의 자막 문자열과 해당 자막마다 자막을 표시할 시작 시간과 끝 시간을 지정할 수 있다. 자막 위치 등을 지정할 수도 있다.</p>\n<p>이를 이용해 자막을 표시하기 위해서는 <code>.vtt</code>파일을 적당한 곳에 저장하고 <code>&#x3C;video></code>나 <code>&#x3C;audio></code>태그 내부의 <code>&#x3C;track></code>요소를 이용해서 해당 파일을 지정해 준다.</p>\n<pre><code class=\"language-html\">&#x3C;video controls>\n  &#x3C;source src=\"assets/video.mp4\" type=\"video/mp4\">\n  &#x3C;source src=\"assets/video.webm\" type=\"video/webm\">\n  &#x3C;source src=\"assets/video.ogv\" type=\"video/ogg\">\n  &#x3C;track src=\"assets/subtitles.vtt\" kind=\"subtitles\" srclang=\"en\" label=\"English\">\n&#x3C;/video>\n</code></pre>\n<p><code>&#x3C;track></code> 태그의 kind 속성을 이용하여 자막의 종류를 지정할 수 있다. subtitles, captions, descriptions, chapters, metadata 등이 있다.</p>\n<p>자막은 subtitles, 자막은 captions, 설명은 descriptions, 단원 구분은 chapters, 메타데이터는 metadata 등이다.</p>\n<p>이때 .vtt 파일은 <code>&#x3C;track></code> 태그를 통해 지정하는데 이 태그는 모든 <code>&#x3C;source></code> 태그보다 뒤에 와야 한다.</p>\n<p>그리고 <code>&#x3C;track></code> 태그에 srclang 속성을 이용하여 자막의 언어를 지정할 수 있고 label 속성을 이용하여 사람들이 자막의 언어가 어떤 것일지 알 수 있도록 할 수 있다.</p>\n<pre><code class=\"language-html\">&#x3C;track kind=\"subtitles\" src=\"subtitles_es.vtt\" srclang=\"es\" label=\"Spanish\" />\n</code></pre>\n<p>위에서 보았듯이, <code>&#x3C;track></code>요소는 미디어 요소의 자식으로서 자막 등 시간별로 필요한 텍스트 트랙을 지정하는 데 사용한다.</p>\n<h1>5. 내장 콘텐츠</h1>\n<p>멀티미디어 콘텐츠 외에도 다양한 기타 콘텐츠를 포함할 수 있게 해준다.</p>\n<p><code>&#x3C;embed></code>, <code>&#x3C;iframe></code>, <code>&#x3C;object></code>, <code>&#x3C;portal></code>, <code>&#x3C;picture></code>, <code>&#x3C;source></code> 태그를 포함한다.</p>\n<p>svg와 mathML을 HTML 문서에 직접 삽입할 수 있게 해주는 <code>&#x3C;svg></code>, <code>&#x3C;math></code> 태그도 있다.</p>\n<h2>5.1. 간략한 역사</h2>\n<p>예전에는 웹사이트의 작은 부분을 frame이라 하고, 메인이 되는 문서인 frameset이라는 문서에 frame을 넣어서 만들었다. 즉 페이지를 frame들의 집합으로 보았던 것이다.</p>\n<p>그리고 90년대 후반 Flash의 등장으로 영상, 애니메이션 같은 여러 콘텐츠를 웹에 삽입할 수 있게 되었다. 액션스크립트를 통해서 동영상을 제어할 수 있고, 애니메이션을 훨씬 더 적은 용량으로 만들 수 있게 한 플래시는 2000년대를 풍미했다.</p>\n<p><code>&#x3C;object></code>, <code>&#x3C;embed></code> 요소 등을 이용해서 같은 작업을 할 수 있었지만 접근성, 보안 등의 이유로 인기가 별로 없었다.</p>\n<p>그러다 플래시가 여러 문제들로 인해 인기가 사그라들고 HTML5가 등장하면서 <code>&#x3C;iframe></code>, <code>&#x3C;embed></code>, <code>&#x3C;object></code> 태그를 이용해서 웹 페이지에 다른 콘텐츠를 넣을 수 있게 되었다.</p>\n<h2>5.2. iframe</h2>\n<p><code>&#x3C;iframe></code> 태그는 다른 HTML 페이지를 현재 페이지 안에 삽입할 수 있게 해준다. <code>&#x3C;iframe></code> 태그의 src 속성을 이용해서 다른 웹 페이지를 지정할 수 있다.</p>\n<p>유튜브에서 공유-퍼가기를 선택하면 그 동영상에 해당하는 <code>&#x3C;iframe></code> 태그를 복사할 수 있다. 다음과 같은 식이다.</p>\n<pre><code class=\"language-html\">&#x3C;iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/b7Pt4hHGi2I\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen>&#x3C;/iframe>\n</code></pre>\n<p>이렇게 삽입된 다른 페이지는 각자 자신의 History를 가지고 있다. 뒤로가기 버튼을 눌렀을 때 현재 페이지가 아니라 삽입된 페이지의 이전 페이지로 이동한다. 그리고 아예 다른 문서로 관리되므로 페이지에 iframe을 추가할 때마다 자원을 더 사용하게 된다.</p>\n<p><code>&#x3C;iframe></code> width, height, src, allowfullscreen 속성이 주로 쓰인다. width, height, src속성은 당연히 각각 크기와 삽입할 페이지를 지정한다.</p>\n<p>이때 src 속성의 경우, 속도 향상을 위해서는 메인 페이지 로딩 이후 JS를 통해 지정하는 것이 좋다. 페이지 로딩 시간을 더 줄여 준다.</p>\n<p>allowfullscreen속성은 Fullscreen API를 사용하여 <code>&#x3C;iframe></code> 삽입된 페이지가 전체화면으로 보이게 할 수 있는지를 지정한다.</p>\n<p>또한 iframe 태그 사이에 삽입된 내용은 <code>&#x3C;iframe></code> 태그가 지원하지 않는 브라우저에서 fallback으로 보여진다.</p>\n<h3>5.2.1. iframe의 보안 문제</h3>\n<p>다음과 같이 <code>&#x3C;iframe></code> 태그로 내 페이지에 네이버 페이지를 삽입하려고 해보자.</p>\n<pre><code class=\"language-html\">&#x3C;iframe\n  src=\"https://www.naver.com/\"\n  width=\"100%\"\n  height=\"500\"\n  allowfullscreen\n>\n&#x3C;/iframe>\n</code></pre>\n<p>그런데 이렇게 하면 네이버 페이지가 제대로 로딩되지 않는다.</p>\n<p><img src=\"/static/iframe-denied-aaebbe9e.png\" alt=\"iframe 로딩 안됨\"></p>\n<p>이는 <code>&#x3C;iframe></code>이 해커들의 공격 벡터가 될 수 있기 때문이다. 해커들은 <code>&#x3C;iframe></code>을 이용하여 특정 페이지를 악의적으로 수정하거나 민감한 정보를 유출하기를 시도할 수 있다.</p>\n<p>HTML 인젝션 중에서도 iframe 인젝션이라고 하는 공격이 있다. 페이지 내에 <code>&#x3C;iframe></code> 태그를 삽입하고 사이즈를 0으로 설정하여 숨기는 것이다. 따라서 사용자는 <code>&#x3C;iframe></code>이 삽입되었다는 것을 시각적으로 알 수 없고 의도치 않게 악성 페이지를 로드하게 된다.</p>\n<p>그리고 유명한 페이지의 경우 많은 사람들이 임베드하고 싶어할 것이므로 이를 모두 허용하면 서버비가 더 많이 들 것이다. 이를 대비해서 <code>&#x3C;iframe></code>으로 해당 페이지를 임베딩하는 것을 막아 놓는 경우도 있다. 예를 들어서 MDN 페이지는 <code>X-Frame-Options: DENY</code> 헤더를 보내서 <code>&#x3C;iframe></code>을 막아 놓았다.</p>\n<p>따라서 필요한 경우에만 삽입하고, 저작권에도 주의하자.</p>\n<p>그 외에 해야 할 것들은 HTTPS 사용하기가 있다. Let's Encrypt를 이용하면 무료로 HTTPS를 사용할 수 있으니 이를 사용하자.</p>\n<p>또한 좀더 자세히 살펴볼 만한 것은 다음과 같다.</p>\n<h3>5.2.2. sandbox 속성</h3>\n<p>iframe에는 sandbox 특성이 있다. 이는 삽입된 콘텐츠에 대해 필요한 작업만 허용하도록 할 수 있다.</p>\n<p>sandbox 특성이 없는 콘텐츠는 JS를 실행하거나 새 창을 띄우는 등의 작업을 할 수 있기 때문에 악의적 공격 가능성이 늘어난다.</p>\n<p>sandbox 특성은 문자열인데 이는 콘텐츠가 허용하는 작업을 지정한다. 만약 sandbox=\"\"로 지정되어 있다면 모든 작업이 허용되지 않는다.</p>\n<p>예를 들어서 <code>allow-modals</code>를 sandbox 문자열에 추가한다면 <code>&#x3C;iframe></code>으로 삽입한 페이지에서 모달 창을 띄울 수 있게 된다. 이외에도 띄어쓰기를 통해서 여러 작업을 iframe sandbox 속성을 통해 허용할 수 있다.</p>\n<p>단 주의할 점은 <code>allow-scripts</code>와 <code>allow-same-origin</code> 옵션을 sandbox에 동시에 적용할 시 <code>&#x3C;iframe></code> 콘텐츠는 same origin policy를 우회하여 sandbox 특성을 해제하는 JS를 실행할 수 있게 된다. 따라서 이 두 옵션은 동시에 적용하지 않는 것이 좋다.</p>\n<h3>5.2.3. CSP 지시어 설정</h3>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/HTTP/CSP\">CSP</a>는 XSS 공격과 같은 보안 위협으로부터 페이지를 보호하기 위한 추가적인 보안 계층이다. 이는 HTML 문서 보안을 개선하기 위해 고안된 HTTP 헤더인 <code>Content-Security-Policy</code>를 제공한다.</p>\n<p>iframe의 보안 문제 해결을 위해서 CSP 설정을 통해 <code>X-Frame-Options</code> 헤더를 전송하도록 설정 가능하다. 이 헤더는 해당 페이지를 iframe으로 삽입할 수 있는지를 지정한다.</p>\n<p>만약 deny로 설정할 시 같은 사이트 내에서의 <code>&#x3C;iframe></code>을 통한 접근도 막는다. sameorigin으로 설정할 시 같은 사이트 내에서만 frame 접근이 가능하다. 이런 식으로 적절한 <code>X-Frame-Options</code> 헤더를 설정하면 <code>&#x3C;iframe></code> 보안 문제를 어느 정도 해결 가능하다.</p>\n<p>이러한 CSP 설정은 meta 요소를 통해서도 할 수 있지만 웹서버를 구성할 때 하는 것이 좋다. 특히 위에서 다룬 <code>X-Frame-Options</code> 헤더의 경우 meta 태그를 통해서 CSP 정책을 구성할 수 없다. 이는 이후 HTTP에서 더 자세히 다룰 것이다.</p>\n<h2>5.3. embed, object</h2>\n<p><code>&#x3C;iframe></code>은 다른 HTML페이지를 페이지 내에 삽입하는 기능을 했다. <code>&#x3C;embed></code>, <code>&#x3C;object></code>는 PDF와 같은 외부 콘텐츠를 페이지에 포함하기 위한 기능을 한다. 단 이 요소들을 사용하는 경우가 많지는 않다. 플러그인 콘텐츠를 삽입하기 위해 사용되는 경우가 있다.</p>\n<pre><code class=\"language-html\">&#x3C;embed src=\"./dummy.pdf\" type=\"application/pdf\" width=\"100\" height=\"200\" />\n&#x3C;object data=\"./dummy.pdf\" type=\"application/pdf\" width=\"100\" height=\"200\">\n  &#x3C;p>대체 텍스트&#x3C;/p>\n&#x3C;/object>\n</code></pre>\n<p><code>&#x3C;object></code> 태그가 일반적으로 페이지에 무언가를 삽입할 때 더 많이 쓰인다. 또한 <code>&#x3C;embed></code>는 대체 콘텐츠를 넣을 방법이 없지만 <code>&#x3C;object></code>는 태그 사이에 대체 콘텐츠를 넣는 방식으로 대체 콘텐츠도 지원한다.</p>\n<p>단 emb<code>&#x3C;embed></code>ed 태그만 지원되는 낡은 브라우저도 있으므로 만약 정말 모든 브라우저에 대응해야 한다면 두 태그를 모두 사용해야 한다. 다음과 같이 <code>&#x3C;object></code>의 대체 콘텐츠로 <code>&#x3C;embed></code>를 넣는 식이다.</p>\n<pre><code class=\"language-html\">&#x3C;object type=\"application/pdf\"\n    data=\"/media/examples/In-CC0.pdf\"\n    >\n    &#x3C;embed type=\"application/pdf\"\n    src=\"/media/examples/In-CC0.pdf\">\n&#x3C;/object>\n</code></pre>\n<h2>5.4. svg</h2>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Adding_vector_graphics_to_the_Web\">웹에 벡터 그래픽 삽입하기</a></p>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/SVG\">SVG</a>는 Scalable Vector Graphics의 약자로 2차원 벡터 그래픽을 XML로 서술하는 언어이다.</p>\n<p>텍스트를 HTML로 기술하듯이 그래픽을 SVG로 기술하는 것이다. <code>&#x3C;circle></code> 태그를 통해 원을 그리고 <code>&#x3C;rect></code> 태그를 통해 사각형을 그리는 등이다. 여기에도 여러 태그들이 있는데 이를 이용하면 다양한 그래픽을 그릴 수 있다. <a href=\"https://developer.mozilla.org/en-US/docs/Web/SVG\">SVG에 관한 더 많은 정보</a></p>\n<pre><code class=\"language-html\">&#x3C;svg width=\"100%\" height=\"100%\">\n  &#x3C;rect width=\"100%\" height=\"100%\" fill=\"black\" />\n  &#x3C;circle cx=\"150\" cy=\"100\" r=\"90\" fill=\"red\" />\n&#x3C;/svg>\n</code></pre>\n<p>간단한 SVG는 위와 같이 직접 만들 수 있지만 복잡한 그래픽을 그리려면 SVG를 직접 구성하는 건 매우 어렵다. 그럴 땐 <a href=\"https://inkscape.org/ko/\">Inkscape</a>와 같은 프로그램을 이용해야 한다.</p>\n<p>그러나 SVG는 쉽게 복잡해지기 때문에 파일 크기가 커질 수 있고 만들기 어렵다는 단점도 있다. 사진과 같은 복잡한 이미지의 경우 래스터 이미지를 쓰는 게 낫다.</p>\n<h3>5.4.1. svg를 페이지에 넣기</h3>\n<p>svg를 페이지에 넣는 것에는 여러 가지 방법이 있다. 일단 img 태그의 src 속성에 svg파일을 넣음으로써 페이지에 SVG를 넣을 수 있다.</p>\n<p>이 방법은 익숙한 문법이라 쉽고 alt text 등의 기능을 사용할 수 있다. 이미지를 하이퍼링크로 만들 수도 있고 브라우저에서 이미지를 캐싱하여 빠르게 로딩할 수 있다.</p>\n<p>그러나 이미지를 JS로 제어할 수 없고 CSS를 넣으려고 하면 SVG 코드에 인라인 CSS를 포함시켜야 한다. SVG 파일에 외부 CSS 스타일시트를 넣으면 무시된다. 같은 이유로 SVG에 의사 클래스 CSS(:hover 등)를 적용할 수 없다.</p>\n<p>몇몇 브라우저의 경우 SVG를 지원하지 않는데 이 경우 srcset 속성을 사용해서 대체 콘텐츠를 만들어줄 수 있다. 다만 srcset 속성도 최신 브라우저만 지원하는 기능이다. 따라서 SVG를 지원하는 브라우저는 srcset 속성의 SVG 파일을 사용하고, 지원하지 않는 브라우저는 src 속성의 PNG 파일을 사용한다.</p>\n<pre><code class=\"language-html\">&#x3C;img src=\"image.png\" srcset=\"image.svg\" alt=\"SVG image\" />\n</code></pre>\n<p>css의 배경 이미지를 사용하여서도 svg를 삽입할 수 있는데, img 태그를 사용할 때와 같이 JS로 svg를 제어할 수 없다는 같은 단점이 있다.</p>\n<p>이런 단점을 극복하기 위해 inline SVG로 svg를 삽입할 수 있다.</p>\n<p>SVG를 페이지에 직접 넣는 방법이다. svg 파일을 텍스트 에디터로 열어서 코드를 복사한 다음 HTML 파일에 붙여넣으면 된다.</p>\n<pre><code class=\"language-html\">&#x3C;svg width=\"300\" height=\"200\">\n  &#x3C;rect width=\"100%\" height=\"100%\" fill=\"green\" />\n&#x3C;/svg>\n</code></pre>\n<p>이렇게 하면 HTTP 요청을 줄일 수 있어서 로딩 시간을 줄일 수 있고 svg 요소에 class, id등을 통해 스타일을 적용할 수 있다. inline SVG는 CSS 상호작용(<code>:hover</code>같은)과 CSS 애니메이션을 svg에 적용할 수 있게 하는 유일한 방법이다.</p>\n<p>그러나 HTML 파일 내에 SVG 코드를 직접 삽입하기 때문에 코드가 길어지고, 재사용이 불가능하다. 또한 브라우저가 svg 파일 캐싱을 할 수 없다.</p>\n<p>마지막으로 iframe 태그를 써서 svg 파일을 넣을 수 있다. iframe 태그의 src 속성에 svg 파일을 넣음으로써 페이지에 SVG를 넣는 것이다.</p>\n<pre><code class=\"language-html\">&#x3C;iframe src=\"mysvg.svg\" width=\"500\" height=\"500\" sandbox>\n  &#x3C;img src=\"mypic.png\" alt=\"내 사진\" />\n&#x3C;/iframe>\n</code></pre>\n<p>그러나 SVG와 웹페이지가 같은 origin을 가지고 있으므로 SVG에 JS를 적용할 수 없고 iframe을 사용할 수 없는 브라우저에서는 SVG 지원이 있어도 동작하지 않는다는 단점이 있다. 일반적으로 iframe 태그를 써서 svg를 렌더링하는 건 좋은 선택이 아니다.</p>\n<h2>5.5. 반응형 이미지 넣기</h2>\n<p><a href=\"https://witch.work/posts/html-responsive-image\">HTML로 반응형 이미지 가져오기</a>글을 따로 작성하였다. picture 태그를 사용한다.</p>\n<h2>5.6. portal</h2>\n<p>다른 HTML 페이지를 임베딩하는 것을 지원하는, <code>iframe</code>과 비슷한 태그라고 하는데 아직 실험적인 기능이라서 지원하는 브라우저가 현재로서는 사실상 없다. <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/portal\">언젠가 이 문서를 보고 공부해야 할지도</a></p>\n<h1>참고</h1>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Learn/HTML/Multimedia_and_embedding\">https://developer.mozilla.org/ko/docs/Learn/HTML/Multimedia_and_embedding</a></p>",
    "excerpt": "웹이 발전하면서 페이지에 이미지나 비디어 등의 멀티미디어를 넣을 수 있게 되었다. 어떻게 하는지 알아보자.\n1. img\nHTML에서 이미지를 넣기 위해서는 img태그를 사용한다. img태그는 내부 내용이나 닫는 태그가 없는 빈 태그이지만 src 속성 하나는 사용되어야 한다. 물론 대체 텍스트를 나타내는 alt속성도 지정해 주는 게 좋다.\n이때 src 속성에는 사용자 에이전트가 지원하는 파일 형식을 제공해야 한다. 웹 브라우저의 지원 이미지 형식 안내서\nsrc 속",
    "headingTree": [
      {
        "title": "1. img",
        "url": "#1-img",
        "items": [
          {
            "title": "1.1. alt 속성",
            "url": "#11-alt-속성",
            "items": []
          },
          {
            "title": "1.2. 다른 속성들",
            "url": "#12-다른-속성들",
            "items": []
          },
          {
            "title": "1.3. figcaption으로 캡션 달기",
            "url": "#13-figcaption으로-캡션-달기",
            "items": []
          },
          {
            "title": "1.4. 이미지를 가져올 수 없을 때",
            "url": "#14-이미지를-가져올-수-없을-때",
            "items": []
          }
        ]
      },
      {
        "title": "2. map, area",
        "url": "#2-map-area",
        "items": []
      },
      {
        "title": "3. audio",
        "url": "#3-audio",
        "items": []
      },
      {
        "title": "4. video",
        "url": "#4-video",
        "items": [
          {
            "title": "4.1. 여러 비디오 소스 제공하기",
            "url": "#41-여러-비디오-소스-제공하기",
            "items": []
          },
          {
            "title": "4.2. video 기타 속성",
            "url": "#42-video-기타-속성",
            "items": []
          },
          {
            "title": "4.3. 비디오에 자막 넣기",
            "url": "#43-비디오에-자막-넣기",
            "items": []
          }
        ]
      },
      {
        "title": "5. 내장 콘텐츠",
        "url": "#5-내장-콘텐츠",
        "items": [
          {
            "title": "5.1. 간략한 역사",
            "url": "#51-간략한-역사",
            "items": []
          },
          {
            "title": "5.2. iframe",
            "url": "#52-iframe",
            "items": [
              {
                "title": "5.2.1. iframe의 보안 문제",
                "url": "#521-iframe의-보안-문제",
                "items": []
              },
              {
                "title": "5.2.2. sandbox 속성",
                "url": "#522-sandbox-속성",
                "items": []
              },
              {
                "title": "5.2.3. CSP 지시어 설정",
                "url": "#523-csp-지시어-설정",
                "items": []
              }
            ]
          },
          {
            "title": "5.3. embed, object",
            "url": "#53-embed-object",
            "items": []
          },
          {
            "title": "5.4. svg",
            "url": "#54-svg",
            "items": [
              {
                "title": "5.4.1. svg를 페이지에 넣기",
                "url": "#541-svg를-페이지에-넣기",
                "items": []
              }
            ]
          },
          {
            "title": "5.5. 반응형 이미지 넣기",
            "url": "#55-반응형-이미지-넣기",
            "items": []
          },
          {
            "title": "5.6. portal",
            "url": "#56-portal",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 3,
      "wordCount": 669
    },
    "url": "/posts/html-multimedia-tag",
    "thumbnail": {
      "local": "/static/iframe-denied-aaebbe9e.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-iframe-denied-aaebbe9e-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAFCAIAAAD38zoCAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAQklEQVR4nGPo6OiYjgo6Ojq2bdvGMH369OVggMw4duwYVGL69OnS0tJ+fn5YJCorK+HGgiSWL1++DRUsX7782rVrAHpVSdvQ7BNlAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "html-responsive-image",
    "title": "HTML로 반응형 이미지 가져오기",
    "date": "2023-06-29T03:00:00Z",
    "description": "HTML에서도 반응형으로 이미지를 불러올 수 있다",
    "tags": [
      "web",
      "front",
      "HTML"
    ],
    "html": "<h1>1. img 태그로 반응형 이미지</h1>\n<p>HTML에서 img 태그는 이미지를 넣는 데에 사용된다. 거의 필수적인 속성만 넣어서 사용하면 다음과 같이 사용하게 될 것이다.</p>\n<pre><code class=\"language-html\">&#x3C;img src=\"assets/profile.png\" alt=\"블로그 프로필 사진\" />\n</code></pre>\n<p>그런데 메모리 절약, 화면 크기에 따른 강조 부분 차이 등으로 인해서 화면 크기에 따라 다른 이미지를 보여주도록 브라우저에 지시하게 될 경우가 있다. 이른바 반응형 이미지라는 것이다.</p>\n<p>물론 이럴 때 CSS를 이용할 수 있을 것이다. 가령 이미지를 표시하는 것을 div 컨테이너로 바꾼 후 화면 너비에 따라서 <code>background-image</code>를 바꿔 준다든지.</p>\n<pre><code class=\"language-css\">@media screen and (max-width: 600px) {\n  .profile {\n    background-image: url(\"assets/profile-small.png\");\n  }\n}\n\n@media screen and (min-width: 600px) {\n  .profile {\n    background-image: url(\"assets/profile-large.png\");\n  }\n}\n</code></pre>\n<p>하지만 HTML로도 이러한 동작을 할 수 있다. 이는 브라우저가 페이지를 불러오기 시작할 때 CSS,JS를 해석하기 전 미리 HTML을 로드하기 때문에 페이지 로딩 시간을 단축시켜준다는 장점도 있다.</p>\n<p>만약 CSS나 JS로 반응형 이미지를 구현했다면, 화면 크기에 따라 처음부터 다른 이미지를 로드할 수가 없다. 메인 파서에는 CSS, JS를 로드하고 해석하기 전에 이미지를 먼저 다운로드하는 최적화 기법이 적용되어 있다.</p>\n<p>따라서 이미지를 로드하는 시점에 CSS, JS가 없기 때문이다. 고로 브라우저는 미리 로드한 이미지를 보여주고, CSS, JS가 로드되면 이미지를 교체하게 된다.</p>\n<p>이는 이미지를 로드하는 시간을 늘리게 된다. 즉 HTML을 이용해야 화면 크기에 따라 다른 이미지를 로드하도록 할 수 있다. 그럼 어떻게 해야 HTML을 이용해서 반응형 이미지를 넣을 수 있을까?</p>\n<h1>2. img 태그</h1>\n<p>img의 srcset, sizes라는 새로운 속성을 사용하는 게 하나의 방법이다. 이때 srcset 속성에 들어가는 파일명은 브라우저가 지원하는 이미지 포맷 파일로만 지정할 수 있다.</p>\n<p>가장 대표적인 예시는 다음과 같다.</p>\n<pre><code class=\"language-html\">&#x3C;img\n  srcset=\"image-320w.jpg 320w, \n          image-480w.jpg 480w, \n          image-768w.jpg 768w\"\n  sizes=\"(max-width:320px) 280px,\n        (max-width:480px) 440px,\n        800px\"\n  src=\"image.jpg\"\n  alt=\"기본 이미지\"\n/>\n</code></pre>\n<p>하지만 매우 다양한 방법이 있으므로 하나하나 알아보자.</p>\n<h2>2.1. 해상도에 따라 이미지 선택</h2>\n<p>다양한 해상도의 화면을 지원해야 하는데 고정 사이즈의 이미지를 나타내야 한다면 sizes 속성을 쓰지 않고 <code>2x</code>와 같은 서술자를 사용해 브라우저가 적절한 해상도 이미지를 선택하게 할 수 있다.</p>\n<p>이런 <code>2x</code>같은 값을 display density descriptor라고 한다. 이는 브라우저가 이미지를 로드할 때 기기의 픽셀 밀도를 확인하고, 그에 맞는 이미지를 선택하게 한다.</p>\n<pre><code class=\"language-html\">&#x3C;img\n  srcset=\"image-320w.jpg, \n          image-480w.jpg 1.5x, \n          image-768w.jpg 2x\"\n  src=\"image.jpg\"\n  alt=\"기본 이미지\"\n/>\n</code></pre>\n<p>브라우저는 보이는 해상도가 얼마인지 확인하고 srcset의 이미지들 중 가장 적합한 이미지를 제공할 것이다.</p>\n<p>그런데 이런 해법은 꽤 유동적인 크기를 가진 이미지를 사용할 때 문제가 생긴다. 앞서 <code>고정 사이즈 이미지를 나타내야 한다면</code> 이라는 단서를 붙인 이유가 있다.</p>\n<p>수많은 해상도를 지원해야 하는 경우 <code>1x</code>에서 <code>16x</code>까지쯤 되는 종류들의 이미지를 모두 srcset에 넣어줘야 하는가?</p>\n<p>브라우저 창이 옆으로 늘어나면서 이미지를 보여줘야 하는 해상도가 엄청나게 많이 변하면 어쩔 것인가? 이미지를 몇 개씩이나 로드하게 되는 문제가 생길 수 있다.</p>\n<p>혹은 <a href=\"https://www.paintcodeapp.com/news/iphone-6-screens-demystified\">아이폰6플러스의 다운샘플링</a>과 같은 이슈가 있을 경우 <code>2x</code>이상의 이미지를 제공하고도 브라우저가 <code>1x</code>급의 이미지를 제공할 수도 있다.</p>\n<p>따라서 이렇게 display density descriptor를 통해서 브라우저가 이미지를 선택하게 하는 방식은 고정폭 이미지를 사용할 경우에 권장된다.</p>\n<h2>2.2. width descriptor</h2>\n<p>그럼 유동적인 크기의 이미지를 사용할 때는 어떻게 해야 할까? 이때는 width descriptor와 sizes를 사용한다. 이는 이미지의 고유 픽셀 너비를 지정하는 것이다. 이제야 위의 예시 코드를 이해할 수 있겠다.</p>\n<pre><code class=\"language-html\">&#x3C;img\n  srcset=\"image-320w.jpg 320w, \n          image-480w.jpg 480w, \n          image-768w.jpg 768w\"\n  sizes=\"(max-width:320px) 280px,\n        (max-width:480px) 440px,\n        800px\"\n  src=\"image.jpg\"\n  alt=\"기본 이미지\"\n/>\n</code></pre>\n<p>srcset은 사용할 이미지 목록과 그 크기를 정의한다. 이미지 파일명/경로와 이미지의 고유 픽셀 너비를 공백으로 구분해서 표기한다. 이때 고유 픽셀 너비란 이미지의 실제 규격 너비를 의미한다.</p>\n<p>이는 브라우저에게 이미지의 실제 규격이 어느 정도라고 알려주는 용도이다. 맥과 같은 경우 이미지 파일 정보에서 이미지 규격을 확인할 수 있는데 거기서 나오는 너비이다.</p>\n<p>가령 위와 같이 이미지 고유 픽셀 너비를 320w로 표기했다면 이미지의 실제 규격의 너비가 320px라는 뜻이다.</p>\n<p>sizes에서는 미디어 쿼리와 해당 미디어 쿼리에 따라 이미지가 어느 정도 너비를 채우게 될지를 정의한다. 위의 예시 코드에서의 경우 앞의 값은 최대 320px의 화면일 때 이미지가 280px를 채우도록 한다는 것이다.</p>\n<h3>2.2.1. sizes의 용도</h3>\n<p>그런데 왜 우리는 sizes 속성을 통해서 이미지가 어느 정도의 너비를 채우게 될지를 정의해 줘야 하는 걸까? 브라우저에게 srcset의 width descriptor를 통해서 이미지의 실제 너비까지 알려 줬는데 브라우저가 알아서 이미지를 선택해서 로드하면 될 것 아닌가?</p>\n<p>위에서 HTML로 반응형 이미지를 제공하는 것의 장점을 이야기하면서 말한 내용에 단서가 있다.</p>\n<pre><code>메인 파서에는 CSS, JS를 로드하고 해석하기 전에 이미지를 먼저 다운로드하는 최적화 기법이 적용되어 있다.\n</code></pre>\n<p>브라우저는 페이지를 로드할 때 먼저 HTML을 다운로드한다. 그리고 나서 CSS, JS를 요청하는데 이 CSS, JS의 로딩이 끝나기 전에 브라우저는 이미지를 다운로드하기 시작한다.</p>\n<p>따라서 이미지가 다운로드되는 시점에 브라우저는 페이지의 레이아웃이 어떻게 될지에 대한 정보를 알지 못한다. 심지어 CSR을 할 경우 아예 HTML 구조조차 알지 못하는 시점에 브라우저는 이미지 다운로드를 시작하게 될 것이다.</p>\n<p>이 시점에 브라우저가 알 수 있는 건 뷰포트 너비뿐이다. 하지만 이는 이미지가 어느 정도 너비로 보이게 될지랑은 큰 관련이 없을 수 있다. 예를 들어서 내 블로그만 해도 프로젝트 사진들이 있는데, 이는 뷰포트 너비에 비해 매우 작은 부분을 차지한다. 뷰포트 너비가 아무리 커져도 약 210px 정도 너비의 이미지가 된다.</p>\n<p><img src=\"/static/my-blog-project-2d9dd4f2.png\" alt=\"내 블로그의 프로젝트 부분\"></p>\n<p>따라서 우리는 sizes 속성을 통해서 뷰포트 너비별로 해당 이미지가 어느 정도 크기로 보이게 될지 브라우저에 알려주는 것이다.</p>\n<pre><code class=\"language-html\">  sizes=\"(max-width:320px) 280px,\n        (max-width:480px) 440px,\n        800px\"\n</code></pre>\n<p>이때 sizes에 넣을 이미지 너비는 px, em으로 된 절댓값이나 뷰포트 상댓값 vw를 사용해야 한다. %는 사용할 수 없다.</p>\n<p>위의 경우 뷰포트 너비가 320px 이하일 때 이미지는 280px 너비를 채우고, 320px 초과 480px 이하일 때 이미지가 440px 너비를 채우고, 480px 초과일 때 이미지가 800px 너비를 채운다는 것이다.</p>\n<h2>2.3. 브라우저의 처리</h2>\n<p>이 속성들이 있을 때 브라우저는, 이미지를 로드할 때 뷰포트 너비를 확인한 후 참이 되는 미디어 조건문을 확인하고, 그 조건문에 해당하는 이미지의 너비(size에 있는 것)를 확인한다. 그리고 그 너비에 가장 가까운 이미지를 srcset에서 찾아서 로드한다.</p>\n<p>이러한 기능은 최신 브라우저에서만 지원된다. srcset, sizes 속성을 지원하지 않는 낡은 브라우저를 위해서 src를 넣어줄 수 있다.</p>\n<h1>3. 아트 디렉션 문제와 picture</h1>\n<p>그런데 화면 크기에 따라 이미지가 나타내는 핵심을 보여주기 위해 다른 형태의 사진을 보여줘야 하는 경우가 있다. 화면이 작아지면 사람이 확대된 사진을 보여 주는 게 좋다든지 하는 경우이다. 이런 문제를 아트 디렉션 문제라고 한다.</p>\n<p>이를 위해서는 picture 태그를 쓸 수 있다. picture 요소가 여러 source를 감싸도록 하여 브라우저가 고를 수 있는 소스들을 제공하는 것이다. picture 태그는 source 태그들을 자식으로 가지며 마지막 자식으로 img 태그를 가진다.</p>\n<p>다양한 화면 크기에 따라 다른 이미지를 제공하려면 picture 태그를 쓰자.</p>\n<pre><code class=\"language-html\">&#x3C;picture>\n  &#x3C;source media=\"(max-width:768px)\" srcset=\"img-480w.jpg\">\n  &#x3C;source media=\"(max-width:1080px)\" srcset=\"img-720w.jpg\">\n  &#x3C;img src=\"img.jpg\" alt=\"시범 이미지\">\n&#x3C;/picture>\n</code></pre>\n<p>source 태그에는 미디어 조건문이 있어서 특정 조건에 따라 다른 이미지를 보여줄 수 있도록 설정 가능하다.</p>\n<p>브라우저는 source 태그들을 위에서부터 아래로 순서대로 확인하며, 조건문을 만족하는 첫 번째 source 태그의 srcset 경로의 이미지를 보여준다.</p>\n<h2>3.1. media 속성은 제안이 아닌 강요</h2>\n<p>이 media 속성은 아트 디렉션이 필요한 경우가 아니면 사용하지 않는 게 좋다.</p>\n<p>media 속성을 쓰게 되면 브라우저에 현재 브라우저 상태와 부합하는 미디어 쿼리를 가진 source 태그의 이미지를 사용하라고 강제하게 되기 때문이다. 최적화를 위해 브라우저가 다른 이미지를 선택하는 건 허용되지 않는다.</p>\n<p>아트 디렉션을 위한 경우 그렇게 강제하는 게 맞지만 그렇지 않은 경우에는 브라우저가 알아서 최적의 이미지를 선택하게 하는 게 좋다.</p>\n<p>이곳의 srcset에도 여러 이미지와 상응하는 sizes 속성을 제공할 수 있다. 그러나 그렇게 하려면 다양한 해상도의 사진도 여러 개씩 제공해야 하는데 그렇게 하는 일은 잘 없다.</p>\n<p>그리고 마지막에 img 태그가 있는데, 이는 브라우저가 picture 태그를 지원하지 않을 때 혹은 참을 리턴하는 미디어 조건문이 없을 때 보여줄 이미지를 설정하는 것이다.</p>\n<h2>3.2. type 속성</h2>\n<p>source는 type속성 내에 MIME 타입을 명시하여 브라우저가 이미지를 로드하기 전에, 브라우저가 지원하지 않는 이미지 유형의 경우 거부할 수 있도록 한다.</p>\n<p>이는 webp등을 사용할 때 유용하다. 해당 타입 이미지를 지원하지 않는 브라우저들에게 이 파일 유형을 즉시 거부하도록 만들어 준다.</p>\n<p>이를 이용하면 개발자는 webp, avif과 같은, 용량 등에서 이점이 큰 최신 이미지 포맷을 부담없이 사용할 수 있게 된다. 만약 해당 이미지 포맷을 지원하지 않는 브라우저일 경우 바로 다음 source의 이미지를 로드하게 되기 때문이다.</p>\n<pre><code class=\"language-html\">&#x3C;picture>\n  &#x3C;source type=\"image/webp\" srcset=\"img-480w.webp\">\n  &#x3C;source type=\"image/jpeg\" srcset=\"img-480w.jpg\">\n  &#x3C;img src=\"img.jpg\" alt=\"시범 이미지\">\n&#x3C;/picture>\n</code></pre>\n<p>이는 페이지가 여러 이미지 포맷을 지원하도록 할 때 유용하다.</p>\n<h1>참고</h1>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images\">https://developer.mozilla.org/ko/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images</a></p>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/HTML/Element/img\">https://developer.mozilla.org/ko/docs/Web/HTML/Element/img</a></p>\n<p><a href=\"https://brucelawson.co.uk/2015/why-we-cant-do-real-responsive-images-with-css-or-javascript/\">https://brucelawson.co.uk/2015/why-we-cant-do-real-responsive-images-with-css-or-javascript/</a></p>\n<p><a href=\"https://cloudfour.com/thinks/responsive-images-101-part-4-srcset-width-descriptors/\">https://cloudfour.com/thinks/responsive-images-101-part-4-srcset-width-descriptors/</a></p>",
    "excerpt": "1. img 태그로 반응형 이미지\nHTML에서 img 태그는 이미지를 넣는 데에 사용된다. 거의 필수적인 속성만 넣어서 사용하면 다음과 같이 사용하게 될 것이다.\n<img src=\"assets/profile.png\" alt=\"블로그 프로필 사진\" />\n\n그런데 메모리 절약, 화면 크기에 따른 강조 부분 차이 등으로 인해서 화면 크기에 따라 다른 이미지를 보여주도록 브라우저에 지시하게 될 경우가 있다. 이른바 반응형 이미지라는 것이다.\n물론 이럴 때 CSS를 이용",
    "headingTree": [
      {
        "title": "1. img 태그로 반응형 이미지",
        "url": "#1-img-태그로-반응형-이미지",
        "items": []
      },
      {
        "title": "2. img 태그",
        "url": "#2-img-태그",
        "items": [
          {
            "title": "2.1. 해상도에 따라 이미지 선택",
            "url": "#21-해상도에-따라-이미지-선택",
            "items": []
          },
          {
            "title": "2.2. width descriptor",
            "url": "#22-width-descriptor",
            "items": [
              {
                "title": "2.2.1. sizes의 용도",
                "url": "#221-sizes의-용도",
                "items": []
              }
            ]
          },
          {
            "title": "2.3. 브라우저의 처리",
            "url": "#23-브라우저의-처리",
            "items": []
          }
        ]
      },
      {
        "title": "3. 아트 디렉션 문제와 picture",
        "url": "#3-아트-디렉션-문제와-picture",
        "items": [
          {
            "title": "3.1. media 속성은 제안이 아닌 강요",
            "url": "#31-media-속성은-제안이-아닌-강요",
            "items": []
          },
          {
            "title": "3.2. type 속성",
            "url": "#32-type-속성",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 326
    },
    "url": "/posts/html-responsive-image",
    "thumbnail": {
      "local": "/static/my-blog-project-2d9dd4f2.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-my-blog-project-2d9dd4f2-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAIAAAA8r+mnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAb0lEQVR4nAFkAJv/APPt79PM1dC+yOfU3eLR2+fV4O/l7O7p7QD17/HLxcuxpbG3q7nj0trEs7zVy9Lx7fEA//7/ZmJmAAUcIjxR8Ni6KCAaWldd//z/APPu8dLHzcvCx+HW2tzR1dbN0ubg4+/q7ZDzSJ6qVoahAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "html-section-tag",
    "title": "HTML의 콘텐츠 구획 태그",
    "date": "2023-08-13T02:00:00Z",
    "description": "HTML의 콘텐츠를 의미적으로 구분하는 태그",
    "tags": [
      "HTML"
    ],
    "html": "<h1>1. 섹션 루트</h1>\n<p><code>&#x3C;head></code>에 들어가는 요소들을 제외하고 다른 요소들은 모두 섹션 루트 즉 <code>&#x3C;body></code>태그 내에 포함된다.</p>\n<p>섹션 루트는 문서의 내용 섹션을 나타내며 <code>&#x3C;body></code>태그로 나타내고 이 태그는 문서에 하나만 존재 가능하다.</p>\n<p><code>onblur</code>, <code>onerror</code>, <code>onfocus</code>, <code>onload</code>, <code>onresize</code>, <code>onpopstate</code> 등의 이벤트 핸들러를 가질 수 있다. 이들은 문서에서 특정 이벤트가 생겼을 때 실행되는 함수를 지정한다. 더 많은 이벤트 핸들러는 <a href=\"https://developer.mozilla.org/ko/docs/Web/HTML/Element/body#%ED%8A%B9%EC%84%B1\">body 태그의 MDN 문서</a>에서 볼 수 있다.</p>\n<h1>2. 페이지를 구성하는 영역</h1>\n<p>HTML에는 페이지의 각 구역을 정의할 수 있는 블록 요소들도 있다. 가령 메인 컨텐츠가 위치하는 구역이라든지. 이 요소들을 이용하면 기본적인 페이지 구조를 HTML로 표현할 수 있다.</p>\n<p>일반적인 문서는 다음과 같은 영역으로 구성된다.</p>\n<p>header : 큰 제목과 로고 등이 있는 띠. 주요 정보가 정리되어 있다. 보통 다른 페이지들에서도 똑같이 나타난다.</p>\n<p>nav : 페이지 내에서 다른 페이지로 이동할 수 있는 링크들이 있는 영역. 주로 메뉴, 링크, 탭이 들어가고 다른 페이지들에서도 일관적으로 나타난다. 보통 header 영역에 들어가지만 필수 사항은 아니다.</p>\n<p>main : 페이지의 가장 주요 내용이 들어가는 영역. 이야기나 페이지의 중요한 비디오 등이 들어간다.</p>\n<p>sidebar : 주변의 정보, 링크, 인용부호 등이 들어가는데 메인 컨텐츠에 따라 내용이 다르다. 기사 페이지라면 sidebar에는 작성자나 관련 기사 링크를 포함할 것이다. 보통 main 영역의 옆에 위치한다.</p>\n<p>footer : 페이지 바닥의 줄로 페이지에 관한 작은 정보나 연락처를 적는다. 사이트맵이나 인기 컨텐츠 바로가기 링크가 있을 수도 있다.</p>\n<p>이 각각의 페이지 요소들에 대해서 적절한 태그들을 사용해야 한다. 그리고 HTML에서는 정말로 이들에 대한 적절한 태그를 제공한다.</p>\n<p>header를 나타내는 header, nav bar를 나타내는 nav, 문서의 주요 컨텐츠에 쓰일 main, article, section, div 등등, sidebar는 aside, footer는 footer를 제공한다.</p>\n<p>전체를 이야기하자면, <code>&#x3C;address></code>, <code>&#x3C;article></code>, <code>&#x3C;aside></code>, <code>&#x3C;footer></code>, <code>&#x3C;header></code>, <code>&#x3C;h1></code>, <code>&#x3C;h2></code>, <code>&#x3C;h3></code>, <code>&#x3C;h4></code>, <code>&#x3C;h5></code>, <code>&#x3C;h6></code>, <code>&#x3C;main></code>, <code>&#x3C;nav></code>, <code>&#x3C;section></code> 태그를 포함한다.</p>\n<p>제목 태그들을 묶을 때 사용하는 <code>&#x3C;hgroup></code>태그도 있었으나 W3C HTML 명세에서는 제거되었다. 아무튼 이런 태그들을 하나씩 알아보자.</p>\n<h2>2.1. 태그 구분의 필요성</h2>\n<p>CSS나 폰트 크기를 통해서 사이트의 각 파트를 구분하고 표시할 수도 있다. 하지만 아예 스크린 리더를 사용하거나 혹은 색을 통해서 구분할 수 없는 정도의 사용자도 많다.</p>\n<p>약 8%의 남자와 0.5%의 여자가 색맹(colorblind)이다. 세계의 약 4~5%가 색맹인 것이다. 이는 우리가 그렇게 지원하려고 노력하는 레거시 브라우저 사용자들보다도 많은 수치이지만 많은 경우 색맹 이용자들은 레거시 브라우저 사용자들에 비해 간과된다.</p>\n<p>이럴 때 콘텐츠를 기능에 따라 구획할 수 있는 HTML 마크업을 사용하는 것은 사이트 구조를 명백하게 드러내는 데 도움이 된다. 이는 스크린 리더 사용자들이 페이지를 명확히 이용하는 데에도 도움이 된다. 이런 데에 쓰이는 태그들을 알아보자.</p>\n<h1>3. 콘텐츠 구획 태그</h1>\n<h2>3.1. 간단한 페이지 예시</h2>\n<p>먼저 간단한 페이지를 한번 구성해 보고, 쓰인 태그들의 의미를 하나하나 짚어보자.</p>\n<pre><code class=\"language-js\">&#x3C;!DOCTYPE html>\n&#x3C;html>\n  &#x3C;head>\n    &#x3C;meta charset=\"utf-8\" />\n    &#x3C;meta name=\"author\" content=\"Kim Sung Hyun\" />\n    &#x3C;title>My Sementic Page&#x3C;/title>\n  &#x3C;/head>\n  &#x3C;body>\n    &#x3C;header>\n      &#x3C;h1>My Sementic Page&#x3C;/h1>\n    &#x3C;/header>\n    &#x3C;nav>\n      &#x3C;ul>\n        &#x3C;li>&#x3C;a href=\"#\">Home&#x3C;/a>&#x3C;/li>\n        &#x3C;li>&#x3C;a href=\"#\">About&#x3C;/a>&#x3C;/li>\n        &#x3C;li>&#x3C;a href=\"#\">Contact&#x3C;/a>&#x3C;/li>\n      &#x3C;/ul>\n      &#x3C;label for=\"search-input\">Search&#x3C;/label>\n      &#x3C;input id=\"search-input\" type=\"search\" placeholder=\"Search\" />\n      &#x3C;input type=\"submit\" value=\"Search\" />\n    &#x3C;/nav>\n    &#x3C;main>\n      &#x3C;article>\n        &#x3C;h2>Home&#x3C;/h2>\n        &#x3C;p>Home page 내용&#x3C;/p>\n      &#x3C;/article>\n      &#x3C;aside>\n        &#x3C;h2>About&#x3C;/h2>\n        &#x3C;ul>\n          &#x3C;li>&#x3C;a href=\"#\">About 1&#x3C;/a>&#x3C;/li>\n          &#x3C;li>&#x3C;a href=\"#\">About 2&#x3C;/a>&#x3C;/li>\n          &#x3C;li>&#x3C;a href=\"#\">About 3&#x3C;/a>&#x3C;/li>\n        &#x3C;/ul>\n      &#x3C;/aside>\n    &#x3C;/main>\n    &#x3C;footer>\n      &#x3C;p>My Sementic Page&#x3C;/p>\n      &#x3C;p>Contact : &#x3C;address>soakdma37@gmail.com&#x3C;/address>&#x3C;/p>\n    &#x3C;/footer>\n  &#x3C;/body>\n&#x3C;/html>\n</code></pre>\n<p>이걸 실행해 보면 끔찍하다. 왜냐하면 아무런 스타일이 없기 때문이다. 후에 CSS를 정리할 때 스타일을 적용해 볼 수 있을 것이다. 하지만 지금은 시맨틱한 페이지를 만든 것에 만족하고 태그들을 살피자.</p>\n<h2>3.2. header</h2>\n<p>header 태그는 구획을 요약하고 소개, 탐색에 도움을 주는 컨텐츠 그룹을 나타낸다. 만약에 body에 바로 포함되어 있다면 문서 전체의 헤더를 나타낸다.</p>\n<p>section, article, nav, aside 등의 요소 안에 포함되어 있다면 해당 요소의 헤더를 나타낸다. 즉 영역의 제목과 간단한 설명 등을 감싸는 데에 사용할 수 있다.</p>\n<p>단 address, footer나 다른 header 태그의 자손으로는 사용될 수 없다.</p>\n<pre><code class=\"language-html\">&#x3C;!-- 이런 식으로 중첩된 헤더를 만들면 안 된다. -->\n&#x3C;header>\n  Parent header\n  &#x3C;header>\n    Child header\n  &#x3C;/header>\n&#x3C;/header>\n</code></pre>\n<p>header는 h1~h6, nav, form, section, article, aside, header, footer, address 등의 요소를 포함할 수 있다.</p>\n<h2>3.3. footer</h2>\n<p>footer 태그는 가장 가까운 구획의 footer를 나타낸다. 일반적으로 작성자, 저작권 정보, 관련 문서 바로가기 등을 담는다. 예를 들어 address 요소를 포함하는 게 일반적이다. 단 구획 콘텐츠는 아니라서 개요에 새로운 구획을 생성하지는 않는다.</p>\n<p>footer가 body 요소의 자식이면 footer는 전체 페이지에 적용된다.</p>\n<h2>3.4. main</h2>\n<p>main은 페이지의 주요 컨텐츠이다. 문서의 핵심 주제나 핵심 기능에 직접적으로 연결된 컨텐츠를 말한다.</p>\n<p>주요 컨텐츠인 만큼 hidden 속성이 없는 한 문서에 하나만 존재해야 한다. main은 article, section, div 등의 태그들을 포함할 수 있으며 요소 개요에 영향을 주지 않는다. 또한 이상적으로는 body에 바로 포함되어야 하며 다른 요소 안에 포함되어서는 안 된다.</p>\n<h2>3.5. article</h2>\n<p>article은 페이지의 나머지 요소와 상관없이 독립적으로 구분되고 재사용할 수 있는 컨텐츠 블록을 나타낸다. 뉴스 기사나 블로그 포스트 같은 것.</p>\n<p>하나의 문서가 여러 개의 article을 포함할 수 있는데, 사용자가 스크롤하면 계속 다음 글을 보여주는 블로그의 경우 각 글이 article 태그가 될 것이다.</p>\n<p>사용할 때 의미론적으로 생각해야 할 건 다음과 같다.</p>\n<ul>\n<li>각 article은 독립적으로 구분되어야 한다.</li>\n<li>article을 식별할 수단이 필요하다. 제목 요소를 article에 포함시키는 방법이 일반적이다.</li>\n<li>article이 중첩되어 있을 경우 안쪽 article은 바깥쪽 article에 관련된 글이다.</li>\n<li>address 태그를 이용해서 작성자 정보를 제공할 수 있다.</li>\n<li>article의 작성요소와 시간은 time의 datetime을 이용해서 표시할 수 있다.</li>\n</ul>\n<h2>3.6. aside</h2>\n<p>aside 태그는 페이지의 메인 컨텐츠와 직접 관련이 있지는 않지만 페이지의 주제와 간접적인 관련이 있는 컨텐츠를 나타낸다. 주로 사이드바로 표현되며 작성자의 정보, 용어 사전, 관련 링크 등이다.</p>\n<h2>3.7. nav</h2>\n<p>nav 태그는 페이지의 주요 링크를 모아놓은 구획을 나타낸다. 주로 메뉴나 목차를 만들 때 사용한다. 단 문서의 모든 링크를 포함할 필요는 없고, 주요 링크만 있으면 된다. 나머지 링크들은 footer에 포함될 때가 많다.</p>\n<p>또한 페이지 내에 목적에 따라 nav 여러 개를 가질 수 있는데 접근성 향상을 하려면 nav에 aria-labelledby을 추가해야 한다. 스크린리더도 nav를 참고하기 때문에 접근성에 영향을 미칠 수 있다.</p>\n<h2>3.8. address</h2>\n<p>가까운 HTML 요소의 사람, 단체, 조직 등에 대한 연락처 정보를 나타낸다. 주소, 이메일, 전화번호, SNS 등 어떤 정보라도 포함할 수 있다.</p>\n<p>헤더에 제작자의 연락처를 적는 데 사용할 수도 있고 article 내에 배치해서 해당 글의 작성자를 나타내는 데 쓸 수도 있다. footer 안에 흔히 쓰인다.</p>\n<pre><code class=\"language-html\">&#x3C;address>\n  &#x3C;p>Written by &#x3C;a href=\"mailto:soakdma37@gmail.com\">soakdma37&#x3C;/a>.&#x3C;/p>\n&#x3C;/address>\n</code></pre>\n<p><code>&#x3C;address></code>내부에 더 복잡한 형태의 마크업을 포함시켜 여러 연락처 정보를 담을 수도 있다.</p>\n<pre><code class=\"language-html\">&#x3C;address>\n  &#x3C;ul>\n    &#x3C;li>Tel: 01234 567 890&#x3C;/li>\n    &#x3C;li>Email: soakdma37@gmail.com&#x3C;/li>\n  &#x3C;/ul>\n&#x3C;/address>\n</code></pre>\n<p>단 <code>&#x3C;address></code>태그의 내용에 연락처 외의 정보를 담아서는 안된다. 가령 날짜 같은 것을 담으면 안된다.</p>\n<h2>3.9. section</h2>\n<p>section은 HTML 문서에서 하나의 기능을 수행하는 독립적인 구획을 나타낸다. 더 적합한 의미 요소가 없을 때 사용한다. 제목을 포함할 수도 있고 아닐 수도 있는데 제목이 아니라도 각 section을 식별할 수단이 필요하다.</p>\n<p>단 콘텐츠가 외부와 구분되어 단독으로 존재할 수 있다면 article 태그를 쓰는 것이 나을 수 있다. 그리고 section은 일반 컨테이너로 사용하는 게 아니라 문서에 해당 구획이 논리적으로 구분되어야 할 때 사용한다. 스타일링만이 목적이라면 div를 쓰자.</p>\n<p>section은 article과 비슷하다. 차이라고 한다면 article은 독립적으로 구분되어야 하지만 section은 그렇지는 않다. 그리고 맥락에 따라 article을 여러 개의 section으로 구성하거나 하나의 section을 여러 article로 구성할 수 있다.</p>\n<pre><code class=\"language-html\">&#x3C;section>\n  &#x3C;h2>Heading&#x3C;/h2>\n  &#x3C;img src=\"./my-image.png\" alt=\"페이지 예시 이미지\" />\n&#x3C;/section>\n</code></pre>\n<h2>3.10. heading</h2>\n<p><code>&#x3C;h1></code>에서 <code>&#x3C;h6></code>까지의 요소는 6단계의 구획 제목을 나타낸다. <code>&#x3C;h1></code>이 제일 큰 제목이다.</p>\n<p><code>&#x3C;h1></code>태그는 페이지당 1개만 있는 것이 좋으며, 제목 태그 자체를 한 페이지에 3개 이상 사용하는 것은 좋지 않다. 많은 단계의 목차를 가진 경우 다루기 쉽지 않기 때문이다. 이런 상황에서는 컨텐츠를 여러 페이지로 나누는 것이 좋다.</p>\n<p>그리고 <code>&#x3C;h1></code>을 쓴 구획 내에서는 <code>&#x3C;h2></code>를 다음으로 사용하는 등 제목 단계를 순차적으로 쓰는 것이 좋다. 그것이 스크린 리더 사용자의 접근성에 좋다.</p>\n<p>h1~h6태그에는 기본 스타일링이 있지만, 이는 의미와는 상관이 없다.</p>\n<p>예를 들어서 span 태그의 텍스트에 css를 적용하여 h1 태그의 기본 스타일링처럼 보이게 했다고 해도 두 태그의 근본적인 의미 차이는 바꿀 수 없다.</p>\n<p>제목 텍스트에 이 태그들을 쓰고, 폰트 사이즈 스타일링 등이 필요하다면 <code>font-size</code> CSS를 사용하자.</p>\n<h2>3.11. non-semantic wrapper div, span</h2>\n<p>어떤 내용을 넣을 특정한 시맨틱 태그가 마땅하지 않을 때 div나 span 태그를 딱히 태그 자체의 의미는 없는 래퍼 태그로 사용한다.</p>\n<p>div는 블록 레벨 요소로 묶을 때 쓰이고 span은 인라인 요소로 요소들을 묶을 때 쓰인다. 이렇게 묶어서 class등으로 스타일링을 할 수 있다.</p>\n<p>단 div 요소는 너무 편리하기 때문에 지나치게 많이 쓰일 때가 있는데, 어떤 시맨틱 태그도 어울리지 않을 때만 생각해서 써야 한다. 그렇지 않으면 의미없는 div 태그들로 코드가 어수선해지게 될 것이다.</p>\n<h2>3.12. br</h2>\n<p>텍스트 안에서 끊고 싶은 지점에 삽입하여 줄바꿈을 강제로 지정한다. 이는 짧은 줄들로 문장을 쓰고 싶을 때 줄바꿈을 강제하는 유일한 방법이다. 시를 HTML 내에서 표현할 때 등에 쓸 수 있다.</p>\n<p>단 줄바꿈을 삽입하는 요소일 뿐이므로 문단 구분을 <code>&#x3C;br></code>요소로 하지는 말자. 문단 구분에는 <code>&#x3C;p></code>태그를 사용하는 게 좋고 여백을 두는 데에는 margin CSS를 쓰는 게 좋다.</p>\n<h2>3.13 hr</h2>\n<p>hr 태그는 문단의 분리나 테마의 전환 등 문단 레벨 요소들의 주제 구분을 위해 사용된다. 브라우저에서는 수평선으로 그려진다.</p>\n<p>단 주제의 분리라는 의미를 가진 요소이므로 단순한 수평선을 그리려는 목적이라면 CSS를 사용하자.</p>\n<p>빈 요소이므로 닫는 태그가 있으면 안 된다.</p>",
    "excerpt": "1. 섹션 루트\n<head>에 들어가는 요소들을 제외하고 다른 요소들은 모두 섹션 루트 즉 <body>태그 내에 포함된다.\n섹션 루트는 문서의 내용 섹션을 나타내며 <body>태그로 나타내고 이 태그는 문서에 하나만 존재 가능하다.\nonblur, onerror, onfocus, onload, onresize, onpopstate 등의 이벤트 핸들러를 가질 수 있다. 이들은 문서에서 특정 이벤트가 생겼을 때 실행되는 함수를 지정한다. 더 많은 이벤트 핸들러는 bo",
    "headingTree": [
      {
        "title": "1. 섹션 루트",
        "url": "#1-섹션-루트",
        "items": []
      },
      {
        "title": "2. 페이지를 구성하는 영역",
        "url": "#2-페이지를-구성하는-영역",
        "items": [
          {
            "title": "2.1. 태그 구분의 필요성",
            "url": "#21-태그-구분의-필요성",
            "items": []
          }
        ]
      },
      {
        "title": "3. 콘텐츠 구획 태그",
        "url": "#3-콘텐츠-구획-태그",
        "items": [
          {
            "title": "3.1. 간단한 페이지 예시",
            "url": "#31-간단한-페이지-예시",
            "items": []
          },
          {
            "title": "3.2. header",
            "url": "#32-header",
            "items": []
          },
          {
            "title": "3.3. footer",
            "url": "#33-footer",
            "items": []
          },
          {
            "title": "3.4. main",
            "url": "#34-main",
            "items": []
          },
          {
            "title": "3.5. article",
            "url": "#35-article",
            "items": []
          },
          {
            "title": "3.6. aside",
            "url": "#36-aside",
            "items": []
          },
          {
            "title": "3.7. nav",
            "url": "#37-nav",
            "items": []
          },
          {
            "title": "3.8. address",
            "url": "#38-address",
            "items": []
          },
          {
            "title": "3.9. section",
            "url": "#39-section",
            "items": []
          },
          {
            "title": "3.10. heading",
            "url": "#310-heading",
            "items": []
          },
          {
            "title": "3.11. non-semantic wrapper div, span",
            "url": "#311-non-semantic-wrapper-div-span",
            "items": []
          },
          {
            "title": "3.12. br",
            "url": "#312-br",
            "items": []
          },
          {
            "title": "3.13 hr",
            "url": "#313-hr",
            "items": []
          }
        ]
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 343
    },
    "url": "/posts/html-section-tag",
    "thumbnail": {
      "local": "/thumbnails/html-section-tag-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-html-section-tag-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAfElEQVR4nGOoqanR0NCwsbHx9PRk5+Dw9fW1sbGxtLRkmDdvnqmpaXt7+7p16yZOmnTu3Llbt25dunSJYcvWrSmpqf39/bNnz962bdt/GGCAs/7///8bBkASl69eO3fu3JVLl169eoWsiKF34pTOru558+adO3cOogkiAQCY22hJyY6v5AAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "html-text-tag",
    "title": "HTML 텍스트 태그",
    "date": "2023-08-15T00:00:00Z",
    "description": "HTML에서 텍스트를 나타내는 데에 쓰이는 태그들",
    "tags": [
      "HTML"
    ],
    "html": "<h1>들어가면서</h1>\n<p>HTML의 주요 작업 중 하나는 브라우저가 텍스트를 올바르게 표시할 수 있도록 돕는 것이다. 텍스트가 없는 페이지는 거의 없으니까(특히 HTML이 처음 나오던 시절에는 더욱 그랬다).</p>\n<p>따라서 제목 및 단락을 추가하고, 목록을 만드는 등 페이지 내부의 텍스트를 나타내는 데에 쓰이는 태그들 중 기본적인 것을 알아보자.</p>\n<h1>1. 텍스트 콘텐츠</h1>\n<p>텍스트 콘텐츠 태그를 통해서 <code>&#x3C;body></code>내부의 콘텐츠 구획을 정리하며 콘텐츠 구획의 목적이나 구조 판별에 사용한다. 접근성과 SEO에 중요하다.</p>\n<p><code>&#x3C;blockquote></code>, <code>&#x3C;dl></code>, <code>&#x3C;dt></code>, <code>&#x3C;dd></code>, <code>&#x3C;div></code>, <code>&#x3C;figcaption></code>, <code>&#x3C;figure></code>, <code>&#x3C;hr></code>, <code>&#x3C;li></code>, <code>&#x3C;menu></code>, <code>&#x3C;ol></code>, <code>&#x3C;p></code>, <code>&#x3C;pre></code>, <code>&#x3C;ul></code> 태그를 포함한다.</p>\n<h2>1.1. blockquote</h2>\n<p>blockquote 요소는 블록 레벨 컨텐츠가 인용된 것을 나타낸다. 별도의 블록이 필요하지 않은 짧은 인용문은 이후에 인라인 텍스트 시맨틱에서 다룰 <code>&#x3C;q></code>태그를 사용하자.</p>\n<p>blockquote 태그의 cite 속성을 사용하면 인용의 출처도 나타낼 수 있다. <code>&#x3C;cite></code>태그를 이용하면 출처 텍스트도 제공할 수 있다.</p>\n<pre><code class=\"language-html\">&#x3C;blockquote cite=\"https://www.naver.com/\">네이버에서 인용한 무언가&#x3C;/blockquote>\n</code></pre>\n<p>주로 들여쓰기된 단락으로 나타낸다.</p>\n<p>그리고 blockquote, q 태그의 cite 속성은 페이지에 표시되지 않는다. 이런 인용 출처를 화면에 나타나게 하고 싶다면 역시 이후에 다룰 <code>&#x3C;cite></code> 태그를 사용하면 된다.</p>\n<h2>1.2. dl, dt, dd</h2>\n<p>목록을 표시하는 ul, ol 태그와 비슷하게 이 태그들을 이용하면 설명 목록을 만들 수 있다. 각 항목과 각 항목에 관련된 설명을 표시하는 것이다. <a href=\"https://xo.dev/articles/why-html-is-important-than-you-think\">HTML을 잘 쓰는 것에 대해 소개한 글에서도 유용한 태그로 이 태그를 예시로 들고 있다.</a></p>\n<p><code>&#x3C;dl></code> 태그는 <code>&#x3C;dt></code>, <code>&#x3C;dd></code> 태그를 포함하는 리스트를 만든다. <code>&#x3C;dt></code>(description term)는 각 항목을 나타내고 <code>&#x3C;dd></code>(description definition)는 항목에 대한 설명을 나타낸다. 용어 사전 구현이나 질문-답변 등 키-값 쌍 목록으로 된 메타데이터 표시에 사용한다.</p>\n<pre><code class=\"language-html\">&#x3C;dl>\n  &#x3C;dt>HTML&#x3C;/dt>\n  &#x3C;dd>웹페이지를 구조화하는 데에 사용된다.&#x3C;/dd>\n  &#x3C;dt>CSS&#x3C;/dt>\n  &#x3C;dd>웹페이지의 스타일링에 사용된다.&#x3C;/dd>\n  &#x3C;dt>JavaScript&#x3C;/dt>\n  &#x3C;dd>웹페이지를 동적으로 구성하도록 해준다.&#x3C;/dd>\n&#x3C;/dl>\n</code></pre>\n<p><code>&#x3C;dt></code>는 용어, 질문, 또는 제목을 나타내고 <code>&#x3C;dd></code>는 정의나 답변을 나타낼 수 있다. 참고로 <code>&#x3C;dt></code>, <code>&#x3C;dd></code>  그룹을 <code>&#x3C;div></code>로 감쌀 수도 있다. 스타일링 등에 유용하다.</p>\n<pre><code class=\"language-html\">&#x3C;dl>\n  &#x3C;div class=\"some-class\">\n    &#x3C;dt>HTML&#x3C;/dt>\n    &#x3C;dd>웹페이지를 구조화하는 데에 사용된다.&#x3C;/dd>\n  &#x3C;/div>\n&#x3C;/dl>\n</code></pre>\n<p>브라우저에서 제공하는 기본 스타일에 의해서 하위 항목 들여쓰기가 적용된다. 물론 들여쓰기를 목적으로 이 요소를 사용하는 건 좋지 않다.</p>\n<p>그리고 dt,dd는 일대일이 아니고 하나의 dt에 여러 dd가 붙어 있을 수 있다.</p>\n<pre><code class=\"language-html\">&#x3C;dl>\n  &#x3C;dt>마녀&#x3C;/dt>\n  &#x3C;dd>제가 쓰는 닉네임입니다.&#x3C;/dd>\n  &#x3C;dd>원래 이렇게 강력한 컨셉은 아니었습니다.&#x3C;/dd>\n  &#x3C;dd>별 생각 없이 닉네임을 마녀공장으로 지었는데, 다들 마녀라고 불러서 마녀가 되었습니다.&#x3C;/dd>\n&#x3C;/dl>\n</code></pre>\n<h2>1.3. div</h2>\n<p>div는 블록 레벨의 의미없는 요소를 제공하는 컨테이너이다. 페이지의 주요 콘텐츠와 관련이 없을 수도 있다.</p>\n<p>다른 요소들과 달리 div는 어떤 의미도 가지지 않는다. 그래서 div를 사용할 때는 <code>&#x3C;article></code>등의 의미를 가지는 요소를 사용할 수 없는지 고민해보고, 정 사용할 수 없다면 div를 사용해야 한다.</p>\n<h2>1.4. figure, figcaption</h2>\n<p>figure 요소는 독립적인 콘텐츠를 표현하며 내부에 figcaption 요소를 사용해 설명을 붙일 수 있다. 다음 코드에서는 이미지에 캡션을 다는 역할을 수행한다.</p>\n<pre><code class=\"language-html\">&#x3C;figure>\n  &#x3C;img src=\"assets/profile.jpg\">\n  &#x3C;figcaption>내 프로필 사진&#x3C;/figcaption>\n&#x3C;/figure>\n</code></pre>\n<p>물론 같은 형태의 디자인을 div, img, p 태그를 이용해서 구현할 수도 있지만 위처럼 하면 특정 이미지에 캡션을 연결해 준다는 의미를 브라우저에 전달할 수 있다.</p>\n<p>이때 figure 태그내의 요소가 꼭 이미지일 필요는 없다. 동영상이나 표, 코드 등이 올 수 있다.</p>\n<h2>1.5 hr</h2>\n<p>hr 태그는 문단의 분리나 테마의 전환 등 문단 레벨 요소들의 구분을 위해 사용된다. 브라우저에서는 수평선으로 그려진다.</p>\n<p>단 주제의 분리라는 의미를 가진 요소이므로 단순한 수평선을 그리려는 목적이라면 CSS를 사용하자.</p>\n<p>빈 요소이므로 닫는 태그가 있으면 안 된다.</p>\n<h2>1.6. ul, ol, li</h2>\n<p>ul 요소는 unordered list로 순서 없는 목록을 나타내고 ol 요소는 ordered list로 순서 있는 목록을 나타낸다. 블록 태그이다.</p>\n<p>두 태그 안에는 li 요소가 존재하는데 이는 list item으로 목록의 항목을 나타낸다. <code>li</code> 요소는 반드시 ul, ol, menu 태그 내부에 위치해야 한다.</p>\n<pre><code class=\"language-html\">&#x3C;ul>\n  &#x3C;li>사과&#x3C;/li>\n  &#x3C;li>배&#x3C;/li>\n  &#x3C;li>딸기&#x3C;/li>\n&#x3C;/ul>\n\n&#x3C;ol>\n오늘 할 일\n  &#x3C;li>HTML 공부&#x3C;/li>\n  &#x3C;li>CSS 공부&#x3C;/li>\n  &#x3C;li>JS 공부&#x3C;/li>\n&#x3C;/ol>\n</code></pre>\n<p>ul, ol의 차이라면 ol은 순서가 중요하다는 점이다. 항목에 순서가 있다면 ol을 사용해야 한다.</p>\n<p>순서가 있는 목록답게 <code>ol</code>은 목록의 순서 역전 여부를 나타내는 <code>reversed</code>, 항목의 순서 시작점을 나타내는 <code>start</code> 속성을 가진다. 또한 항목의 순서 카운터 스타일을 지정하는 <code>type</code> 속성을 가진다.</p>\n<p>물론 목록 태그들 간에 중첩도 가능하다.</p>\n<h2>1.7. menu</h2>\n<p>menu 태그는 사용자가 수행할 수 있는 명령 묶음을 말한다. 메뉴 이름을 뜻하는 label과 메뉴의 종류를 나타내는 type 속성을 가진다.</p>\n<p>그런데 내부에 쓰이는 <code>menuitem</code> 태그는 deprecated되었고, <code>menu</code> 태그 자체도 실험적인 기술이므로 현재 기준으로는 넘어가도 될 듯 하다.</p>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/HTML/Element/menu\">menu 태그 MDN 문서 링크</a></p>\n<h2>1.8. p</h2>\n<p>하나의 문단을 나타내는 블록 요소이다. 해당 태그를 이용해 컨텐츠를 문단 단위로 나누면 페이지의 접근성을 높인다. 아주 예전에는 ¶(필크로)특수문자를 사용해서 문단을 구분했지만 이제는 p 태그를 사용한다.</p>\n<p>브라우저에서는 기본적으로 한 줄의 간격으로 분리하며 다른 스타일은 CSS를 사용해서 지정한다. 앞서 보았던 다른 태그들처럼, 문단 사이 여백 추가를 위해 p 태그를 사용하면 안된다.</p>\n<pre><code class=\"language-html\">&#x3C;p>첫 번째 문단&#x3C;/p>\n&#x3C;p>두 번째 문단&#x3C;/p>\n</code></pre>\n<h2>1.9. pre</h2>\n<p>미리 서식을 지정한 텍스트를 나타내며 문서에 작성한 내용 그대로를 표현한다. 요소 내 공백 문자도 그대로 유지한다.</p>\n<p>일반적으로 HTML에서 공백을 여러 개 반복해 사용하면 파서가 하나의 공백으로 줄여 버리지만 pre 태그를 사용하면 pre 태그 내부 내용에서는 공백을 그대로 유지한다는 것이다. 따라서 아스키 아트 등을 표현할 때 사용할 수 있다.</p>\n<p>접근성을 고려하면 pre요소에 대한 대체 설명을 지정해야 한다. figure, figcaption, id, aria-labelledby 등을 사용할 수 있다.</p>\n<pre><code class=\"language-html\">&#x3C;figure role=\"textbox\" aria-labelledby=\"my-code\">\n  &#x3C;pre>\n    &#x3C;code>\n      function sayHello() {\n        console.log('Hello, World!');\n      }\n    &#x3C;/code>\n  &#x3C;/pre>\n  &#x3C;figcaption id=\"my-code\">\n    Hello, World!를 출력하는 함수를 Javascript로 작성한 코드\n  &#x3C;/figcaption>\n&#x3C;/figure>\n</code></pre>\n<h1>2. 인라인 텍스트 시맨틱</h1>\n<p>인라인 텍스트의 구조나 스타일을 정의한다. 종류가 엄청나게 많은데, <code>&#x3C;a></code>, <code>&#x3C;br></code>, <code>&#x3C;cite></code>, <code>&#x3C;code></code>, <code>&#x3C;q></code>, <code>&#x3C;small></code>, <code>&#x3C;span></code>, <code>&#x3C;strong></code>, <code>&#x3C;time></code>, <code>&#x3C;sup></code> 등이 있다. 꽤 자주 쓰이는 것만 여기 정리한다.</p>\n<p>모든 인라인 텍스트 시맨틱 태그가 큰 의미를 가지고 있는 건 아니다. <code>&#x3C;b></code>처럼 특별한 중요도 부여는 없고 CSS가 지원되지 않는 브라우저에서의 기본적인 텍스트 스타일링과 약간의 의미 구분을 위해서 사용되는 태그들도 있다.</p>\n<h2>2.1. a</h2>\n<p>a 태그는 anchor로 다른 페이지 혹은 같은 페이지의 특정 위치, 파일 등 어떤 URL로의 하이퍼링크를 나타낸다. href(hypertext reference의 약자) 특성을 통해 링크의 목적지를 지정할 수 있다.</p>\n<pre><code class=\"language-html\">&#x3C;a href=\"https://www.google.com\">구글&#x3C;/a>\n</code></pre>\n<p>위의 a태그 내에 <code>구글</code>이라고 작성했듯이, a태그 내의 콘텐츠는 접근성을 위해 링크 목적지의 설명을 나타내야 한다.</p>\n<p>그리고 <code>target=\"_blank\"</code>로 새 창을 열거나 다운로드를 시작하는 링크의 경우 링크 클릭시 발생하는 일을 링크 텍스트에 명시해야 한다.</p>\n<pre><code class=\"language-html\">&#x3C;a href=\"https://www.google.com\" target=\"_blank\">구글(새 탭에서 열림)&#x3C;/a>\n</code></pre>\n<p>그리고 a 태그 내에 이미지 등을 넣어 링크의 행동을 나타낼 땐 alt 텍스트를 꼭 지정하자.</p>\n<p><a href=\"https://witch.work/posts/html-link-tag\">a태그에 관련해서는 자세한 설명 글을 따로 작성하였다.</a></p>\n<h2>2.2. br</h2>\n<p>텍스트 안에서 끊고 싶은 지점에 삽입하여 줄바꿈을 지정한다. 단 줄바꿈을 삽입하는 요소일 뿐이므로 문단 구분을 <code>&#x3C;br></code>요소로 하지는 말자.</p>\n<p>문단 구분에는 <code>&#x3C;p></code>태그를 사용하는 게 좋고 여백을 두는 데에는 margin CSS를 쓰는 게 좋다.</p>\n<h2>2.3. cite</h2>\n<p><code>&#x3C;blockquote></code>와 같은 인용문의 <code>cite</code>속성은 유용해 보이지만 브라우저와 대부분의 스크린 리더는 cite 속성을 기본적으로 인식하지 않는다. 따로 CSS나 JS를 이용하지 않는 이상 사용자가 <code>cite</code>속성을 볼 수 있는 방법이 없다는 뜻이다.</p>\n<p>그래서 cite 속성을 제대로 표시하고 싶을 때는 <code>&#x3C;cite></code>태그를 사용하는 게 좋다. <code>&#x3C;cite></code> 태그는 출처 표기에 사용하며 인용 출처의 제목을 포함해야 한다. 책, 논문, 악보, 게임 등 다양한 저작물을 출처로 포함할 수 있다.</p>\n<p><code>&#x3C;blockquote></code>나 <code>&#x3C;q></code>태그와 함께 사용하면 인용문의 출처를 나타낼 수 있다.</p>\n<p>일반적인 브라우저는 이 태그 콘텐츠를 기울임꼴로 표기한다.</p>\n<pre><code class=\"language-html\">&#x3C;p>\n  현재 이 글의 내용 중 일부는 \n  &#x3C;a href=\"https://developer.mozilla.org/en-US/docs/Learn/HTML/Introduction_to_HTML/Advanced_text_formatting\">\n    &#x3C;cite>MDN의 텍스트 고급 기법 문서&#x3C;/cite>\n  &#x3C;/a>\n  에서 가져왔다.\n&#x3C;/p>\n</code></pre>\n<h2>2.4. abbr</h2>\n<p>abbr 태그는 abbreviation의 약자로 약어를 나타낸다. 처음 등장할 때 용어의 전체 내용을 제공하고 그 뒤에 약어를 나타내기 위한 <code>&#x3C;abbr></code>태그를 제공하는 식으로 쓰인다. 이렇게 하면 사용자에게 약어가 원래 무슨 뜻인지 단서를 제공할 수 있다.</p>\n<p>만약 약어의 전체 내용을 표시하는 게 그렇게 필요하지 않다면 그냥 title 특성을 통해 약어의 전체 내용을 제공할 수 있다. title 속성은 다른 내용을 포함하면 안된다.</p>\n<pre><code class=\"language-html\">&#x3C;abbr title=\"HyperText Markup Language\">HTML&#x3C;/abbr>\n</code></pre>\n<p>HTML의 이전 버전에 있었던 acronym 태그도 abbr 태그와 같은 기능을 한다. 하지만 abbr이 약어와 두문자어를 동시에 지원하도록 바뀌면서 acronym은 deprecated되었다. 따라서 acronym을 사용하지 말고 abbr을 사용하도록 하자.</p>\n<h2>2.5. sup, sub</h2>\n<p><code>&#x3C;sub></code>는 아래 첨자로 나타낼 인라인 텍스트를 지정한다. 기존의 관례상 아래 첨자로 나타나는 각주, 수학 변수의 숫자표기, 화학식 원소를 나타낼 때 등에 쓴다.</p>\n<p><code>&#x3C;sup></code>는 위 첨자로 나타낼 인라인 텍스트를 지정한다. 지수 표기, 4th와 같은 서수 표기 등에 사용한다.</p>\n<h2>2.6. em, strong</h2>\n<p>페이지 내부에서 어떤 문장이나 내용을 강조하거나 중요하게 표시해야 할 때가 있다. 이를 위한 인라인 요소들이 존재한다.</p>\n<p>em 태그는 emphasis의 약자로 텍스트의 강조를 나타내고 기본 스타일은 이탤릭체다. 단 단순히 기울임꼴이 필요해서 이 태그들를 쓰면 안된다. 그럴 땐 CSS를 써야 한다.</p>\n<pre><code class=\"language-js\">&#x3C;p>HTML은 &#x3C;em>텍스트&#x3C;/em>를 올바르게 표시할 수 있도록 설계되었다.&#x3C;/p>\n</code></pre>\n<p>이렇게 em태그를 쓰거나 비슷한 의도의 strong 태그를 쓰면 스크린 리더에서도 다른 톤의 목소리로 표현된다.</p>\n<p>반면 strong은 전체 문서에서 중대하거나 긴급한 콘텐츠, 혹은 주변 콘텐츠와 비교해서 매우 중요한 부분을 나타낸다. 경고 혹은 페이지의 텍스트에 대한 노트를 나타낼 수 있다. 보통은 브라우저에서 굵은 글씨로 표시된다.</p>\n<pre><code class=\"language-html\">&#x3C;strong>절대&#x3C;/strong> 늦으면 안 된다.\n</code></pre>\n<p>단 단순히 굵은 글씨체를 위해서만 사용하면 안 된다. 장식의 의미로 굵은 글씨를 쓰고 싶다면 CSS를 사용하자. 그리고 중요의 의미 없이 그저 주의를 집중시키고 싶을 뿐이라면 b 태그를 사용하자.</p>\n<p>그런데 <code>&#x3C;em></code>도 강조하는 태그 아닌가? 라고 생각할 수 있다. 그러나 <code>&#x3C;em></code>은 강조를 위한 태그이고 <code>&#x3C;strong></code>은 중요성을 나타내는 태그이다.</p>\n<p><code>&#x3C;em></code>은 말할 때 특정 부분에 강조하는 세를 넣는 것과 같다. '난 <em>네가</em> 좋아'라고 하는 것과 '난 네가 <em>좋아</em>'에서 어디에 강세를 넣는지에 따라서 의미가 달라진다. 하지만 <code>&#x3C;strong></code>은 문장 자체에 중요성을 주입할 때 사용한다. '<strong>경고!</strong> 위험한 물질임' 같은 느낌이다.</p>\n<h3>2.6.1. b, i, u</h3>\n<p>em과 비슷하게 이탤릭체를 만드는 태그로 i 태그가 있다. 또한 각각 굵은 글씨와 밑줄을 나타내는 b,u 태그도 있다. 이 요소들은 CSS가 제대로 지원되지 않을 때 사용할 수 있도록 고안되었다.</p>\n<p>이렇게 표현에만 영향을 주는 요소들은 CSS가 아주 대중적이 된 지금 사용할 이유가 딱히 없다. 하지만 HTML5에서는 이 태그들에 새로운 의미론적 역할을 부여하였다.</p>\n<p>HTML5에서는 이 태그들을 이전부터 굵은 글씨 혹은 이탤릭체, 밑줄로 표현하여 구분하던 의미를 전달하기 위해 사용하도록 했다.</p>\n<p>예를 들어서 기술 용어나 외국어는 원래부터 이탤릭체로 표기하곤 했으므로 i 태그를 쓰는 것이다. 잘못된 철자 등은 밑줄로 나타내곤 했으므로 u 태그를 쓰고 말이다.(단 일반적으로 사람들을 밑줄을 하이퍼링크와 강하게 연관해 생각하므로 <code>u</code>태그를 쓰려고 할 때는 더 적합한 표현이 있는지 늘 고민해야 한다)</p>\n<p>i 태그도 이탤릭체 결과를 내놓는다. 하지만 em은 강조를 위해 사용하는 태그이고 i는 외국어, 독백 등 일반적인 맥락에서 벗어났을 경우 사용한다.</p>\n<h2>2.7. code</h2>\n<p>짧은 코드 조각을 나타내는 인라인 요소이다. 기본 스타일은 사용자 에이전트에서 지원하는 고정폭 글씨체다.</p>\n<p>해당 태그는 보통 한 줄의 코드만 나타내므로 여러 줄의 코드를 나타내려면 <code>&#x3C;pre></code>태그를 사용하자.</p>\n<h2>2.8. mark</h2>\n<p>현재 맥락에 관련이 깊거나 관심을 가져야 할 중요한 부분을 나타낸다. 형광펜으로 강조 표시를 하는 것과 같다고 생각하면 된다.</p>\n<p>단 표시를 위해서만 사용하면 안 된다. 그럴 땐 CSS를 사용하자.</p>\n<h2>2.9. q</h2>\n<p>짧은 인라인 인용문. cite 속성을 써서 출처를 표기할 수 있다.</p>\n<pre><code class=\"language-html\">&#x3C;p>이 문장은 &#x3C;q cite=\"https://www.naver.com/\">네이버에서 인용한 무언가&#x3C;/q>를 인용했다.&#x3C;/p>\n</code></pre>\n<p>인라인 인용구는 기본적으로 따옴표로 묶인 일반 텍스트로 표현된다.</p>\n<h2>2.10. span</h2>\n<p>본질적으로는 아무 의미도 나타내지 않는 통용 인라인 컨테이너다. 스타일 적용이나 어떤 특성을 공유하는 요소를 묶을 때 쓸 수 있다. 의미를 갖지 않는 요소를 제공한다는 점에서 인라인 버전의 <code>div</code>라고도 할 수 있겠다.</p>\n<h2>2.11. time</h2>\n<p>시간의 특정 지점 또는 구간을 기계가 읽을 수 있는 형식으로 나타낸다. datetime 특성 값을 지정해 시간을 나타내는 문자열을 사용자 에이전트에 제공할 수 있다.</p>\n<p>datetime 특성이 없는 경우 요소의 텍스트 콘텐츠를 datetime 특성값으로 간주하며 이럴 경우 자식 요소를 두어서는 안된다.</p>\n<pre><code class=\"language-html\">&#x3C;p>최종 수정일: &#x3C;time datetime=\"2023-06-28\">2023년 6월 28일&#x3C;/time>&#x3C;/p>\n</code></pre>\n<p>datetime 속성을 설정할 경우 datetime 내부의 날짜 표기는 사용자의 마음대로 할 수 있지만, datetime 속성에는 기계가 읽을 수 있는 형식으로 표기해야 한다.</p>\n<h2>2.12. var</h2>\n<p>수학 표현이나 프로그래밍 문맥 등에서 변수명을 나타낸다. 브라우저마다 다르지만 흔히 이탤릭체로 표기된다.</p>\n<pre><code class=\"language-html\">&#x3C;p>\n  &#x3C;var>x&#x3C;/var>는 &#x3C;var>y&#x3C;/var>의 2배이다.\n&#x3C;/p>\n</code></pre>\n<p>스타일링을 위해서 사용하면 안된다. 스타일링이 필요할 경우 <code>&#x3C;span></code>으로 래핑하고 CSS를 쓰자.</p>\n<h2>2.13. kbd</h2>\n<p>키보드 입력 등 사용자의 입력을 나타낸다. 보통 키보드 입력을 나타내기 위해 사용한다.</p>\n<pre><code class=\"language-html\">&#x3C;p>Press &#x3C;kbd>Ctrl&#x3C;/kbd> + &#x3C;kbd>C&#x3C;/kbd> to copy the text.&#x3C;/p>\n</code></pre>\n<p><code>&#x3C;kbd></code>요소를 중첩해 사용하여 하나의 입력 안에 작은 부분 입력을 나타낼 수 있다.</p>\n<h2>2.14. samp</h2>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/samp\">samp 태그의 MDN 문서</a></p>\n<p>컴퓨터 프로그램 출력의 예시(혹은 인용문)를 나타낸다.</p>\n<p>kbd 요소를 samp 요소 안에 배치하면 시스템이 재출력한 입력을 나타낼 수 있다.</p>\n<h1>참고</h1>\n<p>HTML 텍스트\n<a href=\"https://developer.mozilla.org/ko/docs/Learn/HTML/Introduction_to_HTML/HTML_text_fundamentals\">https://developer.mozilla.org/ko/docs/Learn/HTML/Introduction_to_HTML/HTML_text_fundamentals</a></p>\n<p>HTML 텍스트 고급 기법\n<a href=\"https://developer.mozilla.org/en-US/docs/Learn/HTML/Introduction_to_HTML/Advanced_text_formatting\">https://developer.mozilla.org/en-US/docs/Learn/HTML/Introduction_to_HTML/Advanced_text_formatting</a></p>",
    "excerpt": "들어가면서\nHTML의 주요 작업 중 하나는 브라우저가 텍스트를 올바르게 표시할 수 있도록 돕는 것이다. 텍스트가 없는 페이지는 거의 없으니까(특히 HTML이 처음 나오던 시절에는 더욱 그랬다).\n따라서 제목 및 단락을 추가하고, 목록을 만드는 등 페이지 내부의 텍스트를 나타내는 데에 쓰이는 태그들 중 기본적인 것을 알아보자.\n1. 텍스트 콘텐츠\n텍스트 콘텐츠 태그를 통해서 <body>내부의 콘텐츠 구획을 정리하며 콘텐츠 구획의 목적이나 구조 판별에 사용한다. 접",
    "headingTree": [
      {
        "title": "들어가면서",
        "url": "#들어가면서",
        "items": []
      },
      {
        "title": "1. 텍스트 콘텐츠",
        "url": "#1-텍스트-콘텐츠",
        "items": [
          {
            "title": "1.1. blockquote",
            "url": "#11-blockquote",
            "items": []
          },
          {
            "title": "1.2. dl, dt, dd",
            "url": "#12-dl-dt-dd",
            "items": []
          },
          {
            "title": "1.3. div",
            "url": "#13-div",
            "items": []
          },
          {
            "title": "1.4. figure, figcaption",
            "url": "#14-figure-figcaption",
            "items": []
          },
          {
            "title": "1.5 hr",
            "url": "#15-hr",
            "items": []
          },
          {
            "title": "1.6. ul, ol, li",
            "url": "#16-ul-ol-li",
            "items": []
          },
          {
            "title": "1.7. menu",
            "url": "#17-menu",
            "items": []
          },
          {
            "title": "1.8. p",
            "url": "#18-p",
            "items": []
          },
          {
            "title": "1.9. pre",
            "url": "#19-pre",
            "items": []
          }
        ]
      },
      {
        "title": "2. 인라인 텍스트 시맨틱",
        "url": "#2-인라인-텍스트-시맨틱",
        "items": [
          {
            "title": "2.1. a",
            "url": "#21-a",
            "items": []
          },
          {
            "title": "2.2. br",
            "url": "#22-br",
            "items": []
          },
          {
            "title": "2.3. cite",
            "url": "#23-cite",
            "items": []
          },
          {
            "title": "2.4. abbr",
            "url": "#24-abbr",
            "items": []
          },
          {
            "title": "2.5. sup, sub",
            "url": "#25-sup-sub",
            "items": []
          },
          {
            "title": "2.6. em, strong",
            "url": "#26-em-strong",
            "items": [
              {
                "title": "2.6.1. b, i, u",
                "url": "#261-b-i-u",
                "items": []
              }
            ]
          },
          {
            "title": "2.7. code",
            "url": "#27-code",
            "items": []
          },
          {
            "title": "2.8. mark",
            "url": "#28-mark",
            "items": []
          },
          {
            "title": "2.9. q",
            "url": "#29-q",
            "items": []
          },
          {
            "title": "2.10. span",
            "url": "#210-span",
            "items": []
          },
          {
            "title": "2.11. time",
            "url": "#211-time",
            "items": []
          },
          {
            "title": "2.12. var",
            "url": "#212-var",
            "items": []
          },
          {
            "title": "2.13. kbd",
            "url": "#213-kbd",
            "items": []
          },
          {
            "title": "2.14. samp",
            "url": "#214-samp",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 2,
      "wordCount": 458
    },
    "url": "/posts/html-text-tag",
    "thumbnail": {
      "local": "/thumbnails/html-text-tag-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-html-text-tag-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAaklEQVR4nGPIz8/n5OR2cnIRFxc3MTFhZmaOi4v7//8/Q35+gZKSUktLy759+w6BwdWrV0ESy5Yvj4uLa2hoeP78+X8kwABn/QIDhMTZ8xeOHz9+9swZdB1NLe1V1TUTJ048fvw4RB9EAgCkompxroTEXAAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "import-and-require",
    "title": "JS 탐구생활 - require와 import 그리고 JS의 모듈 시스템",
    "date": "2023-07-30T00:00:00Z",
    "description": "require와 import 탐구",
    "tags": [
      "javascript"
    ],
    "html": "<h1>0. 시작</h1>\n<p>JS의 모듈에 관한 키워드인 import와 require의 차이는 유명한 프론트 면접 질문 중 하나다. 하지만 나는 이에 대해서 잘 알지 못했다. require가 commonJS에서 쓰이는 문법이고 import가 ES6부터 도입되었다는 정도만 들어서 알고 있었다.</p>\n<p>그래서 이참에 예전에 들어 보기만 하고 묻어 두었던 관련 글들을 꺼내서 읽어보고 정리했다. 차근차근 깊이 들어가는 글이 되려고 노력하였다.</p>\n<h1>1. 기초적인 차이</h1>\n<p>먼저 각자의 문법과 기본적인 차이부터 조사하였다. require와 import는 모두 외부 모듈의 코드를 불러오는 작업을 수행하는 데에 쓰인다.</p>\n<h2>1.1. require</h2>\n<p>모듈을 불러올 때는 <code>require</code> 키워드만 사용하면 된다.</p>\n<pre><code class=\"language-javascript\">const express = require('express');\n</code></pre>\n<p>모듈을 내보낼 때는 <code>exports</code>와 <code>module.exports</code> 2가지의 방법이 있다. 사용하는 방식은 다음과 같다.</p>\n<ol>\n<li>여러 객체를 내보낼 때는 exports의 속성으로 할당한다.</li>\n<li>하나의 객체를 내보낼 때는 module.exports에 할당한다.</li>\n</ol>\n<pre><code class=\"language-javascript\">// 여러 객체를 내보낼 때\n\nexports.a = 1;\nexports.b = 2;\nexports.c = 3;\n\n// 하나의 객체를 내보낼 때\nconst obj = {\n    a: 1,\n    b: 2,\n    c: 3\n};\n\nmodule.exports = obj;\n</code></pre>\n<p>모듈에서 내보내지는 데이터를 담고 있는 객체가 exports이기 때문에 이렇게 해주는 것이다.</p>\n<p>불러올 때는 어떤 방식으로 모듈을 내보냈건 상관없이 <code>require</code>를 사용한다. 이렇게 해서 다른 파일의 exports 객체를 불러와 사용할 수 있다.</p>\n<pre><code class=\"language-javascript\">const obj = require('./obj');\n\nconsole.log(obj.a); // 1\n\n// 각각 불러오기\nconst { a, b, c } = require('./obj');\n</code></pre>\n<h3>1.1.1. exports와 module.exports</h3>\n<p>약간 의문이 생길 수 있는 지점이 있다. 왜 exports와 module.exports를 따로 쓰는 것일까? <a href=\"https://nodejs.org/api/modules.html#exports-shortcut\">exports는 module.exports의 shortcut이기 때문이다.</a></p>\n<p><code>module.exports</code> 변수는 모듈에서 내보내기를 할 객체를 가리킨다. 그리고 편의성을 위해서 모듈 내부에서는 <code>exports</code>를 통해서도 <code>module.exports</code>에 접근할 수 있다.</p>\n<p>따라서 <code>exports.attr=1</code>과 같이 내보낼 객체의 속성을 추가하는 것은 <code>module.exports.attr=1</code>과 같은 표현이다. 편의성을 위해 <code>exports</code>만 쓰는 것 뿐이다.</p>\n<p>그런데 하나의 객체만 내보내고 싶을 때는 <code>module.exports</code>에 할당해야 한다. <code>exports</code>는 shortcut일 뿐이기 때문에 <code>exports=obj</code>와 같이 할당하게 되면 <code>module.exports</code>에도 똑같이 할당되는 것이 아니라 새로운 지역 변수 <code>exports</code>를 만들고 거기에 할당하게 되기 때문이다.</p>\n<p>반면 <code>module.exports</code>에 할당하면 <code>exports</code>에도 같은 값이 들어간다. 모듈이 평가되기 전, <code>exports</code> 변수에는 모듈의 <code>module.exports</code> 변수의 값이 할당되기 때문이다.</p>\n<p>nodejs에서는 <code>require</code>의 작동 방식을 간략화한 코드를 통해서 이를 설명하고 있다.</p>\n<pre><code class=\"language-javascript\">function require(/* ... */) {\n  /* 기본 모듈 객체 */\n  const module = { exports: {} };\n  /* 즉시 실행 함수 */\n  ((module, exports) => {\n    // someFunc은 모듈에서 내보내는 함수\n    function someFunc() {}\n    /* exports에 모듈 할당 */\n    exports = someFunc;\n    /* 이제 exports는 module.exports의 shortcut이 아니며 module에서 내보내는 객체는 여전히 모듈 시스템이 만든 기본 객체 */\n    module.exports = someFunc;\n    /* 이제 모듈은 someFunc을 내보낸다 */\n  })(module, module.exports);\n  return module.exports;\n} \n</code></pre>\n<p>참고로 <code>modules.exports</code>에 대한 할당은 콜백 함수 등으로 이루어지면 안 된다. 이벤트 기반이 아니라 즉각적으로 할당되어야 한다.</p>\n<pre><code class=\"language-javascript\">/* 이렇게 하면 안 된다! */\nsetTimeout(() => {\n  module.exports = { a: 1 };\n}, 1000);\n</code></pre>\n<h2>1.2. import</h2>\n<p>require 대신 ES6에서 새로 도입된 키워드인 import를 사용해서 모듈을 불러올 수 있다. 이때 다른 모듈에서 객체를 불러오는 방식은 내보내기를 한 방식에 따라 달라진다. 따라서 객체를 내보내는 방식부터 알아보자.</p>\n<p>내보내는 방식은 named export와 default export가 있다. named export는 여러 객체를 내보낼 때 사용하고 default export는 하나의 객체만 내보낼 때 사용한다.</p>\n<pre><code class=\"language-javascript\">// named export\nexport const a = 1;\nexport const b = 2;\nexport const c = 3;\n\n// default export\nconst obj = {\n    a: 1,\n    b: 2,\n    c: 3\n};\n\nexport default obj;\n</code></pre>\n<p>그리고 가져올 때, named export는 <code>{}</code>를 사용하며 불러오며 내보낼 때 사용한 이름과 동일한 이름을 사용해야 한다. 식별자 충돌을 피하기 위해서 named export를 별칭으로 할 수도 있다.</p>\n<pre><code class=\"language-js\">export { myFunction as function1, myVariable as variable };\n</code></pre>\n<p>반면 default export는 <code>{}</code>를 사용하지 않고 내보낼 때 사용한 이름과 다른 이름을 사용할 수 있다. 어떤 이름을 사용하든 언제나 default export된 객체만을 가져온다.</p>\n<p>따라서 당연히 default export는 모듈당 딱 하나만 있어야 한다.</p>\n<pre><code class=\"language-javascript\">/* named export 가져오기 */\nimport { a, b, c } from './obj';\n\n/* named export를 별칭으로 가져오기 */\nimport { a as a1, b as b1, c as c1 } from './obj';\n\n/* 모듈 전체 가져오기. named export된 것들을 *로 한번에 묶고 가져와서 as로 별칭을 줘서, default export된 객체처럼 사용 가능 */\nimport * as obj from './obj';\n\n/* default export 가져오기 */\nimport obj from './obj';\n</code></pre>\n<p>변수 바인딩 없이 특정 모듈을 불러와서 실행만 하려 한다면 import만 사용하는 것이 낫다.</p>\n<pre><code class=\"language-javascript\">import './obj.js';\n</code></pre>\n<p>이때 이렇게 가져와진 모듈은 여러 곳에서 사용되더라도 최초 호출 시 단 한 번만 실행된다. 그리고 실행된 모듈은 필요한 곳에 공유되기 때문에 어느 한 모듈에서 객체를 수정하면 다른 모듈에서도 변경사항을 확인할 수 있다.</p>\n<h2>1.3. dynamic import</h2>\n<p>이후에 자세히 설명하겠지만 commonJS의 require는 런타임에 모듈을 읽어 온다. 반면 import는 정적으로 모듈을 불러오기 때문에 import문이 파일의 최상단에 있어야 했고 따라서 동적으로 모듈을 사용할 수 없다는 문제가 있었다.</p>\n<p>예를 들어서 함수 호출의 결과값을 경로로 사용하거나 조건부로 모듈을 불러올 수 없었다.</p>\n<pre><code class=\"language-javascript\">// 불가능한 구문들\nimport { something } from getModuleName();\n\nif (condition) {\n    import { something } from './something';\n}\n</code></pre>\n<p>이런 문제를 해결하기 위해 dynamic import가 도입되었다. 이를 사용하면 런타임에 모듈을 불러올 수 있다. <code>import(module)</code> 표현식은 모듈을 읽고, 모듈이 export하는 모든 것을 포함하는 promise를 반환한다.</p>\n<pre><code class=\"language-javascript\">import(module).then((module) => {\n    // 모듈 객체 사용\n});\n\n// async/await 사용(당연히 async 함수 안에서만 사용 가능)\nconst module = await import(module);\n/* default export된 객체를 사용하려면 module.default를 사용 */\nconsole.log(module.default);\n</code></pre>\n<p>단 이는 함수 호출과는 다른 특수한 문법이기 때문에 import를 변수에 복사하거나 call/apply를 쓰는 것이 불가능하다. 그리고 이는 일반 스크립트에서도 동작한다. script 태그에 type=\"module\"을 추가하지 않아도 된다.</p>\n<h2>1.4. 브라우저에서 모듈 사용하기</h2>\n<p>브라우저에서는 import를 사용하기 위해서는 <code>&#x3C;script></code> 태그에 <code>type=\"module\"</code>을 추가해야 한다. 그렇지 않으면 import를 사용할 수 없다. 모듈은 특수한 키워드 등을 통해서 사용되기 때문이다.</p>\n<pre><code class=\"language-html\">&#x3C;script type=\"module\" src=\"main.js\">&#x3C;/script>\n</code></pre>\n<p>이렇게 선언한 모듈은 각 파일의 독립적인 스코프를 가지기 때문에 모듈 내부에서 정의한 변수나 함수는 <code>import</code>없이 다른 스크립트에서 접근할 수 없다. 예를 들어 다음과 같이 쓴다고 하자.</p>\n<pre><code class=\"language-html\">&#x3C;script type=\"module\" src=\"A.js\">&#x3C;/script>\n&#x3C;script type=\"module\" src=\"B.js\">&#x3C;/script>\n</code></pre>\n<p><code>A.js</code>와 <code>B.js</code>는 같은 HTML 파일에 있는 모듈이지만 서로의 스코프에 접근할 수 없다.</p>\n<p>그리고 이렇게 선언된 스크립트는 언제나 지연 실행된다. 모듈이 언제 로딩이 완료되건 간에 HTML 문서가 완전히 준비되고 나서야 실행되는 것이다.</p>\n<p>만약 HTML 문서가 처리되길 기다리지 않고 모듈이 바로 실행되길 원한다면 <code>async</code> 속성을 태그에 추가하면 된다.</p>\n<pre><code class=\"language-html\">&#x3C;script type=\"module\" src=\"main.js\" async>&#x3C;/script>\n</code></pre>\n<h1>2. 역사 이야기</h1>\n<p>이제 좀 깊이 들어가 보자.</p>\n<p>내가 개발을 제대로 시작한 것은 2021년이었고 그때는 이미 ES6가 주류였다. 그래서 <code>import</code>를 쓰려고 하는 것이 당연했고 nodeJS를 쓸 때도 package.json에 <code>\"type\":\"module\"</code>을 추가해서 import를 사용하는 것이 당연한 줄 알았다. 모두가 그게 새로운 흐름이라며 이제 import의 시대라고 했으니까.</p>\n<p>하지만 2023년 현재도 commonJS의 모듈 문법은 아직도 많이 쓰이고 있다. 2023년 7월 30일 지금도 nodeJS의 공식 문서에서는 require를 사용하고 있고 package.json의 기본값도 <code>\"type\":\"commonjs\"</code>이다. 그리고 많은 npm 패키지들도 commonJS를 사용하거나 최소한 지원하고 있다. pure ESM 패키지는 여전히 지분이 그렇게 크지 않다.</p>\n<pre><code class=\"language-js\">/* nodeJS 공식 문서의 코드. commonJS를 사용하는 것을 볼 수 있다 */\nconst http = require('http');\n\nconst hostname = '127.0.0.1';\nconst port = 3000;\n\nconst server = http.createServer((req, res) => {\n  res.statusCode = 200;\n  res.setHeader('Content-Type', 'text/plain');\n  res.end('Hello World');\n});\n\nserver.listen(port, hostname, () => {\n  console.log(`Server running at http://${hostname}:${port}/`);\n});\n</code></pre>\n<p>그럼 이 commonJS라는 건 왜 생겨났으며 지금도 존재하는가? import를 사용하는 ES 모듈이 새로운 흐름이며 더 좋은 방식이라면 왜 commonJS는 역사 속으로 사라지지 않았으며 오히려 아직도 생태계를 지배하고 있는가? 수많은 기법과 패턴과 라이브러리들이 역사 속으로 사라졌는데 왜 이 commonJS는 아직도 살아남아 있는가?</p>\n<h2>2.1. JS 모듈이 없었을 때의 이야기</h2>\n<p>코드를 작성할 때 여러 파일에 나누어서 모듈화를 하는 일은 흔하다. 이렇게 모듈화를 하면 코드의 재사용이 가능해지고, 코드들이 분리되어서 관리와 협업을 하기 쉬워진다. 그리고 코드의 구조화가 용이해진다.</p>\n<p>하지만 오래전 브라우저에서만 쓰였던 JS에서는 이런 모듈 시스템을 지원하지 않았다. npm 같은 건 물론 없었다. 개발자는 외부 라이브러리를 직접 다운로드해서 프로젝트의 정적 파일들을 위한 폴더에 옮겨둔 후 HTML의 <code>&#x3C;script></code>태그를 통해 불러와야 했다.</p>\n<p>사실 JS가 만들어진지 얼마 안 되었을 때는 모듈 시스템뿐 아니라 지금 있는 기능들의 절반도 없었다.</p>\n<p>그런 언어였기에 장난감 같은 언어로 취급받았고 그랬기 때문에 많은 기능이 필요할 만큼의 스크립트를 JS로 작성하지 않았다. JS로 작성되는 스크립트의 크기가 대부분 그렇게 크지 않았기 때문에 모듈 시스템이 없이도 그럭저럭 성장할 수 있었다.</p>\n<p>그럼 당시에 다른 파일에 있는 객체에 접근하기 위해서는 어떻게 했을까? 전역 window 객체를 사용했다. 당시에는 ES6가 나오기 전이라 var 키워드만 존재했고 JS는 브라우저에서만 실행되는 언어였기 때문에 전역에 선언한 모든 객체가 window 객체를 통해 접근할 수 있었기에 이런 방식이 가능했다.</p>\n<pre><code class=\"language-js\">// A.js\nvar myName=\"김성현\";\nvar myAge=26;\nvar fruits=[\"사과\",\"바나나\",\"포도\"];\n\nvar functionA=function(){\n  console.log(\"제 이름은 \" + myName + \"입니다.\");\n  console.log(\"나이는 \" + myAge + \"살입니다.\");\n  console.log(\"좋아하는 과일은 \" + fruits[0] + \"입니다.\");\n}\n</code></pre>\n<pre><code class=\"language-js\">// B.js\nconsole.log(window.myName);\nconsole.log(window.myAge);\nconsole.log(window.fruits);\n\nwindow.functionA();\n</code></pre>\n<p>그리고 다음과 같이 <code>index.html</code>의 <code>&#x3C;script></code> 태그에 모든 파일을 포함하고 브라우저에서 실행시켜야 했다.</p>\n<pre><code class=\"language-html\">&#x3C;script src=\"./A.js\">&#x3C;/script>\n&#x3C;script src=\"./B.js\">&#x3C;/script>\n</code></pre>\n<p>이런 방식은 대부분의 코드가 결국 같은 스코프에 있기 때문에 충돌의 위험이 너무 컸다. 위 코드에서도 <code>B.js</code>에서 <code>A.js</code>의 모든 변수, 이를테면 <code>myName</code>같은 것을 window 전역 객체를 통해 접근할 수 있는 것을 볼 수 있었다. <code>myName</code>과 같은 변수가 노출될 필요가 없었는데도 말이다.</p>\n<p>또한 재사용성도 떨어졌으며 변수의 순서를 고려해서 script 태그 순서를 잘 설계해야 했다. 위 HTML 파일에서도 <code>B.js</code>를 먼저 불러오면 에러가 발생한다.</p>\n<pre><code class=\"language-html\">&#x3C;!-- 다음과 같이 B.js 먼저 로딩 시 순서가 꼬여서 에러 발생 -->\n&#x3C;script src=\"./B.js\">&#x3C;/script>\n&#x3C;script src=\"./A.js\">&#x3C;/script>\n</code></pre>\n<p>IIFE(즉시 실행 함수)를 이용해서 이 방식을 좀 개선할 수 있었다. 클로저를 이용해서 private 멤버를 만들던 패턴을 사용하는 것이다. 예를 들어서 <code>A.js</code>를 다음과 같이 바꾸면 외부에서 <code>myName</code>이나 <code>myAge</code>에 접근할 수 없다.</p>\n<pre><code class=\"language-js\">var A=(function(){\n  var myName=\"김성현\";\n  var myAge=26;\n  var fruits=[\"사과\",\"바나나\",\"포도\"];\n\n  return {\n    functionA:function(){\n      console.log(\"제 이름은 \" + myName + \"입니다.\");\n      console.log(\"나이는 \" + myAge + \"살입니다.\");\n      console.log(\"좋아하는 과일은 \" + fruits[0] + \"입니다.\");\n    }\n  }\n})();\n</code></pre>\n<p>이제 개발자가 노출시키고 싶은 <code>functionA</code>만 전역 객체 window를 통해서 접근할 수 있게 되었다.</p>\n<p>이런 방식을 사용하여 전역 객체 window에 들어 있는 전역 변수들을 많이 줄일 수 있었고 따라서 충돌 위험도 줄일 수 있었다. 하지만 여전히 <code>index.html</code>의 script 태그에 모든 파일을 포함시켜야 했다. 또한 불편함을 좀 줄였을 뿐 모듈 시스템이 없다는 근본적인 문제가 해결된 것은 아니었다.</p>\n<h2>2.2. commonJS의 등장</h2>\n<p>시간이 지나면서 JS로 작성되는 스크립트의 크기는 점점 커졌고 모듈화의 필요성도 덩달아 커졌다.</p>\n<p>그리고 브라우저 외의 다른 환경에서 JS를 사용하려는 시도도 많아졌던 것도 모듈화의 필요성을 키웠다. <a href=\"https://www.blueskyonmars.com/2009/01/29/what-server-side-javascript-needs/\">당시 브라우저에서 요구되는 것보다 서버단에서 JS를 사용하려고 할 때 모듈화의 필요성이 더 컸기 때문이다. commonJS의 이름까지도 원래는 serverJS였다!</a></p>\n<p>이런 상황을 해결하기 위해 다양한 라이브러리가 등장했고 Mozilla의 Kevin Dangoor가 만든 commonJS도 그 중 하나였다. 비슷한 목적의 다른 라이브러리로 AMD(Asynchronous Module Definition) 등이 있었다.</p>\n<p>아무튼 commonJS는 각 파일에 module객체를 만들고 module.exports에 내보낼 객체를 할당하면 다른 파일에서 require를 통해서 불러오는 방식으로 모듈 시스템을 구현했다.</p>\n<pre><code class=\"language-js\">// 객체 하나 내보내기\nmodule.exports={\n  name:\"김성현\",\n  age:26\n}\n\n// 객체 가져오기\nconst obj=require(\"./obj\");\n</code></pre>\n<p>NodeJS도 이런 commonJS 기반의 모듈화 시스템을 통해서 만들어졌다. 이외에도 Flusspferd, GPSEE, Narwhal, Persevere, RingoJS, Sproutcore, v8cgi와 같은 commonJS 기반의 서버사이드 JS 런타임이 나왔었다.</p>\n<p>그리고 NodeJS가 사실상의 서버사이드 JS 표준이 되면서 commonJS 표준을 업데이트할 필요성은 적어졌다. 사실상 쓰이고 있는 런타임이 Node 하나뿐이어서 거기서 commonJS를 쓰는 방식이 바로 표준이 되었기 때문이다.</p>\n<h2>2.3. 문제점</h2>\n<p>하지만 이렇게 commonJS는 사실상의 표준이 되는 정도의 성공을 거두었음에도 문제점들이 있었다. 먼저 require의 모듈 로딩은 동기적으로 작동하여 성능 문제가 있었다.</p>\n<p>서버사이드에서는 모든 파일이 로컬 디스크에 있어서 필요할 때 바로 불러올 수 있어서 그나마 괜찮았지만 브라우저에서는 필요한 모듈을 모듈 파일이 있는 어딘가에서 모두 내려받을 때까지 아무것도 할 수 없었던 것이다!</p>\n<p>여담이지만 commonJS는 서버 모듈을 비동기적으로 클라이언트에 전송할 수 있는 모듈 전송 포맷을 추가적으로 정의하여 서버사이드 모듈을 비동기적으로 불러올 수 있게 하기는 했다. <a href=\"https://wiki.commonjs.org/wiki/Modules/Transport\">이 포맷은 commonJS 위키에서 더 자세히 볼 수 있다.</a></p>\n<p>또한 require의 작동 방식으로 인해 사용되지 않는 모듈을 제거하여 번들 사이즈를 줄이는 트리쉐이킹을 할 수 없었다. 그리고 브라우저에서 사용하는 것도 어려웠다. NodeJS는 commonJS를 받아들였기 때문에 서버사이드에서는 commonJS를 기본적으로 사용할 수 있었으나 브라우저에서는 아니었다. browser-native가 아니었던 것이다.</p>\n<p>따라서 웹팩과 같은 모듈 번들러를 사용해서 모듈 파일들을 하나로 만든 후 하나의 큰 IIFE를 이용해서 묶어주는 방식으로 commonJS를 사용할 수 있었다. 이런 간편한 번들링 시스템의 등장이 commonJS를 더욱 많이 사용되게 만들기도 했다.</p>\n<p><img src=\"/static/bundler-result-4c2acbc5.png\" alt=\"bundler-result\"></p>\n<p>이런 문제를 개선하기 위해, 그리고 JS 진영에서도 이러한 모듈 시스템을 위한 움직임들을 무시할 수 없었기 때문에 ES6에서 ES Module이 도입되게 된다. 하지만 둘의 호환에 관한 합의는 이루어지지 않았고 그것이 지금 CJS와 ESM이 뒤죽박죽 섞인 이 상황을 만든 것이다.</p>\n<p>아무튼 다시 돌아가서 commonJS와 ES Module의 차이를 더 깊게 알아보자.</p>\n<h1>3. commonJS vs ESM</h1>\n<p>골자는 <a href=\"https://redfin.engineering/node-modules-at-war-why-commonjs-and-es-modules-cant-get-along-9617135eeca1\">CommonJS와 ES 모듈이 함께 갈 수 없는 이유</a>글을 보고 작성하였다.</p>\n<h2>3.1. 차이 - 기본</h2>\n<p>위에 작성한 내용을 토대로 문법적인 차이만 알아보면 다음과 같다.</p>\n<ol>\n<li>require는 commonJS에서 사용하는 문법이고 import는 ES6에서 사용하는 문법이다.</li>\n<li>require는 파일의 어느 부분에나 사용할 수 있지만 import는 파일의 최상단에만 사용할 수 있다.(dynamic import는 제외)</li>\n<li>하나의 파일에서 import와 require를 동시에 사용할 수 없다.</li>\n</ol>\n<p>그리고 일반 스크립트에서의 this가 전역 객체인 것과 달리 모듈에서의 최상위 레벨 this는 <code>undefined</code>이다.</p>\n<pre><code class=\"language-html\">&#x3C;script>\n  alert(this); // 브라우저 환경이라면 window\n&#x3C;/script>\n\n&#x3C;script type=\"module\">\n  alert(this); // undefined\n&#x3C;/script>\n</code></pre>\n<p>내부 구현으로 들어가면 더 많은 차이가 발생한다.</p>\n<h2>3.2. 차이 - 모듈 로드 방식</h2>\n<h3>3.2.1. commonJS</h3>\n<p>commonJS의 <code>require()</code>는 동기적으로 작동한다. 이는 Promise를 리턴하거나 콜백을 호출하지 않고 파일을 읽고 즉시 스크립트를 실행한다. 따라서 스크립트의 입출력이나 다른 사이드 이펙트도 실행하고 <code>module.exports</code>에 설정되어 있는 값을 리턴한다.</p>\n<h3>3.2.2. ESM</h3>\n<p>반면 ESM은 비동기 환경에서 모듈을 로드한다. import된 스크립트를 바로 실행하지 않고 import나 export 호출을 찾기 위해서 스크립트를 파싱한다. 이런 이유로 ESM에서는 종속성이 있는 코드를 실행하지 않고도 named import의 오타를 감지해서 에러를 발생시킬 수 있다.</p>\n<p>그리고 나서 ESM 모듈 로더는 import된 스크립트를 비동기로 다운로드해 파싱하고 또한 해당 스크립트가 import한 스크립트들도 파싱한다. 이런 과정을 더 이상 import할 스크립트가 없을 때까지 반복한다. 그러면서 모듈의 의존성 그래프를 만들어 나간다.</p>\n<p>이 과정이 끝나고 나서야 스크립트는 모듈의 의존성 그래프에 따라 실행된다. 또한 모듈 그래프에서의 형제 스크립트는 병렬적으로 다운로드되고 loader 스펙에 따라서 순서대로 실행된다.</p>\n<h2>3.3. 호환성</h2>\n<p>ESM과 CJS는 그 작동 방식 때문에 서로 호출하는 게 쉽지 않다. 다음과 같은 문제들이 있다.</p>\n<ul>\n<li>CJS에서 ESM 파일을 require로 불러오는 건 불가능하다.</li>\n</ul>\n<p>CJS는 ESM 파일을 <code>require</code>로 불러올 수 없다. 이유는 ESM은 top level await을 지원하지만 cjs에서는 불가능하기 때문이다. <a href=\"https://v8.dev/features/top-level-await\">또한 V8 블로그 글에 의하면 commonJS에서 top level await을 지원할 계획도 없다고 한다.</a></p>\n<p>물론 top level await 때문에만 <code>require(ESM file)</code>이 불가능한 것은 아니다. 동기적으로 동작하는 require로 불러온 ESM 파일에서는 비동기로 파일을 불러올 수 있는데 이렇게 불러온 CJS 파일은 또 동기적으로 파일을 불러올 수 있는 등의 상황에서 순서가 꼬일 수 있는 문제 등이 더 있다.</p>\n<p><a href=\"https://github.com/nodejs/modules/issues/454\">이 깃헙 이슈에 require(ESM)에 대한 더 많은 논의가 있다. 그러나 당분간 ESM 파일을 require로 불러오는 건 힘들어 보인다.</a></p>\n<p>물론 top-level await을 사용하는 ESM 모듈이 얼마나 있다고, 이렇게 완전히 불가능하게 만드는 것은 이상해 보일 수도 있다. 하지만 어떤 문법이 쓰이지 않을 것을 가정하고 무언가를 사용해야 한다는 것은 좋지 않다는 면에서 이런 결정을 나쁘다고만 하기는 힘들 것 같다.</p>\n<ul>\n<li>CJS에서 dynamic import로 ESM 파일을 불러오는 건 가능하긴 하지만 좋지 않다.</li>\n</ul>\n<p>CJS 파일에서 ESM 파일을 동적 import하는 건 가능하다. 즉시 실행 함수를 사용하면 된다.</p>\n<pre><code class=\"language-js\">(async () => {\n  const { default: module } = await import('./module.mjs');\n})();\n</code></pre>\n<p>이는 별로 권장되는 방식은 아니다. 특히 위와 같은 IIFE의 결과를 export해야 할 때 문제다. 이렇게 하면 모듈을 Promise로 내보내게 되는 것인데 이는 동기함수 내부에서 비동기 동작을 하기 힘들다는 점에서 모듈을 사용하기가 불편해지기 때문이다.</p>\n<ul>\n<li>ESM은 CJS 스크립트의 named exports를 제대로 import할 수 없다.</li>\n</ul>\n<p>CJS 스크립트는 실행되면서 named exports를 연산하지만 ESM의 named exports의 경우 스크립트를 파싱하는 단계에서 named exports를 연산하기 때문이다.</p>\n<p>이는 가능하다. CJS 스크립트 전체를 불러오기 때문이다.</p>\n<pre><code class=\"language-js\">import _ from './lodash.cjs';\n</code></pre>\n<p>하지만 다음과 같이 하면 import가 파싱하는 시점에 CJS 스크립트의 named exports를 알 수 없기 때문에 에러가 발생한다.</p>\n<pre><code class=\"language-js\">import { debounce } from './lodash.cjs';\n</code></pre>\n<p>다음과 같이 구조 분해 할당을 통해 우회할 수 있지만 트리쉐이킹이 되지 않으므로 번들 사이즈가 커지는 걸 피할 수 없다.</p>\n<pre><code class=\"language-js\">import _ from './lodash.cjs';\nconst { debounce } = _;\n</code></pre>\n<p>이런 방식으로 ESM 래퍼를 지원하는 라이브러리들도 있다. 하지만 이런 방식은 import 순서를 보장하지는 않기 때문에 문제가 될 수 있다.</p>\n<p>만약 A 라이브러리와 B 라이브러리가 둘 다 CJS 라이브러리이며 위와 같은 우회 방식으로 ESM 래퍼를 지원한다고 하자. 그래서 다음과 같이 import하였다.</p>\n<pre><code class=\"language-js\">import {A1} from 'A';\nimport {B1} from 'B';\n</code></pre>\n<p>하지만 이렇게 하면 비동기로 작동하는 import의 특성상 A1과 B1이 평가되는 순서는 보장되지 않는다. 따라서 B1이 A1에 뭔가 의존하는 경우에는 문제가 발생할 수 있다.</p>\n<ul>\n<li>ESM에서 require를 사용할 수는 있다. 하지만 큰 의미는 없다.</li>\n</ul>\n<p>require는 원래 ESM 스크립트의 문법이 아니지만 <a href=\"https://nodejs.org/api/modules.html#modules_module_createrequire_filename\">사용하는 게 어렵지는 않다.</a> 다음과 같이 작성하면 된다.</p>\n<pre><code class=\"language-js\">import { createRequire } from 'module';\nconst require = createRequire(import.meta.url);\n\nconst {foo} = require('./foo.cjs'); \n</code></pre>\n<p>하지만 이렇게 하는 건 딱히 의미가 없다. 어차피 이렇게 require를 사용해도 트리쉐이킹이 안 되는 건 마찬가지이기 때문에 그냥 위에서 사용한 우회방식을 사용하는 게 낫다.</p>\n<pre><code class=\"language-js\">import cjsModule from './foo.cjs';\nconst {foo} = cjsModule;\n</code></pre>\n<p>그리고 <code>createRequire</code>를 쓸데없이 불러오는 것도 번들 사이즈를 키우는 원인이 된다. 네이티브하게 <code>require</code>를 사용할 수 있는 것도 아닌데, 그냥 위의 우회 방식을 쓰자.</p>\n<h2>3.4. 호환성으로 인한 문제예시</h2>\n<p><a href=\"https://devblog.kakaostyle.com/ko/2022-04-09-1-esm-problem/\">카카오스타일 기술 블로그에도 이런 호환성으로 인해 발생한 문제에 관한 글이 있었다.</a></p>\n<p>해당 글에서 다루는 이슈를 간단히 요약하면 다음과 같다.</p>\n<p>commonJS로 프로젝트를 진행하고 있었는데, commonJS 프로젝트의 ts에서 import를 사용하면 사실 require로 내부적으로 변환된다. 그런데 프로젝트에서 사용하던 <code>chalk</code>라는 라이브러리가 pure ESM으로 변했다.</p>\n<p>따라서 기존의 commonJS 프로젝트에서는 require로 ESM 라이브러리를 불러오는 꼴이 되었고 위에서 다루었던 <code>CJS에서 ESM 파일을 require로 불러오는 건 불가능하다.</code>는 문제가 발생했다.</p>\n<p>따라서 전체 프로젝트를 ESM으로 전환하거나, 위에서 본 것처럼 권장되지는 않지만 dynamic import를 사용하거나 <code>.mjs</code> 확장자를 사용한다는 선택지가 있었다.</p>\n<p>하지만 ts에서는 import를 require로 변환하거나 ESM 프로젝트로 전환해야 했다고 한다. 만약 import를 require로 변환하면 ESM 모듈을 쓸 수가 없고 ESM 프로젝트로 전환하려고 하니 프로젝트 내에 require에 의존하는 곳이 있어 프로젝트 전환은 어려웠다고 한다.</p>\n<p>따라서 ts가 변환하지 않도록 <code>new Function</code>이나 <code>eval</code>로 회피하거나, tsimportlib이라는 라이브러리를 사용할 수 있었다고 한다.</p>\n<h1>4. 패키지 지원</h1>\n<p>그러면 패키지 제작자 측에서는 어떤 선택지가 있을까? 위의 <a href=\"https://devblog.kakaostyle.com/ko/2022-04-09-1-esm-problem/\">ESM 삽질기</a>의 경우 <code>chalk</code> 패키지가 pure ESM으로 변했기 때문에 문제가 발생했다.</p>\n<h2>4.1. ESM만 지원</h2>\n<p>ESM이 미래의 흐름이고 더 좋은 방식이라고 생각하는 패키지 제작자는 ESM만 지원하는 패키지를 만들 수 있다.</p>\n<p>이렇게 했을 때의 문제는 ESM만 지원하는 패키지는 CJS 사용자들에게 매우 큰 불편을 초래할 수 있다는 것이다. CJS 유저들은 <code>require</code>를 사용하는 대신 <code>await import</code>로 동적 임포트를 사용해서 pure ESM 패키지를 불러와야 한다.</p>\n<p>또한 만약 CJS 패키지를 이미 출시한 상태라면 이를 pure ESM 패키지로 바꾸는 건 하위 호환성을 깨뜨리는 것이기 때문에 더욱 문제가 될 수 있다. <a href=\"https://devblog.kakaostyle.com/ko/2022-04-09-1-esm-problem/\">이로 인한 삽질기가 위에도 있었다.</a></p>\n<p>CJS 패키지의 ESM 래퍼를 만드는 건 쉽지만 반대는 어렵다.</p>\n<h2>4.2. CJS만 지원하기</h2>\n<p>TS로 라이브러리를 작성하고 트랜스파일한다면, CJS와 ESM 둘 중 어느 쪽으로든 변환할 수 있다. 따라서 이 둘을 모두 제공할 거라고 생각할 수 있다. 하지만 이는 좋은 방법이 아니다.</p>\n<p>사용자는 실수로 패키지를 import로 불러오고, 또 다른 곳에서는 require로 불러올 수 있다. 이 경우 Node의 모듈 중복 제거가 제대로 작동하지 않을 것이다. Node는 패키지의 CJS파일과 ESM 파일이 같은 내용이라는 것을 알 수 없기 때문이다. 따라서 패키지 모듈 코드는 2번 작동할 것이고 2개의 인스턴스가 생성될 것이다. 이는 여러 버그를 생성할 수 있다.</p>\n<p>따라서 만약 CJS를 지원할 거라면 CJS만 지원하자. 위에서 보았듯 CJS 패키지를 ESM으로 사용하는 건 쉽지만 반대는 정말 어렵기 때문이다.</p>\n<pre><code class=\"language-js\">/* CJS 라이브러리를 ESM으로 사용하기\n트리쉐이킹은 안되지만 어쨌든 복잡한 방식은 아니다 */\nimport _ from './lodash.cjs';\nconst { debounce } = _;\n</code></pre>\n<p>pure ESM 때문에 피를 본 글들만 웹에 셀 수도 없이 많다는 걸 기억하자. 그냥 CJS로 패키지를 만들고, ESM 방식으로 쓸 수 있는지만 테스트하자. import로 불러와 보는 것이다.</p>\n<p>또한 CJS로 작성된 패키지라도 필요하다면 간단한 ESM 래퍼를 제공하는 것도 가능하다.</p>\n<pre><code class=\"language-js\">import someModule from './index.cjs';\nexport const foo = someModule.foo;\n</code></pre>\n<h2>4.3. 둘 다 지원 시도</h2>\n<p><a href=\"https://toss.tech/article/commonjs-esm-exports-field\">CJS와 ESM은 호환되기 힘든 시스템이긴 하지만 어쨌든 패키지에서 둘 다 지원하려는 시도는 많다. 토스 기술블로그의 글을 보고 적는다.</a></p>\n<h3>4.3.1. 이유</h3>\n<p>사실 CJS만 지원해도 간단한 래핑을 통한 ESM 지원 자체는 쉽다. 하지만 래핑을 통해서가 아니라 '정말로' ESM과 CJS 둘 모두의 방식으로 작동하는 라이브러리를 만드는 건 어렵다.</p>\n<blockquote>\n<p>publishing packages that work in esm and cjs is such a nightmare.</p>\n<p>Wes Bos(<a href=\"http://BeginnerJavaScript.com\">http://BeginnerJavaScript.com</a> 운영자)의 트윗</p>\n</blockquote>\n<p>이렇게 굳이 둘을 모두 지원하려고 하는 건 각각의 장점이 있기 때문이다.</p>\n<p>JS는 이제 서버와 클라이언트 양쪽에서 모두 사용되는 언어인데, NodeJS에서는 CJS를 사용하는 일이 많다. 하지만 브라우저 환경에서는 ESM을 쓰는 게 일반적이고 또한 JS 번들의 사이즈를 줄여서 브라우저에서의 성능을 향상시키는 데 도움을 주는 트리쉐이킹을 하는 것도 거의 ESM에서만 가능하다.</p>\n<p>CJS는 require를 동적으로 하는 것에 아무 제약이 없기 때문에 빌드 타임에 정적 분석을 적용하여 트리쉐이킹을 하는 게 어렵기 때문이다.</p>\n<p>반면 ESM은 위에서 살펴보았듯이 dynamic import를 사용하지 않는 한 정적인 구조로 모듈을 불러오기 때문에 정적 분석을 통한 트리쉐이킹이 가능하다.</p>\n<p>이런 각각의 꽤 명확한 장단점이 있기 때문에 둘 다 지원하는 라이브러리를 만드는 것은 꽤 이점이 있는 일이다.</p>\n<h3>4.3.2. 구분</h3>\n<p>그런데 모듈 파일은 그냥 <code>.js</code> 혹은 <code>.ts</code>파일인데 어떻게 CJS 라이브러리인지 ESM 라이브러리인지를 구분할 수 있을까?</p>\n<p><code>package.json</code>의 <code>type</code> 필드를 통해서 구분할 수 있다. <code>type</code>필드의 기본값은 <code>commonjs</code>인데 이때 <code>.js</code>나 <code>.ts</code>파일은 CJS로 해석되고 <code>module</code>이면 ESM으로 해석된다.</p>\n<p>이런 구분을 강제하기 위한 파일 형식도 있다. <code>.cjs</code>나 <code>.cts</code>는 항상 CJS로, <code>.mjs</code>, <code>.mts</code>는 항상 ESM으로 해석된다.</p>\n<h3>4.3.3. 지원방법</h3>\n<p>핵심은 <code>package.json</code>의 <code>exports</code>필드이다. 이를 사용하면 명시된 path 외에서는 모듈을 불러올 수 없게 되고, 실제 파일 시스템 상의 위치와 import 경로를 다르게 지정할 수 있다.</p>\n<pre><code class=\"language-json\">{\n  \"exports\": {\n    \".\": \"./index.js\",\n    /* 이렇게 하면 require(\"/foo\")를 불러왔을 때\n    ./foo.js가 아니라 ./module/foo.js를 불러오게 된다 */\n    \"./foo\": \"./module/foo.js\",\n    \"./bar\": \"./module/bar.js\"\n  }\n}\n</code></pre>\n<p><strong>그리고 같은 import path에 대하여 특정 조건에 따라 다른 모듈을 제공할 수 있다!</strong></p>\n<pre><code class=\"language-json\">{\n  \"exports\": {\n    \".\": {\n      \"require\": \"./cjs/index.cjs\",\n      \"import\": \"./esm/index.mjs\"\n    }\n  }\n}\n</code></pre>\n<p>주의할 점은 <code>exports</code>필드의 모든 경로가 상대경로로 작성되어야 한다는 것이다. 그리고 패키지가 어떤 모듈 시스템을 따르는지에 따라 맞는 확장자를 사용해야 한다.</p>\n<p><code>package.json</code>의 type 필드가 commonjs라면 <code>.js</code>파일은 알아서 CJS로 읽을 것이므로 ESM 패키지 경로에만 <code>.mjs</code>를 사용해 준다. 반면 <code>\"type\":\"module\"</code>이라면 CJS 패키지 경로에 <code>.cjs</code>를 사용해 줘야 한다.</p>\n<pre><code class=\"language-js\">/* for CJS package */\n{\n  \"exports\": {\n    \".\": {\n      \"require\": \"./cjs/index.js\",\n      \"import\": \"./esm/index.mjs\"\n    }\n  }\n}\n\n/* for ESM package */\n{\n  \"exports\": {\n    \".\": {\n      \"require\": \"./cjs/index.cjs\",\n      \"import\": \"./esm/index.js\"\n    }\n  }\n}\n</code></pre>\n<p>만약 모두 <code>.js</code>로만 작성한다면 ESM 모듈을 cjs 로더로 읽는 등의 오류가 발생할 수 있다.</p>\n<h3>4.3.4. for typescript</h3>\n<p>기존의 typescript 환경에서 모듈을 불러올 시에는 파일 시스템에서 패키지 타입 정의를 찾았다.</p>\n<pre><code class=\"language-ts\">// module.d.ts를 탐색\nimport module from 'module';\n</code></pre>\n<p>하지만 이제는 <code>package.json</code>의 exports 필드에서 타입 정의를 탐색한다. 아무튼 이렇게 하면 <code>package.json</code>의 exports 필드에 타입 정의를 추가해 줄 수 있다. 이 또한 CJS와 ESM을 구분해 줘야 할 수 있다.</p>\n<pre><code class=\"language-json\">{\n  \"exports\": {\n    \".\": {\n      \"require\": {\n        \"default\": \"./cjs/index.cjs\",\n        \"types\": \"./cjs/index.d.ts\"\n      },\n      \"import\": {\n        \"default\": \"./esm/index.mjs\",\n        \"types\": \"./esm/index.d.ts\"\n      }\n    }\n  }\n}\n</code></pre>\n<p>단 실제 토스의 라이브러리들을 보면 보통 다음과 같이 exports가 쓰여 있다.(<a href=\"https://github.com/toss/slash/blob/main/packages/common/hangul/package.json\">토스의 @toss/hangul 라이브러리의 package.json</a>의 <code>publishConfig</code>필드 참고)</p>\n<pre><code class=\"language-json\">/* https://github.com/toss/slash/blob/main/packages/common/hangul/package.json */\n\"exports\": {\n  \".\": {\n    \"require\": \"./dist/index.js\",\n    \"import\": \"./esm/index.mjs\",\n    \"types\": \"./dist/index.d.ts\"\n  },\n  \"./package.json\": \"./package.json\"\n},\n</code></pre>\n<p>이는 토스의 라이브러리가 CJS로 제공되기 때문이다. <code>index.d.ts</code>가 CJS로 제공되면 ESM에서도 불러올 수 있기 때문에 위와 같이 CJS와 ESM에 대한 타입 파일을 따로 제공해 주지 않아도 된다.</p>\n<h1>5. 남은 이야기들</h1>\n<h2>5.1. commonJS를 위한 변론</h2>\n<p><img src=\"/static/anakin-meme-b94524d2.jpeg\" alt=\"commonJS를 놓을 수 없다!\"></p>\n<p>commonJS는 아직까지도 끈질기게 남아서 쓰이고 있다. 커다란 이유 중 하나는 <a href=\"https://bun.sh/blog/commonjs-is-not-going-away\">bun의 블로그 글에서 잘 요약하고 있다.</a></p>\n<blockquote>\n<p>npm의 수많은 모듈이 commonJS로 쓰여 있다. 그리고 그들 중 다수가 다음 2가지 조건을 만족한다. 첫째로 더 이상 활발하게 유지보수되지 않는다는 것, 둘째로 기존 프로젝트들에서 대단히 중요하게 쓰이고 있다는 점이다. 모든 패키지가 ESM을 사용하는 날은 절대로 오지 않을 것이다. 따라서 commonJS를 지원하지 않는 런타임이나 프레임워크는 뭔가 크게 놓치고 있는 것이다.</p>\n</blockquote>\n<p>위의 이유는 차세대 JS 런타임이라고 홍보하는 bun에서 commonJS 지원에 많은 노력을 기울이는 이유이기도 하다.</p>\n<p>그런데 commonJS가 더 좋은 점은 정녕 없는 걸까? 있다. CJS에도 어쨌건 변명거리가 있는 것이다...</p>\n<p>첫째로 패키지를 함수 내부에서 레이지 로딩하고 싶을 때 ESM의 경우 dynamic import를 사용해야 하고, 따라서 await을 쓰게 된다. 그러면 async가 된 해당 함수가 Promise를 리턴하게 된다. 이는 약간의 오버헤드를 발생시킬 수 있고 사용 편의성도 떨어뜨린다.</p>\n<p>반면 CJS는 이런 문제가 없다. 원래부터 파일이 require되면 실행되는 방식이기 때문에 조건부 import나 레이지 로딩을 하기 위해 특별한 문법을 쓰지 않아도 된다.</p>\n<pre><code class=\"language-js\">// dynamic import\n\n// for ESM\nasync function func(){\n  const {someModule} = await import('some-module');\n}\n\n// for CJS\nfunction func(){\n  const {someModule} = require('some-module');\n}\n</code></pre>\n<p>그리고 ESM은 초기 로딩이 느리다. 모든 모듈 의존성 그래프를 생성하고 모든 모듈 파일을 파싱하고 나서야 코드가 실행되기 때문이다. 반면 CJS는 require를 만나면 해당 파일을 그때 실행한다. 이는 블로킹 연산이며 <a href=\"https://witch.work/posts/misc/import-and-require#2.3.-%EB%AC%B8%EC%A0%9C%EC%A0%90\">문제점이 되기도 한다.</a> 하지만 서버리스 환경의 cold start에서는 로딩 시간을 현저히 줄여줄 수 있다.</p>\n<p><a href=\"https://bun.sh/blog/commonjs-is-not-going-away#the-case-for-commonjs\">bun에서 꽤 큰 라이브러리인 <code>@babel/core</code>로 테스트해본 결과 CJS가 ESM 로딩보다 약 2.4배 정도 빨랐다고 한다.</a></p>\n<p><img src=\"/static/esm-vs-cjs-benchmark-31103a66.png\" alt=\"벤치마크\"></p>\n<h2>5.2. <code>__filename</code></h2>\n<p>NodeJS 환경에서 <code>type:\"module\"</code>을 지정하여 ESM으로 사용하다 보면 <code>__filename</code>과 <code>__dirname</code> 변수를 바로 사용할 수 없다. 그렇게 하려고 하면 <code>ReferenceError: __filename is not defined</code> 에러가 발생한다.</p>\n<p>다음과 같이 직접 정의해 주어야 한다.</p>\n<pre><code class=\"language-js\">import path from 'path';\nimport { fileURLToPath } from 'url';\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\nconsole.log(__dirname);\n</code></pre>\n<p>그럼 왜 그럴까? commonJS로 모듈을 불러올 때 <a href=\"https://nodejs.org/api/modules.html#the-module-wrapper\">Nodejs에서는 다음과 같은 모듈 래퍼로 모듈 코드를 감싸기 때문이다.</a></p>\n<pre><code class=\"language-js\">(function(exports, require, module, __filename, __dirname) {\n// Module code actually lives in here\n}); \n</code></pre>\n<p>따라서 commonJS 모듈은 위와 같은 모듈 래퍼로 감싸져 있기 때문에 <code>__filename</code>과 <code>__dirname</code>을 바로 사용할 수 있다. 하지만 ESM에서는 위와 같은 동작을 하지 않기 때문에 해당 변수들을 바로 사용할 수 없다.</p>\n<h1>참고</h1>\n<p>require와 import의 차이\n<a href=\"https://inpa.tistory.com/entry/NODE-%F0%9F%93%9A-require-%E2%9A%94%EF%B8%8F-import-CommonJs%EC%99%80-ES6-%EC%B0%A8%EC%9D%B4-1\">https://inpa.tistory.com/entry/NODE-%F0%9F%93%9A-require-%E2%9A%94%EF%B8%8F-import-CommonJs%EC%99%80-ES6-%EC%B0%A8%EC%9D%B4-1</a></p>\n<p>import, export 다루기\n<a href=\"https://inpa.tistory.com/entry/JS-%F0%9F%93%9A-%EB%AA%A8%EB%93%88-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-import-export-%EC%A0%95%EB%A6%AC?category=889099#%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80(HTML)%EC%97%90%EC%84%9C_%EB%AA%A8%EB%93%88_%EC%82%AC%EC%9A%A9_%ED%95%98%EA%B8%B0\">https://inpa.tistory.com/entry/JS-%F0%9F%93%9A-%EB%AA%A8%EB%93%88-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-import-export-%EC%A0%95%EB%A6%AC?category=889099#%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80(HTML)%EC%97%90%EC%84%9C_%EB%AA%A8%EB%93%88_%EC%82%AC%EC%9A%A9_%ED%95%98%EA%B8%B0</a></p>\n<p>export의 MDN 문서\n<a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/export\">https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/export</a></p>\n<p>nodeJS 공식 문서\n<a href=\"https://nodejs.org/ko/docs/guides/getting-started-guide\">https://nodejs.org/ko/docs/guides/getting-started-guide</a></p>\n<p>모듈에 대한 소개 <a href=\"https://ko.javascript.info/modules-intro\">https://ko.javascript.info/modules-intro</a></p>\n<p>CommonJS와 JS 모듈의 역사 <a href=\"https://medium.com/@lisa.berteau.smith/commonjs-and-the-history-of-javascript-modularity-63d8518f103e\">https://medium.com/@lisa.berteau.smith/commonjs-and-the-history-of-javascript-modularity-63d8518f103e</a></p>\n<p>자바스크립트 프레임워크의 네 시대(JS의 초기 시절을 묘사를 위해 참고) <a href=\"https://blog.rhostem.com/posts/2022-05-27-Four-Eras-of-JavaScript-Frameworks\">https://blog.rhostem.com/posts/2022-05-27-Four-Eras-of-JavaScript-Frameworks</a></p>\n<p>IIFE 모듈화 패턴\n<a href=\"https://medium.com/@kadir.yavuz/encapsulation-in-javascript-iife-and-revealing-module-pattern-bebf49ddfa14\">https://medium.com/@kadir.yavuz/encapsulation-in-javascript-iife-and-revealing-module-pattern-bebf49ddfa14</a></p>\n<p>What Server Side JavaScript Needs <a href=\"https://www.blueskyonmars.com/2009/01/29/what-server-side-javascript-needs/\">https://www.blueskyonmars.com/2009/01/29/what-server-side-javascript-needs/</a></p>\n<p>commonJS란 무엇인가? <a href=\"https://yceffort.kr/2023/05/what-is-commonjs\">https://yceffort.kr/2023/05/what-is-commonjs</a></p>\n<p>JS의 모듈화를 위한 움직임, commonJS와 AMD\n<a href=\"https://d2.naver.com/helloworld/12864\">https://d2.naver.com/helloworld/12864</a></p>\n<p>ESM 삽질기 <a href=\"https://devblog.kakaostyle.com/ko/2022-04-09-1-esm-problem/\">https://devblog.kakaostyle.com/ko/2022-04-09-1-esm-problem/</a></p>\n<p>bun에서 commonJS를 지원하는 이유 <a href=\"https://bun.sh/blog/commonjs-is-not-going-away\">https://bun.sh/blog/commonjs-is-not-going-away</a></p>\n<p>왜 commonJS와 ESM은 함께할 수 없는가? <a href=\"https://redfin.engineering/node-modules-at-war-why-commonjs-and-es-modules-cant-get-along-9617135eeca1\">https://redfin.engineering/node-modules-at-war-why-commonjs-and-es-modules-cant-get-along-9617135eeca1</a></p>\n<p>왜 commonJS와 ESM은 함께할 수 없는가?(바로 위 링크) 의 번역 <a href=\"https://roseline.oopy.io/dev/translation-why-cjs-and-esm-cannot-get-along\">https://roseline.oopy.io/dev/translation-why-cjs-and-esm-cannot-get-along</a></p>\n<p>ESM과 CJS의 차이 <a href=\"https://yceffort.kr/2023/05/what-is-commonjs\">https://yceffort.kr/2023/05/what-is-commonjs</a></p>\n<p>라이브러리의 pure ESM 변경으로 인한 삽질기\n<a href=\"https://devblog.kakaostyle.com/ko/2022-04-09-1-esm-problem/\">https://devblog.kakaostyle.com/ko/2022-04-09-1-esm-problem/</a></p>\n<p>두 가지 모듈 시스템을 지원하는 라이브러리 개발하기 <a href=\"https://toss.tech/article/commonjs-esm-exports-field\">https://toss.tech/article/commonjs-esm-exports-field</a></p>",
    "excerpt": "0. 시작\nJS의 모듈에 관한 키워드인 import와 require의 차이는 유명한 프론트 면접 질문 중 하나다. 하지만 나는 이에 대해서 잘 알지 못했다. require가 commonJS에서 쓰이는 문법이고 import가 ES6부터 도입되었다는 정도만 들어서 알고 있었다.\n그래서 이참에 예전에 들어 보기만 하고 묻어 두었던 관련 글들을 꺼내서 읽어보고 정리했다. 차근차근 깊이 들어가는 글이 되려고 노력하였다.\n1. 기초적인 차이\n먼저 각자의 문법과 기본적인 차",
    "headingTree": [
      {
        "title": "0. 시작",
        "url": "#0-시작",
        "items": []
      },
      {
        "title": "1. 기초적인 차이",
        "url": "#1-기초적인-차이",
        "items": [
          {
            "title": "1.1. require",
            "url": "#11-require",
            "items": [
              {
                "title": "1.1.1. exports와 module.exports",
                "url": "#111-exports와-moduleexports",
                "items": []
              }
            ]
          },
          {
            "title": "1.2. import",
            "url": "#12-import",
            "items": []
          },
          {
            "title": "1.3. dynamic import",
            "url": "#13-dynamic-import",
            "items": []
          },
          {
            "title": "1.4. 브라우저에서 모듈 사용하기",
            "url": "#14-브라우저에서-모듈-사용하기",
            "items": []
          }
        ]
      },
      {
        "title": "2. 역사 이야기",
        "url": "#2-역사-이야기",
        "items": [
          {
            "title": "2.1. JS 모듈이 없었을 때의 이야기",
            "url": "#21-js-모듈이-없었을-때의-이야기",
            "items": []
          },
          {
            "title": "2.2. commonJS의 등장",
            "url": "#22-commonjs의-등장",
            "items": []
          },
          {
            "title": "2.3. 문제점",
            "url": "#23-문제점",
            "items": []
          }
        ]
      },
      {
        "title": "3. commonJS vs ESM",
        "url": "#3-commonjs-vs-esm",
        "items": [
          {
            "title": "3.1. 차이 - 기본",
            "url": "#31-차이---기본",
            "items": []
          },
          {
            "title": "3.2. 차이 - 모듈 로드 방식",
            "url": "#32-차이---모듈-로드-방식",
            "items": [
              {
                "title": "3.2.1. commonJS",
                "url": "#321-commonjs",
                "items": []
              },
              {
                "title": "3.2.2. ESM",
                "url": "#322-esm",
                "items": []
              }
            ]
          },
          {
            "title": "3.3. 호환성",
            "url": "#33-호환성",
            "items": []
          },
          {
            "title": "3.4. 호환성으로 인한 문제예시",
            "url": "#34-호환성으로-인한-문제예시",
            "items": []
          }
        ]
      },
      {
        "title": "4. 패키지 지원",
        "url": "#4-패키지-지원",
        "items": [
          {
            "title": "4.1. ESM만 지원",
            "url": "#41-esm만-지원",
            "items": []
          },
          {
            "title": "4.2. CJS만 지원하기",
            "url": "#42-cjs만-지원하기",
            "items": []
          },
          {
            "title": "4.3. 둘 다 지원 시도",
            "url": "#43-둘-다-지원-시도",
            "items": [
              {
                "title": "4.3.1. 이유",
                "url": "#431-이유",
                "items": []
              },
              {
                "title": "4.3.2. 구분",
                "url": "#432-구분",
                "items": []
              },
              {
                "title": "4.3.3. 지원방법",
                "url": "#433-지원방법",
                "items": []
              },
              {
                "title": "4.3.4. for typescript",
                "url": "#434-for-typescript",
                "items": []
              }
            ]
          }
        ]
      },
      {
        "title": "5. 남은 이야기들",
        "url": "#5-남은-이야기들",
        "items": [
          {
            "title": "5.1. commonJS를 위한 변론",
            "url": "#51-commonjs를-위한-변론",
            "items": []
          },
          {
            "title": "5.2. __filename",
            "url": "#52-__filename",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 5,
      "wordCount": 1415
    },
    "url": "/posts/import-and-require",
    "thumbnail": {
      "local": "/static/bundler-result-4c2acbc5.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-bundler-result-4c2acbc5-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAADCAIAAAAhqtkfAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAQUlEQVR4nD3JQQ3AMAwDwP6DKAxCIRCKwWDCwWQMwiAyaZp23zv33u6WBIDk7vp1/ujuzCQZEVX1BUkAM2Nbku0HFTkqE1vvhN0AAAAASUVORK5CYII="
    }
  },
  {
    "slug": "html-table-tags",
    "title": "HTML로 표 만들기",
    "date": "2023-03-28T01:00:00Z",
    "description": "MDN HTML 테이블 튜토리얼, 표 만들기",
    "tags": [
      "web",
      "study",
      "front",
      "HTML"
    ],
    "html": "<p>HTML의 <code>&#x3C;table></code>태그와 그에 연관된 태그들을 이용해서 표를 만드는 것에 관해서 다룬다. HTML에는 표 형식 데이터를 다루기 위한 태그들이 존재한다.</p>\n<p>해당 내용을 다룬 MDN 튜토리얼들을 읽고 정리하였다. <a href=\"https://developer.mozilla.org/ko/docs/Learn/HTML/Tables\">https://developer.mozilla.org/ko/docs/Learn/HTML/Tables</a></p>\n<h1>1. HTML 테이블 기본</h1>\n<p>표는 많은 데이터를 쉽게 보고 분석할 수 있게 한다. 이렇게 표를 효과적으로 만드는 데는 적절한 CSS 스타일링도 한몫 하지만 이는 후에 CSS를 배울 때 할 것이고 여기서는 HTML 테이블의 기본적인 구조에 대해서만 다룬다.</p>\n<h2>1.1. 주의할 점</h2>\n<p>HTML 테이블은 표 형태의 데이터를 보여주는 데 써야 한다. 페이지 레이아웃을 잡는 데에 써서는 안 된다. 예를 들어서 한 행은 헤더, 한 행은 페이지 컨텐츠, 한 행은 푸터를 넣는 식으로, 페이지 레이아웃 용도로 HTML 테이블 태그를 쓰면 안 되는 것이다.</p>\n<p>이는 브라우저들의 CSS 지원이 안 좋을 때 많이 쓰던 방식이라 지금도 몇몇 낡은 사이트에서 보이곤 한다. 하지만 지금은 CSS 레이아웃(flex, grid 등)을 쓰는 게 훨씬 편하다.</p>\n<p>게다가 테이블 태그를 이용해 페이지 레이아웃을 구성하면, 테이블 태그는 레이아웃을 위해서 만들어진 게 아니기 때문에 여러 단점들이 있다. 스크린 리더 사용자들에게 혼란을 줄 수 있고 코드의 유지보수도 힘들다.</p>\n<p>그리고 header, section 등의 레이아웃 태그들은 부모 요소에 의해서 너비가 잘 정의된다. 하지만 테이블 태그들은 기본적으로 그 내용에 의해서 너비가 결정된다.</p>\n<p>따라서 테이블 태그를 이용해 페이지 레이아웃을 구성하면, 브라우저의 크기에 따라서 레이아웃이 깨질 수 있고 다양한 장치에서 잘 작동하도록 하기 위해서는 따로 처리가 필요하다.</p>\n<h2>1.2. 표 만들어보기</h2>\n<p>먼저 MDN에서 제공하는 기본적인 템플릿을 가져오자. <a href=\"https://github.com/mdn/learning-area/blob/main/html/tables/basic/blank-template.html\">HTML 템플릿</a>과 <a href=\"https://github.com/mdn/learning-area/blob/main/html/tables/basic/minimal-table.css\">CSS 템플릿</a>이 제공된다. CSS를 아직 배우지는 않았지만 표의 가독성을 높이기 위한 기본적인 처리가 되어있다.</p>\n<p>표의 모든 내용은 table 태그로 감싸여있다. 그리고 표의 가장 작은 컨테이너는 table cell인데 이는 table data를 뜻하는 td 태그로 감싸져있다. 권장되지는 않지만 <code>table</code>태그 내부에 <code>table</code>태그를 또 넣어서 nested table을 만드는 것도 가능하다.</p>\n<pre><code class=\"language-html\">&#x3C;table>\n  &#x3C;td>첫번째 셀&#x3C;/td>\n  &#x3C;td>두번째 셀&#x3C;/td>\n  &#x3C;td>세번째 셀&#x3C;/td>\n  &#x3C;td>네번째 셀&#x3C;/td>\n&#x3C;/table>\n</code></pre>\n<p>이렇게 표를 만들고 페이지를 띄워 보면 td 셀들이 하나의 칸을 이루는데 이들이 모두 같은 행에 배치된 것을 볼 수 있다. td태그는 더해질 때마다 이전 td 태그와 같은 행에 배치된다.</p>\n<p>이를 해결하기 위해서는 tr 태그를 사용해야 한다. tr 태그는 table row를 뜻하며, 이는 표의 한 행을 묶어주는 역할을 한다.</p>\n<pre><code class=\"language-html\">&#x3C;table>\n  &#x3C;tr>\n    &#x3C;td>첫번째 셀&#x3C;/td>\n    &#x3C;td>두번째 셀&#x3C;/td>\n  &#x3C;/tr>\n  &#x3C;tr>\n    &#x3C;td>첫번째 셀&#x3C;/td>\n    &#x3C;td>두번째 셀&#x3C;/td>\n  &#x3C;/tr>\n&#x3C;/table>\n</code></pre>\n<p>이때 만약 행마다 포함된 td의 개수가 다르다면 가장 긴 행의 길이에 맞춰진다.</p>\n<h2>1.3. 헤더 추가하기</h2>\n<p>표에는 보통 헤더가 필요하다. 행이나 열의 첫 칸에서 데이터가 무엇에 대한 것인지 정의해 주는 것이다.</p>\n<p>이 헤더를 위한 셀은 th 태그를 사용한다. th 태그는 당연히 table header를 뜻한다. 이는 td 태그와 똑같이 작동하지만 의미상으로 헤더를 뜻한다. 따라서 헤더까지 잘 달아서 다음과 같이 표를 만들 수 있다.</p>\n<pre><code class=\"language-html\">&#x3C;table>\n  &#x3C;tr>\n    &#x3C;th>이름&#x3C;/th>\n    &#x3C;th>닉네임&#x3C;/th>\n  &#x3C;/tr>\n  &#x3C;tr>\n    &#x3C;td>김성현&#x3C;/td>\n    &#x3C;td>마녀&#x3C;/td>\n  &#x3C;/tr>\n&#x3C;/table>\n</code></pre>\n<p>이렇게 하면 아까 가져온 CSS 템플릿에 th태그 스타일링도 있으므로 헤더가 회색 배경으로 표시된다. 그리고 헤더는 기본적으로 구분을 위해서 가운데 정렬과 굵은 글씨 스타일링이 되어 있다.</p>\n<p><img src=\"/static/table-header-4da99809.png\" alt=\"header\"></p>\n<p>이렇게 테이블 헤더를 쓰면 헤더가 있는 행이나 열을 하나의 묶음을 이루는 것처럼 인식되기 때문에 스크린 리더 사용자에게도 도움이 된다.</p>\n<h2>1.4. 표의 행과 열 합치기</h2>\n<p>하나의 칸이 여러 행 혹은 열을 차지하도록 하고 싶을 수 있다. 그러면 th, td 태그의 colspan, rowspan 속성을 사용하면 된다. 각각 몇 행을 차지할지, 몇 열을 차지할지를 정의해주면 된다. 당연히 기본은 1이다.</p>\n<pre><code class=\"language-html\">&#x3C;table>\n  &#x3C;tr>\n    &#x3C;th>첫번째 열&#x3C;/th>\n    &#x3C;th>두번째 열&#x3C;/th>\n    &#x3C;th colspan=\"2\">두칸짜리 열&#x3C;/th>\n    &#x3C;th>네번째 열&#x3C;/th>\n  &#x3C;/tr>\n  &#x3C;tr>\n    &#x3C;td>1&#x3C;/td>\n    &#x3C;td>2&#x3C;/td>\n    &#x3C;td>3&#x3C;/td>\n    &#x3C;td>4&#x3C;/td>\n    &#x3C;td>5&#x3C;/td>\n  &#x3C;/tr>\n&#x3C;/table>\n</code></pre>\n<h2>1.5. 열 전체를 스타일링하기</h2>\n<p>표는 그 특성상 하나의 열을 강조하고 싶은 등, 열 전체를 스타일링해야 할 때가 많다. 이때 colgroup, col 태그를 사용할 수 있다.</p>\n<p>colgroup 태그는 table의 여는 태그 바로 다음에 와서 열 전체를 묶어주는 역할을 한다. 이를 이용해서 열 전체를 스타일링할 수 있다.</p>\n<pre><code class=\"language-html\">&#x3C;table>\n  &#x3C;colgroup>\n    &#x3C;col style=\"background-color: aqua\" />\n    &#x3C;col />\n    &#x3C;col />\n    &#x3C;col style=\"background-color: aqua\" />\n  &#x3C;/colgroup>\n  &#x3C;tr>\n    &#x3C;th>첫번째 열&#x3C;/th>\n    &#x3C;th>두번째 열&#x3C;/th>\n    &#x3C;th colspan=\"2\">두칸짜리 열&#x3C;/th>\n    &#x3C;th>네번째 열&#x3C;/th>\n  &#x3C;/tr>\n  &#x3C;tr>\n    &#x3C;td>1&#x3C;/td>\n    &#x3C;td>2&#x3C;/td>\n    &#x3C;td>3&#x3C;/td>\n    &#x3C;td>4&#x3C;/td>\n    &#x3C;td>5&#x3C;/td>\n  &#x3C;/tr>\n&#x3C;/table>\n</code></pre>\n<p>이때 어떤 열에는 스타일링을 하지 않고 다음 열에 스타일링하고 싶다면, 스타일링하고 싶지 않은 열에 대응되는 빈 col 태그도 넣어 주어야 한다. 위 예시에서는 1,4번째 열에만 스타일링이 적용된다.</p>\n<p>그리고 span 속성을 사용하면 여러 열을 한 번에 스타일링할 수도 있다.</p>\n<h1>2. HTML 테이블 고급</h1>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Learn/HTML/Tables/Advanced\">MDN의 HTML 테이블 고급</a>을 참고하였습니다.</p>\n<p>캡션과 표 요약, 행 그룹핑하기, 표의 body/footer 만들기, 표의 접근성 등을 배운다.</p>\n<h2>2.1. 캡션 달기</h2>\n<p>table의 여는 태그 바로 다음에 caption 태그를 넣어서 표에 갭션을 달 수 있다. 꼭 <code>&#x3C;table></code> 바로 다음에 넣어야 한다.</p>\n<p>이는 표에 대한 설명을 삽입하는 것이다. 독자에게 표의 용도를 빠르게 인식시킬 수 있으며 스크린 리더 사용자에게도 도움이 된다.</p>\n<pre><code class=\"language-html\">&#x3C;table>\n  &#x3C;caption>\n    예시 표입니다.\n  &#x3C;/caption>\n  &#x3C;tr>\n    &#x3C;th>첫번째 분류&#x3C;/th>\n    &#x3C;th>두번째 분류&#x3C;/th>\n  &#x3C;/tr>\n  &#x3C;tr>\n    &#x3C;td>첫째 데이터&#x3C;/td>\n    &#x3C;td>첫째 데이터-2&#x3C;/td>\n  &#x3C;/tr>\n  &#x3C;tr>\n    &#x3C;td>둘째 데이터&#x3C;/td>\n    &#x3C;td>둘째 데이터-2&#x3C;/td>\n  &#x3C;/tr>\n&#x3C;/table>\n</code></pre>\n<p>이러면 다음과 같이 표 위에 제목처럼 캡션이 표시된다.</p>\n<p><img src=\"/static/table-caption-996057a3.png\" alt=\"caption\"></p>\n<p>스크린 리더 사용자를 돕기 위해 table에서는 summary 속성을 제공하기는 한다. 이 또한 스크린 리더에 읽힌다. 그러나 이 속성은 deprecated되었고 일반 사용자에게 보이지 않는다. 이런 이유로 caption 태그를 사용하는 것이 낫다.</p>\n<h2>2.2. 표 구조 고급</h2>\n<p>표가 더 복잡한 구조를 가지고 있다면 표의 헤더, 바디, 푸터를 구분하는 것도 좋다. 이를 위해서 thead, tbody, tfoot 태그를 사용할 수 있다.</p>\n<p>이는 접근성을 높이거나 사용자의 가독성을 더 좋게 해주지는 않는다. 하지만 표의 레이아웃을 잡고 스타일링을 하는 데에 도움이 된다. 예를 들어서 스크롤할 때 헤더와 푸터는 그대로 두고 body만 스크롤되게 한다거나.</p>\n<h3>2.2.1. thead</h3>\n<p>thead는 표의 헤더 부분을 묶어준다. 이는 일반적으로 첫 행을 뜻하는데 무조건 그런 것은 아니다. 그리고 table의 여는 태그 바로 다음에 오는 것이 보통이지만 만약 colgroup/col 태그를 쓰고 있다면 colgroup 태그 바로 다음에 와야 한다.</p>\n<pre><code class=\"language-html\">&#x3C;table>\n  &#x3C;colgroup>\n    &#x3C;col />\n    &#x3C;col style=\"background-color: aqua\" />\n  &#x3C;/colgroup>\n  &#x3C;thead>\n    &#x3C;tr>\n      &#x3C;th>첫번째 분류&#x3C;/th>\n      &#x3C;th>두번째 분류&#x3C;/th>\n    &#x3C;/tr>\n  &#x3C;/thead>\n  &#x3C;tbody>\n    &#x3C;tr>\n      &#x3C;td>첫째 데이터&#x3C;/td>\n      &#x3C;td>첫째 데이터-2&#x3C;/td>\n    &#x3C;/tr>\n    &#x3C;tr>\n      &#x3C;td>둘째 데이터&#x3C;/td>\n      &#x3C;td>둘째 데이터-2&#x3C;/td>\n    &#x3C;/tr>\n  &#x3C;/tbody>\n&#x3C;/table>\n</code></pre>\n<h3>2.2.2. tbody</h3>\n<p>tbody는 표의 바디 부분을 묶어준다. 표의 헤더와 푸터를 제외한 나머지 부분을 일컫는다. 헤더 다음에 오거나, 사용자가 구조화하는 방식에 따라서 푸터 다음에 body가 올 수도 있다.</p>\n<h3>2.2.3. tfoot</h3>\n<p>tfoot는 표의 푸터 부분을 묶어준다. 이는 이전 행들의 합계를 나타내는 등의 역할을 하는 마지막 행, 등이 될 수 있다.</p>\n<p>일반적으로 table 태그의 마지막에 넣지만 table header 바로 아래에 넣을 수도 있다. 그렇게 해도 브라우저가 알아서 표의 최하단에 tfoot을 렌더링할 것이다.</p>\n<pre><code class=\"language-html\">&#x3C;table>\n  &#x3C;colgroup>\n    &#x3C;col />\n    &#x3C;col />\n  &#x3C;/colgroup>\n  &#x3C;thead>\n    &#x3C;tr>\n      &#x3C;th>첫번째 분류&#x3C;/th>\n      &#x3C;th>두번째 분류&#x3C;/th>\n    &#x3C;/tr>\n  &#x3C;/thead>\n  &#x3C;tfoot>\n    &#x3C;tr>\n      &#x3C;td>첫번째 합계&#x3C;/td>\n      &#x3C;td>두번째 합계&#x3C;/td>\n    &#x3C;/tr>\n  &#x3C;/tfoot>\n\n  &#x3C;tbody>\n    &#x3C;tr>\n      &#x3C;td>첫째 데이터&#x3C;/td>\n      &#x3C;td>첫째 데이터-2&#x3C;/td>\n    &#x3C;/tr>\n    &#x3C;tr>\n      &#x3C;td>둘째 데이터&#x3C;/td>\n      &#x3C;td>둘째 데이터-2&#x3C;/td>\n    &#x3C;/tr>\n  &#x3C;/tbody>\n&#x3C;/table>\n</code></pre>\n<p>위와 같이 헤더와 푸터를 tbody보다 먼저 넣어도 header->body->footer 순으로 렌더링된다.</p>\n<p><img src=\"/static/table-structure-75afb475.png\" alt=\"structure\"></p>\n<p>이때 tbody는 모든 표에 기본적으로 들어가 있다. 만약 명시적으로 입력하지 않더라도 모든 표에는 tbody가 들어간다.</p>\n<p>tbody가 포함되지 않은 표를 만들고 브라우저에 띄운 후 개발자 도구를 열어서 보면 다음과 같이 tbody가 자동으로 생성된 것을 볼 수 있다.</p>\n<pre><code class=\"language-html\">&#x3C;table>\n  &#x3C;td>데이터 1&#x3C;/td>\n  &#x3C;td>데이터 2&#x3C;/td>\n&#x3C;/table>\n</code></pre>\n<p>개발자 도구에서 위 표를 보면 다음과 같다.</p>\n<p><img src=\"/static/table-tbody-88b2d886.png\" alt=\"tbody\"></p>\n<h2>2.3. 접근성</h2>\n<p>스크린 리더 사용자들은 우리가 하는 것처럼 표를 보고 한눈에 이해하기 힘들다. 스크린 리더가 표를 읽기 때문이다.</p>\n<p>따라서 스크린 리터 사용자들을 위해 표를 잘 구조화해야 한다. 스크린 리더는 헤더들을 모두 인식하고 그 헤더와 연관된 셀들을 연관짓는다. 그래서 셀들이 어떤 헤더와 연관되어 있는지를 인식하고 데이터를 읽어주는 것이다.</p>\n<p>여기에 th태그에 있는 scope 속성이 쓰일 수 있다. scope 속성은 헤더가 어떤 셀과 연관되어 있는지를 알려준다. 헤더가 행과 연관되어 있는가, 아니면 열과 연관되어 있는가 하는 것이다.</p>\n<p>scope는 다음과 같은 값들을 가진다.</p>\n<ul>\n<li>row: 헤더가 행과 연관되어 있다.</li>\n<li>col: 헤더가 열과 연관되어 있다.</li>\n<li>rowgroup: 헤더가 행 그룹과 연관되어 있다.</li>\n<li>colgroup: 헤더가 열 그룹과 연관되어 있다.</li>\n</ul>\n<p>rowgroup, colgroup 같은 경우는 표가 복잡해지면서 헤더가 여러 행이나 열에 걸쳐있는 경우에 사용된다.</p>\n<pre><code class=\"language-html\">&#x3C;table>\n  &#x3C;tr>\n    &#x3C;th colspan=\"2\" scope=\"colgroup\">헤더 1&#x3C;/th>\n    &#x3C;th colspan=\"2\" scope=\"colgroup\">헤더 2&#x3C;/th>\n  &#x3C;/tr>\n  &#x3C;tr>\n    &#x3C;th scope=\"col\">헤더 1-1&#x3C;/th>\n    &#x3C;th scope=\"col\">헤더 1-2&#x3C;/th>\n    &#x3C;th scope=\"col\">헤더 2-1&#x3C;/th>\n    &#x3C;th scope=\"col\">헤더 2-2&#x3C;/th>\n  &#x3C;/tr>\n  &#x3C;tr>\n    &#x3C;td>내용 1-1&#x3C;/td>\n    &#x3C;td>내용 1-2&#x3C;/td>\n    &#x3C;td>내용 2-1&#x3C;/td>\n    &#x3C;td>내용 2-2&#x3C;/td>\n  &#x3C;/tr>\n&#x3C;/table>\n</code></pre>\n<h2>2.4. id와 헤더</h2>\n<p>scope 속성을 쓰는 것의 대체재로 id와 headers 속성을 쓸 수도 있다. th 태그에 id를 주고, td 태그에 headers 속성을 주면 된다. header 속성에는 그 셀의 헤더 역할을 할 모든 th 태그의 id를 공백으로 구분해 적어주면 된다.</p>\n<pre><code class=\"language-html\">&#x3C;table>\n  &#x3C;tr>\n    &#x3C;th colspan=\"2\" id=\"first-header\">헤더 1&#x3C;/th>\n    &#x3C;th colspan=\"2\" id=\"second-header\">헤더 2&#x3C;/th>\n  &#x3C;/tr>\n  &#x3C;tr>\n    &#x3C;th id=\"subheader1\">헤더 1-1&#x3C;/th>\n    &#x3C;th id=\"subheader2\">헤더 1-2&#x3C;/th>\n    &#x3C;th id=\"subheader3\">헤더 2-1&#x3C;/th>\n    &#x3C;th id=\"subheader4\">헤더 2-2&#x3C;/th>\n  &#x3C;/tr>\n  &#x3C;tr>\n    &#x3C;td headers=\"first-header subheader1\">내용 1-1&#x3C;/td>\n    &#x3C;td headers=\"first-header subheader2\">내용 1-2&#x3C;/td>\n    &#x3C;td headers=\"second-header subheader3\">내용 2-1&#x3C;/td>\n    &#x3C;td headers=\"second-header subheader4\">내용 2-2&#x3C;/td>\n  &#x3C;/tr>\n&#x3C;/table>\n</code></pre>\n<p>이렇게 하면 헤더와 데이터간의 더 엄밀한 연관을 지을 수 있지만 더 복잡하고 에러에 대한 여유가 없다. 대부분의 표에서는 scope 속성 사용으로 충분하다.</p>\n<h1>3. 표 만들기 실습</h1>\n<p>MDN에서는 태양계의 행성 정보들로 표를 만들어 보는 예제를 제공한다.</p>\n<p>먼저 <a href=\"https://github.com/mdn/learning-area/blob/main/html/tables/assessment-start/blank-template.html\">HTML 템플릿</a>, <a href=\"https://github.com/mdn/learning-area/blob/main/html/tables/assessment-start/minimal-table.css\">CSS 템플릿</a>을 복사해서 작업중인 디렉토리에 붙여넣는다. 그리고 <a href=\"https://github.com/mdn/learning-area/blob/main/html/tables/assessment-start/planets-data.txt\">행성 데이터</a>를 가져온다.</p>\n<p>행성 데이터를 정리한 표를 만들어 보자.</p>\n<h2>3.1. 표 구조 만들기</h2>\n<p>표의 헤더와 body를 만들고 캡션을 달자.</p>\n<pre><code class=\"language-html\">&#x3C;table>\n  &#x3C;caption>\n    Data about the planets of our solar system\n  &#x3C;/caption>\n  &#x3C;thead>&#x3C;/thead>\n  &#x3C;tbody>&#x3C;/tbody>\n&#x3C;/table>\n</code></pre>\n<p>그리고 적절한 column 헤더들을 달자. thead에 넣으면 좋겠다. 또한 행들의 header도 달아주자. 이때 예시 표와 같도록 span을 조절해 주는 것을 잘 해주자.</p>\n<pre><code class=\"language-html\">&#x3C;table>\n  &#x3C;caption>\n    Data about the planets of our solar system\n  &#x3C;/caption>\n  &#x3C;thead>\n    &#x3C;th colspan=\"2\">&#x26;nbsp;&#x3C;/th>\n    &#x3C;th>Name&#x3C;/th>\n    &#x3C;th>Mass (10&#x3C;sup>24&#x3C;/sup>kg)&#x3C;/th>\n    &#x3C;th>Diameter (km)&#x3C;/th>\n    &#x3C;th>Density (kg/m&#x3C;sup>3&#x3C;/sup>)&#x3C;/th>\n    &#x3C;th>Gravity (m/s&#x3C;sup>2&#x3C;/sup>)&#x3C;/th>\n    &#x3C;th>Length of day (hours)&#x3C;/th>\n    &#x3C;th>Distance from Sun (10&#x3C;sup>6&#x3C;/sup>km)&#x3C;/th>\n    &#x3C;th>Mean temperature (°C)&#x3C;/th>\n    &#x3C;th>Number of moons&#x3C;/th>\n    &#x3C;th>Notes&#x3C;/th>\n  &#x3C;/thead>\n  &#x3C;tbody>\n    &#x3C;tr>\n      &#x3C;th rowspan=\"4\" colspan=\"2\">Terrestrial planets&#x3C;/th>\n      &#x3C;th>Mercury&#x3C;/th>\n    &#x3C;/tr>\n    &#x3C;tr>\n      &#x3C;th>Venus&#x3C;/th>\n    &#x3C;/tr>\n    &#x3C;tr>\n      &#x3C;th>Earth&#x3C;/th>\n    &#x3C;/tr>\n    &#x3C;tr>\n      &#x3C;th>Mars&#x3C;/th>\n    &#x3C;/tr>\n  &#x3C;/tbody>\n  &#x3C;tr>\n    &#x3C;th rowspan=\"4\" colspan=\"1\">Jovian planets&#x3C;/th>\n    &#x3C;th rowspan=\"2\">Gas giants&#x3C;/th>\n    &#x3C;th>Jupiter&#x3C;/th>\n  &#x3C;/tr>\n  &#x3C;tr>\n    &#x3C;th>Saturn&#x3C;/th>\n  &#x3C;/tr>\n  &#x3C;tr>\n    &#x3C;th rowspan=\"2\">Ice giants&#x3C;/th>\n    &#x3C;th>Uranus&#x3C;/th>\n  &#x3C;/tr>\n  &#x3C;tr>\n    &#x3C;th>Neptune&#x3C;/th>\n  &#x3C;/tr>\n  &#x3C;tr>\n    &#x3C;th colspan=\"2\">Dwarf planets&#x3C;/th>\n    &#x3C;th>Pluto&#x3C;/th>\n  &#x3C;/tr>\n&#x3C;/table>\n</code></pre>\n<h2>3.2. 행성 데이터 넣고 표 완성하기</h2>\n<p>raw data들을 이제 맞는 위치에 하나씩 넣어주자. raw data가 행성별로 잘 분류되어 있으므로 넣기만 하면 된다.</p>\n<p>그리고 table header들에 scope를 달아주자.</p>\n<pre><code class=\"language-html\">&#x3C;table>\n  &#x3C;caption>\n    Data about the planets of our solar system\n  &#x3C;/caption>\n  &#x3C;thead>\n    &#x3C;th colspan=\"2\">&#x26;nbsp;&#x3C;/th>\n    &#x3C;th scope=\"col\">Name&#x3C;/th>\n    &#x3C;th scope=\"col\">Mass (10&#x3C;sup>24&#x3C;/sup>kg)&#x3C;/th>\n    &#x3C;th scope=\"col\">Diameter (km)&#x3C;/th>\n    &#x3C;th scope=\"col\">Density (kg/m&#x3C;sup>3&#x3C;/sup>)&#x3C;/th>\n    &#x3C;th scope=\"col\">Gravity (m/s&#x3C;sup>2&#x3C;/sup>)&#x3C;/th>\n    &#x3C;th scope=\"col\">Length of day (hours)&#x3C;/th>\n    &#x3C;th scope=\"col\">Distance from Sun (10&#x3C;sup>6&#x3C;/sup>km)&#x3C;/th>\n    &#x3C;th scope=\"col\">Mean temperature (°C)&#x3C;/th>\n    &#x3C;th scope=\"col\">Number of moons&#x3C;/th>\n    &#x3C;th scope=\"col\">Notes&#x3C;/th>\n  &#x3C;/thead>\n  &#x3C;tbody>\n    &#x3C;tr>\n      &#x3C;th rowspan=\"4\" colspan=\"2\" scope=\"rowgroup\">Terrestrial planets&#x3C;/th>\n      &#x3C;th scope=\"row\">Mercury&#x3C;/th>\n      &#x3C;td>0.330&#x3C;/td>\n      &#x3C;td>4,879&#x3C;/td>\n      &#x3C;td>5,427&#x3C;/td>\n      &#x3C;td>3.7&#x3C;/td>\n      &#x3C;td>4222.6&#x3C;/td>\n      &#x3C;td>57.9&#x3C;/td>\n      &#x3C;td>167&#x3C;/td>\n      &#x3C;td>0&#x3C;/td>\n      &#x3C;td>Closest to the Sun&#x3C;/td>\n    &#x3C;/tr>\n    &#x3C;tr>\n      &#x3C;th scope=\"row\">Venus&#x3C;/th>\n      &#x3C;td>4.87&#x3C;/td>\n      &#x3C;td>12,104&#x3C;/td>\n      &#x3C;td>5,243&#x3C;/td>\n      &#x3C;td>8.9&#x3C;/td>\n      &#x3C;td>2802.0&#x3C;/td>\n      &#x3C;td>108.2&#x3C;/td>\n      &#x3C;td>464&#x3C;/td>\n      &#x3C;td>0&#x3C;/td>\n      &#x3C;td>&#x3C;/td>\n    &#x3C;/tr>\n    &#x3C;tr>\n      &#x3C;th scope=\"row\">Earth&#x3C;/th>\n      &#x3C;td>5.97&#x3C;/td>\n      &#x3C;td>12,756&#x3C;/td>\n      &#x3C;td>5,514&#x3C;/td>\n      &#x3C;td>9.8&#x3C;/td>\n      &#x3C;td>24.0&#x3C;/td>\n      &#x3C;td>149.6&#x3C;/td>\n      &#x3C;td>15&#x3C;/td>\n      &#x3C;td>1&#x3C;/td>\n      &#x3C;td>Our world&#x3C;/td>\n    &#x3C;/tr>\n    &#x3C;tr>\n      &#x3C;th scope=\"row\">Mars&#x3C;/th>\n      &#x3C;td>0.642&#x3C;/td>\n      &#x3C;td>6,792&#x3C;/td>\n      &#x3C;td>3,933&#x3C;/td>\n      &#x3C;td>3.7&#x3C;/td>\n      &#x3C;td>24.7&#x3C;/td>\n      &#x3C;td>227.9&#x3C;/td>\n      &#x3C;td>-65&#x3C;/td>\n      &#x3C;td>2&#x3C;/td>\n      &#x3C;td>The red planet&#x3C;/td>\n    &#x3C;/tr>\n    &#x3C;tr>\n      &#x3C;th rowspan=\"4\" colspan=\"1\" scope=\"rowgroup\">Jovian planets&#x3C;/th>\n      &#x3C;th rowspan=\"2\" scope=\"rowgroup\">Gas giants&#x3C;/th>\n      &#x3C;th scope=\"row\">Jupiter&#x3C;/th>\n      &#x3C;td>1898&#x3C;/td>\n      &#x3C;td>142,984&#x3C;/td>\n      &#x3C;td>1,326&#x3C;/td>\n      &#x3C;td>23.1&#x3C;/td>\n      &#x3C;td>9.9&#x3C;/td>\n      &#x3C;td>778.6&#x3C;/td>\n      &#x3C;td>-110&#x3C;/td>\n      &#x3C;td>67&#x3C;/td>\n      &#x3C;td>The largest planet&#x3C;/td>\n    &#x3C;/tr>\n    &#x3C;tr>\n      &#x3C;th scope=\"row\">Saturn&#x3C;/th>\n      &#x3C;td>568&#x3C;/td>\n      &#x3C;td>120,536&#x3C;/td>\n      &#x3C;td>687&#x3C;/td>\n      &#x3C;td>9.0&#x3C;/td>\n      &#x3C;td>10.7&#x3C;/td>\n      &#x3C;td>1433.5&#x3C;/td>\n      &#x3C;td>-140&#x3C;/td>\n      &#x3C;td>62&#x3C;/td>\n      &#x3C;td>&#x3C;/td>\n    &#x3C;/tr>\n    &#x3C;tr>\n      &#x3C;th rowspan=\"2\" scope=\"rowgroup\">Ice giants&#x3C;/th>\n      &#x3C;th scope=\"row\">Uranus&#x3C;/th>\n      &#x3C;td>86.8&#x3C;/td>\n      &#x3C;td>51,118&#x3C;/td>\n      &#x3C;td>1271&#x3C;/td>\n      &#x3C;td>8.7&#x3C;/td>\n      &#x3C;td>17.2&#x3C;/td>\n      &#x3C;td>2872.5&#x3C;/td>\n      &#x3C;td>-195&#x3C;/td>\n      &#x3C;td>27&#x3C;/td>\n      &#x3C;td>&#x3C;/td>\n    &#x3C;/tr>\n    &#x3C;tr>\n      &#x3C;th scope=\"row\">Neptune&#x3C;/th>\n      &#x3C;td>102&#x3C;/td>\n      &#x3C;td>49,528&#x3C;/td>\n      &#x3C;td>1638&#x3C;/td>\n      &#x3C;td>11.0&#x3C;/td>\n      &#x3C;td>16.1&#x3C;/td>\n      &#x3C;td>4495.1&#x3C;/td>\n      &#x3C;td>-200&#x3C;/td>\n      &#x3C;td>14&#x3C;/td>\n      &#x3C;td>&#x3C;/td>\n    &#x3C;/tr>\n    &#x3C;tr>\n      &#x3C;th colspan=\"2\" scope=\"row\">Dwarf planets&#x3C;/th>\n      &#x3C;th scope=\"row\">Pluto&#x3C;/th>\n      &#x3C;td>0.0146&#x3C;/td>\n      &#x3C;td>2,370&#x3C;/td>\n      &#x3C;td>2095&#x3C;/td>\n      &#x3C;td>0.7&#x3C;/td>\n      &#x3C;td>153.3&#x3C;/td>\n      &#x3C;td>5906.4&#x3C;/td>\n      &#x3C;td>-225&#x3C;/td>\n      &#x3C;td>5&#x3C;/td>\n      &#x3C;td>\n        Declassified as a planet in 2006, but this\n        &#x3C;a\n          href=\"http://www.usatoday.com/story/tech/2014/10/02/pluto-planet-solar-system/16578959/\"\n          >remains controversial&#x3C;/a\n        >\n      &#x3C;/td>\n    &#x3C;/tr>\n  &#x3C;/tbody>\n&#x3C;/table>\n</code></pre>\n<p>그리고 행성의 이름들이 들어간 열에 두꺼운 테두리를 달자. 행성 이름이 들어간 열은 3열이므로 3번째 열에만 border를 달아주면 된다. colgroup을 사용하면 된다. table 태그의 바로 다음, caption 태그 바로 전에 다음과 같이 적는다.</p>\n<pre><code class=\"language-html\">&#x3C;colgroup>\n  &#x3C;col />\n  &#x3C;col />\n  &#x3C;col style=\"border: solid 2px\" />\n&#x3C;/colgroup>\n</code></pre>\n<p>이렇게 하면 평가에 있는 table과 같은 테이블이 만들어진다.</p>\n<p><img src=\"/static/table-assessment-c73bfa3d.png\" alt=\"assessment\"></p>",
    "excerpt": "HTML의 <table>태그와 그에 연관된 태그들을 이용해서 표를 만드는 것에 관해서 다룬다. HTML에는 표 형식 데이터를 다루기 위한 태그들이 존재한다.\n해당 내용을 다룬 MDN 튜토리얼들을 읽고 정리하였다. https://developer.mozilla.org/ko/docs/Learn/HTML/Tables\n1. HTML 테이블 기본\n표는 많은 데이터를 쉽게 보고 분석할 수 있게 한다. 이렇게 표를 효과적으로 만드는 데는 적절한 CSS 스타일링도 한몫 하지만",
    "headingTree": [
      {
        "title": "1. HTML 테이블 기본",
        "url": "#1-html-테이블-기본",
        "items": [
          {
            "title": "1.1. 주의할 점",
            "url": "#11-주의할-점",
            "items": []
          },
          {
            "title": "1.2. 표 만들어보기",
            "url": "#12-표-만들어보기",
            "items": []
          },
          {
            "title": "1.3. 헤더 추가하기",
            "url": "#13-헤더-추가하기",
            "items": []
          },
          {
            "title": "1.4. 표의 행과 열 합치기",
            "url": "#14-표의-행과-열-합치기",
            "items": []
          },
          {
            "title": "1.5. 열 전체를 스타일링하기",
            "url": "#15-열-전체를-스타일링하기",
            "items": []
          }
        ]
      },
      {
        "title": "2. HTML 테이블 고급",
        "url": "#2-html-테이블-고급",
        "items": [
          {
            "title": "2.1. 캡션 달기",
            "url": "#21-캡션-달기",
            "items": []
          },
          {
            "title": "2.2. 표 구조 고급",
            "url": "#22-표-구조-고급",
            "items": [
              {
                "title": "2.2.1. thead",
                "url": "#221-thead",
                "items": []
              },
              {
                "title": "2.2.2. tbody",
                "url": "#222-tbody",
                "items": []
              },
              {
                "title": "2.2.3. tfoot",
                "url": "#223-tfoot",
                "items": []
              }
            ]
          },
          {
            "title": "2.3. 접근성",
            "url": "#23-접근성",
            "items": []
          },
          {
            "title": "2.4. id와 헤더",
            "url": "#24-id와-헤더",
            "items": []
          }
        ]
      },
      {
        "title": "3. 표 만들기 실습",
        "url": "#3-표-만들기-실습",
        "items": [
          {
            "title": "3.1. 표 구조 만들기",
            "url": "#31-표-구조-만들기",
            "items": []
          },
          {
            "title": "3.2. 행성 데이터 넣고 표 완성하기",
            "url": "#32-행성-데이터-넣고-표-완성하기",
            "items": []
          }
        ]
      }
    ],
    "metadata": {
      "readingTime": 4,
      "wordCount": 1006
    },
    "url": "/posts/html-table-tags",
    "thumbnail": {
      "local": "/static/table-header-4da99809.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-table-header-4da99809-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAgElEQVR4nDXLIRKEERiAYdEZJAdwDlmWdWfQd0YUdHcQNEEQNEEUvygIX9id+Xf3qe+8JMZorQ0hxBhDCK8HABDnHKVUSqmUEkIwxjjnvXcCAK21vfcYo9Z6znk/SM5Za51Scs4ZY+ac+CBrLe99a633XkoBgN9x70XE+4eI3/AB5fRmZDMpfL8AAAAASUVORK5CYII="
    }
  },
  {
    "slug": "java-1",
    "title": "중간고사 대비 java 1단원 정리",
    "date": "2022-10-16T00:00:00Z",
    "description": "중간고사 대비 JAVA 내용 정리 1단원",
    "tags": [
      "language"
    ],
    "html": "<h1>1. 중간고사 대비</h1>\n<p>이번 학기에 java 언어 수업을 듣는다. 수업에서 배운 java 관련 내용을 벼락치기하면서 블로그에 정리한다. <code>혼자 공부하는 자바</code>책도 참고하였다.</p>\n<h1>2. 자바의 특징</h1>\n<p>자바 프로그램 작성을 위해선 먼저 <code>.java</code> 파일을 작성해야 한다. 이 파일은 javac 명령어를 이용하면 자바 컴파일러에 의해 컴파일되어 <code>.class</code> 파일로 변환된다. 이 class 파일은 바이트코드를 담고 있으며 java 명령어에 의해서 기계어로 번역되어 실행된다.</p>\n<p>이 java 명령어는 자바 가상 머신(JVM)을 실행시키는 명령어이다. JVM의 사용은 바이트코드가 담긴 <code>.class</code>파일을 운영체제에 상관없이 실행할 수 있도록 한다. 이러한 특징을 통해 자바는 운영체제에 독립적이라고 한다.</p>\n<p>즉 자바 코드가 실행되는 과정은 다음과 같다.</p>\n<ol>\n<li><code>.java</code> 파일 작성</li>\n<li><code>javac</code> 명령어로 소스 파일을 바이트코드 파일(<code>.class</code>)로 컴파일</li>\n<li><code>java</code> 명령어로 바이트코드 파일을 실행</li>\n<li>각 운영체제가 제공하는 JVM이 바이트코드를 기계어로 번역하여 실행</li>\n</ol>\n<h1>3. 기본적인 코드 작성하고 실행하기</h1>\n<p>기본적인 코드를 작성하고 실행해 보자. Vscode에서 확장을 설치하여 코드를 실행하였다. <a href=\"https://kangdanne.tistory.com/m/3\">참고한 블로그</a></p>\n<p>src 폴더 내에 적당한 이름의 폴더(study 폴더를 생성했다)를 만든 후 그 안에 <code>Hello.java</code> 파일을 만든다. 그 파일 내에는 폴더 이름의 package와 파일 이름의 class가 선언되어 있다. 즉 다음과 같은 내용이 파일 내에 자동으로 생성된다.</p>\n<pre><code class=\"language-java\">package study;\n\npublic class Hello {\n\n}\n</code></pre>\n<p>이 파일 내에 <code>main</code> 메소드를 만들어 실행해보자. javac 명령어를 이용하여 바이트코드로 컴파일을 한 후 java 명령어를 이용하여 실행하기 위해서는 class 내부에 main 메소드가 있어야 한다. 바이트코드 파일을 실행하면 가장 먼저 main 메소드를 찾아 실행하기 때문이다. 다음 코드는 <code>System.out.println</code> 함수까지 이용하여 메인 함수 내에서 <code>Hello, World!</code>를 출력하는 코드이다.</p>\n<pre><code class=\"language-java\">package study;\n\npublic class Hello {\n  public static void main(String[] args){\n    System.out.println(\"Hello, world!\");\n  }\n}\n</code></pre>\n<p>vscode에서 run 버튼을 누르면 실행할 수 있다.</p>\n<h1>4. 주석</h1>\n<p>주석은 다음과 같은 3가지가 있다. 그리고 어차피 컴파일 과정에서 무시되기 때문에 실제 실행 속도나 바이트코드 파일의 크기에는 아무 영향도 없다.</p>\n<pre><code class=\"language-java\">package study;\n\npublic class Hello {\n  // 한 줄 주석이다. 이 줄의 끝까지 주석으로 처리된다.\n\n  /*\n   * 범위 주석. 이 범위의 모든 줄이 주석으로 처리된다.\n   */\n\n   /**\n    * 문서 주석. 이 주석은 주로 javadoc으로 문서화할 때 사용된다.\n    */\n  public static void main(String[] args){\n    System.out.println(\"Hello, world!\");\n  }\n}\n\n</code></pre>",
    "excerpt": "1. 중간고사 대비\n이번 학기에 java 언어 수업을 듣는다. 수업에서 배운 java 관련 내용을 벼락치기하면서 블로그에 정리한다. 혼자 공부하는 자바책도 참고하였다.\n2. 자바의 특징\n자바 프로그램 작성을 위해선 먼저 .java 파일을 작성해야 한다. 이 파일은 javac 명령어를 이용하면 자바 컴파일러에 의해 컴파일되어 .class 파일로 변환된다. 이 class 파일은 바이트코드를 담고 있으며 java 명령어에 의해서 기계어로 번역되어 실행된다.\n이 jav",
    "headingTree": [
      {
        "title": "1. 중간고사 대비",
        "url": "#1-중간고사-대비",
        "items": []
      },
      {
        "title": "2. 자바의 특징",
        "url": "#2-자바의-특징",
        "items": []
      },
      {
        "title": "3. 기본적인 코드 작성하고 실행하기",
        "url": "#3-기본적인-코드-작성하고-실행하기",
        "items": []
      },
      {
        "title": "4. 주석",
        "url": "#4-주석",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 74
    },
    "url": "/posts/java-1",
    "thumbnail": {
      "local": "/thumbnails/java-1-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-java-1-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAg0lEQVR4nD3LoQ1DIRSFYSSTMAUDoFgAi0Vg0STs0PdCmtSgcXg0DteUJkxAgkPchr60v/3OQUopzrmUUghBKWWMGWMAAFlrMcaUUkJIjDGlVErZEELgnGutc85rLfiFcs7OOe/9nBMA1rcNz1dr7d17H2P85xvO++N2HCGEWuv1uOADC5RoaboJWcQAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "java-2",
    "title": "중간고사 대비 java 2단원 정리",
    "date": "2022-10-16T00:00:00Z",
    "description": "중간고사 대비 JAVA 내용 정리 2단원",
    "tags": [
      "language"
    ],
    "html": "<p>자바 2단원 변수에 관한 내용이다.</p>\n<h1>1. 변수</h1>\n<p>프로그램은 변수를 통해 메모리의 특정 번지에 값을 저장하고 읽을 수 있다. 우리는 변수를 선언하고, 변수에 값을 저장하고, 변수에 저장된 값을 읽어서 사용할 수 있다. 이때 구체적인 메모리를 다루는 부분은 JVM이 담당한다.</p>\n<h2>1.1 변수의 선언과 초기화</h2>\n<p>변수 사용을 위해선 변수를 선언해야 한다. 변수를 선언하는 방법은 다음과 같다. 저장되는 값의 종류와 변수명을 프로그램에 알려 주는 것이다.</p>\n<pre><code class=\"language-java\">[타입] [변수명]\nint age;\n</code></pre>\n<p>이때 자바에서 지역 변수의 경우 초기화 없이는 사용이 불가능하다. 반면 클래스 멤버 변수, static 변수는 초기화가 없어도 타입에 따라 기본값이 대입되는 경우가 있다. 당분간은 메소드 내의 지역 변수만 사용할 것이므로 이 경우 초기화 없이는 사용이 불가능하다.</p>\n<pre><code class=\"language-java\">package study;\n\npublic class Hello {\n  public static void main(String[] args){\n    int x;\n    /* main 내의 지역변수 x는 아직 초기화가 안 되었으므로 아래 코드는 오류가 발생한다.\n    The local variable x may not have been initialized 오류 발생\n    */\n    System.out.println(x);\n  }\n}\n</code></pre>\n<p>값을 대입해서 초기화해준 후에야 사용 가능해진다.</p>\n<pre><code class=\"language-java\">package study;\n\npublic class Hello {\n  public static void main(String[] args){\n    int x;\n    /* x의 값을 초기화한다 */\n    x=1;\n    System.out.println(x);\n  }\n}\n</code></pre>\n<h1>1.2 변수 사용 범위</h1>\n<p>자바의 모든 변수는 중괄호 블럭 내에서 선언되고 사용된다. 이때 메소드 블럭 내에서 선언된 변수를 로컬 변수라고 부른다. 로컬 변수는 선언된 메서드 블럭 내에서만 사용할 수 있다. 블럭을 벗어나면 변수는 소멸된다.</p>\n<p>이런 것은 다른 변수에 대해서도 마찬가지인데 java의 변수는 자신이 선언된 블럭 내에서만 사용할 수 있다. 예를 들어서 다음과 같은 코드는 x가 선언된 블럭 내에서만 사용할 수 있기 때문에 오류가 발생한다.</p>\n<pre><code class=\"language-java\">package study;\n\npublic class Hello {\n  public static void main(String[] args){\n    {int x;}\n    /* 중괄호를 벗어나서는 x에 접근할 수 없기 때문에 오류 */\n    x=1;\n    System.out.println(x);\n  }\n}\n</code></pre>\n<h1>2. 기본 타입</h1>\n<p>자바에서는 기본 타입(primitive type)으로 다음과 같은 타입을 제공한다. 만약 표기할 수 있는 것 이상의 값을 입력하면 컴파일 에러가 된다.</p>\n<ul>\n<li>정수 타입\n<ul>\n<li>byte : 1바이트, -128~127</li>\n<li>char : 2바이트, 0~65535</li>\n<li>short : 2바이트, -32768~32767</li>\n<li>int : 4바이트, -2147483648~2147483647</li>\n<li>long : 8바이트, -9223372036854775808~9223372036854775807</li>\n</ul>\n</li>\n<li>실수 타입\n<ul>\n<li>float : 4바이트, 1.4E-45~3.4028235E38</li>\n<li>double : 8바이트, 4.9E-324~1.7976931348623157E308</li>\n</ul>\n</li>\n<li>논리 타입\n<ul>\n<li>boolean</li>\n</ul>\n</li>\n</ul>\n<h2>2.1 리터럴</h2>\n<h3>2.1.1 정수 리터럴</h3>\n<p>프로그래머에 의해 직접 입력된 값을 리터럴이라고 부른다. 이때 정수는 여러 형태의 입력이 가능하다.</p>\n<p>2진수는 0b, 0B로 시작한다. 예를 들어 <code>0b1010</code>은 10진수로 10을 의미한다. 만약 0b로 시작하는 리터럴인데 0,1이 아닌 다른 숫자가 들어 있을 경우 컴파일 에러이다.</p>\n<p>8진수는 0으로 시작한다. 예를 들어 <code>010</code>은 10진수로 8을 의미한다. 만약 0으로 시작하는 리터럴인데 0~7이 아닌 다른 숫자가 들어 있을 경우 컴파일 에러이다.</p>\n<p>16진수는 0x, 0X로 시작한다. 예를 들어 <code>0x10</code>은 10진수로 16을 의미한다. 만약 0x로 시작하는 리터럴인데 0<del>9, a</del>f, A~F가 아닌 다른 숫자가 들어 있을 경우 컴파일 에러이다.</p>\n<p>10진수는 그냥 숫자를 입력하면 된다. 당연하지만 <code>10</code>은 10진수로 10을 의미한다.</p>\n<p>또한 리터럴에는 언더바(_)를 사용할 수 있다. 이는 가독성을 높이기 위해 사용한다. 예를 들어 <code>1_000_000</code>은 100만을 의미한다.</p>\n<p>이때 주의할 점은, 컴파일러는 정수 리터럴을 기본적으로 int로 인식한다는 것이다. 따라서 int타입 범위를 넘어서는 값의 리터럴을 변수에 대입하려고 하면 변수가 long 형이라도 에러가 발생한다. 만약 long 타입의 리터럴을 입력하고 싶다면 숫자 뒤에 L, l을 붙여야 한다. 예를 들어 <code>10000000000L</code>은 100억을 의미한다.</p>\n<h3>2.1.2 문자 리터럴</h3>\n<p>문자 리터럴은 작은 따옴표(')로 묶어서 표현한다. 예를 들어 <code>'A'</code>는 문자 A를 의미한다. 이때 문자 리터럴은 2바이트의 유니코드로 저장된다. 따라서 문자 리터럴은 0<del>65535(0</del>2^16-1)의 범위를 가진다.</p>\n<p>유니코드는 정수이므로 char도 정수 타입이고 따라서 정수 리터럴을 대입할 수 있다. 예를 들어 65는 <code>'A'</code>를 의미한다. 44032는 <code>'가'</code>를 의미한다.</p>\n<p>이때 문자 리터럴은 유니코드로 변환되기 때문에 다른 정수 타입에도 저장할 수 있다. 물론 변수 타입에 따라 출력값은 다르게 나온다.</p>\n<pre><code class=\"language-java\">package study;\n\npublic class Hello {\n  public static void main(String[] args){\n    int x='가';\n    char y='가';\n    /* x의 값을 초기화한다 */\n    System.out.println(x); //44032 출력\n    System.out.println(y); //가 출력\n  }\n}\n</code></pre>\n<h2>2.2 String type</h2>\n<p>그런데 문자를 저장하는 char 타입으로는 단어 하나도 표현할 수 없다. 문자 하나만 저장할 수 있으니까. 이럴 때 등장하는 게 String 타입이다. 기본 타입은 아니지만 자주 사용하므로 여기서 다룬다. 물론 문자열 타입의 다양한 기능에 대해서는 후에 다루게 될 것이다..타입 소개만 하고 넘어간다.</p>\n<p>String은 문자열을 저장하는 타입이다. 문자열 리터럴은 큰 따옴표(\")로 묶어서 표현한다. 예를 들어 <code>\"Hello\"</code>는 문자열 Hello를 의미한다. 작은따옴표는 문자 리터럴을 표현할 때 사용하는데 헷갈리지 않게 주의하자.</p>\n<pre><code class=\"language-java\">package study;\n\npublic class Hello {\n  public static void main(String[] args){\n    String word=\"저는 마녀입니다.\";\n    System.out.println(word);\n  }\n}\n</code></pre>\n<h2>2.3 실수 타입</h2>\n<p>자바에서는 float, double 2가지의 실수 타입을 제공한다. float은 4바이트, double은 8바이트이다. float은 소수점 7자리까지, double은 소수점 15자리까지 표현할 수 있다. 메모리에 실제로 저장될 때는 IEEE 754 표준에 따라 저장된다. 이 표준에 대해서는 컴퓨터시스템 등의 과목에서 다루게 된다.</p>\n<p>또한 실수 리터럴은 기본적으로 double 타입이다. 따라서 실수 리터럴은 double 타입에 저장해야 한다. float 타입의 실수 리터럴을 사용하고 싶다면 뒤에 f를 붙여서 표현한다. 예를 들어 3.14는 double 타입의 실수 리터럴이고 3.14f는 float 타입의 실수 리터럴이다.</p>\n<p>또는 <code>5e2</code> 처럼 지수와 가수로 표현된 10진수 실수도 사용할 수 있다. 이 경우 5e2는 5 * 10^2 = 500을 의미한다.</p>\n<h2>2.4 논리 타입</h2>\n<p>참, 거짓을 뜻하는 boolean 타입도 자바에서 기본 타입으로 제공한다. 1byte 크기의 메모리를 사용하며 true, false 두 가지 값만 가질 수 있다. boolean 타입의 변수는 주로 if문, while문, for문 등에서 조건식으로 사용된다.</p>\n<h1>3. 타입 변환</h1>\n<p>자바에서는 다른 타입의 값을 저장할 때 타입 변환이 필요하다. 예를 들어 int 타입의 값을 long 타입의 변수에 저장하려면 int 타입의 값을 long 타입으로 변환해야 한다. 이러한 타입 변환은 자동으로 이루어지기도 하고, 명시적으로 이루어지기도 한다.</p>\n<h2>3.1 자동 타입 변환</h2>\n<p>자동 타입 변환은 작은 크기의 타입을 큰 크기의 타입에 저장할 때 일어난다. 예를 들어 int 타입의 값을 long 타입의 변수에 저장하면 자동으로 int 타입의 값이 long 타입으로 변환된다. int 타입이 가질 수 있는 모든 값을 long 변수에 담을 수 있기 때문에 문제가 없다.</p>\n<p>자동 타입 변환은 다음과 같은 규칙을 따른다.</p>\n<ul>\n<li>byte, short, char 타입은 int 타입으로 변환된다.</li>\n<li>int 타입은 long 타입으로 변환된다.</li>\n<li>long 타입은 float 타입으로 변환된다.</li>\n<li>float 타입은 double 타입으로 변환된다.</li>\n</ul>\n<p>특히 정수 타입이 실수 타입으로 저장될 경우 무조건 자동 타입 변환이 일어난다. 또한 주의할 점이 char보다 허용 범위가 작은 byte 타입은 char 타입으로 자동 변환될 수 없다. char타입은 음수를 포함하지 않는 정수 타입이기 때문이다.(byte는 -128~127까지 표현 가능)</p>\n<h2>3.2 강제 타입 변환</h2>\n<p>큰 크기의 타입을 작은 크기의 타입에 저장하려면 강제 타입 변환이 필요하다. 강제 타입 변환은 다음과 같이 작성한다.</p>\n<pre><code class=\"language-java\">[작은 허용 범위 타입 변수]=([작은 허용 범위 타입]) [큰 허용 범위 타입 변수] 형식으로 쓴다.\nbyte b=(byte)a;\n</code></pre>\n<p>실수 타입을 정수 타입으로 변환할 때는 소수점 이하의 값이 잘린다. 예를 들어 double 타입의 값을 int 타입의 변수에 저장하면 소수점 이하의 값이 잘려서 저장된다.</p>\n<h2>3.3 연산에서의 자동 타입 변환</h2>\n<p>정수 타입 변수가 산술 연산자의 피연산자로 쓰이면 int보다 작은 범위를 갖는 byte, short 타입 변수는 int 타입으로 자동 변환된다. 따라서 다음과 같은 코드는 에러가 발생한다.</p>\n<pre><code class=\"language-java\">package study;\n\npublic class Hello {\n  public static void main(String[] args){\n    byte a=10, b=20;\n    /* a+b 는 int형으로 자동 변환되어 계산되기 때문에\n    이를 byte형에 대입하려 하면 에러 발생 */\n    byte c=a+b;\n    System.out.println(c);\n  }\n}\n</code></pre>\n<p>단, 정수형 변수끼리의 연산이라고 무조건 int타입으로 변환되는 건 아니다. 두 피연산자 중 허용범위가 큰 쪽으로 변환되어 연산을 수행한다. 예를 들어 long타입이 피연산자로 사용되면 두 피연산자 모두 long으로 변환되어 연산이 수행된다.</p>\n<p>이는 자동 타입 변환에서의 관계와 동일하다. 실수끼리의 연산, 실수와 정수 사이 연산에서도 같다. 피연산자가 각각 float, double타입이면 다른 피연산자도 double로 자동 타입 변환되고 int와 double간 연산에서도 double로 둘 다 변환된다.</p>\n<h2>3.4 연산에서의 강제 타입 변환</h2>\n<p>정수끼리의 나눗셈을 하는데 이 결과가 실수형으로 나오게 하고 싶을 수 있다. 예를 들어서 1을 2로 나눈 결과값은 0.5가 맞다. 하지만 피연산자가 둘 다 int형이면 0이 나온다.</p>\n<pre><code class=\"language-java\">package study;\n\npublic class Hello {\n  public static void main(String[] args){\n    int a=1, b=2;\n    System.out.println(a/b);\n  }\n}\n</code></pre>\n<p>이를 해결하기 위해 강제 타입 변환을 사용한다. 두 피연산자 중 적어도 하나를 double로 변환하면 결과값도 double이 된다.</p>\n<pre><code class=\"language-java\">package study;\n\npublic class Hello {\n  public static void main(String[] args){\n    int a=1, b=2;\n    System.out.println((double)a/b);\n  }\n}\n</code></pre>\n<h2>3.5 문자열 자동 타입 변환</h2>\n<p>문자열과 다른 타입의 변수를 + 연산자로 연결하면 문자열로 변환된다. 이를 문자열 자동 타입 변환이라고 한다.</p>\n<pre><code class=\"language-java\">package study;\n\npublic class Hello {\n  public static void main(String[] args){\n    int a=123;\n    String word=\"witch\";\n    System.out.println(a+word); //123witch 출력\n  }\n}\n</code></pre>\n<p>단 이런 자동 타입 변환은 두 피연산자에 대해서만 적용되기 때문에 연산 순서가 중요하다. 자바의 덧셈은 왼쪽에서 오른쪽으로 진행된다. 따라서 <code>123+456+\"witch\"</code> 와 같은 연산식의 경우 <code>123+456</code>이 먼저 수행된 후 <code>579witch</code>가 된다. 반대로 <code>\"witch\"+123+456</code>의 경우 <code>witch123456</code>이 된다. 만약 특정 부분을 먼저 연산하고 싶은 경우 괄호를 쓰자.</p>\n<h2>3.6 문자열을 기본 타입으로 변환</h2>\n<p>문자열을 기본 타입으로 변환하는 것을 문자열을 기본 타입으로 파싱한다고 한다. 문자열을 기본 타입으로 변환하는 방법은 각각의 기본 타입에 해당하는 클래스의 parseXXX() 메소드를 사용하면 된다. 예를 들어서 정수형 문자열을 int형으로 변환하고 싶으면 Integer.parseInt() 메소드를 사용하면 된다.</p>\n<ul>\n<li>Byte.parseByte() : 정수형 문자열을 byte형으로 변환</li>\n<li>Short.parseShort() : 정수형 문자열을 short형으로 변환</li>\n<li>Integer.parseInt() : 정수형 문자열을 int형으로 변환</li>\n<li>Long.parseLong() : 정수형 문자열을 long형으로 변환</li>\n<li>Float.parseFloat() : 실수형 문자열을 float형으로 변환</li>\n<li>Double.parseDouble() : 실수형 문자열을 double형으로 변환</li>\n<li>Boolean.parseBoolean() : 논리형 문자열(\"true\", \"false\")을 boolean형으로 변환</li>\n</ul>\n<p>만약 문자열이 기본 타입으로 변환할 수 없는 문자열(예를 들어 \"abc\"는 기본 타입으로 변환할 수 없다. 16진수형태인 \"0xabc\"와 같은 것도 안된다)이라면 NumberFormatException이 발생한다.</p>\n<p>반대로 기본 타입의 값을 String형으로 변경하고 싶을 땐 <code>String.valueOf()</code> 메소드를 사용하면 된다.</p>\n<h1>참고</h1>\n<p>변수의 초기화 관련 <a href=\"https://stackoverflow.com/questions/19131336/default-values-and-initialization-in-java\">https://stackoverflow.com/questions/19131336/default-values-and-initialization-in-java</a></p>\n<pre><code>\n```\n\n```\n</code></pre>",
    "excerpt": "자바 2단원 변수에 관한 내용이다.\n1. 변수\n프로그램은 변수를 통해 메모리의 특정 번지에 값을 저장하고 읽을 수 있다. 우리는 변수를 선언하고, 변수에 값을 저장하고, 변수에 저장된 값을 읽어서 사용할 수 있다. 이때 구체적인 메모리를 다루는 부분은 JVM이 담당한다.\n1.1 변수의 선언과 초기화\n변수 사용을 위해선 변수를 선언해야 한다. 변수를 선언하는 방법은 다음과 같다. 저장되는 값의 종류와 변수명을 프로그램에 알려 주는 것이다.\n[타입] [변수명]\nin",
    "headingTree": [
      {
        "title": "1. 변수",
        "url": "#1-변수",
        "items": [
          {
            "title": "1.1 변수의 선언과 초기화",
            "url": "#11-변수의-선언과-초기화",
            "items": []
          }
        ]
      },
      {
        "title": "1.2 변수 사용 범위",
        "url": "#12-변수-사용-범위",
        "items": []
      },
      {
        "title": "2. 기본 타입",
        "url": "#2-기본-타입",
        "items": [
          {
            "title": "2.1 리터럴",
            "url": "#21-리터럴",
            "items": [
              {
                "title": "2.1.1 정수 리터럴",
                "url": "#211-정수-리터럴",
                "items": []
              },
              {
                "title": "2.1.2 문자 리터럴",
                "url": "#212-문자-리터럴",
                "items": []
              }
            ]
          },
          {
            "title": "2.2 String type",
            "url": "#22-string-type",
            "items": []
          },
          {
            "title": "2.3 실수 타입",
            "url": "#23-실수-타입",
            "items": []
          },
          {
            "title": "2.4 논리 타입",
            "url": "#24-논리-타입",
            "items": []
          }
        ]
      },
      {
        "title": "3. 타입 변환",
        "url": "#3-타입-변환",
        "items": [
          {
            "title": "3.1 자동 타입 변환",
            "url": "#31-자동-타입-변환",
            "items": []
          },
          {
            "title": "3.2 강제 타입 변환",
            "url": "#32-강제-타입-변환",
            "items": []
          },
          {
            "title": "3.3 연산에서의 자동 타입 변환",
            "url": "#33-연산에서의-자동-타입-변환",
            "items": []
          },
          {
            "title": "3.4 연산에서의 강제 타입 변환",
            "url": "#34-연산에서의-강제-타입-변환",
            "items": []
          },
          {
            "title": "3.5 문자열 자동 타입 변환",
            "url": "#35-문자열-자동-타입-변환",
            "items": []
          },
          {
            "title": "3.6 문자열을 기본 타입으로 변환",
            "url": "#36-문자열을-기본-타입으로-변환",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 362
    },
    "url": "/posts/java-2",
    "thumbnail": {
      "local": "/thumbnails/java-2-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-java-2-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAhklEQVR4nD3MsQkDIRiGYXtXuWxg5QCW1g4gOIDgJskVEVIIFsKlsf57KzuJK9gJFn84Qu5rn4+XGGOklFprpRTnXAjhnENE4pyjlDLGtu12HO+ccynlBO+9tTbnDABrLfyPAEBKKcYIAIg45/wxaZ/eWuu9jzGu+wn783V/7CGEWisiXrUv4ntqi2DGQ0sAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "java-2022-1",
    "title": "기말고사 대비 java - awt",
    "date": "2022-12-11T00:00:00Z",
    "description": "java awt",
    "tags": [
      "language"
    ],
    "html": "<p>java 언어 수업의 기말 범위에선 awt를 배운다. 시험공부한 내용을 간략히 정리한다.</p>\n<h1>1. 시작</h1>\n<p>java에서는 gui 프로그래밍을 위해 awt(abstract window toolkit)라는 패키지를 제공한다.</p>\n<pre><code class=\"language-java\">import java.awt.*;\n</code></pre>\n<p>기본이 되는 요소들을 알아보자.</p>\n<h2>1.1 Frame</h2>\n<p>Frame은 각종 응용 프로그램을 위한 윈도우를 제공한다. 모든 컴포넌트는 Frame 위에 배치되어야 한다. 당연히 최소 한 개는 필요하다. 그리고 각 gui 프로그램은 다음과 같은 과정을 거쳐야 한다.</p>\n<ol>\n<li>new Frame()으로 프레임을 생성한다.</li>\n<li>setSize 메서드로 프레임 크기를 설정한다.</li>\n<li>setVisible 메서드로 프레임을 화면에 보이게 한다.</li>\n</ol>\n<p>아주 간단한 다음과 같은 프로그램을 작성할 수 있다.</p>\n<pre><code class=\"language-java\">import java.awt.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Frame f=new Frame(\"my Frame\");\n        f.setSize(300, 200);\n        f.setVisible(true);\n    }\n}\n</code></pre>\n<h2>1.2 paint</h2>\n<p>paint 메서드는 Frame이 화면에 보여질 때 호출되는 메서드이다. paint 메서드는 다음과 같이 작성한다. 또한 다음과 같은 경우에 실행된다.</p>\n<ol>\n<li>Frame이 처음 화면에 보여질 때, 혹은 setSize로 크기가 변경될 때</li>\n<li>repaint 메서드가 호출될 때</li>\n<li>show 메서드가 호출될 때</li>\n</ol>\n<p>또한 일반적으로 다음과 같이 선언된다.</p>\n<pre><code class=\"language-java\">public void paint(Graphics g){\n  ...\n}\n</code></pre>\n<p>이는 <code>Graphics</code>클래스가 모든 그래픽스 객체의 추상 베이스 클래스이기 때문이다. 그림을 그리는 데에 필요한 모든 설정값과 메서드를 가지고 있다. 그래서 paint 메서드에서는 Graphics 객체를 인자로 받아서 그림을 그린다.</p>\n<h2>1.3 Destroyer</h2>\n<p>앞선 예제에서는 프레임을 닫을 수 있는 방법이 없다. 그래서 프레임을 닫을 수 있는 방법을 알아보자.</p>\n<p>먼저 다음과 같은 클래스를 선언한다.</p>\n<pre><code class=\"language-java\">class WindowDestroyer extends WindowAdapter{\n  public void windowClosing(WindowEvent e){\n    System.exit(0);\n  }\n}\n</code></pre>\n<p>그리고 프레임 f에 대해 저 클래스에 대한 리스너를 추가한다.</p>\n<pre><code class=\"language-java\">public class Main {\n    public static void main(String[] args) {\n        Frame f=new Frame(\"my Frame\");\n        f.setSize(300, 200);\n        WindowDestroyer listener=new WindowDestroyer();\n        f.addWindowListener(listener);\n        f.setVisible(true);\n    }\n}\n</code></pre>\n<h1>2. 도형 그리기 메서드들</h1>\n<p>기본적인 도형을 그리는 메서드를 알아본다.</p>\n<h2>2.1 Frame 생성자</h2>\n<pre><code class=\"language-java\">Frame f=new Frame(창의 제목);\n</code></pre>\n<p>Frame 클래스의 생성자를 보면 생성자 인수로 들어온 문자열과 GraphicsConfiguration 객체를 넣어서 프레임을 초기화하도록 한다. GraphicsConfiguration 객체는 그래픽스 환경에 대한 정보를 가지고 있다. 단 이는 보통 사용자가 직접 설정할 수 없으므로 창의 제목만 생성자 인수로 넣으면 된다.</p>\n<h2>2.2 setSize</h2>\n<p>컴포넌트의 크기를 설정하는 메서드이다. 다음과 같이 사용한다.</p>\n<pre><code class=\"language-java\">f.setSize(width, height);\n</code></pre>\n<h2>2.3 setVisible</h2>\n<p>인수가 true이면 그 컴포넌트를 화면에 보이게 하고, false이면 그 컴포넌트를 화면에서 숨긴다.</p>\n<pre><code class=\"language-java\">f.setVisible(true);\nf.setVisible(false);\n</code></pre>\n<h2>2.4 drawRect</h2>\n<p>drawRect 메서드는 사각형을 그리는 메서드이다. 다음과 같은 형태를 가진다.</p>\n<pre><code class=\"language-java\">public void drawRect(int x, int y, int width, int height)\n</code></pre>\n<p>이때 x,y는 직사각형의 <code>왼쪽 위</code> 꼭짓점의 좌표이고 width, height는 직사각형의 너비와 높이이다.</p>\n<h2>2.5 fillRect</h2>\n<p>fillRect 메서드는 사각형을 채우는 메서드이다. 다음과 같은 형태를 가진다.</p>\n<pre><code class=\"language-java\">public void fillRect(int x, int y, int width, int height)\n</code></pre>\n<p>직사각형을 채울 색은 setColor 메서드로 설정한 색이다. 기본값은 검은색이다.</p>\n<h2>2.6 drawRoundRect</h2>\n<p>drawRoundRect 메서드는 꼭짓점이 둥근 사각형을 그리는 메서드이다. 다음과 같은 형태를 가진다.</p>\n<pre><code class=\"language-java\">public void drawRoundRect(int x, int y, int width, int height, int arcWidth, int arcHeight)\n</code></pre>\n<p>이때 x,y는 drawRect에서처럼 직사각형의 왼쪽 위 꼭짓점의 좌표이고 width, height는 직사각형의 너비와 높이이다. arcWidth, arcHeight는 꼭짓점의 둥근 정도를 나타낸다. arcWidth는 모서리의 둥근 너비의 정도, arcHeight는 모서리의 둥근 높이의 정도를 나타낸다.</p>\n<h2>2.7 fillRoundRect</h2>\n<p>fillRoundRect 메서드는 setColor로 설정한 색으로 채워진 꼭짓점이 둥근 사각형을 그리는 메서드이다. 다음과 같은 형태를 가진다.</p>\n<pre><code class=\"language-java\">public void fillRoundRect(int x, int y, int width, int height, int arcWidth, int arcHeight)\n</code></pre>\n<p>구조는 drawRoundRect와 같다.</p>\n<h2>2.8. DrawLine</h2>\n<p>말 그대로 (x1, y1)에서 (x2, y2)로 향하는 선을 그리는 함수이다.</p>\n<pre><code class=\"language-java\">public void drawLine(int x1, int y1, int x2, int y2)\n</code></pre>\n<h2>2.9. DrawOval</h2>\n<p>drawOval 메서드는 타원을 그리는 메서드이다. 다음과 같은 형태를 가진다.</p>\n<pre><code class=\"language-java\">public void drawOval(int x, int y, int width, int height)\n</code></pre>\n<p>이때 x,y는 <code>타원의 중심이 아니다.</code> x,y는 타원을 딱 맞게 감싸는 직사각형의 왼쪽 위 꼭짓점의 좌표이고 width, height는 그 직사각형의 너비와 높이이다.</p>\n<p>다음과 같은 코드를 보자.</p>\n<pre><code class=\"language-java\">import java.awt.*;\nimport java.awt.event.*;\n\nclass WindowDestroyer extends WindowAdapter{\n    public void windowClosing(WindowEvent e){\n        System.exit(0);\n    }\n}\n\npublic class Main extends Frame {\n    public Main(String str){\n        super(str);\n    }\n\n    public void paint(Graphics g){\n        g.drawLine(50,50,200,200);\n        g.drawOval(50,50,50,30);\n    }\n\n    public static void main(String[] args) {\n        Frame f=new Main(\"my Frame\");\n        f.setSize(500, 300);\n        WindowDestroyer listener=new WindowDestroyer();\n        f.addWindowListener(listener);\n        f.setVisible(true);\n    }\n}\n</code></pre>\n<p>이 결과는 다음과 같다.</p>\n<p><img src=\"/static/drawOval-dfa0845c.png\" alt=\"oval\"></p>\n<p>직선의 시작점(50,50)이 타원의 중심이 아니라 타원을 딱 맞게 감싸는 직사각형의 왼쪽 위 꼭짓점이라는 것을 알 수 있다.</p>\n<h2>2.10. FillOval</h2>\n<p>fillOval 메서드는 setColor로 설정한 색(기본은 검정)으로 채워진 타원을 그리는 메서드이다. 다음과 같은 형태를 가진다. 구조는 drawOval과 같다.</p>\n<pre><code class=\"language-java\">public void fillOval(int x, int y, int width, int height)\n</code></pre>\n<h2>2.11. DrawArc</h2>\n<p>drawArc 메서드는 호를 그리는 메서드이다. 다음과 같은 형태를 가진다.</p>\n<pre><code class=\"language-java\">public void drawArc(int x, int y, int width, int height, int startAngle, int arcAngle)\n</code></pre>\n<p>이때 x,y는 호를 딱 맞게 감싸는 직사각형의 왼쪽 위 꼭짓점의 좌표이고 width, height는 그 직사각형의 너비와 높이이다.</p>\n<p>startAngle은 호의 시작 각도이고 arcAngle은 호의 중심각이다. 각도는 0도가 x축의 양의 방향이고 시계 방향으로 증가한다. 예시는 더 직관적인 fillArc에서 보도록 하겠다.</p>\n<h2>2.12. FillArc</h2>\n<p>fillArc 메서드는 setColor로 설정한 색(기본은 검정)으로 채워진 호를 그리는 메서드이다. 다음과 같은 형태를 가진다. 구조는 drawArc와 같다.</p>\n<pre><code class=\"language-java\">public void fillArc(int x, int y, int width, int height, int startAngle, int arcAngle)\n</code></pre>\n<p>다음과 같이 paint 함수를 만든다고 하자.</p>\n<pre><code class=\"language-java\">public void paint(Graphics g){\n  g.drawLine(50,50,200,200);\n  g.fillArc(50,50,100,70, 60, 200);\n}\n</code></pre>\n<p>그러면 호를 딱 맞게 감싸는 직사각형의 왼쪽 위 꼭짓점이 (50,50)이며 60도에서 시작해서 중심각이 200도인 호가 그려지는 것을 볼 수 있다.</p>\n<p><img src=\"/static/fillArc-7259573c.png\" alt=\"fillArc\"></p>\n<h2>2.13. DrawPolygon</h2>\n<p>다각형을 그리는 메서드이다. x와 y는 각 꼭짓점의 좌표를 저장한 배열이고 n은 꼭짓점의 개수이다.</p>\n<pre><code class=\"language-java\">public void drawPolygon(int[] x, int[] y, int n)\n</code></pre>\n<p>(x[i-1], y[i-1]) 과 (x[i], y[i])를 직선으로 연결한다. 이는 n개의 점에 대해 이루어진다.</p>\n<p>예를 들어 다음과 같이 paint 함수를 만들자.</p>\n<pre><code class=\"language-java\">public void paint(Graphics g){\n    g.drawLine(50,50,200,200);\n    int x[]={50, 100, 100, 50};\n    int y[]={50, 50, 100, 100};\n    g.drawPolygon(x, y, 4);\n}\n</code></pre>\n<p>그러면 다음과 같은 모양이 그려진다.</p>\n<p><img src=\"/static/polygon-1-67f0a501.png\" alt=\"p1\"></p>\n<p>만약 꼭짓점 개수를 다르게 하면? 그럼 x,y 배열의 초기 n개의 원소만 사용한다.</p>\n<pre><code class=\"language-java\">public void paint(Graphics g){\n  g.drawLine(50,50,200,200);\n  int x[]={50, 100, 100, 50};\n  int y[]={50, 50, 100, 100};\n  g.drawPolygon(x, y, 3);\n}\n</code></pre>\n<p>이렇게 꼭짓점을 3개 설정하면 다음과 같은 결과가 나온다.</p>\n<p><img src=\"/static/polygon-2-df423c1f.png\" alt=\"p2\"></p>\n<p>꼭짓점을 설정한 개수가 x,y배열 크기보다 크면 에러가 발생한다. x,y 배열 크기는 4인데 꼭짓점 개수를 5로 설정한다든지 하는 경우에 에러다.</p>\n<h2>2.14. FillPolygon</h2>\n<p>색으로 채워진 다각형을 그리는 메서드이다. drawPolygon과 같은 형태를 가진다.</p>\n<pre><code class=\"language-java\">public void fillPolygon(int[] x, int[] y, int n)\n</code></pre>\n<h1>3. 문자열 그리기 메서드</h1>\n<h2>3.1. drawString</h2>\n<p>문자열을 그리는 메서드이다. 문자열을 그리는 위치는 문자열의 왼쪽 아래 꼭짓점이다.</p>\n<pre><code class=\"language-java\">public void drawString(String str, int x, int y)\n</code></pre>\n<p>예를 들어 다음과 같은 paint 함수를 사용하면..</p>\n<pre><code class=\"language-java\">public void paint(Graphics g){\n  g.drawLine(50,50,200,200);\n  g.drawString(\"저는 마녀입니다\",50,50);\n}\n</code></pre>\n<p>다음과 같은 결과가 나온다.</p>\n<p><img src=\"/static/drawString-c1dfc9e6.png\" alt=\"drawString\"></p>\n<h2>3.2. setFont</h2>\n<p>문자열을 그릴 때 사용할 폰트를 설정한다.</p>\n<pre><code class=\"language-java\">public void setFont(Font f)\n</code></pre>\n<p>setFont는 Graphics 클래스의 메서드이므로 <code>g.setFont(new Font(\"Serif\", Font.BOLD, 20))</code>와 같이 사용한다.</p>\n<p>Font 클래스는 폰트를 나타내는 클래스이다. Font 클래스의 생성자는 다음과 같다.</p>\n<pre><code class=\"language-java\">public Font(String name, int style, int size)\n</code></pre>\n<p>name은 폰트 이름이다. style은 폰트 스타일이다. size는 폰트 크기이다. style은 다음과 같은 상수를 사용한다.</p>\n<pre><code class=\"language-java\">Font.PLAIN\nFont.BOLD\nFont.ITALIC\nFont.BOLD+Font.ITALIC\n</code></pre>\n<p>name은 위의 예시에서와 같이 \"Serif\", \"Sans\"등을 사용할 수 있다.</p>\n<h1>4. 이미지 그리기 메서드</h1>\n<h2>4.1. getImage</h2>\n<p>이미지를 가져오는 메서드이다. 파일 위치를 받아서 이미지를 가져온다. getDefaultToolkit() 을 통해 사용한다.</p>\n<pre><code class=\"language-java\">Image img=Toolkit.getDefaultToolkit().getImage(\"이미지 경로\");\n</code></pre>\n<h2>4.2. drawImage</h2>\n<p>이미지를 그리는 메서드이다.</p>\n<pre><code class=\"language-java\">public boolean drawImage(Image img, int x, int y, ImageObserver observer)\n</code></pre>\n<p>흔히 observer의 자리엔 this를 사용한다. x, y는 이미지의 왼쪽 위 꼭짓점이다.</p>\n<p>혹은 다음과 같은 형식으로도 사용한다.</p>\n<pre><code class=\"language-java\">public boolean drawImage(Image img, int x, int y, int width, int height, ImageObserver observer)\n</code></pre>\n<p>여기서도 observer는 this를 사용한다. width, height는 이미지의 크기이다.</p>\n<p>다음과 같이 사용할 수 있다.</p>\n<pre><code class=\"language-java\">public void paint(Graphics g){\n  g.drawLine(50,50,200,200);\n  Image img=Toolkit.getDefaultToolkit().getImage(\"/Users/kimsunghyun/IdeaProjects/study/src/witch.jpeg\");\n  g.drawImage(img, 50, 50, 100,100,this);\n}\n</code></pre>\n<p>그러면 내가 프로필로 사용하는 사진이 다음과 같이 그려진다. 선의 위치와 비교해 보면 x,y가 이미지의 왼쪽 위 꼭짓점이라는 것을 알 수 있다.</p>\n<p><img src=\"/static/drawImage-aea04c71.png\" alt=\"drawImage\"></p>\n<h1>5. 크기 관련 메서드</h1>\n<h2>5.1. getSize</h2>\n<p>프레임의 크기를 반환한다.</p>\n<pre><code class=\"language-java\">public Dimension getSize()\n</code></pre>\n<h2>5.2. getInsets</h2>\n<p>프레임의 테두리 크기를 반환한다. bottom, left, right, top의 값을 가진다.</p>\n<pre><code class=\"language-java\">public Insets getInsets()\n</code></pre>\n<h2>5.3. 사용</h2>\n<pre><code class=\"language-java\">public void paint(Graphics g){\n  Dimension d=getSize();\n  Insets in=getInsets();\n  g.drawString(\"d.width  : \" + d.width, 10,40);\n  g.drawString(\"d.height : \" + d.height,10,60);\n  g.drawString(\"in.left  : \" + in.left, 10,80);\n  g.drawString(\"in.right : \" + in.right,10,100);\n  g.drawString(\"in.top   : \" + in.top,  10,120);\n  g.drawString(\"in.bottom: \" + in.bottom, 10,140);\n}\n</code></pre>\n<p>이렇게 하면 프레임의 크기와 테두리의 크기를 알 수 있다. 내 컴퓨터의 결과는 다음과 같다.</p>\n<p><img src=\"/static/size-53ef1120.png\" alt=\"getSize\"></p>\n<h1>6. 색상 관련 메서드</h1>\n<h2>6.1. setColor, setBackGround</h2>\n<p>도형이 그려지는 색과 배경을 결정한다.</p>\n<pre><code class=\"language-java\">public void setColor(Color c)\npublic void setBackground(Color c)\n</code></pre>\n<p>setColor는 Graphics 클래스의 메서드이므로 <code>g.setColor(Color.pink)</code>와 같이 사용한다. setBackground는 Frame 클래스의 메서드이므로 <code>f.setBackground(Color.red)</code>와 같이 사용한다. 혹은 프레임 클래스 내부에서 <code>setBackground(Color.red)</code>와 같이 사용할 수도 있다.</p>\n<p>Color 클래스는 색을 나타내는 클래스이다. Color 클래스의 생성자는 다음과 같다.</p>\n<pre><code class=\"language-java\">public Color(int r, int g, int b)\n</code></pre>\n<p>0~255 사이의 값을 갖는 r, g, b를 인자로 받아서 색을 만든다.</p>\n<h2>6.2. getXORMode</h2>\n<p>그래픽 컨텍스트의 현재 색과 새롭게 지정된 색을 바꾸도록 한다. XOR 모드에서 픽셀은 현재 색과 새롭게 지정된 XOR 교대색의 사이를 번갈아가며 바뀐다.</p>\n<pre><code class=\"language-java\">public void paint(Graphics g){\n  g.setColor(Color.pink);\n  g.fillRect(10,10,200,100);\n  g.setXORMode(Color.blue);\n  g.fillRect(100,50,200,100);\n}\n</code></pre>\n<h2>6.3 사용 - 그림 이동시키기</h2>\n<p>XORmode를 이용해서 그림을 지우고 다시 그리는 방식으로 그림을 이동시키는 예제를 만들 수 있다.</p>\n<p>그림을 특정 위치에 그리기 -> 잠시 기다리기 -> 그림을 그린 위치에 덧그리는 방식으로 그림 지우기 -> 조금 이동한 새로운 위치에 그림 그리기의 과정을 반복함으로써 그림이 오른쪽으로 이동하는 것같이 보이게 한다.</p>\n<pre><code class=\"language-java\">public void paint(Graphics g){\n  Image img=Toolkit.getDefaultToolkit().getImage(\"/Users/kimsunghyun/IdeaProjects/study/src/HAEMA.GIF\");\n  Dimension d=getSize();\n  int x;\n  g.setXORMode(Color.white);\n  for (x=10 ; x&#x3C;d.width-100 ; x+=10) \t\t\t// move haema to right direction\n  {\n      g.drawImage(img, x,30, 100, 200, this); \t// draw haema\n      for (int j=0 ; j&#x3C;30000 ; j++);\n      g.drawImage(img, x,30, 100, 200, this); \t// delete haeme drawed\n  }\n  g.drawImage(img, x,30, 100, 200, this);\n}\n</code></pre>\n<h1>7. 패널</h1>\n<p>프레임 안에 있는 일종의 컨테이너이다. 실제로 java.awt.Container를 상속받는다. add 메서드를 통해 컴포넌트를 추가할 수 있다. 또한 setSize, setLocation, setBackground 등의 메서드를 사용할 수 있다.</p>\n<p>그렇게 프레임을 만들고 나면 프레임의 add메서드를 통해 프레임 내에 추가될 수 있다. 다음과 같이 사용하면 핑크색 프레임 내에 노란색 패널이 추가된다.</p>\n<pre><code class=\"language-java\">public static void main(String[] args) {\n    Frame f=new Main(\"my Frame\");\n    Panel p=new Panel();\n    f.setSize(500, 300);\n    f.setBackground(Color.pink);\n    f.setLayout(null);\n    p.setSize(100,100);\n    p.setBackground(Color.yellow);\n    f.add(p);\n    f.addWindowListener(new WindowDestroyer());\n    f.setVisible(true);\n}\n</code></pre>\n<h1>8. 레이아웃</h1>\n<p>위에서 <code>setLayout(null);</code>을 사용하였는데 이 경우 레이아웃 매니저를 사용하지 않겠다는 뜻이다. 그 외에는 다음과 같은 레이아웃 매니저가 있다.</p>\n<h2>8.1. FlowLayout</h2>\n<p>컴포넌트를 왼쪽에서 오른쪽으로 배치하며 기본적으로 가운데 정렬이다. 컴포넌트의 크기가 프레임의 크기보다 크면 다음 줄로 넘어간다. 컴포넌트의 기본 선호 사이즈를 사용하며 뭔가 바꾸고 싶다면 생성자를 사용한다.</p>\n<pre><code class=\"language-java\">f.setLayout(new FlowLayout());\n</code></pre>\n<p>위와 같이 사용한다. 생성자의 매개변수로는 정렬 방식을 지정할 수 있는데 FlowLayout.LEFT, FlowLayout.RIGHT, FlowLayout.CENTER가 있다.</p>\n<p>그리고 frame 메서드 중 pack이 있는데 이는 프레임이 포함하는 컴포넌트들의 크기에 맞게 프레임의 크기를 조절해준다.</p>\n<h2>8.2. BorderLayout</h2>\n<p>프레임과 다이얼로그의 기본 레이아웃이다. 프레임을 5개의 영역으로 나누어 컴포넌트를 배치한다. NORTH, SOUTH, EAST, WEST, CENTER 영역이 있다. 컴포넌트를 배치할 때는 add 메서드의 두 번째 매개변수로 배치할 영역을 지정한다.</p>\n<pre><code class=\"language-java\">f.setLayout(new BorderLayout());\n</code></pre>\n<p>위와 같이 레이아웃 매니저를 지정한다. 그리고 컴포넌트 간의 간격을 조절하고 싶다면 생성자의 매개변수로 간격을 지정할 수도 있다.</p>\n<pre><code class=\"language-java\">f.setLayout(new BorderLayout(hgap, vgap));\n</code></pre>\n<p>다음과 같이 프레임의 add메서드와 함께 사용한다.</p>\n<pre><code class=\"language-java\">f.add(btn1, BorderLayout.NORTH);\nf.add(btn2, BorderLayout.SOUTH);\nf.add(btn3, BorderLayout.EAST);\nf.add(btn4, BorderLayout.WEST);\nf.add(btn5, BorderLayout.CENTER);\n</code></pre>\n<h2>8.3. GridLayout</h2>\n<p>프레임을 행과 열로 나누어 컴포넌트를 배치한다. 프레임을 격자로 나누어서 위에서 아래로, 왼쪽에서 오른쪽으로 차례로 배치한다고 생각하면 된다. 생성자의 매개변수로 다양한 것을 지정할 수 있다.</p>\n<pre><code class=\"language-java\">setLayout(new GridLayout());\nsetLayout(new GridLayout(rows, cols));\nsetLayout(new GridLayout(rows, cols, hgap, vgap));\n</code></pre>\n<p>add메서드를 사용하면 알아서 컴포넌트를 배치해준다.</p>\n<h2>8.4. CardLayout</h2>\n<p>여러 화면을 슬라이드처럼 바꿔가며 보여줄 수 있다. 즉 여러 화면을 레이아웃에 추가한 후 원하는 컨테이너를 보여줄 수 있는 것이다. 순차적으로 다음 화면으로 이동한다든지.</p>\n<p>어떤 화면을 show의 매개변수로 지정하면 그 화면이 보여진다.</p>\n<pre><code class=\"language-java\">public static void main(String[] args) {\n  Frame f=new Main(\"my Frame\");\n  CardLayout card=new CardLayout();\n  f.setLayout(card);\n  Panel p1=new Panel();\n  p1.setBackground(Color.pink);\n  Panel p2=new Panel();\n  p2.setBackground(Color.yellow);\n  Panel p3=new Panel();\n  p3.setBackground(Color.CYAN);\n  f.add(p1, \"1\");\n  f.add(p2, \"2\");\n  f.add(p3, \"3\");\n\n  class Handler extends MouseAdapter{\n      public void mouseClicked(MouseEvent e){\n          card.next(f);\n      }\n  }\n  p1.addMouseListener(new Handler());\n  p2.addMouseListener(new Handler());\n  p3.addMouseListener(new Handler());\n  f.addWindowListener(new WindowDestroyer());\n  f.setSize(500,300);\n  f.setVisible(true);\n  card.show(f, \"1\");\n}\n</code></pre>",
    "excerpt": "java 언어 수업의 기말 범위에선 awt를 배운다. 시험공부한 내용을 간략히 정리한다.\n1. 시작\njava에서는 gui 프로그래밍을 위해 awt(abstract window toolkit)라는 패키지를 제공한다.\nimport java.awt.*;\n\n기본이 되는 요소들을 알아보자.\n1.1 Frame\nFrame은 각종 응용 프로그램을 위한 윈도우를 제공한다. 모든 컴포넌트는 Frame 위에 배치되어야 한다. 당연히 최소 한 개는 필요하다. 그리고 각 gui 프로그",
    "headingTree": [
      {
        "title": "1. 시작",
        "url": "#1-시작",
        "items": [
          {
            "title": "1.1 Frame",
            "url": "#11-frame",
            "items": []
          },
          {
            "title": "1.2 paint",
            "url": "#12-paint",
            "items": []
          },
          {
            "title": "1.3 Destroyer",
            "url": "#13-destroyer",
            "items": []
          }
        ]
      },
      {
        "title": "2. 도형 그리기 메서드들",
        "url": "#2-도형-그리기-메서드들",
        "items": [
          {
            "title": "2.1 Frame 생성자",
            "url": "#21-frame-생성자",
            "items": []
          },
          {
            "title": "2.2 setSize",
            "url": "#22-setsize",
            "items": []
          },
          {
            "title": "2.3 setVisible",
            "url": "#23-setvisible",
            "items": []
          },
          {
            "title": "2.4 drawRect",
            "url": "#24-drawrect",
            "items": []
          },
          {
            "title": "2.5 fillRect",
            "url": "#25-fillrect",
            "items": []
          },
          {
            "title": "2.6 drawRoundRect",
            "url": "#26-drawroundrect",
            "items": []
          },
          {
            "title": "2.7 fillRoundRect",
            "url": "#27-fillroundrect",
            "items": []
          },
          {
            "title": "2.8. DrawLine",
            "url": "#28-drawline",
            "items": []
          },
          {
            "title": "2.9. DrawOval",
            "url": "#29-drawoval",
            "items": []
          },
          {
            "title": "2.10. FillOval",
            "url": "#210-filloval",
            "items": []
          },
          {
            "title": "2.11. DrawArc",
            "url": "#211-drawarc",
            "items": []
          },
          {
            "title": "2.12. FillArc",
            "url": "#212-fillarc",
            "items": []
          },
          {
            "title": "2.13. DrawPolygon",
            "url": "#213-drawpolygon",
            "items": []
          },
          {
            "title": "2.14. FillPolygon",
            "url": "#214-fillpolygon",
            "items": []
          }
        ]
      },
      {
        "title": "3. 문자열 그리기 메서드",
        "url": "#3-문자열-그리기-메서드",
        "items": [
          {
            "title": "3.1. drawString",
            "url": "#31-drawstring",
            "items": []
          },
          {
            "title": "3.2. setFont",
            "url": "#32-setfont",
            "items": []
          }
        ]
      },
      {
        "title": "4. 이미지 그리기 메서드",
        "url": "#4-이미지-그리기-메서드",
        "items": [
          {
            "title": "4.1. getImage",
            "url": "#41-getimage",
            "items": []
          },
          {
            "title": "4.2. drawImage",
            "url": "#42-drawimage",
            "items": []
          }
        ]
      },
      {
        "title": "5. 크기 관련 메서드",
        "url": "#5-크기-관련-메서드",
        "items": [
          {
            "title": "5.1. getSize",
            "url": "#51-getsize",
            "items": []
          },
          {
            "title": "5.2. getInsets",
            "url": "#52-getinsets",
            "items": []
          },
          {
            "title": "5.3. 사용",
            "url": "#53-사용",
            "items": []
          }
        ]
      },
      {
        "title": "6. 색상 관련 메서드",
        "url": "#6-색상-관련-메서드",
        "items": [
          {
            "title": "6.1. setColor, setBackGround",
            "url": "#61-setcolor-setbackground",
            "items": []
          },
          {
            "title": "6.2. getXORMode",
            "url": "#62-getxormode",
            "items": []
          },
          {
            "title": "6.3 사용 - 그림 이동시키기",
            "url": "#63-사용---그림-이동시키기",
            "items": []
          }
        ]
      },
      {
        "title": "7. 패널",
        "url": "#7-패널",
        "items": []
      },
      {
        "title": "8. 레이아웃",
        "url": "#8-레이아웃",
        "items": [
          {
            "title": "8.1. FlowLayout",
            "url": "#81-flowlayout",
            "items": []
          },
          {
            "title": "8.2. BorderLayout",
            "url": "#82-borderlayout",
            "items": []
          },
          {
            "title": "8.3. GridLayout",
            "url": "#83-gridlayout",
            "items": []
          },
          {
            "title": "8.4. CardLayout",
            "url": "#84-cardlayout",
            "items": []
          }
        ]
      }
    ],
    "metadata": {
      "readingTime": 4,
      "wordCount": 958
    },
    "url": "/posts/java-2022-1",
    "thumbnail": {
      "local": "/static/drawOval-dfa0845c.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-drawOval-dfa0845c-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAFCAIAAAD38zoCAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAQklEQVR4nGPQVJefMXv2x8+fo2NiwiIiHjx6dOHSpQuXLjHExycICAjk5uZWg0EuDDBAOM7OznA5CABJwBVikcAEAEYjOU6LleknAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "java-2022-2",
    "title": "기말고사 대비 java - Windows Programming",
    "date": "2022-12-13T00:00:00Z",
    "description": "java Windows Programming",
    "tags": [
      "language"
    ],
    "html": "<p>Java 기말고사 범위의 6번째, Windows Programming에 대해 정리해보았다. 각종 이벤트들과 컴포넌트들에 대해 알아본다.</p>\n<h1>1. 이벤트</h1>\n<p>무슨 일이 생겼는지를 담고 있는 객체이다. 가령 마우스가 클릭되었을 때, 키보드가 눌렸을 때 어떤 키가 눌렸고 커서 위치는 어디고 등등을 담고 있는 것이다. java에서는 이를 <code>ActionEvent</code>라고 한다.</p>\n<h2>1.1 ActionEvent</h2>\n<p>ActionEvent 객체는 다음과 같은 메서드를 포함한다.</p>\n<ul>\n<li><code>String getActionCommand()</code>: 이벤트가 발생한 컴포넌트의 텍스트를 반환한다.</li>\n<li><code>getModifiers()</code>: 이벤트가 발생한 컴포넌트의 키보드 모드를 반환한다.</li>\n</ul>\n<h2>1.2 이벤트 핸들러</h2>\n<p>이벤트 핸들러는 이벤트 객체를 받아서 해독하고 처리하는 역할을 한다.</p>\n<p>이벤트는 그걸 받은 컴포넌트에 전달되는데 컴포넌트는 이벤트를 처리할 수 있는 이벤트 핸들러를 담은 객체인 이벤트 리스너를 가지고 있다. 이벤트를 리스너로 전달하는 것은 컴포넌트 단에서 처리하도록 코드를 짠다.</p>\n<p>예를 들어서 이벤트 리스너는 다음과 같이 작성할 수 있다. actionPerformed 외에도 MouseListener와 mousePressed 등 다양한 이벤트 리스너와 그 메소드들이 있다. 그 이벤트 리스너 추상 클래스들을 구현하는 식으로 핸들러를 만든다.</p>\n<pre><code class=\"language-java\">class ButtonHandler implements ActionListener{\n    public void actionPerformed(ActionEvent e){\n        System.out.println(\"Button Pressed\");\n        System.out.println(\"Button label : \"+ e.getActionCommand());\n    }\n}\n</code></pre>\n<p>그리고 이 이벤트 리스너를 컴포넌트에 등록하는 것은 addActionListener 메서드를 사용한다.</p>\n<pre><code class=\"language-java\">public static void main(String[] args) {\n    Frame f=new Main(\"my Frame\");\n    Button b=new Button(\"Press me\");\n    b.addActionListener(new ButtonHandler());\n    f.add(b, BorderLayout.CENTER);\n    f.pack();\n    f.setVisible(true);\n}\n</code></pre>\n<p>버튼에 이벤트 리스너를 추가함으로써 클릭 이벤트를 처리할 수 있도록 한 것이다.</p>\n<h2>1.3 다중 이벤트 핸들러</h2>\n<p>하나의 컴포넌트에 여러 이벤트 핸들러를 다는 것도 가능하다. 서로 다른 이벤트에 대한 핸들러는 다른 add listener 메서드를 사용하기 때문이다.</p>\n<p>이때 implements한 추상 베이스 클래스의 메서드를 모두 정의해 줘야 됨에 주의.</p>\n<pre><code class=\"language-java\">public class Main implements MouseMotionListener, MouseListener{\n    private TextField tf;\n    private Frame f;\n    public Main(){\n        f=new Frame(\"two listeners\");\n        f.add(new Label(\"마우스 드래그\"), BorderLayout.NORTH);\n        tf=new TextField(30);\n        f.add(tf, BorderLayout.SOUTH);\n        f.addMouseMotionListener(this);\n        f.addMouseListener(this);\n        f.setSize(500,300);\n        f.addWindowListener(new WindowDestroyer());\n        f.setVisible(true);\n    }\n\n    public void paint(Graphics g){\n    }\n\n    public static void main(String[] args) {\n        Main M=new Main();\n    }\n    public void mouseDragged(MouseEvent e){\n        String s=\"Mouse drag X:\" + e.getX() + \"Y:\"+e.getY();\n        tf.setText(s);\n    }\n    public void mouseEntered(MouseEvent e){\n        tf.setText(\"Mouse Entered\");\n    }\n    public void mouseExited(MouseEvent e){\n        tf.setText(\"Mouse Exited\");\n    }\n    public void mouseMoved(MouseEvent e) {}\n    public void mouseReleased(MouseEvent e) {}\n    public void mouseClicked(MouseEvent e) {}\n    public void mousePressed(MouseEvent e) {}\n}\n</code></pre>\n<h1>2. AWT 컴포넌트</h1>\n<h2>2.1 Button</h2>\n<pre><code class=\"language-java\">class ButtonHandler implements ActionListener{\n    public void actionPerformed(ActionEvent e){\n        System.out.println(\"Button Pressed\");\n        System.out.println(\"Button label : \"+ e.getActionCommand());\n    }\n}\npublic class Main{\n    Main(){\n        Frame f=new Frame(\"예시 프로그램\");\n        Button b=new Button(\"예시 버튼\");\n        b.addActionListener(new ButtonHandler());\n        f.add(b);\n        f.pack();\n        f.addWindowListener(new WindowDestroyer());\n        f.setVisible(true);\n    }\n\n    public static void main(String args[]){\n        Main M=new Main();\n    }\n}\n</code></pre>\n<p>ActionListener의 actionPerformed를 사용하였다.</p>\n<h2>2.2 Checkbox</h2>\n<p>생성자는 5가지가 있다.</p>\n<pre><code class=\"language-java\">new Checkbox(); // 라벨 없고, 선택되지 않은 상태로 생성된다\nnew Checkbox(String label);\nnew Checkbox(String label, boolean state);\nnew Checkbox(String label, boolean state, CheckboxGroup group);\nnew Checkbox(String label, CheckboxGroup group, boolean state);\n</code></pre>\n<p>ItemListener의 itemStateChanged를 사용할 수 있다. itemStateChanged는 체크박스의 상태가 변경될 때 호출된다.</p>\n<p>다음 코드에선 One, Two, Three 라벨이 붙은 체크박스 3개를 생성하고 그 상태가 바뀔 때마다 그 상태를 출력한다.</p>\n<pre><code class=\"language-java\">\nclass CheckboxHandler implements ItemListener{\n    public void itemStateChanged(ItemEvent e){\n        String state=\"deselected\";\n        if(e.getStateChange()==ItemEvent.SELECTED){\n            state=\"selected\";\n        }\n        System.out.println(e.getItem() + \" \"+state);\n    }\n}\npublic class Main{\n    Main(){\n        Frame f=new Frame(\"예시 프로그램\");\n        Checkbox cb1=new Checkbox(\"One\", true);\n        Checkbox cb2=new Checkbox(\"Two\", false);\n        Checkbox cb3=new Checkbox(\"Three\", false);\n        cb1.addItemListener(new CheckboxHandler());\n        cb2.addItemListener(new CheckboxHandler());\n        cb3.addItemListener(new CheckboxHandler());\n        f.setLayout(new FlowLayout());\n        f.add(cb1);\n        f.add(cb2);\n        f.add(cb3);\n        f.pack();\n        f.addWindowListener(new WindowDestroyer());\n        f.setVisible(true);\n    }\n\n    public static void main(String args[]){\n        Main M=new Main();\n    }\n}\n</code></pre>\n<p>CheckboxGroup도 <code>new CheckboxGroup()</code>로 생성할 수 있다. 이때 Checkbox의 생성자에 CheckboxGroup을 넣어주면 그 그룹에 속하게 된다.</p>\n<h2>2.3 Choice</h2>\n<p>Choice는 여러가지 중에 하나를 선택하는 드롭다운 메뉴를 만들 수 있다.</p>\n<pre><code class=\"language-java\">Choice ch=new Choice();\nch.addItem(\"First\");\nch.addItem(\"Second\");\nch.addItem(\"Third\");\n</code></pre>\n<p>Choice는 ItemListener의 itemStateChanged를 사용할 수 있다. itemStateChanged는 Choice의 상태가 변경될 때 호출된다.</p>\n<h2>2.4 Canvas</h2>\n<p>Canvas는 그림을 그릴 수 있는 컴포넌트이다. Canvas는 paint() 메소드를 오버라이드하여 그림을 그릴 수 있다.</p>\n<p>다음 예제는 KeyListener의 keyTyped를 사용하여 키보드를 누를 때마다 캔버스 색이 바뀌는 프로그램이다.</p>\n<pre><code class=\"language-java\">public class Main extends Canvas implements KeyListener{\n    private int idx;\n    Color colors[]={Color.red, Color.green, Color.blue};\n    Main(){\n        super();\n    }\n\n    public void paint(Graphics g){\n        g.setColor(colors[idx]);\n        g.fillRect(0,0,getSize().width, getSize().height);\n    }\n\n    public void keyTyped(KeyEvent e){\n        idx=(idx+1)%colors.length;\n        repaint();\n    }\n\n    public void keyPressed(KeyEvent e){}\n    public void keyReleased(KeyEvent e){}\n\n    public static void main(String args[]){\n        Frame f=new Frame(\"캔버스 예시\");\n        Main m=new Main();\n        m.setSize(150,150);\n        f.add(m, BorderLayout.CENTER);\n        m.requestFocus();\n        m.addKeyListener(m);\n        f.pack();\n        f.addWindowListener(new WindowDestroyer());\n        f.setVisible(true);\n    }\n}\n</code></pre>\n<h2>2.5 TextArea</h2>\n<p>TextArea는 여러 줄의 텍스트를 입력할 수 있는 컴포넌트이다. 다음과 같은 생성자를 가진다.</p>\n<pre><code class=\"language-java\">new TextArea();\nnew TextArea(int rows, int cols);\nnew TextArea(String text);\nnew TextArea(String text, int rows, int cols);\n// scrollbar는 스크롤바 유무를 결정한다.\nnew TextArea(String text, int rows, int cols, int scrollbars);\n</code></pre>\n<p>TextListener의 textValueChanged를 사용할 수 있다. textValueChanged는 TextArea의 텍스트가 변경될 때 호출된다.</p>\n<h2>2.6 TextField</h2>\n<p>한 줄의 텍스트를 입력할 수 있는 컴포넌트이다. 다음과 같은 생성자를 가진다.</p>\n<pre><code class=\"language-java\">new TextField();\nnew TextField(int cols);\nnew TextField(String text);\nnew TextField(String text, int cols);\n</code></pre>\n<p>TextListener의 textValueChanged를 사용할 수 있다. textValueChanged는 TextField의 텍스트가 변경될 때 호출된다.</p>\n<p>또한 키 입력을 받기 위해 KeyListener가 아니라 이를 구현한 클래스인 KeyAdapter를 사용할 수 있다.</p>\n<h2>2.7 List</h2>\n<p>List는 여러 개의 항목을 선택할 수 있는 컴포넌트이다. 여러 개의 요소들을 스크롤하면서 하나 혹은 여러 요소를 선택할 수 있다.</p>\n<pre><code class=\"language-java\">new List();\nnew List(int rows);\n// multiple는 여러 개의 요소를 선택할 수 있는지를 결정한다.\nnew List(int rows, boolean multiple);\n</code></pre>\n<p>다음과 같이 사용한다.</p>\n<pre><code class=\"language-java\">public class Main {\n    private Frame f;\n    private List l;\n    public Main(){\n        f=new Frame(\"List Sample\");\n        l=new List(4, true);\n        l.add(\"A\");\n        l.add(\"B\");\n        l.add(\"C\");\n        l.add(\"D\");\n        f.add(l, BorderLayout.CENTER);\n        f.pack();\n        f.addWindowListener(new WindowDestroyer());\n        f.setVisible(true);\n    }\n\n    public static void main(String args[]){\n        Main M=new Main();\n    }\n}\n</code></pre>\n<h2>2.8 Dialog</h2>\n<p>Dialog는 다른 컴포넌트 위에 떠있는 컴포넌트이다. Dialog는 Frame의 메소드를 사용하여 생성할 수 있다.</p>\n<p>또한 다이얼로그가 소속된 프레임이나 다른 다이얼로그의 상태에 따라 사용자에게 보이는지 여부가 변한다. 다이얼로그가 속한 프레임이 닫힌 상태라면 다이얼로그도 보이지 않게 된다.</p>\n<p>WindowListener의 windowOpened, windowClosing, windowClosed, windowActivated, windowDeactivated등의 이벤트 메서드를 사용할 수 있다.</p>\n<p>생성자는 다음과 같다.</p>\n<pre><code class=\"language-java\">new Dialog(Dialog owner);\nnew Dialog(Dialog owner, String title);\nnew Dialog(Dialog owner, String title, boolean modal);\nnew Dialog(Frame owner);\nnew Dialog(Frame owner, boolean modal);\nnew Dialog(Frame owner, String title);\nnew Dialog(Frame owner, String title, boolean modal);\n</code></pre>\n<p>또한 dispose 메서드를 사용하여 다이얼로그를 닫을 수 있고 ActionListener의 actionPerformed를 사용하여 다이얼로그의 버튼을 눌렀을 때의 이벤트를 처리할 수 있다.</p>\n<h2>2.9 FileDialog</h2>\n<p>FileDialog는 파일을 선택할 수 있는 다이얼로그이다. 생성자는 다음과 같다.</p>\n<pre><code class=\"language-java\">new FileDialog(Frame owner);\nnew FileDialog(Frame owner, String title);\nnew FileDialog(Frame owner, String title, int mode);\n</code></pre>\n<p>모드는 다음과 같다. FileDialog.LOAD는 파일을 불러오는 모드이고 FileDialog.SAVE는 파일을 저장하는 모드이다.</p>\n<h2>2.10 Menu</h2>\n<p>메뉴바 -> 메뉴 -> 메뉴아이템.</p>\n<p>메뉴바는 Frame의 setMenuBar를 사용하여 추가할 수 있다.</p>\n<pre><code class=\"language-java\">MenuBar mb=new MenuBar();\nMenu fileMenu=new Menu(\"File\");\nfileMenu.add(new MenuItem(\"Open\"));\nfileMenu.add(new MenuItem(\"Save\"));\nfileMenu.addSeparator(); //구분자 넣기\nfileMenu.add(new MenuItem(\"Exit\"));\nmb.add(fileMenu);\nf.setMenuBar(mb);\n</code></pre>\n<p>또 CheckboxMenuItem을 사용하여 체크박스도 메뉴에 넣을 수 있다.</p>",
    "excerpt": "Java 기말고사 범위의 6번째, Windows Programming에 대해 정리해보았다. 각종 이벤트들과 컴포넌트들에 대해 알아본다.\n1. 이벤트\n무슨 일이 생겼는지를 담고 있는 객체이다. 가령 마우스가 클릭되었을 때, 키보드가 눌렸을 때 어떤 키가 눌렸고 커서 위치는 어디고 등등을 담고 있는 것이다. java에서는 이를 ActionEvent라고 한다.\n1.1 ActionEvent\nActionEvent 객체는 다음과 같은 메서드를 포함한다.\n\nString ge",
    "headingTree": [
      {
        "title": "1. 이벤트",
        "url": "#1-이벤트",
        "items": [
          {
            "title": "1.1 ActionEvent",
            "url": "#11-actionevent",
            "items": []
          },
          {
            "title": "1.2 이벤트 핸들러",
            "url": "#12-이벤트-핸들러",
            "items": []
          },
          {
            "title": "1.3 다중 이벤트 핸들러",
            "url": "#13-다중-이벤트-핸들러",
            "items": []
          }
        ]
      },
      {
        "title": "2. AWT 컴포넌트",
        "url": "#2-awt-컴포넌트",
        "items": [
          {
            "title": "2.1 Button",
            "url": "#21-button",
            "items": []
          },
          {
            "title": "2.2 Checkbox",
            "url": "#22-checkbox",
            "items": []
          },
          {
            "title": "2.3 Choice",
            "url": "#23-choice",
            "items": []
          },
          {
            "title": "2.4 Canvas",
            "url": "#24-canvas",
            "items": []
          },
          {
            "title": "2.5 TextArea",
            "url": "#25-textarea",
            "items": []
          },
          {
            "title": "2.6 TextField",
            "url": "#26-textfield",
            "items": []
          },
          {
            "title": "2.7 List",
            "url": "#27-list",
            "items": []
          },
          {
            "title": "2.8 Dialog",
            "url": "#28-dialog",
            "items": []
          },
          {
            "title": "2.9 FileDialog",
            "url": "#29-filedialog",
            "items": []
          },
          {
            "title": "2.10 Menu",
            "url": "#210-menu",
            "items": []
          }
        ]
      }
    ],
    "metadata": {
      "readingTime": 3,
      "wordCount": 749
    },
    "url": "/posts/java-2022-2",
    "thumbnail": {
      "local": "/thumbnails/java-2022-2-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-java-2022-2-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAjUlEQVR4nGNYunSpsrJyampqRESEoaGhvb1Dfn7+jx8/GMrKylhYWHR1dWNiYo6CwYkTJ37//s2Qn1+grKysoaGhpaXl6elZVFT0HwwYjh49GhQUtHLlyhMnTuzbt2/lypU/fvwASUycPCU0NKyzs/PSpUv//////fs3VMfCJSsWLFy0auXKCxcuIEsAACbCWmWUi+T9AAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "java-3",
    "title": "중간고사 대비 java 2.4단원 정리",
    "date": "2022-10-17T00:00:00Z",
    "description": "중간고사 대비 JAVA 내용 정리 2.4단원",
    "tags": [
      "language"
    ],
    "html": "<p>자바 2.4 변수와 시스템 입출력 관련 내용이다.</p>\n<h1>1. 시스템 입출력</h1>\n<p>우리는 지금까지 모니터 입출력을 위해 <code>System.in</code> 과 <code>System.out</code> 이 붙은 함수들을 사용했다. 특히 <code>System.out.println</code>에서 이를 볼 수 있다.</p>\n<h2>1.1 시스템 출력</h2>\n<p>지금까지 사용한 <code>System.out.println</code>은 한 줄을 출력하고 행을 바꾼다는 의미이다. 출력한 내용 이후에 줄바꿈을 하고 싶지 않을 경우 <code>System.out.print</code>를 사용하면 된다.</p>\n<p>그리고 C언어에서와 같이 포맷 문자열을 출력할 수 있는 <code>System.out.printf</code> 도 제공한다. 이 함수는 C언어의 <code>printf</code>의 포매팅와 동일하게 동작한다. 포맷 문자열을 사용하는 예시는 다음과 같다.</p>\n<pre><code class=\"language-java\">package study;\n\npublic class Hello {\n  public static void main(String[] args){\n    System.out.printf(\"제 이름은 %s이고 나이는 %d살입니다.\" , \"홍길동\", 20);\n  }\n}\n</code></pre>\n<h2>1.2 시스템 입력</h2>\n<p>사용자로부터의 입력을 받는 입력 함수들도 있다. 한 글자를 입력받는 함수로 <code>System.in.read()</code>가 있다. 그런데 이 함수는 입력을 한 글자씩만 읽기 때문에 2개 이상의 키가 조합된 ab 같은 문자열이나 한글조차 입력받을 수 없다. 엔터까지도 캐리지 리턴과 라인 피드 2개의 키로 처리된다.</p>\n<p>이런 단점을 보완하는 게 Scanner클래스이다. 다음과 같이 스캐너 객체를 생성하여 nextLine() 함수를 사용하면 한 줄을 입력받을 수 있다.</p>\n<pre><code class=\"language-java\">package study;\n\nimport java.util.Scanner;\n\npublic class Hello {\n  public static void main(String[] args){\n    // 스캐너 객체 생성 후 sc에 저장\n    Scanner sc = new Scanner(System.in);\n    // 읽은 문자열을 저장한다\n    String userInput= sc.nextLine();\n    System.out.println(userInput);\n  }\n}\n</code></pre>",
    "excerpt": "자바 2.4 변수와 시스템 입출력 관련 내용이다.\n1. 시스템 입출력\n우리는 지금까지 모니터 입출력을 위해 System.in 과 System.out 이 붙은 함수들을 사용했다. 특히 System.out.println에서 이를 볼 수 있다.\n1.1 시스템 출력\n지금까지 사용한 System.out.println은 한 줄을 출력하고 행을 바꾼다는 의미이다. 출력한 내용 이후에 줄바꿈을 하고 싶지 않을 경우 System.out.print를 사용하면 된다.\n그리고 C언어",
    "headingTree": [
      {
        "title": "1. 시스템 입출력",
        "url": "#1-시스템-입출력",
        "items": [
          {
            "title": "1.1 시스템 출력",
            "url": "#11-시스템-출력",
            "items": []
          },
          {
            "title": "1.2 시스템 입력",
            "url": "#12-시스템-입력",
            "items": []
          }
        ]
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 71
    },
    "url": "/posts/java-3",
    "thumbnail": {
      "local": "/thumbnails/java-3-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-java-3-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAhklEQVR4nGNITk5yc3OLjY318fExMzOzsbEpLCz8//8/Q3V1tZiYmK6uLiMjo66u7o4dO06dOgWS2L17d25ubmRk1MqVqx48ePAfBhi+fPny4MGDmzdvfvny5f///7/BACRx/cat23fuPHny+MOHD3DlIImpM+dOmjxl0aJFFy9ehOiASAAAKSVnCU7qN7kAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "java-4",
    "title": "중간고사 대비 java 3, 4단원 정리",
    "date": "2022-10-17T01:00:00Z",
    "description": "중간고사 대비 JAVA 내용 정리 3단원",
    "tags": [
      "language"
    ],
    "html": "<p>혼자 공부하는 자바 3단원의 연산자와 4단원의 조건문과 반복문 관련 내용이다. 이미 C등에서 많이 본 내용이 있으므로 주의할 점만 간단히 정리했다.</p>\n<ul>\n<li>단항 연산자로 부호 연산자가 있는데 이 계산도 int형으로 자동 타입 변환이 일어난다.\n따라서 다음과 같은 코드는 에러가 발생한다.</li>\n</ul>\n<pre><code class=\"language-java\">byte a=1;\nbyte b=-a; // -a의 결과가 int형이 되므로 에러\n</code></pre>\n<ul>\n<li>Math.random() 을 사용해서 0.0&#x3C;=x&#x3C;1.0 범위의 값을 뽑을 수 있다. 1.0은 미포함이다.</li>\n</ul>\n<p>이를 이용해서 start부터 시작하는 n개의 정수 중 하나를 얻기 위한 연산식을 다음과 같이 만들 수 있다. <code>(int)(Math.random()*n)+start</code></p>\n<ul>\n<li>java의 switch문은 문자열에도 적용할 수 있다. 더 구체적으로는 switch문의 조건식은 int, char, String, enum 타입이어야 한다.</li>\n</ul>\n<pre><code class=\"language-java\">package study;\n\nimport java.util.Scanner;\n\npublic class Hello {\n  public static void main(String[] args){\n    // 스캐너 객체 생성 후 sc에 저장\n    Scanner sc = new Scanner(System.in);\n    // 이름을 입력받아 name에 저장\n    String name = sc.nextLine();\n    switch (name){\n      case \"김성현\":\n        System.out.println(\"안녕하세요 김성현님\");\n        break;\n      default:\n        System.out.println(\"안녕하세요\");\n    }\n  }\n}\n</code></pre>\n<ul>\n<li>루프 카운터 변수는 실수를 사용하면 안된다.</li>\n</ul>\n<p>컴퓨터 내에서 실수를 완벽히 정확하게 표현할 수 없기 때문에 잘못된 카운팅이 될 수 있다.</p>\n<pre><code class=\"language-java\">package study;\n\npublic class Hello {\n  public static void main(String[] args){\n    for(double i=0.1;i&#x3C;=1.0;i+=0.1){\n      System.out.println(i);\n      // 중간중간 정확하게 0.1씩 증가하지 않는 부분이 존재하며 경우에 따라 의도대로 실행되지 않을 수 있다\n    }\n  }\n}\n</code></pre>\n<ul>\n<li>라벨을 이용해서 중첩 반복문을 한번에 탈출할 수 있다.</li>\n</ul>\n<p>탈출하고 싶은 반복문 앞에 적절한 이름의 Label을 붙인 후 <code>break Label;</code> 을 사용하면 된다. Label은 지정한 라벨명으로 적절히 바꾸면 된다.</p>\n<pre><code class=\"language-java\">package study;\n\npublic class Hello {\n  public static void main(String[] args){\n    Label:for(int i=0;i&#x3C;5;i++){\n      for(int j=0;j&#x3C;i;j++){\n        for(int k=0;k&#x3C;j;k++){\n          System.out.printf(\"%d %d %d\\n\", i,j,k);\n          if(k==1){break Label;}\n        }\n      }\n    }\n  }\n}\n</code></pre>",
    "excerpt": "혼자 공부하는 자바 3단원의 연산자와 4단원의 조건문과 반복문 관련 내용이다. 이미 C등에서 많이 본 내용이 있으므로 주의할 점만 간단히 정리했다.\n\n단항 연산자로 부호 연산자가 있는데 이 계산도 int형으로 자동 타입 변환이 일어난다.\n따라서 다음과 같은 코드는 에러가 발생한다.\n\nbyte a=1;\nbyte b=-a; // -a의 결과가 int형이 되므로 에러\n\n\nMath.random() 을 사용해서 0.0<=x<1.0 범위의 값을 뽑을 수 있다. 1.0은 미",
    "headingTree": [],
    "metadata": {
      "readingTime": 1,
      "wordCount": 131
    },
    "url": "/posts/java-4",
    "thumbnail": {
      "local": "/thumbnails/java-4-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-java-4-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAeElEQVR4nGOorKyMiYkpKChITU318PAICwsrLi5etWoVQ1ZWFgsLi62trZGR0fbt2/ft23fq1Knbt28zvHjxAsK5cuXKjx8//sMAA5z1////3zAAkrh9997169fv3L797t07ZEUMS5evnr9w0caN669fvw7RBJEAANUubkbxV+v/AAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "java-5",
    "title": "중간고사 대비 java 5단원 정리",
    "date": "2022-10-17T02:00:00Z",
    "description": "중간고사 대비 JAVA 내용 정리 5단원",
    "tags": [
      "language"
    ],
    "html": "<p>혼자 공부하는 자바 5단원, 참조 타입 내용 정리이다.</p>\n<h1>1. 참조 타입</h1>\n<p>자바의 기본 타입은 byte, char, short, int, long, float, double, boolean이 있다. 하지만 이 타입의 변수만 있는 게 아니다. 앞서 다루었던 String도 기본 타입이 아니었다. 이런 타입을 참조 타입이라고 한다.</p>\n<p>기본 타입과의 가장 큰 차이점은 저장되는 값이다. 기본 타입의 변수들에는 실제 값이 저장된다. 하지만 참조 타입 변수들에는 메모리의 번지수, 즉 주소가 저장된다. 예를 들어 String타입의 경우 문자열 객체가 힙 영역에 저장되고 그 객체의 주소값이 String 타입 변수에 저장된다.</p>\n<h2>1.1 참조 변수의 비교</h2>\n<p>참조 타입의 변수들은 주소값을 저장하고 있다. 그렇기 때문에 참조 변수들끼리의 비교는 주소값을 비교하는 것이다. 즉 동일한 객체를 참조하고 있는지만 확인한다. 그래서 참조 변수들끼리의 비교는 == 연산자로 비교할 수 없다. == 연산자는 기본 타입의 변수들끼리의 비교에만 사용할 수 있다.</p>\n<p>참조 타입 변수들의 비교에는 따로 메소드를 구현하거나 문자열의 <code>equals()</code> 메소드처럼 기본적으로 구현된 메소드를 사용해야 한다.</p>\n<h2>1.2 null</h2>\n<p>참조 타입 변수는 null 값을 가질 수 있는데 이는 힙 영역 객체를 참조하지 않는다는 뜻이다. null로 초기화된 참조 변수의 값은 스택 영역에 저장된다. 따라서 <code>==, !=</code> 연산자로 비교할 수 있다.</p>\n<p>그리고 null 값을 가지고 있는 참조 타입 변수를 사용하게 되면 NullPointerException이 발생한다. 이는 참조 변수가 참조하는 객체가 없기 때문에 발생하는 예외이다.</p>\n<h2>1.3 문자열 참조 변수</h2>\n<p>문자열은 참조 타입이다. 이 타입의 특성은 다음과 같다.</p>\n<ul>\n<li>문자열 리터럴이 동일하면 같은 문자열 객체를 참조한다.</li>\n<li>new를 사용해서 아예 새로운 객체를 만들 수도 있다. 이 경우 같은 내용이라도 다른 객체를 참조하게 되므로 비교에 <code>equals()</code> 메소드를 사용해야 한다.</li>\n<li>참조 타입 변수이므로 null을 대입할 수 있다. 이 경우 참조를 잃은 객체는 가비지 컬렉터에 의해 제거된다.</li>\n</ul>\n<h1>2. 배열</h1>\n<p>배열은 같은 타입 데이터를 연속된 공간에 저장하는 자료구조이다.</p>\n<h2>2.1 배열의 선언</h2>\n<p>배열 변수 선언은 다음과 같은 2가지 방식으로 작성해야 한다.</p>\n<pre><code class=\"language-java\">타입[] 변수이름;\n타입 변수이름[];\n</code></pre>\n<p>즉 <code>int[] arr;</code>와 <code>int arr[];</code> 2가지 방식으로 작성할 수 있다.</p>\n<p>배열도 참조 타입 변수이므로 null로 초기화할 수 있다.\n그리고 값의 목록을 통해 다음과 같이 배열을 생성할 수 있다.</p>\n<p><code>int arr[] = {1, 2, 3};</code></p>\n<p>혹은 new를 이용해 다음과 같이 할 수 있다.</p>\n<p><code>int arr[] = new int[3];</code></p>\n<p>이 경우 배열의 각 요소는 기본값으로 초기화된다. 기본 타입의 경우 0(boolean은 false), 참조 타입의 경우 null이다. 예를 들어 <code>new int[3]</code>의 경우 0, 0, 0으로 초기화된다.</p>\n<h2>2.2 배열 길이</h2>\n<p>배열의 길이는 <code>length</code> 필드를 통해 알 수 있다.</p>\n<pre><code class=\"language-java\">int arr[] = {1,2,3,4,5};\nSystem.out.println(arr.length);\n</code></pre>\n<p>이때 length 필드는 읽기 전용이기 때문에 값을 변경할 수 없다.</p>\n<h1>3. 열거형 타입</h1>\n<p>열거 타입은 한정된 값인 열거 상수(enumeration constant)들 중 하나의 상수를 저장하는 타입이다. 예를 들어서 요일 데이터를 갖는 타입을 만들고 싶다면 다음과 같이 작성할 수 있다.</p>\n<pre><code class=\"language-java\">public enum Weekday {MON, TUE, WED, THU, FRI, SAT, SUN};\n</code></pre>\n<p>그리고 열거타입 변수는 다음과 같은 예시처럼 선언+초기화할 수 있다.</p>\n<pre><code class=\"language-java\">Weekday today = Weekday.MON;\n</code></pre>\n<p>그리고 열거 타입도 참조 타입이기 때문에 null로 초기화할 수 있으며 객체를 참조한다.</p>\n<p>주의할 점은 열거 타입은 참조 타입이기 때문에 같은 열거 상수를 저장하는 변수는 같은 객체를 참조한다. 따라서 다음과 같은 코드는 <code>true</code>를 출력한다.</p>\n<pre><code class=\"language-java\">public enum Weekday {MON, TUE, WED, THU, FRI, SAT, SUN};\n  public static void main(String[] args){\n    Weekday today=Weekday.MON;\n    System.out.println(today==Weekday.MON);\n}\n</code></pre>",
    "excerpt": "혼자 공부하는 자바 5단원, 참조 타입 내용 정리이다.\n1. 참조 타입\n자바의 기본 타입은 byte, char, short, int, long, float, double, boolean이 있다. 하지만 이 타입의 변수만 있는 게 아니다. 앞서 다루었던 String도 기본 타입이 아니었다. 이런 타입을 참조 타입이라고 한다.\n기본 타입과의 가장 큰 차이점은 저장되는 값이다. 기본 타입의 변수들에는 실제 값이 저장된다. 하지만 참조 타입 변수들에는 메모리의 번지수,",
    "headingTree": [
      {
        "title": "1. 참조 타입",
        "url": "#1-참조-타입",
        "items": [
          {
            "title": "1.1 참조 변수의 비교",
            "url": "#11-참조-변수의-비교",
            "items": []
          },
          {
            "title": "1.2 null",
            "url": "#12-null",
            "items": []
          },
          {
            "title": "1.3 문자열 참조 변수",
            "url": "#13-문자열-참조-변수",
            "items": []
          }
        ]
      },
      {
        "title": "2. 배열",
        "url": "#2-배열",
        "items": [
          {
            "title": "2.1 배열의 선언",
            "url": "#21-배열의-선언",
            "items": []
          },
          {
            "title": "2.2 배열 길이",
            "url": "#22-배열-길이",
            "items": []
          }
        ]
      },
      {
        "title": "3. 열거형 타입",
        "url": "#3-열거형-타입",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 90
    },
    "url": "/posts/java-5",
    "thumbnail": {
      "local": "/thumbnails/java-5-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-java-5-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAg0lEQVR4nGPIysoKDAxMT0+Pjo62sbHx8PCoqqr6//8/Q2FhITMzs4mJibKy8qZNm3bu3Hnu3DmQxNKlSwMDA9evX3/jxo0fP378hwGGbdu2TZ8+/ffv3/////8NAyCJe/cf3L9//86dO2/fvoUrB0nMWbB41uzZK1asuHr1KkQTRAIAfoNqCl6TLH4AAAAASUVORK5CYII="
    }
  },
  {
    "slug": "java-7",
    "title": "중간고사 대비 java 7단원 정리",
    "date": "2022-10-19T00:00:00Z",
    "description": "중간고사 대비 JAVA 내용 정리 7단원",
    "tags": [
      "language"
    ],
    "html": "<p>혼자 공부하는 자바 7단원 상속 내용 정리</p>\n<h1>1. 상속</h1>\n<p>상속은 이미 만들어진 클래스를 재사용하여 새로운 클래스를 작성하는 것을 말한다. 자식 클래스를 선언할 때 extends 키워드로 어떤 부모 클래스를 상속할지 정의할 수 있다. 예를 들어서 다음과 같이 Person 클래스를 상속받은 Student 클래스를 만들 수 있다.</p>\n<pre><code class=\"language-java\">class Student extends Person {\n    // ...\n}\n</code></pre>\n<p>상속에서 주의해야 할 특징은 다음과 같다.</p>\n<ul>\n<li>여러 개의 부모 클래스를 상속할 수 없다.</li>\n<li>부모 클래스에서 private 접근 제한을 갖는 필드, 메소드는 상속 대상에서 제외된다. 부모와 자식이 다른 패키지에 있다면 default 접근 제한을 갖는 필드, 메소드도 상속 대상에서 제외된다.</li>\n</ul>\n<h2>1.1 부모 생성자 호출</h2>\n<p>A클래스를 상속하여 B클래스를 만들었다고 하자. 그러면 B클래스의 생성자는 A클래스의 생성자를 호출하게 된다. 부모 객체가 없이는 자식 객체도 만들어질 수 없다.</p>\n<p>이때 super 키워드를 사용한다. super 키워드는 부모 클래스의 생성자를 호출하는데 사용한다. super 키워드는 생성자의 첫 번째 문장에서만 사용할 수 있다. super 키워드를 사용하지 않으면 컴파일러가 자동으로 super()를 추가한다.</p>\n<p>super()는 부모 클래스의 기본 생성자를 호출한다. 이때 부모 클래스에 기본 생성자가 없다면 컴파일 에러가 발생한다.</p>\n<p>즉 자식 클래스의 생성자에서는 암묵적이든 명시적이든 부모 클래스 생성자를 호출해야 한다.</p>\n<pre><code class=\"language-java\">class Parent{\n  String name;\n\n  // Parent 클래스는 기본 생성자가 없기 때문에 자식 클래스에서 super()를 호출하면 오류가 발생한다.\n  Parent(String name){\n    this.name=name;\n  }\n}\n\nclass Child extends Parent{\n  Child(){\n    super(\"김성현\");\n  }\n}\n</code></pre>\n<h2>1.2 메소드 오버라이딩</h2>\n<p>부모 클래스에서 정의한 메소드를 자식 클래스에서 재정의하는 것을 메소드 오버라이딩이라고 한다. 상속된 일부 메소드를 자식 클래스에서 수정해서 사용하는 것이다.</p>\n<p>메소드 오버라이딩을 할 때는 다음과 같은 주의사항이 있다.</p>\n<ul>\n<li>부모 클래스의 메소드와 동일한 시그니처를 가져야 한다. 즉 메소드 이름, 매개변수, 리턴 타입이 같아야 한다.</li>\n<li>접근 제한을 더 강하게 할 수 없다(ex : 부모의 메소드는 public인데 자식이 오버라이딩한 메소드가 private인 등)</li>\n<li>새로운 예외를 throw할 수 없다.</li>\n</ul>\n<p>메소드가 재정의되면 자식 객체에서 그 메소드를 호출시 부모 클래스의 메소드가 아니라 자식 클래스에서 재정의한 메소드가 호출된다.</p>\n<p>함수 오버라이딩 시 선언 위에 <code>@Override</code> 어노테이션을 붙이면 컴파일러가 오버라이딩이 제대로 되었는지 확인해준다.</p>\n<p>그런데 만약 부모 클래스의 메소드를 자식 클래스에서 오버라이딩하지 않고 그대로 사용하고 싶다면 <code>super</code> 키워드를 사용하면 된다.</p>\n<pre><code class=\"language-java\">super.메소드이름(매개변수); // 부모 클래스의 메소드를 호출하게 된다.\n</code></pre>\n<h2>1.3 final 클래스</h2>\n<p>final 키워드는 클래스를 정의할 때도 <code>public final class className</code>과 같이 붙여서 사용할 수 있다. final 클래스는 상속할 수 없는 클래스이다. 예를 들어서 String 클래스가 바로 final 클래스이다.</p>\n<pre><code class=\"language-java\">// String이 final 클래스이기 때문에 상속할 수 없다는 에러가 발생한다.\nclass MyString extends String{}\n</code></pre>\n<p>메소드를 선언할 때 final 키워드를 붙이면 이 메소드가 최종적인 메소드라는 뜻이 된다. 즉 final 메소드는 자식 클래스에서 오버라이딩할 수 없다.</p>\n<h2>1.4 protected 접근 제한자</h2>\n<p>protected 접근 제한자는 클래스 내부, 같은 패키지, 그리고 다른 패키지의 자식 클래스에서 접근할 수 있다. 즉 클래스 내부에선 자유롭게 접근 가능하고, 같은 패키지 내에서도 자유롭게 접근 가능하다. 그리고 다른 패키지에 속해 있을 경우 자식 클래스에서만 접근이 가능하다.</p>\n<h1>2. 타입 변환과 다형성</h1>\n<p>다형성은 객체 지향에서 나오는 개념으로 사용 방법은 동일하지만 다양한 객체를 이용해 다양한 결과가 나오도록 하는 것이다. 이를 구현하기 위해선 메소드 오버라이딩과 타입 변환이 필요하다.</p>\n<h2>2.1 클래스의 타입 변환</h2>\n<p>클래스에서도 타입 변환이 있다. 클래스의 타입 변환은 상속 관계에 있는 클래스 사이에서 나타나는데 자식 클래스는 부모 타입으로 자동 타입 변환이 가능하다. 부모타입 변수에 자식 타입 객체를 대입할 때 발생한다.</p>\n<p>Cat 클래스가 Animal 클래스를 상속한다면 <code>Animal a=new Cat()</code> 과 같은 코드에서 Cat 객체는 Animal 타입으로 변환되어 대입된다.</p>\n<p>또한 바로 위의 부모 클래스가 아니더라도 상속 계층에서 상위 타입이면 자동 타입 변환이 일어날 수 있다.</p>\n<p>이때 주의할 점은 부모 타입으로 자동 타입변환된 뒤에는 부모 클래스에 선언된 멤버만 사용할 수 있다는 것이다. 자식 클래스에 선언된 멤버는 사용할 수 없다. 하지만 자식 클래스에서 오버라이딩한 메소드는 부모 클래스 타입으로 자동 타입 변환된 뒤에도 사용할 수 있으며 호출시 자식 클래스의 메소드가 호출된다. 재정의된 자식 클래스 메소드가 호출되는 건 다형성과 관련이 있다.</p>\n<pre><code class=\"language-java\">package study;\n\nclass Animal{\n  public void eat(){\n      System.out.println(\"Animal is eating\");\n  }\n}\n\nclass Cat extends Animal{\n  public void eat(){\n      System.out.println(\"Cat is eating\");\n  }\n\n  public void meow(){\n      System.out.println(\"Cat is meowing\");\n  }\n}\n\npublic class Hello {\n  public static void main(String[] args){\n    Cat c=new Cat();\n    Animal a = c; // c는 Animal 타입으로 형변환됨\n    a.eat(); // 자식 클래스에서 eat() 메소드가 오버라이딩 되었으므로 Cat 클래스의 eat() 메소드가 호출됨\n    c.eat(); // 당연히 Cat 클래스의 eat() 메소드가 호출됨\n    c.meow(); // Cat 클래스의 meow() 메소드가 호출됨. Animal 클래스에는 meow() 메소드가 없으므로 a.meow()로는 호출 불가\n  }\n}\n</code></pre>\n<p>이런 자동 타입 변환을 구현한 이유는 다형성을 위해서이다. 필드 타입을 부모 클래스 타입으로 선언시 다양한 자식 클래스 인스턴스들이 그 변수에 저장될 것이다. 그러면 그 필드에서 같은 메소드를 호출해도 어떤 자식 클래스 인스턴스가 대입되어 있느냐에 따라 다양한 결과를 낼 수 있다.</p>\n<h2>2.2 매개 변수 다형성</h2>\n<p>자동 타입 변환은 필드 값 대입시에도 발생하지만 주로 메소드 호출 시 많이 발생한다. 메소드의 매개변수 타입이 A클래스라면, 메소드의 매개 변수로 A클래스를 상속한 B클래스 인스턴스를 넘겨주는 등이다. 그러면 B클래스 인스턴스는 자동으로 A클래스 타입으로 변환되어 메소드의 매개 변수로 전달된다. 해당 클래스 객체뿐 아니라 자식 객체까지도 매개값으로 사용할 수 있는 것이다. 이런 자동 타입 변환을 매개 변수 다형성이라고 한다.</p>\n<p>다음 코드를 보면 같은 driver 객체에서 drive 메소드를 호출했지만 다른 결과가 나오는 것을 볼 수 있다.</p>\n<pre><code class=\"language-java\">package study;\n\nclass Vehicle{\n  public void run(){\n    System.out.println(\"Vehicle is running\");\n  }\n}\n\nclass Driver{\n  public void drive(Vehicle v){\n    v.run();\n  }\n}\n\nclass Bus extends Vehicle{\n  @Override\n  public void run(){\n    System.out.println(\"Bus is running\");\n  }\n}\n\nclass Taxi extends Vehicle{\n  @Override\n  public void run(){\n    System.out.println(\"Taxi is running\");\n  }\n}\n\n\npublic class Hello {\n  public static void main(String[] args){\n    Driver d = new Driver();\n    Bus b = new Bus();\n    Taxi t = new Taxi();\n    d.drive(b); // Bus is running\n    d.drive(t); // Taxi is running\n  }\n}\n</code></pre>\n<p>강제 타입 변환도 할 수 있다. 부모 타입을 자식 타입으로 변환하는 것이다. 하지만 모든 부모 타입 인스턴스를 자식 타입으로 변환할 수 있는 건 아니다. 자식 타입 인스턴스가 부모 타입으로 자동 타입 변환된 후 그 인스턴스를 사용할 때 강제 타입 변환을 사용할 수 있다.</p>\n<p>만약 모든 부모 타입 인스턴스를 자식 타입으로 변환할 수 있다면 자식 타입 인스턴스에만 있는 메소드를 사용할 수 없는 문제가 생기기 때문이다.</p>\n<pre><code class=\"language-java\">Parent p=new Child();\nChild c=(Child)p;\n</code></pre>\n<p>자식 타입이 부모 타입으로 자동 타입변환되었을 때는 부모 타입의 필드와 메소드만 사용 가능하다. 이때 자식에 선언된 필드, 메소드를 꼭 사용해야 할 때 다시 자식 타입으로 강제 타입 변환을 하는 것이다.</p>\n<p>강제 타입 변환은 자식 타입이 부모 타입으로 변환되어 있는 상태에서만 가능하다. 그래서 주의할 점은 강제 타입 변환을 하기 전에 반드시 instanceof 연산자로 자식 타입으로 변환할 수 있는지 확인해야 한다. 다음과 같이 확인하는 것이다. 그렇게 하지 않으면 ClassCastException이 발생한다.</p>\n<pre><code class=\"language-java\">if(p instanceof Child){\n  Child c=(Child)p;\n}\n</code></pre>\n<h1>3. 추상 클래스</h1>\n<p>객체를 직접 생성할 수 있는 클래스를 실체 클래스라 한다면 그 공통 특성을 추출해 선언한 걸 추상 클래스라 한다. 추상 클래스를 상속하여 실체 클래스를 만드는 것이다. 예를 들어서 Bird, Tiger, Fish 클래스의 공통된 필드, 메소드를 따로 선언한 Animal 클래스를 먼저 만들고 Bird, Tiger, Fish 클래스가 Animal 클래스를 상속받는 것이다.</p>\n<p>이런 추상 클래스를 선언하는 이유는 다음과 같다.</p>\n<ul>\n<li>공통된 필드와 메소드 이름을 통일하여 일관성을 유지할 수 있다.</li>\n<li>실체 클래스를 작성할 때 시간을 절약할 수 있다.</li>\n</ul>\n<p>추상 클래스를 선언할 때는 클래스 선언에 <code>abstract</code>를 붙여야 한다. 이 키워드가 붙은 클래스는 new를 이용해서 객체를 만들지 못하고 상속을 통해 자식 클래스만 만들 수 있다.</p>\n<p>단 추상 클래스도 필드, 메소드, 생성자 선언을 할 수 있다. 생성자가 있으므로 자식 클래스 생성자에서도 super(매개변수)를 이용해서 부모 클래스의 생성자를 호출해야 한다.</p>\n<p>추상 클래스는 실체 클래스가 공통적으로 가져야 할 필드와 메소드를 정의해 놓은 추상 클래스다. 따라서 모든 자식 클래스가 가진 메소드의 내용이 같다면 추상 클래스에 메소드를 작성하는 게 좋다.</p>\n<p>하지만 메소드 선언만 공통이고 내용은 자식마다 달라야 할 수 있다. 그러면 추상 클래스에 추상 메소드를 선언할 수 있다. 추상 메소드는 메소드 선언부만 있고 메소드 내용이 없는 메소드다. 추상 메소드를 선언하면 자식 클래스에서 반드시 메소드 내용을 작성해야 한다. 자식 클래스에서 추상 메소드 재정의를 하지 않을 시 컴파일 에러가 발생한다.</p>\n<pre><code class=\"language-java\">[접근 제한자] abstract [리턴타입] [메소드명](매개변수)\n</code></pre>",
    "excerpt": "혼자 공부하는 자바 7단원 상속 내용 정리\n1. 상속\n상속은 이미 만들어진 클래스를 재사용하여 새로운 클래스를 작성하는 것을 말한다. 자식 클래스를 선언할 때 extends 키워드로 어떤 부모 클래스를 상속할지 정의할 수 있다. 예를 들어서 다음과 같이 Person 클래스를 상속받은 Student 클래스를 만들 수 있다.\nclass Student extends Person {\n    // ...\n}\n\n상속에서 주의해야 할 특징은 다음과 같다.\n\n여러 개의 부모 ",
    "headingTree": [
      {
        "title": "1. 상속",
        "url": "#1-상속",
        "items": [
          {
            "title": "1.1 부모 생성자 호출",
            "url": "#11-부모-생성자-호출",
            "items": []
          },
          {
            "title": "1.2 메소드 오버라이딩",
            "url": "#12-메소드-오버라이딩",
            "items": []
          },
          {
            "title": "1.3 final 클래스",
            "url": "#13-final-클래스",
            "items": []
          },
          {
            "title": "1.4 protected 접근 제한자",
            "url": "#14-protected-접근-제한자",
            "items": []
          }
        ]
      },
      {
        "title": "2. 타입 변환과 다형성",
        "url": "#2-타입-변환과-다형성",
        "items": [
          {
            "title": "2.1 클래스의 타입 변환",
            "url": "#21-클래스의-타입-변환",
            "items": []
          },
          {
            "title": "2.2 매개 변수 다형성",
            "url": "#22-매개-변수-다형성",
            "items": []
          }
        ]
      },
      {
        "title": "3. 추상 클래스",
        "url": "#3-추상-클래스",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 261
    },
    "url": "/posts/java-7",
    "thumbnail": {
      "local": "/thumbnails/java-7-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-java-7-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAiElEQVR4nD3KoQ0DIRSAYZLrND17dQyAwjICGotiBWyvokkNDvcSBAkT4HANzEBygqTiNbRpf/v9RErJOZdSCiEopYwxrTUiEmPMspy27bKuZwAIIeScJwCAUgoAYoxjDPxFUkrWWu+9c+44jtenCc/aaq2ttd77f59wuz+u++6cK6Ug4ndHxDc582ixicWISgAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "java-6",
    "title": "중간고사 대비 java 6단원 정리",
    "date": "2022-10-18T00:00:00Z",
    "description": "중간고사 대비 JAVA 내용 정리 6단원",
    "tags": [
      "language"
    ],
    "html": "<p>혼자 공부하는 자바 6단원, 클래스 관련 내용 정리</p>\n<h1>1. 객체 지향 프로그래밍</h1>\n<h2>1.1 객체</h2>\n<p>객체는 속성과 동작으로 구성되어 있다. 이때 속성을 필드, 동작을 메소드라고 보통 부른다. 객체 모델링이란 현실의 객체의 동작을 추려내서 소프트웨어 객체의 필드, 메소드로 정의하는 것이다. 또한 현실 속의 현상들을 객체 간의 상호작용(메시지를 통해서 일어난다)으로 표현하는 것이다.</p>\n<h2>1.2 클래스</h2>\n<p>객체를 만들기 위해서는 틀이 필요하다. 자바에서는 이 틀이 클래스이다. 클래스에는 객체를 생성하기 위한 필드, 메서드가 정의되어 있고 이 클래스를 통해 만들어진 객체를 인스턴스라 한다.</p>\n<p>이때 클래스는 한 파일 내에 여러 개 선언할 수 있는데 이를 컴파일할 시 바이트코드 파일은 선언된 클래스의 개수만큼 생긴다.</p>\n<p>주의할 점은 클래스 선언시 public으로 선언된 클래스의 이름은 파일명과 같아야 된다는 점이다. 클래스를 생성할 때는 new 연산자를 사용한다.</p>\n<pre><code class=\"language-java\">// Student.java\npackage study;\n\npublic class Student {\n  String name;\n}\n\n// Hello.java\npackage study;\n\npublic class Hello {\n\n  public static void main(String[] args){\n    Student s1=new Student();\n    s1.name=\"김성현\";\n    System.out.println(s1.name);\n  }\n}\n</code></pre>\n<h2>1.3 클래스의 구성 요소</h2>\n<p>클래스의 구성 요소는 필드, 생성자, 메소드가 있다. 이때 생성자는 클래스 이름과 같은 이름을 가지며 리턴 타입이 없는 메소드이다. 생성자는 객체를 생성할 때 호출되며 객체가 생성될 때 필드의 초기화를 담당한다.</p>\n<h1>2. 필드</h1>\n<p>필드는 객체의 속성을 나타내며 생성자 선언과 메소드 선언의 앞, 뒤 어디서든 선언할 수 있다. 또한 기본 타입과 참조 타입 모두 될 수 있다. 초기값은 필드 선언 시 주어질 수도 있고 생략될 수도 있다. 만약 생략되면 기본값이 주어지는데 기본 타입은 0, 참조 타입은 null이다.</p>\n<h1>3. 생성자</h1>\n<p>생성자는 new연산자로 클래스에서 객체를 생성할 때 호출되어 객체를 초기화한다. 생성자가 실행되어 객체가 초기화되면 객체는 힙 영역 메모리에 생성된다.</p>\n<p>만약 사용자가 생성자를 선언하지 않았다면 컴파일시 기본 생성자가 자동으로 추가된다. 하지만 클래스에 명시적으로 선언한 생성자가 하나라도 있다면 기본 생성자는 추가되지 않는다. 이 말은 반대로 말하면 클래스에 생성자가 명시적으로 선언되어 있다면 반드시 선언된 생성자를 호출해서 객체를 생성해야 한다는 뜻이다.</p>\n<h2>3.1 필드 초기화</h2>\n<p>클래스 필드 초기화는 클래스에서 필드 선언 시 초기값을 주거나 생성자에서 초기값을 주는 2가지 방법이 있다.</p>\n<p>이때 생성자는 여러 가지의 인수를 받는 다양한 형태로 오버로딩될 수 있다. new로 객체를 생성할 때 생성자에 전달하는 인수의 형태에 따라 호출되는 생성자가 달라진다. 이를 생성자 오버로딩이라 한다.</p>\n<p>이때 생성자 오버로딩이 많아질 경우 생성자 간 중복 코드가 많아지게 된다. 따라서 생성자 오버로딩을 사용할 때는 중복 코드를 줄이기 위해 this()를 사용하는 것이 좋다. this(매개변수) 는 생성자 내에서 클래스의 다른 생성자를 호출하는 것이다. 주의할 점은 this()는 생성자의 첫 줄에서만 허용된다는 것이다.</p>\n<h1>4. 메소드</h1>\n<p>클래스 메소드는 선언부와 실행 블록으로 구성되며 함수의 선언과 비슷하다. 메소드 선언부를 메소드 시그니처라고 한다.</p>\n<p>메소드 시그니처는 메소드 이름, 매개변수 목록, 리턴 타입으로 구성된다. 메소드 시그니처는 메소드를 호출할 때 사용되며 메소드 이름과 매개변수 목록이 일치해야 호출할 수 있다. 리턴 타입은 메소드의 실행 결과를 반환할 때 사용된다.</p>\n<h2>4.1 매개변수 목록</h2>\n<p>어떤 상황에서는 메소드를 선언할 때 매개변수 개수가 미정일 수도 있다. 이런 경우를 해결하는 방법은 2가지가 있다.</p>\n<ol>\n<li>매개변수를 배열 타입으로 선언</li>\n<li>...을 이용해서 매개변수를 가변인자로 선언</li>\n</ol>\n<p>2번 방식을 이용할 경우 메소드를 호출하기 전에 굳이 배열을 생성하지 않아도 되는 이점이 생긴다. 즉 가변인자는 배열 타입의 매개변수보다 메소드를 호출할 때 편리하다.</p>\n<pre><code class=\"language-java\">package study;\n\npublic class Computer {\n  int sum1(int[] values){\n    int sum=0;\n    for(int i=0;i&#x3C;values.length;i++){\n      sum+=values[i];\n    }\n    return sum;\n  }\n\n  int sum2(int ...values){\n    int sum=0;\n    for(int i=0;i&#x3C;values.length;i++){\n      sum+=values[i];\n    }\n    return sum;\n  }\n}\n</code></pre>\n<h2>4.2 메소드 오버로딩</h2>\n<p>클래스 내에 같은 이름의 메소드를 여러 개 선언하는 걸 메소드 오버로딩이라 한다. 이때 이름이 같은 메소드는 매개변수 타입, 개수, 순서 중 하나 이상이 달라야 한다. 리턴 타입만 다른 것, 그리고 매개변수의 이름이 다른 것은 같은 메소드로 취급되는 것에 주의한다.</p>\n<h1>5. 인스턴스 멤버와 정적 멤버</h1>\n<p>클래스의 필드와 메소드는 당연히 모든 클래스 인스턴스에 포함되어 있어야 한다. 하지만 모든 클래스가 공유하는 어떤 필드나 메소드가 필요할 수도 있다. 이런 경우에는 클래스의 인스턴스 멤버가 아닌 정적 멤버로 선언한다. 인스턴스 멤버는 객체마다 가지고 있는 멤버를 말하며 정적 멤버는 클래스에 포함되어 모든 인스턴스가 공유하는 멤버를 말한다.</p>\n<p>이때 객체 내부에서 인스턴스 멤버에 접근하게 위해서는 this라는 키워드를 사용한다. 반면 정적 멤버에 접근할 때는 클래스 이름을 사용한다.</p>\n<h2>5.1 정적 멤버와 static</h2>\n<p>정적 멤버는 클래스에 고정된 멤버로 객체를 생성하지 않고도 사용할 수 있는 필드와 메소드이다. 정적 필드와 정적 메소드를 선언하기 위해서는 static 키워드를 사용한다.</p>\n<p>정적 필드, 정적 메소드는 클래스에 고정된 멤버이므로 클래스가 메모리에 로딩될 때 생성된다. 따라서 클래스 로딩이 끝나면 바로 사용할 수 있다.</p>\n<p>인스턴스마다 다르게 가지고 있어야 하는 값은 인스턴스 필드로 선언하고, 모든 인스턴스가 공유해야 하는 값은 정적 필드로 선언한다. 메소드를 어떻게 선언할지의 기준은 인스턴스 필드를 가지고 있는 메소드인지에 따라 달라진다. 인스턴스 필드를 포함한다면 인스턴스 메소드로, 인스턴스 필드를 포함하지 않는다면 정적 메소드로 선언한다.</p>\n<h2>5.2 정적 멤버 사용</h2>\n<p>정적 멤버는 클래스가 메모리에 로딩되면 바로 사용할 수 있다. 클래스 이름을 통해 접근한다.</p>\n<pre><code class=\"language-java\">// Calculator.java\npackage study;\n\npublic class Calculator {\n  static double pi=3.141592;\n  static int plus(int x, int y){\n    return x+y;\n  }\n  static int minus(int x, int y){\n    return x-y;\n  }\n}\n// Hello.java\npackage study;\n\npublic class Hello {\n\n  public static void main(String[] args){\n    int res=Calculator.plus(10,20);\n    System.out.println(Calculator.pi);\n    System.out.println(res);\n  }\n}\n</code></pre>\n<p>정적 필드, 정적 메소드는 클래스 이름을 통해 접근해야 하지만, 인스턴스를 통해서도 접근 가능하다. 물론 원칙적으로는 클래스 이름을 통한 접근이 좋다.</p>\n<p>주의할 점은 정적 멤버는 객체가 없어도 실행되기 때문에 정적 메소드 선언시 정적 메소드 내부에 인스턴스 필드나 인스턴스 메소드를 사용할 수 없다. 객체 자신을 참조하는 this도 사용할 수 없다. 정적 메소드 내부에서 인스턴스 필드나 인스턴스 메소드를 사용하려면 객체를 먼저 생성해야 한다.</p>\n<p>이는 <code>main</code>메소드에서도 마찬가지다. main도 정적 메소드이기 때문에 인스턴스 필드, 인스턴스 메소드를 main에서 바로 사용할 수 없다.</p>\n<pre><code class=\"language-java\">package study;\n\npublic class Hello {\n  int temp;\n  public static void main(String[] args){\n    // 정적 메소드 main에서 인스턴스 변수 temp에 접근 불가 - 에러\n    temp=1;\n  }\n}\n</code></pre>\n<h2>5.3 final 필드와 상수</h2>\n<p>final 필드는 최종적인 필드라는 뜻이다. 즉 한 번 값을 할당하면 변경할 수 없는 필드이다. 프로그램 실행 도중에 더 수정할 수 없다. 따라서 이 final 필드는 필드 선언 시에 주거나 생성자에서 초기화해야 한다. 만약 생성자까지 실행되고도 초기화되지 않은 final 필드가 있다면 컴파일 에러가 발생한다.</p>\n<p>하지만 final 필드는 생성자를 통해 초기화될 수도 있으므로 절대 바뀌지 않는 <code>상수</code>라고 하기에는 부족한 감이 있다. static final 필드가 되어야 상수라고 한다.</p>\n<h1>6. 패키지와 접근 제한자</h1>\n<p>패키지의 물리적인 형태는 파일 시스템의 폴더이다. 하지만 패키지는 폴더 기능뿐 아니라 클래스의 일부분의 기능도 한다. 클래스를 유일하게 만들어주는 식별자 역할을 하는 것이다. 클래스 이름이 같아도 패키지가 다르면 다른 클래스로 인식한다. 패키지가 클래스 식별에도 역할을 하는 것이다.</p>\n<h2>6.1 패키지 가져오기</h2>\n<p>사용하고자 하는 패키지의 클래스나 인터페이스가 다른 패키지에 소속되어 있다면 패키지를 가져와야 한다. 패키지를 가져오는 방법은 <code>import</code>문을 사용하는 것이다. <code>import</code>문은 패키지 선언문과 클래스 선언문 사이에 작성한다. <code>import</code>문은 패키지 이름을 포함한 클래스 이름을 작성한다.</p>\n<pre><code class=\"language-java\">import 상위패키지.하위패키지.클래스명;\n</code></pre>\n<p>주의할 점은 상위 패키지를 import했다고 하위 패키지까지 전부 import되는 건 아니라는 것이다.</p>\n<p>또한 서로 다른 패키지에 동일한 이름의 클래스가 존재하고 두 클래스를 모두 사용하고 싶다면 클래스 이름 앞에 패키지 이름을 붙여서 사용하면 된다.</p>\n<h2>6.2 접근 제한자</h2>\n<p>접근 제한자는 클래스, 필드, 메소드, 생성자의 접근 범위를 제한하는 역할을 한다. 접근 제한자는 <code>public</code>, <code>protected</code>, <code>default</code>, <code>private</code>가 있다.</p>\n<ul>\n<li><code>public</code> : 접근 제한이 전혀 없다. 어디서든 접근이 가능하다.</li>\n<li><code>protected</code> : 같은 패키지 또는 자식 클래스에서 사용이 가능하다.</li>\n<li><code>private</code> : 같은 클래스 내에서만 사용이 가능하다.</li>\n<li><code>default</code> : 같은 패키지 내에서만 사용이 가능하고 다른 패키지에선 접근할 수 없다. 위 3가지 접근 제한자를 제외한 나머지는 default 접근 제한자이다.</li>\n</ul>\n<p>이 접근 제한자는 생성자에도 사용 가능하다. 그런데 클래스에 생성자를 선언하지 않았을 때 컴파일러에서 추가하는 기본 생성자가 있다. 이 기본 생성자의 접근 제한은 클래스의 접근 제한과 동일하다. 예를 들어 클래스의 접근 제한이 <code>public</code>이면 기본 생성자의 접근 제한도 <code>public</code>이다.</p>\n<h2>6.3 getter와 setter</h2>\n<p>oop에서는 객체 필드를 객체 외부에서 직접 접근하는 것을 막는 경우가 많다. 객체 필드를 외부에서 마음대로 변경할 경우 객체의 무결성이 깨질 수 있기 때문이다.</p>\n<p>그래서 객체 필드를 외부에서 직접 접근할 수는 없도록 막고 외부에서 접근할 수 있는 통로로서 getter와 setter메소드를 제공한다. 메소드는 매개변수를 검증하여 유효한 값만 객체 필드로 저장할 수 있기 때문이다.</p>\n<p>따라서 클래스를 선언할 때 필드는 <code>private</code>로 선언해서 외부 직접 접근을 막고 getter와 setter 메소드를 public으로 선언하여 제공하는 게 좋다.</p>",
    "excerpt": "혼자 공부하는 자바 6단원, 클래스 관련 내용 정리\n1. 객체 지향 프로그래밍\n1.1 객체\n객체는 속성과 동작으로 구성되어 있다. 이때 속성을 필드, 동작을 메소드라고 보통 부른다. 객체 모델링이란 현실의 객체의 동작을 추려내서 소프트웨어 객체의 필드, 메소드로 정의하는 것이다. 또한 현실 속의 현상들을 객체 간의 상호작용(메시지를 통해서 일어난다)으로 표현하는 것이다.\n1.2 클래스\n객체를 만들기 위해서는 틀이 필요하다. 자바에서는 이 틀이 클래스이다. 클래스",
    "headingTree": [
      {
        "title": "1. 객체 지향 프로그래밍",
        "url": "#1-객체-지향-프로그래밍",
        "items": [
          {
            "title": "1.1 객체",
            "url": "#11-객체",
            "items": []
          },
          {
            "title": "1.2 클래스",
            "url": "#12-클래스",
            "items": []
          },
          {
            "title": "1.3 클래스의 구성 요소",
            "url": "#13-클래스의-구성-요소",
            "items": []
          }
        ]
      },
      {
        "title": "2. 필드",
        "url": "#2-필드",
        "items": []
      },
      {
        "title": "3. 생성자",
        "url": "#3-생성자",
        "items": [
          {
            "title": "3.1 필드 초기화",
            "url": "#31-필드-초기화",
            "items": []
          }
        ]
      },
      {
        "title": "4. 메소드",
        "url": "#4-메소드",
        "items": [
          {
            "title": "4.1 매개변수 목록",
            "url": "#41-매개변수-목록",
            "items": []
          },
          {
            "title": "4.2 메소드 오버로딩",
            "url": "#42-메소드-오버로딩",
            "items": []
          }
        ]
      },
      {
        "title": "5. 인스턴스 멤버와 정적 멤버",
        "url": "#5-인스턴스-멤버와-정적-멤버",
        "items": [
          {
            "title": "5.1 정적 멤버와 static",
            "url": "#51-정적-멤버와-static",
            "items": []
          },
          {
            "title": "5.2 정적 멤버 사용",
            "url": "#52-정적-멤버-사용",
            "items": []
          },
          {
            "title": "5.3 final 필드와 상수",
            "url": "#53-final-필드와-상수",
            "items": []
          }
        ]
      },
      {
        "title": "6. 패키지와 접근 제한자",
        "url": "#6-패키지와-접근-제한자",
        "items": [
          {
            "title": "6.1 패키지 가져오기",
            "url": "#61-패키지-가져오기",
            "items": []
          },
          {
            "title": "6.2 접근 제한자",
            "url": "#62-접근-제한자",
            "items": []
          },
          {
            "title": "6.3 getter와 setter",
            "url": "#63-getter와-setter",
            "items": []
          }
        ]
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 194
    },
    "url": "/posts/java-6",
    "thumbnail": {
      "local": "/thumbnails/java-6-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-java-6-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAgklEQVR4nE3JoQ0DIRSAYTzz4N8EyOfYAMUAT7FGe6Ki11yKJiFhBhI0Oa4bIFAImkuTtr/8P2aMQUSttVIKAKSURDTnZFprzjkACCG89yGElNIJzjlEtNYSUa11zjnGOCHG+FjX3nsppbX2g7LXvdbXcXzuN7bc7pfr8ty2nPM/vAFQ22k8eQhaFAAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "java-8",
    "title": "중간고사 대비 java 8단원 정리",
    "date": "2022-10-19T01:00:00Z",
    "description": "중간고사 대비 JAVA 내용 정리 7단원",
    "tags": [
      "language"
    ],
    "html": "<p>혼자 공부하는 자바 8단원 인터페이스 정리</p>\n<h1>1. 인터페이스</h1>\n<p>인터페이스는 개발 코드와 객체가 서로 통신하는 접점 역할을 한다. 개발 코드가 인터페이스의 메소드를 호출하면 인터페이스가 객체의 메소드를 호출하는 것이다. 즉 개발 코드에선 인터페이스 메소드만 가지고 있으면 된다.</p>\n<p>인터페이스를 쓰는 이유는 개발 코드를 수정하지 않고 사용하는 객체를 변경하게 할 수 있도록 하게 위해서이다. 인터페이스를 사용하면 개발 코드는 인터페이스에 정의된 메소드만 호출하면 되기 때문에 객체를 변경해도 개발 코드를 수정할 필요가 없다.</p>\n<h2>1.1 인터페이스 선언</h2>\n<p>인터페이스는 클래스와 물리적 형태가 동일하지만 class 대신 <code>interface</code> 키워드를 사용한다.</p>\n<pre><code class=\"language-java\">public interface [인터페이스명]{}\n</code></pre>\n<p>인터페이스는 클래스처럼 객체를 생성하는 것이 아니다. 객체의 사용 규칙을 정의하는 것이다. 따라서 인터페이스는 객체를 생성하지 않기 때문에 생성자가 없다. 그리고 인터페이스는 객체를 생성하지 않기 때문에 필드와 메소드의 구현부를 가질 수 없다. 또 인터페이스 객체 같은 건 없기 때문에 this와 super를 사용할 수 없다. 상수 필드와 추상 메소드만을 구성 요소로 가진다.</p>\n<ul>\n<li>상수 필드 선언하기</li>\n</ul>\n<p>인터페이스는 인스턴스나 정적 필드를 선언할 수 없다. 상수 필드만 선언할 수 있는데 이런 상수는 앞서 보았듯 <code>public static final</code>을 붙여야 한다. 만약 이를 생략하더라도 컴파일 과정에서 자동으로 붙게 된다. 또한 상수는 선언과 동시에 초기화해야 한다.</p>\n<ul>\n<li>추상 메소드 선언하기</li>\n</ul>\n<p>인터페이스를 통해 호출된 메소드는 결국 객체에서 실행된다. 따라서 인터페이스 메소드는 실행 블록 없이 추상 메소드로 선언된다. 이렇게 인터페이스의 추상 메소드는 <code>public abstract</code>로 선언되어야 한다. 만약 이를 생략하더라도 컴파일 과정에서 자동으로 붙게 된다.</p>\n<p>인터페이스는 개발 코드의 메소드 호출을 객체의 메소드 호출로 연결해주는 역할만 하면 되기 때문이다.</p>\n<h2>1.2 인터페이스 구현</h2>\n<p>개발 코드가 인터페이스 메소드를 호출시 인터페이스는 객체 메소드를 호출하게 된다. 따라서 인터페이스를 구현하는 객체는 인터페이스의 모든 메소드를 구현해야 한다. 이를 위해 인터페이스를 구현하는 클래스는 <code>implements</code> 키워드를 사용한다. 이렇게 인터페이스의 내용을 구현하는 클래스를 구현 클래스라고 한다.</p>\n<pre><code class=\"language-java\">public class MyClass implements MyInterface {\n  //MyInterface에 정의된 추상 메소드의 실체 메소드를 구현해야 한다.\n    @Override\n    public void method1() {\n        System.out.println(\"MyClass-method1() 실행\");\n    }\n\n    @Override\n    public void method2() {\n        System.out.println(\"MyClass-method2() 실행\");\n    }\n}\n</code></pre>\n<p>이때 인터페이스로 구현 객체를 사용하려면 인터페이스 변수를 선언하고 구현 객체를 대입해야 한다. 그러면 인터페이스 변수는 구현 객체의 번지를 저장하게 된다.</p>\n<pre><code class=\"language-java\">MyInterface myInterface = new MyClass();\n</code></pre>\n<h2>1.3 다중 인터페이스 구현</h2>\n<p>객체는 다수의 인터페이스 타입으로 사용할 수 있다.</p>\n<pre><code class=\"language-java\">public class MyClass implements interfaceA, interfaceB{}\n</code></pre>\n<p>위와 같은 경우 MyClass는 A, B 인터페이스의 모든 메소드를 구현해야 한다. 모든 인터페이스의 추상 메소드에 대해 실체 메소드를 작성해야 하는 것이다.</p>\n<p>그렇게 되면 interfaceA, interfaceB 변수 둘 모드에 MyClass 객체를 대입할 수 있다.</p>\n<h2>1.4 인터페이스의 사용</h2>\n<p>클래스를 선언할 때 인터페이스는 필드, 생성자, 메소드 매개변수, 생성자나 메소드의 로컬변수로 선언될 수 있다. 이렇게 인터페이스 타입으로 선언된 부분들에는 인터페이스의 구현 객체가 들어갈 수 있다. 어떤 구현 객체가 들어가느냐에 따라서 인터페이스에서 호출한 메소드가 어떤 클래스의 메소드로 연결되는지가 달라진다.</p>\n<h1>2. 타입 변환과 다형성</h1>\n<p>프로그램을 개발시 인터페이스를 통해 메소드를 호출하게 했다면 구현 객체만 변경하면 호출되는 메소드가 달라지게 할 수 있다. 따라서 프로그램의 실행 결과를 쉽게 다양하게 조절할 수 있다. 이것이 바로 다형성이다. 또한 구현 객체는 인터페이스 타입으로 자동 타입 변환될 수 있다. 하지만 인터페이스 타입 변수에서 메소드를 호출할 시 대입된 구현 객체 클래스의 메소드가 호출된다.</p>\n<h2>2.1 매개 변수 다형성</h2>\n<p>자동 타입 변환은 필드 값 대입보다는 메소드 호출시 매개변수를 통해서 많이 발생한다. 인터페이스를 통한 다형성의 경우, 매개 변수를 인터페이스 타입으로 선언하고 호출 시에는 구현 객체를 대입하는 것이다.</p>\n<p>그러면 메소드를 호출할 때는 매개 변수에 인터페이스의 구현 객체를 넣어 줄 수 있다. 그 구현 객체가 어떤 클래스인지에 따라 메소드의 동작이 달라질 수 있다. 메소드 호출 시 어떤 구현 객체를 주느냐에 따라 메소드의 실행 결과가 달라지는 것이다.</p>\n<h2>2.2 인터페이스 강제 타입 변환</h2>\n<p>구현 객체를 인터페이스 타입으로 자동 타입 변환하면 인터페이스에 선언된 메소드만 호출할 수 있다. 만약 인터페이스에 3개의 메소드가 선언되어 있고 메소드 매개변수가 인터페이스 타입으로 선언되어 있다면, 그 메소드에 인터페이스의 어떤 구현 객체를 넘겨주는지에 상관없이(구현 객체에는 메소드가 5개 있더라도) 인터페이스에 선언된 3개의 메소드만 호출할 수 있다.</p>\n<p>그러나 인터페이스 타입을 구현 객체 타입으로 강제 타입 변환하면 구현 객체에 선언된 메소드도 호출할 수 있다. 이렇게 인터페이스 타입을 구현 객체 타입으로 강제 타입 변환하는 것을 인터페이스 타입의 다운 캐스팅이라고 한다.</p>\n<p>이때 강제 타입 변환은 구현 객체가 인터페이스 타입으로 자동 타입 변환되어 있는 상태에서만 가능하다. 그러나 어떤 구현 객체가 변환되어 있는지 모르는 상태에서 강제 타입 변환을 하면 컴파일 에러가 발생한다. 이런 경우에는 instanceof 연산자를 사용하여 구현 객체가 인터페이스 타입으로 자동 타입 변환되어 있는지 확인한 후에 강제 타입 변환을 해야 한다. 상속에서와 마찬가지이다.</p>\n<pre><code class=\"language-java\">if(vehicle instanceof Bus) {\n    Bus bus = (Bus) vehicle;\n}\n</code></pre>\n<h1>3. 인터페이스 상속</h1>\n<p>인터페이스도 다른 인터페이스를 상속할 수 있다. 클래스 상속과 마찬가지로 <code>extends</code>키워드를 사용한다. 그리고 클래스 상속과 달리 다중 상속이 허용된다.</p>\n<p>이때 자식 인터페이스를 구현하는 클래스는 자식뿐 아니리 부모(상위)인터페이스의 모든 추상 메소드에 대한 구현 메소드를 가지고 있어야 한다. 그래서 구현 클래스에서 인스턴스 생성 후 하위/상위 인터페이스 타입으로 형변환도 가능하다.</p>\n<p>주의할 점은 상위 인터페이스로 타입 변환될 시, 상위 인터페이스에 선언된 메소드만 사용 가능하다는 것이다. 하위 인터페이스에 선언된 메소드는 사용할 수 없다.</p>",
    "excerpt": "혼자 공부하는 자바 8단원 인터페이스 정리\n1. 인터페이스\n인터페이스는 개발 코드와 객체가 서로 통신하는 접점 역할을 한다. 개발 코드가 인터페이스의 메소드를 호출하면 인터페이스가 객체의 메소드를 호출하는 것이다. 즉 개발 코드에선 인터페이스 메소드만 가지고 있으면 된다.\n인터페이스를 쓰는 이유는 개발 코드를 수정하지 않고 사용하는 객체를 변경하게 할 수 있도록 하게 위해서이다. 인터페이스를 사용하면 개발 코드는 인터페이스에 정의된 메소드만 호출하면 되기 때문에",
    "headingTree": [
      {
        "title": "1. 인터페이스",
        "url": "#1-인터페이스",
        "items": [
          {
            "title": "1.1 인터페이스 선언",
            "url": "#11-인터페이스-선언",
            "items": []
          },
          {
            "title": "1.2 인터페이스 구현",
            "url": "#12-인터페이스-구현",
            "items": []
          },
          {
            "title": "1.3 다중 인터페이스 구현",
            "url": "#13-다중-인터페이스-구현",
            "items": []
          },
          {
            "title": "1.4 인터페이스의 사용",
            "url": "#14-인터페이스의-사용",
            "items": []
          }
        ]
      },
      {
        "title": "2. 타입 변환과 다형성",
        "url": "#2-타입-변환과-다형성",
        "items": [
          {
            "title": "2.1 매개 변수 다형성",
            "url": "#21-매개-변수-다형성",
            "items": []
          },
          {
            "title": "2.2 인터페이스 강제 타입 변환",
            "url": "#22-인터페이스-강제-타입-변환",
            "items": []
          }
        ]
      },
      {
        "title": "3. 인터페이스 상속",
        "url": "#3-인터페이스-상속",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 62
    },
    "url": "/posts/java-8",
    "thumbnail": {
      "local": "/thumbnails/java-8-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-java-8-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAiklEQVR4nGMoLCz08/NLSUmJjo62sbHx8PCoqqr6//8/Q0pKCjMzs42NjYaGxrZt23bu3Hnu3DmQxPr1621sbFpaWg4cOPDjx4//MMBw/Pjxmqqa6dOnr169+suXL7/BACRx+87d+/cfPH78+OPHj3DlIIk5CxZPmzlzxYoVV69e/f//P0T5////AZnJZuOgSgeeAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "java-9",
    "title": "혼자 공부하는 자바 9단원 정리",
    "date": "2022-11-11T01:00:00Z",
    "description": "중첩 클래스와 중첩 인터페이스",
    "tags": [
      "language"
    ],
    "html": "<p>자바 중간고사가 끝났다. 그 뒤에는 응용 프로그래밍을 배우고 있다. 하지만 '혼자 공부하는 자바' 책 내용이 아직 남았기 때문에 그것을 정리하고 있다. 이번에는 9단원 중첩 클래스와 중첩 인터페이스에 대해 정리한다.</p>\n<p>객체 지향 프로그래밍에서 클래스들은 서로 상호작용한다. 이때 어떤 클래스는 특정 클래스와만 관계를 맺게 되는데 이 경우 클래스 내부에 클래스를 선언할 수 있다.</p>\n<h1>1. 중첩 클래스</h1>\n<p>중첩 클래스는 말 그대로 클래스 내부에 선언한 클래스이다. 이러면 외부에는 불필요한 관계 클래스를 감출 수 있다.</p>\n<pre><code class=\"language-java\">class Outer {\n    class Inner {\n        //내부 클래스\n    }\n}\n</code></pre>\n<p>이때 클래스의 멤버로 선언되는 중첩 클래스는 멤버 클래스, 생성자나 메소드 내부에서 선언되는 중첩 클래스를 로컬 클래스라 한다. 로컬 클래스는 메소드 실행시에만 사용되고 메소드 종료시 사라진다.</p>\n<p>//static 접근에 관한 내용 todo</p>\n<p>중첩 클래스도 컴파일시 바이트코드 파일 .class파일이 생성된다.</p>\n<h2>1.1 인스턴스 멤버 클래스</h2>\n<p>인스턴스 멤버 클래스는 static 키워드 없이 중첩 선언된 클래스이다. 이 클래스에는 정적 필드와 메소드는 선언할 수 없다.</p>\n<pre><code class=\"language-java\">class A{\n  // B 클래스가 인스턴스 멤버 클래스\n  class B{\n    B(){\n      System.out.println(\"B\");\n    }\n    int a;\n    void print(){\n      System.out.println(\"in classB\");\n    }\n    static int c; //에러. 정적 필드는 인스턴스 멤버 클래스에 선언 불가능\n  }\n}\n</code></pre>\n<p>A 클래스 외부에서 B 클래스를 사용하려면 A 클래스의 인스턴스를 생성해야 한다.</p>\n<pre><code class=\"language-java\">A a=new A();\nA.B b=a.new B();\n</code></pre>\n<p>A 클래스 내부에서는 A 객체 없이 B 객체를 생성할 수 있다. 단 B클래스는 A 클래스 내부의 클래스이므로 A 클래스 내부에서만 사용하는 게 일반적이다.</p>\n<p>만약 인스턴스 멤버 클래스에 static 필드를 선언하려고 시도할 시 'The field [변수명] cannot be declared static in a non-static inner type, unless initialized with a constant expression' 이라는 오류가 뜬다.</p>\n<p>인스턴스 멤버 클래스에 정적 멤버가 선언 불가능한 이유는 있을 이유가 없고 모호해질 수 있는 가능성이 있기 때문이다.</p>\n<p>먼저 클래스에 정적 멤버가 있는 이유는 인스턴스 생성 없이 클래스 자체에 속한 어떤 데이터를 정의하기 위함인데 인스턴스 멤버 클래스는 애초에 상위 인스턴스가 있기 때문에 멤버 클래스 자체에 속한 데이터를 정의할 이유가 없다.</p>\n<p>또한 정적 멤버는 클래스 자체에 귀속되어서 모든 클래스 인스턴스에 대해서 공유되지만 인스턴스 멤버 클래스는 상위 인스턴스에 귀속되기 때문에 정적 멤버가 있으면 모호해질 수 있다.</p>\n<pre><code class=\"language-java\">class A{\n  class B{\n    static int BMember;\n  }\n}\n</code></pre>\n<p>인스턴스 멤버 클래스에 정적 멤버가 있을 수 있다고 가정하고 위와 같은 코드가 있다고 하자. 그리고 A 클래스의 인스턴스 2개를 만들고 BMember의 값을 각각 바꾸었다.</p>\n<pre><code class=\"language-java\">A a1=new A();\nA a2=new A();\na1.B.BMember=1;\na2.B.BMember=2;\n</code></pre>\n<p>이렇게 하면 BMember의 값은 무엇이 되어야 하는가? 같은 B 클래스이므로 나중에 대입한 2가 되어야 하는가 아니면 a1의 B와 a2의 B는 서로 다른 클래스이므로 1과 2가 되어야 하는가?</p>\n<p>같은 B클래스라고 가정하면 a1과 a2는 다른 인스턴스인데 같은 인스턴스 멤버 클래스를 갖기 때문에 이상하고 a1,a2의 B가 다른 B클래스라고 가정하면 BMember는 정적 멤버인데 a1.B.BMember와 a2.B.BMember가 다른 값을 갖는지가 이상하다.</p>\n<p>이런 모호함이 생길 수 있기 때문에 인스턴스 멤버 클래스에 정적 멤버를 선언할 수 없다.</p>\n<h2>1.2 정적 멤버 클래스</h2>\n<p>정적 멤버 클래스는 static 키워드가 붙어서 선언된 클래스이다. 이 클래스에는 모든 종류의 필드와 모든 종류 메소드를 선언할 수 있다.</p>\n<pre><code class=\"language-java\">class A{\n  A(){\n    System.out.println(\"A\");\n  }\n  static class C{\n    C(){\n      System.out.println(\"C\");\n    }\n    int a;\n    static int b;\n    void print(){\n      System.out.println(\"in classC\");\n    }\n  }\n}\n</code></pre>\n<p>정적 멤버 클래스의 객체 생성은 상위 클래스의 객체 생성 없이도 가능하다.</p>\n<pre><code class=\"language-java\">A.C c = new A.C();\nc.print();\n</code></pre>\n<h2>1.3 로컬 클래스</h2>\n<p>로컬 클래스는 메소드 내부에 선언된 클래스이다. 로컬 클래스는 메소드 내부에서만 사용할 수 있으며 메소드가 종료되면 메모리에서 사라진다. 따라서 접근 제한자나 static을 붙일 수 없다. 어차피 메소드 내에서만 사용되기 때문이다. 같은 이유로 인스턴스 필드와 메소드만 선언할 수 있고 정적 멤버는 선언할 수 없다.</p>\n<pre><code class=\"language-java\">class A{\n  // B 클래스가 인스턴스 멤버 클래스\n  A(){\n    System.out.println(\"A\");\n  }\n\n  void method(){\n    // 로컬 클래스\n    class D{\n      D(){\n        System.out.println(\"D\");\n      }\n      int a;\n      void print(){\n        System.out.println(\"in classD\");\n      }\n    }\n    D d = new D();\n    d.print();\n  }\n}\n</code></pre>\n<p>로컬 클래스는 상위 클래스의 메소드 내에서 사용된다. 특정 메소드를 선언하면 그 클래스가 사용되는 것이다.</p>\n<pre><code class=\"language-java\">A a = new A();\n// method 내부에서 D 클래스 사용\na.method();\n</code></pre>\n<h2>1.4 중첩 클래스 접근 제한</h2>\n<h3>1.4.1 바깥 클래스에서 멤버 클래스 접근</h3>\n<p>바깥 클래스에서 멤버 클래스를 사용할 때는 몇 가지 제한이 있다. 상식적으로 생각해 보면 당연한 제한이 대부분이다.</p>\n<ul>\n<li>인스턴스 멤버 클래스 객체는 바깥 클래스의 인스턴스 필드와 메소드에서만 생성할 수 있다.</li>\n<li>정적 멤버 클래스 객체는 바깥 클래스의 모든 필드와 메소드에서 생성할 수 있다.</li>\n</ul>\n<p>인스턴스 멤버 클래스는 말 그대로 바깥 클래스의 인스턴스에 소속된 것이므로 인스턴스가 있어야만 쓸 수 있다. 따라서 바깥 클래스의 인스턴스 필드와 메소드에서만 생성할 수 있는 것이 당연하다.</p>\n<p>반면 정적 멤버 클래스는 바깥 클래스 그 자체에 속한 것이므로 바깥 클래스의 모든 곳에서 인스턴스를 생성할 수 있다.</p>\n<h3>1.4.2 멤버 클래스에서 바깥 클래스 접근</h3>\n<ul>\n<li>인스턴스 멤버 클래스에선 바깥 클래스의 모든 필드와 메소드에 접근할 수 있다.</li>\n<li>정적 멤버 클래스에서는 바깥 클래스의 정적 필드, 정적 메소드에만 접근할 수 있다.</li>\n</ul>\n<p>인스턴스 멤버 클래스는 각 인스턴스별로 있으므로 클래스 자체에 소속된 정적 멤버에는 당연히 접근할 수 있다.</p>\n<p>반면 정적 멤버 클래스는 바깥 클래스의 인스턴스와는 관계가 없으므로 바깥 클래스의 인스턴스 필드와 메소드에는 접근할 수 없다.</p>\n<pre><code class=\"language-java\">class A{\n  // B 클래스가 인스턴스 멤버 클래스\n  int field1;\n  static int field2;\n  void method1(){\n    System.out.println(\"A instance method1()\");\n  }\n  static void method2(){\n    System.out.println(\"A static method2()\");\n  }\n\n  class B{\n    void method(){\n      field1 = 10;\n      field2 = 10;\n      method1();\n      method2();\n    }\n  }\n\n  static class C{\n    void method(){\n      // 정적 멤버에만 접근 가능\n      // field1 = 10;\n      field2 = 10;\n      // method1();\n      method2();\n    }\n  }\n}\n</code></pre>\n<h3>1.4.3 로컬 클래스에서 바깥 클래스 멤버 접근</h3>\n<p>메소드의 매개변수 혹은 로컬 변수를 로컬 클래스에서 사용할 때가 있을 수 있다. 로컬 클래스는 메소드 내에서만 존재하므로 메소드가 종료될 시 로컬 클래스도 사라지는 게 일반적이다. 그러나 스레드의 경우 메소드가 종료되어도 로컬 스레드 객체가 실행 상태로 존재할 수 있다.</p>\n<p>이런 부분을 막기 위해 자바는 컴파일 시 로컬 클래스에서 사용하는 매개변수와 로컬 변수를 final로 선언한다. 즉 로컬 클래스 내에서 매개 변수나 로컬 변수를 변경할 수 없다. 만약 final로 선언되어 있지 않더라도 자동으로 final로 선언된다.</p>\n<p>만약 이를 어기고 로컬 클래스 내에서 매개 변수나 로컬 변수를 변경하려고 하면 컴파일 에러가 발생한다. 'Local variable [변수명] defined in an enclosing scope must be final or effectively final' 이라는 에러로, 해당 변수는 final이거나 final과 같은 효과를 가져야 한다는 뜻이다. 즉 로컬 클래스 내에서 매개 변수나 로컬 변수를 변경하지 말라는 뜻이다.</p>\n<h3>1.4.4 중첩 클래스에서 바깥 클래스 참조하기</h3>\n<p>클래스 내부에서 <code>this</code>는 객체 스스로를 참조한다. 하지만 중첩 클래스에서 바깥 클래스의 참조가 필요할 때가 있다. 바깥 클래스의 메소드를 사용하는 등이다. 그럴 때는 바깥 클래스의 이름을 this 앞에 붙여 주면 된다.</p>\n<pre><code class=\"language-java\">class A{\n  String field=\"Outter field\";\n  void method(){\n    System.out.println(\"Outter class\");\n  }\n\n  class B{\n    String field=\"Inner field\";\n    void method(){\n      System.out.println(\"Inner class\");\n    }\n    void print (){\n      System.out.println(this.field);\n      this.method();\n      System.out.println(A.this.field);\n      A.this.method();\n    }\n  }\n}\n</code></pre>\n<p>그리고 다음과 같은 코드를 메인 함수에서 실행해 본다.</p>\n<pre><code class=\"language-java\">A a = new A();\nA.B b = a.new B();\nb.print();\n</code></pre>\n<p>결과는 다음과 같다.</p>\n<pre><code>Inner field\nInner class\nOutter field\nOutter class\n</code></pre>\n<h1>2. 중첩 인터페이스</h1>\n<p>중첩 인터페이스는 클래스 멤버로 선언된 인터페이스이다. 인스턴스 멤버 인터페이스와 정적 멤버 인터페이스 모두 가능하다. 접근 같은 경우 중첩 클래스와 동일하다.</p>\n<p>주로 UI 프로그래밍에서 이벤트 처리 목적으로 많이 쓰인다.</p>\n<h1>3. 익명 객체</h1>\n<p>익명 객체는 이름이 없는 객체이다. 익명 객체는 어떤 클래스를 상속하거나 인터페이스를 구현해야 한다. 일반적인 경우 명시적으로 클래스 이름을 주고 선언한다. 하지만 익명 객체는 부모 클래스나 인터페이스를 상속하거나 구현하는 익명 클래스를 선언하고, 그 클래스의 인스턴스를 생성하는 것을 동시에 한다. 따라서 익명 객체는 클래스 이름이 없으며 부모 클래스나 인터페이스를 구현해야 한다.</p>\n<h2>3.1 익명 자식 객체</h2>\n<p>일반적으로 특정 클래스의 자식 객체를 생성할 땐 다음과 같이 한다. 먼저 부모 클래스와 그것을 상속한 자식 클래스를 선언한다.</p>\n<pre><code class=\"language-java\">class Parent{\n  Parent(){\n    System.out.println(\"Parent Constructor\");\n  }\n}\n\nclass Child extends Parent{\n  Child(){\n    System.out.println(\"Child Constructor\");\n  }\n}\n</code></pre>\n<p>그리고 다음과 같이 자식 객체를 생성한다.</p>\n<pre><code class=\"language-java\">Parent a=new Child();\n</code></pre>\n<p>하지만 자식 클래스가 재사용되지 않고 특정 위치에서 한 번만 사용되는 경우에는 간단히 익명 객체를 사용할 수 있다. 다음과 같이 익명 객체를 생성한다.</p>\n<pre><code class=\"language-java\">class Parent{\n  Parent(){\n    System.out.println(\"Parent Constructor\");\n  }\n\n  void method(){\n    System.out.println(\"Parent method\");\n  }\n}\n\n// 익명 객체를 선언해 사용하는 부분\nParent a=new Parent(){\n  @Override\n  void method(){\n    System.out.println(\"Child method\");\n  }\n};\na.method();\n</code></pre>\n<p>보통 익명 객체 내에서는 부모 클래스의 메소드를 재정의한다. 그리고 익명 객체 내에서는 생성자를 선언할 수 없다. 익명 객체 생성시 넣은 인자가 부모 클래스 생성자에 넣어져서 부모 클래스 생성자가 호출될 뿐이다.</p>\n<p>이런 익명 객체는 로컬 변수를 선언할 때의 초기값, 메소드의 인자로 넘겨줄 때, 메소드의 리턴값으로 사용할 때 등 웬만한 곳에 모두 사용할 수 있다.</p>\n<p>이때 주의할 점은 익명 객체는 부모 클래스 타입 변수에 대입되기 때문에 익명 객체에 새롭게 정의된 필드, 메소드는 익명 객체 외부에서 접근할 수 없다. 원래라면 부모 클래스 타입 변수를 자식 클래스 타입으로 형변환하는 방식으로 사용할 수도 있겠지만 익명 객체는 이름이 없기 때문에 자식 클래스 타입 변환도 불가능하다.</p>\n<pre><code class=\"language-java\">Parent a=new Parent(){\n  @Override\n  void method(){\n    System.out.println(\"Child method\");\n  }\n  // 부모 클래스에 없는 메소드\n  void method2(){\n    System.out.println(\"Child method, second\");\n  }\n};\na.method();\na.method2(); //에러. 익명 객체에 새로 정의된 메소드를 외부에서 호출할 수 없다.\n</code></pre>\n<h2>3.2 익명 구현 객체</h2>\n<p>인터페이스 타입의 구현 객체를 생성할 때는 일반적으로 인터페이스 선언 -> 인터페이스의 구현 클래스 선언 -> 구현 객체 생성의 과정을 거친다. 하지만 이 과정을 생략하고 인터페이스를 구현한 익명 구현 객체를 생성할 수도 있다.</p>\n<p>예시로 Person 인터페이스를 선언하고 그 익명 구현 객체를 만들어 보았다. 이때 익명 구현 객체는 인터페이스에 선언된 모든 추상 메소드를 구현해야 한다.</p>\n<pre><code class=\"language-java\">interface Person{\n  public void setName(String name);\n  public String getName();\n}\n\n// 익명 구현 객체 선언과 사용\nPerson me=new Person(){\n  String name;\n  @Override\n  public void setName(String name){\n    this.name=name;\n  }\n  @Override\n  public String getName(){\n    return name;\n  }\n};\nme.setName(\"witch\");\nSystem.out.println(me.getName());\n</code></pre>\n<p>이런 방식으로 익명 객체를 필드 선언, 로컬 변수 선언, 메소드의 인자로 넘겨주기, 메소드의 리턴값으로 사용할 수 있다. 익명 구현 객체도 메소드 인자로 들어갈 수 있다!</p>\n<h2>3.3 익명 객체에서 로컬 변수 사용</h2>\n<p>익명 객체는 메소드 실행이 종료되면 보통 없어진다. 하지만 익명 스레드 객체를 사용할 때는 익명 객체가 메소드 실행이 종료되어도 계속 살아있다.</p>\n<p>이때 메소드의 매개 변수나 로컬 변수를 이러한 익명 객체 내에서 사용하면 문제가 발생한다. 매개변수, 로컬 변수는 메소드 실행이 끝나면 메모리에서 사라지기 때문에 메소드가 끝나도 익명 객체가 살아있는 경우 이 변수들을 사용할 수 없어진다.</p>\n<p>자바는 따라서 컴파일시 익명 객체에서 쓰는 매개 변수, 로컬 변수를 익명 객체에 복사해두고 사용한다. 그리고 매개 변수, 로컬 변수가 수정되면 익명객체의 값과 일관성이 사라지므로 매개변수, 로컬 변수를 final로 선언하도록 강제한다. 만약 그렇게 하지 않으면 java8부터는 final을 자동으로 붙여 준다.</p>\n<p>다음과 같은 코드는 매개변수나 로컬 변수를 변경하지 않으므로 정상적으로 작동한다.</p>\n<pre><code class=\"language-java\">//인터페이스\ninterface Calculate{\n  public int sum_args();\n  public int sum_locals();\n}\n</code></pre>\n<pre><code class=\"language-java\">class Anonymous{\n  public void method(int arg1, int arg2){\n    int b1=3;\n    int b2=4;\n\n    // 익명 구현 객체 사용\n    Calculate calc=new Calculate() {\n      @Override\n      public int sum_args() {\n        return arg1+arg2;\n      }\n      @Override\n      public int sum_locals() {\n        return b1+b2;\n      }\n    };\n    // 매개변수 합\n    System.out.println(calc.sum_args());\n    // 로컬 변수 합\n    System.out.println(calc.sum_locals());\n  }\n}\n</code></pre>\n<p>하지만 익명 객체에서 사용하는 로컬 변수를 변경하면 컴파일 에러가 발생한다.</p>\n<pre><code class=\"language-java\">class Anonymous{\n  public void method(int arg1, int arg2){\n    int b1=3;\n    int b2=4;\n\n    /* 익명 객체에서 사용하는 매개변수 혹은 로컬 변수를 변경하는 시도는 모두 에러 발생\n    자동으로 final로 취급되는 것들이기 때문\n    arg1=10;\n    arg2=20;\n\n    b1=30;\n    b2=40;\n    */\n\n    Calculate calc=new Calculate() {\n      @Override\n      public int sum_args() {\n        return arg1+arg2;\n      }\n      @Override\n      public int sum_locals() {\n        return b1+b2;\n      }\n    };\n    // 매개변수 합\n    System.out.println(calc.sum_args());\n    // 로컬 변수 합\n    System.out.println(calc.sum_locals());\n  }\n}\n</code></pre>\n<h1>참고</h1>\n<p>인스턴스 멤버 클래스에 정적 멤버 변수가 있을 수 없는 이유 <a href=\"https://stackoverflow.com/questions/1953530/why-does-java-prohibit-static-fields-in-inner-classes\">https://stackoverflow.com/questions/1953530/why-does-java-prohibit-static-fields-in-inner-classes</a></p>",
    "excerpt": "자바 중간고사가 끝났다. 그 뒤에는 응용 프로그래밍을 배우고 있다. 하지만 '혼자 공부하는 자바' 책 내용이 아직 남았기 때문에 그것을 정리하고 있다. 이번에는 9단원 중첩 클래스와 중첩 인터페이스에 대해 정리한다.\n객체 지향 프로그래밍에서 클래스들은 서로 상호작용한다. 이때 어떤 클래스는 특정 클래스와만 관계를 맺게 되는데 이 경우 클래스 내부에 클래스를 선언할 수 있다.\n1. 중첩 클래스\n중첩 클래스는 말 그대로 클래스 내부에 선언한 클래스이다. 이러면 외부",
    "headingTree": [
      {
        "title": "1. 중첩 클래스",
        "url": "#1-중첩-클래스",
        "items": [
          {
            "title": "1.1 인스턴스 멤버 클래스",
            "url": "#11-인스턴스-멤버-클래스",
            "items": []
          },
          {
            "title": "1.2 정적 멤버 클래스",
            "url": "#12-정적-멤버-클래스",
            "items": []
          },
          {
            "title": "1.3 로컬 클래스",
            "url": "#13-로컬-클래스",
            "items": []
          },
          {
            "title": "1.4 중첩 클래스 접근 제한",
            "url": "#14-중첩-클래스-접근-제한",
            "items": [
              {
                "title": "1.4.1 바깥 클래스에서 멤버 클래스 접근",
                "url": "#141-바깥-클래스에서-멤버-클래스-접근",
                "items": []
              },
              {
                "title": "1.4.2 멤버 클래스에서 바깥 클래스 접근",
                "url": "#142-멤버-클래스에서-바깥-클래스-접근",
                "items": []
              },
              {
                "title": "1.4.3 로컬 클래스에서 바깥 클래스 멤버 접근",
                "url": "#143-로컬-클래스에서-바깥-클래스-멤버-접근",
                "items": []
              },
              {
                "title": "1.4.4 중첩 클래스에서 바깥 클래스 참조하기",
                "url": "#144-중첩-클래스에서-바깥-클래스-참조하기",
                "items": []
              }
            ]
          }
        ]
      },
      {
        "title": "2. 중첩 인터페이스",
        "url": "#2-중첩-인터페이스",
        "items": []
      },
      {
        "title": "3. 익명 객체",
        "url": "#3-익명-객체",
        "items": [
          {
            "title": "3.1 익명 자식 객체",
            "url": "#31-익명-자식-객체",
            "items": []
          },
          {
            "title": "3.2 익명 구현 객체",
            "url": "#32-익명-구현-객체",
            "items": []
          },
          {
            "title": "3.3 익명 객체에서 로컬 변수 사용",
            "url": "#33-익명-객체에서-로컬-변수-사용",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 2,
      "wordCount": 551
    },
    "url": "/posts/java-9",
    "thumbnail": {
      "local": "/thumbnails/java-9-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-java-9-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAfUlEQVR4nGNITEw0Nja2t7fn5eUPDg62t7dXU1NzcnJi8PT0FBERuQAGO3fuvHLlypEjRw4cOMAwe/Zse3v7VatW/f79+z8SYNi2dWtiYmJZWfmZM2cgQr/BgOHGrdv3799//Pjx+/fvUXRMmjqzq7tn3rx5Fy5cgCiHSAAArihlOdZwDvgAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "javascript-11",
    "title": "모던 자바스크립트 튜토리얼 part 1.6 함수 심화학습",
    "date": "2023-01-20T00:00:00Z",
    "description": "ko.javascript.info part 1-6 첫번째",
    "tags": [
      "javascript"
    ],
    "html": "<h1>1. 재귀와 스택</h1>\n<p>재귀 함수는 자기 반복적인 구조를 가진 함수를 작성할 때 아주 좋다. 예를 들어서 팩토리얼 함수를 작성할 때 재귀 함수를 사용하면 아래와 같이 작성할 수 있다.</p>\n<pre><code class=\"language-js\">function factorial(n) {\n  return n ? n * factorial(n - 1) : 1;\n}\n</code></pre>\n<p>그럼 이런 재귀 함수는 실제 js에서 어떻게 작동하는 걸까? 실행 컨텍스트가 이용된다. 이에 관한 글은 <a href=\"https://www.witch.work/javascript-execution-context/\">여기</a>에 정리하였다.</p>\n<h1>2. 나머지 매개변수와 spread</h1>\n<p>나머지 매개변수를 통해 인수의 개수를 무제한으로 전달할 수 있다. 그리고 나머지 매개변수에는 그 앞의 매개변수들을 제외한 나머지 인수들이 배열 형태로 모인다.</p>\n<p>유사 배열 객체인 arguments를 사용해도 인덱스를 사용해 인수에 접근 가능하다. 그러나 이는 배열이 아니라 유사 배열 객체고 이터러블이라 반복은 가능하지만 배열 메서드를 쓸 수 없다. 또한 인수 전체를 담아 버리므로 특정 인수들만 나머지에 담는 것이 불가능하다. 그리고 화살표 함수는 arguments를 지원하지 않는다.</p>\n<h2>2.1. 스프레드에 대해</h2>\n<p>스프레드 문법은 이터러블에 사용될 수 있다. 스프레드는 for..of와 같은 방식으로 내부의 이터레이터를 호출하여 요소를 수집한다. 단 특정 객체를 배열로 바꿀 땐 <code>Array.from</code>이 더 많이 쓰인다. 스프레드 문법은 내부의 이터레이터를 호출하므로 이터러블에만 사용할 수 있는데, <code>Array.from</code>은 이터러블뿐 아니라 유사 배열 객체에도 쓰일 수 있기 때문이다.</p>\n<p>그런데 스프레드 문법을 직접 써 보면 객체에도 쓸 수 있는 것을 발견할 수 있다.</p>\n<pre><code class=\"language-js\">let a={a:1, b:2, c:3};\nlet aCopy={...a};\nconsole.log(a===aCopy);\n</code></pre>\n<p>이상하다..단순 객체는 이터러블이 아닌데..왜 이럴까? 이는 스프레드 프로퍼티 프로포절에 객체 리터럴에 대해서도 스프레드 문법을 사용할 수 있도록 제안되었고 이게 받아들여졌기 때문이다. 이 내용은 <a href=\"https://www.witch.work/javascript-spread-object/\">다른 글</a>에 정리하였다.</p>\n<h1>3. 변수의 유효범위와 클로저</h1>\n<p>JS는 함수 지향 언어이고 함수 또한 객체로 취급한다. 따라서 함수의 동적 생성이나 함수를 인수로 넘기기 등이 가능하다. 이때 함수와 외부의 상호작용에 대해 좀더 알아본다.</p>\n<p>참고로 여기서는 let, const에 대해서만 다룬다. var에 대해서는 추후에 다룰 것이라고 한다.</p>\n<h2>3.1 코드 블록</h2>\n<p>코드 블록은 중괄호로 묶인 부분을 말한다. 이런 블록은 특정 작업을 수행하는 코드를 한데 묶어두는 용도로 사용되며 변수 스코프로도 사용된다.</p>\n<p>이때 let의 경우는 블록 레벨 스코프를 사용하므로 동일한 스코프에 let으로 변수를 여러 번 선언하면 에러가 발생한다.</p>\n<pre><code class=\"language-js\">let msg = \"hello\";\nconsole.log(msg);\n// Identifier 'msg' has already been declared\nlet msg = \"hello\";\n</code></pre>\n<h2>3.2. 렉시컬 환경</h2>\n<p>JS에서 함수는 객체이므로 당연히 함수에서 반환될 수도 있다. 이런 걸 이용할 수도 있다. 예를 들어서 다음과 같이 활용 가능하다.</p>\n<pre><code class=\"language-js\">function addNumber(n) {\n  return function (x) {\n    return x + n;\n  };\n}\n\nlet add3 = addNumber(3);\nconsole.log(add3(5)); // 8\n</code></pre>\n<p>그런데 만약 <code>addNumber</code>를 통해 함수를 여러 개 만들었을 때 이 함수들은 서로 다른 객체일까? 만약 addNumber 내에 어떤 변수가 있었다면 이 변수는 <code>addNumber</code>가 리턴하는 함수들 내에서 어떤 값을 가질 것인가? 이런 질문에 대한 답은 렉시컬 환경이 준다.</p>\n<p>JS에서는 실행 중인 함수, 코드 블록, 그리고 전역 스크립트는 렉시컬 환경이라 불리는 숨겨진 연관 객체를 갖는다. 즉 각 스코프는 자신이 가지고 있는 정보들을 담은 객체를 가지고 있는 것이다. 이 렉시컬 환경 객체는 환경 레코드와 외부 렉시컬 환경 참조로 구성된다.</p>\n<p>환경 레코드는 스코프가 가지는 모든 지역 변수와 this값 등의 기타 정보를 저장한다. 변수는 이 환경 레코드의 프로퍼티이고 변수를 조작하는 것은 환경 레코드의 프로퍼티를 조작하는 것이다. 그리고 외부 렉시컬 환경 참조는 말 그대로 외부 렉시컬 환경 객체에 대한 참조를 저장한다.</p>\n<h3>3.2.1. 변수와 렉시컬 환경</h3>\n<p>let과 const로 저장된 변수는 스크립트가 시작될 때 엔진에 인식되고 렉시컬 환경에 올라간다. 그러나 특수한 상태인 uninitialized 상태가 되어서 let, const로 선언되기 전에는 변수에 접근할 수 없다.</p>\n<p>예를 들어 다음과 같은 코드를 보자. 주석으로 변수의 저장과 외부 렉시컬 환경 참조를 설명하였다.</p>\n<pre><code class=\"language-js\">/* \n전역 렉시컬 환경\n외부 렉시컬 환경은 없으므로 외부 렉시컬 환경 참조는 null을 가리키고 있다\n지역 변수 a와 그 값 1을 프로퍼티 a:1로 저장\n*/\nlet a=1;\nif(a===1){\n  /*\n  외부 렉시컬 환경 참조는 전역 렉시컬 환경을 가리킨다\n  지역 변수 b와 그 값 2를 저장\n  */\n  let b=2;\n  console.log(b);\n}\n</code></pre>\n<p>코드가 실행되고 실행 흐름이 한 줄씩 나아가면서 렉시컬 환경은 변화한다. 예를 들어서 변수 <code>a</code>를 선언하면 렉시컬 환경에서 a는 undefined로 저장될 것이다. 그리고 실행 흐름 상에서 a에 1을 저장하면 렉시컬 환경에서 a는 1로 변화할 것이다.</p>\n<p>다음 코드를 보고 실행 흐름에 따른 렉시컬 환경 변화를 보자.</p>\n<pre><code class=\"language-js\">/*\n스크립트 시작. 스크립트에서 선언한 변수 전체가 렉시컬 환경에 올라가고 값은 특수한 상태인 uninitialized 상태가 된다. 엔진이 변수들을 인지하긴 하지만 let으로 선언되기 전까지는 해당 변수에 접근할 수 없다\n*/\nlet a, b;\n/*\na,b가 선언되었고 아직 값 할당이 안 되었으므로 프로퍼티의 값은 undefined. \n*/\na=1;\n/* a에 값이 할당되었다. 전역 렉시컬 환경에 이 값이 저장된다. */\n</code></pre>\n<p>하지만 <code>var</code>로 선언된 변수의 경우 스크립트의 시작 시점에 초기화되어 렉시컬 환경에 올라가고 undefined로 초기화된다. 따라서 실제로 코드를 작성할 때 <code>var</code>로 선언된 변수들은 마치 모두 스크립트의 최상단에 선언된 것과 같이 쓰일 수 있다.</p>\n<pre><code class=\"language-js\">/* 코드에선 a의 선언 전이지만 a의 선언이 \n이미 스크립트 시작 시점에 처리되어 a를 사용할 수 있다 */\na = 2;\nconsole.log(a); // 2\n\nvar a = 1;\n</code></pre>\n<h3>3.2.2. 함수와 렉시컬 환경</h3>\n<p>함수 또한 하나의 값처럼 취급되므로 렉시컬 환경에 저장되어 있다. 변수와 비슷하다.</p>\n<p>그러나 함수 선언문으로 선언한 함수의 경우 var가 그랬던 것과 같이 렉시컬 환경의 생성과 함께 초기화된다. 따라서 아직 함수 선언문에 도달하지 못했더라도 렉시컬 환경이 만들어지는 즉시 사용할 수 있다.</p>\n<pre><code class=\"language-js\">// foo는 함수 선언문으로 선언되었으므로 바로 사용 가능\nfoo();\n\nfunction foo() {\n    console.log(\"hi\");\n}\n</code></pre>\n<p>이때 함수 선언문으로 선언된 함수만 이렇게 렉시컬 환경 생성과 동시에 초기화된다. 함수 표현식으로 선언한 함수는 선언 이전에 사용할 수 없다.</p>\n<p>또한 함수를 호출해 실행하면 새로운 렉시컬 환경이 만들어진다. 여기에는 함수의 지역변수와 외부 렉시컬 환경에 대한 참조뿐 아니라 함수 호출 시 넘겨받은 매개변수도 저장된다.</p>\n<p>그런데 함수 내에서 어떤 변수에 접근한다고 하자. 그러면 먼저 내부 렉시컬 환경에서 그 변수를 검색한다. 외부 변수와 같은 이름의 내부 변수가 있으면 그 이름의 변수에 접근 시 내부 변수에 접근하게 되는 이유가 이것이다.</p>\n<p>만약 내부 렉시컬 환경에서 원하는 변수를 찾지 못할 시 검색 범위를 외부 렉시컬 환경으로 확장해 가며 검색한다. 이 검색은 검색 범위가 전역 렉시컬 환경이 될 때까지 반복된다.</p>\n<h3>3.2.3. 함수 생성과 렉시컬 환경</h3>\n<p>함수를 생성하는 함수를 보자. 좀더 간소화하였다.</p>\n<pre><code class=\"language-js\">function foo() {\n    let t = 0;\n\n    return function () {\n        return t++;\n    }\n}\n</code></pre>\n<p><code>foo()</code>를 호출하면 호출시마다 새로운 렉시컬 환경이 만들어진다. 함수 호출시마다 실행 컨텍스트가 콜스택에 쌓이고 거기에는 렉시컬 환경이 포함되어 있는 것을 생각해 볼 때 당연한 이야기이다.</p>\n<p>그럼 <code>foo</code>가 리턴하는 중첩 함수의 렉시컬 환경은 어떻게 될까? 모든 함수는 함수가 생성된 곳의 렉시컬 환경 참조를 숨김 프로퍼티인 <code>[[Environment]]</code>로 갖는다. 이는 함수가 생성될 때 딱 한 번 값이 변경되고 영원히 변하지 않는다.</p>\n<pre><code class=\"language-js\">function foo() {\n    let t = 0;\n\n    return function () {\n        return t++;\n    }\n}\n\nlet t1 = foo();\nlet t2 = foo();\n// 0 1 2 0 1 출력. t1이 가진 Environment와 t2가 가진 Environment가 독립임을 확인 가능하다\nconsole.log(t1());\nconsole.log(t1());\nconsole.log(t1());\nconsole.log(t2());\nconsole.log(t2());\n</code></pre>\n<p>즉 위 코드의 <code>t1, t2</code>의 Environment에는 foo()가 함수를 생성하고 리턴할 당시의 외부 렉시컬 환경, foo의 지역변수 t가 값 0을 가지는 환경에 대한 참조가 저장되어 있다. 자신이 생긴 곳의 렉시컬 환경 참조를 갖는 것이다.</p>\n<p>그럼 t1, t2를 실행하면 어떻게 될까? 먼저 자기 자신의 렉시컬 환경에서 <code>t</code>를 찾는다. 그러나 자신의 렉시컬 환경엔 t가 없다. 따라서 외부 렉시컬 환경인 foo에서 찾게 된다. 이때 이렇게 외부 변수에 접근할 땐 <code>[[Environment]]</code>를 사용한다. 그게 참조하고 있는 렉시컬 환경에 있는 t를 찾아서 0을 리턴하고 t를 1로 바꾸는 것이다.</p>\n<p>이렇게 외부 변수를 기억하고 접근할 수 있는 함수를 클로저라고 하는데, js는 모든 함수에 Environment 숨김 프로퍼티가 있으므로 모든 함수가 클로저다.</p>\n<p>이를 보여주는 또 하나의 예제는 다음과 같다.</p>\n<pre><code class=\"language-js\">function print() {\n  let a = \"김성현\";\n  return function () {\n    console.log(a); // 김성현\n  };\n}\n\nlet a = \"김성현2\";\n\nlet p = print();\np();\n</code></pre>\n<p>p의 생성시에 기억된, p 생성 당시의 렉시컬 환경에서 a를 먼저 찾기 때문에 이런 일이 발생하는 것이다.</p>\n<h2>3.3. 메모리 GC와 클로저</h2>\n<p>함수 호출이 끝나면 해당 함수 호출로 생성된 렉시컬 환경은 메모리에서 제거된다. 더 이상 그 환경에 도달할 수 없기 때문이다.</p>\n<p>하지만 호출된 함수 내에서 함수를 만들어서 리턴한다면, 리턴된 함수의 <code>[[Environment]]</code>가 호출된 함수의 렉시컬 환경을 참조하고 있을 것이다. 따라서 함수 호출이 종료되어도 렉시컬 환경이 메모리에서 제거되지 않는다.</p>\n<p>이렇게 렉시컬 환경이 메모리에서 제거되지 않음으로 인해 메모리 누수가 발생할 수 있다.</p>\n<p>예를 들어서 다음 코드를 보자.</p>\n<pre><code class=\"language-js\">function addNumber(n) {\n  return function (x) {\n    return x + n;\n  };\n}\n// addOne, addTwo, addThree는\n// 모두 그 생성된 렉시컬 환경을 독립적으로 기억한다\nlet addOne = addNumber(1);\nlet addTwo = addNumber(2);\nlet addThree = addNumber(3);\n\nconsole.log(addOne(1)); // 2\nconsole.log(addTwo(1)); // 3\nconsole.log(addThree(1)); // 4\n</code></pre>\n<p>위 코드에서 <code>addNumber</code>함수의 호출이 끝난 이후에도 <code>addOne</code>, <code>addTwo</code>, <code>addThree</code>가 내부 Environment 프로퍼티에서 각각의 렉시컬 환경을 기억하고 있기 때문에 <code>addNumber</code>가 호출되면서 만들어진 렉시컬 환경들은 메모리에서 제거되지 않는다.</p>\n<p>물론 addOne, addTwo 등의 함수가 메모리에서 제거되면 그게 생성될 때 기억되었던 addNumber의 렉시컬 환경도 제거될 것이다.</p>\n<h3>3.3.1. V8의 메모리 최적화</h3>\n<p>그런데 V8엔진 같은 경우 변수 사용을 분석하고 외부 변수가 사용되지 않는다고 판단되면 이를 메모리에서 제거하는 최적화 프로세스가 있다.</p>\n<pre><code class=\"language-js\">let val = \"global\";\n\nfunction f() {\n  let val = \"local\";\n  function g() {\n    debugger;\n    /* 이때 실행이 멈춘 상태에서 val 변수는\n    V8에 의해 최적화된다. 그런데 val은 아무데서도 사용되지\n    않았음로 삭제되어 val을 콘솔에서 출력하려는 시도는 실패한다 */\n  }\n  return g;\n}\n\nlet foo = f();\nfoo();\n</code></pre>\n<h2>3.4. 클로저 예시</h2>\n<h3>3.4.1. 카운터</h3>\n<pre><code class=\"language-js\">function Counter() {\n  this.count = 0;\n\n  this.increment = function () {\n    return ++this.count;\n  };\n\n  this.decrement = function () {\n    return --this.count;\n  };\n}\n\nlet counter = new Counter();\n// 1 2 3 2\nconsole.log(counter.increment());\nconsole.log(counter.increment());\nconsole.log(counter.increment());\nconsole.log(counter.decrement());\n</code></pre>\n<p>이 예제의 increment, decrement 함수는 모두 카운터를 잘 작동시킨다. 두 함수 모두 동일한 렉시컬 환경을 가지고 같은 count변수를 공유하기 때문이다.</p>\n<h3>3.4.2. 보이는 변수</h3>\n<pre><code class=\"language-js\">let x = 1;\n\nfunction func() {\n  console.log(x);\n  let x = 2;\n}\n\nfunc();\n</code></pre>\n<p>다음 코드에서 x에 접근하려는 시도는 에러를 발생시킨다.</p>\n<pre><code>Uncaught ReferenceError: Cannot access 'x' before initialization\n</code></pre>\n<p><code>func</code>함수가 호출될 때 새로운 렉시컬 환경이 만들어진다. 그리고 이 환경이 처음 만들어질 때 스크립트 중에 지역변수 <code>x</code>가 선언된 것을 엔진이 감지하고 x를 <code>&#x3C;uninitialized></code>로 초기화한다.</p>\n<p>그리고 <code>console.log(x)</code>가 실행되면서 <code>x</code>에 접근하려는 시도가 이뤄지는데, 이때 <code>x</code>는 uninitialized 상태이기 때문에 let 이전에 접근할 수 없다. 따라서 위 코드는 에러가 발생하는 게 당연하다.</p>\n<h3>3.4.3. 반복문으로 함수 만들기</h3>\n<pre><code class=\"language-js\">function makeFunction() {\n  let funcs = [];\n\n  let i = 0;\n  while (i &#x3C; 3) {\n    funcs[i] = function () {\n      console.log(i);\n    };\n    i++;\n  }\n  return funcs;\n}\n\nlet funcs = makeFunction();\n// 모두 3이 나온다\nfuncs[0]();\nfuncs[1]();\nfuncs[2]();\n</code></pre>\n<p>의도한 것과 달리 왜 모두 3이 나오는 걸까? <code>funcs[i]</code> 함수가 만들어질 때 외부 렉시컬 환경에 대한 참조가 기억된다. 그리고 이 함수가 호출될 때 i에 접근하게 된다. 그런데 이 함수 내부에는 i라는 지역 변수가 없으므로 외부 렉시컬 환경에 접근하게 된다.</p>\n<p>그런데 이때 외부 렉시컬 환경은 <code>makeFunction</code> 함수의 렉시컬 환경이다. 그리고 <code>makeFunction</code>이 끝나는 시점에서 이 렉시컬 환경에 i는 3으로 저장되어 있다. 따라서 funcs 배열의 어떤 함수를 호출해도 3이 나오는 것이다.</p>\n<p>이를 해결하기 위해서는 funcs[i] 함수가 만들어질 때 i의 값을 복사해서 function[i]의 외부 렉시컬 환경에 저장해두면 된다.</p>\n<pre><code class=\"language-js\">function makeFunction() {\n  let funcs = [];\n\n  let i = 0;\n  while (i &#x3C; 3) {\n    let j = i;\n    funcs[i] = function () {\n      console.log(j);\n    };\n    i++;\n  }\n  return funcs;\n}\n</code></pre>\n<p>그러면 이제는 0, 1, 2가 나오는 것을 확인할 수 있다. funcs[i]가 생성될 때 저장되는 렉시컬 환경에 j가 따로따로 저장되기 때문이다.</p>",
    "excerpt": "1. 재귀와 스택\n재귀 함수는 자기 반복적인 구조를 가진 함수를 작성할 때 아주 좋다. 예를 들어서 팩토리얼 함수를 작성할 때 재귀 함수를 사용하면 아래와 같이 작성할 수 있다.\nfunction factorial(n) {\n  return n ? n * factorial(n - 1) : 1;\n}\n\n그럼 이런 재귀 함수는 실제 js에서 어떻게 작동하는 걸까? 실행 컨텍스트가 이용된다. 이에 관한 글은 여기에 정리하였다.\n2. 나머지 매개변수와 spread\n나머지 매",
    "headingTree": [
      {
        "title": "1. 재귀와 스택",
        "url": "#1-재귀와-스택",
        "items": []
      },
      {
        "title": "2. 나머지 매개변수와 spread",
        "url": "#2-나머지-매개변수와-spread",
        "items": [
          {
            "title": "2.1. 스프레드에 대해",
            "url": "#21-스프레드에-대해",
            "items": []
          }
        ]
      },
      {
        "title": "3. 변수의 유효범위와 클로저",
        "url": "#3-변수의-유효범위와-클로저",
        "items": [
          {
            "title": "3.1 코드 블록",
            "url": "#31-코드-블록",
            "items": []
          },
          {
            "title": "3.2. 렉시컬 환경",
            "url": "#32-렉시컬-환경",
            "items": [
              {
                "title": "3.2.1. 변수와 렉시컬 환경",
                "url": "#321-변수와-렉시컬-환경",
                "items": []
              },
              {
                "title": "3.2.2. 함수와 렉시컬 환경",
                "url": "#322-함수와-렉시컬-환경",
                "items": []
              },
              {
                "title": "3.2.3. 함수 생성과 렉시컬 환경",
                "url": "#323-함수-생성과-렉시컬-환경",
                "items": []
              }
            ]
          },
          {
            "title": "3.3. 메모리 GC와 클로저",
            "url": "#33-메모리-gc와-클로저",
            "items": [
              {
                "title": "3.3.1. V8의 메모리 최적화",
                "url": "#331-v8의-메모리-최적화",
                "items": []
              }
            ]
          },
          {
            "title": "3.4. 클로저 예시",
            "url": "#34-클로저-예시",
            "items": [
              {
                "title": "3.4.1. 카운터",
                "url": "#341-카운터",
                "items": []
              },
              {
                "title": "3.4.2. 보이는 변수",
                "url": "#342-보이는-변수",
                "items": []
              },
              {
                "title": "3.4.3. 반복문으로 함수 만들기",
                "url": "#343-반복문으로-함수-만들기",
                "items": []
              }
            ]
          }
        ]
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 394
    },
    "url": "/posts/javascript-11",
    "thumbnail": {
      "local": "/thumbnails/javascript-11-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-javascript-11-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAjUlEQVR4nGPo6+sLCwsLDAyMjY3NycnR0dEJCQlRUlJiaGlpMTc3b25q1tfXV1dXX7du3eXLlw8dOsSQmZnJyMgoKira3t5+9+7d379//wcDhh07tickJFRUVFy+fPn///9fv379DQYMi5csTUhIKCoqmjFjxpIlS65duwbVsWzV2uXLV2zduhUiBDcKAMD7We0itJCgAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "javascript-12",
    "title": "모던 자바스크립트 튜토리얼 part 1.6 함수 심화학습 두번째",
    "date": "2023-01-28T00:00:00Z",
    "description": "ko.javascript.info part 1-6 2번째",
    "tags": [
      "javascript"
    ],
    "html": "<p>모던 자바스크립트 Part1.6을 정리하는 두번째 글이다.</p>\n<h1>1. 오래된 var</h1>\n<p>지금까지 했던 let, const 외에 var로도 변수를 선언할 수 있다. 이게 원래 JS에서 쓰이던 방식이다.</p>\n<p>let을 var로 바꿔도 유사하게 작동할 때가 많다. 하지만 몇몇 중요한 부분에서 다른 점이 있다.</p>\n<h2>1.1. 스코프</h2>\n<p>블록 기준으로 스코프를 나누는 let과 달리 var는 함수 스코프와 전역 스코프뿐이다. 따라서 함수 스코프가 아닌 블록은 스코프를 분리하지 않는다.</p>\n<pre><code class=\"language-js\">if (1) {\n  var a = 1;\n  console.log(a);\n}\n\nconsole.log(a);\n// if블록은 함수 스코프가 아니라서\n// var는 스코프를 나누지 않기에 여기서도 a에 접근 가능\n</code></pre>\n<p>반면 함수를 기준으로는 스코프를 나눈다.</p>\n<pre><code class=\"language-js\">function foo() {\n  var bar = 1;\n}\n\nfoo();\nconsole.log(bar); \n// 함수 밖에서 bar를 참조하면 ReferenceError 발생\n</code></pre>\n<h2>1.2. 변수 중복 선언</h2>\n<p>var는 같은 스코프 내에서 중복 선언이 가능하다. 그러나 이미 선언된 변수를 var로 다시 선언시 변수에 값은 대입되지만, 새로 메모리를 할당하거나 하지는 않는다.</p>\n<pre><code class=\"language-js\">var a = 1; // 이 시점에 이미 a는 선언되었다\nvar a = 2;\nvar a = 3;\nconsole.log(a); // 3이 출력된다\n</code></pre>\n<h2>1.3. 선언 전 사용</h2>\n<p>var의 선언은 함수의 어느 부분에서 선언되었든 함수가 시작하는 시점에 처리된다. 따라서 선언 위치와 상관없이 함수 본문 내 어디서든, var를 만나기 이전에도 사용할 수 있다. 단 선언만 처리되고 값의 할당은 스크립트 시작 시점엔 처리되지 않는다.</p>\n<pre><code class=\"language-js\">function foo() {\n  // a의 선언은 처리되었지만 값은 대입되지 않아 undefined가 출력된다\n  console.log(a);\n  var a = 1;\n}\n\nfoo();\n</code></pre>\n<p>값을 미리 대입해 주면 그 값으로 처리된다.</p>\n<pre><code class=\"language-js\">function foo() {\n  a = 2;\n  console.log(a); // 2\n  var a = 1;\n  console.log(a); // 1\n}\n\nfoo();\n</code></pre>\n<p>물론 함수 밖에서는 사용할 수 없다.</p>\n<pre><code class=\"language-js\">function foo() {\n  var a = 1;\n  console.log(a);\n}\nconsole.log(a); // 에러\nfoo();\n</code></pre>\n<h2>1.4. IIFE</h2>\n<p>IIFE는 Immediately Invoked Function Expression의 약자로, 함수를 선언함과 동시에 즉시 실행하는 것이다. 이는 var도 블록 레벨 스코프로 사용할 수 있도록 한 대안 중 하나이다.</p>\n<p>즉시 실행 함수 표현식은 함수 표현식을 만들고 괄호로 감싸는 방식으로 만들어진다.</p>\n<pre><code class=\"language-js\">(function () {\n  let msg = \"Hello World\";\n  console.log(msg);\n})();\n// hello world\n</code></pre>\n<p>이런 걸 이용해서 private 멤버를 흉내낼 수 있다. var밖에 없던 시절 쓰이던 트릭이다.</p>\n<pre><code class=\"language-js\">var User = (function () {\n    var name = \"김성현\";\n\n    return function () {\n        this.getName = function () {\n            return name;\n        }\n\n        this.setName = function (newName) {\n            name = newName;\n        }\n    }\n})();\n\nvar user1 = new User();\nconsole.log(user1.name); //undefined\nconsole.log(user1.getName()); //김성현\nuser1.name = \"다른 이름\";\nconsole.log(user1.getName()); //김성현\nuser1.setName(\"다른 이름\");\nconsole.log(user1.getName()); //다른 이름\n</code></pre>\n<p>위 예시를 보면 User 함수는 쓰이는 즉시 호출된다. 그리고 호출이 끝남과 함께 함수 내부의 지역변수 name은 (원래는)사라진다. 또한 일반적인 방법으론 접근할 수 없다.</p>\n<p>하지만 즉시 실행 함수가 리턴한 함수의 내부 숨김 프로퍼티 <code>[[Environment]]</code>에는 그 렉시컬 환경이 남아 있으므로 그 함수들(여기선 getName, setName)은 즉시 실행 함수의 렉시컬 환경에 접근하여 name에 접근 가능하다. 따라서 위와 같이 private를 흉내낼 수 있는 것이다.</p>\n<h1>2. 전역 객체</h1>\n<p>전역 객체는 보통 언어 자체나 호스트 환경에 기본 내장되어 있다. 브라우저 환경에선 window, Nodejs환경에선 global인데, 최근에는 globalThis로 표준화되었다.</p>\n<p>let, const가 아닌 var로 선언된 변수는 전역 객체의 프로퍼티다. 단 애초에 var를 쓰지 말고, 또한 이런 방식으로 전역 객체를 사용하는 건 추천되지 않는다. let을 사용하면 또 전역 객체를 통해 변수에 접근할 수 없다.</p>\n<p>그런데 만약 모든 곳에서 사용할 수 있는 어떤 변수를 만들고 싶다면 전역 객체에 직접 추가해 줄 수 있다.</p>\n<pre><code class=\"language-js\">globalThis.authorName = \"김성현\";\nconsole.log(authorName);\n</code></pre>\n<p>이렇게 전역 객체에 추가한 변수는 스크립트 어디서든 접근 가능하다. 물론 전역 변수를 만드는 건 좋지는 않다.</p>\n<h1>3. 기명 함수 표현식</h1>\n<p>기명 함수 표현식은 말 그대로 이름이 있는 함수 표현식이다.</p>\n<p>다음 코드를 보자. 함수 표현식에 이름이 붙어 있다.</p>\n<pre><code class=\"language-js\">let foo = function bar() {\n    console.log(\"SH\");\n}\n</code></pre>\n<p>이렇게 한다고 해서 foo를 호출하지 못한다거나 하는 건 아니다. 일반적인 함수 표현식을 쓴 것과 똑같이 작동한다. 그럼 뭐가 다를까?</p>\n<p>함수 표현식 내에서 자기 자신을 참조할 수 있으며 표현식 외부에선 그 이름을 사용할 수 없게 된다.</p>\n<pre><code class=\"language-js\">let greeting = function func(name) {\n    if (name) {\n        console.log(`안녕하세요 ${name}님`);\n    }\n    else {\n        func(\"김성현\");\n    }\n}\n\ngreeting(); //안녕하세요 김성현님\nfunc(); //기명 함수 표현식 밖에선 함수표현식의 이름에 접근할 수 없으므로 에러\n</code></pre>\n<p>그런데 이는 func 대신 그냥 greeting을 넣어서 작성해도 된다. 굳이 함수 표현식에 이름을 달지 않아도 되는 것이다. 그럼 이렇게 하면 뭐가 좋을까? greeting이 다른 함수에 할당될 때 발생한다.</p>\n<pre><code class=\"language-js\">let greeting = function (name) {\n    if (name) {\n        console.log(`안녕하세요 ${name}님`);\n    }\n    else {\n        greeting(\"김성현\");\n    }\n}\n\ngreeting(); // 안녕하세요 김성현님\nlet foo = greeting;\ngreeting = null;\nfoo();\n//foo의 외부 렉시컬 환경에서 greeting을 가져올 수 없으므로 에러\n</code></pre>\n<p>반면 기명 함수 표현식을 사용하면 함수 표현식의 이름은 함수의 지역 렉시컬 환경에 존재하므로 기존 함수의 이름이 어떻게 되든 함수 내부에서 표현식의 이름을 통해 함수 자체를 가져올 수 있다.</p>\n<pre><code class=\"language-js\">let greeting = function func(name) {\n    if (name) {\n        console.log(`안녕하세요 ${name}님`);\n    }\n    else {\n        func(\"김성현\");\n    }\n}\n\ngreeting(); // 안녕하세요 김성현님\nlet foo = greeting;\ngreeting = null;\nfoo();\n// 안녕하세요 김성현님\n</code></pre>\n<p>언제든지 함수 내부에서 함수 표현식의 내부 이름을 사용해서 자기 자신을 호출할 수 있다. JS는 이렇게 함수 표현식에 붙인 이름이 무조건 현재 함수만 참조하도록 보장한다.</p>\n<h2>3.1. 함수 프로퍼티</h2>\n<p>함수도 객체이므로 프로퍼티를 붙일 수 있다. 또한 name, length등의 기본 프로퍼티도 있다.</p>\n<h1>참고</h1>\n<p><a href=\"https://coderwall.com/p/ta4caw/using-iife-to-create-private-members-in-javascript\">https://coderwall.com/p/ta4caw/using-iife-to-create-private-members-in-javascript</a></p>",
    "excerpt": "모던 자바스크립트 Part1.6을 정리하는 두번째 글이다.\n1. 오래된 var\n지금까지 했던 let, const 외에 var로도 변수를 선언할 수 있다. 이게 원래 JS에서 쓰이던 방식이다.\nlet을 var로 바꿔도 유사하게 작동할 때가 많다. 하지만 몇몇 중요한 부분에서 다른 점이 있다.\n1.1. 스코프\n블록 기준으로 스코프를 나누는 let과 달리 var는 함수 스코프와 전역 스코프뿐이다. 따라서 함수 스코프가 아닌 블록은 스코프를 분리하지 않는다.\nif (1",
    "headingTree": [
      {
        "title": "1. 오래된 var",
        "url": "#1-오래된-var",
        "items": [
          {
            "title": "1.1. 스코프",
            "url": "#11-스코프",
            "items": []
          },
          {
            "title": "1.2. 변수 중복 선언",
            "url": "#12-변수-중복-선언",
            "items": []
          },
          {
            "title": "1.3. 선언 전 사용",
            "url": "#13-선언-전-사용",
            "items": []
          },
          {
            "title": "1.4. IIFE",
            "url": "#14-iife",
            "items": []
          }
        ]
      },
      {
        "title": "2. 전역 객체",
        "url": "#2-전역-객체",
        "items": []
      },
      {
        "title": "3. 기명 함수 표현식",
        "url": "#3-기명-함수-표현식",
        "items": [
          {
            "title": "3.1. 함수 프로퍼티",
            "url": "#31-함수-프로퍼티",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 243
    },
    "url": "/posts/javascript-12",
    "thumbnail": {
      "local": "/thumbnails/javascript-12-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-javascript-12-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAiklEQVR4nGPo6+sLCwsLDAyMjY3NzMzU1NQMCQlRUlJiaGlpMTc3b2lpMTU1NTc337dv36VLlw4dOsSQlpbOyMgoISHh4OAgJCTk5OT0////379/M2zbujUqKmrevHkPHjw4c+bMiRMnoBILFi4KCQldsmTJf1TAsHzVulWr1mzatOHy5csQtRAJAHEnV3FYOm/QAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "javascript-13",
    "title": "모던 자바스크립트 튜토리얼 part 1.6 함수 심화학습 세번째",
    "date": "2023-01-30T00:00:00Z",
    "description": "ko.javascript.info part 1-6 3번째",
    "tags": [
      "javascript"
    ],
    "html": "<h1>1. new Function</h1>\n<p>앞에서 다룬 방법 외에도 new Function으로 함수를 만들 수 있다.</p>\n<pre><code class=\"language-js\">let 함수명= new Function(인자1, 인자2, ... , 함수의 본문);\nlet sum = new Function('a', 'b', 'return a + b');\n</code></pre>\n<p>이 방식을 사용하면 런타임에 받은 문자열을 사용해서 함수를 만들 수 있다. 서버에서 받은 문자열로 함수 만들기도 가능하다.</p>\n<p>또한 이 방식으로 만든 함수에는 차이가 있는데 바로 함수 내부에서 자신이 생성된 렉시컬 환경을 기억하는 <code>[[Environment]]</code>가 무조건 전역 렉시컬 환경을 참조한다는 것이다. 따라서 new Function으로 생성된 함수는 전역 변수가 아닌 외부 변수에 접근할 수 없다. 이 함수에 무언가 넘겨주고 싶다면 매개 변수를 사용하자.</p>\n<h1>2. setTimeout과 setInterval</h1>\n<p>일정 시간이 지난 후에 원하는 함수를 호출하는, 호출 스케줄링을 하는 함수들이다.</p>\n<h2>2.1. setTimeout</h2>\n<pre><code class=\"language-js\">let timerId = setTimeout(함수 혹은 문자열, [시간], [인자1], [인자2], ...);\nsetTimeout(func, time, arg1, arg2, ...);\n</code></pre>\n<p>time이 지난 후 arg1, arg2...를 매개변수로 하여 func을 호출한다. 이때 time은 밀리세컨드 단위이며 기본값은 0이다.</p>\n<p>다음과 같이 하면 func을 1초 이후에 호출하게 된다.</p>\n<pre><code class=\"language-js\">setTimeout(func, 1000);\n</code></pre>\n<p>그리고 만약 setTimeout에 첫 번째 인수가 문자열이라면 js에선 이 문자열을 함수로 만들어 실행한다.</p>\n<h3>2.1.2. 리턴값</h3>\n<p>setTimeout은 타이머 식별자를 반환한다.</p>\n<pre><code class=\"language-js\">function foo() {\n  console.log(\"foo\");\n}\n\nlet tid = setTimeout(foo, 1000);\nlet tid2= setTimeout(foo, 2000);\nconsole.log(tid); // 1\nconsole.log(tid2); // 2\n</code></pre>\n<p>이 타이머 식별자를 이용하면 clearTimeout을 사용하여 타이머를 취소할 수 있다.</p>\n<pre><code class=\"language-js\">function foo() {\n  console.log(\"foo\");\n}\n\nlet tid = setTimeout(foo, 1000);\nclearTimeout(tid); // tid에 해당하는 스케줄링을 취소\nconsole.log(\"done\");\n</code></pre>\n<p>단 NodeJS에서 setTimeout을 사용할 때는 타이머 식별자가 타이머 객체가 되는 등, 타이머 식별자는 꼭 숫자는 아닐 수도 있다.</p>\n<h2>2.2. setInterval</h2>\n<p>setInterval의 형식은 setTimeout과 거의 같다.</p>\n<pre><code class=\"language-js\">let timerId = setInterval(함수 혹은 문자열, [시간], [인자1], [인자2], ...);\n</code></pre>\n<p>그러면 지정한 시간마다 함수를 호출하게 된다. 이때 인자는 setInterval에 넘겨준 인자들이 그대로 함수에 전달된다.</p>\n<p>그리고 setInterval도 타이머 식별자를 반환하는데 이를 이용하여 clearInterval로 타이머를 취소할 수 있다.</p>\n<pre><code class=\"language-js\">// 1초 간격으로 메시지를 보여줌\nlet timerId = setInterval(() => console.log(\"째깍\"), 1000);\n\n// 4초 후에 정지\nsetTimeout(() => {\n  clearInterval(timerId);\n  alert(\"정지\");\n}, 4000);\n// 째깍 이 4번 출력되고 정지 창이 뜬다.\n</code></pre>\n<h2>2.3. 중첩 setTimeout으로 주기적 실행</h2>\n<p>setInterval을 쓰지 않더라도 setTimeout을 재귀적으로 사용하면 주기적으로 실행할 수 있다.</p>\n<pre><code class=\"language-js\">let tid = setTimeout(function tick() {\n  console.log(\"2초 지났다\");\n  tid = setTimeout(tick, 2000);\n}, 2000);\n</code></pre>\n<p>이렇게 하면 2초마다 tick이 호출되는데, tick 안에서 다시 setTimeout으로 tick을 호출하여 2초 뒤에 다시 tick을 호출하게 된다.</p>\n<p>그리고 이런 식으로 하면 호출 결과에 따라 다음 호출의 딜레이를 조정하거나 다른 함수를 호출하는 등 더 유연한 작업을 할 수 있다.</p>\n<h3>2.3.1. setInterval과의 차이</h3>\n<p>setTimeout은 지연 간격을 보장하지만, setInterval은 그렇지 않다.</p>\n<pre><code class=\"language-js\">let i = 1;\nsetInterval(() => {\n  for (let i = 0; i &#x3C; 1000000000; i++);\n  console.log(i++);\n}, 1000);\n</code></pre>\n<p>위 코드는 1초마다 한번씩 i를 로그에 찍을 것이다. 그런데 10억번의 반복이 함수 호출마다 있다. 실제로 호출해 보면 함수 호출마다 약 0.3~0.5초가 소모된다.</p>\n<p>그런데 setInterval은 이렇게 함수 호출에 소모되는 시간도 지연 간격에 포함한다. setInterval이 지정한 함수 호출이 끝나고 나면 엔진은 함수 첫 호출 이후에 지연된 시간을 확인하고 지연 시간이 지났으면 다음 호출을 시작한다.</p>\n<p>즉 만약 함수 호출에 걸린 시간이 0.5초라면 스케줄러는 0.5초가 지난 것을 확인하고 delay초가 아니라 delay-0.5초가 지난 후 바로 다음 함수를 호출한다. 만약 함수가 소모한 시간이 delay보다 길면 즉시 다음 함수를 호출한다.</p>\n<p>반면 중첩 setTimeout은 함수 실행이 종료된 후 delay가 지난 후 다음 함수를 호출한다. 따라서 함수가 소모한 시간이 delay보다 긴지 어떤지에 상관없이 다음 함수 호출까지 delay가 지연된다.</p>\n<pre><code class=\"language-js\">let i = 1;\nsetTimeout(function run() {\n  for (let j = 0; j &#x3C; 1000000000; j++);\n  console.log(i++);\n  setTimeout(run, 1000);\n});\n</code></pre>\n<p>위 코드를 실행해 보면 1초가 약간 넘는 시간마다 run 함수가 호출되는 것을 확인할 수 있다. 이는 run 함수 실행에도 약 0.4초가 걸리고 그 시간이 지난 후 또 1초가 지나서 run이 다시 호출되기 때문이다.</p>\n<p>setTimeout은 이전 함수의 실행이 종료된 후 다음 함수 호출을 스케줄링하기 때문이다.</p>\n<h2>2.4. gc와 setTimeout</h2>\n<p>setTimeout, setInterval에 함수를 넘기면 함수에 대한 내부 참조가 만들어진다. 따라서 여기 넘긴 함수는 clearTimeout, clearInterval을 호출하기 전까지 가비지 컬렉션 대상이 되지 않는다.</p>\n<p>이런 방식은 메모리 누수를 일으킨다. 다음 코드 같은 경우 setInterval에 넘긴 함수는 외부 렉시컬 환경의 a를 참조한다. 따라서 함수가 끝나도 a는 setInterval에서 참조하고 있으므로 가비지 컬렉션 대상이 되지 않는다. 이런 메모리 누수를 일으키고 싶지 않다면 스케줄링이 필요없어지면 clearTimeout, clearInterval을 호출해야 한다.</p>\n<pre><code class=\"language-js\">let a = 1;\n\nsetInterval(() => {\n  console.log(a++);\n}, 1000);\n</code></pre>\n<h2>2.5. setTimeout(func,0)</h2>\n<p><code>setTimeout(func,0)</code>은 함수 실행까지의 대기 시간을 0으로 설정한다. 그러나 이는 함수를 즉시 실행하는 것이 아니라 함수를 즉시 실행할 수 있을 때 실행하라는 의미이다. 현재 처리중인 스크립트의 처리가 종료된 직후 스케줄링한 함수를 실행하는 것이다.</p>\n<pre><code class=\"language-js\">setTimeout(() => {\n  console.log(\"a\");\n});\nconsole.log(\"b\");\n// b a\n</code></pre>\n<p>위 코드에서 b가 먼저 출력된다. 현재 스크립트인 b 출력을 먼저 처리한 직후 setTimeout에 넘긴 함수가 실행되는 것이다.</p>\n<p>그리고 setTimeout간의 순서는 딱히 보장되지 않는다.</p>\n<pre><code class=\"language-js\">setTimeout(() => {\n  console.log(\"A\");\n});\nsetTimeout(() => {\n  console.log(\"B\");\n});\nsetTimeout(() => {\n  console.log(\"C\");\n});\n</code></pre>\n<p>위 코드에서 A,B,C의 출력 순서는 보장되지 않는다는 것이다. 만약 이 순서를 보장하고 싶다면 중첩 setTimeout을 사용해야 한다.</p>\n<h1>3. call, apply, 데코레이터</h1>\n<h2>3.1. 데코레이터</h2>\n<p>데코레이터는 인수로 받은 함수의 행동을 변경시켜 주는 함수를 말한다. 데코레이터는 함수를 인수로 받아서 특정한 행동을 하고 래퍼 함수를 반환한다. 이 래퍼 함수는 원래 함수를 호출하는 것과 같은 행동을 하면서 추가적인 기능을 수행한다.</p>\n<p>예를 들어 함수에 캐싱 기능을 추가해 주는 데코레이터를 만들어 보자.</p>\n<p>먼저 간단하게 피보나치 함수를 만들자. 재귀 호출이 엄청나게 일어나는 코드이다.</p>\n<pre><code class=\"language-js\">function fibonacci(n) {\n  if (n &#x3C;= 1) return 1;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n}\n</code></pre>\n<p><code>fibonacci(100)</code>만 해도 연산이 끝나질 않는다. 이 함수를 데코레이터를 사용해 캐싱 기능을 추가해 보자.</p>\n<pre><code class=\"language-js\">function fibonacci(n) {\n  if (n &#x3C;= 1) return 1;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\nfunction cachingDecorator(func) {\n  let cache = new Map();\n  return function (x) {\n    if (cache.has(x)) {\n      return cache.get(x);\n    }\n    let result = func(x);\n    cache.set(x, result);\n    return result;\n  };\n}\n\nfibonacci = cachingDecorator(fibonacci);\nconsole.log(fibonacci(100));\n</code></pre>\n<p>아주 빠른 시간에 답이 나오는 것을 볼 수 있다. 이 데코레이터는 내부적으로 Map을 만든 후 다음과 같은 함수를 만들어 반환한다.</p>\n<p>함수를 호출할 때마다 Map에 없는 인수라면 Map에 인수와 결과를 저장한다. 그리고 다음에 같은 인수로 함수를 호출하면 Map에서 값을 꺼내서 반환한다.</p>\n<h2>3.2. bind, call, apply</h2>\n<p>this는 자신을 호출한 객체를 가리킨다. 따라서 내부에서 this를 사용하는 객체 메서드를 다른 변수에 할당하여 사용하려고 하면 문제가 발생한다. 이때 이를 해결하는 방법 중 하나로 bind가 있다. 예를 들어서 다음 코드는 잘 작동하지 않는다.</p>\n<pre><code class=\"language-js\">let obj = {\n  name: \"김성현\",\n  age: 27,\n  greeting: function () {\n    console.log(`안녕하세요. ${this.name}입니다.`);\n  },\n};\n\nobj.greeting(); // 안녕하세요. 김성현입니다.\nlet greet = obj.greeting;\n// this가 undefined가 되어서 제대로 작동하지 않는다\ngreet();\n</code></pre>\n<p>하지만 bind를 사용하면 this를 고정시킬 수 있다. bind는 함수를 호출하지는 않고 함수 내에서 가리키는 this만 바꾼다.</p>\n<pre><code class=\"language-js\">obj.greeting(); // 안녕하세요. 김성현입니다.\nlet greet = obj.greeting.bind(obj);\ngreet(); // 안녕하세요. 김성현입니다.\n</code></pre>\n<p>call은 함수의 메서드이다. call은 첫번째 인수로 this가 될 객체를 받는다. 두번째 인수부터는 함수의 인수를 받는다. 즉 다음과 같은 형태로 사용한다.</p>\n<pre><code class=\"language-js\">func.call(thisArg, arg1, arg2, ...)\n</code></pre>\n<p>이를 이용해 위 코드의 this가 잘 작동하도록 고치면 다음과 같다.</p>\n<pre><code class=\"language-js\">let obj = {\n  name: \"김성현\",\n  age: 27,\n  greeting: function () {\n    console.log(`안녕하세요. ${this.name}입니다.`);\n  },\n};\n\nobj.greeting(); // 안녕하세요. 김성현입니다.\nlet greet = obj.greeting;\ngreet.call(obj);\n</code></pre>\n<p>apply는 call과 비슷하지만 인수를 배열로 받는다. 즉 다음과 같은 형태로 사용한다.</p>\n<pre><code class=\"language-js\">// arg1, arg2...를 배열에 넣어서 전달한다. 유사 배열 객체에 담아서 전달해도 된다.\nfunc.apply(thisArg, [arg1, arg2, ...])\n</code></pre>\n<p>그리고 대부분의 JS 엔진은 내부에서 apply를 최적화하기 때문에 apply를 사용하는 게 더 빠르다고 한다.</p>\n<h2>3.3. call, apply와 데코레이터</h2>\n<p>이를 데코레이터에 어떻게 적용할까? 위의 3.1.에서와 같이 데코레이터를 만들면 문제가 생긴다. 객체 메서드 내부에서 this에 접근하는 메서드가 있다면 데코레이터 내부에서 this에 접근하면서 문제가 생길 수 있다.</p>\n<pre><code class=\"language-js\">let test = {\n  someMethod() {\n    return 2;\n  },\n\n  doubleNumber(n) {\n    return n * this.someMethod();\n  },\n};\n\nfunction cachingDecorator(func) {\n  let cache = new Map();\n  return function (x) {\n    if (cache.has(x)) {\n      return cache.get(x);\n    }\n    let result = func(x);\n    cache.set(x, result);\n    return result;\n  };\n}\nconsole.log(test.doubleNumber(3));\ntest.doubleNumber = cachingDecorator(test.doubleNumber);\nconsole.log(test.doubleNumber(3));\n/* 실패한다. 캐싱 데코레이터가 리턴하는 내부에서 func을 호출하는데, 이 func의 역할을 하는\ntest.doubleNumber 내부에서는 원래 this(test)에 접근한다. 그러나 캐싱 데코레이터가 리턴하는 래퍼 함수 내에서는 this의 맥락이 사라졌기에 test.doubleNumber의 this에 접근할 수 없어서 에러이다. */\n</code></pre>\n<p>이를 해결하기 위해 call, apply를 사용한다. call, apply는 this를 명시적으로 지정할 수 있기 때문에 이를 이용해 this를 명시적으로 지정해주면 된다. 캐싱 데코레이터를 다음과 같이 수정한다.</p>\n<pre><code class=\"language-js\">function cachingDecorator(func) {\n  let cache = new Map();\n  return function (x) {\n    if (cache.has(x)) {\n      return cache.get(x);\n    }\n    let result = func.call(this, x);\n    cache.set(x, result);\n    return result;\n  };\n}\n</code></pre>\n<p>이렇게 하면 잘 작동한다. 원리는 다음과 같다.</p>\n<p>먼저 데코레이터를 적용하게 된 함수는 래퍼 함수로 대체된다. 그리고 래퍼 함수는 원래 함수를 호출할 때 this를 명시적으로 지정해준다. 이때 래퍼 함수가 호출하는 원래 함수는 객체 함수이므로 호출할 때 <code>obj.method()</code>형태로 호출될 것이다. 따라서 call이 명시적으로 지정해준 this는 원래 함수가 호출될 때의 객체가 되고 따라서 정상적으로 작동하게 된다.</p>\n<p>그런데 만약 함수에 프로퍼티가 붙어 있다면 데코레이터를 적용한 함수에선 프로퍼티를 사용할 수 없다.</p>\n<pre><code class=\"language-js\">function fibonacci(n) {\n  if (n &#x3C;= 1) return 1;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\nfibonacci.temp = 1;\n\nfunction cachingDecorator(func) {\n  let cache = new Map();\n  return function (x) {\n    if (cache.has(x)) {\n      return cache.get(x);\n    }\n    let result = func(x);\n    cache.set(x, result);\n    return result;\n  };\n}\n\nconsole.log(fibonacci.temp);\nfibonacci = cachingDecorator(fibonacci);\nconsole.log(fibonacci.temp);\n// 데코레이터를 적용한 함수에서는 기존 프로퍼티가 없으므로 undefined가 출력된다.\n</code></pre>\n<h2>3.4. call 다른 활용</h2>\n<p>함수의 arguments를 조작할 때 쓸 수 있다. 함수에 들어온 인자를 관리하는 유사 배열 객체인데 원래는 배열이 아니기 때문에 배열 메서드를 사용할 수 없다. 그런데 call을 이용하면 배열 메서드를 사용할 수 있다.</p>\n<p>물론 Array.from을 쓸 수도 있겠지만 call로 배열의 join 메서드를 빌려올 수도 있다. 다음과 같이.</p>\n<pre><code class=\"language-js\">function example() {\n  console.log(Array.prototype.join.call(arguments));\n}\n\nexample(\"a\", \"b\", \"c\"); // a,b,c\n</code></pre>\n<h1>참고</h1>\n<p>call, apply에 대하여 <a href=\"https://www.zerocho.com/category/JavaScript/post/57433645a48729787807c3fd\">https://www.zerocho.com/category/JavaScript/post/57433645a48729787807c3fd</a></p>",
    "excerpt": "1. new Function\n앞에서 다룬 방법 외에도 new Function으로 함수를 만들 수 있다.\nlet 함수명= new Function(인자1, 인자2, ... , 함수의 본문);\nlet sum = new Function('a', 'b', 'return a + b');\n\n이 방식을 사용하면 런타임에 받은 문자열을 사용해서 함수를 만들 수 있다. 서버에서 받은 문자열로 함수 만들기도 가능하다.\n또한 이 방식으로 만든 함수에는 차이가 있는데 바로 함수 내부에",
    "headingTree": [
      {
        "title": "1. new Function",
        "url": "#1-new-function",
        "items": []
      },
      {
        "title": "2. setTimeout과 setInterval",
        "url": "#2-settimeout과-setinterval",
        "items": [
          {
            "title": "2.1. setTimeout",
            "url": "#21-settimeout",
            "items": [
              {
                "title": "2.1.2. 리턴값",
                "url": "#212-리턴값",
                "items": []
              }
            ]
          },
          {
            "title": "2.2. setInterval",
            "url": "#22-setinterval",
            "items": []
          },
          {
            "title": "2.3. 중첩 setTimeout으로 주기적 실행",
            "url": "#23-중첩-settimeout으로-주기적-실행",
            "items": [
              {
                "title": "2.3.1. setInterval과의 차이",
                "url": "#231-setinterval과의-차이",
                "items": []
              }
            ]
          },
          {
            "title": "2.4. gc와 setTimeout",
            "url": "#24-gc와-settimeout",
            "items": []
          },
          {
            "title": "2.5. setTimeout(func,0)",
            "url": "#25-settimeoutfunc0",
            "items": []
          }
        ]
      },
      {
        "title": "3. call, apply, 데코레이터",
        "url": "#3-call-apply-데코레이터",
        "items": [
          {
            "title": "3.1. 데코레이터",
            "url": "#31-데코레이터",
            "items": []
          },
          {
            "title": "3.2. bind, call, apply",
            "url": "#32-bind-call-apply",
            "items": []
          },
          {
            "title": "3.3. call, apply와 데코레이터",
            "url": "#33-call-apply와-데코레이터",
            "items": []
          },
          {
            "title": "3.4. call 다른 활용",
            "url": "#34-call-다른-활용",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 2,
      "wordCount": 543
    },
    "url": "/posts/javascript-13",
    "thumbnail": {
      "local": "/thumbnails/javascript-13-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-javascript-13-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAjElEQVR4nC3KMQrDIBSAYQevItkdBRf3rILg5Nx3iYDgLN6g7VBL6fg2QRByAbccxcHSpv/6/STGaK3VWjvnAIBzboxZloWEEKSU3nshhJSy1tp7b60RAKCUMsaUUpTSdV3nnGMMUmv13m/blnMupbTW/nC93S/wLaWEiPu+z1/k8Xrn/ETE4zjO94QPaBFVHM0MRFAAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "javascript-10",
    "title": "모던 자바스크립트 튜토리얼 part 1.5 자료구조와 자료형 - 2",
    "date": "2023-01-15T00:00:00Z",
    "description": "ko.javascript.info part 1-5 두번째",
    "tags": [
      "javascript"
    ],
    "html": "<h1>1. 맵과 셋</h1>\n<h2>1.1. 맵</h2>\n<p>Map은 데이터를 키-값 형식으로 저장한다. 객체와 다른 점은 키에 다양한 자료형이 허용된다는 것이다. 객체도 키로 쓸 수 있다. 다음과 같은 메서드들이 있다.</p>\n<ul>\n<li>new Map()</li>\n<li>map.set(key, value) : 맵 스스로가 반환된다. 따라서 chaining도 가능</li>\n<li>map.get(key) : 키가 존재하지 않으면 undefined 반환</li>\n<li>map.has(key)</li>\n<li>map.delete(key)</li>\n<li>map.clear()</li>\n<li>map.keys()</li>\n<li>map.values()</li>\n<li>map.entries()</li>\n</ul>\n<p>그리고 size 프로퍼티가 있어 맵의 크기를 알 수 있다.</p>\n<p>이때 <code>map[key]</code>를 이용해서 값을 가져오거나 설정하는 것도 가능하다. 하지만 그렇게 하면 맵이 일반 객체처럼 취급되게 되므로 get, set을 쓰자.</p>\n<p>그리고 맵은 삽입한 순서대로 순회를 실시한다. forEach도 지원한다.</p>\n<h3>1.1.1. 객체와 맵</h3>\n<p><code>Object.entries(obj)</code>를 이용하면 객체를 맵으로 바꿀 수 있다. 이 메서드는 객체의 키-값 쌍을 배열로 반환하는데 이 배열을 맵의 생성자에 넣으면 맵이 만들어진다.</p>\n<p>그리고 <code>Object.fromEntries(map)</code>를 이용하면 맵을 객체로 바꿀 수 있다. 이 메서드는 각 요소가 [키, 값]인 배열을 받아 객체를 만든다. 따라서 map.entries()를 Object.fromEntries에 넣으면 맵을 객체로 바꿀 수 있다.</p>\n<h2>1.2. 셋</h2>\n<p>셋은 중복을 허용하지 않는 값의 집합이다. 셋은 중복을 허용하지 않는다는 점에서 맵과 비슷하지만 키-값 쌍이 아니라 단순히 값만 저장한다는 점에서 다르다. 셋은 다음과 같은 메서드들을 지원한다.</p>\n<p>이때 셋은 중복을 허용하지 않으므로 같은 값을 여러 번 삽입해도 한 개만 저장된다.</p>\n<ul>\n<li>new Set(iterable)</li>\n<li>set.add(value) : 셋 스스로가 반환된다. 따라서 chaining도 가능</li>\n<li>set.delete(value)</li>\n<li>set.has(value)</li>\n<li>set.clear()</li>\n<li>set.keys()</li>\n<li>set.values() : set.keys()와 같다. 맵과의 호환성을 위해 존재한다.</li>\n<li>set.entries() : 맵과의 호환성을 위해 존재한다. [value,value] 형태로 반환한다.</li>\n</ul>\n<p>for..of, forEach도 지원한다.</p>\n<p>또한 Array.from을 이용해 셋을 배열로 바꿀 수 있다.</p>\n<ul>\n<li>이때 맵과 셋의 keys, values 메서드는 배열이 아니라 iterable 객체를 반환한다. 즉 배열 메서드를 사용할 수 없다. 따라서 배열로 바꾸려면 Array.from을 이용해야 한다.</li>\n</ul>\n<h2>1.3. 위크맵과 위크셋</h2>\n<p>위크맵과 위크셋은 맵과 셋과 비슷하지만 차이점이 있다. 위크맵과 위크셋은 객체만 저장할 수 있고, 객체가 아닌 원시값은 저장할 수 없다.</p>\n<p>또한 위크맵과 위크셋을 쓰면 키로 쓰인 객체가 가비지 컬렉션의 대상이 된다. 즉 위크맵, 위크셋의 키로 사용된 객체를 참조하는 것이 아무것도 없다면 해당 키 객체가 삭제된다.</p>\n<p>위크맵과 위크셋은 다음과 같은 메서드를 지원한다. keys와 같은 메서드, size와 같은 프로퍼티를 지원하지 않는 것은 가비지 컬렉션 때문이다.</p>\n<p>가비지 컬렉션이 언제 수행될지 알 수 없기 때문에 현재 위크맵/위크셋이 어떤 키를 가지고 있는지 그리고 그 개수가 몇 개인지 등을 알 수 없는 것이다.</p>\n<ul>\n<li>\n<p>new WeakMap()</p>\n</li>\n<li>\n<p>weakMap.set(key, value)</p>\n</li>\n<li>\n<p>weakMap.get(key)</p>\n</li>\n<li>\n<p>weakMap.delete(key)</p>\n</li>\n<li>\n<p>weakMap.has(key)</p>\n</li>\n<li>\n<p>new WeakSet()</p>\n</li>\n<li>\n<p>weakSet.add(value)</p>\n</li>\n<li>\n<p>weakSet.delete(value)</p>\n</li>\n<li>\n<p>weakSet.has(value)</p>\n</li>\n</ul>\n<p>이런 위크맵, 위크셋은 외부 코드에 속한 객체에 대해 어떤 속성을 부여해 줘야 할 때 쓰일 수 있다. 외부 객체가 사라질 때 자동으로 거기 연관된 속성도 사라지는 것이다.</p>\n<h1>2. keys, values, entries</h1>\n<p>keys(), values(), entries() 메서드는 맵, 셋, 배열 객체에 사용될 수 있다. 일반 객체를 위한 비슷한 기능은 다음과 같다.</p>\n<ul>\n<li>Object.keys(obj) : 객체의 키를 배열로 반환한다.</li>\n<li>Object.values(obj) : 객체의 값들을 배열로 반환한다.</li>\n<li>Object.entries(obj) : 객체의 [키, 값] 쌍을 배열로 반환한다.</li>\n</ul>\n<p>이때 맵, 셋, 배열 객체의 keys와 같은 메서드는 배열과는 다른 이터러블 객체를 반환하지만 일반 객체의 Object.keys는 진짜 배열을 반환한다. 따라서 Object.xxx 메서드의 반환값에는 for..of를 쓸 수 있다. 여기서 위 메서드들은 객체의 프로퍼티 중 심볼형 키를 무시한다는 점에 주의하자.</p>\n<p>js에선 복잡한 구조들이 모두 객체에 기반하다 보니 객체에 따로 keys, values, entries 메서드들이 만들어질 수 있다. 따라서 일반 객체를 위한 방법으로 Object.keys, Object.values, Object.entries를 만든 것이다.</p>\n<h2>2.1. 객체에 배열 메서드 쓰기</h2>\n<p>배열 전용인 map, filter와 같은 메서드는 객체에 사용할 수 없다. 사용하기 위해서는 다음과 같이 한다.</p>\n<pre><code class=\"language-js\">let prices = {\n  apple: 0.67,\n  orange: 1.49,\n  banana: 0.39,\n  grape: 2.79,\n  pear: 1.29,\n};\n\n// Object.entries를 써서 키-값을 요소로 갖는 배열을 만들고 filter 적용\nlet overOneBill = Object.entries(prices).filter(\n  ([key, value]) => value > 1.0\n);\n// Object.fromEntries를 써서 키-값을 요소로 갖는 배열을 다시 객체로 만듦\noverOneBill = Object.fromEntries(overOneBill);\nconsole.log(overOneBill);\n</code></pre>\n<h1>3. 구조 분해 할당</h1>\n<h2>3.1. 배열 구조 분해 할당</h2>\n<p>구조 분해 할당은 객체 혹은 배열을 변수로 분해해서 할당하거나 함수에 전달하게 해 준다. <code>[]</code>를 쓰면 된다.</p>\n<pre><code class=\"language-js\">let blog = [\"witch\", \"work\"];\nlet [first, second] = blog;\nconsole.log(first, second); //witch work\n</code></pre>\n<p>이때 필요 없는 요소를 버리기 위해서 쉼표를 사용해 요소를 무시할 수 있다.</p>\n<pre><code class=\"language-js\">let myName = [\"김\", \"성\", \"현\"];\nlet [first, , third] = myName; //2번째 원소는 생략되었다\nconsole.log(first, third);\n</code></pre>\n<p>또한 할당 연산자 우측에는 for..of로 반복 가능한 모든 객체가 올 수 있다. 그리고 좌측에는 할당할 수 있는 거라면 뭐든지 올 수 있다. 객체 프로퍼티도 가능하다.</p>\n<p>예를 들어서 문자열도 반복 가능한 객체이므로 구조 분해 할당 가능하다.</p>\n<pre><code class=\"language-js\">let [first, second] = \"hi\";\nconsole.log(first, second); //h i\n</code></pre>\n<p>구조 분해 할당은 반복에서도 사용할 수 있다.</p>\n<pre><code class=\"language-js\">let me = {\n  name: \"김성현\",\n  age: 26,\n  hobby: \"코딩\",\n};\n\n// me의 프로퍼티들이 [키, 값] 형태로 담긴 배열이 반환됨\nconsole.log(Object.entries(me));\n// Object.entries(me)의 결과를 순회하며 각각의 키와 값을 출력함\nfor (let [k, v] of Object.entries(me)) {\n  console.log(k, v);\n}\n</code></pre>\n<p>이때 만약 할당하려는 변수 개수가 배열의 길이보다 크더라도 에러는 발생하지 않는다. 단 넘치는 변수에는 undefined가 할당된다. 다만 이를 방지하기 위해 <code>=</code>를 이용해 기본값을 설정해 줄 수 있다.</p>\n<p>구조 분해 할당에서 변수에 할당해줄 값이 없는 경우 기본값이 할당된다. 할당해줄 값이 있으면 기본값은 할당되지 않는다.</p>\n<pre><code class=\"language-js\">let arr = [\"김성현\"];\n\nlet [first = \"1\", second = \"2\"] = arr;\n// 김성현 2\nconsole.log(first, second);\n</code></pre>\n<h2>3.2. 객체 구조 분해 할당</h2>\n<p>객체를 구조 분해 할당할 땐 <code>{}</code>를 쓴다. 우측엔 분해하려는 객체를, 좌측엔 해당하는 객체 프로퍼티의 패턴을 넣는다. 다음과 같이 쓰는 것이다.</p>\n<pre><code class=\"language-js\">let me = {\n  name: \"김성현\",\n  age: 26,\n  hobby: \"코딩\",\n};\n/* 해당하는 이름의 키를 갖는 프로퍼티가 할당되므로 순서는 상관없다.\nlet {age, name, hobby} 로 써도 결과는 같음 */\nlet { name, age, hobby } = me;\n// 김성현 26 코딩\nconsole.log(name, age, hobby);\n</code></pre>\n<p>그런데 객체의 프로퍼티 값을 저장하고자 하는 변수 이름이 프로퍼티 키와 다를 수도 있다. 그럴 경우 <code>:</code>를 쓰면 된다. <code>프로퍼티 키: 변수 이름</code> 형태로 쓰면 된다.</p>\n<pre><code class=\"language-js\">let me = {\n  name: \"김성현\",\n  age: 26,\n  hobby: \"코딩\",\n};\n\nlet { age: myAge, name: myName, hobby: myHobby } = me;\n// 김성현 26 코딩\nconsole.log(myName, myAge, myHobby);\n</code></pre>\n<p><code>=</code>를 쓰면 기본값을 설정할 수 있는 것은 배열 구조 분해 할당과 같다. 그리고 rest 연산자도 마찬가지로 사용할 수 있다.</p>\n<pre><code class=\"language-js\">let me = {\n  name: \"김성현\",\n  age: 26,\n  hobby: \"코딩\",\n};\n\nlet { age: myAge, ...rest } = me;\n// 26, {name: \"김성현\", hobby: \"코딩\"}\nconsole.log(myAge, rest);\n</code></pre>\n<p>구조 분해 할당은 기존 변수에도 할 수 있다. 그러나 <code>{}</code>를 표현식 안에서 쓰지 않고 주요 코드 흐름상에 배치하면 코드 블록으로 인식된다. 따라서 기존 변수에 구조 분해 할당을 하려면 할당문을 괄호로 감싸 주어야 한다.</p>\n<pre><code class=\"language-js\">let me = {\n  name: \"김성현\",\n  age: 26,\n  hobby: \"코딩\",\n};\n\nlet age, name, hobby;\n// 괄호로 할당문을 감싸서 코드블록이 아닌 것을 표현\n({ age: myAge, ...rest } = me);\n// 26, {name: \"김성현\", hobby: \"코딩\"}\nconsole.log(myAge, rest);\n</code></pre>\n<p>좀 더 복잡한 객체도 구조만 맞춰 준다면 구조 분해 할당을 할 수 있다.</p>\n<h1>4. Date 객체</h1>\n<p>Date 객체는 날짜와 시간을 다루는 데 사용하며 <code>new Date()</code>로 생성할 수 있다. 생성자에 인수를 넣지 않으면 현재 시간을 나타내는 Date 객체를 생성한다. 이것을 활용하는 방법들을 알아보자.</p>\n<h2>4.1. 특정 날짜 객체 생성</h2>\n<p><code>new Date(ms)</code>는 1970/1/1 0시 0분 0초에서 ms만큼의 밀리초가 지난 시점이 저장된 Date객체를 생성해 반환한다.</p>\n<p>만약 1970/1/1 이전의 시간을 생성하고 싶다면 ms에 음수를 넣으면 된다.</p>\n<pre><code class=\"language-js\">let date = new Date(0);\n// 1970-01-01T00:00:00.000Z\nconsole.log(date);\n</code></pre>\n<p><code>new Date(dateString)</code>의 dateString에 문자열 인수를 넣으면 자동으로 구문 분석되어 해당 시간이 저장된 Date 객체를 생성해 반환한다.</p>\n<pre><code class=\"language-js\">let date = new Date(\"2020-01-01\");\n// 2020-01-01T00:00:00.000Z\nconsole.log(date);\n</code></pre>\n<p><code>new Date(year, month, date, hours, minutes, seconds, ms)</code>의 인수로 연, 월, 일, 시, 분, 초, 밀리초를 넣으면 해당 시간이 저장된 Date 객체를 생성해 반환한다. 이를 사용하는 주의사항은 다음과 같다.</p>\n<ul>\n<li>year는 반드시 4자리 숫자여야 한다.</li>\n<li>월은 0부터 시작한다. 0은 1월, 1은 2월, 11은 12월을 나타낸다.</li>\n<li>일은 1부터 시작한다. 기본값은 1이다.</li>\n<li>시, 분, 초, 밀리초는 생략 가능하다. 생략하면 0으로 간주한다.</li>\n</ul>\n<h2>4.2. 날짜 객체 메서드</h2>\n<p>Date 객체에서 정보를 가져오는 다음과 같은 메서드가 있다.</p>\n<ul>\n<li><code>getFullYear()</code> : 연도를 반환한다. getYear()는 사용하지 않는다.</li>\n<li><code>getMonth()</code> : 월을 반환한다. 0부터 시작해서 11까지 있다.</li>\n<li><code>getDate()</code> : 일을 반환한다. 1~31이다.</li>\n<li><code>getDay()</code> : 요일을 반환한다. 0부터 시작한다. 0은 일요일, 1은 월요일, 6은 토요일을 나타낸다.</li>\n<li><code>getHours()</code> : 시를 반환한다.</li>\n<li><code>getMinutes()</code> : 분을 반환한다.</li>\n<li><code>getSeconds()</code> : 초를 반환한다.</li>\n<li><code>getMilliseconds()</code> : 밀리초를 반환한다.</li>\n<li><code>getTime()</code> : 1970/1/1 0시 0분 0초에서 현재까지의 밀리초를 반환한다.</li>\n</ul>\n<p>또한 get 대신 set을 쓰면 Date 객체의 정보를 설정할 수 있는 메서드가 된다.</p>\n<ul>\n<li>setFullYear(year, month, date)</li>\n<li>setMonth(month, date)</li>\n<li>setDate(date)</li>\n<li>setHours(hour, [min, sec, ms])</li>\n<li>setMinutes(min, [sec, ms])</li>\n<li>setSeconds(sec, [ms])</li>\n<li>setMilliseconds(ms)</li>\n<li>setTime(milliseconds)</li>\n</ul>\n<p>그리고 Date 객체는 자동 고침 기능을 지원한다. 예를 들어 1월 32일 같은 값은 없다. 그런 값으로 Date 객체를 생성하려고 하면 자동으로 2월 1일로 수정된다. 초과된 시간이 알아서 다른 구성요소에 배분되는 것이다.</p>\n<pre><code class=\"language-js\">let now = new Date(2020, 01, 50);\n// 01은 2월로 취급되므로 결과는 2020년 3월 21일이다\nconsole.log(now);\n</code></pre>\n<p>이런 자동 고침 기능은 일정 시간이나 날짜를 더하거나 빼는 연산에도 적용된다.</p>\n<pre><code class=\"language-js\">let now = new Date();\nnow.setHours(now.getHours() + 3); \n//3시간이 지난 후의 시간\nconsole.log(now);\n// 일은 1부터 시작하는데 0으로 설정하면 이전 달의 마지막 날이 된다\nnow.setDate(0);\nconsole.log(now);\n</code></pre>\n<h2>4.3. 형변환</h2>\n<p>Date객체는 숫자형으로 변환하면 1970/1/1 0시 0분 0초에서 현재까지 경과를 밀리초를 반환한다. getTime 메서드를 사용하는 것과 똑같다.</p>\n<pre><code class=\"language-js\">let now = new Date();\nconsole.log(+now);\n</code></pre>\n<p>이렇게 현재 시간을 밀리초로 변환한 결과는 Date 객체를 만들지 않고도 가능하다. Date.now()를 사용하면 된다. 이는 중간에 Date 객체를 만들지 않으므로 getTime보다 빠르고 가비지 컬렉션이 필요없다.</p>\n<h2>4.4. Date.parse</h2>\n<p>Date.parse는 문자열을 Date 객체로 변환한다. 이때 문자열은 <code>YYYY-MM-DDTHH:mm:ss.sssZ</code> 형식이어야 한다. ss.sss는 초와 밀리초를 나타낸다. 그리고 Z는 UTC+0 시간대임을 나타낸다. 만약 이를 <code>+HH:mm</code>이나 <code>-HH:mm</code> 형식으로 바꾸면 UTC+0 시간대가 아닌 다른 시간대를 나타낼 수 있다.</p>\n<p>그리고 YYYY, YYYY-MM, YYYY-MM-DD 형식도 지원한다. 이때는 시간은 0시 0분 0초로 설정된다.</p>\n<p>이런 형식에 맞는 문자열을 대상으로 Date.parse를 호출하면 그 시간까지의 타임스탬프를 반환한다. 형식에 맞지 않는 문자열일 경우 NaN을 반환한다.</p>\n<p>그걸 기반으로 Date 객체를 만들려면 <code>new Date(Date.parse(str))</code> 형태로 사용하면 된다.</p>\n<h1>5. JSON</h1>\n<p>JSON은 JavaScript Object Notation의 약자로 자바스크립트의 값이나 객체를 나타내는 표기법이다. 그러나 JSON을 다른 언어에서도 사용할 수 있다. 그런 기능을 지원하는 라이브러리를 사용하면 된다.</p>\n<p>하지만 JS에선 기본적으로 JSON을 다루는 메서드를 지원한다. <code>JSON.stringify</code>와 <code>JSON.parse</code>이다. 각각 객체를 JSON으로, JSON을 객체로 변환한다.</p>\n<pre><code class=\"language-js\">let me = {\n  name: \"김성현\",\n  age: 25,\n  hobby: \"코딩\",\n};\n\nlet meJSON = JSON.stringify(me);\n// 객체가 문자열로 변환된 결과\nconsole.log(meJSON);\n</code></pre>\n<p><code>JSON.stringify</code>로 변환된 문자열은 JSON으로 인코딩되고, 직렬화 처리되고, 문자열로 변환된, 그리고 결집된 객체이다. 이렇게 문자열로 변환된 객체는 네트워크를 통해 전송하거나 저장소에 저장 가능하다.</p>\n<h2>5.1. 객체 인코딩</h2>\n<p><code>JSON.stringify</code>로 인코딩된 객체는 다음과 같은 특징을 갖는다.</p>\n<ol>\n<li>문자열은 큰따옴표로 감싸진다. 작은따옴표나 백틱은 안된다.</li>\n<li>객체 프로퍼티 이름은 큰따옴표로 감싸진다. \"age\":30과 같이 표현된다.</li>\n</ol>\n<p>또한 객체, 배열도 인코딩할 수 있으며 문자형, 숫자형, 불린형, null도 인코딩 가능하다. 이때 문자열을 인코딩할 시 무조건 큰따옴표로 감싸진다.</p>\n<p>이때 JSON은 언어에 종속되지 않는 포맷이므로 <code>JSON.stringify</code>의 인코딩에서 JS 특유의 프로퍼티는 무시된다.</p>\n<p>즉 함수 프로퍼티, 키가 심볼인 프로퍼티, 값이 undefined인 프로퍼티는 인코딩에서 제외된다.</p>\n<pre><code class=\"language-js\">let me = {\n  name: \"김성현\",\n  age: 25,\n  hobby: \"코딩\",\n  // 이 아래는 무시됨\n  sayHi: function () {\n    console.log(`안녕하세요 ${this.name}입니다.`);\n  },\n  [Symbol(\"id\")]: 12345,\n  temp: undefined,\n};\n\nlet meJSON = JSON.stringify(me);\n// 객체가 문자열로 변환된 결과\nconsole.log(meJSON);\n</code></pre>\n<p>또한 객체의 프로퍼티 값으로 객체가 있을 경우, 그 객체도 인코딩된다. 즉 중첩 객체도 잘 인코딩된다. 단 주의할 점은 순환 참조가 있을 때는 인코딩이 제대로 안된다는 것이다.</p>\n<pre><code class=\"language-js\">let room = {\n  number: 105,\n};\n\nlet me = {\n  name: \"김성현\",\n  age: 25,\n  hobby: \"코딩\",\n};\n\nme.address = room;\nroom.owner = me;\n// Uncaught TypeError: Converting circular structure to JSON 즉 순환참조 오류\nlet meJSON = JSON.stringify(me);\nconsole.log(meJSON);\n</code></pre>\n<h2>5.2. replacer</h2>\n<p><code>JSON.stringify</code>의 전체 형태는 다음과 같다.</p>\n<pre><code class=\"language-js\">let json = JSON.stringify(value[, replacer, space]);\n</code></pre>\n<p>value는 앞에서 보았듯 인코딩하고자 하는 값이다. 그리고 replacer는 인코딩할 때 어떤 프로퍼티를 인코딩할지가 담긴 배열이나 매핑 함수이다. space는 서식 변경 목적으로 사용할 공백의 개수이다.</p>\n<p>보통 <code>JSON.stringify</code>에는 인수를 하나만 넘기지만 순환 참조를 다룰 경우 2번째 인수를 사용한다.</p>\n<p>예를 들어 위의 코드에서는 me 객체의 address프로퍼티가 room 객체를 참조하고 room 객체의 owner 프로퍼티가 me 객체를 참조하므로 순환 참조가 발생하였다. 이를 해결하기 위해선 replacer 인수에 \"address\"를 뺀 키값들이 담겨 있는 배열을 넘겨주면 그 프로퍼티들만 인코딩된다.</p>\n<pre><code class=\"language-js\">let room = {\n  number: 105,\n};\n\nlet me = {\n  name: \"김성현\",\n  age: 25,\n  hobby: \"코딩\",\n  friend: [{ name: \"김기동\" }, { name: \"김형식\" }],\n};\n\nme.address = room;\nroom.owner = me;\nlet meJSON = JSON.stringify(me, [\"name\", \"age\", \"hobby\", \"friend\"]);\n/* {\"name\":\"김성현\",\"age\":25,\"hobby\":\"코딩\",\"friend\":[{\"name\":\"김기동\"},{\"name\":\"김형식\"}]}\naddress를 인코딩에서 제외 */\nconsole.log(meJSON);\n</code></pre>\n<p>또한 replacer 인수에는 매핑 함수를 넘겨줄 수도 있다. 매핑 함수는 인코딩할 프로퍼티의 키와 값을 매개변수로 받는다. 이 함수는 반환값을 가지는데, 반환값이 undefined이면 해당 프로퍼티는 인코딩에서 제외된다.</p>\n<p>따라서 위와 같은 코드의 경우 key가 \"address\"일 때 undefined를 반환하는 함수를 replacer로 전달하면 address 프로퍼티는 인코딩에서 제외된다.</p>\n<pre><code class=\"language-js\">let room = {\n  number: 105,\n};\n\nlet me = {\n  name: \"김성현\",\n  age: 25,\n  hobby: \"코딩\",\n  friend: [{ name: \"김기동\" }, { name: \"김형식\" }],\n};\n\nme.address = room;\nroom.owner = me;\nlet meJSON = JSON.stringify(me, function replacer(key, value) {\n  if (key === \"address\") {\n    return undefined;\n  }\n  console.log(key, value);\n  return value;\n});\nconsole.log(meJSON);\n</code></pre>\n<p>이때 replacer 함수에 key, value를 로그로 찍는 기능을 추가해 보면, replacer 함수가 중첩 객체와 배열 요소까지 포함해서 모든 키-값 쌍을 처리한다는 걸 알 수 있다. 재귀적으로 처리하는 것이다.</p>\n<p>또한 맨 처음에 이 함수가 호출될 땐 <code>{\"\":me}</code> 형태의 래퍼 객체가 만들어지기 때문에 맨 처음에는 인코딩되는 객체 자신이 replacer 함수의 value로 들어가게 된다.</p>\n<p>위 코드의 로그 결과는 다음과 같다.</p>\n<p><img src=\"/static/stringifyLog-5964008d.png\" alt=\"stringify\"></p>\n<p>이런 식으로 replacer 인수를 이용해 원하는 프로퍼티만 인코딩할 수 있다.</p>\n<h2>5.3. space</h2>\n<p><code>JSON.stringify</code>의 3번째 인수 space는 가독성을 높이기 위해 중간에 삽입할 공백문자 수를 나타낸다. space 수에 따라 들여쓰기가 되고 중첩 객체는 별도의 줄에 출력된다.</p>\n<pre><code class=\"language-js\">let me = {\n  name: \"김성현\",\n  age: 25,\n  hobby: \"코딩\",\n};\n\nlet meJSON = JSON.stringify(me, null, 4);\n/*\n{\n    \"name\": \"김성현\",\n    \"age\": 25,\n    \"hobby\": \"코딩\"\n}\n*/\nconsole.log(meJSON);\n</code></pre>\n<h2>5.4. toJSON</h2>\n<p>객체에 toJSON 메서드가 있으면 <code>JSON.stringify</code>는 toJSON 메서드를 호출해서 반환값을 인코딩한다. 따라서 toJSON 메서드를 구현하면 <code>JSON.stringify</code>가 반환하는 문자열을 조작할 수 있다.</p>\n<pre><code class=\"language-js\">let me = {\n  name: \"김성현\",\n  age: 25,\n  hobby: \"코딩\",\n  toJSON: function () {\n    return this.age;\n  },\n};\n\n// writer는 me 객체를 참조하고 있으므로 me.toJSON()이 호출된다.\n// 그러면 me.age가 반환되고 이 값이 인코딩된다.\nlet profile = {\n  title: \"안녕하세요\",\n  content: \"저는 김성현입니다.\",\n  writer: me,\n};\n\nlet meJSON = JSON.stringify(profile);\nconsole.log(meJSON);\n</code></pre>\n<h2>5.5. JSON.parse</h2>\n<p><code>JSON.parse</code>는 JSON 문자열을 파싱해서 자바스크립트 객체로 반환한다. <code>JSON.parse</code>는 2개의 인수를 받는데, 첫 번째 인수는 파싱할 JSON 문자열이고 두 번째 인수는 reviver 함수다.</p>\n<pre><code class=\"language-js\">let value=JSON.parse(str, [reviver])\n</code></pre>\n<p>이 함수는 디버깅을 위해 JSON을 직접 만들고 디코딩할 때도 많이 쓰인다. 그런데 이렇게 JSON을 직접 만들 때는 JSON 문자열이 유효한지 검사하지 않는다. 따라서 유효하지 않은 JSON 문자열을 파싱하면 에러가 발생한다.</p>\n<p>그러니 다음과 같은 점을 주의해서 JSON 문자열을 만들어야 한다.</p>\n<ol>\n<li>프로퍼티 키와 문자열 값은 큰따옴표로 감싸야 한다. 작은따옴표나 백틱은 안된다.</li>\n<li>new같은 걸 사용하면 안된다. 순수한 값만 사용해야 한다.</li>\n</ol>\n<p>그리고 두번째 인수인 reviver 함수는 모든 (key, value) 쌍 대상으로 호출된다. 이 함수는 반환값을 반환하면 그 값을 사용하고 반환값이 없으면 value를 그대로 사용한다.</p>\n<p>예를 들어서 key가 date인 경우 value를 Date 객체로 변환하고 싶다면 다음과 같이 reviver 함수를 구현하면 된다.</p>\n<pre><code class=\"language-js\">let json = `{\n    \"name\": \"김성현\",\n    \"age\": 25,\n    \"hobby\": \"코딩\",\n    \"date\": \"2021-01-01\"\n}`;\n\nlet obj = JSON.parse(json, (key, value) => {\n  if (key === \"date\") {\n    return new Date(value);\n  }\n  return value;\n});\n\nconsole.log(obj.date.getFullYear());\n</code></pre>",
    "excerpt": "1. 맵과 셋\n1.1. 맵\nMap은 데이터를 키-값 형식으로 저장한다. 객체와 다른 점은 키에 다양한 자료형이 허용된다는 것이다. 객체도 키로 쓸 수 있다. 다음과 같은 메서드들이 있다.\n\nnew Map()\nmap.set(key, value) : 맵 스스로가 반환된다. 따라서 chaining도 가능\nmap.get(key) : 키가 존재하지 않으면 undefined 반환\nmap.has(key)\nmap.delete(key)\nmap.clear()\nmap.keys()\n",
    "headingTree": [
      {
        "title": "1. 맵과 셋",
        "url": "#1-맵과-셋",
        "items": [
          {
            "title": "1.1. 맵",
            "url": "#11-맵",
            "items": [
              {
                "title": "1.1.1. 객체와 맵",
                "url": "#111-객체와-맵",
                "items": []
              }
            ]
          },
          {
            "title": "1.2. 셋",
            "url": "#12-셋",
            "items": []
          },
          {
            "title": "1.3. 위크맵과 위크셋",
            "url": "#13-위크맵과-위크셋",
            "items": []
          }
        ]
      },
      {
        "title": "2. keys, values, entries",
        "url": "#2-keys-values-entries",
        "items": [
          {
            "title": "2.1. 객체에 배열 메서드 쓰기",
            "url": "#21-객체에-배열-메서드-쓰기",
            "items": []
          }
        ]
      },
      {
        "title": "3. 구조 분해 할당",
        "url": "#3-구조-분해-할당",
        "items": [
          {
            "title": "3.1. 배열 구조 분해 할당",
            "url": "#31-배열-구조-분해-할당",
            "items": []
          },
          {
            "title": "3.2. 객체 구조 분해 할당",
            "url": "#32-객체-구조-분해-할당",
            "items": []
          }
        ]
      },
      {
        "title": "4. Date 객체",
        "url": "#4-date-객체",
        "items": [
          {
            "title": "4.1. 특정 날짜 객체 생성",
            "url": "#41-특정-날짜-객체-생성",
            "items": []
          },
          {
            "title": "4.2. 날짜 객체 메서드",
            "url": "#42-날짜-객체-메서드",
            "items": []
          },
          {
            "title": "4.3. 형변환",
            "url": "#43-형변환",
            "items": []
          },
          {
            "title": "4.4. Date.parse",
            "url": "#44-dateparse",
            "items": []
          }
        ]
      },
      {
        "title": "5. JSON",
        "url": "#5-json",
        "items": [
          {
            "title": "5.1. 객체 인코딩",
            "url": "#51-객체-인코딩",
            "items": []
          },
          {
            "title": "5.2. replacer",
            "url": "#52-replacer",
            "items": []
          },
          {
            "title": "5.3. space",
            "url": "#53-space",
            "items": []
          },
          {
            "title": "5.4. toJSON",
            "url": "#54-tojson",
            "items": []
          },
          {
            "title": "5.5. JSON.parse",
            "url": "#55-jsonparse",
            "items": []
          }
        ]
      }
    ],
    "metadata": {
      "readingTime": 3,
      "wordCount": 793
    },
    "url": "/posts/javascript-10",
    "thumbnail": {
      "local": "/static/stringifyLog-5964008d.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-stringifyLog-5964008d-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAIAAAA8r+mnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAb0lEQVR4nAFkAJv/AIGBgYqEhKqqra+traunqJ+fn1paWjw9PQBSUlSOjY7e3t709PT39vb///+UlJRGRkYAamtrY15e39zc/P399PT0////ioqKPD09ADw9PRcXF2pra5+foJydnZ+fn35/f3d3dz26OAYOcfZDAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "javascript-14",
    "title": "모던 자바스크립트 튜토리얼 part 1.6 함수 심화학습 네번째",
    "date": "2023-02-04T00:00:00Z",
    "description": "ko.javascript.info part 1-6 4번째",
    "tags": [
      "javascript"
    ],
    "html": "<h1>1. 함수 바인딩</h1>\n<p>객체 메서드가 객체 내부가 아닌 다른 곳에 전달되거나 콜백으로 사용되면 this 정보가 사라지는 문제가 생긴다. 예를 들어서 setTimeout 함수는 this 정보를 잃어버린다.</p>\n<pre><code class=\"language-js\">let me = {\n  firstName: \"김성현\",\n  greeting() {\n    console.log(`안녕하세요. ${this.firstName}입니다.`);\n  },\n};\n\nme.greeting(); // 안녕하세요. 김성현입니다.\nsetTimeout(me.greeting, 1000); // 안녕하세요. undefined입니다\n</code></pre>\n<p>이는 setTimeout에 me.greeting을 전달할 때 객체 맥락에서 분리된 함수만이 전달되기 때문이다.</p>\n<p>그리고 이게 만약 브라우저 환경이라면 setTimeout 메서드는 window 객체를 가리키는 this를 가지게 된다.</p>\n<pre><code class=\"language-js\">let me = {\n  firstName: \"김성현\",\n  greeting() {\n    console.log(`안녕하세요. ${this.firstName}입니다.`);\n  },\n};\nwindow.firstName = \"이름없음\";\n\nme.greeting(); // 안녕하세요. 김성현입니다.\nsetTimeout(me.greeting, 1000); // 안녕하세요. 이름없음입니다.\n// 브라우저 환경에서 this는 window를 가리키기 때문에 window.firstName이 출력됨\n</code></pre>\n<p>그럼 객체 메서드를 전달할 때 맥락도 유지하려면 어떻게 할까?</p>\n<h2>1.1. 래퍼 함수</h2>\n<p>다음과 같이 래퍼 함수를 만들면 me.greeting을 호출할 때 콜백으로 호출되는 게 아니라 보통 때처럼 me 객체의 메서드로 호출되기 때문에 정상적으로 작동한다.</p>\n<pre><code class=\"language-js\">let me = {\n  firstName: \"김성현\",\n  greeting() {\n    console.log(`안녕하세요. ${this.firstName}입니다.`);\n  },\n};\n\nsetTimeout(function () {\n  me.greeting();\n}, 1000);\n</code></pre>\n<p>하지만 만약 setTimeout 콜백이 실행되기 전에 me.greeting이 변경되면 문제가 생긴다.</p>\n<pre><code class=\"language-js\">let me = {\n  firstName: \"김성현\",\n  greeting() {\n    console.log(`안녕하세요. ${this.firstName}입니다.`);\n  },\n};\n\nsetTimeout(function () {\n  me.greeting();\n}, 1000);\nme.greeting = () => {\n  console.log(\"변경된 함수\");\n};\n// 1초 뒤에 '변경된 함수' 출력\n</code></pre>\n<p>따라서 이런 경우 bind 메서드를 사용하면 된다.</p>\n<h2>1.2. bind</h2>\n<p><code>func.bind(context)</code>는 func를 호출할 때 this를 context로 고정시킨 새로운 함수를 반환한다. 즉 다음과 같이 me.greeting의 this를 me로 고정시킨 새로운 함수를 만들어서 setTimeout에 전달하면 된다.</p>\n<pre><code class=\"language-js\">let me = {\n  firstName: \"김성현\",\n  greeting() {\n    console.log(`안녕하세요. ${this.firstName}입니다.`);\n  },\n};\n\nlet myGreeting = me.greeting.bind(me);\nsetTimeout(myGreeting, 1000);\n</code></pre>\n<p>bind를 사용하면 this만 고정되고 함수 인수는 그대로 전달된다.</p>\n<p>만약 객체에 메서드가 여러 개 있고 메서드 전체를 전달하려 하면 반복문을 쓸 수 있다.</p>\n<pre><code class=\"language-js\">// 반복문을 써서 메서드 바인딩\nfor(let key in obj){\n  if(typeof obj[key] === 'function'){\n    obj[key] = obj[key].bind(obj);\n  }\n}\n</code></pre>\n<h2>1.3. 인수 바인딩</h2>\n<p>bind 메서드는 this를 고정시키는 것 뿐만 아니라 함수 인수를 고정시킬 수도 있다. 다음과 같이 bind 메서드에 인수를 전달하면 된다.</p>\n<pre><code class=\"language-js\">function f(a, b) {\n  console.log(a + b);\n}\n\nlet addTwo = f.bind(null, 2);\nconsole.log(g(1)); // 3\n</code></pre>\n<p>이런 방식을 partial function이라고 한다. 기존 함수의 매개변수 중 일부를 고정시킨 새로운 함수를 만들어주는 기능이다. 포괄적인 함수 하나를 기반으로 여러 변형 함수를 만들어내는 데 쓸 수 있다.</p>\n<p>그런데 bind 메서드를 사용하려면 this를 기본적으로 지정해 줘야 하는데, 매번 this를 고정할 객체를 찾아 주는 건 번거롭다. 따라서 this는 알아서 처리해 주고 인수만 고정시킬 수 있는 함수를 짜볼 수 있다.</p>\n<pre><code class=\"language-js\">// argsBound는 고정할 인수들\nfunction partial(func, ...argsBound) {\n  return function (...args) {\n    // 객체 메서드와 같은 this를 사용하기 위해 call 사용\n    return func.call(this, ...argsBound, ...args);\n  };\n}\n</code></pre>\n<p>이 함수를 쓰면 partial로 고정되기 전 함수의 this를 partial로 인수가 고정된 함수에 바인딩해 준다.</p>\n<h2>1.4. bind의 특성</h2>\n<p>bind가 반환한 특수 객체인 묶인 함수는 함수 생성 시점의 컨텍스트 그리고 bind에서 제공된 인수만을 기억한다. 따라서 한번 bind를 호출하여 묶인 함수에 다시 bind를 호출해도 무시된다.</p>\n<pre><code class=\"language-js\">function f() {\n  console.log(this.name);\n}\n\nlet g = f.bind({ name: \"John\" }).bind({ name: \"김성현\" });\ng();\n// John\n</code></pre>\n<p>또한 bind를 사용하면 새로운 함수 객체가 만들어져서 반환되므로 기존 함수의 프로퍼티는 묶인 함수에는 없다.</p>\n<pre><code class=\"language-js\">function f() {\n  console.log(this.name);\n}\nf.test = 1;\n\nlet g = f.bind({ name: \"John\" });\nconsole.log(f.test); // 1\nconsole.log(g.test); // undefined\n</code></pre>\n<h1>2. 화살표 함수 revisit</h1>\n<p>JS에선 forEach 등을 사용할 때 함수를 생성하고 그것을 전달하는 일이 많이 일어난다. 이때 화살표 함수를 사용하면 현재 컨텍스트를 잃지 않게 된다.</p>\n<p>화살표 함수는 this를 고유하게 가지지 않는다. 화살표 함수에서 this를 사용하면 화살표 함수가 아닌 외부 함수에서 this 값을 가져온다. 따라서 화살표 함수를 사용할 시 별개의 this 없이 외부 컨텍스트의 this를 사용할 수 있다.</p>\n<p>예를 들어서, 스터디 인원이 담겨 있고 그들을 차례로 출력하는 함수를 가진 객체를 만들어 보자. 이때 forEach에 function을 통해 만든 함수를 넘겨주면 그 함수의 this는 window(브라우저 환경에서는)를 가리키게 된다.</p>\n<pre><code class=\"language-js\">let study = {\n  goal: \"study JS\",\n  people: [\"John\", \"Jane\", \"Jack\", \"Jill\"],\n\n  printPeople: function () {\n    this.people.forEach(function (person) {\n      // 이 경우 여기서의 this는 window가 되므로 결과가 이상하게 나올 것\n      console.log(`${this.goal}: ${person}`);\n    });\n  },\n};\n\nstudy.printPeople();\n</code></pre>\n<p>이를 제대로 작동시키기 위해서는 화살표 함수를 써야 한다.</p>\n<pre><code class=\"language-js\">let study = {\n  goal: \"study JS\",\n  people: [\"John\", \"Jane\", \"Jack\", \"Jill\"],\n\n  printPeople: function () {\n    this.people.forEach((person) => {\n      // 여기서의 this는 화살표 함수가 아닌 외부 함수인 printPeople을 호출한 객체를 가리키게 된다\n      console.log(`${this.goal}: ${person}`);\n    });\n  },\n};\n\nstudy.printPeople();\n/*study JS: John\nstudy JS: Jane\nstudy JS: Jack\nstudy JS: Jill */\n</code></pre>\n<p>화살표 함수는 this가 없기에 생성자로 사용할 수 없다. 그리고 <code>bind</code>와도 다른데, <code>bind</code>는 함수의 this를 고정시킨 새로운 함수를 만들고, 또한 외부 렉시컬 환경이 아닌 아예 다른 객체를 this로 설정할 수도 있다.</p>\n<p>그러나 화살표 함수는 this를 특별히 바인딩하지 않고, 아예 this가 존재하지 않기에 외부 렉시컬 환경의 this를 사용하게 되는 것 뿐이다.</p>",
    "excerpt": "1. 함수 바인딩\n객체 메서드가 객체 내부가 아닌 다른 곳에 전달되거나 콜백으로 사용되면 this 정보가 사라지는 문제가 생긴다. 예를 들어서 setTimeout 함수는 this 정보를 잃어버린다.\nlet me = {\n  firstName: \"김성현\",\n  greeting() {\n    console.log(`안녕하세요. ${this.firstName}입니다.`);\n  },\n};\n\nme.greeting(); // 안녕하세요. 김성현입니다.\nsetTimeout(m",
    "headingTree": [
      {
        "title": "1. 함수 바인딩",
        "url": "#1-함수-바인딩",
        "items": [
          {
            "title": "1.1. 래퍼 함수",
            "url": "#11-래퍼-함수",
            "items": []
          },
          {
            "title": "1.2. bind",
            "url": "#12-bind",
            "items": []
          },
          {
            "title": "1.3. 인수 바인딩",
            "url": "#13-인수-바인딩",
            "items": []
          },
          {
            "title": "1.4. bind의 특성",
            "url": "#14-bind의-특성",
            "items": []
          }
        ]
      },
      {
        "title": "2. 화살표 함수 revisit",
        "url": "#2-화살표-함수-revisit",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 295
    },
    "url": "/posts/javascript-14",
    "thumbnail": {
      "local": "/thumbnails/javascript-14-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-javascript-14-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAh0lEQVR4nDXKIQqDIRiAYYPFcxiMnkDwAlb3Cyaj4DE+MNvGdoTJYPMCgsnsSawGB/u3tz4vSilZa7XWzrkQAufcGMMYQzFGIQQAiG+11jFGaw2FEAghlFIpJcZYKbX3XmuhUt7eewDovddae+8/uN7ul+MAgJzznHP/Q4/nK+dcShljnO8JH5zPVq3+PJmtAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "javascript-18",
    "title": "모던 자바스크립트 튜토리얼 part 1.9 클래스",
    "date": "2023-02-10T00:00:00Z",
    "description": "ko.javascript.info part 1-9 첫번째",
    "tags": [
      "javascript"
    ],
    "html": "<h1>1. 클래스와 기본 문법</h1>\n<p>같은 객체를 여러 개 생성할 때는 앞에서 배운 생성자 함수를 사용할 수도 있지만 모던 JS에서 도입된 클래스를 사용할 수 있다.</p>\n<pre><code class=\"language-js\">class MyClass{\n  constructor(){\n    //생성자\n  }\n  method(){}\n}\n</code></pre>\n<p><code>new MyClass()</code>를 호출하면 객체가 만들어지고 constructor가 실행된다.</p>\n<h2>1.1. 클래스가 뭔가?</h2>\n<p>클래스는 함수의 한 종류이다.</p>\n<pre><code class=\"language-js\">class MyClass {}\nconsole.log(typeof MyClass); //function\n</code></pre>\n<p>클래스 문법은 다음과 같이 작동한다. 먼저 클래스 이름과 같은 함수를 만들고, 함수 본문을 constructor 메서드에서 가져온다. 그리고 클래스 메서드를 클래스이름.prototype에 추가한다. 즉 클래스 메서드는 prototype에서 가져오는 것이다.</p>\n<pre><code class=\"language-js\">class MyClass {\n  constructor() {\n    this.myVar = 1;\n  }\n  myMethod() {\n    return this.myVar;\n  }\n}\n\nconsole.log(MyClass === MyClass.prototype.constructor); // true\nconsole.log(MyClass.prototype.myMethod); // 위 클래스에서 정의한 myMethod 함수 내용\n</code></pre>\n<h2>1.2. 클래스와 생성자 함수</h2>\n<p>클래스는 생성자 함수와 비슷한 기능을 하므로 클래스와 같은 기능을 하는 생성자 함수를 만들 수도 있다. 그러나 클래스는 단순한 설탕이 아니다.</p>\n<p>첫번째 차이는 class를 통해서 만들어진 같은 이름의 함수에는 <code>[[IsClassConstructor]]:true</code>내부 프로퍼티가 붙는다. 이 프로퍼티 때문에 class 생성자는 new를 붙여 호출하지 않으면 에러가 발생하게 된다.</p>\n<p>문자열로 변환할 때도 마찬가지다. class를 문자열로 변환하면 class로 시작하는 문자열이 반환된다. 이때 클래스임을 구분하기 위해 IsClassConstructor 내부 프로퍼티가 사용된다.</p>\n<pre><code class=\"language-js\">class MyClass {\n  constructor() {\n    this.myVar = 1;\n  }\n  myMethod() {\n    return this.myVar;\n  }\n}\n\nconsole.log(MyClass.toString()); // class로 시작함\n\nfunction MyFunction() {\n  this.myVar = 1;\n  this.myMethod = function () {\n    return this.myVar;\n  };\n}\n\nconsole.log(MyFunction.toString());\n// function으로 시작함\n</code></pre>\n<p>클래스에 있는 메서드는 enumerable이 아니다. 그래서 for..in 반복문에서는 나타나지 않는다. 또한 클래스는 항상 strict mode로 실행된다.</p>\n<h2>1.3. 클래스 표현식</h2>\n<p>함수 표현식과 비슷하다. 또한 클래스 표현식에 클래스 이름을 쓰면 클래스 내부에서만 사용할 수 있는 이름을 만들 수 있다.</p>\n<pre><code class=\"language-js\">let MyClass = class {\n  constructor() {\n    this.myVar = 1;\n  }\n  myMethod() {\n    return this.myVar;\n  }\n};\n\nlet myInstance = new MyClass();\nconsole.log(myInstance.myMethod()); //1\n</code></pre>\n<p>물론 함수에서 클래스를 반환하는 식으로, 클래스의 동적 생성도 가능하다.</p>\n<h2>1.4. getter, setter, 계산된 프로퍼티</h2>\n<p>클래스에 getter, setter도 설정할 수 있다. 또한 <code>[]</code>를 이용해서 계산된 프로퍼티 이름도 쓸 수 있다.</p>\n<pre><code class=\"language-js\">let MyClass = class {\n  constructor(myName) {\n    this.foo = myName;\n    this.myNumber = 1;\n  }\n  get myNumber() {\n    return this._myNumber;\n  }\n  set myNumber(value) {\n    this._myNumber = value;\n  }\n  // 계산된 메서드 이름\n  [\"sung\" + 1]() {\n    console.log(\"hello\");\n  }\n};\n\nlet myInstance = new MyClass(\"sunghyun\");\nconsole.log(myInstance.foo);\nconsole.log(myInstance.myNumber);\nmyInstance.sung1(); // hello\n</code></pre>\n<h2>1.5. 클래스 필드</h2>\n<p><code>클래스 프로퍼티 이름=값</code>과 같이 클래스 필드를 만들 수 있다. 이는 개별 객체마다 클래스 필드를 따로 설정한다. 클래스 메서드와 달리 클래스이름.prototype이 아니라 클래스 인스턴스 자체에 저장된다.</p>\n<pre><code class=\"language-js\">class MyClass {\n  value = 1;\n  constructor() {}\n  method() {\n    this.value = 2;\n  }\n}\n\nlet inst1 = new MyClass();\nlet inst2 = new MyClass();\ninst1.method();\nconsole.log(inst1.value, inst2.value); //2 1\n</code></pre>\n<p>위 코드를 통해 각 클래스 인스턴스에 저장된 클래스 필드는 별개라는 것을 알 수 있다.</p>\n<h2>1.6. 클래스 필드 활용</h2>\n<p>그럼 이는 어떻게 쓸 수 있을까? 클래스 필드를 이용해서 바인딩된 메서드를 만들 수 있다.</p>\n<p>JS에서 this는 동적으로 결정된다. 따라서 다른 컨텍스트에서 객체 메서드를 호출하게 되면 this가 제대로 동작하지 않을 수 있다.</p>\n<pre><code class=\"language-js\">function func(callback) {\n  callback();\n}\n\nlet obj = {\n  value: 1,\n  method() {\n    console.log(this.value);\n  },\n};\nobj.method(); // 1\nfunc(obj.method); //undefined\n// obj.method가 객체와 분리된 상태에서 저장되므로..\n</code></pre>\n<p>이를 해결하기 위해 래퍼 함수를 만들거나 bind, call 등을 사용할 수 있다. 그러나 클래스 필드를 사용할 수도 있다. 애초에 래퍼 함수를 클래스 필드로 하는 것이다.</p>\n<p>기존에 작성한, this가 제대로 작동하지 않는 코드는 다음과 같다.</p>\n<pre><code class=\"language-js\">function func(callback) {\n  return callback();\n}\n\nclass MyClass {\n  constructor() {\n    this.myVar = 1;\n  }\n  myMethod() {\n    return this.myVar;\n  }\n}\n\nconst myClass = new MyClass();\nconsole.log(myClass.myMethod()); //1\nconsole.log(func(myClass.myMethod)); // this 참조가 안되므로 에러\n</code></pre>\n<p>클래스 필드 자체를 화살표 함수로 작성한다. 그러면 화살표 함수는 this가 없으므로 상위 스코프의 this를 참조한다. 따라서 여기서의 this는 MyClass를 참조하게 된다.</p>\n<pre><code class=\"language-js\">function func(callback) {\n  return callback();\n}\n\nclass MyClass {\n  constructor() {\n    this.myVar = 1;\n  }\n  myMethod = () => this.myVar;\n}\n\nconst myClass = new MyClass();\nconsole.log(myClass.myMethod()); //1\nconsole.log(func(myClass.myMethod)); // 1\n</code></pre>\n<h2>1.7. 클래스 필드 화살표 함수 사용의 단점</h2>\n<p>스터디 자료에 달린 댓글에 있는 내용이다. 클래스 필드에 화살표 함수를 사용하는 위의 방법은 단점도 있다.</p>\n<p>먼저 화살표 함수는 클래스의 메서드가 아니라 클래스 필드에 함수 객체를 넣은 것이다. 따라서 클래스이름.prototype에 저장되어 있지 않다.</p>\n<pre><code class=\"language-js\">class MyClass {\n  constructor() {}\n  myFunc() {\n    return 1;\n  }\n}\n\nconsole.log(MyClass.prototype.myFunc()); //1\n\nclass MyClass2 {\n  constructor() {}\n  myFunc = () => {\n    return 1;\n  };\n}\n\nconsole.log(MyClass2.prototype.myFunc()); // 에러\n</code></pre>\n<p>따라서 테스트 케이스 작성 시 문제가 있다고 한다.</p>\n<p>그리고 상속이 안 된다고 하는데 이는 이제 해결된 듯 하다.</p>\n<h1>2. 클래스 상속</h1>\n<p>extends 키워드로 클래스를 상속할 수 있다. 이때 이 상속은 프로토타입을 사용한다.</p>\n<p>기존 클래</p>",
    "excerpt": "1. 클래스와 기본 문법\n같은 객체를 여러 개 생성할 때는 앞에서 배운 생성자 함수를 사용할 수도 있지만 모던 JS에서 도입된 클래스를 사용할 수 있다.\nclass MyClass{\n  constructor(){\n    //생성자\n  }\n  method(){}\n}\n\nnew MyClass()를 호출하면 객체가 만들어지고 constructor가 실행된다.\n1.1. 클래스가 뭔가?\n클래스는 함수의 한 종류이다.\nclass MyClass {}\nconsole.log(typ",
    "headingTree": [
      {
        "title": "1. 클래스와 기본 문법",
        "url": "#1-클래스와-기본-문법",
        "items": [
          {
            "title": "1.1. 클래스가 뭔가?",
            "url": "#11-클래스가-뭔가",
            "items": []
          },
          {
            "title": "1.2. 클래스와 생성자 함수",
            "url": "#12-클래스와-생성자-함수",
            "items": []
          },
          {
            "title": "1.3. 클래스 표현식",
            "url": "#13-클래스-표현식",
            "items": []
          },
          {
            "title": "1.4. getter, setter, 계산된 프로퍼티",
            "url": "#14-getter-setter-계산된-프로퍼티",
            "items": []
          },
          {
            "title": "1.5. 클래스 필드",
            "url": "#15-클래스-필드",
            "items": []
          },
          {
            "title": "1.6. 클래스 필드 활용",
            "url": "#16-클래스-필드-활용",
            "items": []
          },
          {
            "title": "1.7. 클래스 필드 화살표 함수 사용의 단점",
            "url": "#17-클래스-필드-화살표-함수-사용의-단점",
            "items": []
          }
        ]
      },
      {
        "title": "2. 클래스 상속",
        "url": "#2-클래스-상속",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 275
    },
    "url": "/posts/javascript-18",
    "thumbnail": {
      "local": "/thumbnails/javascript-18-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-javascript-18-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAhUlEQVR4nGOYOnVqQkJCdHR0WlpaaWmpg4NDXFycrq4uQ09Pj6ura2dnp4ODAzs7e0BAwJ07d44dO8Ywb9685OTkhoaG5ubmY8eOXbt27T8YMBw4cKCzs3PDhg3379+HCP0BA4b7jx4/efr02bNnnz59gohCdSxduXbx4iWbNm6EGAKXAAA6XGQLj5ZUngAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "javascript-15",
    "title": "모던 자바스크립트 튜토리얼 part 1.7 객체 프로퍼티 설정",
    "date": "2023-02-06T00:00:00Z",
    "description": "ko.javascript.info part 1-7",
    "tags": [
      "javascript"
    ],
    "html": "<h1>1. 프로퍼티 플래그와 설명자</h1>\n<p>프로퍼티는 값과 함께 속성 플래그 3가지를 가진다. writable, enumerable, configurable이다. 기본적으로 셋 모두 true로 설정되어 있다. 각 속성에 대한 설명은 아래와 같다.</p>\n<p>writable : 값을 수정할 수 있는지\nenumerable : for..in 루프나 Object.keys와 같은 메서드로 프로퍼티를 나열할 수 있는지\nconfigurable : 프로퍼티를 삭제하거나 플래그 수정할 수 있는지</p>\n<p>프로퍼티에 대한 정보는 다음 메서드로 확인할 수 있다. 이 메서드는 프로퍼티 값과 플래그 정보가 담긴 프로퍼티 설명자 객체를 반환한다.</p>\n<pre><code>Object.getOwnPropertyDescriptor(obj, property) \n</code></pre>\n<p>다음과 같이 쓸 수 있는 것이다.</p>\n<pre><code class=\"language-js\">let me = {\n  firstName: \"김성현\",\n};\nconsole.log(Object.getOwnPropertyDescriptor(me, \"firstName\"));\n/*\n{\n  value: '김성현',\n  writable: true,\n  enumerable: true,\n  configurable: true\n}\n*/\n</code></pre>\n<p><code>Object.defindProperty</code> 메서드를 사용하면 프로퍼티 플래그를 수정할 수 있다.</p>\n<pre><code class=\"language-js\">Object.defineProperty(obj, propertyName, descriptor)\n</code></pre>\n<p>이때 descriptor는 프로퍼티 설명자 객체인데, 플래그 정보를 전달하지 않으면 자동으로 false로 설정된다.</p>\n<p>각 프로퍼티 플래그 설정에 따라 프로퍼티에 특성이 생긴다. writable이 false면 값을 쓸 수 없게 되고, enumerable이 false면 for..in 루프나 Object.keys와 같은 메서드로 프로퍼티를 나열할 수 없게 된다.</p>\n<p>configurable이 false면 프로퍼티를 삭제하거나 플래그를 수정할 수 없게 된다. 예를 들어 Math.PI는 변경할 수 없는 상수이므로 configurable이 false이다.</p>\n<p>이렇게 configurable을 false로 설정하면 돌이킬 수 없다. defineProperty를 써도 이 플래그 수정은 불가능하다.</p>\n<p><code>Object.defineProperties</code>를 쓰면 프로퍼티 여러 개 설정 가능하다.</p>\n<p><code>Object.getOwnPropertyDescriptors(obj)</code>를 쓰면 프로퍼티 설명자를 전부 가져올 수 있다. defineProperties를 쓰면 객체 복사 시 플래그까지 복사하는 것도 가능하다.</p>\n<p>그리고 for..in을 통한 복사는 객체의 심볼형 프로퍼티는 복사하지 않는 데에 반해 아래 방법은 심볼형 프로퍼티까지 잘 복사한다.</p>\n<pre><code class=\"language-js\">// 설명자까지 복사한 객체 리턴\nObject.defineProperties({}, Object.getOwnPropertyDescriptors(obj));\n</code></pre>\n<h1>2. 프로퍼티 getter, setter</h1>\n<p>객체의 프로퍼티는 데이터 프로퍼티와 접근자 프로퍼티로 나뉜다. 데이터 프로퍼티는 우리가 일반적으로 사용하는 데이터를 담는다. 반면 접근자 프로퍼티는 본질적으로 함수지만, getter와 setter 역할을 한다.</p>\n<p>get, set 키워드를 이용해서 선언할 수 있고 사용할 때는 실제 프로퍼티가 있는 것처럼 사용한다. 아래는 getter를 사용한 예시이다.</p>\n<pre><code class=\"language-js\">let me = {\n  firstName: \"성현\",\n  lastName: \"김\",\n\n  get fullName() {\n    return this.lastName + this.firstName;\n  },\n};\nconsole.log(me.fullName);\n// 김성현\n</code></pre>\n<p>아직 세터 메서드가 없으므로 fullName 프로퍼티는 읽기 전용이다. 값을 직접 할당하려고 해도 제대로 되지 않는다.</p>\n<pre><code class=\"language-js\">me.fullName = \"이성현\";\nconsole.log(me.fullName);\n// 김성현\n// 실제로는 fullName 프로퍼티가 없으므로 값이 바뀌지 않았다\n</code></pre>\n<p>여기에 세터를 만들면, 일반적으로 객체 프로퍼티를 사용하는 것처럼 fullName에 값을 할당할 수 있다.</p>\n<pre><code class=\"language-js\">let me = {\n  firstName: \"성현\",\n  lastName: \"김\",\n\n  get fullName() {\n    return this.lastName + this.firstName;\n  },\n\n  set fullName(value) {\n    [this.lastName, this.firstName] = value.split(\" \");\n  },\n};\nconsole.log(me.fullName);\n// 김성현\nme.fullName = \"이 성현\";\nconsole.log(me.fullName);\n// 이성현\n</code></pre>\n<h2>2.1. 접근자 프로퍼티의 설명자</h2>\n<p>접근자 프로퍼티는 데이터 프로퍼티와는 다른 설명자를 가지고 있다. get, set, enumerable, configurable 플래그가 있다. value와 writable이 없어졌다.</p>\n<p>다른 건 get, set인데 get은 인수가 없는 함수로 프로퍼티 값을 읽을 때 호출되고, set은 인수가 하나인 함수로 프로퍼티 값을 쓸 때 호출된다. 나머지 설명자는 데이터 프로퍼티에서와 같다.</p>\n<p>이 설명자들도 defineProperty로 설정할 수 있다. 그런데 프로퍼티들은 접근자 혹은 데이터 둘 중 하나이므로 get, value를 동시에 설정하면 에러가 난다.</p>\n<h2>2.2. getter, setter 활용</h2>\n<p>값을 설정할 시 특정 값 이상일 때만 설정되도록 하고 싶은 등, 값을 통제하고자 할 때 쓸 수 있다.</p>\n<pre><code class=\"language-js\">let obj = {\n  get num() {\n    return this._num;\n  },\n  set num(value) {\n    if (value &#x3C; 10) {\n      console.log(\"value is too small\");\n    } else {\n      this._num = value;\n    }\n  },\n};\n\nobj.num = 5;\nconsole.log(obj.num); // 값이 10보다 작으므로 설정되지 않는다\nobj.num = 15;\nconsole.log(obj.num);\n</code></pre>",
    "excerpt": "1. 프로퍼티 플래그와 설명자\n프로퍼티는 값과 함께 속성 플래그 3가지를 가진다. writable, enumerable, configurable이다. 기본적으로 셋 모두 true로 설정되어 있다. 각 속성에 대한 설명은 아래와 같다.\nwritable : 값을 수정할 수 있는지\nenumerable : for..in 루프나 Object.keys와 같은 메서드로 프로퍼티를 나열할 수 있는지\nconfigurable : 프로퍼티를 삭제하거나 플래그 수정할 수 있는지\n프로",
    "headingTree": [
      {
        "title": "1. 프로퍼티 플래그와 설명자",
        "url": "#1-프로퍼티-플래그와-설명자",
        "items": []
      },
      {
        "title": "2. 프로퍼티 getter, setter",
        "url": "#2-프로퍼티-getter-setter",
        "items": [
          {
            "title": "2.1. 접근자 프로퍼티의 설명자",
            "url": "#21-접근자-프로퍼티의-설명자",
            "items": []
          },
          {
            "title": "2.2. getter, setter 활용",
            "url": "#22-getter-setter-활용",
            "items": []
          }
        ]
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 180
    },
    "url": "/posts/javascript-15",
    "thumbnail": {
      "local": "/thumbnails/javascript-15-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-javascript-15-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAkklEQVR4nGNob28PDAz08PDw8/NLSUlRU1Pz8/OTlpZmaGho0NPTa2lpCQ0N5ePnb29vv3HjxoEDBxhSUlIkJSV5eHjCw8MVFRWvXr36////379/M2zbtiUxMTG/oCA3NzcxMfHt27dQiWnTZ0dGRcXGxtbW1k6ZMgUi8f//f4Yly1ctXbpsy+bNN27cgKiFSAAAO2dRsu+RVx4AAAAASUVORK5CYII="
    }
  },
  {
    "slug": "javascript-3",
    "title": "모던 자바스크립트 튜토리얼 part 1.2 자바스크립트 기본 - 2",
    "date": "2022-12-17T00:00:00Z",
    "description": "ko.javascript.info part 1-2 두번째",
    "tags": [
      "javascript"
    ],
    "html": "<p><a href=\"https://ko.javascript.info/\">모던 자바스크립트 튜토리얼</a>을 정리한다.</p>\n<h1>1. 변수와 상수</h1>\n<p>변수는 데이터를 저장하는 공간이다. <code>let</code>키워드를 이용하여 생성한다.</p>\n<pre><code class=\"language-js\">let a;\n</code></pre>\n<p><code>=</code>로 할당할 수 있고 이렇게 할당한 데이터에는 변수명을 통해 접근 가능하다.</p>\n<p>이전에는 <code>var</code>키워드를 사용해서 변수를 선언했지만 <code>let</code>키워드를 사용하는 것이 좋다. <code>var</code>의 차이는 나중에 따로 설명한다.</p>\n<p>단 엄격 모드가 적용중이지 않다면 <code>let</code>없이도 값 할당을 통해 변수를 생성할 수 있다.</p>\n<pre><code class=\"language-js\">a = 5;\n</code></pre>\n<p>단 위 코드는 엄격 모드에선 에러를 발생시키므로 주의한다.</p>\n<h2>1.1 변수명</h2>\n<p>변수명은 문자, 숫자, <code>$</code>, <code>_</code>로 구성할 수 있다. 그리고 숫자로 시작할 수 없다. 특이한 점으로 <code>$</code> 기호를 쓸 수 있다는 것을 기억해 두자. 이 <code>$</code>기호는 인터프리터에게 어떤 의미를 갖는 것은 아니지만 흔히 제이쿼리 객체나 앵귤러 프레임워크 변수 등 특별한 의미를 갖는 변수명에 사용될 때가 있다.</p>\n<h2>1.2 상수</h2>\n<p>상수는 한번 할당하면 값을 변경할 수 없는 변수이다. <code>const</code>키워드를 사용하여 생성한다.</p>\n<p>단 이는 절대로 거기 담긴 값을 변경할 수 없다는 게 아니라 변수가 가리키고 있는 참조를 변경할 수 없다는 의미임에 주의한다.</p>\n<p>이때 매직 넘버를 지정해 주는 상수 변수의 경우 대문자로 변수명을 쓰는 컨벤션이 있다. 다음과 같이.</p>\n<pre><code class=\"language-js\">const MAX_COUNT = 5;\n</code></pre>\n<h1>2. 자료형</h1>\n<p>JS는 동적 타이핑 언어이다. 즉 변수에 할당된 값에 따라 변수의 자료형이 결정된다. 하지만 그렇다고 자료형이 존재하지 않는 건 아니다. JS는 총 8가지의 기본 자료형이 있다.</p>\n<h2>2.1. 숫자형</h2>\n<p>정수 및 부동소수점을 나타낸다. 또한 <code>Infinity</code>, <code>-Infinity</code>, <code>NaN</code>과 같은 특수 숫자값도 존재한다.</p>\n<p>이 숫자형은 $2^53 -1$ 범위를 가진 정수까지 나타낼 수 있다. 그리고 그 이상의 큰 숫자를 표현하기 위한 BigInt형이 있는데 이건 정수 리터럴 끝에 <code>n</code>을 붙여 표현한다.</p>\n<pre><code class=\"language-js\">const bigInt = 1234567890123456789012345678901234567890n;\n</code></pre>\n<h2>2.2. 문자형</h2>\n<p>문자열을 나타낸다. 큰따옴표나 작은따옴표로 감싸서 표현한다.</p>\n<p>또 다른 방식으로는 백틱을 쓰는 것이 있다. 이 백틱으로 싸인 문자열은 템플릿 리터럴이라고 하며 여러 줄 문자열과 문자 보간을 사용할 수 있다.</p>\n<p>변수나 표현식을 <code>${}</code>로 감싸서 문자열 안에 넣으면 된다.</p>\n<pre><code class=\"language-js\">alert(`my number is ${5 + 10}`);\n</code></pre>\n<p>이 템플릿 리터럴에 관한 더 많은 내용은 <a href=\"https://www.witch.work/javascript-template-literal/\">여기</a>에 정리하였다.</p>\n<p>char타입은 js에 없다. 문자열 뿐이다.</p>\n<h2>2.3. 부울형</h2>\n<p>boolean 타입은 true, false 두 가지 값만을 가진다.</p>\n<h2>2.4. null</h2>\n<p>null 타입은 값이 없음을 나타내며 앞의 어떤 자료형에도 속하지 않는다. null 타입의 변수는 null 값만을 가질 수 있다.</p>\n<p>또한 다른 언어에서는 null을 0이나 빈 문자열로 취급하지만 js에서의 null은 존재하지 않거나 비어 있는 값, 알 수 없는(unknown) 값을 나타낸다.</p>\n<h2>2.5. undefined</h2>\n<p>undefined 타입의 변수는 undefined 값만을 가질 수 있다. 이는 값이 아직 할당되지 않은 상태를 나타낸다. 예를 들어 변수를 선언하고 할당하지 않으면 undefined가 할당된다.</p>\n<pre><code class=\"language-js\">let a;\nconsole.log(a); // undefined 출력\n</code></pre>\n<h2>2.6 객체, 심볼</h2>\n<p>객체는 여러 값을 하나의 단위로 구성한 복합적인 자료구조이다. 객체를 사용하여 좀더 복잡한 데이터 구조를 표현할 수 있다.</p>\n<p>심볼은 객체의 고유한 식별자를 만들 때 사용한다. 이 둘은 이후에 자세히 다룰 것이다.</p>\n<h2>2.7 typeof</h2>\n<p>typeof 연산자는 피연산자의 자료형을 반환한다. <code>typeof x</code>와 같이 연산자 형태로 쓰거나 <code>typeof(x)</code>와 같이 함수 형태로 쓸 수 있다. 여기서는 기억해 두어야 할 부분만 알아보겠다.</p>\n<pre><code class=\"language-js\">typeof(null); // object\n\nfunction add(a, b) {\n  return a + b;\n}\nconsole.log(typeof add); // function\n</code></pre>\n<p>먼저 null은 object 형으로 출력된다. 이는 ECMA 문서에도 그렇게 하라고 나와 있다. 이는 JS의 버그로 여겨지고 있지만 이를 고치는 것은 호환성을 해칠 수 있기 때문에 고치지 않는다. 그 이유에 대해서는 다음 문단에서 간단히 설명하겠다.</p>\n<p>그리고 js에서 함수는 일급 객체이지만 typeof를 함수에 적용하면 function이라는 문자열을 반환한다. 함수 타입이라는 건 js에 존재하지 않으므로 이상한 방식이지만 오래전의 규칙이기 때문에 이렇게 동작한다. 이때 함수도 객체인데 어떻게 구분해서 function 타입으로 알려주는지에 대해서는 <a href=\"https://www.howdy-mj.me/javascript/why-does-typeof-function-return-function\">여기</a>에 잘 정리되어 있었다.</p>\n<h2>2.8. typeof(null)의 이유</h2>\n<p>아주 오래 전 js의 첫 버전이 나올 때, 값은 32비트 워드에 저장되었다. 그런데 이 32비트를 온전히 값 저장에만 쓰지 않았다. 하위의 몇 비트를 타입을 나타내는 type tag에 할애하였고 나머지를 진짜 값을 저장하는 데에 사용했다. 다음과 같은 타입 태그가 있었다.</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>타입</th><th>태그</th></tr></thead><tbody><tr><td>object</td><td>000</td></tr><tr><td>integer</td><td>1</td></tr><tr><td>double</td><td>010</td></tr><tr><td>string</td><td>100</td></tr><tr><td>boolean</td><td>110</td></tr></tbody></table>\n<p>typeof 연산자는 위와 같이 하위 태그를 통해 각 값의 타입을 구분하였다.</p>\n<p>그런데 특별한 2가지 값이 있었다. 그게 바로 null과 undefined였다. 이때 undefined는 $-2^30$ 값을 갖는 <code>JSVAL_VOID</code>로 정의하였고 null은 널 포인터를 나타내는 값 <code>JSVAL_NULL</code>로 정의하였다.</p>\n<p>그런데 널 포인터 값은 0이므로 당연히 하위 비트가 000이 되었고 따라서 typeof연산자는 null을 object로 판단하게 되었다.</p>\n<h1>3. 브라우저와 간단한 상호작용</h1>\n<h2>3.1. alert</h2>\n<p>alert 함수는 브라우저에서 경고창을 띄워주는 함수이다. 인자로 받은 문자열을 경고창에 띄워주며, 경고창은 사용자가 확인 버튼을 누르면 사라진다.</p>\n<pre><code class=\"language-js\">alert(\"저는 김성현입니다.\");\n</code></pre>\n<h2>3.2. prompt</h2>\n<p>prompt는 2개의 인수를 받아서 브라우저에 입력창을 띄운다. 첫번째 인수는 입력창에 표시될 문자열이고, 두번째 인수는 입력창에 기본으로 표시될 문자열이다. 두번째 인수는 없어도 된다.\n사용자가 입력창에 입력한 값을 반환한다.</p>\n<p>사용자가 확인을 누르면 사용자가 입력한 값이 prompt의 반환값으로 들어간다. 그리고 취소나 ESC키를 누르면 prompt의 값으로 null이 들어간다. 다음과 같은 코드를 보자.</p>\n<pre><code class=\"language-js\">let result = prompt(\"입력창을 만들어 본다.\", \"여기에 입력하세요.\");\nalert(result);\n</code></pre>\n<p>이 코드를 실행시키면 다음과 같은 입력창이 뜬다.</p>\n<p><img src=\"/static/prompt-59236af6.png\" alt=\"prompt\"></p>\n<p>여기에 <code>김성현</code>을 입력한 후 확인 버튼을 누르면 다음과 같이 김성현이라고 적힌 경고창이 뜨게 된다.</p>\n<p><img src=\"/static/prompt_result-3ee0bf7f.png\" alt=\"prompt_result\"></p>\n<p>만약 취소를 눌렀다면 null이 적힌 경고창이 뜨게 된다.</p>\n<p>이때 주의할 점은, IE의 경우 prompt의 두번째 인수가 없을 경우 undefined를 두번째 인수로 자동으로 넣어 주는 동작을 한다는 것이다. 그래서 IE를 고려한다면 prompt의 두번째 인수를 생략하면 안 된다. 빈 문자열이라도 넣어주자.</p>\n<h2>3.3. confirm</h2>\n<p>confirm은 인수로 받은 질문과 함꼐 사용자에게 확인 또는 취소를 묻는 창을 띄워준다. 사용자가 확인을 누르면 true, 취소를 누르면 false를 반환한다.</p>\n<pre><code class=\"language-js\">let result = confirm(\"당신이 김성현인가요?\");\nalert(result);\n</code></pre>\n<p>위처럼 쓸 수 있다. 컨펌 창에서 사용자의 선택에 따라 true 혹은 false가 적힌 alert창이 뜬다. 단순히 경고창에 결과를 띄워 주는 것만이 아니라 사용자의 선택에 따라 어떤 동작을 취하게 하는 데에 사용할 수 있다.</p>\n<h2>3.4. 제약사항</h2>\n<p>위 함수들은 모두 모달 창을 띄운다. 이 모달이 떠있는 동안은 스크립트 실행이 일시 중단되고 사용자가 나머지 페이지가 상호작용이 불가능하게 된다.</p>\n<p>또한 이 함수들의 모달 창 위치와 모양은 브라우저에서 알아서 결정하며 개발자는 이를 제어할 수 없다. 간결성을 위한 대가이다.</p>\n<h1>4. 형변환</h1>\n<p>원시 타입의 형변환에 대해서만 다룬다. 객체 타입의 형변환은 나중에 다룰 예정이다.</p>\n<h2>4.1. 문자형으로의 변환</h2>\n<p>String 함수를 사용하면 어떤 값을 문자형으로 변환할 수 있다.</p>\n<pre><code class=\"language-js\">let booleanValue = true;\nconsole.log(typeof booleanValue);\nlet StringValue = String(booleanValue);\nconsole.log(typeof StringValue); // 문자열로 변환되어 string을 출력한다.\n</code></pre>\n<p>또한 문자열 타입을 기대하는 곳에 다른 타입이 오면 자동으로 문자열로 변환된다. 예를 들어서 alert는 인수로 받은 값을 문자열로 변환하여 출력한다. 그리고 문자열과 다른 타입의 덧셈에서 다른 타입은 문자열로 변환된다.</p>\n<pre><code class=\"language-js\">console.log(10 + \"문자열\"); \n//10이 문자열로 변환되어 처리되어서 10문자열 이라고 출력된다.\n</code></pre>\n<h2>4.2. 숫자형으로 변환</h2>\n<p>위와 마찬가지로 숫자형으로 변환하는 방법은 Number 함수를 사용하는 것이다.<code>Number(target)</code>과 같이 사용한다.</p>\n<p>또한 숫자로의 형변환은 수학과 관련된 함수나 표현식에서 자동으로 일어난다. 숫자가 기대되는 곳에 다른 타입의 값이 오면 자동으로 숫자형으로 변환되는 것이다. 만약 숫자가 아닌 값을 숫자로 변환하려고 하면 NaN이 된다.</p>\n<p>예를 들어서 뺄셈에는 숫자만 오기 때문에 뺄셈에 문자열이 오면 자동으로 숫자형으로 변환된다.</p>\n<pre><code class=\"language-js\">console.log(10 - \"5\");\n//\"5\"가 5로 변환되어 결과는 5가 된다.\n</code></pre>\n<p>단 문자열을 숫자로 변환할 때는 숫자로 변환할 수 없는 문자가 포함되어 있으면 NaN이 된다.</p>\n<pre><code class=\"language-js\">console.log(10 - \"김성현\"); //NaN\n</code></pre>\n<p>숫자형으로 변환하는 규칙은 다음과 같다.</p>\n<ul>\n<li>undefined는 NaN이 된다.</li>\n<li>null은 0이 된다.</li>\n<li>true나 false는 1 혹은 0이 된다.</li>\n<li>문자열은 처음과 끝 공백이 제거되고 공백 제거 후 빈 문자열이 된다면 0이 된다. 공백을 제거한 문자열이 숫자로 변환될 수 있으면 숫자로 변환한다. 그게 실패하면 NaN이 된다.</li>\n</ul>\n<h2>4.3. 불린 형으로의 변환</h2>\n<p>불린형을 요구하는 연산에 쓰일 때 자동으로 불린형으로 변환된다. 또는 Boolean 함수를 사용해서 불린형으로 변환할 수 있다.</p>\n<pre><code class=\"language-js\">console.log(Boolean(0)); //false\n</code></pre>\n<p>규칙은 간단하다. falsy한 값이면 false로 변환되고 나머지는 true로 변환된다.</p>\n<p>falsy한 값은 숫자 0, -0, 0n, 빈 문자열, null, undefined, NaN이다.</p>\n<p><span style=\"color:red\">빈 배열은 falsy한 값이 아님에 주의한다.</span></p>\n<h1>5. 기본 연산자와 수학</h1>\n<h2>5.1. 수학 연산자</h2>\n<p>수학 연산자는 +, -, *, /, %, **가 있다. %는 나머지 연산자이고 **는 거듭제곱 연산자이다. 알아둬야 할 건 거듭제곱 연산자는 정수가 아닌 숫자에 대해서도 동작한다는 것이다. <code>3**(1/2)</code>와 같은 것도 가능하다.</p>\n<h3>5.1.1. 나머지 연산자와 음수</h3>\n<p>나머지 연산자의 피연산자가 둘 모두 양수일 때는 명확하다. 5%3의 결과는 당연히 2일 것이다. 하지만 -5%-3은 어떨까? 실험해 보면 -2가 나오는 것을 알 수 있다.</p>\n<p>이 나머지 연산자의 결과 부호는 항상 왼쪽 피연산자의 부호를 따르게 되어 있다.</p>\n<pre><code class=\"language-js\">5%3 //2\n5%-3 //2\n-5%3 //-2\n-5%-3 //-2\n</code></pre>\n<p>만약 나머지가 0이라도 왼쪽 피연산자가 음수라면 결과가 <code>-0</code>이 된다.</p>\n<pre><code class=\"language-js\">-4 % -2 // -0\n</code></pre>\n<p>NaN의 나머지는 NaN이다. 또한 Infinity의 나머지도 NaN이다.</p>\n<h3>5.1.2. 연산자와 형변환</h3>\n<p>덧셈을 제외한 모든 수학 연산자는 오직 숫자형만 받는다. 따라서 덧셈 연산자가 아닌 수학 연산자의 피연산자가 숫자형이 아닌 경우 자동으로 숫자형으로 변환된다.</p>\n<pre><code class=\"language-js\">10 - '3' //7\n'10' / '3' //3.3333333333333335\n</code></pre>\n<p>또한 덧셈 연산자는 단항 연산자로도 쓰일 수 있다. 만약 숫자에 <code>+</code>를 붙이면 아무런 변화가 없다. 피연산자가 숫자형이 아니라면 숫자형으로 변환된다. <code>+</code>를 Number 함수 대신 숫자형 변환에 사용할 수도 있는 것이다.</p>\n<pre><code class=\"language-js\">+\"123\" // 123\n</code></pre>\n<h2>5.2. 할당 연산자</h2>\n<p>할당 연산자 <code>=</code>는 오른쪽 피연산자의 값을 왼쪽 피연산자에 할당한다. 그런데 덧셈 연산자가 값을 반환하듯이 이 할당 연산자 또한 값이 평가된다. 왼쪽 피연산자에 할당된 값을 반환하는 것이다.</p>\n<pre><code class=\"language-js\">let a = 1;\nlet b = 2;\n// c=2+3과 같다. 그리고 a엔 2가, b엔 3이 할당된다.\nlet c = (a = 2) + (b = 3);\nconsole.log(a, b, c);\n</code></pre>\n<p>또한 체이닝을 이용해서 여러 변수를 한번에 할당할 수도 있다.</p>\n<pre><code class=\"language-js\">a=b=c=3;\n</code></pre>\n<p>이렇게 할당 연산자의 평가를 이용하는 코드는 사용하지 않는 게 권장되기는 한다.</p>\n<h2>5.3. 복합 연산자</h2>\n<p>복합 연산자는 연산자와 할당 연산자를 결합한 것이다. 예를 들어 <code>+=</code>는 덧셈 연산자와 할당 연산자를 결합한 것이다.</p>\n<h2>5.4. 증감 연산자</h2>\n<p>++, --로 나타나는 증감 연산자는 피연산자의 크기를 1 증가/감소시킨다. 전위형, 후위형이 있다. C언어에서와 같이 전위형은 피연산자의 값을 먼저 증가/감소시키고 사용하고, 후위형은 먼저 값을 사용하고 피연산자의 값을 나중에 증가/감소시킨다.</p>\n<p>그리고 증감 연산자는 대부분의 연산자보다 우선순위가 높기 때문에 평가가 먼저 이루어진다.</p>\n<h2>5.5. 비트 연산자</h2>\n<p>비트를 다루는 연산자이다. &#x26;, |, ^, ~, <code>&#x3C;&#x3C;</code>, <code>>></code>가 있다. 여기까지는 C언어와 같다. 그리고 부호 없는 오른쪽 시프트 연산자로 <code>>>></code>가 있다. 이 연산자는 부호 비트를 0으로 채운다.</p>\n<h2>5.6. 쉼표 연산자</h2>\n<p>쉼표 연산자는 여러 표현식을 코드 한 줄에서 실행하고 평가할 수 있게 한다. 그리고 쉼표로 연결된 표현식 중 마지막 표현식의 평가 결과만 반환한다.</p>\n<p>주의할 점은 쉼표 연산자는 우선순위가 낮기 때문에 제대로 사용하려면 괄호로 감싸 줘야 한다는 것이다.</p>\n<pre><code class=\"language-js\">// (3,7) 중 마지막 것만 평가되어서 a는 5가 된다.\nlet a = (1,2,3,4,5);\n</code></pre>\n<p>가독성 때문에 권장되는 코드는 아니지만 여러 동작을 하나의 줄에서 처리하려는 구조에서 쉼표 연산자를 사용한다. 사용 예시는 다음과 같다.</p>\n<pre><code class=\"language-js\">for(let l=0,r=0;r&#x3C;s;l++,r++){\n  if(left[l]!=right[r]){\n    if(diff){p=0;break;}\n    r--; diff++;\n  }\n}\n</code></pre>\n<h1>6. 비교 연산자</h1>\n<p>JS에도 당연히 비교 연산자가 있다. C언어에 있는 것과 같은 기능을 하는 부등호와 같은지 나타내는 등호가 있다.</p>\n<h2>6.1. 평가값</h2>\n<p>비교 연산자 식은 그 결과에 따라 true 혹은 false로 평가된다. 예를 들어 <code>2>1</code>은 true로 평가된다.</p>\n<h2>6.2. 문자열 비교</h2>\n<p>JS에서 문자열은 사전순으로 비교된다. 사전 뒤쪽의 문자열이 더 크다고 판단되는 것이다. 이 비교 알고리즘은 문자열을 한 글자씩 비교하면서 같으면 넘어가고 다른 문자가 나오면 그걸 비교하여 결과를 반환한다. 그런데 이렇게 한 글자씩 비교하다가 문자열 둘 중 하나가 끝나버리면 길이가 더 긴 문자열이 크다고 판단된다.</p>\n<p>이때 각 문자들은 사실 사전순으로가 아니라 유니코드 값으로 비교된다. 따라서 'a'가 'A'보다 크고 '가'가 'a'보다 크다. 유니코드 값이 더 크기 때문이다.</p>\n<h2>6.3. 다른 타입 비교</h2>\n<p>비교 연산자의 피연산자 자료형이 다르면 숫자형으로 변환된다. 예를 들어서 <code>'2'>1</code>과 같은 식을 평가한다면 문자열 '2'는 숫자형으로 변환되어 <code>2>1</code>과 같은 식이 될 것이고 당연히 결과값은 true이다. 다른 타입의 비교에 관한 자세한 글은 <a href=\"https://www.witch.work/javascript-compare-different-types/\">여기</a>로.</p>\n<p>또한 이런 상황은 동등 연산자 <code>==</code>를 사용할 때도 벌어진다. JS에서 <code>0=='0'</code>이 true라는 건 널리 알려진 사실이다. 이는 ==가 비교할 때 숫자형으로 변환해서 비교하기 때문이다. 똑같은 이유로 <code>0==false</code>도 참이다.</p>\n<p>이를 해결하기 위해서는 <code>===, !==</code>를 사용하면 된다. 이는 일치 연산자로 동등 연산자의 더 엄격한 버전이다. 자료형의 동등 여부까지 검사해 준다.</p>\n<h2>6.4 null과 undefined</h2>\n<p>비교 연산자가 null, undefined에 작용할 때는 어떻게 될까?</p>\n<pre><code class=\"language-js\">null===undefined\n</code></pre>\n<p>위 식은 false를 반환한다. 두 값의 타입이 다르기 때문이다. 앞에서 살펴보았듯이 null은 널 타입이고 undefined는 undefined 하나로 이루어진 타입을 가진다.</p>\n<pre><code class=\"language-js\">null==undefined\n</code></pre>\n<p>그런데 위 식은 true를 반환한다. <code>==</code>는 null, undefined에 특별한 규칙을 적용하여 둘이 동등하다고 판단한다. 이는 <a href=\"https://262.ecma-international.org/5.1/#sec-11.9.3\">명세서</a>에 나와 있는 부분이다.</p>\n<pre><code class=\"language-js\">null > 0 //false\nnull &#x3C; 0 //false\nnull >= 0 //true\nnull == 0 //false\n</code></pre>\n<p>null을 비교 연산자 >,&#x3C;,>=,&#x3C;=에 사용하면 0으로 변환되어 사용된다. 따라서 <code>null>0</code>은 <code>0>0</code>이 되어 false이고 <code>null>=0</code>은 <code>0>=0</code>이 되어 true가 되는 것이다.</p>\n<p>그런데 <code>null==0</code>과 같이 <code>==</code>이 쓰일 때는 피연산자가 null일 때 형변환을 안한다. null을 <code>==</code>로 비교할 땐 다른 쪽이 null, undefined일 때만 결과가 true이고 나머지는 모두 결과가 false이다.</p>\n<pre><code class=\"language-js\">undefined > 0 //false\nundefined &#x3C; 0 //false\n</code></pre>\n<p>undefined는 비교 연산자와 함께 쓰이면 NaN으로 변환된다. NaN이 피연산자로 쓰일 경우 비교 연산자는 무조건 false를 반환하게 되므로 위와 같은 결과가 나온다.</p>\n<pre><code class=\"language-js\">undefined == 0 //false\n</code></pre>\n<p>undefined를 <code>==</code>로 비교하면 상대가 null, undefined일 때 true이고 나머지는 모두 false이다.</p>\n<p>따라서 비교 연산자를 쓸 때 피연산자에 null이나 undefined가 들어갈 가능성이 있을 때 각별히 주의하자.</p>\n<h1>7. if와 삼항 연산자 ?:</h1>\n<p>JS에도 다른 언어와 마찬가지로 if 조건문이 있다. 이는 if()의 괄호 안의 조건식을 평가하고 그 평가값을 boolean으로 변환한 게 true이면 중괄호 내의 코드블록이 실행되는 방식으로 동작한다.</p>\n<p>앞의 형변환에서 본 것과 같이 boolean으로 변환될 때 false로 변환되는 falsy value는 0, 빈 문자열, null, undefined, NaN밖에 없음을 기억하자.</p>\n<pre><code class=\"language-js\">if(NaN){\n    //이 블록은 절대 실행되지 않는다.\n}\n</code></pre>\n<p>else, else if도 다른 언어와 똑같이 작동한다.</p>\n<p>또한 삼항 연산자 <code>?:</code>도 C언어와 똑같은 기능을 한다. 하지만 가독성을 위해 매우 간단한 경우 외에는 if문을 사용하는 것이 권장된다.</p>\n<h1>8. 논리 연산자</h1>\n<p>논리 연산자에는 ||, &#x26;&#x26;, ! 이 있다. 각각의 기본적인 기능은 다른 언어들에서와 비슷하다.</p>\n<h2>8.1. OR</h2>\n<p>OR 연산자 <code>||</code>는 두 피연산자 중 하나라도 true이면 그 연산식을 true로 평가한다. 다른 언어에서와 똑같다. 하지만 좀 다른 활용을 할 수 있다.</p>\n<p>OR연산자는 피연산자를 왼쪽에서 오른쪽으로 평가하고, 피연산자 중 첫 번째 truthy value를 반환한다. 만약 피연산자가 모두 falsy이면 맨 마지막 피연산자를 반환한다. 이는 변수들 중 참인 값을 찾는 데에 사용될 수 있다.</p>\n<pre><code class=\"language-js\">0 || \"\" || NaN // 모두 falsy이므로 마지막 피연산자 NaN 반환\nnull || \"김성현\" || \"a\" //피연산자 중 첫번째 truthy인 \"김성현\"반\n</code></pre>\n<p>또한 다른 언어에 있는 기능 중 short circuit 기능이 js에서도 지원된다. truthy 피연산자를 만나면 그 뒤의 연산자들은 평가하지 않는 것이다. 이는 왼쪽 조건이 falsy일 때만 어떤 명령을 실행하고자 할 때 쓸 수 있다.</p>\n<pre><code class=\"language-js\">let me=\"Alex\"\nme===\"Ben\" || console.log(\"You are not Ben.\")\n</code></pre>\n<p>간단한 예시지만 이름이 벤이 아니면 특정 메시지가 출력되도록 하는 코드이다.</p>\n<h2>8.2. AND</h2>\n<p>AND 연산자 <code>&#x26;&#x26;</code>는 두 피연산자 모두 truthy일 때 연산식이 truthy로 평가된다.</p>\n<p>또한 위의 <code>||</code>과 같이 피연산자를 왼쪽에서 오른쪽으로 평가하는데 이때 첫번째 falsy value를 반환한다. 만약 모두 true이면 마지막 피연산자가 반환된다.</p>\n<pre><code class=\"language-js\">1 &#x26;&#x26; 2 &#x26;&#x26; null &#x26;&#x26; 3 //첫번째 falsy인 null 반환\n</code></pre>\n<p>이 또한 왼쪽 명령이 true일 때 어떤 명령을 실행하는 데에 쓸 수 있다.</p>\n<pre><code class=\"language-js\">let me=\"Ben\"\n// me가 Ben일 때만 콘솔 로그가 찍힌다.\nme===\"Ben\" &#x26;&#x26; console.log(\"You are Ben!\")\n</code></pre>\n<p>단 이런 AND, OR의 기능을 if대신 쓰는 건 가독성을 해치기 때문에 용도에 맞게 써야 한다.</p>\n<h2>8.3 우선순위</h2>\n<p><code>&#x26;&#x26;</code>가 <code>||</code>보다 우선순위가 높다. 즉 <code>&#x26;&#x26;</code>가 먼저 평가된다.</p>\n<p>따라서 <code>null || 2 &#x26;&#x26; 3 || 4</code>와 같은 표현식이 있다면 <code>2 &#x26;&#x26; 3</code>이 먼저 평가되어 <code>null || 3 || 4</code>가 되고 이 평가 결과는 3이 된다.</p>\n<h2>8.4 NOT</h2>\n<p>NOT 연산자 <code>!</code>은 말 그대로 피연산자를 bool로 변환한 후 그 역을 반환한다. 예를 들어 <code>!0</code>은 0을 boolean으로 변환하면 false가 되고 그 역이므로 <code>!0</code>은 true이다.</p>\n<p>이 원리로 <code>!</code>을 2번 쓰면 피연산자를 불린으로 변환한 값의 역의 역을 반환하게 되므로 피연산자를 불린으로 변환한 값이 반환된다. Boolean 함수를 쓴 것과 같은 결과이다.</p>\n<p>또한 NOT은 AND, OR보다 우선순위가 높기 때문에 가장 먼저 평가된다. NOT > AND > OR 순으로 우선순위가 높다(먼저 실행된다).</p>\n<h1>9. nullish ??</h1>\n<p>??는 왼쪽 피연산자가 null이나 undefined면 오른쪽 피연산자를 반환하고 그렇지 않으면 왼쪽 피연산자를 반환한다. 그리고 왼쪽에서 오른쪽으로 평가된다.</p>\n<p>즉 피연산자 중 첫 번째로 정의된 값을 반환하는 것이다. 이것이 <code>||</code>와의 차이를 만든다. 예를 들어서 변수에 기본값을 할당하는 데에 <code>||</code>를 쓴다고 하자. 다음과 같이 말이다.</p>\n<pre><code class=\"language-js\">let result=count || 1; \n</code></pre>\n<p>만약 count가 falsy한 값이면 result에는 기본값 1이 할당될 것이다. 하지만 count가 지금 갖고 있는 어떤 물건의 개수라면 0도 충분히 의미있는 값으로 취급되어야 한다. 하지만 ||를 사용한다면 0은 falsy value로 취급되고 result에는 기본값 1이 들어가고 만다. 이럴 때 ??를 써야 한다.</p>\n<pre><code class=\"language-js\">let count=0;\nlet result=count ?? 1;\nconsole.log(result); // 0이 출력된다\n</code></pre>\n<p><code>??</code>의 우선순위는 5로 대부분의 연산자보다 낮기 때문에 괄호와 함께 사용하는 게 좋다.</p>\n<p>왼쪽 피연산자가 null이나 undefined가 아닌 게 판명되면 오른쪽 피연산자는 평가되지 않는 short circuit도 똑같이 작동한다.</p>\n<p>그리고 주의할 점은 <code>??</code>와 <code>&#x26;&#x26;, ||</code>는 같이 쓰일 수 없다는 것이다. 만약 같이 쓰면 에러가 발생한다.</p>\n<pre><code class=\"language-js\">true || undefined ?? \"foo\"; // SyntaxError 발생\n</code></pre>\n<p>단 괄호를 써서 우선순위를 명시적으로 나타내면 괜찮다.</p>\n<pre><code class=\"language-js\">true || (undefined ?? \"foo\") // 잘 동작하여 true 반\n</code></pre>\n<h1>참고</h1>\n<p><a href=\"https://stackoverflow.com/questions/846585/what-is-the-purpose-of-the-dollar-sign-in-javascript\">js에서 변수명에 쓰이는 달러 표시의 의미</a></p>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Template_literals\">MDN 템플릿 리터럴</a></p>\n<p><a href=\"https://stackoverflow.com/questions/18808226/why-is-typeof-null-object\">왜 js에서 null은 object인가?</a>와 <a href=\"https://2ality.com/2013/10/typeof-null.html\">그 원본 글</a></p>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Glossary/Falsy\">JS falsy value</a></p>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Remainder\">나머지 연산자</a></p>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing\">Nullish coalescing operator - JavaScript | MDN</a></p>",
    "excerpt": "모던 자바스크립트 튜토리얼을 정리한다.\n1. 변수와 상수\n변수는 데이터를 저장하는 공간이다. let키워드를 이용하여 생성한다.\nlet a;\n\n=로 할당할 수 있고 이렇게 할당한 데이터에는 변수명을 통해 접근 가능하다.\n이전에는 var키워드를 사용해서 변수를 선언했지만 let키워드를 사용하는 것이 좋다. var의 차이는 나중에 따로 설명한다.\n단 엄격 모드가 적용중이지 않다면 let없이도 값 할당을 통해 변수를 생성할 수 있다.\na = 5;\n\n단 위 코드는 엄격 ",
    "headingTree": [
      {
        "title": "1. 변수와 상수",
        "url": "#1-변수와-상수",
        "items": [
          {
            "title": "1.1 변수명",
            "url": "#11-변수명",
            "items": []
          },
          {
            "title": "1.2 상수",
            "url": "#12-상수",
            "items": []
          }
        ]
      },
      {
        "title": "2. 자료형",
        "url": "#2-자료형",
        "items": [
          {
            "title": "2.1. 숫자형",
            "url": "#21-숫자형",
            "items": []
          },
          {
            "title": "2.2. 문자형",
            "url": "#22-문자형",
            "items": []
          },
          {
            "title": "2.3. 부울형",
            "url": "#23-부울형",
            "items": []
          },
          {
            "title": "2.4. null",
            "url": "#24-null",
            "items": []
          },
          {
            "title": "2.5. undefined",
            "url": "#25-undefined",
            "items": []
          },
          {
            "title": "2.6 객체, 심볼",
            "url": "#26-객체-심볼",
            "items": []
          },
          {
            "title": "2.7 typeof",
            "url": "#27-typeof",
            "items": []
          },
          {
            "title": "2.8. typeof(null)의 이유",
            "url": "#28-typeofnull의-이유",
            "items": []
          }
        ]
      },
      {
        "title": "3. 브라우저와 간단한 상호작용",
        "url": "#3-브라우저와-간단한-상호작용",
        "items": [
          {
            "title": "3.1. alert",
            "url": "#31-alert",
            "items": []
          },
          {
            "title": "3.2. prompt",
            "url": "#32-prompt",
            "items": []
          },
          {
            "title": "3.3. confirm",
            "url": "#33-confirm",
            "items": []
          },
          {
            "title": "3.4. 제약사항",
            "url": "#34-제약사항",
            "items": []
          }
        ]
      },
      {
        "title": "4. 형변환",
        "url": "#4-형변환",
        "items": [
          {
            "title": "4.1. 문자형으로의 변환",
            "url": "#41-문자형으로의-변환",
            "items": []
          },
          {
            "title": "4.2. 숫자형으로 변환",
            "url": "#42-숫자형으로-변환",
            "items": []
          },
          {
            "title": "4.3. 불린 형으로의 변환",
            "url": "#43-불린-형으로의-변환",
            "items": []
          }
        ]
      },
      {
        "title": "5. 기본 연산자와 수학",
        "url": "#5-기본-연산자와-수학",
        "items": [
          {
            "title": "5.1. 수학 연산자",
            "url": "#51-수학-연산자",
            "items": [
              {
                "title": "5.1.1. 나머지 연산자와 음수",
                "url": "#511-나머지-연산자와-음수",
                "items": []
              },
              {
                "title": "5.1.2. 연산자와 형변환",
                "url": "#512-연산자와-형변환",
                "items": []
              }
            ]
          },
          {
            "title": "5.2. 할당 연산자",
            "url": "#52-할당-연산자",
            "items": []
          },
          {
            "title": "5.3. 복합 연산자",
            "url": "#53-복합-연산자",
            "items": []
          },
          {
            "title": "5.4. 증감 연산자",
            "url": "#54-증감-연산자",
            "items": []
          },
          {
            "title": "5.5. 비트 연산자",
            "url": "#55-비트-연산자",
            "items": []
          },
          {
            "title": "5.6. 쉼표 연산자",
            "url": "#56-쉼표-연산자",
            "items": []
          }
        ]
      },
      {
        "title": "6. 비교 연산자",
        "url": "#6-비교-연산자",
        "items": [
          {
            "title": "6.1. 평가값",
            "url": "#61-평가값",
            "items": []
          },
          {
            "title": "6.2. 문자열 비교",
            "url": "#62-문자열-비교",
            "items": []
          },
          {
            "title": "6.3. 다른 타입 비교",
            "url": "#63-다른-타입-비교",
            "items": []
          },
          {
            "title": "6.4 null과 undefined",
            "url": "#64-null과-undefined",
            "items": []
          }
        ]
      },
      {
        "title": "7. if와 삼항 연산자 ?:",
        "url": "#7-if와-삼항-연산자-",
        "items": []
      },
      {
        "title": "8. 논리 연산자",
        "url": "#8-논리-연산자",
        "items": [
          {
            "title": "8.1. OR",
            "url": "#81-or",
            "items": []
          },
          {
            "title": "8.2. AND",
            "url": "#82-and",
            "items": []
          },
          {
            "title": "8.3 우선순위",
            "url": "#83-우선순위",
            "items": []
          },
          {
            "title": "8.4 NOT",
            "url": "#84-not",
            "items": []
          }
        ]
      },
      {
        "title": "9. nullish ??",
        "url": "#9-nullish-",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 2,
      "wordCount": 433
    },
    "url": "/posts/javascript-3",
    "thumbnail": {
      "local": "/static/prompt-59236af6.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-prompt-59236af6-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAADCAIAAAAhqtkfAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAVklEQVR4nAFLALT/AKOjpIaHiuXm5vj5+PP09PHz8/r6+ubm5gB/h5NPXGq9wszR1dzM0drK0Na+xdClq7YA6uvs8vT1+Pn5+vr69vb2///+N1NxAAgtXns3q1lIWK4AAAAASUVORK5CYII="
    }
  },
  {
    "slug": "javascript-4",
    "title": "모던 자바스크립트 튜토리얼 part 1.2 자바스크립트 기본 - 3",
    "date": "2022-12-26T00:00:00Z",
    "description": "ko.javascript.info part 1-2 세번째",
    "tags": [
      "javascript"
    ],
    "html": "<h1>1. 반복문</h1>\n<p>while과 for문이 있다.</p>\n<h2>1.1. while</h2>\n<p>다른 언어에서와 똑같다. 다음과 같은 형식을 하고 condition이 참일 동안 본문을 실행한다.</p>\n<pre><code class=\"language-js\">while(condition){\n    // 본문\n}\n</code></pre>\n<p>condition의 평가값은 불린으로 변경되고 그 값이 true일 시 while 본문을 실행한다.</p>\n<h2>1.2. do~while</h2>\n<p>do~while문도 다른 언어에서 있는 것과 똑같이 존재한다.</p>\n<pre><code class=\"language-js\">do{\n    // 본문\n} while(condition);\n</code></pre>\n<p>역시 condition이 참일 동안 본문이 실행된다. 단 while과의 차이점은 본문이 먼저 실행된 후 condition이 평가된다는 것이다. 따라서 본문이 최소한 한 번은 실행된다.</p>\n<h2>1.3. for</h2>\n<p>for문도 다음과 같다.</p>\n<pre><code class=\"language-js\">for(begin; condition; step){\n    // 본문\n}\n</code></pre>\n<p>반복문을 진입할 때 begin이 실행되고, 반복마다 condition이 확인되며 본문이 한번 실행될 때마다 step이 실행된다.</p>\n<p>begin -> (condition이 참이면 본문 실행 후 step 실행)을 반복하는 것이다. 만약 condition이 처음부터 false라면 본문은 한 번도 실행되지 않는다.</p>\n<p>또한 for문의 구성 요소 중 필요없는 게 있다면 생략도 가능하다. 미리 초기화된 변수를 사용하여 begin을 쓸 필요 없는 등의 경우이다.</p>\n<h2>1.4. break/continue with label</h2>\n<p>JS에서의 break, continue도 다른 언어에서와 같다. 다른 점은 라벨과 함께 쓰일 수 있다는 점이다. 여러 개의 중첩 반복문을 빠져나올 때 사용 가능하다. 예를 들어서 다음과 같은 이중 반복문이 있다.</p>\n<pre><code class=\"language-js\">for(let i=0;i&#x3C;3;i++){\n  for(let j=0;j&#x3C;3;j++){\n    console.log(i,j);\n  }\n}\n</code></pre>\n<p>만약 이를 i,j가 각각 1,1일 때 끝내고 싶다면 다음과 같이 flag를 쓰고 2번 break를 써야 한다.</p>\n<pre><code class=\"language-js\">let flag=0;\nfor(let i=0;i&#x3C;3;i++){\n  for(let j=0;j&#x3C;3;j++){\n    console.log(i,j);\n    if(i===1 &#x26;&#x26; j===1){flag=1;break;}\n  }\n  if(flag){break;}\n}\n</code></pre>\n<p>하지만 빠져나오고 싶은 반복문에 라벨을 쓰고 break 뒤에 그 라벨을 붙이면 해당 라벨의 반복문을 한번에 빠져나올 수 있다.</p>\n<pre><code class=\"language-js\">outer:for(let i=0;i&#x3C;3;i++){\n  for(let j=0;j&#x3C;3;j++){\n    console.log(i,j);\n    if(i===1 &#x26;&#x26; j===1){break outer;}\n  }\n}\n</code></pre>\n<p>continue도 라벨과 함께 사용할 수 있는데 그럴 경우 해당 라벨이 붙은 반복문의 다음 단계가 실행된다. 예를 들어서 다음과 같이 사용할 경우, i가 1이면 outer의 다음 단계가 실행되기 때문에 i가 1인 경우는 <code>1 0</code>이 출력된 이후 바로 i가 2인 단계로 넘어간다.</p>\n<pre><code class=\"language-js\">outer:for(let i=0;i&#x3C;3;i++){\n  for(let j=0;j&#x3C;3;j++){\n    console.log(i,j);\n    if(i===1){continue outer;}\n  }\n}\n</code></pre>\n<h1>2. switch</h1>\n<p>여러 개로 분기하는 if 조건문은 switch로 대체할 수 있다. target이 case의 값과 일치하면 해당 case의 본문이 실행된다. 만약 일치하는 case가 없다면 default의 본문이 실행된다.</p>\n<pre><code class=\"language-js\">switch(target){\n  case value1:\n    // 본문\n    break;\n  case value2:\n    // 본문\n    break;\n  default:\n    // 본문\n}\n</code></pre>\n<p>이때 switch는 target의 값과 같은 case로 점프하는 것이므로 break를 쓰지 않으면 해당 case의 본문이 실행된 이후 다음 case의 본문까지 실행된다. 예를 들어서 다음과 같은 switch문이 있다.</p>\n<pre><code class=\"language-js\">switch(target){\n  case 1:\n    console.log(1);\n  case 2:\n    console.log(2);\n    break;\n  case 3:\n    console.log(3);\n    break;\n  default:\n    console.log('default');\n}\n</code></pre>\n<p>이때 target이 1이라면 1과 2가 모두 콘솔 로그에 찍힌다. 또한 target과 case에는 어떤 표현식이든 올 수 있다.</p>\n<p>switch문은 일치 비교 <code>===</code>를 사용한다는 것도 기억하자. 따라서 0과 '0'은 다르게 취급된다. 입력값을 switch에 줄 때 그 값의 타입이 어떤지 꼭 확인하자. 예를 들어 prompt함수는 리턴값이 문자열이다.</p>\n<pre><code class=\"language-js\">let a='0';\n// '문자 0' 이 출력된다.\nswitch(a){\n  case 0:\n  console.log(\"숫자 0\");\n  break;\n  case '0':\n  console.log(\"문자 0\");\n  break;\n  default:\n  console.log(\"다른 것\");\n}\n</code></pre>\n<h1>3. 함수</h1>\n<p>다른 언어에서처럼 JS에서도 함수를 만들 수 있다. function 키워드를 이용해 선언한다.</p>\n<pre><code class=\"language-js\">function 함수이름(매개변수1, 매개변수2, ...){\n  // 본문\n}\n</code></pre>\n<p>또한 함수도 중괄호로 새로운 코드 블록을 생성해 주기 때문에 함수 내에서만 접근 가능한 지역 변수를 만들 수 있고 함수 스코프 외부의 변수에 접근할 수도 있다. 단 만약 외부 변수와 같은 이름을 가진 함수 내 지역 변수가 있다면 지역 변수가 더 우선된다.</p>\n<p>다음 코드의 경우 함수 내에서 a를 선언했기 때문에 함수 내에서는 a가 3이고 함수 외부에서는 a가 1이다.</p>\n<pre><code class=\"language-js\">let a=1;\nfunction test(){\n  let a=3;\n  console.log(a);\n}\ntest();\nconsole.log(a);\n</code></pre>\n<h2>3.1. 매개변수</h2>\n<p>JS에서도 함수에 매개변수를 전달해 사용할 수 있다. 이때 매개변수는 함수 내부로 복사되어 사용된다. 다음 코드를 보자.</p>\n<pre><code class=\"language-js\">function test(nickname){\n  nickname=nickname+\"me\";\n  console.log(nickname)\n}\nlet t=\"witch\";\n// witchme가 출력됨\ntest(t);\n// witch가 출력됨\nconsole.log(t);\n</code></pre>\n<p>함수 내에서 nickname을 변경했지만 매개변수로 전달된 변수는 변하지 않은 것을 볼 수 있다. 이는 매개변수가 함수 내부로 복사되어 사용된다는 것을 보여준다. 그런데 단순히 모든 것이 복사되는 것은 아닌데..이는 다른 글에서 다루겠다.</p>\n<h2>3.2. 매개변수 기본값</h2>\n<p>함수 호출 시 매개변수가 들어갈 위치에 아무것도 넣지 않으면 undefined가 들어간다.</p>\n<pre><code class=\"language-js\">function test(arg1, arg2){\n  console.log(arg1, arg2);\n}\n// 1 undefined\ntest(1);\n</code></pre>\n<p>이때 매개변수에 기본값을 설정해 놓으면 매개변수가 들어가지 않을 때 기본값이 들어간다. 매개변수에 전달된 값이 undefined일 때도 기본값이 들어가게 된다.</p>\n<pre><code class=\"language-js\">function test(arg1, arg2=2){\n  console.log(arg1, arg2);\n}\n// 1 2\ntest(1);\n</code></pre>\n<p>매개변수 기본값은 함수를 호출할 때마다 평가되기 때문에 매개변수 기본값에는 함수를 호출할 때마다 달라져야 하는 값이나 표현식을 넣을 수도 있다.</p>\n<pre><code class=\"language-js\">function test(arg1, arg2=func()){\n  console.log(arg1, arg2);\n}\n</code></pre>\n<h2>3.3. 매개변수 기본값의 다른 방식</h2>\n<p>함수 선언 후에 매개변수 기본값을 설정하는 것이 적절할 경우 undefined와의 비교, ||, ?? 를 사용하는 방법을 쓸 수 있다.</p>\n<pre><code class=\"language-js\">function test(arg1, arg2){\n  if(arg2===undefined){\n    arg2=\"default\"\n  }\n  console.log(arg1, arg2);\n}\n\n// 이 경우 arg2가 falsy value일 때 기본값이 들어감\nfunction test(arg1, arg2){\n  arg2=arg2 || \"default\";\n  console.log(arg1, arg2);\n}\n\nfunction test(arg1, arg2){\n  arg2=arg2 ?? \"default\";\n  console.log(arg1, arg2);\n}\n</code></pre>\n<h2>3.4. 반환값 이용하기</h2>\n<p>return을 이용해 함수를 호출한 곳으로 값을 반환할 수 있다. 그런데 return을 이용하지 않거나 return 값을 명시하지 않으면 undefined가 반환된다.</p>\n<pre><code class=\"language-js\">function test(arg1, arg2){\n  console.log(arg1, arg2);\n}\n//undefined\nconsole.log(test(1,0));\n</code></pre>\n<h1>4. 함수 표현식</h1>\n<p>앞에서는 함수 선언문 방식으로 함수를 만들었다. 다음과 같은 방식이다.</p>\n<pre><code class=\"language-js\">function 함수명(매개변수들){\n  본문\n}\n</code></pre>\n<p>그런데 함수 표현식(function expression)을 이용해서도 함수를 정의할 수 있다. JS에선 함수도 개체이고 따라서 함수를 변수에 할당할 수 있는 것이다.</p>\n<pre><code class=\"language-js\">let 함수명=function(매개변수들){\n  본문\n};\n</code></pre>\n<p>물론 함수는 호출할 수 있기 때문에 일반적인 값과는 다르지만, 변수에 함수를 할당하는 등 일반적인 값에 할 수 있는 일들을 함수에도 할 수 있다.</p>\n<p>그런데 위에 함수 표현식으로 함수를 정의한 부분을 보면 함수 선언문과 달리 끝에 <code>;</code>이 붙어 있다. 이는 함수 표현식이 결국 변수에 값을 할당하는 방식이기 때문에 <code>let a=0;</code>과 같은 문에 세미콜론을 붙이는 것과 같이 세미콜론이 권장되는 것이다.</p>\n<p>이렇게 함수를 값처럼 사용하는 것을 이용하면 특정 이벤트에 따라 호출되는 콜백 함수를 만드는 등 다양한 용도로 사용할 수 있다.</p>\n<h2>4.1. 함수 선언문과 함수 표현식</h2>\n<p>그럼 선언문과 표현식, 2가지 방식으로 함수를 생성할 때 무슨 차이가 있을까?</p>\n<p>함수 표현식은 코드 실행이 표현식에 도달했을 때 함수를 생성한다. 따라서 함수 표현식 코드가 나오기 이전에 그 함수를 쓰는 건 불가능하다.</p>\n<pre><code class=\"language-js\">// 아직 greeting이 정의되지 않아서 사용할 수 없다. 에러 발생!\ngreeting();\n\nlet greeting=function(){\n  console.log(\"Hi\");\n}\n</code></pre>\n<p>함수 선언문은 그 코드에 도달하기 전에도 호출할 수 있다. 자바스크립트 엔진이 코드를 실행하기 전에 함수 선언문들을 먼저 찾아서 함수를 생성하기 때문이다. 즉 모든 코드는 함수 선언문으로 정의된 함수들이 모두 생성된 후 실행된다.</p>\n<pre><code class=\"language-js\">greeting();\n// 함수 선언문으로 정의되었기 때문에 함수 선언문 이전에 호출할 수 있다.\nfunction greeting(){\n  console.log(\"Hi\");\n}\n</code></pre>\n<p>함수 표현식으로 할 수 있는 일을 하나 더 알아보자. 어떤 변수값에 따라서 함수를 다르게 정의해야 하는 경우가 있다고 하자. 예를 들어서 주어진 변수값이 나이이고 나이가 18세 이상이면 성인, 18세 미만이면 미성년자라는 메시지를 출력하는 함수를 만들어야 한다고 하자.</p>\n<p>물론 함수를 하나로 만들고 함수 내부에서 if문을 써주는 방식도 있다.</p>\n<pre><code class=\"language-js\">function greeting(age){\n  if(age>=18){\n    console.log(\"성인입니다.\");\n  }\n  else{\n    console.log(\"미성년자입니다.\");\n  }\n}\n</code></pre>\n<p>하지만 다음과 같이, 나이 변수에 따라 아예 다른 함수를 생성할 수도 있다. 그리고 이런 함수를 생성하는 방법이 바로 함수 표현식이다. 이게 더 유용할 때가 있다.</p>\n<pre><code class=\"language-js\">let greeting;\n\nif(myAge>=18){\n  greeting=function(){\n    console.log(\"성인입니다.\");\n  }\n}\nelse{\n  greeting=function(){\n    console.log(\"미성년자입니다.\");\n  }\n}\n</code></pre>\n<h1>5. 화살표 함수 기본</h1>\n<p>화살표 함수를 이용하면 함수 표현식보다 간단하게 함수를 생성할 수 있다.</p>\n<pre><code class=\"language-js\">let 함수명=(매개변수들) => 리턴값;\n</code></pre>\n<p>예를 들어서 다음과 같이 쓸 수 있다.</p>\n<pre><code class=\"language-js\">// 인수의 앞에 Hi를 붙여서 리턴해 준다.\nlet greeting=(name) => \"Hi \"+name;\nconsole.log(greeting(\"SungHyun\"));\n</code></pre>\n<p>만약 리턴값만 있는 함수가 아니라 본문이 있는 함수라면 화살표 함수에도 중괄호 블록을 만들 수 있다. 이때는 리턴값을 <code>return</code>으로 명시해 줘야 한다.</p>\n<pre><code class=\"language-js\">let add=(a,b) => {\n  // 함수 본문\n  let sum=a+b;\n  return sum;\n}\n</code></pre>\n<p>이 화살표 함수는 후에 더 자세히 다룰 것이다.</p>",
    "excerpt": "1. 반복문\nwhile과 for문이 있다.\n1.1. while\n다른 언어에서와 똑같다. 다음과 같은 형식을 하고 condition이 참일 동안 본문을 실행한다.\nwhile(condition){\n    // 본문\n}\n\ncondition의 평가값은 불린으로 변경되고 그 값이 true일 시 while 본문을 실행한다.\n1.2. do~while\ndo~while문도 다른 언어에서 있는 것과 똑같이 존재한다.\ndo{\n    // 본문\n} while(condition);\n\n",
    "headingTree": [
      {
        "title": "1. 반복문",
        "url": "#1-반복문",
        "items": [
          {
            "title": "1.1. while",
            "url": "#11-while",
            "items": []
          },
          {
            "title": "1.2. do~while",
            "url": "#12-dowhile",
            "items": []
          },
          {
            "title": "1.3. for",
            "url": "#13-for",
            "items": []
          },
          {
            "title": "1.4. break/continue with label",
            "url": "#14-breakcontinue-with-label",
            "items": []
          }
        ]
      },
      {
        "title": "2. switch",
        "url": "#2-switch",
        "items": []
      },
      {
        "title": "3. 함수",
        "url": "#3-함수",
        "items": [
          {
            "title": "3.1. 매개변수",
            "url": "#31-매개변수",
            "items": []
          },
          {
            "title": "3.2. 매개변수 기본값",
            "url": "#32-매개변수-기본값",
            "items": []
          },
          {
            "title": "3.3. 매개변수 기본값의 다른 방식",
            "url": "#33-매개변수-기본값의-다른-방식",
            "items": []
          },
          {
            "title": "3.4. 반환값 이용하기",
            "url": "#34-반환값-이용하기",
            "items": []
          }
        ]
      },
      {
        "title": "4. 함수 표현식",
        "url": "#4-함수-표현식",
        "items": [
          {
            "title": "4.1. 함수 선언문과 함수 표현식",
            "url": "#41-함수-선언문과-함수-표현식",
            "items": []
          }
        ]
      },
      {
        "title": "5. 화살표 함수 기본",
        "url": "#5-화살표-함수-기본",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 384
    },
    "url": "/posts/javascript-4",
    "thumbnail": {
      "local": "/thumbnails/javascript-4-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-javascript-4-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAiElEQVR4nGPo6uoKDAz09vYODQ3NysrS1tYODw9XU1NjaGho0NPTKy8v9/Dw4OHhcXJykpSU5OHhYSgrK5OWlm5oaDh+/PidO3fOnTt3AAwYDh8+VF5e9uzZsx8/fvxHAgzTps+Ijo4+d+7cly9f/v///xsGGJYsX714yZIVK1ZcvXoVIgHRAQCLaFm0wUVqnQAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "javascript-6",
    "title": "모던 자바스크립트 튜토리얼 part 1.3 코드 품질 - 2",
    "date": "2022-12-31T00:00:00Z",
    "description": "ko.javascript.info part 1-3 두번째",
    "tags": [
      "javascript"
    ],
    "html": "<h1>1. 테스트 자동화와 Mocha</h1>\n<p>우리는 개발하면서 끊임없이, 내가 개발한 기능이 잘 동작하는지 테스트한다. 이를 통해 우리는 코드를 개선하고, 새로운 기능을 추가할 수 있다. 이러한 테스트를 수동으로 진행하는 것은 귀찮고, 시간이 오래 걸린다.</p>\n<p>그래서 우리는 자동화된 테스트를 만들어야 한다. 많은 테스트 케이스를 만들어서 함수를 수정할 때마다 이 테스트를 통과하는지를 시험하는 것이다.</p>\n<p>여기서는 예를 들어 x의 n제곱을 반환하는 함수 pow(x, n)을 만드는 상황을 생각해보자. 코드를 바로 작성하기 전에 먼저 명세서를 작성해야 한다.</p>\n<p>명세서는 decribe, it, assert 3가지 요소로 이루어진다. 이 요소들의 기능은 다음과 같다.</p>\n<ul>\n<li>describe는 테스트를 그룹화한다. 그리고 구현하고자 하는 기능에 대한 설명을 적는다.</li>\n<li>it는 특정 기능에 대한 설명이 들어가고 2번째 인수에는 테스트를 수행하는 함수가 들어간다.</li>\n<li>assert는 테스트를 수행하는 함수 내부에 들어간다. 이 함수는 테스트를 통과하지 못하면 에러를 반환하도록 되어 있다. 예를 들어 assert.equal(pow(2, 3), 8)은 pow(2, 3)과 8이 같은지를 체크하여 다르면 에러를 반환한다.</li>\n</ul>\n<pre><code class=\"language-javascript\">describe(\"pow\", function() {\n  it(\"주어진 숫자를 n제곱한다.\", function() {\n    assert.equal(pow(2, 3), 8);\n  });\n});\n</code></pre>\n<p>이 명세서를 이용해 함수를 테스트하는 데에는 Mocha라는 테스트 프레임워크가 사용된다.</p>\n<h2>1.1. 실행해보기</h2>\n<p><a href=\"https://ko.javascript.info/testing-mocha\">보고 있는 글</a>에 나와 있는 대로 HTML 페이지를 작성해보자.</p>\n<pre><code class=\"language-html\">&#x3C;!DOCTYPE html>\n&#x3C;html>\n  &#x3C;head>\n    &#x3C;meta charset=\"utf-8\" />\n    &#x3C;title>Test Page&#x3C;/title>\n    &#x3C;!-- 결과 출력에 사용되는 mocha css를 불러옵니다. -->\n    &#x3C;link\n      rel=\"stylesheet\"\n      href=\"https://cdnjs.cloudflare.com/ajax/libs/mocha/3.2.0/mocha.css\"\n    />\n    &#x3C;!-- Mocha 프레임워크 코드를 불러옵니다. -->\n    &#x3C;script src=\"https://cdnjs.cloudflare.com/ajax/libs/mocha/3.2.0/mocha.js\">&#x3C;/script>\n    &#x3C;script>\n      mocha.setup(\"bdd\"); // 기본 셋업\n    &#x3C;/script>\n    &#x3C;!-- chai를 불러옵니다 -->\n    &#x3C;script src=\"https://cdnjs.cloudflare.com/ajax/libs/chai/3.5.0/chai.js\">&#x3C;/script>\n    &#x3C;script>\n      // chai의 다양한 기능 중, assert를 전역에 선언합니다.\n      let assert = chai.assert;\n    &#x3C;/script>\n  &#x3C;/head>\n  &#x3C;body>\n    &#x3C;script>\n      function pow(x, n) {\n        /* 코드를 여기에 작성합니다. 지금은 빈칸으로 남겨두었습니다. */\n      }\n    &#x3C;/script>\n\n    &#x3C;!-- 테스트(describe, it...)가 있는 스크립트를 불러옵니다. -->\n    &#x3C;script src=\"test.js\">&#x3C;/script>\n\n    &#x3C;!-- 테스트 결과를 id가 \"mocha\"인 요소에 출력하도록 합니다.-->\n    &#x3C;div id=\"mocha\">&#x3C;/div>\n    &#x3C;!-- 테스트를 실행합니다! -->\n    &#x3C;script>\n      mocha.run();\n    &#x3C;/script>\n  &#x3C;/body>\n&#x3C;/html>\n</code></pre>\n<p>그리고 아까 작성한 명세서를 test.js에 넣는다.</p>\n<pre><code class=\"language-javascript\">//test.js\ndescribe(\"pow\", function () {\n  it(\"주어진 숫자를 n제곱한다.\", function () {\n    assert.equal(pow(2, 3), 8);\n  });\n});\n</code></pre>\n<p>이 상태로 위의 HTML 파일을 크롬에서 열면 아래와 같은 결과를 볼 수 있다. 당연하지만 테스트가 통과되지 않았다고 한다. 아직 함수를 전혀 작성하지 않았으니 당연하다.</p>\n<p><img src=\"/static/test-1-9604027d.png\" alt=\"test-1\"></p>\n<h2>1.2. 테스트 개선</h2>\n<p>그런데 아직 우리는 테스트를 하나밖에 작성하지 않았다. 만약 pow함수가 무조건 8을 리턴하는 함수라면 우리가 작성한 테스트를 통과해 버릴 것이다. 따라서 몇 가지 테스트를 더 추가해 보자.</p>\n<p>추가는 describe 블록 내에 it 블록을 더 추가하면 된다. 물론 같은 it 블록 내에 여러 개의 assert를 넣을 수도 있다. 하지만 기존 it 블록에 assert를 추가하는 방식은 하나의 assert가 실패했을 시 그 뒤의 테스트 결과를 알 수 없다는 단점이 있다. 따라서 it블록 하나(하나의 테스트)에서는 한 가지만 확인하자.</p>\n<pre><code class=\"language-js\">//test.js\ndescribe(\"pow\", function () {\n  it(\"2의 3제곱은 8\", function () {\n    assert.equal(pow(2, 3), 8);\n  });\n\n  it(\"3의 4제곱은 81\", function () {\n    assert.equal(pow(3, 4), 81);\n  });\n});\n</code></pre>\n<p>이제 pow 함수를 제대로 작성해서 테스트해 보자. pow 함수를 다음과 같이 수정한다.</p>\n<pre><code class=\"language-js\">function pow(x, n) {\n  let r=1;\n  for(let i=0;i&#x3C;n;i++){\n    r*=x;\n  }\n  return r;\n}\n</code></pre>\n<p>그리고 나서 테스트 페이지를 다시 열면 2개의 테스트를 모두 통과한 것을 볼 수 있다.</p>\n<p><img src=\"/static/test-success-ac2b7290.png\" alt=\"success\"></p>\n<p>하지만 이렇게 모든 테스트를 하나씩 작성하면 힘이 든다. 따라서 여러 개의 테스트를 반복문을 통해서 만드는 것도 가능하다. 예를 들어 1부터 5까지의 네제곱에 대해서 pow 함수를 테스트하는 코드를 다음과 같이 만들 수 있다.</p>\n<pre><code class=\"language-js\">//test.js\ndescribe(\"pow\", function () {\n  it(\"2의 3제곱은 8\", function () {\n    assert.equal(pow(2, 3), 8);\n  });\n\n  function makeTest(x) {\n    let result = x * x * x * x;\n    it(`${x}의 네제곱은 ${result}`, function () {\n      assert.equal(pow(x, 4), result);\n    });\n  }\n\n  for (let i = 1; i &#x3C;= 5; i++){\n    makeTest(i);\n  }\n});\n</code></pre>\n<h2>1.3 테스트 그룹화</h2>\n<p>위에서는 네제곱에 대해서만 테스트했지만 당연히 여러 가지의 테스트가 있을 수 있다. 네제곱뿐 아니라 세제곱에 대해서도 테스트를 만든다거나, 숫자가 아닌 입력에 대해 제대로 대처하는지에 대한 테스트들을 생각할 수 있다. 이를 위해서 중첩 describe를 사용할 수 있다.</p>\n<p>먼저 세제곱 테스트 그룹을 새로 만들어 보자.</p>\n<pre><code class=\"language-js\">//test.js\ndescribe(\"pow\", function () {\n  describe(\"세제곱 테스트\", function () {\n    function makeTest(x) {\n      let result = x * x * x;\n      it(`${x}의 세제곱은 ${result}`, function () {\n        assert.equal(pow(x, 3), result);\n      });\n    }\n\n    for (let i = 1; i &#x3C;= 5; i++){\n      makeTest(i);\n    }\n  })\n    \n\n  describe(\"네제곱 테스트\", function () {\n    function makeTest(x) {\n      let result = x * x * x * x;\n      it(`${x}의 네제곱은 ${result}`, function () {\n        assert.equal(pow(x, 4), result);\n      });\n    }\n\n    for (let i = 1; i &#x3C;= 5; i++){\n      makeTest(i);\n    }\n  })\n});\n</code></pre>\n<p>이렇게 정의된 테스트 그룹은 테스트 결과 페이지에 들여쓰기된 상태로 출력된다.</p>\n<p><img src=\"/static/test-group-e45f74d5.png\" alt=\"test-group\"></p>\n<p>그리고 pow 함수에선 수많은 예외가 발생할 수 있다. 예를 들어서 인자로 문자열이 들어온다면? 이런 예외들을 처리하는 테스트도 있어야 한다. 여기서는 일단 <code>pow(x,n)</code>에서 n이 음수일 때 혹은 n이 정수가 아닐 때에 적절히 대처하는지에 대한 테스트를 작성해 본다.</p>\n<p>앞에서 말한 예외적인 경우 리턴값은 NaN이 되어야 한다. <code>assert.isNaN</code>을 사용하여 다음과 같이 테스트를 작성하자.</p>\n<pre><code class=\"language-js\">describe(\"네제곱 테스트\", function () {\n  function makeTest(x) {\n    let result = x * x * x * x;\n    it(`${x}의 네제곱은 ${result}`, function () {\n      assert.equal(pow(x, 4), result);\n    });\n  }\n\n  for (let i = 1; i &#x3C;= 5; i++){\n    makeTest(i);\n  }\n})\n\ndescribe(\"예외 처리\", function () {\n  it(\"n이 음수면 결과는 NaN\", function () {\n    assert.isNaN(pow(2, -1));\n  });\n\n  it(\"n이 정수가 아니면 결과는 NaN\", function () {\n    assert.isNaN(pow(2, 1.5));\n  })\n\n  it(\"n이 정수가 아니면 결과는 NaN - 2\", function () {\n    assert.isNaN(pow(2, \"Hi\"));\n  })\n})\n</code></pre>\n<p>아직 우리는 pow함수에서 예외처리를 해주지 않았으므로 예외 처리 테스트들은 모두 실패한다. 이를 pow 함수에서 수정해 보자. 다음과 같이 할 수 있다.</p>\n<pre><code class=\"language-js\">function pow(x, n) {\n  if(typeof(n)!=\"number\" || Math.round(n) != n){\n    return NaN;\n  }\n  if(n&#x3C;0){\n    return NaN;\n  }\n  let r=1;\n  for(let i=0;i&#x3C;n;i++){\n    r*=x;\n  }\n  return r;\n}\n</code></pre>\n<p>pow 함수를 이렇게 수정한 후 다시 페이지를 로드하면 모든 테스트가 통과되는 것을 볼 수 있다. 이런 식으로 테스트 명세서를 작성한 후 그 테스트들을 통과하는 코드를 구현하는 것은 기존에 구현된 기능에 영향을 주지 않고 안전하게 코드를 개선하거나 변경하게 해준다. 그리고 에러 발생 여부를 쉽게 테스트할 수 있으므로 수정과 개선을 기피하지 않게 된다.</p>\n<p>그리고 구현 전에 테스트를 먼저 작성하므로, 코드 전에 스펙을 상세히 정의하게 되어 더 나은 아키텍처를 구성할 수 있다.</p>\n<p>마지막으로, 하나의 it블록에 명확한 입력, 출력을 가진 하나의 테스트만 작성하는 것이 좋음에 유의하자.</p>\n<h1>2. 폴리필</h1>\n<p>JS는 계속 바뀌는 언어이다. 계속 새로운 제안이 등록되고 레벨이 어느 정도 올라가면 정말 JS 표준에 포함되기도 한다. 그런데 표준에 포함된 지 얼마 안 되는 기능은 특정 엔진에서 작동하지 않기도 한다. 모든 엔진이 표준을 완벽하게 구현하는 건 아니기 때문이다.</p>\n<h2>2.1. 트랜스파일</h2>\n<p>이럴 때 모던 JS코드를 구 표준 코드로 바꾸어 주는 트랜스파일러인 바벨을 사용할 수 있다. 웹팩 같은 프로젝트 빌드 시스템은 코드 수정시마다 자동으로 트랜스파일해준다. 예를 들어서 ES6 코드를 ES5로 바꾸어 주는 것도 트랜스파일이다.</p>\n<h2>2.2. 폴리필</h2>\n<p>명세서에는 새로운 내용이 추가되기도 한다. 이때 새 문법이 추가된 경우 트랜스파일러가 구 표준 코드로 바꿔 주면 된다. 그런데 새 내장 함수가 추가된 경우 명세서에 있는 함수가 구현되어 있어야 사용할 수 있다. 이렇게 새롭게 만들어진 표준을 준수할 수 있게 기존 함수의 동작을 수정하거나 새롭게 구현한 함수 스크립트를 폴리필(polyfill)이라고 한다.</p>\n<p>예를 들어서 <a href=\"https://xo.dev/js-temporal-api/\">Temporal API</a>를 사용할 수 있도록 해주는 폴리필은 <a href=\"https://github.com/js-temporal/temporal-polyfill\">여기</a>를 참고해 설치할 수 있다.</p>",
    "excerpt": "1. 테스트 자동화와 Mocha\n우리는 개발하면서 끊임없이, 내가 개발한 기능이 잘 동작하는지 테스트한다. 이를 통해 우리는 코드를 개선하고, 새로운 기능을 추가할 수 있다. 이러한 테스트를 수동으로 진행하는 것은 귀찮고, 시간이 오래 걸린다.\n그래서 우리는 자동화된 테스트를 만들어야 한다. 많은 테스트 케이스를 만들어서 함수를 수정할 때마다 이 테스트를 통과하는지를 시험하는 것이다.\n여기서는 예를 들어 x의 n제곱을 반환하는 함수 pow(x, n)을 만드는 상",
    "headingTree": [
      {
        "title": "1. 테스트 자동화와 Mocha",
        "url": "#1-테스트-자동화와-mocha",
        "items": [
          {
            "title": "1.1. 실행해보기",
            "url": "#11-실행해보기",
            "items": []
          },
          {
            "title": "1.2. 테스트 개선",
            "url": "#12-테스트-개선",
            "items": []
          },
          {
            "title": "1.3 테스트 그룹화",
            "url": "#13-테스트-그룹화",
            "items": []
          }
        ]
      },
      {
        "title": "2. 폴리필",
        "url": "#2-폴리필",
        "items": [
          {
            "title": "2.1. 트랜스파일",
            "url": "#21-트랜스파일",
            "items": []
          },
          {
            "title": "2.2. 폴리필",
            "url": "#22-폴리필",
            "items": []
          }
        ]
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 372
    },
    "url": "/posts/javascript-6",
    "thumbnail": {
      "local": "/static/test-1-9604027d.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-test-1-9604027d-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAADCAIAAAAhqtkfAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAU0lEQVR4nGPYtnXruTNnPrx///r167Vr1x44cKC3tzczM5MhNChIko8vKiBg8by5KxcvPnJg3+vXr////89w7+69QE9PLSUlST4+dVnZzKQkiAQAn3gqn+Cz9zQAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "javascript-5",
    "title": "모던 자바스크립트 튜토리얼 part 1.3 코드 품질 - 1",
    "date": "2022-12-27T00:00:00Z",
    "description": "ko.javascript.info part 1-3 첫번째",
    "tags": [
      "javascript"
    ],
    "html": "<h1>1. 크롬에서의 디버깅</h1>\n<p>크롬에서 <code>F12</code>를 누르거나 맥에서는 <code>Ctrl + Shift + I</code>를 누르면 개발자 도구가 열린다. 여기에는 Sources 패널이 있다. 이 패널에서는 로딩된 페이지의  코드를 보고 디버깅할 수 있다. 페이지를 구성하는 데 쓰인 모든 리소스를 트리 형태로 보여주고 그 소스도 볼 수 있게 해준다.</p>\n<p>예시를 통해 알아보자. 먼저 index.html을 다음과 같이 작성한다.</p>\n<pre><code class=\"language-html\">&#x3C;!DOCTYPE html>\n&#x3C;html>\n  &#x3C;head>\n    &#x3C;meta charset=\"utf-8\" />\n    &#x3C;title>Study Page&#x3C;/title>\n  &#x3C;/head>\n  &#x3C;body>\n    &#x3C;script src=\"./script.js\">&#x3C;/script>\n  &#x3C;/body>\n&#x3C;/html>\n</code></pre>\n<p>그리고 script.js를 다음과 같이 간단한 코드로 작성해본다.</p>\n<pre><code class=\"language-js\">function hello(name) {\n  console.log(\"Hello \", name);\n}\n\nfunction goodbye(name) {\n  console.log(\"Goodbye \", name);\n}\n\nfunction greeting(name) {\n  hello(name);\n  goodbye(name);\n}\n\ngreeting(\"witch\");\n</code></pre>\n<p>이렇게 한 후 index.html을 실행하면 콘솔에 'Hello witch' 와 'Goodbye witch'가 찍히는 것을 볼 수 있다.</p>\n<h2>1.1. 중단점 설정하기</h2>\n<p>이제 개발자 도구를 열어보자. Sources 패널에서 script.js를 클릭하면 다음과 같이 코드가 보인다.</p>\n<p><img src=\"/static/scriptjs-devtools-0798ce76.png\" alt=\"devtools\"></p>\n<p>소스가 보이는 곳에서 줄 번호를 클릭하면 중단점이 설정된다. 다음과 같이 6번 줄과 10번 줄에 중단점을 설정했다.</p>\n<p><img src=\"/static/break-56ba717d.png\" alt=\"breakpoint\"></p>\n<p>이제 새로고침을 하면 중단점이 설정된 곳에서 코드 실행이 멈춘다. 페이지에 <code>Paused in debugger</code>라는 문구가 뜨고 다음 중단점까지 실행하거나 하는 등의 기능을 사용할 수 있다.</p>\n<p>예를 들어 위와 같은 코드에서는 <code>greeting(\"witch\")</code>에서 코드의 실행이 시작되고 바로 greeting 함수 내부로 이동하여 10번 줄에서 첫 중단점이 걸린다. 다음 중단점은 goodbye함수가 호출될 때 goodbye 함수 내부인 6번 줄에서 걸린다.</p>\n<p>또한 중단점을 걸어 두면 중단점까지 코드가 실행된 시점에서의 콜스택(중단점까지 오면서 호출된 함수의 경로), 현재 정의된 모든 변수(scope에서 확인 가능)등 다양한 정보를 확인할 수 있으므로 디버깅에 도움이 된다.</p>\n<p>예를 들어 다음과 같이 콜스택과 현재 정의된 변수들을 확인 가능하다. greeting 함수 -> goodbye 함수를 거쳐 6번 줄의 중단점에 도달했다는 것을 알 수 있다. 또한 현재 정의된 변수는 name이 있다.</p>\n<p><img src=\"/static/devtool-info-2c5a29d4.png\" alt=\"info\"></p>\n<p>또한 코드 중간에 <code>debugger</code>라는 키워드를 사용하면 코드가 실행되는 시점에서 중단점이 걸린다. 에디터를 떠나지 않고도 중단점을 설정할 수 있다는 장점이 있다.</p>\n<pre><code class=\"language-js\">function greeting(name) {\n  hello(name);\n  debugger;\n  goodbye(name);\n}\n</code></pre>\n<h2>1.2. 실행 추적시 동작</h2>\n<p>디버깅할 때 다음 중단점으로 이동하기, 바로 다음 명령어 실행하기 등의 기능을 알아보자.</p>\n<h3>1.2.1. Resume</h3>\n<p>스크립트 실행을 다시 시작하여 다음 중단점까지 실행한다. 다음 중단점이 없으면 스크립트 실행이 끝날 때까지 실행한다. 단축키는 <code>F8</code>이다.</p>\n<h3>1.2.2. Step</h3>\n<p>바로 다음 문을 실행한다. 만약 함수 호출이 있다면 호출된 함수 내부로 이동해서 다음 문을 실행한다. 즉 스크립트 전체를 문 하나씩 실행하는 것이다. 단축키는 <code>F9</code>이다.</p>\n<h3>1.2.3. Step over</h3>\n<p>다음 문을 실행하는데 Step과 달리 함수 내부로 들어가지는 않는다. 다음과 같은 상황으로 예를 들어 보자. 10번 줄의 hello 호출에서 중단점이 걸려 있다.</p>\n<p><img src=\"/static/stepover-d4d0117e.png\" alt=\"step-over\"></p>\n<p>이 상태에서 step을 실행하면 호출된 hello함수 내부로 이동하여 2번 줄을 실행한다. 그러나 step over를 실행하면 hello 함수 내부로 들어가지 않고 바로 11번 줄의 goodbye 함수 실행으로 이동하게 된다. 단축키는 <code>F10</code>이다.</p>\n<h3>1.2.4. Step out</h3>\n<p>실행 중인 함수의 실행이 끝날 때까지 실행하고 함수가 끝난 후의 명령어로 이동한다. 가능한 빨리 함수 실행을 끝내고 다음으로 넘어가고자 할 때 사용한다. 단축키는 <code>Shift + F11</code>이다.</p>\n<h3>1.2.5. Step into</h3>\n<p>step과 같이 다음 명령어를 실행한다. 그러나 비동기 함수 호출에서 차이가 있다. step은 비동기 동작을 무시하지만 step into는 비동기 동작 코드로 진입하고 필요하다면 비동기 동작 완료까지 대기한다. 단축키는 <code>F11</code>이다.</p>\n<h1>2. 주석 작성하기</h1>\n<p>코드에서 무슨 일이 일어나는지를 다 설명하는 주석을 다는 것은 그렇게 좋지 않다. 함수를 적절히 분리하고 그 함수의 이름을 잘 지어서 주석 없이도 동작이 눈에 들어오는 코드를 짜는 것이 원칙적으로는 가장 좋다.</p>\n<p>그러나 주석이 있는 것이 좋을 때가 몇 개 있는데 먼저 아키텍처를 설명하는 주석이다. 고차 컴포넌트나 컴포넌트 간 상호작용을 설명하는 주석은 코드 구조를 파악하는 데 도움을 주므로 좋다.</p>\n<p>또한 직관적이지 않은 무언가가 있다면 작성해 주는 게 좋다. 예를 들어서 switch문에서 break 없이 fall-through를 의도적으로 하는 코드가 있다면 주석이 있는 게 좋다.</p>\n<p>그리고 어떤 문제를 해결하기 위해 작성한 코드가 있다면 그 방식을 적어주는 것도 추후에 코드를 이해하는 데에 좋다. 문제 해결을 위해 넣어 둔 부분을 리팩토링하면서 고쳐 버릴 수도 있기 때문이다.</p>\n<h2>2.1 JSDoc</h2>\n<p>JSDoc이라는 문법을 사용하여 함수에 관한 문서를 작성하는 주석도 쓰면 좋다. 각 함수의 용례, 매개변수, 리턴값 정보 등이 들어간다.</p>\n<p>이를 쓰면 API를 설명하는 주석을 더 쉽게 달 수 있고 IDE에서도 함수나 클래스의 정보를 보여준다. 이를 기반으로 API 문서를 자동으로 생성해 주는 도구도 있다.</p>\n<p>JSDoc은 주석을 <code>/** */</code>으로 감싸서 작성할 수 있다. 그리고 <code>@</code>로 시작하는 키워드를 사용하여 작성한다.</p>\n<pre><code class=\"language-js\">/**\n * @author witch\n * @param {string} name 인사를 할 이름\n * @version 1.0.0\n */\nfunction hello(name) {\n  console.log(\"Hello \", name);\n}\n</code></pre>\n<p>유명한 태그들은 다음과 같다.</p>\n<h3>2.1.1. @author</h3>\n<p>작성자를 나타낸다.</p>\n<h3>2.1.2. @constructor</h3>\n<p>함수가 클래스 생성자임을 나타낸다. 생략하더라도 어차피 constructor 함수는 생성자로 인식한다.</p>\n<h3>2.1.3. @deprecated</h3>\n<p>함수가 더 이상 사용되지 않는 것임을 나타낸다.</p>\n<h3>2.1.4. @exception</h3>\n<p>함수가 어떤 에러를 던지는지 나타낸다. <code>@exception {InvalidArgumentException} description</code>  와 같이 쓸 수 있다.</p>\n<h3>2.1.5. @exports</h3>\n<p>export되는 함수임을 나타낸다. exports 객체를 사용한다면 이 태그는 굳이 쓸 필요가 없다. exports나 module.exports에 외에 다른 모듈을 export하는 경우에만 쓴다. @export modulename 과 같이 쓸 수 있다.</p>\n<h3>2.1.6. @param</h3>\n<p>함수의 매개변수를 설명한다. <code>@param {string} name 인사를 할 이름</code> 와 같이 매개변수 타입과 매개변수명, 설명을 쓸 수 있다.</p>\n<h3>2.1.7. @private</h3>\n<p>함수가 private 접근 제한임을 나타낸다.</p>\n<h3>2.1.8. @return, returns</h3>\n<p>함수의 리턴값을 설명한다. <code>@return {string} 리턴값에 대한 설명</code> 와 같이 리턴값의 타입과 설명을 쓸 수 있다.</p>\n<h3>2.1.9. @see</h3>\n<p>다른 개체와의 연관성을 나타낸다. 예를 들어서 bar 함수가 foo 함수와 관련이 있다면 foo의 JSDoc에 <code>@see {@link bar}</code> 와 같이 쓸 수 있다.</p>\n<h3>2.1.10. @throws</h3>\n<p>@exception과 같은 역할을 한다.</p>\n<h3>2.1.11. @todo</h3>\n<p>함수에 대한 TODO를 나타낸다. <code>@todo 할 일</code> 와 같이 쓸 수 있다.</p>\n<h3>2.1.12. @this</h3>\n<p>다른 심볼 내에서 쓰일 때 this 키워드가 가리키는 것을 나타낸다. 예를 들어서 <code>@this {Foo}</code> 와 같이 쓰면 이 객체가 Foo 내에서 쓰일 때 이 함수 내의 this는 Foo 객체를 가리킨다는 것을 나태난다.</p>\n<p>JSDoc 문서의 예시는 다음과 같이 나타난다. setName 함수가 Greeter 클래스 내에서 쓰일 때 this는 Greeter 클래스의 인스턴스를 가리킨다는 것을 나타낸다.</p>\n<pre><code class=\"language-js\">/** @constructor */\nfunction Greeter(name) {\n    setName.apply(this, name);\n}\n\n/** @this Greeter */\nfunction setName(name) {\n    /** document me */\n    this.name = name;\n}\n</code></pre>\n<h3>2.1.13. @version</h3>\n<p>버전을 나타낸다. <code>@version 1.0.0</code> 와 같이 쓸 수 있다.</p>\n<h1>참고</h1>\n<p>위키 JSDoc 문서 <a href=\"https://en.wikipedia.org/wiki/JSDoc\">https://en.wikipedia.org/wiki/JSDoc</a></p>\n<p>JSDoc see <a href=\"https://jsdoc.app/tags-see.html\">https://jsdoc.app/tags-see.html</a></p>\n<p>JSDoc this <a href=\"https://jsdoc.app/tags-this.html\">https://jsdoc.app/tags-this.html</a></p>",
    "excerpt": "1. 크롬에서의 디버깅\n크롬에서 F12를 누르거나 맥에서는 Ctrl + Shift + I를 누르면 개발자 도구가 열린다. 여기에는 Sources 패널이 있다. 이 패널에서는 로딩된 페이지의  코드를 보고 디버깅할 수 있다. 페이지를 구성하는 데 쓰인 모든 리소스를 트리 형태로 보여주고 그 소스도 볼 수 있게 해준다.\n예시를 통해 알아보자. 먼저 index.html을 다음과 같이 작성한다.\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta",
    "headingTree": [
      {
        "title": "1. 크롬에서의 디버깅",
        "url": "#1-크롬에서의-디버깅",
        "items": [
          {
            "title": "1.1. 중단점 설정하기",
            "url": "#11-중단점-설정하기",
            "items": []
          },
          {
            "title": "1.2. 실행 추적시 동작",
            "url": "#12-실행-추적시-동작",
            "items": [
              {
                "title": "1.2.1. Resume",
                "url": "#121-resume",
                "items": []
              },
              {
                "title": "1.2.2. Step",
                "url": "#122-step",
                "items": []
              },
              {
                "title": "1.2.3. Step over",
                "url": "#123-step-over",
                "items": []
              },
              {
                "title": "1.2.4. Step out",
                "url": "#124-step-out",
                "items": []
              },
              {
                "title": "1.2.5. Step into",
                "url": "#125-step-into",
                "items": []
              }
            ]
          }
        ]
      },
      {
        "title": "2. 주석 작성하기",
        "url": "#2-주석-작성하기",
        "items": [
          {
            "title": "2.1 JSDoc",
            "url": "#21-jsdoc",
            "items": [
              {
                "title": "2.1.1. @author",
                "url": "#211-author",
                "items": []
              },
              {
                "title": "2.1.2. @constructor",
                "url": "#212-constructor",
                "items": []
              },
              {
                "title": "2.1.3. @deprecated",
                "url": "#213-deprecated",
                "items": []
              },
              {
                "title": "2.1.4. @exception",
                "url": "#214-exception",
                "items": []
              },
              {
                "title": "2.1.5. @exports",
                "url": "#215-exports",
                "items": []
              },
              {
                "title": "2.1.6. @param",
                "url": "#216-param",
                "items": []
              },
              {
                "title": "2.1.7. @private",
                "url": "#217-private",
                "items": []
              },
              {
                "title": "2.1.8. @return, returns",
                "url": "#218-return-returns",
                "items": []
              },
              {
                "title": "2.1.9. @see",
                "url": "#219-see",
                "items": []
              },
              {
                "title": "2.1.10. @throws",
                "url": "#2110-throws",
                "items": []
              },
              {
                "title": "2.1.11. @todo",
                "url": "#2111-todo",
                "items": []
              },
              {
                "title": "2.1.12. @this",
                "url": "#2112-this",
                "items": []
              },
              {
                "title": "2.1.13. @version",
                "url": "#2113-version",
                "items": []
              }
            ]
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 226
    },
    "url": "/posts/javascript-5",
    "thumbnail": {
      "local": "/static/scriptjs-devtools-0798ce76.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-scriptjs-devtools-0798ce76-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAFCAIAAAD38zoCAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAgUlEQVR4nGOQV1QpLCxevGSJm7s3ExO3nb1DV3dPRWUVg4ubm5q6enNz8+JFi4vzit0cHRcuWLB02TKG+fNmV1VVzp8/f+aMmV7unpmZmV+/fl2/fj3Dfxg4dPjI/PnzT5048f//f6jE169ff37/+fXr1z9//379+vX///8rV64CAMIlS9gkHWlOAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "javascript-8",
    "title": "모던 자바스크립트 튜토리얼 part 1.4 객체 기본 - 2",
    "date": "2023-01-02T00:00:00Z",
    "description": "ko.javascript.info part 1-4 두번째",
    "tags": [
      "javascript"
    ],
    "html": "<h1>1. 메서드와 this</h1>\n<p>객체에도 메서드가 존재할 수 있다. 객체 프로퍼티에 값을 할당할 때 함수를 값으로 할당하면 메서드가 된다.</p>\n<pre><code class=\"language-js\">let info = {\n  name: \"김성현\",\n  age: 25,\n};\n\ninfo.sayHi = function () {\n  alert(\"안녕하세요\");\n};\n</code></pre>\n<p>위와 같이 객체를 선언한 경우 <code>info.sayHi()</code>로 메서드를 사용할 수 있다.</p>\n<h2>1.1 메서드의 단축 구문</h2>\n<p>객체 내부에 function 키워드를 사용하여 메서드를 선언하거나 단축 구문으로 함수 이름만 적어도 된다.</p>\n<pre><code class=\"language-js\">// function 키워드 쓰기\nlet info = {\n  name: \"김성현\",\n  age: 25,\n  sayHi: function () {\n    alert(\"안녕하세요\");\n  },\n};\n// 단축 구문 쓰기\nlet info = {\n  name: \"김성현\",\n  age: 25,\n  sayHi() {\n    alert(\"안녕하세요\");\n  },\n};\n</code></pre>\n<p>위의 2가지 방식은 약간의 차이가 있다. 먼저 단축 구문으로 선언한 메서드의 경우 생성자로 사용할 수 없다.</p>\n<pre><code class=\"language-js\">let info = {\n  name: \"김성현\",\n  blog: \"https://www.witch.work/\",\n\n  method1() {},\n  method2: function () {\n    console.log(this.name);\n  },\n};\nnew info.method1(); // 단축 구문으로 생성한 메서드는 생성자로 사용시 에러 발생\nnew info.method2(); // 일반 구문으로 생성한 메서드는 생성자로 정상 실행\n</code></pre>\n<p>그리고 단축 구문으로 선언한 메서드는 <code>메서드 정의</code>라고도 불린다. 그 이름답게, 메서드 정의로 선언한 메서드에서만 super 키워드에 대한 접근이 가능하다.</p>\n<h1>1.2 메서드와 this</h1>\n<p>메서드 내부에서 this 키워드를 사용하면 메서드를 호출한 객체를 참조할 수 있다. 이 값은 런타임에 결정되며 문맥에 따라 달라진다. 같은 함수라도 다른 객체에서 호출하거나 문맥이 달라지면 this값이 달라질 수 있다. 아래 코드를 보면 sayHi를 호출한 객체에 따라 this가 달라지는 것을 확인할 수 있다.</p>\n<pre><code class=\"language-js\">let user = {\n  name: \"김성현\",\n};\nlet member = {\n  name: \"김기동\",\n};\nfunction sayHi() {\n  alert(this.name);\n}\n\nuser.f = sayHi;\nmember.f = sayHi;\n\nuser.f(); // 김성현\nmember.f(); // 김기동\n</code></pre>\n<p>물론 sayHi에서 <code>alert(user.name)</code>을 쓰는 식으로 외부 변수 접근을 통해 특정 객체를 참조하도록 강제할 수도 있다. 하지만 이럴 경우 user의 내용이 바뀌었을 경우 문제가 생길 수 있다.</p>\n<p>이 내용은 다른 글에서 더 자세히 다루도록 한다.</p>\n<h1>2. new와 생성자</h1>\n<p>생성자 함수, new를 쓰면 유사한 객체를 쉽게 만들 수 있다. 생성자 함수는 일반 함수와 구분하기 위해 관례적으로 첫 글자를 대문자로 쓴다.</p>\n<p>또한 생성자 함수는 new를 붙여 호출하며, new를 붙이지 않고 호출하면 일반 함수로 동작한다. 다음은 Person이라는 생성자 함수를 만들고 사용한 예시이다.</p>\n<pre><code class=\"language-js\">function Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\nlet person = new Person(\"John\", 30);\nconsole.log(person.name);\n</code></pre>\n<p><code>new Person</code>을 호출하면 다음과 같은 일이 일어난다. 먼저 빈 객체를 만들어 this에 할당하고 함수 본문을 실행한다. 그리고 this를 반환한다. 다음과 같은 코드를 통해서, 함수의 시작시 this가 빈 객체를 참조하고, 함수가 종료되면 만들어진 this가 반환되는 것을 확인할 수 있다.</p>\n<pre><code class=\"language-js\">function Person(name, age) {\n  console.log(this);\n  this.name = name;\n  this.age = age;\n  console.log(this);\n}\n\nlet person = new Person(\"John\", 30);\n</code></pre>\n<p>new를 붙여 주면 어떤 함수든 생성자 함수로 실행된다. 생성자 함수의 첫 글자가 대문자인 건 관례이다.</p>\n<h2>2.1. new.target</h2>\n<p>new를 붙여 호출했는지 확인할 수 있는 함수 내의 특별한 프로퍼티이다. new를 붙여 호출했으면 new.target은 함수 자신을 참조하고, 그렇지 않으면 undefined를 참조한다.</p>\n<h2>2.2. 생성자의 return</h2>\n<p>생성자 함수에는 보통 return을 쓰지 않지만 쓰지 못하는 건 아니다. return을 쓰면 어떤 일이 일어날까?</p>\n<p>객체를 리턴하면 this대신 객체가 반환된다. 만약 원시형을 리턴하면 this가 무시되고, 리턴된 값이 반환된다. 아무것도 리턴하지 않고 <code>return;</code>만 쓰는 경우에도 this가 반환된다.</p>\n<pre><code class=\"language-js\">function Person(name, age) {\n  this.name = name;\n  this.age = age;\n  return 3;\n}\n//person은 3이 아니라 생성자에서 반환한 this가 된다\nlet person = new Person(\"John\", 30);\nconsole.log(person);\n</code></pre>\n<p>또한 인수가 없는 생성자 함수의 경우 괄호를 생략하고 호출할 수도 있다. 그러나 좋은 코드 스타일은 아니다.</p>\n<p>그리고 생성자 내에서 this에 메서드를 추가하는 것도 물론 가능하다.</p>\n<h1>3. 옵셔널 체이닝</h1>\n<p>우리가 객체의 속성에 접근할 때 만약 객체에 없는 속성에 접근 시도를 한다면 undefined가 반환된다. 그런데 <code>user.address.city</code>와 같이 객체의 속성에 중첩해서 접근할 경우, 중간에 존재하지 않는 속성이 있다면 에러가 발생한다. 옵셔널 체이닝은 이런 문제를 다룰 수 있게 해준다.</p>\n<p><code>?.</code>는 <code>?.</code>앞의 평가 대상이 undefined나 null이면 평가를 멈추고 undefined를 반환한다. 다음과 같이 쓸 수 있다.</p>\n<pre><code class=\"language-js\">let user = null;\nconsole.log(user?.address);\n</code></pre>\n<p>user가 널이므로 user?.address는 undefined가 된다. 만약 <code>user.address</code>를 썼다면 에러가 발생했을 것이다.</p>\n<p>그러나 <code>?.</code>는 그 바로 앞의 평가 대상에 대해서만 작동한다. 만약 ?.의 결과로 undefined가 반환되었고 그 다음에 .을 통한 객체 접근 시도가 있다면 에러가 반환된다.</p>\n<pre><code class=\"language-js\">let user = {\n  name: \"김성현\",\n  age: 25,\n};\n// user.address가 없으므로 undefined.city와 같고 따라서 에러 발생\nconsole.log(user?.address.city);\n</code></pre>\n<p>그리고 ?.도 평가 대상이 없으면 에러가 발생한다.</p>\n<pre><code class=\"language-js\">// user변수 자체가 없으므로 에러 발생\nconsole.log(user?.address);\n</code></pre>\n<h2>3.1. 메서드와 함께 쓰기</h2>\n<p>?.는 연산자가 아니고 함수 혹은 대괄호와 함께 쓰이는 특별한 문법 구조체이다. 따라서 메서드 호출과 함께도 쓸 수 있다. 예를 들어서 존재 여부가 확실치 않은 함수를 호출할 때.</p>\n<p>다음과 같이 쓰인 경우, test 객체에 method2는 없다. 하지만 ?.를 통해 호출했으므로 에러는 발생하지 않고 그냥 평가가 멈춘다.</p>\n<p>test.method2는 undefined가 되는데 ?.가 undefined를 감지하므로 평가를 멈추는 것이다.</p>\n<pre><code class=\"language-js\">let test = {\n  method() {\n    console.log(\"method\");\n  },\n};\n\ntest.method();\ntest.method2?.();\n</code></pre>\n<p>비슷하게 <code>undefined?.()</code>도 에러를 발생시키지 않는다.</p>\n<h2>3.2. 대괄호와 함께 쓰기</h2>\n<p>. 대신 대괄호를 사용해 객체 프로퍼티에 접근하는 경우 <code>?.[]</code>를 사용할 수 있다. 해당 키의 존재가 확실하지 않아도 안전하게 프로퍼티를 읽는 것이다.</p>\n<pre><code class=\"language-js\">let user = {\n  name: \"김성현\",\n  age: 25,\n};\n// undefined를 출력\nconsole.log(user?.[\"house address\"]);\n</code></pre>\n<p>?.는 할당 연산자 왼쪽에서 사용될 수 없다는 점에 주의하자. 쓰기에는 사용할 수 없다. 단 delete와 조합하여 '이 객체가 있을 경우 이 속성을 삭제'하는 용도로 사용할 수 있다.</p>\n<h1>4. 심볼형</h1>\n<p>심볼형에 관하여는 따로 글을 작성하였다.</p>\n<h1>5. 객체를 원시형으로 변환하기</h1>\n<p>객체에 연산을 가하거나 alert로 출력하는 등의 동작을 하면 자동 형 변환이 일어난다. 객체가 원시값으로 변환되는 것이다. 그럼 이 변환은 어떻게 일어날까?</p>\n<h2>5.1. 원시형으로 변환하는 경우</h2>\n<p>논리형으로 변환하는 경우 객체는 무조건 true로 변환된다.</p>\n<pre><code class=\"language-js\">let emptyObject = {};\nconsole.log(Boolean(emptyObject));\n// true\n</code></pre>\n<p>숫자형으로 변환하는 건 객체끼리 빼는 연산을 하거나 수학 관련 함수를 적용할 때 일어난다.</p>\n<p>예를 들어 Date 객체를 숫자로 변환시 1970년 1월 1일부터 현재 시각까지 경과한 시간을 밀리세컨드 단위로 따진 숫자로 변환되는데, 따라서 Date객체끼리 빼면 두 날짜의 시간 차이가 밀리세컨드 단위로 반환된다.</p>\n<p>문자형으로의 형변환은 alert, String 등의 함수를 적용할 때 일어난다.</p>\n<h2>5.2. ToPrimitive</h2>\n<p>ToPrimitive는 명세서의 추상 연산 중 하나이다. 이때 추상 연산이란 언어에 직접 들어가 있는 연산이 아니라 자바스크립트 엔진이 내부적으로 사용하는 연산이다.</p>\n<p>이 중 하나로 형변환을 자동으로 해주는 메서드 ToPrimitive가 있는 것이다. 이 메서드는 객체를 원시값으로 변환하는데 사용되며 목표로 하는 자료형을 뜻하는 hint에 따라 3가지로 나뉜다.</p>\n<h3>5.2.1. hint가 \"string\"인 경우</h3>\n<p>alert 함수에 인수로 들어가는 경우와 같이 문자열을 기대하는 연산을 수행할 땐 hint가 \"string\"이다.</p>\n<p>객체를 문자열로 변환하게 되면 보통 [object Object]가 반환된다. 이는 객체의 toString 메서드를 호출한 결과이다. 이에 관해서는 다른 글에서 더 자세히 다룬다.</p>\n<h3>5.2.2. hint가 \"number\"인 경우</h3>\n<p>수학 연산을 적용하려 할 때 hint가 \"number\"가 된다. 이때 객체는 먼저 valueOf 메서드를 호출하고, 그 결과가 원시값이 아니라면 toString 메서드를 호출한다.</p>\n<h3>5.2.3. hint가 \"default\"인 경우</h3>\n<p>연산자가 기대하는 자료형이 확실치 않을 때 hint가 \"default\"가 된다. 스터디 자료에서 든 예시는 <code>+</code>인데 피연산자가 문자열일 수도 있고 숫자일 수도 있기 때문이다.</p>\n<p>또한 <code>==</code>를 사용해 비교할 때도 마찬가지다. hint가 default가 된다.</p>\n<p>그러나 대소 비교 연산자 <code>>,&#x3C;</code>의 경우 피연산자에 문자열, 숫자 다 들어갈 수 있지만 hint는 \"number\"가 된다. 이는 명세서에 명시되어 있다.</p>\n<p>하지만 Date 객체를 제외하면 모든 내장 객체가 hint가 default인 경우와 number인 경우를 동일하게 처리하므로 이런 걸 모두 알 필요는 없다.</p>\n<h2>5.3. 객체의 형변환 과정</h2>\n<p>객체의 형변환 알고리즘은 다음과 같다.</p>\n<ol>\n<li>객체에 <code>obj[Symbol.toPrimitive](hint)</code>메서드가 있는지 찾고, 있다면 메서드를 호출합니다.</li>\n<li>hint가 \"string\"이라면 <code>obj.toString()</code>과 <code>obj.valueOf()</code>를 호출합니다.</li>\n<li>hint가 \"number\"나 \"default\"라면 <code>obj.valueOf()</code>와 <code>obj.toString()</code>을 호출합니다.</li>\n</ol>\n<p>여기 나온 것들을 하나하나 살펴보자.</p>\n<h3>5.3.1. Symbol.toPrimitive</h3>\n<p>이는 객체의 내장 심볼 함수인데 이 심볼은 다음과 같이 힌트를 받아서 그에 따른 변환값을 반환하는 함수이다. 또한 인수로 받는 hint는 \"string\", \"number\", \"default\" 중 하나여야 한다.</p>\n<pre><code class=\"language-js\">let user = {\n  name: \"김성현\",\n  age: 25,\n\n  [Symbol.toPrimitive](hint) {\n    console.log(hint);\n    return hint == \"string\" ? `{name: \"${this.name}\"}` : this.age;\n  },\n};\n\nconsole.log(user);\n// number, 25가 찍힘\nconsole.log(Number(user));\n// string, {name: \"김성현\"}이 찍힘\nconsole.log(String(user));\n</code></pre>\n<p>위와 같이 Symbol.toPrimitive를 구현하면 객체를 숫자나 문자열로 변환할 때 Symbol.toPrimitive가 호출된다.</p>\n<h3>5.3.2. toString, valueOf</h3>\n<p>객체에 Symbol.toPrimitive가 없다면 toString과 valueOf를 호출한다. 이 둘은 모두 객체의 메서드이며 각각 원시값을 반환해야 한다.</p>\n<p>만약 hint가 \"string\"이라면 toString이 먼저 호출되고, \"number\"이거나 \"default\"라면 valueOf가 먼저 호출된다. 그리고 보통 valueOf는 객체 자신을 반환하고 toString은 \"[object Object]\"를 반환한다.</p>\n<p>만약 객체에 Symbol.toPrimitive와 valueOf가 없으면, toString이 모든 형 변환을 처리합니다. 그리고 만약 Symbol.toPrimitive, toString, valueOf가 모두 원시값을 반환하지 않는다면 에러가 발생한다.</p>\n<p>그리고 만약 toString이나 valueOf가 원시값을 반환하지 않는다면 그 함수 호출로 인한 결과는 무시된다. 바로 다음 형변환으로 넘어가는 것이다.</p>\n<p>예를 들어 다음 코드의 경우 user의 toString이 객체를 반환하므로 결과가 무시된다. 그 후 valueOf가 호출되어 원시값을 반환하므로 정상적으로 형변환을 진행한다. 로그창을 보면 toString도 호출은 되는 것을 알 수 있다.</p>\n<pre><code class=\"language-js\">let user = {\n  name: \"김성현\",\n  age: 30,\n\n  toString() {\n    console.log(\"toString\");\n    return this;\n  },\n\n  valueOf() {\n    console.log(\"valueOf\");\n    return this.name;\n  },\n};\nconsole.log(String(user));\n</code></pre>\n<p>단 위 형변환 함수들이 항상 hint에 해당하는 자료형으로의 변환을 보장하지는 않는다. 원시값만 반환하면 된다. toString이 정수를 반환한다고 해도 에러가 발생하는 건 아니다.</p>\n<pre><code class=\"language-js\">let user = {\n  name: \"김성현\",\n  age: 25,\n\n  toString() {\n    return this.age;\n  },\n};\n// 둘 다 잘 동작한다.\nconsole.log(+user);\nconsole.log(String(user));\n</code></pre>\n<h3>5.3.3. 추가 형변환</h3>\n<p>만약 객체가 피연산자로 쓰인다면 한번 형변환 된 후 연산자에 맞게 또 형변환될 수도 있다. 만약 toString등으로 변환된 원시값이 연산자에 맞지 않을 때 일어나는 일이다.</p>\n<pre><code class=\"language-js\">let user = {\n  toString() {\n    return \"10\";\n  },\n};\nconsole.log(user * 2);\n</code></pre>\n<p>위 코드는 20이 출력된다. user가 원시값 <code>\"10\"</code>으로 변환된 후 곱셈 연산자에 의해 또 정수로 변환되어 2와 곱해졌기 때문이다.</p>\n<p>반면 다음과 같은 경우 연산이 <code>\"10\"+2</code>가 되어 102가 출력된다.</p>\n<pre><code class=\"language-js\">let user = {\n  toString() {\n    return \"10\";\n  },\n};\nconsole.log(user + 2);\n</code></pre>\n<h1>참고</h1>\n<p>메서드 정의로 선언한 메서드의 차이 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Method_definitions\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Method_definitions</a></p>\n<p>ToPrimitive에 관하여 <a href=\"https://leesoo7595.github.io/javascript/2020/06/05/JavaScript_toPrimitive/\">https://leesoo7595.github.io/javascript/2020/06/05/JavaScript_toPrimitive/</a></p>",
    "excerpt": "1. 메서드와 this\n객체에도 메서드가 존재할 수 있다. 객체 프로퍼티에 값을 할당할 때 함수를 값으로 할당하면 메서드가 된다.\nlet info = {\n  name: \"김성현\",\n  age: 25,\n};\n\ninfo.sayHi = function () {\n  alert(\"안녕하세요\");\n};\n\n위와 같이 객체를 선언한 경우 info.sayHi()로 메서드를 사용할 수 있다.\n1.1 메서드의 단축 구문\n객체 내부에 function 키워드를 사용하여 메서드를 선언하",
    "headingTree": [
      {
        "title": "1. 메서드와 this",
        "url": "#1-메서드와-this",
        "items": [
          {
            "title": "1.1 메서드의 단축 구문",
            "url": "#11-메서드의-단축-구문",
            "items": []
          }
        ]
      },
      {
        "title": "1.2 메서드와 this",
        "url": "#12-메서드와-this",
        "items": []
      },
      {
        "title": "2. new와 생성자",
        "url": "#2-new와-생성자",
        "items": [
          {
            "title": "2.1. new.target",
            "url": "#21-newtarget",
            "items": []
          },
          {
            "title": "2.2. 생성자의 return",
            "url": "#22-생성자의-return",
            "items": []
          }
        ]
      },
      {
        "title": "3. 옵셔널 체이닝",
        "url": "#3-옵셔널-체이닝",
        "items": [
          {
            "title": "3.1. 메서드와 함께 쓰기",
            "url": "#31-메서드와-함께-쓰기",
            "items": []
          },
          {
            "title": "3.2. 대괄호와 함께 쓰기",
            "url": "#32-대괄호와-함께-쓰기",
            "items": []
          }
        ]
      },
      {
        "title": "4. 심볼형",
        "url": "#4-심볼형",
        "items": []
      },
      {
        "title": "5. 객체를 원시형으로 변환하기",
        "url": "#5-객체를-원시형으로-변환하기",
        "items": [
          {
            "title": "5.1. 원시형으로 변환하는 경우",
            "url": "#51-원시형으로-변환하는-경우",
            "items": []
          },
          {
            "title": "5.2. ToPrimitive",
            "url": "#52-toprimitive",
            "items": [
              {
                "title": "5.2.1. hint가 \"string\"인 경우",
                "url": "#521-hint가-string인-경우",
                "items": []
              },
              {
                "title": "5.2.2. hint가 \"number\"인 경우",
                "url": "#522-hint가-number인-경우",
                "items": []
              },
              {
                "title": "5.2.3. hint가 \"default\"인 경우",
                "url": "#523-hint가-default인-경우",
                "items": []
              }
            ]
          },
          {
            "title": "5.3. 객체의 형변환 과정",
            "url": "#53-객체의-형변환-과정",
            "items": [
              {
                "title": "5.3.1. Symbol.toPrimitive",
                "url": "#531-symboltoprimitive",
                "items": []
              },
              {
                "title": "5.3.2. toString, valueOf",
                "url": "#532-tostring-valueof",
                "items": []
              },
              {
                "title": "5.3.3. 추가 형변환",
                "url": "#533-추가-형변환",
                "items": []
              }
            ]
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 2,
      "wordCount": 441
    },
    "url": "/posts/javascript-8",
    "thumbnail": {
      "local": "/thumbnails/javascript-8-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-javascript-8-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAhElEQVR4nGNoa2vz9/f39PT09/dPSkpSVVUNCgoSFRVlKCsrU1ZWTkpK0tXVZefgEBUVNTQ0PHPmDMPSpUvb2tqePn16796962Bw9OjR////M5w4caKtrW39+vUfPnz4Dwa/wYBh4uQpQWCwefNmuChIx8IlKxYvWbJ58+bLly9DJCD6AJFBW4WI5vrBAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "javascript-array-insert-time-complexity",
    "title": "JS 탐구생활 - 배열 삽입 메서드의 시간복잡도",
    "date": "2024-02-22T00:00:00Z",
    "description": "JS 배열의 삽입 메서드는 어떤 시간복잡도를 가질까?",
    "tags": [
      "javascript"
    ],
    "html": "<h1>1. 들어가며</h1>\n<p>Javascript의 배열은 실제 배열이 아니다. 그럼 배열의 삽입 메서드들의 시간복잡도는 어떻게 될까?</p>\n<h2>1.1. 의문</h2>\n<p>일반적인 언어에서 배열은 연속된 메모리 공간에 원소들을 저장하는 자료구조이다. 따라서 C 등의 언어에서 배열은 얼만큼의 연속된 메모리 공간을 사용할 것인지 고정된 크기로 선언하며 일반적으로 배열의 크기를 변경하는 것은 불가능하다.</p>\n<p>예를 들어 C언어에서 크기 10의 배열을 선언하면 이제 배열 크기를 11 혹은 다른 크기로 변경할 수는 없다. 동적 배열이라고 해도 새로운 배열을 할당 후 기존 배열을 복사해야 한다.</p>\n<p>하지만 Javascript의 배열은 실제 배열이 아니다. Javascript의 배열은 객체이며, 배열의 인덱스는 객체의 속성이다. 인덱스가 아니라 다른 속성을 추가하는 것도 가능하며 배열의 크기를 늘리거나 줄이는 것도 가능하다. <code>push</code>, <code>pop</code>, <code>shift</code>, <code>unshift</code>같은 메서드들도 있다.</p>\n<p>물론 다른 언어들에서도 비슷한 자료구조들이 있다. Python의 리스트나 C++의 Vector등이 동적 배열로 구현되어 있다. 하지만 key-value쌍을 갖는 Javascript의 배열과는 묘하게 다르다.</p>\n<p>그럼 Javascript의 배열의 삽입 메서드들의 시간복잡도는 어떻게 될까? C++의 Vector와 같은 동적 배열과 비슷한 시간복잡도를 가질까? 아니면 다른 자료구조를 사용해서 O(1)에 양쪽 삽입이 가능할까?</p>\n<p>따라서 이 글에서는 모든 Javascript 엔진이 따라야 하는 명세와 벤치마크를 기반으로 Javascript 배열의 삽입 메서드들의 시간복잡도를 분석해 보았다.</p>\n<p>이후 Javascript에서 배열의 구현을 구체적으로 다루는 글에서 보겠지만 Javascript의 배열은 대부분의 엔진에서 우리가 아는, 연속된 메모리 공간을 차지하는 그런 배열로 구현되어 있다. 하지만 다른 구현체도 있고 특정 경우에 내부적으로 다른 자료구조로 변환되기도 하므로 이 글에서는 명세를 기반으로 분석해 보았다.</p>\n<h1>2. 명세 탐구</h1>\n<h2>2.1. push</h2>\n<p>배열의 <code>push</code>메서드는 배열의 맨 뒤에 원소를 추가한다. <code>Array.prototype.push(element1, element2, ...)</code>와 같은 형태로 나타나서 인수로 받은 것들을 모두 배열 끝에 추가한다. 그리고 배열의 새 길이를 반환한다.</p>\n<p>ECMA-262의 <code>Array.prototype.push</code> 명세는 다음과 같다.</p>\n<p><img src=\"/static/push-ecma-ca8fe10e.png\" alt=\"push-ecma\"></p>\n<p>에러 체킹 등을 걷어내고 로직만 보면, 모든 인수에 대해서 배열의 끝에 해당 인수를 추가하고 배열 길이를 1 늘리는 동작을 반복하는 것이다. 따라서 시간복잡도는 O(인자 개수)라고 할 수 있고 인자가 상수 개수라면 O(1)이다.</p>\n<h2>2.2. pop</h2>\n<p><code>Array.prototype.pop</code>은 배열의 맨 끝, 그러니까 <code>array.length - 1</code> 인덱스의 원소를 제거하고 제거한 그 원소를 반환한다. ECMA-262에서의 명세는 다음과 같다.</p>\n<p><img src=\"/static/pop-ecma-5292f5ab.png\" alt=\"pop-ecma\"></p>\n<p>배열이 비어 있을 때 <code>undefined</code>를 반환하는 처리가 있긴 하다. 그래도 기본 로직은 배열의 끝 원소를 제거하고 반환하는 것이다. 배열의 다른 원소들에 대해서 어떤 동작을 반복한다든지 하는 건 없다. 따라서 시간복잡도는 O(1)이다.</p>\n<h2>2.3. unshift</h2>\n<p><code>Array.prototype.unshift</code>는 인자로 받은 원소들을 배열의 맨 앞에 추가한다. 그리고 배열의 새 길이를 반환한다. 명세는 다음과 같다.</p>\n<p><img src=\"/static/unshift-ecma-3c4d2b38.png\" alt=\"unshift-ecma\"></p>\n<p>여기서 4.c를 보면 배열에 있던 기존 원소들을 인자 개수인 <code>argCount</code>만큼 뒤로 이동시키는 것을 볼 수 있다. 그리고 인자로 받은 원소들을 배열의 앞(기존 원소들이 이동했으니 이제 비어 있다)에 추가한다.</p>\n<p>이 함수의 시간복잡도는 O(기존의 배열 길이 + unshift 인자 개수)이고, 일반적으로 <code>unshift</code>의 인자 갯수가 기존 배열 길이보다 적으므로 시간복잡도는 O(n)이라고 할 수 있다.</p>\n<h2>2.4. shift</h2>\n<p><code>Array.prototype.shift</code>는 배열의 맨 앞에 있는 원소를 제거한다. 그리고 제거한 원소를 반환한다. 명세는 다음과 같다.</p>\n<p><img src=\"/static/shift-ecma-3df2376e.png\" alt=\"shift-ecma\"></p>\n<p>여기서는 6.을 보면 기존 원소들을 한 칸씩 앞으로 당겨주고 있다. <code>[1, len-1]</code>범위 인덱스의 원소들을 <code>[0, len-2]</code> 인덱스로 한 칸씩 옮겨주는 것이다. 이외에 반복이 적용되는 부분은 없다.</p>\n<p>이를 보면 이 함수의 시간복잡도는 O(기존의 배열 길이)이므로 O(n)이라고 할 수 있을 것이다. 기존 배열의 첫 원소는 이후에 반환해야 하기 때문에 4. 에서 보관해 놓고 9. 에서 반환한다.</p>\n<h1>3. 벤치마크</h1>\n<p><a href=\"https://jsbench.me/\">JS 벤치마크 사이트</a>에서 간단히 벤치마크도 해보았다. 일단 가볍게 1000번 정도씩 돌려 보았다. push/pop이 훨씬 빠르다는 것을 알 수 있었다.</p>\n<p><img src=\"/static/bench1000-c7464488.png\" alt=\"1000\"></p>\n<p>그리고 1만번, 10만번의 벤치마크도 돌려 보았는데 <code>push</code>, <code>pop</code>은 반복 횟수에 따라 걸리는 시간이 선형적으로 증가하는 반면 <code>shift</code>, <code>unshift</code>는 반복 횟수 증가에 따른 경과 시간이 훨씬 더 크게 증가하는 것을 볼 수 있었다. <code>shift</code>, <code>unshift</code>는 실제로도 O(n)에 가까운 시간복잡도를 가지는 것으로 보인다.</p>\n<p>1만번 벤치마크</p>\n<p><img src=\"/static/bench10000-79a16570.png\" alt=\"10000\"></p>\n<p>10만번 벤치마크</p>\n<p><img src=\"/static/bench100000-43fdf303.png\" alt=\"100000\"></p>\n<h1>참고</h1>\n<p><a href=\"https://medium.com/@brayce1996/time-complexity-analysis-of-javascript-array-unshift-74930aaa2f6\">Time Complexity Analysis of Javascript Array unshift </a></p>\n<p><a href=\"https://tc39.es/ecma262/#sec-array.prototype.push\">ECMA-262 push</a></p>\n<p><a href=\"https://tc39.es/ecma262/#sec-array.prototype.pop\">ECMA-262 pop</a></p>\n<p><a href=\"https://tc39.es/ecma262/#sec-array.prototype.unshift\">ECMA-262 unshift</a></p>\n<p><a href=\"https://tc39.es/ecma262/#sec-array.prototype.shift\">ECMA-262 shift</a></p>",
    "excerpt": "1. 들어가며\nJavascript의 배열은 실제 배열이 아니다. 그럼 배열의 삽입 메서드들의 시간복잡도는 어떻게 될까?\n1.1. 의문\n일반적인 언어에서 배열은 연속된 메모리 공간에 원소들을 저장하는 자료구조이다. 따라서 C 등의 언어에서 배열은 얼만큼의 연속된 메모리 공간을 사용할 것인지 고정된 크기로 선언하며 일반적으로 배열의 크기를 변경하는 것은 불가능하다.\n예를 들어 C언어에서 크기 10의 배열을 선언하면 이제 배열 크기를 11 혹은 다른 크기로 변경할 수",
    "headingTree": [
      {
        "title": "1. 들어가며",
        "url": "#1-들어가며",
        "items": [
          {
            "title": "1.1. 의문",
            "url": "#11-의문",
            "items": []
          }
        ]
      },
      {
        "title": "2. 명세 탐구",
        "url": "#2-명세-탐구",
        "items": [
          {
            "title": "2.1. push",
            "url": "#21-push",
            "items": []
          },
          {
            "title": "2.2. pop",
            "url": "#22-pop",
            "items": []
          },
          {
            "title": "2.3. unshift",
            "url": "#23-unshift",
            "items": []
          },
          {
            "title": "2.4. shift",
            "url": "#24-shift",
            "items": []
          }
        ]
      },
      {
        "title": "3. 벤치마크",
        "url": "#3-벤치마크",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 91
    },
    "url": "/posts/javascript-array-insert-time-complexity",
    "thumbnail": {
      "local": "/static/push-ecma-ca8fe10e.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-push-ecma-ca8fe10e-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAFCAIAAAD38zoCAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAfUlEQVR4nGPwDfM1tTXlFuU2sTdPykrOK8vNKcmZu3QuQ/e07oj4SBtXW/8w//C48PK68unzp5++dJqhp7cvIS3Txt4pOirm0KFD3759+w8GDLPnzNbS1Q0Ki4iIji0sKrx9+/afv39AEtOmTYmIjp01e/a+/fvhyv///w8AoMBD6xnMIbcAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "javascript-9",
    "title": "모던 자바스크립트 튜토리얼 part 1.5 자료구조와 자료형 - 1",
    "date": "2023-01-07T00:00:00Z",
    "description": "ko.javascript.info part 1-5 첫번째",
    "tags": [
      "javascript"
    ],
    "html": "<h1>1. 원시값의 메서드</h1>\n<p>원시값은 객체가 아니기 때문에 프로퍼티나 메서드가 있을 수 없다. 하지만 <code>toUpperCase</code>와 같이 원시값에 적용되는 메서드가 분명히 있다. 문자열의 length와 같은 프로퍼티도 있다. 어떻게 된 걸까?</p>\n<h2>1.1. 원시값 래퍼 객체</h2>\n<p>JS의 원시값에 메서드를 사용하기 위해 이런 방식이 사용된다.</p>\n<p>먼저 원시값은 원시값 그대로 형태를 유지한다. 그리고 원시값이 메서드나 프로퍼티에 접근하려고 할 시 추가 기능을 제공하는 특수한 임시 래퍼 객체를 만들어 주고 메서드/프로퍼티 접근을 적용한다. 객체는 그 접근이 끝나면 삭제된다.</p>\n<p>즉 원시값의 메서드나 프로퍼티에 접근하게 되면 원시값은 임시로 객체처럼 작동한다. 따라서 원시값의 프로퍼티 접근도 시도할 수 있다.</p>\n<pre><code class=\"language-js\">a=\"test\";\nconsole.log(a.foo); //undefined\n</code></pre>\n<p>JS 엔진들은 이런 래퍼 객체 최적화에 신경을 쓰기 때문에 이를 사용하는 건 그렇게 많은 자원을 필요로 하지 않는다.</p>\n<h2>1.2. 래퍼 객체 생성자</h2>\n<p>래퍼 객체를 직접 만들 수도 있다. Number, Boolean, String과 같은 문법을 생성자 함수로 사용하면 된다. 그렇게 하면 각 원시값의 래퍼 객체가 생긴다.</p>\n<p>그러나 이를 사용하는 것은 좋지 않다. 원시값으로 취급되어야 하는 값이 객체로 취급되는 건 혼동을 부를 수 있기 때문이다. 예를 들어 <code>new Number(0)</code>으로 값을 생성한다면 0값을 가진 Number 임시 객체가 생성될 것이다.</p>\n<p>그런데 이를 논리 평가에 사용한다면, 객체는 언제나 논리 평가 시 참이기 때문에 <code>Number{0}</code>은 참이 될 것이다. 하지만 숫자 0은 일반적으로 false로 평가되는 게 맞으므로 원치 않는 동작이 생길 수 있다.</p>\n<h1>2. 숫자형</h1>\n<p>JS에서 숫자는 BigInt를 제외하고 IEEE-754 형식으로 저장된다.</p>\n<h2>2.1. 진법 표현</h2>\n<p>일반적으로 JS에서 모든 수는 10진수로 취급된다. <code>1e9</code>와 같이 과학적 표기법도 가능하다.</p>\n<p>그러나 16진수, 8진수, 2진수도 지원하는데 이는 각각 0x, 0o, 0b라는 접두사로 표현 가능하다. 하지만 비교 연산자를 사용할 시 같은 수 판단은 진수에 상관없이 이루어진다. 예를 들어 <code>0b11===3</code>은 true이다.</p>\n<p>만약 다른 진법을 사용해서 정수를 쓰고 싶다면 parseInt를 써야 한다.</p>\n<h2>2.1.1. toString(base)로 진법 다루기</h2>\n<p><code>num.toString(base)</code>는 num을 base진법으로 표현한 후 문자열로 변환해서 반환해 준다. base는 2~36까지 쓸 수 있다.</p>\n<pre><code class=\"language-js\">let a=33;\nconsole.log(a.toString(16)); //21\n</code></pre>\n<h2>2.2. 부정확한 계산</h2>\n<p>JS에서 숫자는 BigInt를 제외하면 내부적으로 IEEE-754 형식으로 표현된다. 정확히 64비트에 저장되는데 이때 52비트가 숫자를 저장하고 11비트는 소수점 위치를, 1비트는 부호를 저장한다.</p>\n<p>그런데 만약 너무 큰 수가 저장되면 64비트 공간이 넘쳐서 Infinity로 처리되기도 한다. 예를 들어 <code>1e500</code>과 같은 수를 출력해 보면 <code>Infinity</code>가 출력된다.</p>\n<p>또한 유명한 예시인 <code>0.1+0.2===0.3</code>이 false인 것도 IEEE754 저장 방식의 문제이다. 0.1, 0.2 와 같은 소수를 2진법의 IEEE754 형식으로 정확하게 표현할 수 없기 때문이다.</p>\n<p>이를 해결하는 방법 중 하나는 toFixed를 사용하는 것이다. 이때 toFixed는 문자열을 반환하므로 숫자형 변환을 위해 단항 연산자 <code>+</code>를 사용한다.</p>\n<pre><code class=\"language-js\">let res=0.1+0.2;\nconsole.log(+res.toFixed(2)); //0.3\n</code></pre>\n<p>비슷한 정밀도 손실 예시로 너무 큰 수를 표현하게 되면 유효숫자가 손실되어 부정확하게 표현되는 것이 있다.</p>\n<p><img src=\"/static/inaccurate-1979c284.PNG\" alt=\"inaccurate\"></p>\n<h2>2.3. 숫자형 관련 메서드 몇개</h2>\n<p><code>Infinity</code>, <code>-Infinity</code>, <code>NaN</code>은 숫자형에 속한다. 그러나 일반적인 숫자는 아니기 때문에 그것인지 확인하는 함수도 존재한다. <code>isNaN</code>과 <code>isFinite</code>이다.</p>\n<p>이때 <code>isNaN</code>이 필요한 이유는 <code>NaN</code>이 다른 모든 값과 같지 않기 때문이다. 심지어 자기 자신과도 같지 않다.</p>\n<pre><code class=\"language-js\">alert(NaN === NaN) //false\n</code></pre>\n<p><code>isFinite</code>는 인수로 받은 숫자가 NaN, Infinity, -Infinity가 아닌 일반적인 숫자일 경우 true를 반환한다.</p>\n<p>또한 불가능할 때까지 문자열에서 숫자를 읽는 parseInt, parseFloat 함수가 존재한다. 문자열을 읽는 도중 숫자가 아닌 게 나오면 그때까지 수집된 숫자를 반환한다.</p>\n<pre><code class=\"language-js\">console.log(parseInt('120px')); //120\nconsole.log(parseFloat('12.5rem')); //12.5\n</code></pre>\n<p><code>parseInt(\"a\")</code>와 같이 읽을 수 있는 숫자가 없을 경우 NaN을 반환한다. 그리고 parseInt의 2번째 인수에 2~36을 넘겨주면 파싱할 때 사용할 진수를 사용할 수 있다.</p>\n<pre><code class=\"language-js\">console.log(parseInt('0xff', 16));\n</code></pre>\n<h2>2.4. Object.is</h2>\n<p><code>Object.is</code>는 값을 비교할 때 사용하는 메서드인데 <code>===</code>과 다른 결과를 반환하는 2가지 케이스가 있다.</p>\n<ol>\n<li><code>NaN===NaN</code>은 false지만 <code>Object.is(NaN, NaN)</code>은 true</li>\n<li><code>0===-0</code>은 true지만 <code>Object.is(0, -0)</code>는 false</li>\n</ol>\n<p>Object.is의 비교방식을 SameValue라고 한다.</p>\n<h2>2.5. 그 외 메서드</h2>\n<h3>2.5.1. Math.random()</h3>\n<p>0~1 사이의 난수를 반환한다. 여기서 반환되는 난수에 1은 제외이다.</p>\n<h3>2.5.2. Math.max, Math.min</h3>\n<p>인수로 받은 수들 중 최댓값, 최솟값을 반환한다. 인수 중 숫자가 아닌 문자열이 있으면 숫자로 반환되고 이게 실패하면 NaN이 반환된다.</p>\n<h3>2.5.3. Math.pow(n, p)</h3>\n<p>n을 p제곱한 값을 반환한다. 이때 실수 제곱도 가능하다.</p>\n<h1>3. 문자열</h1>\n<p>JS는 char형 같은 게 없다. 문자열뿐이다. 그리고 이 문자열은 무조건 UTF16 인코딩을 따른다.</p>\n<p>문자열을 선언하는 방법은 큰따옴표나 작은따옴표를 사용하는 방법이 하나 있다. 그리고 백틱을 사용하여 템플릿 리터럴을 사용하는 방법이 있는데 이는 <a href=\"https://www.witch.work/javascript-template-literal/\">이 글</a>에 정리해 놓았다.</p>\n<p>이때 주의할 점은 문자열은 불변하는 값이라는 것이다. <code>word[0]='a'</code>처럼 변경을 시도하면 에러가 발생한다.</p>\n<h2>3.1. 유니코드 표현</h2>\n<p><code>\\</code>를 사용하여 이스케이프 문자를 표현할 수 있다는 건 유명하다. 그런데 자바스크립트에선 이를 이용해 유니코드 기호도 표현할 수 있다.</p>\n<p><code>\\uXXXX</code>의 XXXX위치에 UTF-16 인코딩의 16진수 코드를 넣으면 된다. UTF-32 의 긴 유니코드를 사용하고 싶다면 <code>\\u{XX..XX}</code>를 사용하면 된다.</p>\n<pre><code class=\"language-js\">console.log(\"\\u00A9\");\nconsole.log(\"\\u{1F60D}\");\n</code></pre>\n<h2>3.2. 프로퍼티와 메서드</h2>\n<p>문자열은 원시값이지만 앞에서 살펴봤다시피 임시 래퍼 객체를 통해 프로퍼티와 메서드 접근이 가능하다.</p>\n<h3>3.2.1. length</h3>\n<p>length 프로퍼티는 문자열의 길이를 저장한다. <code>str.length</code>처럼 사용 가능하다.</p>\n<h3>3.2.2. charAt</h3>\n<p>문자열 내 특정 인덱스의 글자에 접근하려면 대괄호 인덱싱을 이용할 수 있지만 <code>charAt</code>메서드를 사용할 수도 있다. 두 방법의 차이는, 접근하려는 위치에 글자가 없을 경우 대괄호 방식은 undefined를 반환하지만 charAt은 빈 문자열을 반환한다는 것이다.</p>\n<pre><code class=\"language-js\">let word=\"witch\";\nconsole.log(word[10]); //undefined\nconsole.log(word.charAt(10)); //빈 문자열\n</code></pre>\n<h3>3.2.3. 문자열 순회</h3>\n<p><code>for..of</code>를 이용해서 문자열을 구성하는 글자를 한 글자씩 순회하며 작업할 수 있다.</p>\n<pre><code class=\"language-js\">for(let ch of word){\n    console.log(ch);\n}\n</code></pre>\n<h3>3.2.4. 대문자, 소문자 변경</h3>\n<p><code>toUpperCase</code>는 문자열의 모든 알파벳을 대문자로 바꾼 문자열을 리턴해 주고 <code>toLowerCase</code>는 모든 알파벳을 소문자로 바꾼 문자열을 리턴한다.</p>\n<h3>3.2.5. 부분 문자열 찾기</h3>\n<p><code>indexOf</code>메서드를 사용하면 부분 문자열을 찾을 수 있다. <code>word.indexOf(substr, pos)</code>는 word 문자열에서 substr을 찾아서 그 시작 위치(인덱스)를 반환한다. 만약 찾지 못하면 -1을 반환한다.</p>\n<p>이때 두번째 인수 pos는 선택적 인수인데 만약 두번째 인수를 전달하지 않으면 주어진 문자열의 첫 인덱스부터 탐색을 시작한다. pos인수를 넘겨주면 해당 pos 인덱스부터 탐색이 시작된다.</p>\n<p>같은 기능이지만 문자열 끝에서부터 substr을 찾는 메서드로 <code>lastIndexOf</code>가 있다.</p>\n<p>단 주의할 점은, 문자열을 찾았는지 판단할 때 0과 비교하면 안 된다는 점이다. indexOf가 탐색에 성공해서 반환한 값이 0일 수 있기 때문이다.</p>\n<pre><code class=\"language-js\">let word=\"witch\";\n// w를 찾았지만 반환값이 0이므로 아무것도 출력되지 않음\nif(word.indexOf('w')){\n    console.log(\"w is found\");\n}\n</code></pre>\n<p>이런 경우 indexOf 리턴값을 -1과 비교해야 한다. 다음 코드는 정상적으로 작동한다.</p>\n<pre><code class=\"language-js\">let word=\"witch\";\n\nif(word.indexOf('w')!==-1){\n    console.log(\"w is found\");\n}\n</code></pre>\n<p>부분 문자열의 포함 여부를 알아내는 메서드로 <code>str.includes(substr, pos)</code>가 있다. substr의 존재여부에 따라 true, false를 반환한다. 2번째 인수 pos의 용도도 indexOf에서와 같다.</p>\n<p>또한 startsWith, endsWith로 문자열이 특정 문자열로 시작하거나 끝나는지를 판단할 수도 있다.</p>\n<h3>3.2.6. 부분 문자열 추출</h3>\n<p>문자열의 일부를 추출하는 메서드는 3가지가 있다.</p>\n<p>str.slice는 파이썬의 slicing과 같이 start~end인덱스의(end는 미포함) 문자열을 반환한다. 만약 2번째 end 인수가 생략되면 start부터 끝까지를 반환한다.</p>\n<p>또한 음수 인수를 넘길 수도 있는데 이 경우 문자열 끝에서부터 인덱스 카운팅을 시작한다. 즉 맨 마지막 문자가 -1인덱스가 되는 것이다.</p>\n<pre><code class=\"language-js\">let word=\"witch_work\";\n\nconsole.log(word.slice(1,5)); //itch\nconsole.log(word.slice(5)); //_work\nconsole.log(word.slice(3,-4)); //ch_\nconsole.log(word.slice(4,3)); // 빈 문자열\n</code></pre>\n<p>slice는 만약 start가 end와 같거나 더 크면 빈 문자열을 반환한다.</p>\n<p>substring은 slice와 같은 기능을 하는 메서드지만 음수 인수를 허용하지 않는다. 음수 인수를 넣을 경우 0으로 처리된다. 그리고 start가 end보다 커도 s~e 사이의 문자열을 잘 추출한다.</p>\n<pre><code class=\"language-js\">let word=\"witch_work\";\n// witc 가 출력된다.\n// 음수 인수가 0으로 처리되어 substring(4,0)이 되고 따라서 0~4 사이의 문자열이 추출되기 때문\nconsole.log(word.substring(4,-1));\n</code></pre>\n<p>이렇게 인덱스를 이용하는 것 대신 길이를 이용하는 방식도 있다. <code>str.substr(start, length)</code>는 start인덱스부터 시작해 length개의 문자열을 추출한다. 단 이 substr은 브라우저 전용 기능이므로 브라우저 외 환경에서는 제대로 동작하지 않을 수 있다.</p>\n<p>그리고 slice가 음수 인수가 허용되어 좀더 유연하므로 slice를 쓰는 게 substring보다 일반적으로 더 좋은 선택이다.</p>\n<h2>3.3. 문자열 비교</h2>\n<p>JS에서 문자열은 모두 UTF-16으로 인코딩되고 따라서 모든 글자가 숫자 형식 코드와 매칭된다. 이 코드는 str의 특정 인덱스에 위치한 문자의 코드를 알아내는 메서드 <code>str.codePointAt(index)</code>로 알아낼 수 있다. 반대로 <code>String.fromCodePoint(code)</code>로 특정 숫자코드에 대응하는 글자를 만들어 줄 수도 있다.</p>\n<p>아무튼 JS는 문자열을 비교할 때 이 숫자 코드를 이용해서 비교한다. 각 문자열의 첫 인덱스부터 한 글자씩 비교해 가면서 숫자 코드가 더 큰 문자가 나온 문자열이 더 크다고 판단하는 것이다.</p>\n<p>따라서 단순히 문자열에 비교 연산자를 쓰면 소문자가 대문자보다 무조건 크게 나오는 등의 문제가 있다. 제대로 비교하기 위해서는 국제화 관련 표준인 ECMA-402를 통해 문자열을 비교하는 <code>str.localeCompare(str2)</code>를 써야 한다.</p>\n<p>str이 str2보다 작으면 음수, 같으면 0, str이 str2보다 크면 양수를 반환한다.</p>\n<pre><code class=\"language-js\">console.log(\"ABC\".localeCompare(\"abb\")); //1\nconsole.log(\"ABC\">\"abb\"); //false\n</code></pre>\n<p>위의 결과를 보면 단순 비교를 했을 경우 대문자가 숫자코드가 작으므로 더 작다고 판단되었지만 localeCompare에서는 ABC가 abb보다 더 크다는, 일반적인 알파벳에 기반한 비교를 잘 해준 것을 볼 수 있다.</p>\n<h1>4. 배열</h1>\n<h2>4.1. 배열 생성</h2>\n<p>배열은 대괄호를 쓰거나 생성자를 사용해 만든다.</p>\n<pre><code class=\"language-js\">let arr = new Array();\nlet arr2 = [];\n</code></pre>\n<h2>4.2. 배열 순회</h2>\n<p>배열을 순회할 때는 for문을 쓰는 게 일반적이다. 이때 3가지 선택지가 있다. 인덱스를 사용해 순회하는 건 가장 기본적인 방법이다.</p>\n<pre><code class=\"language-js\">let members = [\"고주형\", \"전민지\", \"장소원\"];\n\nfor (let i=0;i&#x3C;members.length;i++) {\n  console.log(members[i]);\n}\n</code></pre>\n<p>for-of문을 쓰는 방법도 있다. 이 방법은 배열의 요소를 순회하면서 요소를 변수에 할당해주는 방식이다. 배열의 인덱스 말고 값만이 필요할 때 사용하면 좋다.</p>\n<pre><code class=\"language-js\">let members = [\"고주형\", \"전민지\", \"장소원\"];\n\nfor (let member of members) {\n  console.log(member);\n}\n</code></pre>\n<p>for-in문을 사용할 수도 있다. 그러나 for-in문은 객체를 순회할 때 사용하는 것이 일반적이며 키가 숫자가 아닌 프로퍼티와 메서드를 가지는 유사 배열 객체의 경우 원치 않는 프로퍼티까지 순회하는 결과가 나올 수 있다.</p>\n<pre><code class=\"language-js\">let members = [\"고주형\", \"전민지\", \"장소원\"];\nmembers.foo = \"김성현\";\n// members의 foo도 순회에 포함된다\nfor (let name in members) {\n  console.log(members[name]);\n}\n// members의 foo는 순회에 포함되지 않는다\nfor (let name of members) {\n  console.log(name);\n}\n</code></pre>\n<p>게다가 for-in은 객체에 사용하는 것에 최적화되어 있어 배열에 for-of를 쓰는 것보다는 느리다.</p>\n<h2>4.3. length</h2>\n<p>배열의 length는 배열 내의 실제 요소 개수를 세는 게 아니라 배열 내의 가장 큰 인덱스에 1을 더한 값이다.</p>\n<pre><code class=\"language-js\">let test = [];\ntest[1000] = 1;\nconsole.log(test.length); \n// 배열에 요소는 실제로는 하나뿐인데 length는 1001\n</code></pre>\n<p>또한 배열 length에는 쓰기도 가능하다. 이때 length가 줄어들면 배열의 뒤쪽 요소가 삭제된다. 기존 length보다 더 큰 length를 지정하면 배열 뒤쪽엔 빈 공간이 채워진다.</p>\n<pre><code class=\"language-js\">let test = [1, 2, 3];\n// [1, 2, 3] 3\nconsole.log(test, test.length);\ntest.length = 5;\n// [1, 2, 3, empty × 2] 5\nconsole.log(test, test.length);\ntest.length = 2;\n// [1, 2] 2. 배열이 잘렸다!\nconsole.log(test, test.length);\n</code></pre>\n<h2>4.4. 배열 메서드</h2>\n<p>잘 모르고 있던 메서드만 적는다.</p>\n<h3>4.4.1. splice</h3>\n<p>splice는 배열의 요소를 삭제하거나 추가할 때 사용한다. 첫 번째 인수는 시작 인덱스, 두 번째 인수는 삭제할 요소 개수, 세 번째 인수부터는 추가할 요소를 나열한다.</p>\n<pre><code class=\"language-js\">arr.splice(index[, deleteCount, elem1, ..., elemN])\n</code></pre>\n<p>이때 추가할 요소는 index번째(0-base) 원소의 앞에 추가된다. 즉, index번째 원소는 뒤로 밀려난다. <code>arr.splice(0, 0, 1)</code> 과 같은 경우 배열의 첫 번째에 삽입되어야 하는 것을 생각하면 당연하다.</p>\n<p>여기에는 음수 인덱스도 사용할 수 있다.</p>\n<h3>4.4.2. forEach</h3>\n<p>forEach는 배열의 요소를 순회하면서 각 요소에 대해 함수를 실행한다. forEach는 반환값이 없다.(정확히는 undefined를 반환한다.)</p>\n<pre><code class=\"language-js\">let arr = [1, 2, 3, 4, 5];\n\narr.forEach((item, index) => {\n  console.log(item, index);\n});\n</code></pre>\n<h3>4.4.3. indexOf, lastIndexOf, includes</h3>\n<p>문자열의 같은 메서드와 같은 기능을 한다.</p>\n<pre><code class=\"language-js\">arr.indexOf(item, from) // from부터 item을 찾는다. 못 찾으면 -1\narr.lastIndexOf(item, from) // from부터 item을 뒤에서부터 찾는다. 못 찾으면 -1\narr.includes(item, from) // from부터 item이 있는지 검색. 못 찾으면 false\n</code></pre>\n<h3>4.4.4. find, findIndex</h3>\n<p>find는 배열의 요소를 순회하면서 조건에 맞는 첫 번째 요소를 반환한다. findIndex는 조건에 맞는 첫 번째 요소의 인덱스를 반환한다.</p>\n<p>만약 조건에 맞는 요소가 없으면 find는 undefined, findIndex는 -1을 반환한다.</p>\n<h3>4.4.5. map</h3>\n<p>map은 배열의 요소를 순회하면서 각 요소에 대해 함수를 실행한 결과를 모아 새로운 배열을 만들어서 리턴해 준다.</p>\n<pre><code class=\"language-js\">let arr = [1, 2, 3, 4, 5];\n\nlet res = arr.map((item) => item + 10);\n// 11,12,13,14,15\nconsole.log(res);\n</code></pre>\n<h3>4.4.6. reduce, reduceRight</h3>\n<p>reduce는 배열의 전체 원소들을 기반으로 값을 하나 도출할 때 사용한다. 다음과 같은 형태로 사용된다.</p>\n<pre><code class=\"language-js\">arr.reduce(function(accumulator, item, index, array) {\n  // ...\n}, [initial]);\n</code></pre>\n<p>reduce는 배열의 첫 번째 원소부터 마지막 원소까지 순회하면서 accumulator에 값을 누적시킨다. accumulator는 초기값으로 initial을 사용할 수도 있고, 사용하지 않을 경우 배열의 첫 번째 원소를 사용한다.</p>\n<p>reduce에 쓰이는 함수의 인수들은 다음과 같은 의미가 있다. accumulator는 이전 함수 호출의 결과인 누적 값, item은 현재 배열의 원소, index는 현재 배열의 인덱스, array는 배열 자체를 의미한다.</p>\n<p>예를 들어 reduce를 이용해 배열 요소 전체의 합을 구할 수 있다.</p>\n<pre><code class=\"language-js\">let arr = [1, 2, 3, 4, 5];\n// initial누적값을 정하지 않았으므로 배열의 첫 번째 원소 1이 첫 누적값으로 사용된다\nlet res = arr.reduce((s, current) => s + current);\n// 15\nconsole.log(res);\n</code></pre>\n<p>단 이렇게 초기값을 명시하지 않을 경우, 만약 배열이 비어 있다면 문제가 생긴다. 첫번째 원소가 없기 때문이다. 따라서 초기값을 명시해 주는 것이 안전하다. 다음과 같이 말이다.</p>\n<pre><code class=\"language-js\">let res = arr.reduce((s, current) => s + current, 0);\n</code></pre>\n<p>reduceRight는 reduce와 동일한 기능을 하지만, 배열의 끝에서부터 시작한다.</p>\n<h3>4.4.7. isArray</h3>\n<p>해당 원소가 배열이면 true, 아니면 false를 반환한다.</p>\n<h3>4.4.8. thisArg</h3>\n<p>배열 메서드들은 모두 thisArg라는 인수를 받을 수 있다. thisArg는 메서드 내부에서 this로 사용할 객체를 지정한다. thisArg를 사용하지 않으면 함수 내부에서 this는 undefined가 된다(브라우저 환경에선 전역 윈도우 객체).</p>\n<pre><code class=\"language-js\">let numberFilter = {\n  min: 18,\n  max: 99,\n  filter(value) {\n    if (value &#x3C; this.min || value > this.max) {\n      return false;\n    }\n    return true;\n  },\n};\n\nlet ages = [12, 18, 20, 1, 100, 90, 14];\n\n// numberFilter.filter의 this로 numberFilter 객체를 사용한다고 지정\nlet filtered = ages.filter(numberFilter.filter, numberFilter);\nconsole.log(filtered);\n</code></pre>\n<h1>5. 이터러블</h1>\n<p>객체를 이터러블로 만들면 어떤 객체든 for..of로 순회할 수 있다. 객체에 for..of가 호출되면 다음과 같은 일이 일어나기 때문이다.</p>\n<ol>\n<li>객체의 Symbol.iterator 메서드를 호출한다. 이때 Symbol.iterator는 next 메서드를 갖는 이터레이터 객체를 반환해야 한다.</li>\n<li>for..of는 다음 값이 필요할 때마다 이터레이터 객체의 next 메서드를 호출한다. 이때 next 메서드는 value와 done 프로퍼티를 갖는 객체를 반환해야 한다.</li>\n<li>next 메서드가 반환하는 객체의 done 프로퍼티가 true가 될 때까지 for..of는 반복한다.</li>\n</ol>\n<p>객체의 Symbol.iterator의 구조는 다음과 같이 이루어진다.</p>\n<pre><code class=\"language-js\">객체[Symbol.iterator] = function(){\n  return {\n    // next 메서드가 구현되어 있는 객체\n    next(){\n      if(순회할 값이 더 있으면){\n        return {done: false, value: 순회할 다음 값}\n      } else {\n        return {done: true}\n      }\n    }\n  }\n}\n</code></pre>\n<p>혹은 next 메서드를 아예 객체 자체에 구현해 놓은 다음 Symbol.iterator에서는 객체 자신을 반환해 주도록 하는 것도 가능하다.</p>\n<pre><code class=\"language-js\">let obj={\n  [Symbol.iterator]: function(){\n    // for..of가 시작돨 때의 초기 조건 설정\n    return this;\n  },\n  next(){\n    if(순회할 값이 더 있으면){\n      return {done: false, value: 순회할 다음 값}\n    } else {\n      return {done: true}\n    }\n  }\n}\n</code></pre>\n<p>단 위와 같은 방식의 단점은 2개의 for..of 반복문을 동시에 쓸 수 없다는 점이다. 이터레이터가 객체 자신 그 하나뿐이므로 반복의 진행 상태를 공유하기 때문이다.</p>\n<p>이터러블을 만들면 관심사의 분리가 가능해진다. next메서드는 이터레이터 객체에 맡기고 반복하는 객체는 반복의 메커니즘에는 신경쓸 필요가 없어진다.</p>\n<h2>5.1. 이터러블 직접 호출</h2>\n<p>이터레이터를 직접 호출하는 것도 가능하다. 단 잘 쓰이는 것은 아니다.</p>\n<pre><code class=\"language-js\">let it=obj[Symbol.iterator]();\n\nwhile(1){\n  let result=it.next();\n  if(result.done) break;\n  console.log(result.value);\n}\n</code></pre>\n<h2>5.2. 이터러블과 배열</h2>\n<p>이터러블은 <code>Symbol.iterator</code> 메서드를 가져서 반복 가능한 객체이다. 유사 배열 객체와는 다르다. 유사 배열 객체는 인덱스와 length 프로퍼티를 가지고 있는 객체이다.</p>\n<p>인덱스와 length가 있지만 Symbol.iterator가 없는 유사 배열 객체도 있다.</p>\n<pre><code class=\"language-js\">// 인덱스, length 프로퍼티가 있지만 Symbol.iterator가 없어서 이터러블은 아닌 유사 배열 객체\nlet arrayLike={\n  0: 'hello',\n  1: 'world',\n  length: 2\n}\n</code></pre>\n<h2>5.3. Array.from</h2>\n<p>Array.from 메서드는 이터러블이나 유사 배열을 진짜 배열로 바꿔서 반환해 준다. 이러면 배열 메서드도 쓸 수 있게 된다.</p>\n<pre><code class=\"language-js\">let arr = {\n  0: \"witch\",\n  1: \"work\",\n  length: 2,\n};\n\nlet arr2 = Array.from(arr);\narr2.pop();\nconsole.log(arr2); // ['witch']\n</code></pre>\n<p>Array.from은 넘겨받은 객체가 이터러블이나 유사 배열이면 이를 배열로 변환해 준다. 그리고 이 함수는 선택적인 인수가 있다.</p>\n<pre><code class=\"language-js\">Array.from(obj, [mapFn, thisArg])\n</code></pre>\n<p>mapFn 함수를 지정하면 변환한 배열을 추가하기 전에 각 요소에 mapFn을 적용한다. 그리고 thisArg를 지정하면 mapFn을 호출할 때 this로 사용할 객체를 지정할 수 있다.</p>",
    "excerpt": "1. 원시값의 메서드\n원시값은 객체가 아니기 때문에 프로퍼티나 메서드가 있을 수 없다. 하지만 toUpperCase와 같이 원시값에 적용되는 메서드가 분명히 있다. 문자열의 length와 같은 프로퍼티도 있다. 어떻게 된 걸까?\n1.1. 원시값 래퍼 객체\nJS의 원시값에 메서드를 사용하기 위해 이런 방식이 사용된다.\n먼저 원시값은 원시값 그대로 형태를 유지한다. 그리고 원시값이 메서드나 프로퍼티에 접근하려고 할 시 추가 기능을 제공하는 특수한 임시 래퍼 객체를 ",
    "headingTree": [
      {
        "title": "1. 원시값의 메서드",
        "url": "#1-원시값의-메서드",
        "items": [
          {
            "title": "1.1. 원시값 래퍼 객체",
            "url": "#11-원시값-래퍼-객체",
            "items": []
          },
          {
            "title": "1.2. 래퍼 객체 생성자",
            "url": "#12-래퍼-객체-생성자",
            "items": []
          }
        ]
      },
      {
        "title": "2. 숫자형",
        "url": "#2-숫자형",
        "items": [
          {
            "title": "2.1. 진법 표현",
            "url": "#21-진법-표현",
            "items": []
          },
          {
            "title": "2.1.1. toString(base)로 진법 다루기",
            "url": "#211-tostringbase로-진법-다루기",
            "items": []
          },
          {
            "title": "2.2. 부정확한 계산",
            "url": "#22-부정확한-계산",
            "items": []
          },
          {
            "title": "2.3. 숫자형 관련 메서드 몇개",
            "url": "#23-숫자형-관련-메서드-몇개",
            "items": []
          },
          {
            "title": "2.4. Object.is",
            "url": "#24-objectis",
            "items": []
          },
          {
            "title": "2.5. 그 외 메서드",
            "url": "#25-그-외-메서드",
            "items": [
              {
                "title": "2.5.1. Math.random()",
                "url": "#251-mathrandom",
                "items": []
              },
              {
                "title": "2.5.2. Math.max, Math.min",
                "url": "#252-mathmax-mathmin",
                "items": []
              },
              {
                "title": "2.5.3. Math.pow(n, p)",
                "url": "#253-mathpown-p",
                "items": []
              }
            ]
          }
        ]
      },
      {
        "title": "3. 문자열",
        "url": "#3-문자열",
        "items": [
          {
            "title": "3.1. 유니코드 표현",
            "url": "#31-유니코드-표현",
            "items": []
          },
          {
            "title": "3.2. 프로퍼티와 메서드",
            "url": "#32-프로퍼티와-메서드",
            "items": [
              {
                "title": "3.2.1. length",
                "url": "#321-length",
                "items": []
              },
              {
                "title": "3.2.2. charAt",
                "url": "#322-charat",
                "items": []
              },
              {
                "title": "3.2.3. 문자열 순회",
                "url": "#323-문자열-순회",
                "items": []
              },
              {
                "title": "3.2.4. 대문자, 소문자 변경",
                "url": "#324-대문자-소문자-변경",
                "items": []
              },
              {
                "title": "3.2.5. 부분 문자열 찾기",
                "url": "#325-부분-문자열-찾기",
                "items": []
              },
              {
                "title": "3.2.6. 부분 문자열 추출",
                "url": "#326-부분-문자열-추출",
                "items": []
              }
            ]
          },
          {
            "title": "3.3. 문자열 비교",
            "url": "#33-문자열-비교",
            "items": []
          }
        ]
      },
      {
        "title": "4. 배열",
        "url": "#4-배열",
        "items": [
          {
            "title": "4.1. 배열 생성",
            "url": "#41-배열-생성",
            "items": []
          },
          {
            "title": "4.2. 배열 순회",
            "url": "#42-배열-순회",
            "items": []
          },
          {
            "title": "4.3. length",
            "url": "#43-length",
            "items": []
          },
          {
            "title": "4.4. 배열 메서드",
            "url": "#44-배열-메서드",
            "items": [
              {
                "title": "4.4.1. splice",
                "url": "#441-splice",
                "items": []
              },
              {
                "title": "4.4.2. forEach",
                "url": "#442-foreach",
                "items": []
              },
              {
                "title": "4.4.3. indexOf, lastIndexOf, includes",
                "url": "#443-indexof-lastindexof-includes",
                "items": []
              },
              {
                "title": "4.4.4. find, findIndex",
                "url": "#444-find-findindex",
                "items": []
              },
              {
                "title": "4.4.5. map",
                "url": "#445-map",
                "items": []
              },
              {
                "title": "4.4.6. reduce, reduceRight",
                "url": "#446-reduce-reduceright",
                "items": []
              },
              {
                "title": "4.4.7. isArray",
                "url": "#447-isarray",
                "items": []
              },
              {
                "title": "4.4.8. thisArg",
                "url": "#448-thisarg",
                "items": []
              }
            ]
          }
        ]
      },
      {
        "title": "5. 이터러블",
        "url": "#5-이터러블",
        "items": [
          {
            "title": "5.1. 이터러블 직접 호출",
            "url": "#51-이터러블-직접-호출",
            "items": []
          },
          {
            "title": "5.2. 이터러블과 배열",
            "url": "#52-이터러블과-배열",
            "items": []
          },
          {
            "title": "5.3. Array.from",
            "url": "#53-arrayfrom",
            "items": []
          }
        ]
      }
    ],
    "metadata": {
      "readingTime": 3,
      "wordCount": 704
    },
    "url": "/posts/javascript-9",
    "thumbnail": {
      "local": "/static/inaccurate-1979c284.PNG",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-inaccurate-1979c284-PNG",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAADCAIAAAAhqtkfAAAACXBIWXMAAAsTAAALEwEAmpwYAAAASElEQVR4nGPYtnmLt5s3H7e0iJCynIyOII98Y33Xv39/GQ4dOnTy1ImnTx//+/f3PxJg2LB+k5SUirKyjpSUipCg9IULFyESAK14KrPSU+u0AAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "javascript-array-deep-dive",
    "title": "JS 탐구생활 - JS 배열은 어떻게 저장될까?",
    "date": "2024-02-28T00:00:00Z",
    "description": "js의 배열에 대하여..",
    "tags": [
      "javascript"
    ],
    "html": "<h1>1. Javascript 배열은 배열이 아니다</h1>\n<p>일반적으로 자료구조 시간에 배우는 배열이란 연속된 메모리 공간에 같은 타입의 데이터를 저장하는 자료구조이다. 하지만 Javascript의 배열은 그렇지 않다. <code>push</code>, <code>pop</code>등 배열의 크기를 늘리거나 줄이는 메서드도 있고, 서로 다른 타입의 데이터를 저장할 수도 있다.</p>\n<pre><code class=\"language-js\">a = [1, 2, 3];\n// 배열의 크기를 늘리는 메서드\n// 또한 배열에 서로 다른 타입의 데이터를 저장한다\na.push(\"me\");\n</code></pre>\n<p>이는 실제로 Javascript의 배열은 배열이 아니라 특수한 <code>length</code> 프로퍼티와 음이 아닌 정수를 key로 갖는 객체이기 때문이다. 따라서 이 글에서는 Javascript의 배열이 어떤 형식을 갖는지, 그리고 그것을 Javascript 엔진에서는 구체적으로 어떻게 구현하고 있는지 알아보고자 한다.</p>\n<h1>2. Javascript 배열의 구조</h1>\n<p>Javascript의 <code>Object.getOwnPropertyDescriptors</code>를 사용하여 배열의 구조를 살펴볼 수 있다.</p>\n<pre><code class=\"language-js\">console.log(Object.getOwnPropertyDescriptors([1, 2, 3]));\n</code></pre>\n<p>크롬 개발자 도구에서 위 코드를 실행시켜 보면 다음과 같은 출력이 나온다. 배열의 각 인덱스에 대해서 value, writable, enumerable, configurable 프로퍼티를 갖는 객체가 있다. 그리고 length 프로퍼티도 있다.</p>\n<pre><code class=\"language-js\">{\n  0: {value: 1, writable: true, enumerable: true, configurable: true},\n  1: {value: 2, writable: true, enumerable: true, configurable: true},\n  2: {value: 3, writable: true, enumerable: true, configurable: true},\n  length: {value: 3, writable: true, enumerable: false, configurable: false}\n}\n</code></pre>\n<p>Javascript 배열은 이런 객체의 형태를 띤다. 그래서 Javascript에서는 C같은 언어에선 상상도 할 수 없는, 서로 다른 타입으로 구성된 배열도 만들 수 있는 것이다. 그냥 value에 다른 값을 대응시켜 주기만 하면 되기 때문이다.</p>\n<p>하지만 배열이 Javascript 객체와 같이 해시 테이블로 구현되어 있다면(Javascript 객체가 무조건 해시 테이블로 구현되는 건 아니지만 일반적으로)인덱스를 통한 접근이 일반적인 배열에 비해 느릴 수밖에 없다.</p>\n<p>따라서 현대적인 자바스크립트 엔진들은 배열을 일반 객체와 구별하여 보다 배열처럼 동작하도록 최적화하여 구현한다. 다음 장에서는 이러한 최적화에 대하여 알아볼 것이다.</p>\n<p>잘 관찰해 보면 <code>length</code> 프로퍼티는 반복 불가능(<code>enumerable: false</code>)하고 속성 제거, 설명자 플래그 변경이 불가능(<code>configurable: false</code>)하다. <code>length</code>의 특성을 생각해 보면 그럴 수밖에 없다.</p>\n<p><code>length</code> 이외의 다른 프로퍼티들은 <code>writable</code>, <code>enumerable</code>, <code>configurable</code>이 모두 <code>true</code>로 되어 있다. 이는 배열의 원소들을 변경하거나 추가하거나 제거하는 것이 기본적으로 늘 가능하다는 것을 의미한다.</p>\n<p>따라서 다른 객체를 저장할 때와 달리 배열에서는 정말 숫자 인덱스와 <code>length</code> 프로퍼티만을 신경쓰면 된다. 그리고 <code>length</code> 프로퍼티를 변경하면 배열의 크기가 변경된다.</p>\n<h1>4. JS 배열, 더 깊이</h1>\n<p>그런데 배열 메서드의 시간복잡도에 대한 검색을 하다가 <a href=\"https://stackoverflow.com/questions/11514308/big-o-of-javascript-arrays\">스택오버플로우의 한 질문글</a>에서, 현대 JS엔진들은 배열이 sparse하지 않은 한 배열을 해시테이블(즉 객체)로 관리하지 않는다는 말을 보았다. 우리가 위에서 <code>getOwnPropertyDescriptors</code>을 사용해서 본 것과는 좀 다른 이야기다. 배열을 객체로 관리하지 않는다고?</p>\n<p>물론 <a href=\"https://shanepark.tistory.com/220\">객체 말고 Map을 사용하라는 말</a>도 있지만 이는 다른 이야기고..</p>\n<pre><code>내가 본 댓글 전문\nWorth mentioning this answer is no longer correct. Modern engines do not store Arrays (or objects with indexed integer keys) as hashtables (but like well... arrays like in C) unless they're sparse. To get you started here is a 'classical' benchmark illustrating this –\nBenjamin Gruenbaum\n</code></pre>\n<p>그럼 대체 어떻게 배열을 관리한다는 것인가! 열심히 검색해 보니 <a href=\"https://itnext.io/v8-deep-dives-understanding-array-internals-5b17d7a28ecc\">Understanding Array Internals</a>라는 보석같은 글이 있었다. V8에서 배열을 어떻게 구현한지를 다룬 글이었다. 이 글을 간단히 이해한 대로 정리해 본다.</p>\n<h2>4.1. 시작</h2>\n<p>JS 배열 말고, 학교 수업 시간에 배울 법한 배열 자료구조는 연속된 메모리 덩어리와 같다. 배열의 시작 주소부터 배열의 크기만큼의 메모리를 가지는 자료구조이다. 그러나 JS배열은 위에서 대강 살펴보았다시피 그것과는 조금 다르다. push, pop과 같은 메서드부터 이상하다.</p>\n<p>물론 C++이나 JAVA의 Vector처럼 원소의 삽입/삭제가 가능한 동적 배열도 있다. 그러나 그것들은 내부적으로 보면 결국 배열의 크기를 정해 놓고 크기 상한에 도달하면 새로운 배열을 동적 할당하는 방식이다. 하지만 JS 배열은 그런 식으로 동작하지 않는다.</p>\n<p>따라서 V8에서 제공하는 <code>%DebugPrint</code> 함수를 이용하여 내부를 들여다보자. 먼저 node REPL을 켠다. 엔진의 고유 함수를 실행 가능하도록 하기 위해 <code>--allow-natives-syntax</code> 옵션을 사용하자.</p>\n<p><img src=\"/static/nodeREPL-08aab937.png\" alt=\"repl\"></p>\n<h2>4.2. 빈 배열</h2>\n<p><code>%DebugPrint</code> 함수를 이용하여 빈 배열의 정보를 출력해 보자.</p>\n<pre><code class=\"language-bash\">const arr=[];\nundefined\n> %DebugPrint(arr);\nDebugPrint: 0x1458667c9379: [JSArray]\n - map: 0x2699696c3c39 &#x3C;Map(PACKED_SMI_ELEMENTS)> [FastProperties]\n - prototype: 0x266f4d105d79 &#x3C;JSArray[0]>\n - elements: 0x3f94f0541329 &#x3C;FixedArray[0]> [PACKED_SMI_ELEMENTS]\n - length: 0\n - properties: 0x3f94f0541329 &#x3C;FixedArray[0]>\n - All own properties (excluding elements): {\n    0x3f94f05455f1: [String] in ReadOnlySpace: #length: 0x2d848adb4c29 &#x3C;AccessorInfo> (const accessor descriptor), location: descriptor\n }\n0x2699696c3c39: [Map]\n - type: JS_ARRAY_TYPE\n - instance size: 32\n - inobject properties: 0\n - elements kind: PACKED_SMI_ELEMENTS\n - unused property fields: 0\n - enum length: invalid\n - back pointer: 0x3f94f05415b9 &#x3C;undefined>\n - prototype_validity cell: 0x2d848adb5169 &#x3C;Cell value= 1>\n - instance descriptors #1: 0x266f4d105d49 &#x3C;DescriptorArray[1]>\n - transitions #2: 0x31d900141ad1 &#x3C;TransitionArray[8]>Transition array #2:\n     0x3f94f0546609 &#x3C;Symbol: (elements_transition_symbol)>: (transition to HOLEY_SMI_ELEMENTS) -> 0x2699696c3fe1 &#x3C;Map(HOLEY_SMI_ELEMENTS)>\n     0x36411fa7daf1: [String] in OldSpace: #level: (transition to (const data field, attrs: [WEC]) @ Any) -> 0x309ae03d40f1 &#x3C;Map(PACKED_SMI_ELEMENTS)>\n\n - prototype: 0x266f4d105d79 &#x3C;JSArray[0]>\n - constructor: 0x266f4d13eb09 &#x3C;JSFunction Array (sfi = 0x199b37c84611)>\n - dependent code: 0x3f94f0541251 &#x3C;Other heap object (WEAK_ARRAY_LIST_TYPE)>\n - construction counter: 0\n[]\n</code></pre>\n<p>여기서 element 부분을 보자. <code>elements: 0x3f94f0541329 &#x3C;FixedArray[0]> [PACKED_SMI_ELEMENTS]</code> 라고 되어 있다.</p>\n<p>이는 우리가 선언한 빈 배열이 데이터를 저장하기 위해서 우리가 아는 것과 같은 고정된 크기의 배열을 사용하고 있다는 것을 의미한다. <code>FixedArray[0]</code>이므로 현재 고정 크기 배열의 크기는 0이다.</p>\n<h2>4.3. 배열의 원소 타입 추적</h2>\n<p>위에서 elements kind로 표시되는 <code>PACKED_SMI_ELEMENTS</code>는 배열의 원소가 모두 정수형이라는 것을 의미한다. <code>PACKED_SMI_ELEMENTS</code>의 SMI는 small int를 뜻하는데(그렇게 작지는 않지만 어쨌든) -2^31에서 2^31-1 사이의 범위를 갖는 정수형을 의미한다.</p>\n<p>V8은 배열 연산의 최적화를 위해서 배열의 원소들의 타입을 추적하고 있는데 이것이 elements kind에 표시되고 있는 것이다. 이런 추적을 통해서 V8은 배열의 원소들을 다룰 때 불필요한 타입 변환이나 체크를 하지 않고 최적화된 코드를 실행할 수 있다.</p>\n<p>그리고 배열이 수정될 때 이 elements kind는 그에 따라 변경된다. 이 변경은 더 일반적인 타입으로 변경되는 것이다. 예를 들어, 배열의 원소가 처음에 정수형이었다가 문자열이 되면 elements kind는 <code>PACKED_SMI_ELEMENTS</code>에서 <code>PACKED_ELEMENTS</code>로 변경된다. 이렇게 한번 배열의 elements kind가 변경되면 다시 원래의 타입으로 변경되지 않는다.</p>\n<p><img src=\"/static/array-element-change-9fcd9a1f.svg\" alt=\"배열의 원소 타입이 변하는 순서\"></p>\n<p>그리고 이 elements kind는 배열의 원소들이 변경될 때마다 변경된다. 예를 들어, 배열의 원소가 처음에 정수형이었다가 문자열이 되면 elements kind는 <code>PACKED_SMI_ELEMENTS</code>에서 <code>PACKED_ELEMENTS</code>로 변경된다.</p>\n<p>이를 실험하기 위해 아까 비어 있던 배열에 <code>witch</code>라는 문자열을 삽입한 후 다시 <code>%DebugPrint()</code>를 실행해보자.</p>\n<pre><code class=\"language-bash\">> arr.push(\"witch\")\n1\n> arr\n[ 'witch' ]\n> %DebugPrint(arr);\n...\nelements: 0x0ebe131cc2a1 &#x3C;FixedArray[17]> [PACKED_ELEMENTS]\n...\n</code></pre>\n<p>elements kind가 <code>PACKED_ELEMENTS</code>로 변경되었다.</p>\n<p>이때 <code>arr.pop()</code>으로 배열의 원소를 제거하여 다시 빈 배열로 바꾼 후 다시 <code>%DebugPrint()</code>를 실행해도 elements kind는 <code>PACKED_ELEMENTS</code>로 남아있다.</p>\n<h2>4.4. 배열의 공간 할당</h2>\n<p>앞에서 문자열을 추가한 배열에 <code>%DebugPrint</code>함수를 사용한 결과를 다시 보자. elements kind가 <code>PACKED_ELEMENTS</code>로 변경되었고, elements는 <code>0x0ebe131cc2a1 &#x3C;FixedArray[17]></code>로 표시되었다.</p>\n<p>여기서 볼 것은 FixedArray size가 17로 바뀌었다는 것이다. 그런데 우리는 원소를 하나밖에 추가하지 않았다.. 그럼 왜 size가 17이 되었을까? 이는 JS배열이 동적으로 동작하므로, 배열의 저장 공간이 부족해졌을 때 얼만큼의 메모리를 추가 할당하는지에 관련되어 있다.</p>\n<p>새로운 메모리 capacity 할당은 다음과 같은 식을 따른다.</p>\n<p>$new_capacity = (old_capacity + old_capacity / 2) + 16$</p>\n<p>old_capacity는 <code>(기존 배열의 capacity + 삽입된 원소 수)`` 이므로 여기서는 1이다(빈 배열에 원소 1개 삽입). 따라서 new_capacity는 </code>1 + 1/2 * 1 + 16 = 17`이 된다. 위에서 나온 FixedArray size와 같다.</p>\n<p>그럼 배열에 할당된 메모리가 줄기도 할까? 만약 배열에 pop연산 등이 많이 가해져서 배열에 할당된 메모리의 50% 이상이 사용되지 않게 되면 배열의 메모리를 줄이는 작업이 일어난다.</p>\n<p>방금만 해도 원소가 하나뿐인 배열에 pop을 가하니까 <code>FixedArray[17]</code>이 <code>FixedArray[0]</code>로 줄어들었다.</p>\n<h2>4.5. hole</h2>\n<p>위에서 <code>witch</code>라는 문자열을 배열에 삽입한 후 <code>%DebugPrint()</code>를 실행한 결과를 다시 보자.</p>\n<pre><code class=\"language-bash\">> arr\n[ 'witch' ]\n> %DebugPrint(arr);\nDebugPrint: 0x2a0ee8b8711: [JSArray] in OldSpace\n - map: 0x2699696c4d19 &#x3C;Map(PACKED_ELEMENTS)> [FastProperties]\n - prototype: 0x266f4d105d79 &#x3C;JSArray[0]>\n - elements: 0x0ebe131cc2a1 &#x3C;FixedArray[17]> [PACKED_ELEMENTS]\n - length: 1\n - properties: 0x3f94f0541329 &#x3C;FixedArray[0]>\n - All own properties (excluding elements): {\n    0x3f94f05455f1: [String] in ReadOnlySpace: #length: 0x2d848adb4c29 &#x3C;AccessorInfo> (const accessor descriptor), location: descriptor\n }\n - elements: 0x0ebe131cc2a1 &#x3C;FixedArray[17]> {\n           0: 0x0f0d12e0eea9 &#x3C;String[5]: #witch>\n        1-16: 0x3f94f0541689 &#x3C;the_hole>\n }\n0x2699696c4d19: [Map]\n - type: JS_ARRAY_TYPE\n - instance size: 32\n - inobject properties: 0\n - elements kind: PACKED_ELEMENTS\n - unused property fields: 0\n - enum length: invalid\n - back pointer: 0x2699696c4d61 &#x3C;Map(HOLEY_DOUBLE_ELEMENTS)>\n - prototype_validity cell: 0x2d848adb5169 &#x3C;Cell value= 1>\n - instance descriptors #1: 0x02a0ee8b9789 &#x3C;DescriptorArray[2]>\n - transitions #4: 0x0b116d9199c1 &#x3C;TransitionArray[12]>Transition array #4:\n     0x3f94f0546609 &#x3C;Symbol: (elements_transition_symbol)>: (transition to HOLEY_ELEMENTS) -> 0x2699696c4df1 &#x3C;Map(HOLEY_ELEMENTS)>\n     0x36411fa7daf1: [String] in OldSpace: #level: (transition to (const data field, attrs: [WEC]) @ Any) -> 0x09ad648c34a1 &#x3C;Map(PACKED_ELEMENTS)>\n     0x3f94f0545d31: [String] in ReadOnlySpace: #raw: (transition to (const data field, attrs: [___]) @ Any) -> 0x309ae03c6e01 &#x3C;Map(PACKED_ELEMENTS)>\n     0x3f94f0546681 &#x3C;Symbol: (frozen_symbol)>: (transition to frozen) -> 0x2699696c4e39 &#x3C;Map(PACKED_FROZEN_ELEMENTS)>\n\n - prototype: 0x266f4d105d79 &#x3C;JSArray[0]>\n - constructor: 0x266f4d13eb09 &#x3C;JSFunction Array (sfi = 0x199b37c84611)>\n - dependent code: 0x3f94f0541251 &#x3C;Other heap object (WEAK_ARRAY_LIST_TYPE)>\n - construction counter: 0\n\n[ 'witch' ]\n</code></pre>\n<p>빈 배열일 때와 달리 <code>elements</code>항목이 새로 생겼다. 0인덱스에는 당연히 우리가 삽입한 문자열이 들어 있다. 하지만 1-16 인덱스에는 the_hole이 들어 있다고 한다.</p>\n<p>이 the_hole은 V8에서 아직 원소가 할당되지 않았거나 삭제된 배열의 원소를 표현하기 위해 사용하는 특수한 값이다. 즉, 배열의 원소가 할당되지 않은 상태를 hole이라고 한다. 우리의 예시에선 배열에 할당은 되었지만 아직 사용되지 않은 인덱스들에 the_hole이 들어가 있다.</p>\n<h2>4.6. packed, holey</h2>\n<p>위에 보면 <code>elements kind</code>가 <code>PACKED_ELEMENTS</code>라고 되어 있다. 이 PACKED는 뭘까? 이건 배열에 hole이 있는지 여부를 나타낸다. elements kind에 packed가 붙어 있으면 배열이 hole이 없는 상태라는 것이다.</p>\n<p>elements kind에 holey가 붙어 있으면 배열이 hole이 있는 상태라고 할 수 있다.</p>\n<p>예를 들어서 [1] 이 있는 배열 <code>arr</code>에 <code>arr[2]=3;</code>을 실행하면 인덱스 1에는 hole이 들어가 있게 된다. 아직 아무것도 할당되지 않았기 때문이다. 그 상태에서 <code>arr</code>에 <code>%DebugPrint</code>를 실행하면 elements가 다음과 같이 나온다.</p>\n<pre><code class=\"language-bash\">- elements: 0x3ef33f55da39 &#x3C;FixedArray[20]> [HOLEY_SMI_ELEMENTS]\n</code></pre>\n<p>elements 정보는 이렇다. 중간에 the_hole이 있는 걸 볼 수 있다.</p>\n<pre><code class=\"language-bash\">- elements: 0x3ef33f55da39 &#x3C;FixedArray[20]> {\n          0: 1\n          1: 0x3c7a9bac1689 &#x3C;the_hole>\n          2: 3\n      3-19: 0x3c7a9bac1689 &#x3C;the_hole>\n}\n</code></pre>\n<p><code>HOLEY_SMI_ELEMENTS</code>는 배열에 hole 혹은 smi_element만 있다는 것을 뜻한다. 이 element kind를 가지는 배열은 packed element를 가진 배열보다 좀 느리다. holey 배열을 사용하면 V8에서 배열을 순회하거나 수정할 때 value check을 해야 하기 때문이다.(hole skip을 위해서)</p>\n<p>이외에도 <code>PACKED_ELEMENT</code>, <code>PACKED_DOUBLE_ELEMENTS</code>, <code>HOLEY_ELEMENTS</code>, <code>HOLEY_DOUBLE_ELEMENTS</code> 등의 element kind가 있다. DOUBLE이 붙은 건 말 그대로 실수 element를 뜻하고 그냥 <code>PACKED_ELEMENT</code>는 문자열이나 일반 객체를 뜻한다.</p>\n<h2>4.7. 배열의 다른 구현</h2>\n<p>그런데 배열은 위에서 잠시 살펴본 것과 같이 해시테이블로 구현될 수도 있다. V8에서도 그렇게 하는 경우가 있다. 예를 들어서 아까의 <code>arr</code> 배열에 다음과 같은 연산을 하자.</p>\n<pre><code class=\"language-js\">arr[32 &#x3C;&#x3C; 20] = 0;\n</code></pre>\n<p>그리고 <code>%DebugPrint</code>를 실행하면 다음과 같이 나온다.</p>\n<pre><code class=\"language-bash\">%DebugPrint(arr);\nDebugPrint: 0x2adbcfd64299: [JSArray]\n - map: 0x08023b1c23c1 &#x3C;Map(DICTIONARY_ELEMENTS)> [FastProperties]\n - prototype: 0x13b862905d79 &#x3C;JSArray[0]>\n - elements: 0x2fd0ff649a89 &#x3C;NumberDictionary[16]> [DICTIONARY_ELEMENTS]\n - length: 33554433\n - properties: 0x3c7a9bac1329 &#x3C;FixedArray[0]>\n - All own properties (excluding elements): {\n    0x3c7a9bac55f1: [String] in ReadOnlySpace: #length: 0x0fa1689b4c29 &#x3C;AccessorInfo> (const accessor descriptor), location: descriptor\n }\n - elements: 0x2fd0ff649a89 &#x3C;NumberDictionary[16]> {\n   - max_number_key: 33554432\n   33554432: 0 (data, dict_index: 0, attrs: [WEC])\n   0: 1 (data, dict_index: 0, attrs: [WEC])\n   2: 3 (data, dict_index: 0, attrs: [WEC])\n }\n0x8023b1c23c1: [Map]\n - type: JS_ARRAY_TYPE\n - instance size: 32\n - inobject properties: 0\n - elements kind: DICTIONARY_ELEMENTS\n - unused property fields: 0\n - enum length: invalid\n - stable_map\n - back pointer: 0x2a4729384df1 &#x3C;Map(HOLEY_ELEMENTS)>\n - prototype_validity cell: 0x0fa1689b5169 &#x3C;Cell value= 1>\n - instance descriptors (own) #1: 0x13b862905d49 &#x3C;DescriptorArray[1]>\n - prototype: 0x13b862905d79 &#x3C;JSArray[0]>\n - constructor: 0x13b86293eb09 &#x3C;JSFunction Array (sfi = 0x117f70bc4611)>\n - dependent code: 0x3c7a9bac1251 &#x3C;Other heap object (WEAK_ARRAY_LIST_TYPE)>\n - construction counter: 0\n\n[ 1, &#x3C;1 empty item>, 3, &#x3C;33554429 empty items>, 0 ]\n</code></pre>\n<p>우리의 배열은 이제 <code>NumberDictionary</code>로 구현되어 있다! 이 <code>NumberDictionary</code>가 바로 해시테이블로 구현되어 있다.</p>\n<p>또한 element kind도 <code>DICTIONARY_ELEMENTS</code>로 바뀌었다. V8은 많은 hole을 갖는 sparse array를 다룰 때 메모리를 줄이기 위해 이 element kind를 사용한다. 해시테이블을 이용해서 hole이 아닌 원소들만을 저장하는 것이다.</p>\n<p>이 <code>DICTIONARY_ELEMENTS</code>의 구조는 위 배열의 elements들을 보면 대강 알 수 있다.</p>\n<pre><code class=\"language-bash\">elements: 0x2fd0ff649a89 &#x3C;NumberDictionary[16]> {\n  - max_number_key: 33554432\n  33554432: 0 (data, dict_index: 0, attrs: [WEC])\n  0: 1 (data, dict_index: 0, attrs: [WEC])\n  2: 3 (data, dict_index: 0, attrs: [WEC])\n}\n</code></pre>\n<p>이 구조, 어쩐지 낯이 익다..앞에서 <code>getOwnPropertyDescriptors</code>함수를 이용해 배열의 프로퍼티들을 출력해보았을 때 나왔던 구조와 비슷하지 않은가?</p>\n<p><code>data</code>가 <code>value</code>이고 <code>dict_index</code>가 <code>key</code> 즉 index이고 <code>attrs:[WEC]</code>의 WEC가 각각 writable, enumerable, configurable이라고 추론할 수 있다.</p>\n<pre><code class=\"language-js\">{\n  0: {value: 1, writable: true, enumerable: true, configurable: true},\n  1: {value: 2, writable: true, enumerable: true, configurable: true},\n  2: {value: 3, writable: true, enumerable: true, configurable: true},\n  length: {value: 3, writable: true, enumerable: false, configurable: false}\n}\n</code></pre>\n<p>하지만 이렇게 딕셔너리를 사용해 배열을 저장하면 메모리를 절약하는 대신 해시테이블을 사용하기 때문에 배열의 원소에 접근하는 속도가 느려진다. 시간복잡도로 따지면 똑같이 O(1)이지만 해시 함수도 계산해야 하고, entry lookup도 해야 하고 중간중간 rehashing도 수행해 줘야 하기 때문이다. 이런 용어들은 자료구조 내용을 참고하자.</p>\n<p>이렇게 딕셔너리를 사용하는 건 배열이 특정 threshold 길이를 넘어갔을 때이고 그 threadhold는 약 32MB이다. 이 threshold를 넘어가면 배열의 element kind가 <code>DICTIONARY_ELEMENTS</code>로 바뀌고, 그 이후로는 배열의 원소를 추가하거나 삭제할 때마다 딕셔너리를 사용하게 된다. <a href=\"https://github.com/nodejs/node/blob/49342fe6f2ca6cedd5219d835a0a810e6f03cdd7/deps/v8/src/objects/js-array.h#L120\">V8에서 threshold를 설정하는 코드는 다음과 같다.</a></p>\n<pre><code class=\"language-cpp\">// This constant is somewhat arbitrary. Any large enough value would work.\nstatic const uint32_t kMaxFastArrayLength = 32 * 1024 * 1024;\n</code></pre>\n<h1>5. JS 상수 배열</h1>\n<p>앞서 배열이 어떻게 구현되는지를 알아보았다. 그런데 우리가 앞서 무엇을 보았는가? const로 선언된 배열에 push하는 것을 보았다. 어떻게 이런 것이 가능할까? 그것은 JS에서 배열에 const 선언을 하는 것은 배열 변수가 다른 객체를 참조하지 못하도록 하는 것이기 때문이다. 하지만 push는 참조를 바꾸지 않는다.</p>\n<h2>5.1. 참조 확인</h2>\n<p>js에는 파이썬의 <code>id()</code>처럼 객체의 고유 id를 확인할 수 있는 함수가 없다. 따라서 <a href=\"https://stackoverflow.com/questions/1997661/unique-object-identifier-in-javascript\">다음 스택오버플로우 글</a>에 있는 함수를 써서 객체 각각에 고유 아이디를 부여했다. Object 프로토타입에 uniqueId 메서드를 부여하여 새로운 객체가 생길 때마다 고유 아이디를 부여하는 것이다.</p>\n<pre><code class=\"language-js\">(function () {\n  if (typeof Object.prototype.uniqueId == \"undefined\") {\n    var id = 0;\n    Object.prototype.uniqueId = function () {\n      if (typeof this.__uniqueid == \"undefined\") {\n        this.__uniqueid = ++id;\n      }\n      return this.__uniqueid;\n    };\n  }\n})();\n</code></pre>\n<p>다음과 같이 간단하게 개발자 도구에서 실험했다. push/pop은 참조를 바꾸지 않는다는 것을 확인할 수 있다. uniqueId가 바뀌지 않았기 때문이다. 하지만 아예 새로운 배열을 할당하면 uniqueId가 바뀜을 통해 새로운 객체가 생성되는 것을 확인할 수 있다.</p>\n<p><img src=\"/static/uniqueID-9960c7cf.png\" alt=\"unique\"></p>\n<p>const는 즉 배열 변수가 다른 객체를 참조하지 못하도록 하는 것이다. 배열 변수가 같은 객체를 가리키고 있다면 push나 pop등을 통해 그 객체가 바뀌는 것은 상관없다.</p>\n<h2>5.2. 내용도 안 바뀌는 객체 만들기</h2>\n<p>그러면 어떻게 객체의 내용까지 변경 불가능하게 만들까? 그냥 <code>Object.freeze()</code>라는 함수를 사용하면 된다. 이 함수는 객체를 동결해서 더 이상 변경될 수 없게 한다. 새로운 속성 추가, 속성 제거, 속성 값 변경 등을 불가능하게 하는 것이다. 또한 프로토타입 변경도 방지한다.</p>\n<pre><code class=\"language-js\">Object.freeze(arr);\n</code></pre>\n<p>이 함수를 쓰고 나서 배열의 내용을 바꾸려고 하면 에러가 발생한다.</p>\n<p><img src=\"/static/freeze-a3565fca.png\" alt=\"freeze\"></p>\n<h1>참고</h1>\n<p><a href=\"https://poiemaweb.com/js-array-is-not-arrray\">자바스크립트 배열은 배열이 아니다</a></p>\n<p><a href=\"https://morohaji.tistory.com/55\">상수 배열 선언 실패</a></p>\n<p><a href=\"https://stackoverflow.com/questions/62771790/how-to-create-a-constant-array-that-is-not-modified-by-its-reference-in-javascri\">상수 배열 선언하기</a></p>\n<p><a href=\"https://itnext.io/v8-deep-dives-understanding-array-internals-5b17d7a28ecc\">V8의 배열 내부 구현</a></p>\n<p><a href=\"https://saki-chan.dev/Elements_Kinds/\">DebugPrint 해석에 참고</a></p>\n<p><a href=\"https://medium.com/@brayce1996/time-complexity-analysis-of-javascript-array-unshift-74930aaa2f6\">shift, unshift의 복잡도 분석</a></p>\n<p><a href=\"https://tc39.es/ecma262/#sec-array.prototype.push\">ECMA-262 push</a></p>\n<p><a href=\"https://tc39.es/ecma262/#sec-array.prototype.pop\">ECMA-262 pop</a></p>\n<p><a href=\"https://tc39.es/ecma262/#sec-array.prototype.unshift\">ECMA-262 unshift</a></p>\n<p><a href=\"https://tc39.es/ecma262/#sec-array.prototype.shift\">ECMA-262 shift</a></p>\n<p><a href=\"https://github.com/v8/v8/blob/5d67f90e0f9b76f4e98488126d7658e9228c332f/src/builtins/builtins-array.cc#L603\">v8의 unshift</a></p>\n<p><a href=\"https://stackoverflow.com/questions/1997661/unique-object-identifier-in-javascript\">js 객체에 유일한 id 부여하기</a></p>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze\">MDN freeze</a></p>\n<p><a href=\"https://v8.dev/blog/elements-kinds\">https://v8.dev/blog/elements-kinds</a></p>",
    "excerpt": "1. Javascript 배열은 배열이 아니다\n일반적으로 자료구조 시간에 배우는 배열이란 연속된 메모리 공간에 같은 타입의 데이터를 저장하는 자료구조이다. 하지만 Javascript의 배열은 그렇지 않다. push, pop등 배열의 크기를 늘리거나 줄이는 메서드도 있고, 서로 다른 타입의 데이터를 저장할 수도 있다.\na = [1, 2, 3];\n// 배열의 크기를 늘리는 메서드\n// 또한 배열에 서로 다른 타입의 데이터를 저장한다\na.push(\"me\");\n\n이는 ",
    "headingTree": [
      {
        "title": "1. Javascript 배열은 배열이 아니다",
        "url": "#1-javascript-배열은-배열이-아니다",
        "items": []
      },
      {
        "title": "2. Javascript 배열의 구조",
        "url": "#2-javascript-배열의-구조",
        "items": []
      },
      {
        "title": "4. JS 배열, 더 깊이",
        "url": "#4-js-배열-더-깊이",
        "items": [
          {
            "title": "4.1. 시작",
            "url": "#41-시작",
            "items": []
          },
          {
            "title": "4.2. 빈 배열",
            "url": "#42-빈-배열",
            "items": []
          },
          {
            "title": "4.3. 배열의 원소 타입 추적",
            "url": "#43-배열의-원소-타입-추적",
            "items": []
          },
          {
            "title": "4.4. 배열의 공간 할당",
            "url": "#44-배열의-공간-할당",
            "items": []
          },
          {
            "title": "4.5. hole",
            "url": "#45-hole",
            "items": []
          },
          {
            "title": "4.6. packed, holey",
            "url": "#46-packed-holey",
            "items": []
          },
          {
            "title": "4.7. 배열의 다른 구현",
            "url": "#47-배열의-다른-구현",
            "items": []
          }
        ]
      },
      {
        "title": "5. JS 상수 배열",
        "url": "#5-js-상수-배열",
        "items": [
          {
            "title": "5.1. 참조 확인",
            "url": "#51-참조-확인",
            "items": []
          },
          {
            "title": "5.2. 내용도 안 바뀌는 객체 만들기",
            "url": "#52-내용도-안-바뀌는-객체-만들기",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 4,
      "wordCount": 1128
    },
    "url": "/posts/javascript-array-deep-dive",
    "thumbnail": {
      "local": "/static/nodeREPL-08aab937.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-nodeREPL-08aab937-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAFCAIAAAD38zoCAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAWUlEQVR4nGOQlZUwNjUVExdPTk0tLinJycmZMmXK8RMnGLZt2/YEDL59+/YfBt6+fcvw5MkTOP8bGPz////V61coEnBw6dIlhkuXLr2Fgdtg8Pbt27Xr1gEAcNJiHeVod24AAAAASUVORK5CYII="
    }
  },
  {
    "slug": "javascript-async-method",
    "title": "Javascript와 비동기 - 방법",
    "date": "2023-08-25T02:00:00Z",
    "description": "JS의 비동기에 대하여",
    "tags": [
      "javascript"
    ],
    "html": "<h1>0. 시작</h1>\n<p>Javascript는 싱글스레드 언어이다. 그 말은 작업을 처리할 수 있는 콜스택이 하나뿐이라는 말과 같다.</p>\n<p>이는 언어 설계에서부터 의도된 것이다. 먼저 초기에 JS는 웹브라우저에서 동적인 부분을 처리하기 위한 목적으로만 만들어진 작은 언어였기에 싱글스레드로도 충분할 때가 많았고 비동기를 진지하게 지원하려고 하지도 않았다.</p>\n<p>또한 이런 구현의 장점도 있었다. JS는 싱글스레드 언어가 됨으로써 언어 설계자에게도 사용자에게도 간단한 구현을 할 수 있게 해주었다. 멀티스레드 환경에서 고려해야 하는 데드락이나 경합 상태와 같은 수많은 동시성 관련 이슈들을 고려하지 않아도 되었기 때문이다.</p>\n<p>하지만 JS로 하는 일은 점점 많아졌고 <code>fetch</code>로 HTTP 요청을 만들어 서버와 통신하거나 일정 시간 이후에 특정 작업이 실행되도록 예약하는 등 꽤 많은 작업이 비동기를 요구하게 되었다. 성능 관련 이슈도 있고 말이다.</p>\n<p>그래서 JS는 비동기를 지원하기 위해 여러가지 방법을 제공하고 내부적으로는 이벤트 루프를 통해 비동기 작업을 처리하도록 했다.</p>\n<p>gc와 같은 부분들도 싱글스레드 작업에 방해되지 않도록 여러 처리를 했다. 이런 부분들을 차근차근 알아보자.</p>\n<h1>1. 비동기 작업의 필요성</h1>\n<p>다음과 같은 HTML을 짜보자.</p>\n<pre><code class=\"language-html\">&#x3C;!DOCTYPE html>\n&#x3C;html lang=\"en-us\">\n  &#x3C;head>\n    &#x3C;meta charset=\"utf-8\">\n    &#x3C;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    &#x3C;meta name=\"viewport\" content=\"width=device-width\">\n    &#x3C;title>오~~래 걸리는 작업&#x3C;/title>\n  &#x3C;/head>\n  &#x3C;body>\n    &#x3C;label>\n      &#x3C;span>소수의 개수&#x3C;/span>\n      &#x3C;input type=\"text\" value=\"1000000\">\n    &#x3C;/label>\n    &#x3C;button id=\"generate\">소수 생성 시작&#x3C;/button>\n    &#x3C;button id=\"reload\">재시작&#x3C;/button>\n    &#x3C;div id=\"result\">&#x3C;/div>\n    &#x3C;textarea>소수 생성 동안 이곳은 사용 불가능해진다.&#x3C;/textarea>\n\n    &#x3C;script>\n      function generatePrimes(q){\n        function isPrime(n){\n          for(let c=2;c*c&#x3C;=n;c++){\n            if(n%c===0){\n              return false\n            }\n          }\n          return true;\n        }\n\n        const primes=[];\n        const mx=1000000;\n\n        while(primes.length&#x3C;q){\n          const n=Math.floor(Math.random()*(mx+1));\n          if(isPrime(n)){\n            primes.push(n);\n          }\n        }\n        return primes;\n      }\n\n      document.getElementById('generate').addEventListener('click',function(){\n        const q=document.querySelector('input').value;\n        const primes=generatePrimes(q);\n        const result=document.getElementById('result');\n        document.getElementById('result').textContent=`소수 ${q}개 생성 완료`;\n      })\n\n      document.getElementById('reload').addEventListener('click',function(){\n        location.reload();\n      })\n    &#x3C;/script>\n  &#x3C;/body>\n&#x3C;/html>\n</code></pre>\n<p>이를 브라우저에서 켜보면 다음과 같은 창이 생성된다.</p>\n<p><img src=\"/static/prime-HTML-34d3375b.png\" alt=\"primeHTML\"></p>\n<p>소수 생성 시작 버튼을 누르면 input에 입력된 갯수만큼의 소수를 생성하는 작업이 시작되는데, 이 작업이 끝나기 전까지는 밑의 텍스트 입력 창을 사용하지 못하는 것을 볼 수 있다. 괜히 저런 문구를 <code>&#x3C;textarea></code>에 써 놓은 게 아니다.</p>\n<p>하지만 논리적으로는 소수 생성과 밑의 텍스트 입력창은 별 상관이 없다. 굳이 소수 생성이 끝나야 사용할 수 있게 될 필요가 없다. 이런 것을 해결하기 위해서는 해당 함수가 작업하는 동안 다른 이벤트에 응답이 가능하도록 하는 비동기가 필요하다.</p>\n<p>그럼 JS에서는 이런 비동기를 어떻게 처리하고 있을까? 구체적인 동작 방식은 뒤에서 다루겠지만 방법만 보면 JS에서 비동기 작업을 처리하는 방법들은 콜백 함수, Promise, async/await 그리고 최근에 나온 Worker 정도가 있다.</p>\n<h1>2. 콜백 함수를 이용한 비동기 처리</h1>\n<p>바닐라 JS를 좀 해본 사람이라면 이벤트 핸들러의 비동기 처리 방식을 생각할 수 있다. 콜백을 사용하는 것이다. 비동기 작업을 완료하는 이벤트가 발생시키는 신호를 받았을 때 어떤 콜백을 실행하는 방식이다.</p>\n<p>초기의 비동기 API는 이런 방식을 사용하고는 했다. <code>fetch</code> API 이전에 HTTP 요청을 보낼 때 쓰이던 <code>XMLHttpRequest</code>가 이를 사용하던 대표적인 객체였다. <code>XMLHttpRequest</code> 객체의 <code>loadend</code>이벤트가 발생하면 특정 콜백을 실행하도록 한 것이다.</p>\n<pre><code class=\"language-js\">const xhr=new XMLHttpRequest();\n\nxhr.addEventListener('loadend',()=>{\n  // HTTP 요청이 끝나면 실행되는 콜백 내용\n  console.log('loadend');\n});\n</code></pre>\n<p>하지만 이렇게 콜백을 이용할 경우, 비동기 작업이 순서대로 일어나도록 처리하기 어렵다. 이전에 진행되던 비동기 작업의 맥락을 유지해 줘야 하기 때문이다. 서버에 요청한 데이터가 도착하면 렌더링을 하는 등 비동기 작업의 순서를 강제해 줘야 할 때가 많았기에 이런 상황이 만드는 콜백의 중첩은 개발자들을 매우 힘들게 했다.</p>\n<p>이건 <a href=\"https://witch.work/posts/callstack-and-async#2.1.-%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%9E%91%EC%97%85%EC%9D%98-%EB%A7%A5%EB%9D%BD-%EC%9C%A0%EC%A7%80\">콜스택과 비동기 프로그래밍 글의 관련 부분</a>을 참고할 수 있다. 하지만 이 글을 탐구하지 않더라도 그냥 콜백이 중첩되어서 매우 힘들어진다는 것 정도는 알아두자.</p>\n<p>이런 콜백 중첩을 콜백 지옥이라고들 부르는데, <a href=\"https://developer.mozilla.org/ko/docs/Learn/JavaScript/Asynchronous/Introducing\">MDN에서 제시하는 간단한 콜백 지옥 예시는 다음과 같다. 실제로 쓰이는 콜백 지옥 코드라면 에러 핸들링 콜백까지 들어가서 더욱 복잡했을 것이다.</a></p>\n<pre><code class=\"language-js\">function doStep1(init, callback) {\n  const result = init + 1;\n  callback(result);\n}\n\nfunction doStep2(init, callback) {\n  const result = init + 2;\n  callback(result);\n}\n\nfunction doStep3(init, callback) {\n  const result = init + 3;\n  callback(result);\n}\n\nfunction doOperation() {\n  doStep1(0, (result1) => {\n    doStep2(result1, (result2) => {\n      doStep3(result2, (result3) => {\n        console.log(`result: ${result3}`);\n      });\n    });\n  });\n}\n\ndoOperation();\n</code></pre>\n<p>이를 개선한 게 다음에 볼 Promise이다.</p>\n<h1>3. Promise</h1>\n<h2>3.1. 소개</h2>\n<p>Promise는 새로운 비동기 프로그래밍 방법이다. 비동기 작업 순서를 좀더 편하게 정할 수 있게 해주고 에러 발생시 에러를 깔끔하게 처리할 수 있게 한다. 작업이 완료되거나 실패할 때 콜백이 실행되는 구조이므로 언제 작업이 완료될지를 보장하지는 않는다.</p>\n<p>어떤 작업을 비동기로 실행한다면, 그 비동기 작업을 하는 코드가 있고 그 작업이 끝나면 실행되어야 할 코드가 있다. 서버에서 데이터를 받아오는 작업을 하는 코드와 그 데이터로 무언가를 하는 코드를 예시로 들 수 있을 것이다.</p>\n<p>Promise는 이 둘을 연결시켜 주는 작업을 한다. 비동기 작업을 실행하고, 실행 완료시 어떤 코드가 실행되도록 신호를 전달하는 것이다. <code>then</code>을 이용해서 작업이 완료되었을 때 실행할 콜백을 연쇄적으로 등록할 수 있고, <code>catch</code>를 이용해서 에러 발생시 실행할 콜백을 등록할 수 있다.</p>\n<pre><code class=\"language-js\">fetch(url)\n  .then((response) => {\n    // HTTP 요청이 성공적으로 끝났을 때 실행\n    // response는 HTTP 응답 객체\n    console.log(response);\n    return response.json();\n  })\n  .catch((error) => {\n    // HTTP 요청이 실패했거나 앞의 then에서 에러가 발생했을 때 실행\n    console.log(error);\n    errorCallback(error);\n  });\n</code></pre>\n<p>또한 then 내에서 반환된 값은 다음에 오는 then 콜백 함수의 인수로 전달된다. 이를 이용하면 then 체인을 이어서 작성할 수도 있다. 그리고 이 모든 <code>then</code>블럭에서 발생하는 에러를 하나의 <code>catch</code>로 처리할 수 있다. 다음 코드가 이해를 도울 수 있다.</p>\n<pre><code class=\"language-js\">new Promise((resolve, reject) => {\n  resolve(1);\n}).then((value) => {\n  // resolve의 인수가 value로 들어옴(1)\n  console.log(value);\n  return value + 1;\n}).then((value) => {\n  // 앞에서 리턴한 값이 value로 들어옴(2)\n  console.log(value);\n  return value + 1;\n}).then((value) => {\n  // 앞에서 리턴한 값이 value로 들어옴(3)\n  console.log(value);\n  return value + 1;\n}).then((value) => {\n  // catch로 넘어가기 위해 에러 발생시키기\n  throw new Error(\"일부러 에러 발생\");\n}).catch((error) => {\n  // 에러 메시지 출력(Error: 일부러 에러 발생)\n  console.log(error);\n});\n</code></pre>\n<p>앞의 then에서 리턴한 값이 콜백 함수의 인수로 들어오기 때문에 이를 이용해 어떤 연쇄 작업을 진행할 수도 있다.</p>\n<p>Promise 객체는 한번에 성공 혹은 실패 중 하나의 결과만 가지며 이미 성공한 작업이 실패로 돌아가거나 실패한 작업이 다시 성공할 수는 없다. 그리고 여러 번 실행될 수 있는 이벤트 리스너와 달리(<code>onclick</code> 이벤트 리스너 콜백은 클릭 이벤트 발생시마다 호출된다) Promise의 then은 딱 한번만 실행된다.</p>\n<p>그리고 Promise가 성공하거나 실패한 이후에 성공/실패 콜백을 더해도 맞는 콜백이 실행된다. 이런 특성은 비동기 작업을 다루는 데에 매우 유용했다. 언제 작업이 완료되는지에 신경쓰지 않고 결과가 나왔을 때 반응하는 데에만 관심을 둘 수 있게 해주었기 때문이다.</p>\n<h2>3.2. Promise 객체</h2>\n<p>Promise는 다음과 같이 만들어진다.</p>\n<pre><code class=\"language-js\">const promise=new Promise((resolve, reject)=>{\n  // 비동기 작업\n  // 작업이 완료되면 resolve(결과)를 호출\n  // 에러 발생시 reject(에러)를 호출\n})\n</code></pre>\n<p>이때 Promise 생성자에 전달되는 함수는 <code>executor</code>라고 한다. 이는 Promise가 만들어질 때 자동으로 실행되며 비동기 작업을 맡는다. 이렇게 executor 함수가 실행되고 아직 완료되지 않은 상태는 성공도 아니고 실패도 아닌 중간 상태이며 <code>pending</code>상태라 한다.</p>\n<p>executor는 <code>resolve</code>, <code>reject</code> 2개의 인수를 받는데 이는 JS에서 제공하는 콜백이다. 그리고 executor에서는 인수로 넘겨준 이 콜백 둘 중 하나는 반드시 호출해야 한다.</p>\n<p><code>resolve</code>/<code>reject</code> 둘 중 하나가 호출되어 Promise executor가 끝난 상태는 결과에 상관없이 통틀어서 <code>resolved</code>라 부르며 fulfilled, rejected의 두 가지 경우가 있다.ㄴ</p>\n<p><code>resolve</code>는 작업이 성공적으로 끝났을 때 fulfilled로 넘어가기 위해서 호출하는 함수이다. <code>resolve</code>에 넘겨주는 인수는 그대로 다음 <code>then</code>블록 콜백의 인수가 된다.</p>\n<p>다음과 같은 코드를 실행해 보면 Promise 내에서 2초 후에 <code>resolve</code>가 호출되고 그 인수가 then 블럭에서 호출되는 것을 볼 수 있다.</p>\n<pre><code class=\"language-js\">const timeoutPromise = new Promise((resolve, reject) => {\n  setTimeout(function () {\n    resolve(\"Promise 안의 타임아웃\");\n  }, 2000);\n})\n\n// 2초 후에 \"Promise 안의 타임아웃\"이 출력된다\ntimeoutPromise.then(console.log);\n</code></pre>\n<p>반대로 <code>reject</code>는 작업이 실패했을 때 호출하며 Promise를 rejected 상태로 만든다. 그리고 <code>reject</code>의 인수는 <code>catch</code>블록 콜백의 인수가 된다.</p>\n<p><img src=\"/static/promise-state-65bfa5b3.png\" alt=\"promise-state\">ㄴ</p>\n<p>이렇게 resolve, reject를 활용해서 사용자 정의 Promise를 만들 수도 있다.</p>\n<p>그리고 비동기 코드에서는 기존에 사용하던 try...catch가 작동하지 않으며 Promise의 then, catch를 이용해 에러를 처리해야 한다.</p>\n<p><code>finally</code>도 있는데, 이는 Promise가 성공하든 실패하든 실행되는 콜백 함수를 받는다. 이 콜백 함수는 then, catch에 들어가는 함수와 달리 따로 인수를 받지 않는다. Promise가 이행되었는지 거부되었는지 판단할 수 없기 때문이다.\n다만 상대적으로 최신의 브라우저에서 지원된다.</p>\n<pre><code class=\"language-js\">myPromise\n  .then((response) => {\n    doSomething(response);\n  })\n  .catch((e) => {\n    returnError(e);\n  })\n  .finally(() => {\n    runFinalCode();\n  });\n</code></pre>\n<h2>3.3. Promise.all</h2>\n<p>모든 Promise가 성공해서 fulfilled일 경우 어떤 코드를 실행하고 싶을 수 있다. 이런 기능은 <code>Promise.all</code>메서드를 사용해서 만들 수 있다. 이를 이용하면 Promise로 이루어진 배열을 인수로 받아서 비동기로 실행하고 모든 Promise가 fulfilled일 경우 실행할 코드를 지정할 수 있다. 매개변수로 받은 배열의 Promise 작업들을 모두 하나의 Promise로 묶인 것처럼 실행하는 것이다.</p>\n<p>그리고 각 Promise의 결과값을 담은 배열이 then 콜백 함수의 인수로 전달된다.</p>\n<pre><code class=\"language-js\">Promise.all([PromiseA, PromiseB, PromiseC]).then((values) => {\n  // PromiseA, PromiseB, PromiseC가 모두 fulfilled일 경우 실행\n  // values는 각 Promise의 결과값을 담은 배열\n  console.log(values);\n}).catch((error) => {\n  // PromiseA, PromiseB, PromiseC 중 하나라도 rejected일 경우 실행\n  console.log(error);\n});\n</code></pre>\n<p>이때 각각의 Promise는 then과 catch 블럭을 각자 가진 Promise이다. 따라서 각각의 Promise가 성공하든 실패하든 각각의 then, catch 블럭은 실행된다.</p>\n<p>Promise는 우리가 어떤 함수의 리턴값을 모르거나 얼마나 걸릴지 모를 때 그것에 의존하는 코드를 실행하게 해준다. 또한 콜백 없이도 비동기 작업을 처리하도록 해준다. 대부분의 모던 WebAPI는 Promise 기반이며 비동기 작업은 점점 중요해지고 있으므로 이를 잘 이해해 놓아야 한다.</p>\n<h2>3.4. Promise API</h2>\n<p>많은 API가 프로미스 기반이다. 하지만 우리가 직접 프로미스를 반환하는 API를 만들 수도 있다. 보통 이벤트나 메시지를 전달하는 비동기 작업을 래핑하는 데 쓴다.</p>\n<p>예를 들어 사람 이름과 지연 시간을 받아서, 지연 시간 이후에 사람 이름을 넣어서 깨우는 메시지를 출력하는 함수를 만들 수 있다.</p>\n<pre><code class=\"language-js\">function alarm(person, delay){\n  return new Promise((resolve, reject) => {\n    if(delay&#x3C;0){\n      throw new Error(\"Negative delay\");\n    }\n    setTimeout(() => {\n      resolve(`${person}! Wake up!`)\n    }, delay);\n  });\n}\n</code></pre>\n<p>이렇게 만든 Promise를 사용하면 다음과 같다.</p>\n<pre><code class=\"language-js\">alarm(\"SungHyun\", 2000).then((message) => {\n  console.log(message);\n}).catch((error) => {\n  console.log(error);\n});\n</code></pre>\n<p>이러면 alarm이 반환한 Promise의 executor가 즉시 실행된다. 그리고 2초 뒤에 alarm에서 resolve에 전달한 메시지가 출력된다. 만약 전달했던 delay가 음수일 경우 에러가 발생하고 catch에서 잡아낸다.</p>\n<h1>4. async, await</h1>\n<p><code>async</code>, <code>await</code>을 이용하면 Promise를 좀더 쉽게 사용할 수 있다.</p>\n<p><code>async</code>는 함수 앞에 붙여서 함수가 항상 Promise를 반환하도록 한다. Promise가 아닌 값을 반환해도 resolved promise로 값을 감싸서 반환시킨다.</p>\n<p>그리고 <code>await</code>은 뒤에 오는 Promise가 처리될 때까지 기다렸다가 결과를 반환한다. 이를 이용하면 Promise를 then으로 연결하는 것보다 좀더 직관적으로 코드를 작성할 수 있다.</p>\n<p>예를 들어 다음과 같이 하면 프로그램이 실행된지 1초 이후에 \"PromiseA\"가 콘솔에 출력된다.</p>\n<pre><code class=\"language-js\">let PromiseA = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve(\"PromiseA\");\n  }, 1000);\n});\n\nasync function foo(){\n  let result = await PromiseA;\n  console.log(result);\n}\n\nfoo();\n</code></pre>\n<p><code>await</code>으로 Promise 처리를 위해 함수 실행을 잠시 중단한 동안 엔진은 다른 스크립트를 실행하거나 이벤트를 처리하는 등 다른 일을 할 수 있다.</p>\n<h1>참고</h1>\n<p>JS는 왜 싱글스레드면서 논블로킹일 수 있는가 <a href=\"https://www.geeksforgeeks.org/why-javascript-is-a-single-thread-language-that-can-be-non-blocking/\">https://www.geeksforgeeks.org/why-javascript-is-a-single-thread-language-that-can-be-non-blocking/</a></p>\n<p><a href=\"https://miracleground.tistory.com/entry/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%99%9C-%EC%8B%B1%EA%B8%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EB%A5%BC-%EC%84%A0%ED%83%9D%ED%96%88%EC%9D%84%EA%B9%8C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%8A%A4%EB%A0%88%EB%93%9C-%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%8F%99%EA%B8%B0-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%97%94%EC%A7%84-%EC%9D%B4%EB%B2%A4%ED%8A%B8%EB%A3%A8%ED%94%84\">https://miracleground.tistory.com/entry/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%99%9C-%EC%8B%B1%EA%B8%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EB%A5%BC-%EC%84%A0%ED%83%9D%ED%96%88%EC%9D%84%EA%B9%8C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%8A%A4%EB%A0%88%EB%93%9C-%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%8F%99%EA%B8%B0-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%97%94%EC%A7%84-%EC%9D%B4%EB%B2%A4%ED%8A%B8%EB%A3%A8%ED%94%84</a></p>\n<p>JS 비동기 소개 <a href=\"https://developer.mozilla.org/ko/docs/Learn/JavaScript/Asynchronous/Introducing\">https://developer.mozilla.org/ko/docs/Learn/JavaScript/Asynchronous/Introducing</a></p>\n<p>JS Promise <a href=\"https://developer.mozilla.org/ko/docs/Learn/JavaScript/Asynchronous/Promises\">https://developer.mozilla.org/ko/docs/Learn/JavaScript/Asynchronous/Promises</a></p>\n<p><a href=\"https://medium.com/tooploox/callback-hell-promises-bluebird-and-es7-async-await-to-the-rescue-56c45e23efcb\">https://medium.com/tooploox/callback-hell-promises-bluebird-and-es7-async-await-to-the-rescue-56c45e23efcb</a></p>\n<p><a href=\"https://ko.javascript.info/async-await\">https://ko.javascript.info/async-await</a></p>",
    "excerpt": "0. 시작\nJavascript는 싱글스레드 언어이다. 그 말은 작업을 처리할 수 있는 콜스택이 하나뿐이라는 말과 같다.\n이는 언어 설계에서부터 의도된 것이다. 먼저 초기에 JS는 웹브라우저에서 동적인 부분을 처리하기 위한 목적으로만 만들어진 작은 언어였기에 싱글스레드로도 충분할 때가 많았고 비동기를 진지하게 지원하려고 하지도 않았다.\n또한 이런 구현의 장점도 있었다. JS는 싱글스레드 언어가 됨으로써 언어 설계자에게도 사용자에게도 간단한 구현을 할 수 있게 해주",
    "headingTree": [
      {
        "title": "0. 시작",
        "url": "#0-시작",
        "items": []
      },
      {
        "title": "1. 비동기 작업의 필요성",
        "url": "#1-비동기-작업의-필요성",
        "items": []
      },
      {
        "title": "2. 콜백 함수를 이용한 비동기 처리",
        "url": "#2-콜백-함수를-이용한-비동기-처리",
        "items": []
      },
      {
        "title": "3. Promise",
        "url": "#3-promise",
        "items": [
          {
            "title": "3.1. 소개",
            "url": "#31-소개",
            "items": []
          },
          {
            "title": "3.2. Promise 객체",
            "url": "#32-promise-객체",
            "items": []
          },
          {
            "title": "3.3. Promise.all",
            "url": "#33-promiseall",
            "items": []
          },
          {
            "title": "3.4. Promise API",
            "url": "#34-promise-api",
            "items": []
          }
        ]
      },
      {
        "title": "4. async, await",
        "url": "#4-async-await",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 3,
      "wordCount": 675
    },
    "url": "/posts/javascript-async-method",
    "thumbnail": {
      "local": "/static/prime-HTML-34d3375b.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-prime-HTML-34d3375b-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAADCAIAAAAhqtkfAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAOklEQVR4nGPg4+NjYWGJiYlZt25dcnJyVlbWtWvX/v//z7Bt27Zr167du3fv+/fv/5EAAzLnOxhAJADluTkKWlQ4LwAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "javascript-before-start",
    "title": "자바스크립트 배경지식",
    "date": "2023-08-21T00:00:00Z",
    "description": "자바스크립트의 몇 가지 배경지식을 알아보자",
    "tags": [
      "javascript"
    ],
    "html": "<h1>1. JS 소개</h1>\n<h2>1.1. JS의 용도</h2>\n<p>HTML이 웹 콘텐츠의 구조를 짜고 의미를 부여하며, CSS가 콘텐츠에 스타일을 적용할 수 있게 한다면 JS는 콘텐츠를 동적으로 만들어준다.</p>\n<p>이 JS는 브라우저에서 작동하는 프로그래밍 언어이다. 브라우저에 내장된 V8, 스파이더몽키 등의 JS 가상 머신(엔진)이 JS 스크립트를 읽고 기계어로 전환하고 실행한다.</p>\n<p>이를 이용하면 페이지를 동적으로 만들 수 있다. 예를 들어서 페이지의 모든 요소(DOM element)에는 style 속성이 존재하며 해당 요소의 인라인 CSS 스타일을 모두 담고 있는데, JS를 이용하면 이를 변경하여 스타일을 동적으로 제어할 수 있다.</p>\n<p>그리고 클라이언트 사이드 JS에서는 브라우저 API(DOM API나 Canvas, <a href=\"https://developer.mozilla.org/en-US/docs/Web/Guide/Audio_and_video_delivery\">오디오/비디오 API</a>등)는 물론 많은 서드파티 API를 사용해서 더 많은 일을 할 수도 있다.</p>\n<p>물론 <a href=\"https://expressjs.com/ko/\">express</a>와 같은 걸 이용해서 서버사이드에서 JS를 쓸 수도 있다.</p>\n<h2>1.2. JS의 동작</h2>\n<p>웹 페이지를 브라우저로 불러오게 되면 먼저 HTML과 CSS를 불러온다. 그리고 HTML을 파싱하면서 DOM을 만들고, CSS를 파싱하면서 CSSOM을 만든다. 그리고 이 둘을 합쳐서 렌더 트리를 만든다.</p>\n<p>이 렌더 트리는 브라우저 화면에 표시되는 노드들로 구성된다. 그 다음 JS를 코드가 작성된 순서대로 실행하여 렌더 트리를 동적으로 수정하고 UI를 업데이트한다. 그리고 JS는 기본적으로 인터프리터 언어이지만 JIT 컴파일러를 통해 자주 실행되는 코드를 바이트코드로 변환하여 성능 향상을 꾀한다.</p>\n<p>이때 실행되는 원리를 자세히 보려면 <a href=\"https://velog.io/@wish/JavaScript%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%90%A0%EA%B9%8C\">wishone님의 블로그</a>에 설명되어 있다.</p>\n<h2>1.3. JS로 할 수 없는 일</h2>\n<p>브라우저에서도 할 수 없는 일들이 몇 가지 있다. JS에서 할 수 없는 일이라고 생각해도 무방하다.</p>\n<p>먼저 디스크에 저장된 임의의 파일을 다룰 수 없다. <code>&#x3C;input type=\"file\"></code>태그를 쓰거나 <code>FormData</code>객체를 사용하는 등 특수한 경우에만 가능하다.</p>\n<p>그리고 사용자의 명시적인 허가 없이 카메라, 마이크, 위치 정보 등을 가져올 수 없다. 이는 보안상의 이유로 브라우저에서 제한되어 있다. 웹에서 몇몇 프로그램을 사용하다 보면 볼 수 있는 '카메라 권한 허용'등이 이런 것에 대해 사용자의 허가를 얻는 것이다.</p>\n<p>또 일반적으로 브라우저 내의 서로 다른 탭, 창은 서로의 정보를 알 수 없다. Same Origin Policy 때문이다. 따라서 두 페이지 간의 데이터 교환을 위해서는 서로가 데이터 교환에 동의해야 하고 특정한 js 코드를 포함해야 한다.</p>\n<h1>2. 세팅과 몇몇 정보</h1>\n<p>본격적으로 JS 문법을 배우기 전에 먼저 JS를 사용하기 위한 세팅을 해야 한다. 물론 브라우저에서 실행할 수도 있고 <a href=\"https://playcode.io/\">code playground</a>같은 곳도 있지만 나는 HTML 파일을 사용하겠다.</p>\n<p>HTML 문서의 <code>&#x3C;head></code> 태그 안에 <code>&#x3C;script></code> 태그를 넣어 스크립트를 실행할 수 있다. 이 때, <code>src</code> 속성을 이용해 외부 스크립트 파일을 로딩할 수도 있다. JS코드가 길어질 경우 이런 식으로 <code>.js</code>파일로 분리하고 불러오는 방식으로 사용하는 것이 좋다.</p>\n<p>아무튼 JS를 실행할 배경이 되는 HTML 파일을 먼저 만들자. js-study 폴더를 만들고 index.html 파일을 만들자.</p>\n<pre><code class=\"language-html\">&#x3C;!DOCTYPE html>\n&#x3C;html>\n  &#x3C;head>\n    &#x3C;meta charset=\"utf-8\" />\n    &#x3C;title>Study Page&#x3C;/title>\n  &#x3C;/head>\n  &#x3C;body>\n    &#x3C;h1>마녀&#x3C;/h1>\n  &#x3C;/body>\n&#x3C;/html>\n</code></pre>\n<p>vscode의 Open in browser 익스텐션을 사용하면 html파일을 vscode를 통해서 바로 열 수 있다. index.html을 vscode 상에서 우클릭하고 Open in Default browser를 선택하면 브라우저에서 열린다.</p>\n<p>다음과 같이 js를 삽입하여 사용할 것이다.</p>\n<pre><code class=\"language-html\">&#x3C;!DOCTYPE html>\n&#x3C;html>\n  &#x3C;head>\n    &#x3C;meta charset=\"utf-8\" />\n    &#x3C;title>Study Page&#x3C;/title>\n  &#x3C;/head>\n  &#x3C;body>\n    &#x3C;script>\n      alert(\"Hello World\");\n    &#x3C;/script>\n  &#x3C;/body>\n&#x3C;/html>\n</code></pre>\n<h2>2.1. <code>&#x3C;script></code></h2>\n<p>여담이지만, <code>&#x3C;script></code> 태그에도 속성이 붙어 있을 때가 있다. 몇 가지만 알고 넘어가자.</p>\n<p>language 속성은 현재 사용하고 있는 스크립트 언어를 나타낸다. 하지만 지금은 deprecated되었고 대신 type속성을 사용한다.</p>\n<p>type속성은 파일이 어떤 스크립팅 언어를 사용하는지를 명시하는 역할을 했으며 HTML4에서는 이 속성을 꼭 명시해야 했다.</p>\n<p>하지만 HTML5에서는 이 속성을 생략해도 된다. 기본값은 JS MIME 타입이다. 요즘은 오히려 이를 생략함으로써 JS MIME 타입을 굳이 명시하지 않는 것이 권장된다.</p>\n<p>이 속성은 또한 JS 모듈을 명시하는 데에도 사용된다. <code>type=\"module\"</code>로 설정하면 이 태그 안의 코드가 JS 모듈이라는 것을 의미한다.</p>\n<p>앞서 말했듯 src 속성을 사용하면 외부 스크립트(파일, URL등)를 사용할 수 있다.</p>\n<pre><code class=\"language-html\">&#x3C;script src=\"./script.js\">&#x3C;/script>\n</code></pre>\n<p>만약 <code>&#x3C;script></code> 태그가 src 속성을 가지고 있다면 태그 내부의 코드는 무시된다. 다음과 같은 파일의 경우 <code>script.js</code>의 내용만 실행된다.</p>\n<pre><code class=\"language-html\">&#x3C;!DOCTYPE html>\n&#x3C;html>\n  &#x3C;head>\n    &#x3C;meta charset=\"utf-8\" />\n    &#x3C;title>Study Page&#x3C;/title>\n  &#x3C;/head>\n  &#x3C;body>\n    &#x3C;script src=\"./script.js\">\n      alert(\"Hello World\");\n    &#x3C;/script>\n  &#x3C;/body>\n&#x3C;/html>\n</code></pre>\n<h2>2.2. 스크립트 로딩 관련</h2>\n<p>HTML 문서의 <code>&#x3C;head></code> 태그 안에 <code>&#x3C;script></code> 태그를 넣어 스크립트를 실행할 수 있다. 이 때, <code>src</code> 속성을 이용해 외부 스크립트 파일을 로딩할 수도 있다.</p>\n<p>그런데 문제는 모든 HTML이 순서 그대로 불려온다는 것이다. 다음과 같은 경우를 생각해 보자.</p>\n<pre><code class=\"language-js\">const buttons = document.querySelectorAll('button');\n\nfor (const button of buttons) {\n  button.addEventListener('click', createParagraph);\n}\n</code></pre>\n<pre><code class=\"language-html\">&#x3C;!DOCTYPE html>\n&#x3C;html lang=\"en-US\">\n  &#x3C;head>\n    &#x3C;meta charset=\"utf-8\">\n    &#x3C;meta name=\"viewport\" content=\"width=device-width\">\n    &#x3C;title>My test page&#x3C;/title>\n    &#x3C;script src=\"test.js\">&#x3C;/script>\n  &#x3C;/head>\n  &#x3C;body>\n    &#x3C;button>문단 추가 버튼&#x3C;/button>\n  &#x3C;/body>\n&#x3C;/html>\n</code></pre>\n<p>위 코드가 정상적으로 작동한다면, 버튼을 누를 때마다 문단이 추가되어야 한다. 그러나 코드를 실행해 보면 그렇지 못하다는 것을 알 수 있다.</p>\n<p>body의 button 태그가 로딩되기 전에 head태그의 script 태그가 먼저 불려와서 JS의 <code>addEventListener</code>를 실행해 버리기 때문이다. HTML이 순서대로 로딩되는 건 이런 문제를 낳는다. 이를 해결하는 방식은 3가지 있다.</p>\n<p>가장 고전적인 방법은 <code>&#x3C;script></code>태그를 본문의 맨 마지막 줄, body의 닫는 태그 바로 앞에 쓰는 것이다. 그러면 모든 HTML이 로딩된 후에 스크립트가 로딩된다. 이렇게 하면 HTML을 모두 불러오기 전에는 스크립트를 전혀 실행할 수 없다는 문제가 있다.</p>\n<p>다른 하나는 <code>DOMContentLoaded</code>를 쓰는 방법이다. 이는 브라우저가 HTML 문서를 다 읽었다는 것을 나타내는 이벤트를 수신한 시점에 스크립트를 실행한다.</p>\n<pre><code class=\"language-html\">&#x3C;script>\n  document.addEventListener(\"DOMContentLoaded\", (event)=>{\n    // 실행할 JS 코드\n  });\n&#x3C;/script>\n</code></pre>\n<p>async, defer 속성을 사용할 수도 있는데 이는 다음 섹션에서 알아보자.</p>\n<h2>2.3. async, defer</h2>\n<p>위 문제 해결을 위해 async 혹은 defer 속성을 이용할 수 있다.</p>\n<p><code>defer</code>속성을 <code>&#x3C;script></code>태그에 지정하면 HTML 문서가 다 읽힌 후에 스크립트를 실행하도록 한다.</p>\n<p>즉 HTML 분석이 끝나서 DOM이 준비된 이후, <code>DOMContentLoaded</code> 이벤트가 발생하기 전에 실행된다. 그리고 HTML 분석(파싱) 동안에도 별도 스레드에서 스크립트를 로딩하게 하여 로딩 시간을 줄여 준다. 스크립트 로딩이 완료될 시 해당 스크립트 실행은 페이지 구성이 끝날 때까지 지연된다.</p>\n<p>그러나 외부 스크립트를 불러올 때만 사용할 수 있다. <code>&#x3C;script></code>태그에 <code>src</code>속성이 없으면 <code>defer</code>속성은 무시된다.</p>\n<pre><code class=\"language-html\">&#x3C;script src=\"script.js\" defer>&#x3C;/script>\n</code></pre>\n<p>script에 <code>async</code>속성을 지정할 수도 있다. 이 경우 스크립트는 페이지 로딩과 완전히 독립적으로 동작한다.</p>\n<p><code>async</code> 속성이 지정된 스크립트는 백그라운드에서 다운로드되고 다운로드가 끝나면 즉시 실행된다. 스크립트가 실행되는 동안은 페이지 렌더링이 잠시 중단되고, 스크립트 실행이 끝나면 이어서 진행된다.</p>\n<p>기존 script 태그같은 경우 HTML 분석 중 script를 만나게 되면 HTML 분석을 멈추고 로딩+실행을 하고 나서 다시 HTML 분석을 시작한다.</p>\n<p>하지만 async를 쓰면 HTML 파싱 동안에도 스크립트 로딩을 할 수 있다. 딱 로딩된 JS 스크립트의 실행 시간만큼만 HTML 분석을 멈추게 된다.</p>\n<p>단 단점은 HTML 분석 동안 스크립트들을 병렬로 로딩하기 때문에 스크립트들의 실행 순서가 보장되지 않는다는 것이다. 먼저 로딩되는 것부터 실행된다. 따라서 독립적인 스크립트에만 사용하자. 실행순서가 중요하다면 <code>defer</code>를 사용하자.</p>\n<p><img src=\"/static/async-defer-7f83bd5d.jpg\" alt=\"async와 defer의 차이\"></p>\n<p>출처 <a href=\"https://developer.mozilla.org/ko/docs/Learn/JavaScript/First_steps/What_is_JavaScript#%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8_%EB%A1%9C%EB%94%A9_%EC%A0%84%EB%9E%B5\">MDN 문서</a></p>\n<p><code>async</code>, <code>defer</code>모두 브라우저가 HTML을 파싱하는 동안 스크립트를 로딩할 수 있게 해준다. 스크립트를 가져오는 동안에도 페이지 로딩이 이루어질 수 있도록 해주는 것이다.</p>\n<p>의존성 없는 스크립트를 불러오는 대로 바로바로 실행하려면 <code>async</code>를, 의존성이 있거나 DOM 로딩 이후에 실행되어야 할 스크립트들을 순서대로 실행하려면 <code>defer</code>를 사용하자.</p>\n<h1>3. 코드 구조</h1>\n<p>statement(문)은 어떤 작업을 수행하는 문법 구조, 명령어이다. JS에서도 코드에 원하는 만큼 문을 작성할 수 있는데 서로 다른 문은 <code>;</code>로 구분한다. 그리고 가독성을 위해 보통 한 줄에 한 문을 작성한다.</p>\n<pre><code class=\"language-js\">alert(\"Hello\");\nalert(\"World\");\n</code></pre>\n<h2>3.1. 세미콜론</h2>\n<p>앞에서 각 문은 세미콜론(<code>;</code>)으로 구분한다고 배웠다. 그런데 줄 바꿈이 있으면 세미콜론을 생략할 수 있다. 예를 들어서 다음과 같은 코드는 문제가 없다. 각 문 뒤에 세미콜론이 자동으로 붙기 때문이다.</p>\n<pre><code class=\"language-js\">alert(\"Hello World\")\nalert(\"my code\")\n</code></pre>\n<p>줄바꿈을 암시적으로 세미콜론으로 해석하는 방식을 automatic semicolon insertion이라 한다. 대부분의 경우 줄바꿈은 세미콜론을 의미하는 것이다.</p>\n<p>이것에 관한 구체적인 규칙은 <a href=\"https://witch.work/posts/javascript-semicolon-insertion\">이 글에 있는데 일반적으로는 statement 사이에 세미콜론을 다 붙여 주는 게 좋다는 것이 결론이다.</a></p>\n<h2>3.2 주석</h2>\n<p>주석은 스크립트의 어느 곳에나 작성 가능하고 JS 엔진에 의해 무시되기 때문에 주석의 위치도 실행에 영향을 주지 않는다.</p>\n<p>한 줄짜리 주석은 <code>//</code>로 만든다. 그리고 여러 줄 주석은 <code>/*</code>와 <code>*/</code>로 만든다.</p>\n<pre><code class=\"language-js\">// 한 줄 주석\n/* 여러\n줄\n주석 */\n</code></pre>\n<p>그리고 주석을 중첩해서 사용할 수 없다는 점에 주의하자. <code>/* */</code> 안에 <code>/* */</code>를 넣으면 에러가 발생한다.</p>\n<p>약간의 팁인데, vscode에서 코드 여러 줄을 선택한 후에 <code>Ctrl + /</code>를 누르면 주석을 만들 수 있다. mac 같은 경우 <code>Cmd + /</code>를 누르면 된다. 그리고 주석으로 처리된 부분을 선택한 후 해당 단축키를 다시 누르면 일괄적으로 주석이 해제된다.</p>\n<p>vscode뿐 아니라 대부분의 에디터에서 지원하는 편리한 기능이니 알아두자.</p>\n<h1>4. strict mode</h1>\n<p>JS는 ES5로 넘어오면서 새로운 기능이 추가되고 기존 기능 중 일부를 변경하기도 했다. 이러면서 하위 호환성 문제가 있었다. 따라서 ES5부터는 strict mode라는 기능이 추가되었다. 이 기능을 사용하면 ES5 변경사항이 적용된다. 그렇지 않으면 이전의 규칙을 따른다.</p>\n<p>strict mode를 사용하려면 스크립트 맨 위에 <code>\"use strict\"</code>를 작성하면 된다. 스크립트 최상단이 아니면 엄격 모드가 적용되지 않는다.</p>\n<p>그리고 한번 strict mode가 적용되면 다시 해제할 수 없다.</p>\n<h2>4.1. use strict 생략</h2>\n<p>모던 자바스크립트에선 클래스와 모듈이라는 구조를 제공한다. 이를 사용하고 있다면, 또한 script 태그에 <code>type=\"module\"</code> 속성이 있다면 자동으로 엄격 모드가 코드에 적용된다. 이 경우 <code>\"use strict\"</code>를 생략해도 된다.</p>\n<p>따라서 만약 클래스나 모듈을 사용하는 모던 자바스크립트를 사용하고 있다면 <code>\"use strict\"</code>를 굳이 쓰지 말자.</p>\n<h1>5. 참고하면 좋은 자료</h1>\n<p>JS 시리즈는 MDN의 JS 이야기를 주로 참고해서 글을 쓴다. <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript\">https://developer.mozilla.org/ko/docs/Web/JavaScript</a></p>\n<p>깊이있는 자료들은 다음과 같은 곳에서 얻을 수 있다.</p>\n<p>JS의 공식문서라 할 수 있는 ECMA-262 <a href=\"https://www.ecma-international.org/publications/standards/Ecma-262.htm\">https://www.ecma-international.org/publications/standards/Ecma-262.htm</a>\n그러나 공부할 땐 MDN이 더 낫다.</p>\n<p>MDN에서 제공하는 레퍼런스 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference</a></p>\n<p>브라우저가 특정 기능을 지원하는지 확인 <a href=\"https://caniuse.com/\">https://caniuse.com/</a></p>\n<h1>참고</h1>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#attr-type\">MDN의 script 태그의 type 속성</a></p>\n<p>defer, async 스크립트 <a href=\"https://ko.javascript.info/script-async-defer\">https://ko.javascript.info/script-async-defer</a></p>",
    "excerpt": "1. JS 소개\n1.1. JS의 용도\nHTML이 웹 콘텐츠의 구조를 짜고 의미를 부여하며, CSS가 콘텐츠에 스타일을 적용할 수 있게 한다면 JS는 콘텐츠를 동적으로 만들어준다.\n이 JS는 브라우저에서 작동하는 프로그래밍 언어이다. 브라우저에 내장된 V8, 스파이더몽키 등의 JS 가상 머신(엔진)이 JS 스크립트를 읽고 기계어로 전환하고 실행한다.\n이를 이용하면 페이지를 동적으로 만들 수 있다. 예를 들어서 페이지의 모든 요소(DOM element)에는 styl",
    "headingTree": [
      {
        "title": "1. JS 소개",
        "url": "#1-js-소개",
        "items": [
          {
            "title": "1.1. JS의 용도",
            "url": "#11-js의-용도",
            "items": []
          },
          {
            "title": "1.2. JS의 동작",
            "url": "#12-js의-동작",
            "items": []
          },
          {
            "title": "1.3. JS로 할 수 없는 일",
            "url": "#13-js로-할-수-없는-일",
            "items": []
          }
        ]
      },
      {
        "title": "2. 세팅과 몇몇 정보",
        "url": "#2-세팅과-몇몇-정보",
        "items": [
          {
            "title": "2.1. <script>",
            "url": "#21-script",
            "items": []
          },
          {
            "title": "2.2. 스크립트 로딩 관련",
            "url": "#22-스크립트-로딩-관련",
            "items": []
          },
          {
            "title": "2.3. async, defer",
            "url": "#23-async-defer",
            "items": []
          }
        ]
      },
      {
        "title": "3. 코드 구조",
        "url": "#3-코드-구조",
        "items": [
          {
            "title": "3.1. 세미콜론",
            "url": "#31-세미콜론",
            "items": []
          },
          {
            "title": "3.2 주석",
            "url": "#32-주석",
            "items": []
          }
        ]
      },
      {
        "title": "4. strict mode",
        "url": "#4-strict-mode",
        "items": [
          {
            "title": "4.1. use strict 생략",
            "url": "#41-use-strict-생략",
            "items": []
          }
        ]
      },
      {
        "title": "5. 참고하면 좋은 자료",
        "url": "#5-참고하면-좋은-자료",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 372
    },
    "url": "/posts/javascript-before-start",
    "thumbnail": {
      "local": "/static/async-defer-7f83bd5d.jpg",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-async-defer-7f83bd5d-jpg",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAABCAIAAABsYngUAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIUlEQVR4nGNgZmX+/OWTkZFheUWxt7+nrJxcRnr84cP7AG5XCYrac1StAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "javascript-compare-different-types",
    "title": "JS 탐구생활 - 비교 연산",
    "date": "2023-08-03T04:00:00Z",
    "description": "서로 다른 타입의 비교는 어떻게 이루어질까?",
    "tags": [
      "javascript"
    ],
    "html": "<p>JS의 비교 연산자에 관해 알아보고 있었다. <code>==</code>는 비교하려는 값의 자료형이 다르면 이 값들을 숫자형으로 바꾼다는 건 잘 알려진 사실이다. 따라서 <code>'2'==2</code>의 결과는 true 가 된다. 뭐 <code>===</code>에 비해 잘 쓰이는 연산자도 아니고, 어쨌건 <code>2</code>나 <code>\"2\"</code>나 형태는 비슷해 보이니까 크게 납득이 가지 않는 동작도 아니기 때문에 그냥 넘어갈 수 있다.</p>\n<p>하지만 이뿐만이 아니다. <code>null==undefined</code>의 결과는 true이다. 이건 뭔가 이상하다. 또한 <code>document.all==undefined</code>도 true이다. 왜지? 한번에 이해가 가지 않는다. 따라서 명세를 보며 대체 이 동등 비교라는 게 어떻게 일어나는 것인지 알아보기로 했다.</p>\n<p>일단 비교 연산자 <code>==</code>는 일부 경우에는 <code>===</code>과 동등하게 작동하기도 한다. 따라서 <code>===</code>의 경우를 먼저 살펴보자.</p>\n<h1>1. <code>===</code>의 경우</h1>\n<p><code>===</code>의 경우는 두 값의 타입과 값이 모두 같아야 true를 반환한다고 알려져 있다. 예를 들어 <code>1===1</code>은 true이고 <code>1==='1'</code>은 false이다. 그럼 더 자세한 동작은?</p>\n<p><code>===</code>의 동작은 명세서에 IsStrictlyEqual(x,y)라는 이름으로 정의되어 있다. 두 피연산자가 엄격히 같은지를 판단하는 이항 연산인 것이다. 그 동작은 다음과 같다.</p>\n<ol>\n<li>두 값의 타입이 다르면 false를 반환한다.</li>\n<li>x가 숫자이면 Number::equals(x,y)를 호출하여 그 결과를 리턴한다.</li>\n<li>x가 숫자가 아니면 SameValueNonNumber(x,y)를 호출하여 그 결과를 리턴한다.</li>\n</ol>\n<p>그럼 여기 나오는 Number::equals와 SameValueNonNumber는 무엇일까?</p>\n<h2>1.1. Number::equals</h2>\n<p>Number::equals(x,y)는 명세서에 다음과 같이 정의되어 있다.</p>\n<ol>\n<li>만약 x나 y가 NaN이면 false를 반환한다.</li>\n<li>x와 y가 같은 숫자이면 true를 반환한다.</li>\n<li>x가 -0이고 y가 +0이면 true를 반환한다.</li>\n<li>x가 +0이고 y가 -0이면 true를 반환한다.</li>\n<li>그 외의 경우 false를 반환한다.</li>\n</ol>\n<h2>1.2. SameValueNonNumber</h2>\n<p>SameValueNonNumber(x,y)는 숫자값이 아닌 값 x,y를 받아서 불린값을 반환한다. 명세서에 구체적인 동작은 다음과 같이 정의되어 있다.</p>\n<p>이때 x의 타입이 y의 타입과 같아야 제대로 동작이 시작된다. 따라서 x가 null이면 y도 null, x가 undefined이면 y도 undefined이게 된다. 즉 3번은 <code>null===null</code>, <code>undefined===undefined</code>인 경우를 담당한다.</p>\n<ol>\n<li>x,y의 타입이 같은지 assert로 검사. <code>===</code>를 통해서 왔을 경우 타입이 같으므로 상관없다.</li>\n<li>x가 BigInt이면 BigInt::equal(x,y)를 호출하여 그 결과를 리턴한다. BigInt::equal은 단순히 BigInt값을 비교하는 역할이다.</li>\n<li>x가 undefined이거나 null이면 true를 반환한다.</li>\n<li>x가 문자열이라면 문자열 비교를 해서 같으면 true, 다르면 false를 반환한다. 여기서 문자열이 같다는 건 길이가 같고 같은 문자들과 순서로 구성되어 있다는 뜻이다.</li>\n<li>x가 불린값이라면 불린값 비교를 해서 같으면 true, 다르면 false를 반환한다.</li>\n<li>x가 심볼이라면 심볼 비교를 해서 같으면 true, 다르면 false를 반환한다.</li>\n<li>x,y가 같은 객체에 대한 참조를 가진다면 true, 아니면 false를 반환한다.</li>\n</ol>\n<p>즉 정리하면 x,y가 같은 타입이어야 진행되는 연산이며 x가 BigInt이면 BigInt::equal을 호출하고, 객체를 제외한 원시형이면 값을 비교한다. 그리고 객체라면 참조를 비교한다.</p>\n<h2>1.3. 정리</h2>\n<p>즉 지금까지 살펴본 <code>===</code>의 작동을 정리하면 다음과 같다.</p>\n<p><img src=\"/static/isStrictlyEqual-map-ce10035d.png\" alt=\"isStrictlyEqual 알고리즘\"></p>\n<h1>2. <code>==</code>의 경우</h1>\n<p>처음 이걸 시작한 건 <code>null==undefined</code>는 왜 true냐는 질문이었다. 하지만 찾아보아도 명세서에 그렇게 정의되어 있다는 것 이상 더 설명이 없었다. 따라서 명세를 찾아보았다.</p>\n<p>이는 명세서에 <code>IsLooselyEqual(x,y)</code>로 정의되어 있었다. x,y를 받아서 불린값이나 throw completion을 반환한다. 이런 걸 normal completion이라 하는데 추후 다룰 일이 있을지도..<a href=\"https://medium.com/geekculture/understanding-javascript-what-is-the-completion-record-2334a58c35c\">궁금한 사람은 미디엄 등에 몇몇 글이 있다.</a></p>\n<p>명세는 다음과 같이 나와있다.</p>\n<p><img src=\"/static/isLooselyEqual-ecma-a3c79514.png\" alt=\"isLooselyEqual\"></p>\n<h2>2.1. 타입이 같을 경우</h2>\n<p>이 경우에는 위에서 알아본 <code>===</code>의 경우와 같다. x,y의 타입이 같을 경우 <code>IsLooselyEqual(x,y)</code>는 <code>IsStrictlyEqual(x,y)</code>를 호출한다.</p>\n<h2>2.2. null, undefined</h2>\n<p>x가 null, y가 undefined라면 true를 반환한다. 반대의 경우도 마찬가지이다. 아무 이유도 안 달려 있고 그냥 그렇다.</p>\n<h2>2.3. isHTMLDDA</h2>\n<p>만약 x가 객체이고 x가 <code>[[isHTMLDDA]]</code> 내부 슬롯을 가지고 있고 y가 null혹은 undefined라면 true를 반환한다. 반대의 경우도 마찬가지이다.</p>\n<p>참고로 이 <code>[[isHTMLDDA]]</code> 내부 슬롯은 host-defined 즉 non-native 객체에만 존재한다. 이걸 가진 객체는 ToBoolean, IsLooselyEqual 등에서 undefined와 같이 취급된다고 한다. document.all이 이에 해당한다.</p>\n<p>그래서 실제로 <code>document.all == undefined</code>는 true를 반환한다.</p>\n<h2>2.4. 문자열과 숫자</h2>\n<p>x가 문자열이고 y가 숫자, 혹은 x가 숫자이고 y가 문자열인 경우이다. 이럴 경우 잘 알려져 있다시피 문자열을 숫자로 변환한 후 비교한다.</p>\n<p>더 구체적으로는 예를 들어 x가 숫자이고 y가 문자열인 경우 <code>IsLooselyEqual(x,ToNumber(y))</code>를 호출한다. 반대의 경우도 마찬가지이다.</p>\n<h2>2.5. BigInt와 문자열</h2>\n<p>x가 문자열이고 y가 BigInt인 경우 x에 <code>StringToBigInt(x)</code>를 씌운 후 y와 비교한다. 이때 <code>StringToBigInt(x)</code>가 undefined일 경우 false를 반환한다. 그 외의 경우 <code>IsLooselyEqual(StringToBigInt(x),y)</code>를 호출한다.</p>\n<p>x가 BigInt이고 y가 문자열인 반대의 경우도 마찬가지이다.</p>\n<h2>2.6. 둘 중 하나가 Boolean</h2>\n<p>둘 중 하나가 불린 값이면 해당 값에 <code>ToNumber()</code>를 취한 후 나머지 하나와 비교한다. 예를 들어 x가 불린값이면 <code>IsLooselyEqual(ToNumber(x),y)</code>를 호출한다.</p>\n<p>이것이 <code>1==true</code>가 true인 이유이다.</p>\n<h2>2.7. 둘 중 하나가 객체</h2>\n<p>비교하는 대상 중 하나가 객체이고 나머지 하나가 문자열, 숫자, BigInt, 심볼 중 하나라고 하자. 그러면 객체를 <code>ToPrimitive</code>를 통해 원시값으로 변환한 후 비교한다. 이때 <code>ToPrimitive</code>의 hint는 <code>default</code>이다. 즉 <code>ToPrimitive</code>의 결과는 문자열, 숫자, 심볼 중 하나이다.</p>\n<p>이 <code>ToPrimitive</code>의 동작에 대해서는 <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive\">MDN의 잘 알려진 심볼 Symbol.toPrimitive에 대한 문서</a>를 보자.</p>\n<p>이를 이용하면, 무언가 실용적인 도움은 크게 되지 않지만 다음과 같은 이상한 결과를 만들어낼 수도 있다.</p>\n<pre><code class=\"language-js\">const temp={\n  [Symbol.toPrimitive](hint){\n    return \"witch\"\n  }\n}\n\nconsole.log(temp==\"witch\"); // true\n</code></pre>\n<h2>2.8. BigInt와 숫자</h2>\n<p>비교하는 대상 중 하나가 숫자이고 하나가 BigInt인 경우이다. 만약 둘 중 하나가 무한(Infinity)값이라면 false를 반환한다. 무한이란 정의상 그 어떤 수를 가져와도 그보다 커야 하므로 당연하다.</p>\n<p>그 외의 경우 수학적인 값 비교를 통해서 비교한다.</p>\n<p><strong>위의 경우를 제외하면 <code>isLooselyEqual</code>은 false를 반환한다</strong></p>\n<h1>참고</h1>\n<p><a href=\"https://262.ecma-international.org/5.1/#sec-11.8.5\">ECMA262의 비교 연산자 스펙</a></p>\n<p><a href=\"https://tc39.es/ecma262/#sec-abstract-operations\">https://tc39.es/ecma262/#sec-abstract-operations</a></p>\n<p><a href=\"https://tc39.es/ecma262/#sec-samevaluenonnumber\">https://tc39.es/ecma262/#sec-samevaluenonnumber</a></p>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Glossary/Falsy\">https://developer.mozilla.org/ko/docs/Glossary/Falsy</a></p>\n<p><a href=\"https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\">https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot</a></p>",
    "excerpt": "JS의 비교 연산자에 관해 알아보고 있었다. ==는 비교하려는 값의 자료형이 다르면 이 값들을 숫자형으로 바꾼다는 건 잘 알려진 사실이다. 따라서 '2'==2의 결과는 true 가 된다. 뭐 ===에 비해 잘 쓰이는 연산자도 아니고, 어쨌건 2나 \"2\"나 형태는 비슷해 보이니까 크게 납득이 가지 않는 동작도 아니기 때문에 그냥 넘어갈 수 있다.\n하지만 이뿐만이 아니다. null==undefined의 결과는 true이다. 이건 뭔가 이상하다. 또한 document",
    "headingTree": [
      {
        "title": "1. ===의 경우",
        "url": "#1-의-경우",
        "items": [
          {
            "title": "1.1. Number::equals",
            "url": "#11-numberequals",
            "items": []
          },
          {
            "title": "1.2. SameValueNonNumber",
            "url": "#12-samevaluenonnumber",
            "items": []
          },
          {
            "title": "1.3. 정리",
            "url": "#13-정리",
            "items": []
          }
        ]
      },
      {
        "title": "2. ==의 경우",
        "url": "#2-의-경우",
        "items": [
          {
            "title": "2.1. 타입이 같을 경우",
            "url": "#21-타입이-같을-경우",
            "items": []
          },
          {
            "title": "2.2. null, undefined",
            "url": "#22-null-undefined",
            "items": []
          },
          {
            "title": "2.3. isHTMLDDA",
            "url": "#23-ishtmldda",
            "items": []
          },
          {
            "title": "2.4. 문자열과 숫자",
            "url": "#24-문자열과-숫자",
            "items": []
          },
          {
            "title": "2.5. BigInt와 문자열",
            "url": "#25-bigint와-문자열",
            "items": []
          },
          {
            "title": "2.6. 둘 중 하나가 Boolean",
            "url": "#26-둘-중-하나가-boolean",
            "items": []
          },
          {
            "title": "2.7. 둘 중 하나가 객체",
            "url": "#27-둘-중-하나가-객체",
            "items": []
          },
          {
            "title": "2.8. BigInt와 숫자",
            "url": "#28-bigint와-숫자",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 248
    },
    "url": "/posts/javascript-compare-different-types",
    "thumbnail": {
      "local": "/static/isStrictlyEqual-map-ce10035d.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-isStrictlyEqual-map-ce10035d-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAICAIAAAC6ZnJRAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAf0lEQVR4nD2OQQ0DMRADwyJgQiDS9R0EiyAMlsG+7lUpDAJhIQSCIezjCsDVNdX5ORrLTvwlInLOYwwAn+tKDy2lbEoyuXvv3cxIioiqvs8zrbVqre5O0sxaa6/juN3d3bSU4u4JgIjMOUn23nPOqnqvAYiIxwXw/7Dj7mYG4AsmgnUe1s2hTwAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "javascript-7",
    "title": "모던 자바스크립트 튜토리얼 part 1.4 객체 기본 - 1",
    "date": "2023-01-01T00:00:00Z",
    "description": "ko.javascript.info part 1-4 첫번째",
    "tags": [
      "javascript"
    ],
    "html": "<p>2023년 새해가 밝았다. 그리고 나는 JS를 정리하고 있다. 아아..</p>\n<h1>1. 객체의 개념</h1>\n<p>객체는 원시 타입과 달리 다양한 데이터를 저장할 수 있다. key-value 쌍으로 이루어진 프로퍼티를 여러 개 넣을 수 있는 것이다. 이때 key는 문자열, value는 아무 타입이나 가능하다. 해시로 관리되기에 key의 타입은 제한이 있다.</p>\n<p>중괄호 <code>{}</code>나 생성자 <code>new Object()</code>로 객체를 만들 수 있다. 하지만 보통 중괄호를 쓴다.</p>\n<h2>1.1. 프로퍼티 다루기</h2>\n<p>객체의 key-value 쌍을 프로퍼티라고 한다. 이는 <code>.</code>을 통해 조회할 수 있다.</p>\n<pre><code class=\"language-js\">let user={\n  name:\"김성현\",\n  nickname:\"witch\",\n  age:25,\n}\n\nconsole.log(user.name); // \"김성현\" 을 출력한다.\n</code></pre>\n<p>물론 새로운 프로퍼티를 추가할 수도 있다. 그리고 <code>delete</code>연산자를 쓰면 프로퍼티 삭제도 가능하다.</p>\n<pre><code class=\"language-js\">let user={\n  name:\"김성현\",\n  nickname:\"witch\",\n  age:25,\n}\n\nuser.gender=\"Male\";\ndelete user.age;\nconsole.log(user); // {name: '김성현', nickname: 'witch', gender: 'Male'}\n</code></pre>\n<p>만약 key 문자열이 띄어쓰기가 들어간 상태로 구성되어 있다면 따옴표로 묶어 줘야 한다.</p>\n<pre><code class=\"language-js\">let user={\n  name:\"김성현\",\n  nickname:\"witch\",\n  age:25,\n  \"now in\":'서울',\n}\n</code></pre>\n<p>또한 주의할 점은 객체가 상수로 선언되었더라도 프로퍼티를 수정할 수 있다는 점이다. 객체를 const로 선언하는 건 객체 내용을 고정하는 게 아니라 객체에 대한 참조를 고정하는 것이기 때문이다.</p>\n<h2>1.2. 대괄호 표기법</h2>\n<p>만약 key가 여러 단어로 이루어진 경우 <code>.</code>을 통해 객체 프로퍼티를 참고할 수 없다. <code>.</code>으로 객체 키를 참조할 수 있는 건 대부분 키가 유효한 변수명일 때이다.</p>\n<p>단 다른 점이 있는데 객체 key는 for, let과 같은 JS의 예약어를 사용해도 된다.</p>\n<p>key가 유효한 변수명이 아닐 경우 대괄호를 이용해 key 조회가 가능하다. 대괄호를 이용할 경우 모든 표현식의 평가 결과를 key로 조회 가능하다.</p>\n<pre><code class=\"language-js\">let user={\n  name:\"김성현\",\n  nickname:\"witch\",\n  age:25,\n  \"now in\":'서울',\n}\n\nconsole.log(user[\"now in\"]); // 서울\n</code></pre>\n<h2>1.3. 계산된 프로퍼티</h2>\n<p>객체 리터럴을 만들 때 key를 대괄호로 둘러싼 경우 computed property라 하여 표현식의 평가 결과를 key로 쓸 수 있다. 예를 들어 prompt 창의 리턴값 같은 것들을 객체 키로 사용하게 된다.</p>\n<pre><code class=\"language-js\">let name=prompt(\"당신의 이름을 입력해 주세요\", \"\");\n\nlet info={\n  [name]:\"me\",\n}\nconsole.log(info);\n</code></pre>\n<p>혹은 변수의 복잡한 연산 결과와 같은 걸 키로 사용할 수도 있다.</p>\n<h2>1.4. 프로퍼티 이름 제약</h2>\n<p>객체의 key는 변수명과 달리 for, let 같은 예약어를 사용할 수도 있다. 또한 어떤 문자형이나 심볼형 값을 사용할 수도 있다. 만약 다른 타입 값을 키로 사용하면 문자열로 자동 변환된다.</p>\n<p>단 <code>__proto__</code>만은 역사적인 이유로 객체의 키로 사용할 수 없다. 여기에 대해서는 추후에 다시 다룰 것이다.</p>\n<h2>1.5. 프로퍼티 존재 여부 확인</h2>\n<p>만약 객체에 존재하지 않는 프로퍼티 키에 접근하려고 시도한다면 JS에서는 에러를 발생시키는 대신 undefined를 반환하도록 한다. 따라서 객체 키 조회 결과를 undefined와 비교하는 식으로 객체에 특정 키가 존재하는지 확인할 수 있다.</p>\n<p>이와 같은 기능을 지원하는 걸로 <code>in</code>연산자가 있다. key 조회 후 undefined와 대조하는 것과의 차이는, <code>in</code>을 사용하면 value가 undefined인 경우를 가려낼 수 있다는 점이다. 물론 value를 굳이 undefined로 설정할 일이 별로 없긴 하다.</p>\n<pre><code class=\"language-js\">let info={\n  name:\"김성현\",\n  nickname:\"마녀\",\n}\nconsole.log(\"name\" in info); //name은 있으므로 true\nconsole.log(\"age\" in info); //age는 없으므로 false\n</code></pre>\n<h2>1.6. 객체 순회</h2>\n<p><code>for..in</code>을 사용하면 객체의 모든 키를 순회할 수 있다.</p>\n<pre><code class=\"language-js\">let info={\n  name:\"김성현\",\n  nickname:\"마녀\",\n}\n\nfor(let key in info){\n  console.log(key);\n}\n</code></pre>\n<h2>1.7. 객체 정렬 방식</h2>\n<p>프로퍼티에도 순서가 있다. 이 순서는 <code>for..in</code>으로 객체를 순회할 때 확인 가능하다.</p>\n<p>정수 형태의 프로퍼티(변형 없이 정수로 변환될 수 있어야 한다. 예를 들어 <code>+49</code>는 변형이 있어야 정수로 변할 수 있으므로 정수형태 프로퍼티가 아니다)는 자동으로 정렬되고 나머지는 추가한 순서대로 정렬된다.</p>\n<h1>2. 객체와 참조</h1>\n<p>원시 타입은 값 그대로가 저장된다. 예를 들어서 <code>let a=1</code>이라 할당하면 a에는 실제로 1이라는 값이 담긴다. 그러나 객체는 참조에 의해서 저장되고 복사된다. 따라서 다른 변수에 객체를 할당하면 그 객체에 대한 참조가 전달된다.</p>\n<p>예를 들어 다음과 같이 정수값 1을 a에 담고 b에 할당시 b에도 값 1이 저장된다. 값이 저장된 것이므로 b를 변경해도 a는 똑같다.</p>\n<pre><code class=\"language-js\">let a=1;\nlet b=a;\nb=2;\nconsole.log(a,b); // 1 2\n</code></pre>\n<p>하지만 객체를 다른 변수에 할당한 후 그 변수를 조작하면 원래 변수도 바뀐다. 참조를 할당하기 때문이다.</p>\n<pre><code class=\"language-js\">let info={\n  name:\"김성현\",\n  nickname:\"마녀\",\n}\n\nlet info2=info;\ninfo2.name=\"김상준\";\nconsole.log(info, info2); //info, info2 모두 변경되었다.\n</code></pre>\n<h2>2.1. 객체 비교</h2>\n<p>객체를 비교할 때 <code>==</code>과 <code>===</code>는 같은 동작을 한다. 둘 다 객체의 참조를 비교하기 때문이다. 예를 들어 다음 코드에서 a,b는 완전히 똑같은 내용의 객체이지만 메모리에 있는 서로 다른 객체를 가리키고 있기 때문에 <code>==</code>과 <code>===</code> 모두 <code>false</code>를 반환한다.</p>\n<pre><code class=\"language-js\">let a = {\n  name: \"김성현\",\n  blog: \"https://www.witch.work/\",\n};\nlet b = {\n  name: \"김성현\",\n  blog: \"https://www.witch.work/\",\n};\nconsole.log(a == b);\nconsole.log(a === b);\n</code></pre>\n<h2>2.2. 객체 복사</h2>\n<p>그런데 객체의 참조를 복사하지 않고 객체의 내용을 복사하고 싶을 때가 있다. 일단, 만약 객체의 각 프로퍼티 value가 원시형이라면 객체를 순회하며 복제하면 된다.</p>\n<pre><code class=\"language-js\">let a = {\n  name: \"김성현\",\n  blog: \"https://www.witch.work/\",\n};\nlet b = {};\n\nfor (let key in a) {\n  b[key] = a[key];\n}\nconsole.log(b === a); //false\n</code></pre>\n<p>또는 Object.assign을 사용할 수도 있다. 이 함수는 2번째 인수부터 끝 인수까지 받은 객체를 첫 번째 인수 객체에 복사한다.</p>\n<pre><code class=\"language-js\">let a = {\n  name: \"김성현\",\n  blog: \"https://www.witch.work/\",\n};\nlet b = {\n  nickname: \"마녀\",\n};\n\nlet info = {};\n\nObject.assign(info, a, b);\nconsole.log(info); // a,b의 내용이 info로 복사된 상태\n</code></pre>\n<p>만약 첫 번째 인수 객체에 동일한 key를 갖는 프로퍼티가 있을 경우 뒤에 있는 객체의 프로퍼티가 덮어쓴다. 더 자세한 설명은 <a href=\"https://www.witch.work/javascript-object-assign/\">여기</a>로.</p>\n<h2>2.3. 객체의 깊은 복사</h2>\n<p>앞에서는 객체의 프로퍼티 value가 원시형이라면 객체를 순회하며 복제하면 된다고 했다.</p>\n<p>하지만 프로퍼티 value가 객체라면 어떻게 해야할까? 이 경우 앞선 방식을 사용하면 문제가 발생한다. 각 value의 참조가 복제되기 때문이다. 다음 코드에서 문제를 확인할 수 있다.</p>\n<pre><code class=\"language-js\">let info1 = {\n  name: \"김성현\",\n  blog: \"https://www.witch.work/\",\n  sizes: {\n    height: 171,\n    foot: 280,\n  },\n};\n\nlet info2 = info1;\ninfo2.sizes.foot = 290;\n//위에서 info2의 value를 수정하는 코드 때문에 info1도 수정된다.\nconsole.log(info1);\n</code></pre>\n<p>이를 해결하기 위해서는 객체의 각 값을 검사하면서 값이 객체인 경우 그 구조도 복사해 주는 방법을 사용해야 한다. 이를 깊은 복사라고 한다.</p>\n<p>이를 구현하기 위해서는 Structured cloning algorithm을 사용하거나 lodash의 cloneDeep 함수를 사용하면 된다.</p>\n<h1>3. 가비지 컬렉션</h1>\n<p>JS는 사용하지 않는 메모리를 가비지 컬렉션으로 관리한다. 이 가비지 컬렉터는 모든 객체를 모니터링하고 도달할 수 없는 객체는 삭제한다. 여기서 도달 가능하다는 것은 어떻게든 접근하거나 사용할 수 있는 값이라는 것이다.</p>\n<p>예를 들어서 현재 함수의 지역 변수, 매개변수, 중첩함수 체인 내에 있는 변수, 매개변수, 전역 변수 등은 삭제되지 않는다.</p>\n<p>그럼 도달 불가능하다는 것은 무엇을 뜻하는가? 해당 객체를 참조하는 곳이 더 이상 없다는 의미이다.</p>\n<pre><code class=\"language-js\">let info1 = {\n  name: \"김성현\",\n  blog: \"https://www.witch.work/\",\n};\n// 이제 info1이 가리키던 객체를 참조하는 곳은 없다.\ninfo1=null;\n</code></pre>\n<p>하지만 객체의 참조가 다른 변수에 들어 있는 등 다른 경로를 통해 거기에 도달할 수 있다면 객체는 가비지 컬렉팅되지 않는다. 주의할 점은 객체끼리 서로를 참조하는 것으로는 충분하지 않다는 것이다. 우리가 프로그램 내에서 거기 접근할 방식이 있어야 한다.</p>\n<p>이러한 도달 가능성을 알아내는 방식은 다음과 같다.</p>\n<p>먼저 다음과 같은 값들을 루트라고 부른다.</p>\n<ul>\n<li>현재 함수의 지역 변수, 매개변수</li>\n<li>중첩 함수의 체인 내에서 사용되는 변수, 매개변수</li>\n<li>전역 변수</li>\n<li>그 외 기본적으로 접근 가능하다고 생각되는 것들. 콜스택에 들어 있는 개체들.</li>\n</ul>\n<p>그리고 이 루트들을 통해 접근할 수 있는 모든 개체들에 mark한다. 개체들을 정점으로, 참조를 간선으로 하는 그래프가 있고 루트들에서 시작해서 그래프 탐색을 한다고 생각하면 된다.</p>\n<p>이렇게 루트들을 시작으로 하는 모든 탐색을 끝냈을 때 도달할 수 없는 개체들이 가비지 컬렉팅의 대상이 된다.</p>\n<h1>참고</h1>\n<p><a href=\"https://stackoverflow.com/questions/9748358/when-does-the-js-engine-create-a-garbage-collection-root\">https://stackoverflow.com/questions/9748358/when-does-the-js-engine-create-a-garbage-collection-root</a></p>",
    "excerpt": "2023년 새해가 밝았다. 그리고 나는 JS를 정리하고 있다. 아아..\n1. 객체의 개념\n객체는 원시 타입과 달리 다양한 데이터를 저장할 수 있다. key-value 쌍으로 이루어진 프로퍼티를 여러 개 넣을 수 있는 것이다. 이때 key는 문자열, value는 아무 타입이나 가능하다. 해시로 관리되기에 key의 타입은 제한이 있다.\n중괄호 {}나 생성자 new Object()로 객체를 만들 수 있다. 하지만 보통 중괄호를 쓴다.\n1.1. 프로퍼티 다루기\n객체의 ",
    "headingTree": [
      {
        "title": "1. 객체의 개념",
        "url": "#1-객체의-개념",
        "items": [
          {
            "title": "1.1. 프로퍼티 다루기",
            "url": "#11-프로퍼티-다루기",
            "items": []
          },
          {
            "title": "1.2. 대괄호 표기법",
            "url": "#12-대괄호-표기법",
            "items": []
          },
          {
            "title": "1.3. 계산된 프로퍼티",
            "url": "#13-계산된-프로퍼티",
            "items": []
          },
          {
            "title": "1.4. 프로퍼티 이름 제약",
            "url": "#14-프로퍼티-이름-제약",
            "items": []
          },
          {
            "title": "1.5. 프로퍼티 존재 여부 확인",
            "url": "#15-프로퍼티-존재-여부-확인",
            "items": []
          },
          {
            "title": "1.6. 객체 순회",
            "url": "#16-객체-순회",
            "items": []
          },
          {
            "title": "1.7. 객체 정렬 방식",
            "url": "#17-객체-정렬-방식",
            "items": []
          }
        ]
      },
      {
        "title": "2. 객체와 참조",
        "url": "#2-객체와-참조",
        "items": [
          {
            "title": "2.1. 객체 비교",
            "url": "#21-객체-비교",
            "items": []
          },
          {
            "title": "2.2. 객체 복사",
            "url": "#22-객체-복사",
            "items": []
          },
          {
            "title": "2.3. 객체의 깊은 복사",
            "url": "#23-객체의-깊은-복사",
            "items": []
          }
        ]
      },
      {
        "title": "3. 가비지 컬렉션",
        "url": "#3-가비지-컬렉션",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 306
    },
    "url": "/posts/javascript-7",
    "thumbnail": {
      "local": "/thumbnails/javascript-7-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-javascript-7-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAhUlEQVR4nGNoa2vz9/f39PT09/dPSkpSVVUNCgoSFRVlKCsrU1ZWTk1NNTQ05OTkFBUVNTQ0PHPmDMPKlSsnTJjw6NGje/fuXQeDo0eP/v//n+HMmTO5eXm7du36DwO/wYBh2vRZ1jY2+fn5b9++hYuCdCxcsmLp0mWbNm26dOkSRAKiDwDMH1ygWRcVRQAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "javascript-check-undefined",
    "title": "JS 탐구생활 - undefined 판정 방식과 이유",
    "date": "2024-02-04T00:00:00Z",
    "description": "undefined 판정에는 단순 비교 이상의 것이 있다",
    "tags": [
      "javascript"
    ],
    "html": "<h1>1. 시작</h1>\n<p>JS를 쓰다 보면 특정 변수가 <code>undefined</code>인지 판정해야 할 때가 있다. 함수 선언에 명시된 인자가 넘어왔는지를 판단할 때, 브라우저 호환성 문제에 대응하기 위해 특정 키워드나 메서드가 존재하는지 확인할 때 등이다.</p>\n<p>이때 단순히 <code>===</code> 연산자를 사용해서 <code>undefined</code>와 비교하는 방식으로 판정할 수 있다. 예를 들어서 함수에 첫번째 인자가 넘어왔는지 확인하는 코드를 이렇게 짤 수 있다.</p>\n<pre><code class=\"language-js\">function foo(a) {\n  if (a === undefined) {\n    // 함수에 인자 a가 넘어오지 않았을 때의 처리\n  }\n  else {\n    // 함수에 인자 a가 넘어왔을 때의 처리\n  }\n}\n</code></pre>\n<p>이런 경우 <code>if (!a)</code> 등으로도 판정할 수 있다. 하지만 <code>null</code>이나 빈 문자열 등도 조건문을 통과하는 것을 막기 위해서는 명시적으로 <code>undefined</code>와 비교하는 것이 낫다. 여기까지는 일반적인 이야기이다.</p>\n<p>그런데 옛날 코드들을 보면 다른 방식들을 볼 수 있다. 예를 들어서 <code>typeof a === 'undefined'</code> 나 <code>a === void 0</code> 등이다. 이런 방식들은 어떤 이유로 사용되었을까?</p>\n<p>이는 ES3까지는 전역 객체 프로퍼티 <code>undefined</code>가 수정 가능했기 때문이다. 즉 전역에서의 <code>undefined</code>라는 이름을 다른 값으로 덮어쓸 수 있었다. <code>undefined</code>는 JS의 예약어도 아니기 때문에 가능했다. 그래서 이렇게 덮어씌워진 <code>undefined</code>와 비교되는 것을 피하기 위해서 앞서 언급한 다른 비교 방식들을 사용하였다.</p>\n<p>그럼 이 말이 무슨 의미가 있는지, 이제부터는 좀 더 깊이 알아보자. 이런 것들을 보려고 한다.</p>\n<ul>\n<li>왜 <code>undefined</code> 판정에 <code>===</code> 연산자만으로는 부족했는가</li>\n<li>이전에 쓰였던 <code>undefined</code> 판정 방식들</li>\n<li>각 방식의 장단점</li>\n</ul>\n<h1>2. 왜 <code>=== undefined</code> 만으로 부족했는가</h1>\n<p>왜 <code>undefined</code> 판정에 <code>===</code> 연산자를 통한 단순 비교 외의 방식들이 사용되었을까? 앞서 이야기했듯 ES3까지 <code>undefined</code>가 전역에서 수정 가능했기 때문이다. 이 이야기는 <code>undefined</code>에 관한 현재와 과거의 명세를 비교해 봄으로써 알 수 있다.</p>\n<h2>2.1. undefined의 현재 명세</h2>\n<p>먼저 현재의 명세에서 <code>undefined</code>를 어떻게 정의하고 있는지 살펴보자.</p>\n<p><a href=\"https://tc39.es/ecma262/\">ECMAScript 명세</a>에서는 <code>undefined</code> 값을 아직 값을 할당하지 않은 변수에 쓰이는 값으로 정의하고 있다.<sup><a href=\"#user-content-fn-1\" id=\"user-content-fnref-1\" data-footnote-ref=\"\" aria-describedby=\"footnote-label\">1</a></sup></p>\n<blockquote>\n<p>4.4.13 undefined value</p>\n<p>primitive value used when a variable has not been assigned a value</p>\n</blockquote>\n<p>그리고 바로 다음 섹션에서 <code>undefined</code> 타입이란 <code>undefined</code> 값 하나만을 가지는 타입이라고 정의한다. 이 <code>undefined</code> 타입은 ECMAScript 명세에서 정의하는 타입으로도 나와 있다.</p>\n<blockquote>\n<p>6.1.1 The Undefined Type</p>\n<p>The Undefined type has exactly one value, called undefined. Any variable that has not been assigned a value has the value undefined.</p>\n</blockquote>\n<p>그럼 우리가 쓰는 이 <code>undefined</code> 값은 어디서 오는 걸까? 이는 전역 객체의 프로퍼티이다.</p>\n<pre><code class=\"language-js\">> Object.getOwnPropertyDescriptor(globalThis, 'undefined')\n{\n  value: undefined,\n  writable: false,\n  enumerable: false,\n  configurable: false\n}\n</code></pre>\n<p>전역 객체의 프로퍼티에 대한 명세에서 <code>undefined</code>는 <code>undefined</code> 값을 가지는 프로퍼티로 정의되어 있다.</p>\n<blockquote>\n<p>19.1 Value Properties of the Global Object</p>\n<p>(생략)</p>\n<p>19.1.4 undefined</p>\n<p>The value of undefined is undefined (see 6.1.1). This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</p>\n</blockquote>\n<p>즉 <code>undefined</code>는 undefined 타입이 포함하는 유일한 값이며 전역 객체의 <code>undefined</code> 프로퍼티를 통해서 접근할 수 있는 값이다. 이 프로퍼티는 <code>[[Writable]]</code>, <code>[[Enumerable]]</code>, <code>[[Configurable]]</code> 설명자가 모두 <code>false</code>로 정의되어 있다. 따라서 프로퍼티의 수정이나 삭제가 불가능하고 설명자 수정도 불가능하다는 것을 알 수 있다.</p>\n<p>따라서 지금 ES5에서는 전역 프로퍼티 <code>undefined</code>의 수정이 불가능하다. 그럼 ES3까지는 어땠을까?</p>\n<h2>2.2. undefined가 수정 가능하던 시절</h2>\n<p><a href=\"https://www-archive.mozilla.org/js/language/e262-3.pdf\">ES3의 명세</a>에서는 전역 객체 프로퍼티 <code>undefined</code>를 다음과 같이 정의했다.</p>\n<blockquote>\n<p>15.1.1 Value Properties of the Global Object</p>\n<p>(생략)</p>\n<p>15.1.1.3 undefined</p>\n<p>The initial value of undefined is undefined (section 8.1). This property has the attributes { DontEnum, DontDelete }.</p>\n</blockquote>\n<p>이때 지금의 <code>[[Writable]]</code>설명자에 해당하는 <code>[[ReadOnly]]</code> 라는 property attribute가 있었다. 그런데 당시의 <code>undefined</code>는 명세상 해당 어트리뷰트를 갖고 있지 않은 걸 볼 수 있다. 지금으로 따지면 <code>[[Enumerable]]</code>와 <code>[[Configurable]]</code>는 <code>false</code>이고 <code>[[Writable]]</code>는 <code>true</code>였던 것이다.</p>\n<p>따라서 이 시절에는 <code>undefined</code> 전역 객체 프로퍼티를 다른 값으로 덮어쓸 수 있었다.</p>\n<pre><code class=\"language-js\">// ES3 시절에는 이런 코드가 가능했다\nvar undefined = 123;\nconsole.log(undefined); // 123\nconsole.log(undefined === 123); // true\n</code></pre>\n<p><code>undefined</code>라는 이름을 코드 상에서 쓰게 되면 전역 객체 프로퍼티 <code>undefined</code>라는 key를 통해 <code>undefined</code>값에 접근하게 되는데, 이 key가 다른 값에 할당되어 있어서 <code>undefined</code>값이 아닌 다른 값이 반환되는 상황이 가능했던 것이다.</p>\n<p>이는 특정 값이 <code>undefined</code>인지를 판정할 때 <code>a === undefined</code>와 같이 비교한다면 문제가 될 수 있었다. <code>undefined</code>가 다른 값일 수 있었으니까. 앞서 보았던 <code>typeof a</code>를 활용하는 등의 방식으로 이를 피할 수 있었다.</p>\n<h2>2.3. undefined의 수정 가능성</h2>\n<p>앞서 ES3까지는 전역 프로퍼티 <code>undefined</code>를 수정할 수 있었다는 걸 보았다. 그런데 이런 일이 일어날 가능성은 있었을까?</p>\n<p><code>undefined</code>를 실수로 수정하게 되는 상황이 정말 일어나기 힘든 일이었다면 앞서 설명한 <code>undefined</code> 판정 방식들이 필요 없었을 것이다.</p>\n<p>그런데 이는 실수로 흔히 일어날 수 있는 일이었다<sup><a href=\"#user-content-fn-2\" id=\"user-content-fnref-2\" data-footnote-ref=\"\" aria-describedby=\"footnote-label\">2</a></sup>. 다음과 같이 <code>this</code>의 프로퍼티에 값을 할당하는 함수가 있다고 하자.</p>\n<pre><code class=\"language-js\">function assign(key, value) {\n  this[key] = value;\n}\n</code></pre>\n<p>그런데 이 함수가 전역 스코프에서 호출된다면? <code>this</code>는 전역 객체를 가리키게 된다. 이때 <code>key</code>가 <code>undefined</code>라면 전역 <code>undefined</code> 프로퍼티에 값이 할당되어 버린다.</p>\n<p>물론 <code>assign('undefined', 1)</code>과 같이 개발자가 명시적으로 <code>undefined</code>를 넘기려고 할 일은 잘 없을 것이다.</p>\n<p>하지만 <code>obj['foo']</code>를 <code>assign</code>의 <code>key</code>인수로 넣었는데 <code>obj</code>에 <code>foo</code> 프로퍼티가 없는 경우 등 실수로 <code>undefined</code>를 인수로 넘길 수 있는 가능성은 많다.</p>\n<pre><code class=\"language-js\">var obj={\n  name: 'foo',\n}\n\nassign('abc', 1); // windiw.abc === 1\nassign(obj.foo, 'bar'); // window.undefined === 'bar'\n</code></pre>\n<p>이런 경우 전역 객체 프로퍼티 <code>undefined</code>의 값을 덮어쓰게 되면서 코드 전체에 영향을 미칠 수 있었다. 따라서 이런 상황에 대처하기 위해 <code>undefined</code>를 판정할 때 <code>===</code> 연산자만으로는 부족했던 것이다. 이제 그때 쓰였던 방식들을 살펴보자.</p>\n<h1>3. 이전의 방식들</h1>\n<p><code>undefined</code>가 전역에서 수정될 수 없도록 한 건 ES5부터이다. 그래서 ES5가 널리 쓰이기 전의 자료들을 보면 다양한 <code>undefined</code> 판정 방식을 볼 수 있다.</p>\n<h2>3.1. typeof 연산자 사용</h2>\n<p>현재 실행 환경에 특정 기능의 메서드나 프로퍼티가 존재하는지 판정하기 위해 <code>undefined</code>와 비교하는 예제에서 이런 방식을 볼 수 있다<sup><a href=\"#user-content-fn-3\" id=\"user-content-fnref-3\" data-footnote-ref=\"\" aria-describedby=\"footnote-label\">3</a></sup>.</p>\n<pre><code class=\"language-js\">// Javascript Patterns, 215p\nif(typeof document.attachEvent !== 'undefined') {\n  document.attachEvent('onclick', console.log);\n}\n</code></pre>\n<p>앞서 제시한 코드의 출처 말고도 다양한 도서들<sup><a href=\"#user-content-fn-4\" id=\"user-content-fnref-4\" data-footnote-ref=\"\" aria-describedby=\"footnote-label\">4</a></sup>에서 <code>typeof</code>를 이용한 <code>undefined</code> 판정 방식을 볼 수 있다.</p>\n<p>도서 외에도 jQuery의 기여 가이드<sup><a href=\"#user-content-fn-5\" id=\"user-content-fnref-5\" data-footnote-ref=\"\" aria-describedby=\"footnote-label\">5</a></sup>의 스타일 가이드에서 전역 변수에 대해서는 <code>typeof</code>를 이용한 판정을 권장하는 등 여러 곳에서 이 방식을 볼 수 있다.</p>\n<p><img src=\"/static/jquery-type-check-1ba39b35.png\" alt=\"jquery의 타입 판정 가이드\"></p>\n<p><code>typeof</code>는 전역 객체 <code>undefined</code> 프로퍼티가 갖고 있는 값과 상관없이 작동하여 값이 <code>undefined</code>인지 판정할 수 있었기에 이런 방식이 쓰였다.</p>\n<h2>3.2. void 연산자 사용</h2>\n<p><code>void 0</code>이나 <code>void(0)</code>과의 비교도 자주 쓰이던 방식이다. <code>void</code>는 피연산자를 평가하고 <code>undefined</code>를 반환하는 연산자이기 때문에 이를 이용해서 <code>undefined</code> 값을 얻은 후 이용하는 것이다.</p>\n<p>babel의 소스 코드 등에서 이를 찾을 수 있다. 다음은 클래스 관련 코드를 babel로 변환했을 때, 생성자를 처리하기 위한 코드의 일부이다<sup><a href=\"#user-content-fn-6\" id=\"user-content-fnref-6\" data-footnote-ref=\"\" aria-describedby=\"footnote-label\">6</a></sup>. <code>self</code>가 <code>undefined</code>인지 판정할 때 <code>void 0</code>과 비교하는 코드를 볼 수 있다.</p>\n<pre><code class=\"language-js\">helpers.assertThisInitialized = helper(\"7.0.0-beta.0\")`\n  export default function _assertThisInitialized(self) {\n    if (self === void 0) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n  }\n`;\n</code></pre>\n<p>이 외에도 해당 파일의 다른 babel 헬퍼 함수들에서도 <code>void 0</code>과의 비교를 통한 <code>undefined</code> 판정을 볼 수 있다.</p>\n<p><code>void 0</code>은 전역 <code>undefined</code> 프로퍼티와 상관없이 동작했다. 또 <code>void</code>는 연산자였고 예약어였기 때문에 기능 수정 같은 게 불가능했고 따라서 늘 확실하게 <code>undefined</code> 값을 얻을 수 있었다.</p>\n<h2>3.3. 변수 shadowing<sup><a href=\"#user-content-fn-7\" id=\"user-content-fnref-7\" data-footnote-ref=\"\" aria-describedby=\"footnote-label\">7</a></sup></h2>\n<p><code>undefined</code>는 ES3까지 전역에서 값을 덮어쓸 수 있었다. 하지만 이렇게 덮어쓴 전역의 <code>undefined</code>도 다른 스코프에서는 또 shadowing될 수 있었다.</p>\n<p>이를 이용해 <code>undefined</code>를 덮어쓰고 비교하여 판정하는 방식도 있다. 다음은 이런 방식을 사용한 예제이다. 일부러 즉시 실행 함수의 인자 이름을 <code>undefined</code>로 하고 인자를 넘기지 않음으로써 전역 <code>undefined</code>를 덮어쓴 후 <code>undefined</code>를 판정하는 코드이다.</p>\n<pre><code class=\"language-js\">// undefined를 전역 변수 선언으로 덮어쓸 수 있었던 ES3까지의 코드\nvar undefined = 1;\n\nfunction check(a){\n  var result=(function(undefined){\n    return a === undefined;\n  })();\n\n  return result;\n}\n</code></pre>\n<p>따라서 <code>check</code> 함수는 <code>a</code>가 진짜 <code>undefined</code>일 때 <code>true</code>를 반환한다. backbonejs 등에서도 이 방식을 볼 수 있다고 한다.<sup><a href=\"#user-content-fn-8\" id=\"user-content-fnref-8\" data-footnote-ref=\"\" aria-describedby=\"footnote-label\">8</a></sup></p>\n<h1>4. 각 방식의 장단점</h1>\n<p>현재 기준으로는 <code>===</code>를 이용해서 <code>undefined</code>와 단순 비교를 통해 판정하는 게 가장 간단하고 직관적이다. 하지만 지금은 ES3 시절 전역 객체 프로퍼티 <code>undefined</code>를 덮어쓸 수 있었던 문제를 극복하기 위해 나왔던 방식들을 다루고 있다. 따라서 당시의 방식들에 대해 이야기한다.</p>\n<h2>4.1. typeof 방식</h2>\n<p>앞서 언급한 다른 방식들과 <code>typeof</code>를 이용한 방식이 다른 게 하나 있다. 이 방식은 아직 선언되지 않은 변수에 대해서도 오류 발생 없이 작동한다는 것이다. 다른 방식의 경우 <code>undefined</code> 판정 시도 시 ReferenceError가 발생한다.</p>\n<pre><code class=\"language-js\">typeof undeclaredVariable === 'undefined'; // true\nundeclaredVariable === undefined; // ReferenceError\nundeclaredVariable === void 0; // ReferenceError\n</code></pre>\n<p>이는 경우에 따라 장점일 수 있다. 예를 들어 브라우저에 특정 기능이 있는지 판단하는 feature detection을 할 경우 브라우저에 따라 스코프에 해당 이름이 존재하지 않을 수도 있다. 이럴 경우 <code>typeof</code>를 이용한 판정이 목적에 맞고 더 안전하다.</p>\n<p>예를 들어 commonJS 환경인지 판정할 때 다음과 같은 코드를 볼 수 있다. 이 경우 <code>module</code>이라는 이름이 아예 스코프에 없을 수도 있기에 <code>typeof</code>를 이용한 판정이 적절하다.</p>\n<pre><code class=\"language-js\">if (typeof module !== 'undefined' &#x26;&#x26; module.exports) {\n  // commonJS 환경\n}\n</code></pre>\n<p>그런데 <code>typeof</code>를 이용하는 방식의 이런 점은 대부분의 경우에는 모호할 수 있다는 단점이 될 수 있다. 다음과 같은 코드를 보자. 다음과 같은 조건문은 <code>foo</code>가 아예 선언되어 있지 않을 때와 <code>foo</code>가 선언되어 있지만 <code>undefined</code>일 때를 구분하지 못한다.</p>\n<pre><code class=\"language-js\">if (typeof foo === 'undefined') {\n  // 조건문이 참일 때\n}\n</code></pre>\n<p>만약 오타로 인해 조건문을 잘못 써서 아예 선언되지 않은 변수를 판정하려고 했을 때, 이런 실수를 찾아내기 어려울 수 있다.</p>\n<pre><code class=\"language-js\">if (typeof fooo === 'undefined') {\n  // foo가 아닌 fooo를 적어 버렸지만 이 조건문은 참이 되어버린다\n}\n</code></pre>\n<p>작은 차이가 하나 더 있는데 <code>document.all</code>이라는 특이한 객체에 대해서도 <code>typeof</code>를 이용한 판정이 가능하다. <code>document.all</code>은 페이지의 모든 요소를 배열로 가지고 있는 객체인데, 이 객체는 IE에서 쓰였고 호환성을 위해 남아 있다.</p>\n<p>이 객체는 실제로 <code>undefined</code>가 아니기 때문에 <code>document.all === undefined</code>는 <code>false</code>를 반환한다. 하지만 <code>typeof document.all === 'undefined'</code>는 <code>true</code>를 반환한다. 이런 사실은 <code>document.all</code>이 있는지를 통해 IE를 판정하는데 쓰일 수 있다. 물론 <code>document.all</code>이 거의 묻힌 지금은 큰 의미 없다.</p>\n<p>또한 이 방식에는 피연산자의 타입을 판정하는 과정이 있기 때문에 느릴 '수도' 있지만 일반적인 엔진에서는 큰 차이가 없다.</p>\n<h2>4.2. 다른 방식들</h2>\n<p>변수 shadowing 방식은 코드도 길고 가독성도 떨어졌다. 그리고 역시 함수 스코프 내에서는 <code>undefined</code>를 덮어쓸 수 있었기 때문에 그렇게까지 안전한 방식도 아니었다. 따라서 다른 방식들에 비해 떨어지는 점이 많았고 쓰이는 예시도 거의 찾을 수 없었다.</p>\n<p><code>void 0</code>을 이용한 방식은 값이 <code>undefined</code>인지를 판정한다는 점에서는 가장 안전하고 명확했다. <code>void</code>는 연산자이고 예약어여서 수정 불가능했고 언제나 안전하게 <code>undefined</code>를 얻을 수 있게 해주었다.</p>\n<p><code>void 0</code>과의 비교는 '값을 다른 어떤 값이랑 비교한다'는 것도 명확히 보여주었다. 하지만 <code>undefined</code>를 써서 비교하는 것보다는 직관성이 덜하기는 했다. 따라서 <code>isUndefined</code>와 같이 이름을 통해 목적을 드러내주는 함수들을 만드는 방식도 쓰였다.</p>\n<h1>5. 여담</h1>\n<h2>5.1. undefined는 지금도 shadowing 가능하다</h2>\n<p>ES5부터는 전역 프로퍼티 <code>undefined</code>가 수정할 수 없게 되었다. 하지만 이는 전역 스코프에서만 해당하는 일이다. <code>undefined</code>라는 이름은 여전히 예약어가 아니기 때문에 다른 스코프에서는 여전히 <code>undefined</code>라는 이름을 덮어쓸 수 있다.</p>\n<pre><code class=\"language-js\">// 함수 스코프로는 이렇게\nfunction foo() {\n  var undefined = 123;\n  console.log(undefined); // 123\n}\n\nfoo();\n\n// 블록 스코프로는 이렇게 중괄호만 이용해도 된다\n{\n  let undefined = 123;\n  console.log(undefined); // 123\n}\n</code></pre>\n<h1>참고</h1>\n<p>variable === undefined vs. typeof variable === \"undefined\" <a href=\"https://stackoverflow.com/questions/4725603/variable-undefined-vs-typeof-variable-undefined\">https://stackoverflow.com/questions/4725603/variable-undefined-vs-typeof-variable-undefined</a></p>\n<p>Checking for undefined: === versus typeof versus falsiness <a href=\"https://2ality.com/2013/04/check-undefined\">https://2ality.com/2013/04/check-undefined</a></p>\n<p>The void operator in JavaScript <a href=\"https://2ality.com/2011/05/void-operator.html\">https://2ality.com/2011/05/void-operator.html</a></p>\n<p>MDN undefined <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/undefined\">https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/undefined</a></p>\n<p>ECMAScript 3 명세 <a href=\"https://www-archive.mozilla.org/js/language/e262-3.pdf\">https://www-archive.mozilla.org/js/language/e262-3.pdf</a></p>\n<p>How can I check for \"undefined\" in JavaScript? <a href=\"https://stackoverflow.com/questions/3390396/how-can-i-check-for-undefined-in-javascript\">https://stackoverflow.com/questions/3390396/how-can-i-check-for-undefined-in-javascript</a></p>\n<p>Detecting an undefined object property <a href=\"https://stackoverflow.com/questions/27509/detecting-an-undefined-object-property\">https://stackoverflow.com/questions/27509/detecting-an-undefined-object-property</a></p>\n<p>What does \"javascript:void(0)\" mean? <a href=\"https://stackoverflow.com/questions/1291942/what-does-javascriptvoid0-mean\">https://stackoverflow.com/questions/1291942/what-does-javascriptvoid0-mean</a></p>\n<p>JavaScript <code>undefined</code> vs <code>void 0</code> <a href=\"https://stackoverflow.com/questions/5716976/javascript-undefined-vs-void-0\">https://stackoverflow.com/questions/5716976/javascript-undefined-vs-void-0</a></p>\n<section data-footnotes=\"\" class=\"footnotes\"><h2 class=\"sr-only\" id=\"footnote-label\">Footnotes</h2>\n<ol>\n<li id=\"user-content-fn-1\">\n<p>흔히 같이 묶이는 <code>null</code>은 어떤 객체 값이 의도적으로 없음(intentional absence of any object value)을 나타내는 값이라고 명세에서 정의하고 있다. <a href=\"#user-content-fnref-1\" data-footnote-backref=\"\" aria-label=\"Back to reference 1\" class=\"data-footnote-backref\">↩</a></p>\n</li>\n<li id=\"user-content-fn-2\">\n<p><a href=\"https://2ality.com/2013/04/check-undefined\">https://2ality.com/2013/04/check-undefined</a> 의 WebReflection의 댓글 <a href=\"#user-content-fnref-2\" data-footnote-backref=\"\" aria-label=\"Back to reference 2\" class=\"data-footnote-backref\">↩</a></p>\n</li>\n<li id=\"user-content-fn-3\">\n<p>스토얀 스테파노프 지음, 김준기, 변유진 옮김, \"Javascroipt Patterns, 자바스크립트 코딩 기법과 핵심 패턴\", 인사이트, 2011 <a href=\"#user-content-fnref-3\" data-footnote-backref=\"\" aria-label=\"Back to reference 3\" class=\"data-footnote-backref\">↩</a></p>\n</li>\n<li id=\"user-content-fn-4\">\n<p>데이비드 허먼의 \"이펙티브 자바스크립트\", 악셀 라우슈마이어의 \"자바스크립트를 말하다\" 등 <a href=\"#user-content-fnref-4\" data-footnote-backref=\"\" aria-label=\"Back to reference 4\" class=\"data-footnote-backref\">↩</a></p>\n</li>\n<li id=\"user-content-fn-5\">\n<p>jQuery 기여 가이드의 Type Checks <a href=\"https://contribute.jquery.org/style-guide/js/#type-checks\">https://contribute.jquery.org/style-guide/js/#type-checks</a> <a href=\"#user-content-fnref-5\" data-footnote-backref=\"\" aria-label=\"Back to reference 5\" class=\"data-footnote-backref\">↩</a></p>\n</li>\n<li id=\"user-content-fn-6\">\n<p><a href=\"https://github.com/rubennorte/babel/blob/738060ebfa7ac133d7dd6a2590835acaa08f15f3/packages/babel-helpers/src/helpers.js#L645\">https://github.com/rubennorte/babel/blob/738060ebfa7ac133d7dd6a2590835acaa08f15f3/packages/babel-helpers/src/helpers.js#L645</a> <a href=\"#user-content-fnref-6\" data-footnote-backref=\"\" aria-label=\"Back to reference 6\" class=\"data-footnote-backref\">↩</a></p>\n</li>\n<li id=\"user-content-fn-7\">\n<p>\"자바스크립트를 말하다\"등의 저자인 악셀 라우슈마이어의 블로그 <a href=\"https://2ality.com/2013/04/check-undefined\">https://2ality.com/2013/04/check-undefined</a> <a href=\"#user-content-fnref-7\" data-footnote-backref=\"\" aria-label=\"Back to reference 7\" class=\"data-footnote-backref\">↩</a></p>\n</li>\n<li id=\"user-content-fn-8\">\n<p><a href=\"https://phuoc.ng/collection/this-vs-that/variable-undefined-vs-typeof-variable-undefined/\">https://phuoc.ng/collection/this-vs-that/variable-undefined-vs-typeof-variable-undefined/</a> <a href=\"#user-content-fnref-8\" data-footnote-backref=\"\" aria-label=\"Back to reference 8\" class=\"data-footnote-backref\">↩</a></p>\n</li>\n</ol>\n</section>",
    "excerpt": "1. 시작\nJS를 쓰다 보면 특정 변수가 undefined인지 판정해야 할 때가 있다. 함수 선언에 명시된 인자가 넘어왔는지를 판단할 때, 브라우저 호환성 문제에 대응하기 위해 특정 키워드나 메서드가 존재하는지 확인할 때 등이다.\n이때 단순히 === 연산자를 사용해서 undefined와 비교하는 방식으로 판정할 수 있다. 예를 들어서 함수에 첫번째 인자가 넘어왔는지 확인하는 코드를 이렇게 짤 수 있다.\nfunction foo(a) {\n  if (a === und",
    "headingTree": [
      {
        "title": "1. 시작",
        "url": "#1-시작",
        "items": []
      },
      {
        "title": "2. 왜 === undefined 만으로 부족했는가",
        "url": "#2-왜--undefined-만으로-부족했는가",
        "items": [
          {
            "title": "2.1. undefined의 현재 명세",
            "url": "#21-undefined의-현재-명세",
            "items": []
          },
          {
            "title": "2.2. undefined가 수정 가능하던 시절",
            "url": "#22-undefined가-수정-가능하던-시절",
            "items": []
          },
          {
            "title": "2.3. undefined의 수정 가능성",
            "url": "#23-undefined의-수정-가능성",
            "items": []
          }
        ]
      },
      {
        "title": "3. 이전의 방식들",
        "url": "#3-이전의-방식들",
        "items": [
          {
            "title": "3.1. typeof 연산자 사용",
            "url": "#31-typeof-연산자-사용",
            "items": []
          },
          {
            "title": "3.2. void 연산자 사용",
            "url": "#32-void-연산자-사용",
            "items": []
          },
          {
            "title": "3.3. 변수 shadowing[^7]",
            "url": "#33-변수-shadowing7",
            "items": []
          }
        ]
      },
      {
        "title": "4. 각 방식의 장단점",
        "url": "#4-각-방식의-장단점",
        "items": [
          {
            "title": "4.1. typeof 방식",
            "url": "#41-typeof-방식",
            "items": []
          },
          {
            "title": "4.2. 다른 방식들",
            "url": "#42-다른-방식들",
            "items": []
          }
        ]
      },
      {
        "title": "5. 여담",
        "url": "#5-여담",
        "items": [
          {
            "title": "5.1. undefined는 지금도 shadowing 가능하다",
            "url": "#51-undefined는-지금도-shadowing-가능하다",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 2,
      "wordCount": 579
    },
    "url": "/posts/javascript-check-undefined",
    "thumbnail": {
      "local": "/static/jquery-type-check-1ba39b35.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-jquery-type-check-1ba39b35-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAHCAIAAAC6O5sJAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAcklEQVR4nEXMIQ4FIQyEYe6AQ1ZVIpHIkZWc48megTtwI2w9thrNS9hN9pPzJxNUNcYI4Hftvc8V5pwiklLiy8y+ACDnzMxE1Ht/g5mJCBExs6qutb4A4Fmf6Q3unnMuFwC93D2cc8YYrTUApZRa6/P2BwiHX91Sbw0IAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "javascript-dom-property",
    "title": "JS 탐구생활 - JS에서 DOM 속성 접근하기",
    "date": "2022-05-20T00:00:00Z",
    "description": "JS에서 DOM 속성으로 할 수 있는 일",
    "tags": [
      "javascript"
    ],
    "html": "<h1>1. DOM 객체 프로퍼티</h1>\n<p>브라우저에서 대부분의 HTML들에게 주어진 HTML 속성(어트리뷰트)는 그로 인해 만들어지는 DOM 객체의 프로퍼티가 된다. 예를 들어서 다음과 같은 경우를 생각해 볼 수 있다.</p>\n<pre><code class=\"language-html\">&#x3C;h1 id=\"greeting\" style=\"color:blue\">안녕하세요. 저는 마녀입니다.&#x3C;/h1>\n\n&#x3C;script>\n  let greet=document.getElementById('greeting');\n  console.log(greet.style.color)\n  console.log(greeting.style.color) //id와 같은 이름으로 선언된 전역 변수로 엘리먼트에 접근하는 방식\n&#x3C;/script>\n</code></pre>\n<p>h1에 style 속성을 주었고, 위 코드를 실행시켜 보면 그 속성 중 하나인 color에 접근하여 blue가 로그에 찍히는 것을 볼 수 있다.</p>\n<p>이런 DOM 객체 프로퍼티는 사용자가 원하는 대로 만들 수도 있다. 그냥 DOM 객체에 추가하기만 하면 된다.</p>\n<pre><code class=\"language-html\">&#x3C;h1 id=\"greeting\" style=\"color:blue\">안녕하세요. 저는 마녀입니다.&#x3C;/h1>\n\n&#x3C;script>\n  let greet=document.getElementById('greeting');\n  greet.data='이름';\n  greet.sayTagName = function() {\n    console.log(this.tagName);\n  };\n  console.log(greet.data)\n  greet.sayTagName();\n&#x3C;/script>\n</code></pre>\n<p>greet DOM 객체에 추가한 데이터와 함수가 잘 작동함을 위 코드를 실행시켜 보면 확인할 수 있다.</p>\n<h1>2. 속성과 프로퍼티</h1>\n<p>HTML 태그를 통해 엘리먼트를 생성할 때 주어진 속성이 만약 명세서에 있는 표준 속성일 경우, HTML 태그에 주어진 속성은 자동으로 그로 인해 생성된 DOM 객체의 프로퍼티가 된다. 위에서 <code>greet.style.color</code> 가 <code>h1</code> 태그의 속성으로 주어졌지만 <code>greet</code> DOM 객체의 프로퍼티로도 들어가 있는 것이 단적인 예시이다.</p>\n<p>그러나 이렇게 HTML을 파싱해서 DOM 객체를 만들 때 그 HTML의 표준 속성이 아닌 속성이 있다면 그 속성은 DOM 객체의 프로퍼티로 들어가지 않는다. 다음과 같이, h1 태그에 test라는 속성을 주고 거기에 접근을 시도한다. 그러면 test는 h1 태그의 표준 속성이 아니므로 제대로 접근이 안 되는 것을 볼 수 있다. test 속성이 DOM 객체의 프로퍼티로 들어가지 않았기 때문이다.</p>\n<pre><code class=\"language-html\">&#x3C;h1 id=\"greeting\" style=\"color:blue\" test=\"test-property\">\n  안녕하세요. 저는 마녀입니다.\n&#x3C;/h1>\n\n&#x3C;script>\n  let greet=document.getElementById('greeting');\n  console.log(greet.test) //undefined가 출력된다\n&#x3C;/script>\n</code></pre>\n<p>이런 비표준 속성은 <code>getAttribute</code> 라는 메서드를 통해 접근할 수 있다. 이때 HTML 속성의 값은 항상 문자열이며 대소문자를 구분하지 않음에 주의한다. 그리고 속성의 값은 모두 문자열로 변환된다.</p>\n<pre><code class=\"language-html\">&#x3C;h1 id=\"greeting\" style=\"color:blue\" test=\"test-property\">\n  안녕하세요. 저는 마녀입니다.\n&#x3C;/h1>\n\n&#x3C;script>\n  let greet=document.getElementById('greeting');\n  console.log(greet.getAttribute('test')) //test-property가 출력된다\n  console.log(greet.getAttribute('tEsT')) //HTML 속성은 대소문자를 구분하지 않으므로 이렇게 접근하는 것도 가능하다\n&#x3C;/script>\n</code></pre>\n<p><code>getAttribute</code>외에도 엘리먼트에 적용할 수 있는 <code>setAttribute</code>, <code>hasAttribute</code>,  <code>removeAttribute</code> 메서드도 있다. 이 메서드들을 통해 HTML에서 지정한 비표준 속성도 DOM 객체에서 조작할 수 있다.</p>\n<h1>3. 비표준 속성의 사용</h1>\n<p>그런데 이런 비표준 속성이 어디에 사용될까? 우리는 대부분 표준 속성만을 사용해 HTML을 작성하는데 말이다.</p>\n<p>비표준 속성들은 사용자가 직접 지정한 데이터를 HTML에서 JS로 넘기고 싶은 경우나, JS로 조작할 HTML 요소를 표시하는 데에 사용할 수 있다.</p>\n<p>다음 코드는 <code>info</code>속성을 가진 객체들을 모두 순회하면서 그 객체의 <code>info</code> 속성에 해당하는 값을 그 객체의 innerHTML로 넣어주는 코드이다. HTML 태그에 비표준 속성인 <code>info</code>를 넣어 놓고 JS로 조작하는 것이다.</p>\n<pre><code class=\"language-html\">&#x3C;div info=\"name\">&#x3C;/div>\n&#x3C;div info=\"likes\">&#x3C;/div>\n\n&#x3C;script>\n  let myInfo={\n    name:'김성현',\n    likes:'커피'\n  };\n\n  for(let div of document.querySelectorAll('[info]')){\n    let field=div.getAttribute('info');\n    div.innerHTML=myInfo[field];\n  }\n&#x3C;/script>\n</code></pre>\n<p>이렇게 비표준 속성들을 사용해서 객체들을 조작하게 되면, 클래스 등을 이용해서 조작하는 것에 비해서 더 쉽게 변경할 수 있는 객체를 얻을 수 있게 된다고 한다.</p>\n<p>그런데 <code>info</code> 같은 속성은 꽤 일반적인 이름이다. 충분히 어떤 태그의 표준 속성으로 들어갈 수도 있다. 그 외에도, 비표준인 속성을 이용하는 코드를 작성했는데 그 속성이 표준으로 들어가는 경우는 있을 수 있다. 이런 경우를 방지하기 위해서 JS에서는 특정 접두사의 속성을 개발자가 용도에 맞게 사용할 수 있도록 예약해 놓았다. 이게 바로 <code>data-*</code> 속성이다.</p>\n<p>이렇게 작성한 <code>data-</code>속성은 DOM 객체에서 dataset 프로퍼티를 사용하면 접근 가능하다. <code>data-</code> 로 시작하는 속성을 케밥케이스로 작성하면 카멜케이스로 변환되어 모두 DOM 객체의 dataset 프로퍼티에 저장된다.</p>\n<pre><code class=\"language-html\">&#x3C;h1 id='test' data-test-text=\"test\">테스트를 위한 텍스트&#x3C;/h1>\n\n&#x3C;script>\n  let t=document.getElementById('test')\n  console.log(t.dataset.testText)\n&#x3C;/script>\n</code></pre>\n<p>이때 <code>data-test-text</code> 속성이 <code>testText</code> 프로퍼티가 된 것에 주의한다. <code>data-</code> 접두사는 빠지고, 표기가 카멜 표기법으로 바뀌었다.</p>",
    "excerpt": "1. DOM 객체 프로퍼티\n브라우저에서 대부분의 HTML들에게 주어진 HTML 속성(어트리뷰트)는 그로 인해 만들어지는 DOM 객체의 프로퍼티가 된다. 예를 들어서 다음과 같은 경우를 생각해 볼 수 있다.\n<h1 id=\"greeting\" style=\"color:blue\">안녕하세요. 저는 마녀입니다.</h1>\n\n<script>\n  let greet=document.getElementById('greeting');\n  console.log(greet.style.c",
    "headingTree": [
      {
        "title": "1. DOM 객체 프로퍼티",
        "url": "#1-dom-객체-프로퍼티",
        "items": []
      },
      {
        "title": "2. 속성과 프로퍼티",
        "url": "#2-속성과-프로퍼티",
        "items": []
      },
      {
        "title": "3. 비표준 속성의 사용",
        "url": "#3-비표준-속성의-사용",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 220
    },
    "url": "/posts/javascript-dom-property",
    "thumbnail": {
      "local": "/thumbnails/javascript-dom-property-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-javascript-dom-property-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAi0lEQVR4nGPYtGmTg4NDYmKisrJyYWFhe3u7sLDw7NmzGQoLC5mZmZ2cnCQlJTU0NBRBQOnixUsMS5cujY6Ozs3NTU9P37Zt27lz5x4/fvzjxw+G48eP9/b2trS0rFix4vfv3/9hgOHOvXv3799/9erVly9f/v//D5djmLNg8azZs1esWHH16lVkCQC0wl07OyfXGgAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "javascript-event-loop-dive",
    "title": "JS의 이벤트 루프에 다이빙하기",
    "date": "2023-01-31T00:00:00Z",
    "description": "JS 이벤트 루프와의 전투기",
    "tags": [
      "javascript"
    ],
    "html": "<p>setTimeout이 정확하지 않은 이유를 찾다가 이벤트 루프가 나왔고, 이것이 너무 길어져 글이 분리되었다.</p>\n<h1>1. 웹 표준</h1>\n<p>JS 명세서를 눈을 씻고 찾아봐도 setTimeout, setInterval과 같은 비동기 메서드들이 없다. console.log 같은 것도 마찬가지다. 하지만 시중에 나와 있는 거의 모든 JS 호스트 환경이 이런 메서드를 제공한다.</p>\n<p>이는 W3C에서 지정하는 JS 표준(ECMAScript)이 아니라 WHATWG에서 지정하는 WebAPI 표준에 포함되어 있다. 브라우저에서 동작하게 만들어진 API의 묶음 같은 거라고 생각하면 된다. 브라우저 외에도 대부분의 JS 호스트 환경이 이를 지원한다.</p>\n<p>setTimeout 이외에도 console, fetch, XMLHttpRequest 등이 WebAPI에 포함된다.</p>\n<h1>2. WebAPI와 JS 엔진</h1>\n<p>우리는 각 함수들이 어떤 표준에 포함되는지 딱히 신경쓰며 사용하지 않는다. setTimeout이 어떤 표준에 포함되든지 일반적으로 JS를 쓸 때 사용할 수 있지 않은가?</p>\n<p>하지만 내부적으로는 이를 관리해 줘야 한다. WebAPI와 JS엔진은 어떻게 상호작용할까?</p>\n<p><img src=\"/static/webapi-665b89c0.png\" alt=\"webapi\"></p>\n<h2>2.1. JS엔진 영역</h2>\n<p>콜스택은 JS 엔진이 관리하는 영역이다. JS에서 실행되는 코드에서 함수들은 실행 순으로 스택에 쌓이고, 스택 자료구조가 그렇듯이 맨 위부터 하나씩 실행된다. 실행이 종료된 함수는 스택에서 제거된다.</p>\n<p>JS는 싱글스레드이기 때문에 한 번에 한 가지 일만 할 수 있다. 따라서 콜스택은 하나뿐이고 호출되는 함수들을 이 하나뿐인 콜스택으로 관리한다. 이 콜스택 크기에는 제한이 있어서 만약 콜스택 크기가 제한을 넘어가면 'Maximum call stack size exceeded'에러가 발생한다.</p>\n<p>그리고 힙은 변수, 객체들이 저장되는 영역인데 콜스택의 함수들이 실행될 때 필요한 데이터를 제공하는 곳이다.</p>\n<h2>2.2. WebAPI에 대하여</h2>\n<p>위에서, JS는 싱글스레드이기 때문에 한 번에 한 가지 일만 할 수 있다고 했다. 그런데 우리는 브라우저에서 작업을 동시에 진행할 수 있다. 이는 브라우저 또는 JS호스트 환경이 제공하는 API들 덕분이다. 이를 webAPI라고 한다.</p>\n<p>webAPI는 setTimeout, fetch, XMLHttpRequest 등 비동기로 실행되는 API를 관리한다. 이런 API들은 JS 플랫폼 자체에서 관리되어서 JS 콜스택의 진행을 막지 않는다. 즉 한 번에 한 가지 일만 할 수 있는 JS 인터프리터와 별개로 실행되기 때문에 webAPI가 관리하는 API들은 동시에 실행될 수 있는 것이다.</p>\n<p>또한 webAPI는 JS로 작성된 게 아니라 C 등 다른 언어로 작성되었기 때문에 일반적인 JS에서 할 수 없는 것들도 하게 해준다. AJAX 요청을 보낸다든지, DOM을 조작한다든지 하는 것들이 모두 WebAPI의 영역이다.</p>\n<h2>2.3. 태스크 큐(콜백 큐)</h2>\n<p>webAPI를 통해서 우리는 JS 인터프리터(한 번에 한 가지 일만 가능)와 별개로 다른 작업을 동시에 진행할 수 있다. 그런데 WebAPI와 JS 코드는 어떻게 상호작용하는가? ajax 요청으로 서버에서 받아온 정보로 무언가를 해야 하는데 이를 JS는 어떻게 처리하는가? 바로 태스크 큐를 통해서 처리한다.</p>\n<p>WebAPI 함수들은 전부 비동기로 동작하기 때문에 콜백 함수를 가지고 있다. webAPI는 API 호출이 끝난 이후에 이 콜백의 코드를 실행하도록 해준다.</p>\n<p>다음 코드를 실행하면 a,c,b가 차례대로 출력된다.</p>\n<pre><code class=\"language-js\">console.log(\"a\");\nsetTimeout(() => {\n  console.log(\"b\");\n}, 0);\nconsole.log(\"c\");\n</code></pre>\n<p>이는 setTimeout의 동작 때문이다. setTimeout은 JS 인터프리터가 다음 명령을 실행하는 동안 동시에 실행된다. 지정한 delay가 지나면 콜백 함수는 실행될 것이다.</p>\n<p>그런데 이 콜백 함수는 당연히 JS로 쓰여 있을 것이다. 그러므로 JS 인터프리터가 이 콜백 함수를 실행해야 할 것이다. 콜백 함수가 콜스택에 들어가야 한다는 말이다.</p>\n<p>그런데 콜스택에는 이미 다른 함수가 실행되고 있을 수 있다. 그러므로 콜백 함수는 대기열에 들어가게 된다. 이 대기열을 태스크 큐라고 한다.</p>\n<p>setTimeout의 처리는 다음과 같다.</p>\n<ol>\n<li>setTimeout이 실행된다.</li>\n<li>이 setTimeout은 WebAPI에 전달된다.</li>\n<li>WebAPI는 setTimeout이 지정한 delay가 지나면 setTimeout의 콜백 함수를 태스크 큐로 전달한다.</li>\n<li>이벤트 루프가 돌다가 콜스택이 비어있으면 태스크 큐의 top에 있는 콜백 함수를 꺼내서 콜스택에 넣는다.</li>\n</ol>\n<p>예를 들어 다음과 같은 코드가 있다고 하자.</p>\n<pre><code class=\"language-js\">setTimeout(foo, 1000);\n</code></pre>\n<p>그러면 setTimeout은 1초 뒤에 콜백 함수를 실행하라는 정보와 콜백 함수 <code>foo</code>를 WebAPI에 전달한다.</p>\n<p>WebAPI는 이 정보를 이용해서 1초 이후에 콜백 함수를 태스크 큐로 보낸다. setTimeout 외에 다른 비동기 메서드라면 해당하는 정보에 따라 특정 시점에 콜백함수를 태스크 큐로 보낼 것이다. 그리고 이벤트 루프는 콜스택이 비어있을 때 태스크 큐의 top에 있는 콜백 함수를 콜스택으로 보낸다.</p>\n<h2>2.4. 최적화 필요성</h2>\n<p>만약 콜스택이 현재 어떤 코드를 실행시키고 있다면 이벤트 루프는 block된다. 이 말은 콜스택에서 수행되고 있는 작업이 있다면 그것이 끝나고 콜스택이 완전히 비기 전까지 태스크 큐의 작업들은 콜스택에 전달되지 못한다는 것이다. 그리고 큐의 구조를 생각해 볼 때 콜백 함수들은 큐에 쌓인 순서대로 실행되어야 한다.</p>\n<p>이런 것 때문에 최적화가 필요하다. 만약 콜스택에 너무 많은 코드를 실행시키거나 태스크 큐에 너무 많은 작업들을 할당하면 태스크 큐의 작업들을 처리하느라 새로운 작업이 실행되지 못할 것이다.</p>\n<p>예를 들어 스크롤을 내릴 때는 이벤트가 태스크 큐에 엄청나게 많이 추가된다. 스크롤 이벤트 처리에 시간이 좀 걸린다면 태스크 큐에 쌓인 수많은 스크롤 이동 이벤트를 순서대로 처리하느라, 이후에 태스크 큐에 쌓이는 사용자의 클릭 이벤트 등을 빠르게 처리하기 힘들 것이다.</p>\n<p>따라서 함수 호출이 일정 시간 간격 미만으로 이루어지지지 않게 하는 기법인 디바운싱, 연달아 호출되는 함수 중 마지막 혹은 처음만 호출하는 쓰로틀링 등의 기법을 사용해야 한다.</p>\n<h2>2.5. 비동기 메서드</h2>\n<p>어떤 작업을 비동기로 실행하고 싶다면 그 작업을 콜백 함수로 만들어서 setTimeout에 넘긴 후 setTimeout(func, 0)처럼 사용하면 된다.</p>\n<p>그러면 func에 해당하는 작업은 다음 이벤트 사이클에 가능한 빨리 실행될 것이다. 그런데 꼭 비동기 작업 이후에 실행해야 하는 작업도 있다. 예를 들어서 DB에서 데이터를 가져온 후 프론트에서 어떤 가공을 하는 경우이다.</p>\n<p>그런 경우 setTimeout을 중첩하여 사용하면 된다.</p>\n<pre><code class=\"language-js\">function A() {\n  console.log(\"A\");\n}\n\nfunction B() {\n  console.log(\"B\");\n}\n\nfunction C() {\n  console.log(\"C\");\n}\n\nsetTimeout(() => {\n  A();\n  setTimeout(() => {\n    B();\n    setTimeout(() => {\n      C();\n    });\n  });\n});\n</code></pre>\n<p>물론 이런 방식으로 코드를 짜면 익히 알려진 콜백 지옥이 생기고 이런 걸 해결하는 여러 방법으로 Promise, async/await 등이 있다. 하지만 여기서 자세히 다룰 내용은 아니다. 다음에 Promise 작동 방식은 보겠지만, Promise의 사용 패턴 등은 이 글을 벗어난다.</p>\n<h1>3. Promise의 작동</h1>\n<p>그런데 우리는 JS에서 비동기를 실현하는 방법을 하나 더 알고 있다. 이 방법도 순서를 강제할 수 있다. 바로 Promise이다. 이 Promise는 어떻게 처리되는 걸까?</p>\n<h2>3.1. Promise는</h2>\n<p>우리는 앞서 setTimeout을 이용해서 비동기 코드를 짤 수 있다고 보았다. 이런 걸 Promise를 이용해서도 비동기로 짤 수 있다.</p>\n<pre><code class=\"language-js\">new Promise((res, rej) => {\n  res();\n})\n  .then(() => {\n    A();\n  })\n  .then(() => {\n    B();\n  })\n  .then(() => {\n    C();\n  });\n</code></pre>\n<p>물론 async/await을 이용할 수도 있고 같은 Promise를 사용해도 다르게 짤 수도 있다. 하지만 여기서 중요한 건 Promise는 어떻게 작동하는지 이해하는 것이다. 위 코드는 어떻게 비동기로 작동하는가?</p>\n<h2>3.2. job queue</h2>\n<p>Promise는 콜백을 이용한 방식과 다르게 작동한다. 프로미스는 자신들만의 큐를 따로 가지고 있고 이는 job 큐나 프로미스 큐라고 불린다.</p>\n<p>이는 태스크 큐에 비해 우선순위를 가지고 있어서 태스크 큐에 비해 더 우선적으로 다루어진다. 그 말은 이벤트 루프가 프로미스 큐를 먼저 처리하고 난 후 태스크 큐를 처리한다는 뜻이다.</p>\n<p>다음 코드를 보자.</p>\n<pre><code class=\"language-js\">function A() {\n  console.log(\"A\");\n}\n\nfunction B() {\n  console.log(\"B\");\n}\n\nfunction C() {\n  console.log(\"C\");\n}\n\nA();\nsetTimeout(B, 0);\nnew Promise((resolve, reject) => {\n  resolve();\n}).then(() => {\n  C();\n});\nconsole.log(\"D\")\n</code></pre>\n<p>위 코드는 A,D,C,B를 순서대로 출력한다. B,C의 출력은 비동기로 처리되므로 A,D가 가장 먼저 출력되는 것은 당연하다. 그리고 이벤트 루프에서 프로미스 큐가 더 우선 처리되므로 C가 먼저 출력된다. 그리고 나서 태스크 큐가 처리되므로 B가 출력된다.</p>\n<p>이에 관한 내용은 다음과 같은 링크에 더 있지만 아직 지식이 부족해 후로 미룬다.</p>\n<p><a href=\"https://ko.javascript.info/microtask-queue\">https://ko.javascript.info/microtask-queue</a>\n<a href=\"https://ko.javascript.info/event-loop\">https://ko.javascript.info/event-loop</a></p>\n<h1>참고</h1>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/API/setTimeout#%EB%94%9C%EB%A0%88%EC%9D%B4%EA%B0%80_%EC%A7%80%EC%A0%95%ED%95%9C_%EA%B0%92%EB%B3%B4%EB%8B%A4_%EB%8D%94_%EA%B8%B4_%EC%9D%B4%EC%9C%A0\">https://developer.mozilla.org/ko/docs/Web/API/setTimeout#%EB%94%9C%EB%A0%88%EC%9D%B4%EA%B0%80_%EC%A7%80%EC%A0%95%ED%95%9C_%EA%B0%92%EB%B3%B4%EB%8B%A4_%EB%8D%94_%EA%B8%B4_%EC%9D%B4%EC%9C%A0</a></p>\n<p><a href=\"https://ssocoit.tistory.com/249\">https://ssocoit.tistory.com/249</a></p>\n<p><a href=\"https://ko.javascript.info/settimeout-setinterval\">https://ko.javascript.info/settimeout-setinterval</a></p>\n<p><a href=\"https://negabaro.github.io/archive/js-async-detail\">https://negabaro.github.io/archive/js-async-detail</a></p>\n<p><a href=\"https://velog.io/@seongkyun/fetch-setTimeout%EC%9D%80-%ED%91%9C%EC%A4%80-API%EC%9D%BC%EA%B9%8C-len7n3gc\">https://velog.io/@seongkyun/fetch-setTimeout%EC%9D%80-%ED%91%9C%EC%A4%80-API%EC%9D%BC%EA%B9%8C-len7n3gc</a></p>\n<p><a href=\"https://joooing.tistory.com/entry/%EC%9D%B4%EB%B2%A4%ED%8A%B8%EB%A3%A8%ED%94%84-setTimeout%EC%9D%98-%EC%8B%9C%EA%B0%84%EC%9D%80-%EC%A0%95%ED%99%95%ED%95%A0%EA%B9%8C\">https://joooing.tistory.com/entry/%EC%9D%B4%EB%B2%A4%ED%8A%B8%EB%A3%A8%ED%94%84-setTimeout%EC%9D%98-%EC%8B%9C%EA%B0%84%EC%9D%80-%EC%A0%95%ED%99%95%ED%95%A0%EA%B9%8C</a></p>\n<p><a href=\"https://felixgerschau.com/javascript-event-loop-call-stack/#web-apis\">https://felixgerschau.com/javascript-event-loop-call-stack/#web-apis</a></p>\n<p><a href=\"https://www.youtube.com/watch?v=8aGhZQkoFbQ\">https://www.youtube.com/watch?v=8aGhZQkoFbQ</a></p>\n<p><a href=\"https://atoz-developer.tistory.com/94\">https://atoz-developer.tistory.com/94</a></p>",
    "excerpt": "setTimeout이 정확하지 않은 이유를 찾다가 이벤트 루프가 나왔고, 이것이 너무 길어져 글이 분리되었다.\n1. 웹 표준\nJS 명세서를 눈을 씻고 찾아봐도 setTimeout, setInterval과 같은 비동기 메서드들이 없다. console.log 같은 것도 마찬가지다. 하지만 시중에 나와 있는 거의 모든 JS 호스트 환경이 이런 메서드를 제공한다.\n이는 W3C에서 지정하는 JS 표준(ECMAScript)이 아니라 WHATWG에서 지정하는 WebAPI 표",
    "headingTree": [
      {
        "title": "1. 웹 표준",
        "url": "#1-웹-표준",
        "items": []
      },
      {
        "title": "2. WebAPI와 JS 엔진",
        "url": "#2-webapi와-js-엔진",
        "items": [
          {
            "title": "2.1. JS엔진 영역",
            "url": "#21-js엔진-영역",
            "items": []
          },
          {
            "title": "2.2. WebAPI에 대하여",
            "url": "#22-webapi에-대하여",
            "items": []
          },
          {
            "title": "2.3. 태스크 큐(콜백 큐)",
            "url": "#23-태스크-큐콜백-큐",
            "items": []
          },
          {
            "title": "2.4. 최적화 필요성",
            "url": "#24-최적화-필요성",
            "items": []
          },
          {
            "title": "2.5. 비동기 메서드",
            "url": "#25-비동기-메서드",
            "items": []
          }
        ]
      },
      {
        "title": "3. Promise의 작동",
        "url": "#3-promise의-작동",
        "items": [
          {
            "title": "3.1. Promise는",
            "url": "#31-promise는",
            "items": []
          },
          {
            "title": "3.2. job queue",
            "url": "#32-job-queue",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 353
    },
    "url": "/posts/javascript-event-loop-dive",
    "thumbnail": {
      "local": "/static/webapi-665b89c0.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-webapi-665b89c0-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAFCAIAAAD38zoCAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAiElEQVR4nAF9AIL/AO3u7uzr5svHua2pm87MxbnAx77Fy/T08gDy8/Tx7t+zrJe2pp/w6NwAETYAIUX///4A9/f62NXHEAwAwrSx7ubfR22LSmuG+/n3AMzMzMnJxKuci8O2p6+7pK24p5mZmubm5gDg4ODv8PHSxcDWz86jrKCiqpzm5ubo6Oh151flnxPnXwAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "javascript-exotic-object",
    "title": "JS 탐구생활 - exotic object",
    "date": "2023-08-01T00:00:00Z",
    "description": "JS의 exotic object는 무엇일까?",
    "tags": [
      "javascript"
    ],
    "html": "<h1>1. 시작</h1>\n<p><code>Object.create</code>는 인수로 받은 객체를 프로토타입으로 하는 객체를 생성하여 리턴한다.</p>\n<p>그리고 Array 객체는 <code>Array.prototype</code>이 프로토타입인 객체이다. 그러면 다음 출력 결과는 어떻게 될까?</p>\n<pre><code class=\"language-js\">console.log(Array.isArray(Object.create(Array.prototype)));\n</code></pre>\n<p><code>Array.prototype</code>을 상속한 객체가 Array인지 판별하는 것이므로 true가 아닐까? 하지만 답은 false이다. <a href=\"https://forum.kirupa.com/t/js-tip-of-the-day-exotic-objects/643152\">생성자 함수를 이용해서 제대로 상속을 해도 마찬가지다.</a></p>\n<p>이유는 exotic object 때문이다. 뭔가 객체의 고유한 내부 동작이 있어서 프로토타입을 이용해서 쉽게 상속할 수 없는 것이다. 바로 위의 <code>Array</code>가 대표적인 exotic object이다.</p>\n<h1>2. JS 객체의 분류</h1>\n<p>JS에서 객체는 ordinary object와 exotic object로 나뉜다. ordinary object 즉 일반 객체란 우리가 보는 흔한 객체, 그러니까 다음과 같은 것들이다.</p>\n<pre><code class=\"language-js\">{\n  a: 1,\n  b: 2,\n  c: 3\n}\n</code></pre>\n<p>exotic object, 특수 객체는 이런 일반 객체의 동작과는 다른 동작을 가지고 있는 객체이다. <code>Array</code>도 <code>length</code>속성이 일반 객체와 다르게 동작하기 때문에 특수 객체이다.</p>\n<p>위의 <code>Array</code>도 exotic object이고 <code>Proxy</code>, <code>String</code>, <code>Arguments</code> 객체 등이 exotic object이다.</p>\n<p>그래서 대체 앞서 말했던 exotic object가 무엇인가? 명세에 의하면 이는 ordinary object가 아닌 객체이므로 ordinary object부터 알아야 한다.</p>\n<h1>3. ordinary object</h1>\n<p><a href=\"https://tc39.es/ecma262/#ordinary-object\">명세의 ordinary object에 대한 정의를 정리하면 다음과 같다.</a></p>\n<p>모든 객체에는 필수적으로 구현되어야 하는 essential internal method가 있다. 그리고 어떤 객체든지 이 essential internal method들에 대해서는 구현하고 있어야 한다. 이때 모든 객체가 이런 essential internal method들을 같은 알고리즘으로 구현하고 있을 필요는 없다.</p>\n<ul>\n<li><code>[[GetPrototypeOf]]</code></li>\n<li><code>[[SetPrototypeOf]]</code></li>\n<li><code>[[IsExtensible]]</code></li>\n<li><code>[[PreventExtensions]]</code></li>\n<li><code>[[GetOwnProperty]]</code></li>\n<li><code>[[DefineOwnProperty]]</code></li>\n<li><code>[[HasProperty]]</code></li>\n<li><code>[[Get]]</code></li>\n<li><code>[[Set]]</code></li>\n<li><code>[[Delete]]</code></li>\n<li><code>[[OwnPropertyKeys]]</code></li>\n</ul>\n<p>그리고 함수 객체들은 다음과 같은 essential internal method들을 구현해야 한다.</p>\n<ul>\n<li><code>[[Call]]</code></li>\n<li><code>[[Construct]]</code></li>\n</ul>\n<p>ordinary object란 이런 essential internal method들을 특정 기준에 따라 구현한 객체를 말한다. <a href=\"https://tc39.es/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots\">이 기준들은 모두 명세에 나와 있다.</a> 우리가 일반적으로 생각하는 <code>{apple:\"사과\", banana:\"바나나\"}</code>와 같은 객체가 바로 이 기준을 만족하는 ordinary object이다(이것뿐인 건 물론 아니지만).</p>\n<p>그리고 이런 기준을 만족하는 객체의 essential internal method는 보통 해당 메서드 이름 앞에 <code>Ordinary</code>를 붙인 식으로 정의된다. 예를 들어 <a href=\"https://tc39.es/ecma262/#sec-ordinarygetprototypeof\">ordinary object의 <code>[[GetPrototypeOf]]</code>는 <code>OrdinaryGetPrototypeOf</code>로 정의된다.</a></p>\n<h1>4. exotic object</h1>\n<p>exotic object란 바로 위에서 설명한 ordinary object가 아닌 객체이다. 그런데 위에서 말하기를 essential internal method들은 모든 객체에서 구현되어 있어야 한다고 했다.</p>\n<p>그 말인즉, exotic object에도 해당 메서드들은 구현되어 있지만 ordinary object에서 쓰이는 것과 다른 방식으로 구현되어 있다는 뜻이다. 전체 exotic object 중 간단한 것 몇 가지를 예시로 살펴보자.</p>\n<p>참고로 명세에서 정의하는 exotic object 전체는 다음과 같다.</p>\n<ul>\n<li>Bound Function Exotic Objects</li>\n<li>Array Exotic Objects</li>\n<li>String Exotic Objects</li>\n<li>Arguments Exotic Objects</li>\n<li>Integer-Indexed Exotic Objects</li>\n<li>Module Namespace Exotic Objects</li>\n<li>Immutable Prototype Exotic Objects</li>\n<li>Proxy Exotic Objects</li>\n</ul>\n<h2>4.1. Array exotic object</h2>\n<p><a href=\"https://tc39.es/ecma262/#array-exotic-object\">Array Exotic Object</a>의 경우 array index를 프로퍼티 키로 가지는 프로퍼티들을 특별하게 취급하며 <code>length</code>라는 특별한 속성을 갖는 특수 객체이다.</p>\n<p>이 말은 array exotic object의 다른 essential internal method는 모두 ordinary object과 같고 <code>[[DefineOwnProperty]]</code>내부 메서드의 구현이 다르다는 뜻이다.</p>\n<p>다음은 array exotic object의 <code>[[DefineOwnProperty]]</code> 내부 메서드의 명세인데 이를 보면 ordinary object의 해당 메서드와는 다른 동작을 한다는 것을 알 수 있다.</p>\n<p><img src=\"/static/js-array-defineownproperty-79f1220d.png\" alt=\"array exotic object의 DefineOwnProperty\"></p>\n<p>만약 <code>length</code>프로퍼티를 설정하면 <code>ArraySetLength</code>라는 메서드를 호출하여 <code>length</code>프로퍼티를 설정한다.</p>\n<p>간단히 설명하면 만약 설정한 length값이 현재의 length보다 크면 설정한 length까지 배열을 늘리고 남는 칸들은 빈칸으로 채운다. 만약 설정한 length값이 현재의 length보다 작으면 설정한 length까지 배열을 줄이고 남는 칸들은 삭제한다.</p>\n<p>단 이때 삭제할 값들은 configurable이 true인 프로퍼티들만 삭제한다. 이 메서드의 구체적인 동작이 이 글에서 중요한 건 아니므로 자세한 사항은 <a href=\"https://tc39.es/ecma262/#sec-arraysetlength\">명세를 참고하자.</a></p>\n<p>그리고 유효한 배열 인덱스(int 범위의 양의 정수)를 프로퍼티 키로 가지는 프로퍼티들도 특별하게 취급한다. 이 프로퍼티들은 <code>length</code>프로퍼티와 연결되어 있다. 만약 설정하는 배열 인덱스가 <code>length</code> 프로퍼티보다 크면 <code>length</code>를 해당 인덱스보다 1 큰 값으로 설정하는 식이다.</p>\n<p>명세에 대해서 위에 설명한 부분을 제외하면 모두 ordinary object와 동일하다.</p>\n<p>이렇게 <code>[[DefineOwnProperty]]</code> 메서드에서 Array exotic object는 ordinary object와 다른 동작을 한다.</p>\n<h2>4.2. Bound function exotic object</h2>\n<p><a href=\"https://tc39.es/ecma262/#sec-bound-function-exotic-objects\">간단한 설명이므로 아주 자세한 동작은 명세를 참고하자.</a></p>\n<p>처음에 Bound function이라는 용어를 보고 유계(bounded function)의 의미인 줄 알았는데 bind의 과거형으로 쓰인 bound의 의미였다. 아무튼 이 객체는 <code>Function.prototype.bind</code>에서 리턴된 객체이다.</p>\n<p><code>Function.prototype.bind</code>의 용도를 생각해 볼 때 이 객체는 당연히 함수의 조건인 <code>[[Call]]</code>과 <code>[[Construct]]</code> 메서드를 구현해야 한다.</p>\n<p>이때 이 bound function exotic object가 ordinary object와 다른 점은 함수를 호출할 때 bind에서 주어진 함수, 그리고 this와 인수들을 미리 설정해놓고 호출한다는 것이다.</p>\n<p>생성자 함수의 경우 new와 함께 생성자로써 호출한 함수를 저장하는 <code>new.target</code>을 조작하는 부분도 있다.</p>\n<p><img src=\"/static/js-bound-function-8c1a70d3.png\" alt=\"bound function object 명세\"></p>\n<p>참고로 해당 값들은 <code>Function.prototype.bind</code>호출 시 bound function exotic object의 내부 슬롯인 <code>[[BoundTargetFunction]]</code>, <code>[[BoundThis]]</code>, <code>[[BoundArguments]]</code>에 저장된다. 함수를 호출하기 전에 먼저 해당 내부 슬롯들을 이용하여 어떤 함수를 호출할지, this는 무엇인지, 인수는 무엇인지를 결정한다.</p>\n<h2>4.3. Immutable prototype exotic object</h2>\n<p>이 exotic object는 내부 슬롯인 <code>[[Prototype]]</code>이 한번 초기화되면 해당 슬롯을 변경할 수 없는 객체이다.</p>\n<p>이 말은 <code>[[SetPrototypeOf]]</code> 메서드를 호출해도 <code>[[Prototype]]</code>이 변경되지 않는다는 뜻이다. 만약 해당 메서드가 받은 인수가 현재 프로토타입과 같으면 첫번째 인수 객체를 반환하고 그렇지 않으면 에러를 발생시킨다. 절대 프로토타입은 변하지 않는다.</p>\n<p>단 이 객체를 직접 만들 수는 없다. 이는 <code>Object.prototype</code> 그리고 호스트 환경 내부에서만 쓰이는 객체이기 때문이다. 당연히 만약 <code>Object.prototype</code>의 프로토타입을 변경하려고 하면 에러가 발생한다. 해당 객체는 Immutable prototype exotic object니까.</p>\n<h1>5. 동작 예시</h1>\n<p>위에서 보았듯이 Immutable prototype exotic object는 프로토타입을 변경할 수 없다. 단 <code>Object.setPrototypeOf</code>에 현재 프로토타입과 같은 값을 넣으면 에러가 발생하지 않고 프로토타입을 바꾸려고 한 객체가 반환된다.</p>\n<pre><code class=\"language-js\">// Object.prototype 출력됨\nObject.setPrototypeOf(Object.prototype, null);\n// Object prototype may only be an Object or null 에러\nObject.setPrototypeOf(Object.prototype, {x:1});\n</code></pre>\n<p>프로토타입으로는 Array exotic object를 제대로 상속할 수 없다. exotic object의 내부 메서드 구현이 상속되지 못하기 때문이다. 다음 코드를 보면 프로토타입 상속시 Array exotic object 특유의 length 동작방식도 상속되지 않으며 <code>Array.isArray</code>도 통과하지 못하는 걸 볼 수 있다.</p>\n<pre><code class=\"language-js\">function ProtoArray(){\n  // super()의 동작에 가깝게 흉내내기\n  Array.prototype.push.apply(this, arguments);\n}\n\nProtoArray.prototype = Object.create(Array.prototype);\nProtoArray.prototype.constructor = ProtoArray;\n\nconst arr = new ProtoArray(1,2,3);\nconsole.log(arr.length); // 3\narr.push(4);\nconsole.log(arr.length); // 4\narr[10]=5;\nconsole.log(arr.length); // 4\nconsole.log(Array.isArray(arr)); // false\n</code></pre>\n<p>반면 클래스의 <code>extends</code>를 이용하면 이런 exotic object 동작까지 제대로 상속 가능하다. 다음과 같이 하면 length도 제대로 배열처럼 동작하고 <code>Array.isArray</code>도 통과한다.</p>\n<pre><code class=\"language-js\">class ClassArray extends Array{}\n\nconst arr = new ClassArray(1,2,3);\nconsole.log(arr.length); // 3\narr.push(4);\nconsole.log(arr.length); // 4\narr[10]=5;\nconsole.log(arr.length); // 11\nconsole.log(Array.isArray(arr)); // true\n</code></pre>\n<p>이때 <code>Array</code>의 exotic object의 내부 구현 즉 length의 동작과 같은 것을 제대로 상속하기 위해서는 서브클래스의 constructor에서 <code>super()</code>를 반드시 호출해야 한다.</p>\n<p>이는 <code>Array</code>의 exotic object의 내부 구현을 서브클래스의 인스턴스에 연결하기 위함이다. 다만 대부분의 <code>Array.prototype</code> 메서드들은 제네릭하게 구현되어 있어서 <code>this</code>값이 Array exotic object인지는 관련 없이 동작한다.</p>\n<blockquote>\n<p>Subclass constructors that intend to inherit the exotic Array behaviour must include a super call to the Array constructor to initialize subclass instances that are Array exotic objects. However, most of the Array.prototype methods are generic methods that are not dependent upon their this value being an Array exotic object.</p>\n<p>ECMA 262 명세, <a href=\"https://tc39.es/ecma262/2021/#sec-array-constructor\">https://tc39.es/ecma262/2021/#sec-array-constructor</a></p>\n</blockquote>\n<p>그리고 이런 특별한 내부 구현은 사용자가 쉽게 조작할 수 없다. Array와 같은 몇몇 클래스에 대해서만 <code>extends</code>를 이용한 상속이 허용되어 있을 뿐이다.</p>\n<h1>6. 빌트인 객체 상속 원리</h1>\n<p>(이 섹션 내용은 2023.08.12에 추가)</p>\n<p>class 문법은 어떻게 exotic object의 내부 구현을 상속할 수 있을까? 이는 class가 인스턴스를 생성할 때 새로운 방식을 쓰기 때문이다.</p>\n<p>class의 생성자는 기본 생성자와 파생 생성자(base constructor, derived constructor) 2가지가 존재한다. 클래스가 어디선가 상속된 클래스일 경우 파생 생성자를 갖게 된다.(<code>Array.prototype</code>이 <code>Object.prototype</code>을 상속받은 것과 같이 빌트인 객체 간의 관계는 제외하고)</p>\n<p>기존에는 이런 구분이 전혀 필요 없다. class가 생기기 전에는 인스턴스 생성을 위해 생성자 함수를 사용했는데 모든 생성자 함수는 <code>Function.prototype</code>을 프로토타입으로 가졌고 이 예외는 빌트인 객체뿐이었기 때문이다.</p>\n<p>하지만 class 문법에서는 상속된 클래스에서는 <code>super()</code>를 무조건 호출해야 하며 디폴트 생성자에서도 <code>super()</code>가 자동으로 호출된다. 즉 상속된 클래스에서 인스턴스를 생성할 때면 <code>super()</code>를 통해 base class까지 거슬러 올라간 후 기본 생성자로 객체를 생성한다.</p>\n<p>따라서 exotic object를 상속한 클래스 인스턴스를 생성할 때도 exotic object base class 생성자까지 거슬러 올라가서 해당 생성자부터 호출하게 되고 이런 원리로 exotic object의 동작까지 상속할 수 있는 것이다.</p>\n<p>이를 의사 코드로 표현한다면 다음과 같다. <a href=\"https://witch.work/posts/javascript-prototype-misc#4.4.-%EB%B9%8C%ED%8A%B8%EC%9D%B8-%EA%B0%9D%EC%B2%B4-%EC%83%81%EC%86%8D\">Babel에서 빌트인 객체를 처리하는 방식을 분석한 더 자세한 글도 작성했었으니 더 자세히 이런 동작을 탐구하고 싶다면 참고할 수 있다.</a></p>\n<pre><code class=\"language-js\">// 출처 https://www.bsidesoft.com/5370\nconst Cls = class extends Array{\n  constructor(){\n    if(classKind == 'base'){ //본인 기본생성자라면 this는 본인이 생성하지만\n      this = Object.create(new.target.prototype);\n    }else{ //아니라면 부모에게 위임하자. 하지만 new.target은 유지한다.\n      this = Reflect.construct(Array, [], new.target); \n    }\n  }\n};\n</code></pre>\n<p>즉 derived class일 경우 base 생성자까지 거슬러 올라가서 생성을 위임한 후 <code>Reflect.construct</code>를 이용해 <code>new.target</code>을 현재의 클래스로 고정해 주는 원리이다. 실제로는 <code>classKind</code>같은 게 아니라 특수 내부 프로퍼티 <code>[[ConstructorKind]]:\"derived\"</code>를 사용해서 base, derived class를 구분한다.</p>\n<h1>참고</h1>\n<p><a href=\"https://blog.bitsrc.io/exotic-objects-understanding-why-javascript-behaves-so-moody-5f55e867354f\">https://blog.bitsrc.io/exotic-objects-understanding-why-javascript-behaves-so-moody-5f55e867354f</a></p>\n<p><a href=\"https://ui.toast.com/posts/ko_20221116_1\">https://ui.toast.com/posts/ko_20221116_1</a></p>\n<p><a href=\"https://forum.kirupa.com/t/js-tip-of-the-day-exotic-objects/643152\">https://forum.kirupa.com/t/js-tip-of-the-day-exotic-objects/643152</a></p>\n<p>ECMA262 명세 <a href=\"https://tc39.es/ecma262/\">https://tc39.es/ecma262/</a></p>\n<p>빌트인 객체 상속원리 <a href=\"https://www.bsidesoft.com/5370\">https://www.bsidesoft.com/5370</a></p>",
    "excerpt": "1. 시작\nObject.create는 인수로 받은 객체를 프로토타입으로 하는 객체를 생성하여 리턴한다.\n그리고 Array 객체는 Array.prototype이 프로토타입인 객체이다. 그러면 다음 출력 결과는 어떻게 될까?\nconsole.log(Array.isArray(Object.create(Array.prototype)));\n\nArray.prototype을 상속한 객체가 Array인지 판별하는 것이므로 true가 아닐까? 하지만 답은 false이다. 생성자 함",
    "headingTree": [
      {
        "title": "1. 시작",
        "url": "#1-시작",
        "items": []
      },
      {
        "title": "2. JS 객체의 분류",
        "url": "#2-js-객체의-분류",
        "items": []
      },
      {
        "title": "3. ordinary object",
        "url": "#3-ordinary-object",
        "items": []
      },
      {
        "title": "4. exotic object",
        "url": "#4-exotic-object",
        "items": [
          {
            "title": "4.1. Array exotic object",
            "url": "#41-array-exotic-object",
            "items": []
          },
          {
            "title": "4.2. Bound function exotic object",
            "url": "#42-bound-function-exotic-object",
            "items": []
          },
          {
            "title": "4.3. Immutable prototype exotic object",
            "url": "#43-immutable-prototype-exotic-object",
            "items": []
          }
        ]
      },
      {
        "title": "5. 동작 예시",
        "url": "#5-동작-예시",
        "items": []
      },
      {
        "title": "6. 빌트인 객체 상속 원리",
        "url": "#6-빌트인-객체-상속-원리",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 2,
      "wordCount": 555
    },
    "url": "/posts/javascript-exotic-object",
    "thumbnail": {
      "local": "/static/js-array-defineownproperty-79f1220d.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-js-array-defineownproperty-79f1220d-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAmElEQVR4nGOQkpZhZedkYWPz8fVdvnZDW0dXaVn5+k1bGELDI4RFxFMyslrb2jZu2nzx0uULFy/ev/+AoaOzS1xBWUxazsvXb9++ff/+/f0PBgwzZ89W1tFl4OSxtrWbPGXKvXv3oBK79+xR1taWlFPomTBl644dFy5ehEpMnTrNyt4xPiW9q2/C8uUrly1ffuHixXv37gEAufxPV5HzVbAAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "javascript-history-initial-decisions",
    "title": "JS의 소리를 찾아서 - Javascript의 초기 실수와 선택들",
    "date": "2024-01-21T00:00:00Z",
    "description": "Javascript의 이상한 부분들은 어디서 왔을까?",
    "tags": [
      "javascript",
      "history"
    ],
    "html": "<h1>썸네일</h1>\n<p><img src=\"/static/js-weird-36df170c.png\" alt=\"자바스크립트는 못말려\"></p>\n<h1>JS의 소리를 찾아서 시리즈</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>시리즈</th></tr></thead><tbody><tr><td><a href=\"https://witch.work/posts/javascript-history-start\">JS의 소리를 찾아서 - 시작하면서</a></td></tr><tr><td><a href=\"https://witch.work/posts/javascript-history-the-birth\">JS의 소리를 찾아서 - Javascript의 탄생</a></td></tr><tr><td><a href=\"https://witch.work/posts/javascript-history-initial-decisions\">JS의 소리를 찾아서 - Javascript의 초기 실수와 선택들</a></td></tr></tbody></table>\n<p>이 글에서는 다음과 같은 내용을 다룬다. 다만 기술적인 부분보다는 좀더 역사적인 사실들에 집중하여 다룰 것이다.</p>\n<ul>\n<li>Javascript 역사의 간단한 요약</li>\n<li>Javascript의 초기의 실수들</li>\n<li>Javascript의 초기의 선택들</li>\n<li>Javascript에 영향을 준 기타 언어들</li>\n</ul>\n<h1>1. 간단한 역사</h1>\n<blockquote>\n<p>이미 잘 알려져 있겠지만 1995년 5월, 나는 '자바와 비슷해야 하고', '초보자에게도 쉬워야 하며', '넷스케이프 브라우저 내의 거의 모든 것을 제어할 수 있어야 한다'는 강압적이고도 강제적인 관리 명령하에 열흘 만에 자바스크립트를 만들었다.</p>\n<p>데이비드 허먼 저, 김준기 옮김, '이펙티브 자바스크립트'에 실린 브랜든 아이크의 추천사</p>\n</blockquote>\n<p>Javascript는 1995년 브랜든 아이크에 의해서 열흘만에 급하게 만들어졌다. 처음에는 이렇게 새로운 언어를 만들기보다는 기존 언어, 특히 Scheme 언어를 브라우저에 넣으려고 했다.</p>\n<p>하지만 당시 아이크를 고용했던 넷스케이프가 브라우저 시장에서 마이크로소프트를 이기기 위해 썬 마이크로시스템즈(Java를 만든 그곳)와 동맹을 맺게 되면서 그럴 수 없어졌다. 브라우저에는 동맹사 제품인 Java가 들어가야 했기 때문이다.</p>\n<p>그래서 브라우저에는 Java와 Java를 보조하기 위한 간단한 스크립팅 언어가 들어가기로 했다. 아이크는 이 'Java를 보조하는 간단한 스크립팅 언어'를 만들게 되었다.</p>\n<p>하지만 시간이 없었다. 이런 결정이 난 것은 1995년 5월이었는데 넷스케이프는 9월에는 브라우저를 출시해야 했다.</p>\n<p>이렇게 시간에 쫓기면서 아이크는 10일만에 Javascript의 프로토타입(당시의 이름은 Mocha)을 만들었다. Java를 보조하기 위한 언어이므로 '자바와 비슷해 보여야 하고 초보자에게도 쉬워야 한다'는 요구사항과 함께였다.</p>\n<p>Javascript의 대부분의 실수들은 방금 말한 3가지가 맞물려 가며 생겼다.</p>\n<ul>\n<li>10일의 촉박한 시간</li>\n<li>Java와 비슷해 보여야 한다는 요구사항</li>\n<li>초보자도 쉽게 쓸 수 있는 언어여야 한다는 요구사항</li>\n</ul>\n<p>그럼 이제 Javascript의 실수들부터 그 와중에도 이루어진 선택들 그리고 이외의 영향들에 대해서 차례로 알아보자.</p>\n<p>만약 Javascript의 초기 역사가 더 자세하게 궁금한 사람들은 <a href=\"https://witch.work/posts/javascript-history-the-birth\">JS의 소리를 찾아서 - Javascript의 탄생</a>을 참고하길 바란다.</p>\n<h1>2. Javascript 초기의 실수들</h1>\n<blockquote>\n<p>\"저에게 시간과 예산이 조금만 더 있었더라면...\"</p>\n<p>니트로 박사</p>\n</blockquote>\n<p>브랜든 아이크에게는 시간이 없었고 일손도 없었다. Javascript는 언제나 바쁜 일정으로 만들어졌고 초기 Javascript 제작의 대부분 기간 동안 아이크는 거의 혼자 작업했다.</p>\n<p>Javascript의 역사를 다룬 글들을 읽어 보면 'xx가 이런 부분을 도와주었다'나 'xx가 이런 부분을 만들어 주었다'라는 문구는 있어도 'xx와 같이 일했다'는 말은 도무지 찾아볼 수가 없다.</p>\n<p>이런 상황 속에서 만들어진 Javascript에 허술한 부분이 있는 건 어쩌면 당연했다. 문제는 그 실수들이 지금까지도 남아서 우리를 괴롭히고 있다는 것이다. 이제부터 살펴볼 <code>var</code>의 호이스팅, 기묘한 <code>Date</code>클래스, <code>==</code>연산자의 형변환 규칙 등은 JS를 공부하면서 한번쯤 보게 되는 것들인데, 이 모든 것들이 초기의 실수에서 시작되었다.</p>\n<h2>2.1. var 호이스팅</h2>\n<blockquote>\n<p>끌어올림이란 '스코프 맨 앞으로 이동'이라는 뜻입니다. 함수 선언은 완벽히 끌어올려지며, 변수 선언은 부분적으로 끌어올려집니다.</p>\n<p>악셀 라우슈마이어 저, 한선용 옮김, '자바스크립트를 말하다' 263쪽</p>\n</blockquote>\n<p><code>var</code> 변수 선언과 함수가 스코프의 최상단으로 끌어올려지는 현상인 호이스팅은 Javascript의 특이한 동작으로 많이 언급된다. 호이스팅이 무엇이고 어떤 의미가 있는지는 글의 주제를 벗어난다. 여기서는 그게 왜 만들어졌는지를 다룬다.</p>\n<p>호이스팅은 순전히 기술적 이유 때문에 탄생했다. 함수의 호이스팅은 함수를 어디서든 사용할 수 있게 함으로써 스코프 내에서 프로그램을 탑다운식으로 분해하여 볼 수 있도록 해주었다. 그리고 선언 이전의 호출도 가능하게 했다.</p>\n<p>그리고 호이스팅은 재귀 함수에서 값을 스코프에 바인딩하는 <a href=\"https://stackoverflow.com/questions/16530534/scheme-when-to-use-let-let-and-letrec\"><code>let rec</code></a>을 추가적인 비용 없이 할 수 있게 해주었다.</p>\n<p>하지만 이렇게 나름의 이유가 있었던 함수 호이스팅과 달리 <code>var</code>로 선언된 변수의 호이스팅은 원래 의도가 아니었다. Javascript가 급하게 만들어지면서 생긴, 함수 호이스팅의 의도되지 않은 부작용이다. 10일간의 촉박한 기간 동안 Javascript를 만들면서 생긴 실수라고 할 수 있겠다.</p>\n<h2>2.2. typeof</h2>\n<p><code>typeof</code> 연산자는 피연산자의 타입을 식별하는 문자열을 반환한다. 그런데 이 연산자에는 많은 실수들이 있다.</p>\n<p>예를 들어서 문자열 리터럴과 <code>String</code> 생성자로 만들어진 문자열 객체의 타입이 다르다고 나온다.</p>\n<pre><code class=\"language-js\">typeof \"hello world\" // \"string\"\ntypeof new String(\"hello world\") // \"object\"\n</code></pre>\n<p>또한 null에 대해서도 <code>typeof</code>를 적용해 보면 <code>object</code>라는 값이 나온다.</p>\n<pre><code class=\"language-js\">typeof null // \"object\"\n</code></pre>\n<p>이는 Java에서 원시값과 객체로 값을 구분하는 방식을 따른 것이다. 하지만 정적 타입이 있어서 타입을 통해 값을 구분할 수 있었던 Java와 달리 Javascript는 동적 타입이라서 타입을 통해 값을 구분할 수 없었다.</p>\n<p>그래서 타입을 쓰지 않고 억지로 값을 구분하려다 보니 위와 같은 결과가 나온 것이다. Java와 비슷하게 만들면서도 10일간의 촉박한 기간 동안 작업하면서 충분한 고려를 하지 못했다고 할 수 있다.</p>\n<p><code>typeof null</code>에 대한 더 깊은 탐구는 <a href=\"https://witch.work/posts/javascript-why-typeof-null-is-object\">JS 탐구생활 - JS의 typeof null은 왜 object일까?</a>에서 볼 수 있다.</p>\n<h2>2.3. Date 클래스</h2>\n<p>Javascript 1.0의 <code>Date</code>는 Java의 <code>java.util.Date</code>를 거의 그대로 가져온 것이다. 그런데 열흘 안에 급하게 옮기느라 버그나 이상한 특성까지 옮겨왔다.</p>\n<p>예를 들어서 1970년 1월 1일을 0으로 표현하는 것, month만 0에서 11까지로 표현하는 것, 그리고 Y2K 버그가 옮겨왔다(Y2K 버그는 얼마 안 지나 고쳐지기는 했다).</p>\n<p>이외에도 우리가 <code>Date</code>객체를 사용하면서 느낀 이상한 부분들은 대부분 Java의 <code>java.util.Date</code>에서 옮겨온 것이다. 시간이 흐르고 Java는 Java 8을 기점으로 현대적인 시간/날짜 관리 패키지인 <code>java.time</code>을 추가하면서 <code>java.util.Date</code>와 멀어졌지만 JavaScript는 아직까지 <code>Date</code>를 사용하고 있다.</p>\n<p>즉 <code>Date</code>의 기묘한 점들은 촉박한 시간 동안 Java의 <code>Date</code>클래스를 옮겨오면서 생긴 실수라고 할 수 있다. 문제는 이 실수가 아직까지 남아 있다는 것이지만.</p>\n<p>참고로 <code>java.util.Date</code>를 옮겨올 때 <code>equals</code>, <code>before</code>, <code>after</code> 메서드는 빠졌다. 이들은 Javascript의 자동 형변환으로 인해 숫자에 쓰이는 연산자를 Date 객체에 직접 사용할 수 있었기 때문에 필요없어서 제외되었다.</p>\n<h2>2.4. 자동 형변환과 == 연산자</h2>\n<pre><code class=\"language-js\">1 + '1' === '11' // true\n</code></pre>\n<p>피연산자들에 대해 이루어지는 자동 형변환은 Javascript가 초보자들도 쉽게 쓸 수 있는 간단한 스크립트 언어를 목적으로 만들어지던 시절 언어의 진입 장벽을 낮추기 위해 만들어졌다. 초보자도 쉽게 쓸 수 있는 언어로 만들려다가 생긴 실수라고 할 수 있다.</p>\n<p>그러나 Javascript가 점점 범용 언어로 발전하면서 이 자동 형변환은 혼란과 많은 버그의 원인이 되었다.</p>\n<p>또한 <code>==</code>연산자의 형변환이 만들어진 데에는 역사적인 이유가 하나 더 있다. 이런 자동 형변환은 Javascript(당시에는 Mocha)가 10일만에 프로토타이핑된 후 넷스케이프 내부의 알파 유저들의 요청에 대응하여 만들어진 것이다.</p>\n<p>예를 들어 문자열 <code>\"404\"</code> HTTP 코드를 숫자 <code>404</code>와 <code>==</code> 연산자로 비교했을 때 결과가 참으로 나와야 한다는 요구사항이 있었다. 그리고 HTML 폼의 빈 필드에 대해서 기본값을 제공하기 위해 빈 문자열은 숫자 맥락에서 <code>0</code>으로 해석되도록 해 달라는 요구사항도 있었다.</p>\n<p>당시에 이 요구사항들은 아예 터무니없는 것은 아니었고 Javascript와 HTTP/HTML의 용이한 통합을 위해서였다. 하지만 결국 이런 요구사항들은 <code>==</code> 연산자의 이해하기 힘든 형변환 규칙이 만들어지는 데에 기여하게 되었다.</p>\n<h2>2.5. this</h2>\n<p><code>this</code>는 여러 언어들에서 일반적으로, 메서드가 호출되었을 때 해당 메서드를 호출한 객체를 가리키는 키워드이다. 하지만 Javascript에서는 이 <code>this</code>가 많은 프로그래머들에게 혼란을 주었다.</p>\n<p><code>this</code>가 객체의 메서드에서 쓰였을 때와 객체에서 독립적인 일반 함수로 쓰였을 때, 생성자 함수로 쓰였을 때 등 <code>this</code>가 쓰인 맥락에 따라 <code>this</code>가 가리키는 객체가 달라지기 때문이다. 함수가 객체 메서드라면 <code>this</code>는 메서드를 호출한 객체를, 일반 함수라면 <code>this</code>는 전역 객체를 가리킨다. 생성자 함수라면 함수가 생성할 객체를 가리킨다.</p>\n<p>HTML에서도 Javascript 코드를 메서드 형식으로 호출된 함수처럼 변환해 주는 경우가 있기 때문에 이런 혼란이 더 커진다. 예를 들어서 다음과 같은 코드가 있다고 하자.</p>\n<pre><code class=\"language-html\">&#x3C;button name=\"B\" onclick=\"alert(this.name + \" clicked\")>Click me&#x3C;/button>\n</code></pre>\n<p>이 버튼을 클릭했을 시 버튼의 <code>onclick</code>메서드가 호출되는데 이때 <code>this</code>는 버튼 객체를 가리킨다. 그래서 <code>this.name</code>은 버튼의 <code>name</code> 프로퍼티가 된다.</p>\n<p>이 혼란스러운 <code>this</code>는 원래 Java에서 빌려온 키워드이다. 그런데 Java에서는 함수가 무조건 클래스에 속해 있는 메서드의 형태이기 때문에 문제가 없었다. 하지만 Javascript에는 객체 메서드뿐 아니라 개별적인 함수, 생성자 함수까지 있었는데 <code>this</code>가 그 모든 함수에서 비슷한 용법으로 쓰임으로써 혼란을 주었다.</p>\n<p>Java와 비슷하게 만들면서도 10일간의 촉박한 기간 동안 작업하면서 충분한 고려를 하지 못했다고 할 수 있다.</p>\n<h2>2.6. with</h2>\n<p><code>with</code>는 객체의 속성에 접근할 때 객체 이름을 생략하여 간편함을 제공할 목적으로 만들어졌다. '간편함'이라는 말에서 알 수 있듯 이는 원래 '초보자도 Javascript를 사용하기 쉽도록'하기 위해 만들어졌다.</p>\n<p>요즘은 거의 쓰이지 않는 문법이기에 간단히 설명하면 <code>with</code>의 블럭 내에서는 <code>with</code>가 지정한 객체의 프로퍼티를 변수처럼 사용할 수 있다. 예를 들어 다음과 같은 <code>with</code> 블럭 내에서는 <code>obj</code>의 프로퍼티인 <code>a</code>와 <code>b</code>에 접근할 때 <code>obj</code>를 생략할 수 있다.</p>\n<pre><code class=\"language-js\">with (obj) {\n  a = b;\n}\n</code></pre>\n<p>하지만 이는 다음과 같이 해석된다. 매우 혼란스러운 코드이다.</p>\n<pre><code class=\"language-js\">if (obj.a === undefined) {\n    a = (obj.b === undefined) ? b : obj.b;\n} else {\n    obj.a = (obj.b === undefined) ? b : obj.b;\n}\n</code></pre>\n<p>a와 b가 둘 다 obj의 속성일 수 있기 때문에 이런 일이 발생한다. 이는 제대로 해석하기 매우 어렵다. 또한 단순한 가독성 문제뿐 아니라 <code>with</code>는 변수명의 어휘적 바인딩을 어렵게 만들어 프로세서 속도를 느리게 만들고 버그의 원인이 된다.</p>\n<p>이 <code>with</code> 또한 10일만에 급하게 언어를 만들면서도 초보자가 쉽게 쓸 수 있도록 만들려다가 설계를 충분히 검토하지 못해 생긴 실수라고 할 수 있다.</p>\n<h1>3. Javascript 초기의 선택들</h1>\n<blockquote>\n<p>아주 자랑스럽지는 않지만 Scheme과 같은 일급 함수와 Self와 같은 프로토타입(하나뿐이긴 하지만)을 자바스크립트의 주요 요소로 선택한 것에 만족한다. Java의 영향, 특히 y2k 버그, 원시값과 객체의 구분(예를 들어 string과 String)과 같은 부분은 아쉬운 부분이다.</p>\n<p><a href=\"https://brendaneich.com/2008/04/popularity/\">Brendan Eich, Popularity</a></p>\n</blockquote>\n<p>앞서 언급했듯 아이크는 1995년 5월, 단 10일만에 Javascript의 프로토타입(당시 이름은 Mocha)을 만들었다. 매우 촉박한 시간이었다.</p>\n<p>그래서 아이크는 본인이 생각하는 중요한 사항을 빼면 나머지는 매우 유연하게 만들었다. 아이크는 자신이 Javascript를 이렇게 유연하게 만들어 놓으면 내장 라이브러리 등은 날림으로 해두어도 다른 개발자들이 수정하리라고 생각했다. 실제로 Javascript의 내장 라이브러리는 초기에 날림으로 만들어진 게 많다.</p>\n<p>여담이지만 이런 이유로 Javascript는 빌트인 객체를 포함해서 모든 객체들의 수정을 거의 허용한다. <code>Object.prototype</code>과 같은 객체들을 수정할 수 있는 것도 이런 설계 때문이다. 이는 폴리필을 만들 수 있는 기반이 되기도 한다.</p>\n<p>그런데, 그럼 아이크가 언어를 만들 때 생각했다는 그 '중요한 사항'들은 무엇인가? 열흘간의 촉박한 프로토타이핑 기간 속에서도 양보할 수 없었던 건 무엇이었을까? 그 중요한 사항 2가지는 Self의 프로토타입 기반의 객체지향 시스템과 Scheme에서 온 일급 객체 함수의 개념이었다.</p>\n<p>이 두 가지는 Javascript 창시자 브랜든 아이크의 여러 인터뷰와 발표에서도 'Javascript에서 잘 만든 부분'으로 자주 언급된다(물론 급하게 만드는 과정의 실수는 있었다고 인정하지만). 그럼 이 두 가지에 대해 알아보자.</p>\n<p>이외에도 Javascript는 여러 언어들에서 영향을 받았지만 그 부분에 대해서는 다음 섹션 <code>#4</code>에서 다룬다.</p>\n<h2>3.1. 프로토타입</h2>\n<blockquote>\n<p>객체는 다른 객체로부터 상속된다. 모든 객체는 어떤 다른 객체, 즉 프로토타입과 연관되어 있다.</p>\n<p>데이비드 허먼 저, 김준기 옮김, '이펙티브 자바스크립트', 109쪽</p>\n</blockquote>\n<p>프로토타입은 Javascript에서 객체지향을 구현하는 방식이다. 클래스 언어를 사용해본 사람들에게 이는 매우 낯선 부분이다. 그래서 이후 ES6에서 클래스가 추가되기도 했다.</p>\n<p>하지만 프로토타입은 분명 그 당시로서는 Javascript에 들어갈 만한 기능이었다. 프로그래밍 초보자를 위한 언어였던 Javascript의 목적성에 비해 클래스 기반의 객체지향은 너무 복잡했기 때문이다.</p>\n<p>프로토타입의 철학적 배경에 관해서는 <a href=\"https://medium.com/@limsungmook/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%99%9C-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%84-%EC%84%A0%ED%83%9D%ED%96%88%EC%9D%84%EA%B9%8C-997f985adb42\">자바스크립트는 왜 프로토타입을 선택했을까</a>라는 아주 유명한 글이 있다.</p>\n<p>다 맞는 이야기는 아니지만, 철학적 배경에 대해서는 앞의 글을 참고할 수 있다. 여기서는 좀더 실질적인 이야기를 해보려고 한다.</p>\n<h3>3.1.1. 클래스 모델링의 어려움</h3>\n<p>클래스는 Simula라는 언어에서 객체지향을 모델링하는 방식으로 처음 도입되었다. 그리고 이후 Smalltalk, C++, Java 등의 언어에서도 사용되었다.</p>\n<p>하지만 문제는 클래스를 사용하는 게 본래부터 어렵다는 것이었다. 지금도 클래스 모델링이 얼마나 많은 사람들의 머리를 아프게 하고 있을지 상상도 가지 않는다. 왜냐 하면 클래스를 모델링한다는 것은 <code>이 객체의 본질이 무엇인가?</code>라는 질문을 던지도록 하기 때문이다.</p>\n<p>만약 이 질문에 대해 잘못된 결정을 내려서 클래스를 잘못 모델링했는데 이미 많은 인스턴스가 만들어져 있다면 그걸 고치기가 매우 어렵다. 따라서 처음부터 여러 가지를 고려하여 클래스를 잘 모델링해야 한다.</p>\n<p>이는 절대 쉬운 일이 아니고 초보자를 위한 언어였던 Javascript에 이런 클래스 기반의 객체지향을 넣는 것은 좋지 않았다. 그래서 아이크는 프로토타입 기반의 객체지향을 선택했다. 프로토타입을 사용하면 이런 문제를 해결하거나 최소한 쉽게 가릴 수 있다.</p>\n<h3>3.1.2. 프로토타입의 도입</h3>\n<p>프로토타입은 상위 클래스의 상속이라기보다는 다른 객체에 동작을 '위임'하는 방식으로 작동한다. 따라서 프로토타입이 새 객체에 적합하지 않다면 프로토타입 객체를 런타임에 수정함으로써 먼저 그 객체가 사용된 코드에 영향을 주지 않고도 수정할 수 있다.</p>\n<p>뭔가가 잘못되면 바로 수정할 수 있고 처음부터 객체를 잘 모델링하기 위한 추상적인 생각을 하지 않아도 된다. 프로토타입 기반의 객체지향이 클래스 기반의 객체지향보다 상대적으로 '바로 사용하기' 쉽다고 할 수 있겠다.</p>\n<p>Javascript는 초보자를 위한 언어로 만들어졌기 때문에 이렇게 쉽게 사용할 수 있어야 했다. 따라서 상대적으로 쉽게 사용할 수 있는 프로토타입 기반 객체 모델이 도입되었다.</p>\n<p>구체적인 구현에 관해서는 프로토타입 기반의 객체지향을 구현한 Self라는 언어의 영향을 받았다. Self도 Javascript의 프로토타입 체인과 같은 방식으로 동작한다. Self에서도 각 객체가 프로토타입 객체의 참조를 가지고 있었고 그 참조를 통해 프로토타입 객체의 기능을 사용할 수 있었다.</p>\n<p>물론 Javascript는 Java를 보조하는 언어로 포지셔닝되었었기 때문에 Javascript의 초기 문서에는 이런 프로토타입 기반의 객체지향 이야기가 나오지 않는다. 하지만 Javascript 생성자 함수의 <code>prototype</code> 프로퍼티의 작명 등에서 Self와 프로토타입 기반 객체 모델의 영향을 엿볼 수 있다.</p>\n<h3>3.1.3. Java와의 충돌 방지</h3>\n<p>Javascript가 보조해야 할 언어였던 Java가 이미 클래스 기반이었다. 때문에 Javascript도 클래스 기반의 객체지향을 사용한다면 Java와 같은 영역에서 경쟁하게 되었을 것이다.</p>\n<p>프로토타입 기반의 객체지향을 사용하면 Java와 클래스 구현에 대해 경쟁하지 않고도 Java의 보완재 역할을 할 수 있었다.</p>\n<h3>3.1.4. 시간의 부족</h3>\n<p>계속 언급되었듯이 아이크에게는 시간이 얼마 없었다. 그런데 프로토타입은 클래스에 비해서 언어 제작자가 구현하기 쉬웠다.</p>\n<p>또한 수많은 내장 라이브러리들과 빌트인 메서드 또한 프로토타입을 통해 작동하도록 하면 사용자가 직접 원하는 메서드들을 만들고 또 수정할 수 있게 된다. <code>Object.prototype</code>등의 빌트인 프로토타입을 수정하면 되었다. 이는 Javascript 언어에서 지원해야 하는 기능을 최소화할 수 있게 해주었다.</p>\n<p>그래서 Javascript는 이렇게 구현하기도 쉽고, 여러 작업들을 사용자에게 맡겨 버릴 수도 있는 프로토타입 기반의 객체 모델로 시작한다.</p>\n<h2>3.2. 일급 객체 함수와 클로저</h2>\n<blockquote>\n<p>A closure is a procedure that records what environment it was created in.</p>\n<p>An Introduction to Scheme and its Implementation, The University of Texas at Austin</p>\n</blockquote>\n<blockquote>\n<p>자바스크립트의 함수는 어휘적 유효범위를 가진 일급 객체입니다. 또한 주류가 된 첫번째 람다 언어며, 좀더 깊이 들어가면, 이름처럼 자바에 가깝기보다는 Lisp 언어 그리고 Scheme 언어와 더 많은 공통점이 있습니다. 자바스크립트는 C의 옷을 입은 Lisp이라고 할 수 있습니다.</p>\n<p>더글러스 크록포드 저, 김명신 옮김, '자바스크립트 핵심 가이드', 14쪽</p>\n</blockquote>\n<p>Javascript에서는 함수를 프로그램의 다른 객체와 똑같이 취급한다. 이 개념을 일급 객체 함수라고 하는데 이는 앞서 언급한 프로토타입과 함께 브랜든 아이크가 Javascript에서 잘 만들었다고 자부하는 기능이다.</p>\n<p>지금은 Python, Ruby, Kotlin 등의 언어에서도 일급 객체 함수와 클로저를 지원하고 일급 객체 함수 개념도 유명해졌다. 하지만 당시에 이런 개념은 그렇게 대중적이지 않았다. 그럼 왜 당시 Javascript는 이 개념을 도입했을까?</p>\n<h3>3.2.1. 일급 객체 함수와 Scheme</h3>\n<p>Javascript의 일급 객체 함수 개념은 Scheme에서 왔다. Scheme은 거의 처음으로 일급 객체 함수 개념을 도입한 언어였다.</p>\n<p>브랜든 아이크의 원래 목표는 앞서 언급했듯 Scheme을 브라우저에 구현하는 것이었다. 상황상 그렇게 할 수 없었지만 아이크는 Scheme에서 제시한 일급 객체 함수 개념이 좋다고 여전히 생각했다. 그래서 일급 객체 함수를 Javascript에 도입했다.</p>\n<h3>3.2.2. 여파</h3>\n<p>일급 객체 함수 도입은 Scheme에 있는 다른 개념들도 Javascript에 같이 가져왔다. 다만 구문상의 영향은 거의 없었다. 딱 일급 객체 함수와 거기서 파생된 클로저 등 몇몇 개념에만 영향을 주었다.</p>\n<p>일급 객체 함수가 도입됨으로써 함수가 일반적인 다른 객체들과 같이 다루어지는 것이 가능해졌고 클로저, 함수를 인수로 넘기는 것, 객체 메서드, 이벤트 핸들러 등이 가능해졌다. 함수 표현식 또한 일급 객체 함수 덕분에 가능해졌다.</p>\n<p>클로저도 일급 객체 함수를 통해서 가능해졌다. 일급 객체 함수 개념을 통해 함수가 다른 함수의 반환값이 되는 게 가능해졌고 그래서 함수가 자신이 생성된 환경을 기억할 수 있게 된 것이다.</p>\n<p>다음의 <code>makeCounter</code> 함수에서 반환하는 함수는 클로저에 들어간 <code>count</code> 변수를 기억하고 증가시키는 기능을 한다.</p>\n<pre><code class=\"language-js\">function makeCounter() {\n    var count = 0;\n    return function() {\n        return count++;\n    };\n}\n</code></pre>\n<p>만약 함수가 일급 객체가 아니라서 다른 함수에서 값처럼 반환될 수 없었을 테고, 함수가 자신이 만들어진 주변 환경을 기억하고 거기 접근할 수 있는 클로저도 없었을 것이다.</p>\n<p>클로저가 React 등 현대의 프론트엔드 프레임워크에서 중요한 역할을 하는 것을 생각하면 이는 실제로 좋은 선택이었다. 이 클로저에 관해서는 이후에 다른 글을 하나 더 쓸 예정이다.</p>\n<h1>4. Javascript에 영향을 준 다른 언어들</h1>\n<p>또 Javascript는 여러 언어들에서 영향을 받았다. 이는 \"Java와 비슷해야 한다\"는 요구사항을 제외하면 아이크에게 다른 언어적 세부사항들을 정할 수 있는 권한이 있었고 사실 Javascript의 고유한 무언가를 제대로 만들 시간도 없었기 때문이다.</p>\n<p>따라서 Javascript는 Scheme, Self, Java, HyperTalk, Perl, Awk, Python등 여러 언어의 영향을 받았다.</p>\n<h2>4.1. Scheme</h2>\n<p>앞서 말했듯 Scheme의 일급 객체 함수 개념은 Javascript에 영향을 주었다. 그리고 앞서 언급했던 클로저, 함수를 인수로 넘기기, 객체 메서드, 이벤트 핸들러, 함수 표현식 등에도 Scheme의 영향이 있다.</p>\n<p>하지만 구문상의 영향은 거의 없었다. 딱 '일급 객체로서의 함수'와 거기서 파생된 클로저 등 몇몇 개념에만 영향을 주었다.</p>\n<h2>4.2. Self</h2>\n<p>Javascript(당시에는 Mocha)가 객체 기반의 언어가 되어야 한다고 당시에는 모두 생각했다. 하지만 그것이 클래스 모델을 통해서 이루어지면 안됐다. 클래스가 있으면 구현도 오래 걸리고 같은 클래스 모델을 사용하는 Java와 경쟁해야 했을 것이기 때문이다.</p>\n<p>따라서 아이크는 프로토타입 기반의 객체지향 시스템을 만들기로 했고 이는 Self에서 영향을 받았다. 그렇게 Javascript는 Self와 같이 단일 프로토타입을 기반으로 하며 프로토타입 체인을 통한 위임을 사용하는 언어로 시작한다.</p>\n<h2>4.3. Java</h2>\n<p>Javascript의 전신인 Mocha가 만들어질 때 마크 앤드리슨은 Mocha가 누구나 HTML 문서에 몇 줄쯤 직접 작성할 수 있을 정도로 쉬워야 한다고 했지만 또 Java와 비슷해 보여야 한다고 계속 강조했다. 그러면서 BASIC같은 언어의 영향은 명시적으로 배제했다.</p>\n<p>이런 Java와 비슷해 보여야 하는 외형적인 요구사항은 Javascript에 Java의 동작 또한 녹아들게 했다. 예를 들어서 boolean, int, double, string과 같은 원시 타입의 의미는 Java의 영향이다. 물론 Javascript에는 클래스가 없었으므로 용법은 달랐고 키워드만 빌려온 것이다.</p>\n<h2>4.4. HyperTalk</h2>\n<p>Javascript가 브라우저에 결합되는 방식에는 애플의 HyperCard라는 제품에 들어가 있던 HyperTalk라는 언어가 영향을 줬다.</p>\n<p>HyperTalk는 제품 내에서 컴포넌트에 접근하거나 컴포넌트를 제어할 수 있도록 하는 언어였다. 현재 HTML 태그가 <code>onclick</code>같은 이벤트 핸들러 속성을 갖는 건 이 HyperTalk의 영향이다.</p>\n<h2>4.5. Perl</h2>\n<p>Perl은 Javascript의 문자열과 배열, 정규 표현식 처리에 영향을 주었다. 예를 들어서 배열의 <code>push</code>, <code>pop</code>, <code>shift</code>, <code>unshift</code>, <code>splice</code>메서드는 Perl의 배열 메서드에서 이름을 가져온 것이다. 문자열의 <code>match</code>, <code>replace</code>, <code>substr</code>도 Perl에서 왔다.</p>\n<p>정규식과 문자열 매칭 관련 문법도 Perl에서 가져왔다. <code>&#x26;&#x26;</code>과 <code>||</code>와 같은 논리 연산자가 true, false가 아니라 피연산자의 실제 값을 반환하는 것도 Perl의 스타일이다.</p>\n<h2>4.6. awk</h2>\n<p>Javascript의 함수는 awk의 영향을 받았다. <code>function</code>키워드가 바로 awk에서 가져온 것이다.</p>\n<h1>5. 정리</h1>\n<h2>5.1. Javascript 제작자는 최선을 다했다</h2>\n<blockquote>\n<p>var hoisting was thus unintended consequence of function hoisting, no block scope, Javascript as a 1995 rush job.</p>\n<p>브랜든 아이크, Javascript 창시자</p>\n</blockquote>\n<p>Javascript의 기이해 보이는 면들은 대부분 초기 설계에 기반한다. Javascript는 아주 촉박한 시간 내에 만들어졌고 모든 것을 신경쓸 여유가 없었다. 허술하나마 그렇게 설계한 이유가 있었던 것도 있었지만 그 구체적인 구현은 충분한 고려 없이 이루어졌다.</p>\n<p>하지만 프로토타입과 일급 객체 함수 등 나름의 이유가 있고 탄탄한 기능들도 있었다. 프로토타입은 초보자들이 Javascript를 용이하게 사용할 수 있도록 하기 위해서였고 지금도 프로토타입 기반 객체지향의 지지자들이 꽤 존재한다. 일급 객체 함수는 당시로서는 꽤 선진적인 기능의 도입이었으며 클로저 등 일급 객체 함수에서 파생된 기능과 패턴들은 지금도 엄청나게 많이 쓰인다.</p>\n<p>그리고 부족한 시간 내에서도 여러 언어들에서 많은 개념을 빌려와서 합침으로써 10일만에 만든 것 치고는 아주 괜찮은 언어를 만들어냈다. Java의 보조 언어 격이었던 작은 언어가 이렇게 웹을 지배하는 언어가 되었다는 사실 자체가 언어의 기본 설계는 괜찮았다는 것을 보여준다고 생각한다.</p>\n<h2>5.2. 실수들은 해결되고 있다</h2>\n<blockquote>\n<p>표준을 제정하는 위원회가 언어의 나쁜 점들을 제거하기는 어렵습니다. 왜냐하면 위원회가 나쁜 점을 제거하게 되는 경우 기존에 그 나쁜 점을 사용하여 개발된 프로그램들에 영향을 미치기 때문입니다. 그러므로 위원회는 보통 기존의 불완전함 위에 더 많은 기능을 추가하는 것 외에는 힘이 없습니다. 설상가상으로 새로 추가한 기능들이 기존 기능들과 조화를 이루지 못하는 경우도 있기 때문에, 언어의 나쁜 점이 가중되는 결과를 낳기도 합니다.</p>\n<p>더글러스 크록포드 저, 김명신 옮김, '자바스크립트 핵심 가이드', 12쪽</p>\n</blockquote>\n<p>지금까지 살펴보았듯이, 언어의 기본 설계는 괜찮았더라도 자잘한 문제들이 있기는 했다. 호이스팅이나 <code>==</code> 연산자, <code>Date</code>와 같은 것들 말이다.</p>\n<p>하지만 이런 문제들은 지금도 해결되고 있다. <code>let</code>, <code>const</code>와 같이 TDZ를 이용해 호이스팅 문제를 회피하고 블록 스코프를 사용하는 변수 선언 키워드가 생겼고 이제는 <code>typeof</code>대신 아예 타입스크립트가 쓰인다. <code>==</code>연산자와 <code>with</code>는 ESLint를 통해 사용하지 않도록 설정할 수 있다. 기묘한 <code>Date</code>는 <a href=\"https://xo.dev/articles/js-temporal-api\">Temporal API 프로포절</a>을 통해 극복되려고 하고 있다.</p>\n<p>이렇게 실수들은 해결되어 가고 있으며, 요즘 Javascript의 새로운 기능들이나 프로포절을 보면 Javascript가 만들어지던 시절과 달리 매우 많은 것이 고려된다. 브랜든 아이크 또한 JSConf 발표에서 이런 새로운 흐름들이 언젠가는 <code>eval</code>, 전역 객체, <code>with</code>와 같은 Javascript의 '악'들을 없애줄 것이라고 말한다.</p>\n<p>ES3이 있었고, ES5와 ES6이 있었다. 최근에도 ES2023 개정으로 몇 가지 메서드가 추가되었다. 이렇게 하다 보면, 언젠가 우리는 Javascript가 만들어지던 시절의 실수들을 모두 시간의 뒤로 밀어낼 수 있을 것이다. 하지만 이전에는 무엇이 있었는지, 이 글을 통해 내가 아는 것들을 모아 남겨 놓는다.</p>\n<h1>참고 문헌</h1>\n<p><a href=\"https://witch.work/posts/javascript-history-references#JS%EC%9D%98-%EC%86%8C%EB%A6%AC%EB%A5%BC-%EC%B0%BE%EC%95%84%EC%84%9C---Javascript%EC%9D%98-%EC%B4%88%EA%B8%B0-%EC%8B%A4%EC%88%98%EC%99%80-%EC%84%A0%ED%83%9D%EB%93%A4\">'JS는 왜 그 모양일까? - 참고 문헌'에서 볼 수 있다</a></p>",
    "excerpt": "썸네일\n\nJS의 소리를 찾아서 시리즈\n|시리즈|\n|---|\n|JS의 소리를 찾아서 - 시작하면서|\n|JS의 소리를 찾아서 - Javascript의 탄생|\n|JS의 소리를 찾아서 - Javascript의 초기 실수와 선택들|\n이 글에서는 다음과 같은 내용을 다룬다. 다만 기술적인 부분보다는 좀더 역사적인 사실들에 집중하여 다룰 것이다.\n\nJavascript 역사의 간단한 요약\nJavascript의 초기의 실수들\nJavascript의 초기의 선택들\nJavascrip",
    "headingTree": [
      {
        "title": "썸네일",
        "url": "#썸네일",
        "items": []
      },
      {
        "title": "JS의 소리를 찾아서 시리즈",
        "url": "#js의-소리를-찾아서-시리즈",
        "items": []
      },
      {
        "title": "1. 간단한 역사",
        "url": "#1-간단한-역사",
        "items": []
      },
      {
        "title": "2. Javascript 초기의 실수들",
        "url": "#2-javascript-초기의-실수들",
        "items": [
          {
            "title": "2.1. var 호이스팅",
            "url": "#21-var-호이스팅",
            "items": []
          },
          {
            "title": "2.2. typeof",
            "url": "#22-typeof",
            "items": []
          },
          {
            "title": "2.3. Date 클래스",
            "url": "#23-date-클래스",
            "items": []
          },
          {
            "title": "2.4. 자동 형변환과 == 연산자",
            "url": "#24-자동-형변환과--연산자",
            "items": []
          },
          {
            "title": "2.5. this",
            "url": "#25-this",
            "items": []
          },
          {
            "title": "2.6. with",
            "url": "#26-with",
            "items": []
          }
        ]
      },
      {
        "title": "3. Javascript 초기의 선택들",
        "url": "#3-javascript-초기의-선택들",
        "items": [
          {
            "title": "3.1. 프로토타입",
            "url": "#31-프로토타입",
            "items": [
              {
                "title": "3.1.1. 클래스 모델링의 어려움",
                "url": "#311-클래스-모델링의-어려움",
                "items": []
              },
              {
                "title": "3.1.2. 프로토타입의 도입",
                "url": "#312-프로토타입의-도입",
                "items": []
              },
              {
                "title": "3.1.3. Java와의 충돌 방지",
                "url": "#313-java와의-충돌-방지",
                "items": []
              },
              {
                "title": "3.1.4. 시간의 부족",
                "url": "#314-시간의-부족",
                "items": []
              }
            ]
          },
          {
            "title": "3.2. 일급 객체 함수와 클로저",
            "url": "#32-일급-객체-함수와-클로저",
            "items": [
              {
                "title": "3.2.1. 일급 객체 함수와 Scheme",
                "url": "#321-일급-객체-함수와-scheme",
                "items": []
              },
              {
                "title": "3.2.2. 여파",
                "url": "#322-여파",
                "items": []
              }
            ]
          }
        ]
      },
      {
        "title": "4. Javascript에 영향을 준 다른 언어들",
        "url": "#4-javascript에-영향을-준-다른-언어들",
        "items": [
          {
            "title": "4.1. Scheme",
            "url": "#41-scheme",
            "items": []
          },
          {
            "title": "4.2. Self",
            "url": "#42-self",
            "items": []
          },
          {
            "title": "4.3. Java",
            "url": "#43-java",
            "items": []
          },
          {
            "title": "4.4. HyperTalk",
            "url": "#44-hypertalk",
            "items": []
          },
          {
            "title": "4.5. Perl",
            "url": "#45-perl",
            "items": []
          },
          {
            "title": "4.6. awk",
            "url": "#46-awk",
            "items": []
          }
        ]
      },
      {
        "title": "5. 정리",
        "url": "#5-정리",
        "items": [
          {
            "title": "5.1. Javascript 제작자는 최선을 다했다",
            "url": "#51-javascript-제작자는-최선을-다했다",
            "items": []
          },
          {
            "title": "5.2. 실수들은 해결되고 있다",
            "url": "#52-실수들은-해결되고-있다",
            "items": []
          }
        ]
      },
      {
        "title": "참고 문헌",
        "url": "#참고-문헌",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 2,
      "wordCount": 418
    },
    "url": "/posts/javascript-history-initial-decisions",
    "thumbnail": {
      "local": "/static/js-weird-36df170c.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-js-weird-36df170c-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAFCAIAAAD38zoCAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAhElEQVR4nGPwDkjr6l+5eccFe5do74C07MLurPwO74A0Bu+AtAWzt506+3Ty7LXeAWnNnYsr6qZ7+qcwePqn9TTMvHv986Pn/2MSKyvqplfWz4JKTOlafvn0y4uXP0fEl+cWdmcXdtu7RDCU10yprZttYuppaukrIqGloGwuKqkjIqEFAJfjN1Dk/I1QAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "javascript-history-references",
    "title": "JS는 왜 그 모양일까? - 참고 문헌",
    "date": "2023-12-16T00:00:00Z",
    "description": "JS의 역사를 알아보는 데 쓰인 자료들",
    "tags": [
      "javascript"
    ],
    "html": "<h1>썸네일</h1>\n<p><img src=\"/static/books-83c3466b.svg\" alt=\"책들\"></p>\n<h1>참고문헌들</h1>\n<h1>JS의 소리를 찾아서 - Javascript의 탄생</h1>\n<ul>\n<li>Allen Wirfs-Brock, Brendan Eich, JavaScript: The First 20 Years</li>\n</ul>\n<p><a href=\"https://dl.acm.org/doi/abs/10.1145/3386327\">https://dl.acm.org/doi/abs/10.1145/3386327</a></p>\n<p>ECMAScript 6 에디터이기도 했던 Allen Wirfs-Brock과 Javascript의 창시자 Brendan Eich가 매우 간헐적(13~15년 주기)으로 열리는 The History of Programming Languages Conference에서 공개한 190페이지 분량의 문헌이다. 가장 자세하고 많은 정보를 담고 있다.</p>\n<ul>\n<li>더글러스 크록포드, 자바스크립트는 왜 그 모양일까?</li>\n</ul>\n<p><a href=\"https://product.kyobobook.co.kr/detail/S000001033091\">https://product.kyobobook.co.kr/detail/S000001033091</a></p>\n<ul>\n<li>이펙티브 자바스크립트의 추천사</li>\n</ul>\n<p><a href=\"https://product.kyobobook.co.kr/book/preview/9788966260850?siteGb=DIKY\">https://product.kyobobook.co.kr/book/preview/9788966260850?siteGb=DIKY</a></p>\n<ul>\n<li>악셀 라우슈마이어 지음, 한선용 옮김, 자바스크립트를 말하다</li>\n</ul>\n<p><a href=\"https://product.kyobobook.co.kr/detail/S000001057544\">https://product.kyobobook.co.kr/detail/S000001057544</a></p>\n<p>4단원에 JS의 탄생 과정에 대한 2쪽짜리 섹션이 있다.</p>\n<ul>\n<li>How JavaScript Was Created</li>\n</ul>\n<p><a href=\"https://web.archive.org/web/20200227184037/https://speakingjs.com/es5/ch04.html\">https://web.archive.org/web/20200227184037/https://speakingjs.com/es5/ch04.html</a></p>\n<p>위의 '자바스크립트를 말하다'에서 참고한 부분의 원문이다. 약간의 인용문이 더 들어가 있고 다른 문서들과 비교해 볼 때 이쪽이 원문이라 그런지 좀더 정확하다고 보인다.</p>\n<ul>\n<li>A Brief History of JavaScript</li>\n</ul>\n<p><a href=\"https://auth0.com/blog/a-brief-history-of-javascript/\">https://auth0.com/blog/a-brief-history-of-javascript/</a></p>\n<p>JS의 긴 역사에 관한 매우 긴 글이다. 위에 있는 JavaScript: The First 20 Years 다음으로 자세한 편이라고 생각한다.</p>\n<ul>\n<li>브랜든 아이크의 인터뷰들</li>\n</ul>\n<p>The A-Z of Programming Languages: JavaScript</p>\n<p><a href=\"https://a-z.readthedocs.io/en/latest/javascript.html\">https://a-z.readthedocs.io/en/latest/javascript.html</a></p>\n<p>JS에 대한 브랜든 아이크와의 인터뷰를 실었다. JS의 탄생 당시 상황을 묘사한다.</p>\n<p>JavaScript creator ponders past, future</p>\n<p><a href=\"https://www.infoworld.com/article/2653798/javascript-creator-ponders-past--future.html\">https://www.infoworld.com/article/2653798/javascript-creator-ponders-past--future.html</a></p>\n<p>마찬가지로 인터뷰</p>\n<ul>\n<li>Douglas Crockford, The World's Most Misunderstood Programming Language Has Become the World's Most Popular Programming Language</li>\n</ul>\n<p><a href=\"http://crockford.com/javascript/popular.html\">http://crockford.com/javascript/popular.html</a></p>\n<p>더글라스 크록포드가 JS의 탄생 당시 상황을 약간 묘사한 부분이 있는데, 브랜든 아이크가 쓴 'Popularity'에서는 이 부분에 대해 더글라스는 넷스케이프에 있지 않았는데 이야기를 만들어내고 있다고 깠다.</p>\n<ul>\n<li>브랜든 아이크의 블로그</li>\n</ul>\n<p>JavaScript 1, 2, and in between</p>\n<p><a href=\"https://brendaneich.com/2005/06/javascript-1-2-and-in-between/\">https://brendaneich.com/2005/06/javascript-1-2-and-in-between/</a></p>\n<p>Popularity</p>\n<p><a href=\"https://brendaneich.com/2008/04/popularity/\">https://brendaneich.com/2008/04/popularity/</a></p>\n<p>A Brief History of JavaScript</p>\n<p><a href=\"https://brendaneich.com/2010/07/a-brief-history-of-javascript/\">https://brendaneich.com/2010/07/a-brief-history-of-javascript/</a></p>\n<p>New JavaScript Engine Module Owner <a href=\"https://brendaneich.com/2011/06/\">https://brendaneich.com/2011/06/</a></p>\n<p>Brendan Eich: An Introduction to JavaScript\n아이크가 JSConf에서 한 발표인데, Introduction은 절대 아니고 JS의 간략한 역사와 앞으로 나아갈 길, 자기가 보기에 좋았던 프로포절들을 소개하는 내용이다.</p>\n<p><a href=\"https://www.youtube.com/watch?v=1EyRscXrehw\">https://www.youtube.com/watch?v=1EyRscXrehw</a></p>\n<ul>\n<li>1995: The Birth of JavaScript</li>\n</ul>\n<p><a href=\"https://webdevelopmenthistory.com/1995-the-birth-of-javascript/\">https://webdevelopmenthistory.com/1995-the-birth-of-javascript/</a></p>\n<p>1995년의 JS가 탄생하던 상황을 묘사한 글</p>\n<ul>\n<li>넷스케이프가 브라우저에 Java를 넣겠다고 한 보도자료</li>\n</ul>\n<p><a href=\"https://web.archive.org/web/19970614003224/http://home.netscape.com/newsref/pr/newsrelease25.html\">https://web.archive.org/web/19970614003224/http://home.netscape.com/newsref/pr/newsrelease25.html</a></p>\n<ul>\n<li>영문 위키피디아의 Javascript</li>\n</ul>\n<p><a href=\"https://en.wikipedia.org/wiki/JavaScript\">https://en.wikipedia.org/wiki/JavaScript</a></p>\n<p>JS의 등장 배경을 웬만큼은 알 수 있다.</p>\n<ul>\n<li>2020년과 이후 JavaScript의 동향 - JavaScript(ECMAScript)</li>\n</ul>\n<p><a href=\"https://d2.naver.com/helloworld/4268738\">https://d2.naver.com/helloworld/4268738</a></p>\n<ul>\n<li>JS name was a big fat marketing scam!</li>\n</ul>\n<p><a href=\"https://twitter.com/BrendanEich/status/1334966006813319168\">https://twitter.com/BrendanEich/status/1334966006813319168</a></p>\n<ul>\n<li>prototype based vs. class based inheritance</li>\n</ul>\n<p><a href=\"https://stackoverflow.com/questions/816071/prototype-based-vs-class-based-inheritance\">https://stackoverflow.com/questions/816071/prototype-based-vs-class-based-inheritance</a></p>\n<p>프로토타입과 클래스 기반 상속의 차이점에 대한 질문과 답변</p>\n<ul>\n<li>이상한 나라의 JS</li>\n</ul>\n<p><a href=\"https://dev.to/ben/what-is-the-oddest-javascript-behavior-4dh2\">https://dev.to/ben/what-is-the-oddest-javascript-behavior-4dh2</a></p>\n<p><a href=\"https://zerolog.vercel.app/posts/weird-js\">https://zerolog.vercel.app/posts/weird-js</a></p>\n<p>JS의 많은 기묘한 동작 중 일부를 모아 놓았다.</p>\n<ul>\n<li>ECMAScript 4: The missing version</li>\n</ul>\n<p><a href=\"https://evertpot.com/ecmascript-4-the-missing-version/\">https://evertpot.com/ecmascript-4-the-missing-version/</a></p>\n<ul>\n<li>WWW 30주년 – 최초의 웹 사이트들을 만나자!</li>\n</ul>\n<p><a href=\"https://channy.creation.net/blog/1220\">https://channy.creation.net/blog/1220</a></p>\n<h1>JS의 소리를 찾아서 - Javascript의 초기 실수와 선택들</h1>\n<ul>\n<li>Allen Wirfs-Brock, Brendan Eich, JavaScript: The First 20 Years</li>\n</ul>\n<p><a href=\"https://dl.acm.org/doi/abs/10.1145/3386327\">https://dl.acm.org/doi/abs/10.1145/3386327</a></p>\n<ul>\n<li>더글러스 크록포드, 자바스크립트는 왜 그 모양일까?</li>\n</ul>\n<p><a href=\"https://product.kyobobook.co.kr/detail/S000001033091\">https://product.kyobobook.co.kr/detail/S000001033091</a></p>\n<ul>\n<li>이펙티브 자바스크립트의 추천사</li>\n</ul>\n<p><a href=\"https://product.kyobobook.co.kr/book/preview/9788966260850?siteGb=DIKY\">https://product.kyobobook.co.kr/book/preview/9788966260850?siteGb=DIKY</a></p>\n<ul>\n<li>악셀 라우슈마이어 지음, 한선용 옮김, 자바스크립트를 말하다</li>\n</ul>\n<p><a href=\"https://product.kyobobook.co.kr/detail/S000001057544\">https://product.kyobobook.co.kr/detail/S000001057544</a></p>\n<ul>\n<li>JS 창시자 브랜든 아이크의 호이스팅 의도 설명</li>\n</ul>\n<p><a href=\"https://twitter.com/BrendanEich/status/522394590301933568\">https://twitter.com/BrendanEich/status/522394590301933568</a></p>\n<ul>\n<li>The history of “typeof null”</li>\n</ul>\n<p><a href=\"https://2ality.com/2013/10/typeof-null.html\">https://2ality.com/2013/10/typeof-null.html</a></p>\n<ul>\n<li>JavaScript에서 날짜, 시간과 Temporal API</li>\n</ul>\n<p><a href=\"https://xo.dev/articles/js-temporal-api\">https://xo.dev/articles/js-temporal-api</a></p>\n<ul>\n<li>브랜든 아이크의 블로그</li>\n</ul>\n<p>JavaScript 1, 2, and in between</p>\n<p><a href=\"https://brendaneich.com/2005/06/javascript-1-2-and-in-between/\">https://brendaneich.com/2005/06/javascript-1-2-and-in-between/</a></p>\n<p>Popularity</p>\n<p><a href=\"https://brendaneich.com/2008/04/popularity/\">https://brendaneich.com/2008/04/popularity/</a></p>\n<ul>\n<li>Is JavaScript \"like Scheme\"? If so, are there some use cases that show JavaScript being used for similar problems and with similar style as Scheme?</li>\n</ul>\n<p><a href=\"https://www.quora.com/Is-JavaScript-like-Scheme-If-so-are-there-some-use-cases-that-show-JavaScript-being-used-for-similar-problems-and-with-similar-style-as-Scheme\">https://www.quora.com/Is-JavaScript-like-Scheme-If-so-are-there-some-use-cases-that-show-JavaScript-being-used-for-similar-problems-and-with-similar-style-as-Scheme</a></p>\n<ul>\n<li>Javascript this의 동작</li>\n</ul>\n<p><a href=\"https://stackoverflow.com/questions/541167/what-is-the-rationale-for-the-behavior-of-the-this-keyword-in-javascript\">https://stackoverflow.com/questions/541167/what-is-the-rationale-for-the-behavior-of-the-this-keyword-in-javascript</a></p>\n<ul>\n<li>Lambda Calculus And Closure</li>\n</ul>\n<p><a href=\"https://kimsereylam.com/racket/2019/02/06/lambda-calculus-and-closure.html\">https://kimsereylam.com/racket/2019/02/06/lambda-calculus-and-closure.html</a></p>\n<ul>\n<li>람다, 익명 함수, 클로저</li>\n</ul>\n<p><a href=\"https://hyunseob.github.io/2016/09/17/lambda-anonymous-function-closure/\">https://hyunseob.github.io/2016/09/17/lambda-anonymous-function-closure/</a></p>\n<ul>\n<li>Scheme의 Closure</li>\n</ul>\n<p><a href=\"https://www.cs.utexas.edu/ftp/garbage/cs345/schintro-v13/schintro_122.html\">https://www.cs.utexas.edu/ftp/garbage/cs345/schintro-v13/schintro_122.html</a></p>\n<p>Lambda Calculus And Closure</p>\n<p><a href=\"https://kimsereylam.com/racket/2019/02/06/lambda-calculus-and-closure.html\">https://kimsereylam.com/racket/2019/02/06/lambda-calculus-and-closure.html</a></p>\n<ul>\n<li>Is JavaScript \"like Scheme\"?</li>\n</ul>\n<p><a href=\"https://www.quora.com/Is-JavaScript-like-Scheme-If-so-are-there-some-use-cases-that-show-JavaScript-being-used-for-similar-problems-and-with-similar-style-as-Scheme\">https://www.quora.com/Is-JavaScript-like-Scheme-If-so-are-there-some-use-cases-that-show-JavaScript-being-used-for-similar-problems-and-with-similar-style-as-Scheme</a></p>\n<p>JavaScript Isn't Scheme 에 관한 Y Combinator의 댓글들 <a href=\"https://news.ycombinator.com/item?id=6068360\">https://news.ycombinator.com/item?id=6068360</a></p>\n<ul>\n<li>영문 위키피디아의 Javascript</li>\n</ul>\n<p><a href=\"https://en.wikipedia.org/wiki/JavaScript\">https://en.wikipedia.org/wiki/JavaScript</a></p>\n<p>JS의 등장 배경을 웬만큼은 알 수 있다.</p>\n<ul>\n<li>프로토타입의 철학에 관한 글들</li>\n</ul>\n<p>자바스크립트는 왜 프로토타입을 선택했을까 <a href=\"https://medium.com/@limsungmook/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%99%9C-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%84-%EC%84%A0%ED%83%9D%ED%96%88%EC%9D%84%EA%B9%8C-997f985adb42\">https://medium.com/@limsungmook/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%99%9C-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%84-%EC%84%A0%ED%83%9D%ED%96%88%EC%9D%84%EA%B9%8C-997f985adb42</a></p>\n<p>자바스크립트가 프로토타입을 선택한 이유와 이를 통해 이해하는 실행컨텍스트, 호이스팅, this <a href=\"https://wonsss.github.io/javascript/why-javascript-is-prototype-based-language/\">https://wonsss.github.io/javascript/why-javascript-is-prototype-based-language/</a></p>\n<p>객체지향 시스템과 패러다임 그리고 철학\n<a href=\"https://black7375.tistory.com/86\">https://black7375.tistory.com/86</a></p>\n<ul>\n<li>Temporal API</li>\n</ul>\n<p>JavaScript에서 날짜, 시간과 Temporal API</p>\n<p><a href=\"https://xo.dev/articles/js-temporal-api\">https://xo.dev/articles/js-temporal-api</a></p>",
    "excerpt": "썸네일\n\n참고문헌들\nJS의 소리를 찾아서 - Javascript의 탄생\n\nAllen Wirfs-Brock, Brendan Eich, JavaScript: The First 20 Years\n\nhttps://dl.acm.org/doi/abs/10.1145/3386327\nECMAScript 6 에디터이기도 했던 Allen Wirfs-Brock과 Javascript의 창시자 Brendan Eich가 매우 간헐적(13~15년 주기)으로 열리는 The History of ",
    "headingTree": [
      {
        "title": "썸네일",
        "url": "#썸네일",
        "items": []
      },
      {
        "title": "참고문헌들",
        "url": "#참고문헌들",
        "items": []
      },
      {
        "title": "JS의 소리를 찾아서 - Javascript의 탄생",
        "url": "#js의-소리를-찾아서---javascript의-탄생",
        "items": []
      },
      {
        "title": "JS의 소리를 찾아서 - Javascript의 초기 실수와 선택들",
        "url": "#js의-소리를-찾아서---javascript의-초기-실수와-선택들",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 2,
      "wordCount": 637
    },
    "url": "/posts/javascript-history-references",
    "thumbnail": {
      "local": "/static/books-83c3466b.svg",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-books-83c3466b-svg",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA/klEQVR4nB2OIWuFABRG79vafoeMsbq0InbhgdgsIhrEIDgtsm6w+bCJTNEhyLDJihsyi0yjgsEoi2uGx1PvcOmUc/g+sCzrNsuyp7qu42EYftq2/bRt+xEAABEP4Hne8zzPiIiXbdt24jzPS1VV7xzHPYDjOF9lWeI4judpmraiKJYoii5BEODxeHyFOI67XcjzfE2SBAVBQIZhVpqmkSTJE/i+33Vdh03TLK7roqqqq67rSNP0NwDc7BNvfd9jGIabJEmLYRhnURSRoqgPADjsZ0GWZck0zV/btlHTtE1RlJVl2RcAuII0Ta93ief5O47jclEUTwRB3P+XAPAHbkqPCPcZBDQAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "javascript-history-start",
    "title": "JS의 소리를 찾아서 - 시작하면서",
    "date": "2024-01-19T00:00:00Z",
    "description": "Javascript의 숨겨진 이야기를 찾아서",
    "tags": [
      "javascript",
      "history"
    ],
    "html": "<h1>JS의 소리를 찾아서 시리즈</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>시리즈</th></tr></thead><tbody><tr><td><a href=\"https://witch.work/posts/javascript-history-start\">JS의 소리를 찾아서 - 시작하면서</a></td></tr><tr><td><a href=\"https://witch.work/posts/javascript-history-the-birth\">JS의 소리를 찾아서 - Javascript의 탄생</a></td></tr><tr><td><a href=\"https://witch.work/posts/javascript-history-initial-decisions\">JS의 소리를 찾아서 - Javascript의 초기 실수와 선택들</a></td></tr></tbody></table>\n<h1>서론</h1>\n<blockquote>\n<p>최고의 시절이자 최악의 시절, 지혜의 시대이자 어리석음의 시대였다. 믿음의 세기이자 의심의 세기였으며, 빛의 계절이자 어둠의 계절이었다. 희망의 봄이면서 곧 절망의 겨울이었다.\n우리 앞에는 모든 것이 있었지만 한편으로 아무것도 없었다. 우리는 모두 천국으로 향해 가고자 했지만 우리는 엉뚱한 방향으로 걸었다.\n말하자면, 지금과 너무 흡사하게, 그 시절 목청 큰 권위자들 역시 좋든 나쁘든 간에 오직 극단적인 비교로만 그 시대를 규정하려고 했다.</p>\n<p>찰스 디킨스 저, 이은정 옮김, '두 도시 이야기', 펭귄클래식코리아, 13쪽</p>\n</blockquote>\n<p>누가 뭐래도 Javascript는 웹을 지배하고 있다. Javascript를 싫어하는 사람이라도 Javascript와 거기서 파생된 수많은 것들이 웹에 끼치고 있는 영향력을 무시할 수는 없다. 나 또한 프론트 개발자로서 Javascript와 친해져야만 했고 그게 정답이라 생각했다. 아마 많은 사람들이 그렇게 말할 것이다.</p>\n<p>하지만 그런 것 치고 Javascript에는 이상한 부분들이 많다. 자동 형변환 규칙이라든지 <code>==</code>연산자 등 자잘한 이상한 동작부터 프로토타입 상속이나 클로저 같은 언어 설계에 해당하는 부분들까지, Javascript에는 온통 낯설고 이상한 것 투성이다. <a href=\"https://zerolog.vercel.app/posts/weird-js\">이상한 나라의 JS</a>처럼 그런 낯선 부분들을 다룬 글도 산더미처럼 있다.</p>\n<p>물론 Python이나 Java 같은 다른 주류 언어들도 각자 수많은 비판을 받고 있다. 하지만 Javascript만큼 빠와 까를 모두 미치게 하는 언어도 없다.</p>\n<p>그럼, 대체 Javascript는 어쩌다 이런 모습으로 오늘날에 이르렀을까? 그리고 그 이상한 부분들은 어떻게 쓰일 수 있고 어떻게 처리되고 있을까?</p>\n<p>나는 Javascript에 기여한 사람도 아니고 모든 것을 완벽히 파헤칠 수 있을 만큼의 실력자도 아니다. 지금 시점에선 이미 많은 시간이 흘러서 알 수 없게 된 것들도 있다.</p>\n<p>하지만 여러 책, 문서, 인터뷰 등이 아직 많이 남아 있다. 그것들을 통해 Javascript 언어의 역사 그리고 그때 그 사람들이 무슨 생각을 했고 왜 이런 선택을 했는지 되짚어보는 시도를 해볼 수 있다.</p>\n<p>이런 것들을 궁금해하는 사람들은 많은 데에 비해 자료는 별로 없다고 느꼈다. 그래서 되는 대로 끌어모아 글을 하나하나 써본다. 다음에는 누군가 나보다 더 뛰어난 사람이 더 좋은 글을 쓰는 데에 조금이라도 기반이 되었으면 좋겠다.</p>\n<p>내가 더 많은 자료를 접하고 성장하면서 이 시리즈는 점차 늘어나고 개정되어갈 것이다. 완성에는 오랜 시간이 걸릴 걸로 예상한다. 2024년 1월 현재 다음과 같은 시리즈들이 있다.</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>시리즈</th></tr></thead><tbody><tr><td><a href=\"https://witch.work/posts/javascript-history-start\">JS의 소리를 찾아서 - 시작하면서</a></td></tr><tr><td><a href=\"https://witch.work/posts/javascript-history-the-birth\">JS의 소리를 찾아서 - Javascript의 탄생</a></td></tr><tr><td><a href=\"https://witch.work/posts/javascript-history-initial-decisions\">JS의 소리를 찾아서 - Javascript의 초기 실수와 선택들</a></td></tr></tbody></table>",
    "excerpt": "JS의 소리를 찾아서 시리즈\n|시리즈|\n|---|\n|JS의 소리를 찾아서 - 시작하면서|\n|JS의 소리를 찾아서 - Javascript의 탄생|\n|JS의 소리를 찾아서 - Javascript의 초기 실수와 선택들|\n서론\n\n최고의 시절이자 최악의 시절, 지혜의 시대이자 어리석음의 시대였다. 믿음의 세기이자 의심의 세기였으며, 빛의 계절이자 어둠의 계절이었다. 희망의 봄이면서 곧 절망의 겨울이었다.\n우리 앞에는 모든 것이 있었지만 한편으로 아무것도 없었다. 우리는 ",
    "headingTree": [
      {
        "title": "JS의 소리를 찾아서 시리즈",
        "url": "#js의-소리를-찾아서-시리즈",
        "items": []
      },
      {
        "title": "서론",
        "url": "#서론",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 24
    },
    "url": "/posts/javascript-history-start",
    "thumbnail": {
      "local": "/thumbnails/javascript-history-start-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-javascript-history-start-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAhUlEQVR4nD2MuQ0DIRAACdwJLaxEP8TbACVsA34Ci4vOogECqsAitCHAIriMEIlgrbPkm3BGGuGcU0ohIgBIKQFAa71tmyCi0w8ppbU2xmdKaYwhvPfGGEQkIu89M885mXkPIYRaa2utlMJ/xCuXd86fWnvvh93D7b6cL9fHusYYjw8zfwElOmZeeOdAIwAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "javascript-history-the-birth",
    "title": "JS의 소리를 찾아서 - Javascript의 탄생",
    "date": "2024-01-20T00:00:00Z",
    "description": "Javascript가 만들어지던 시대의 이야기",
    "tags": [
      "javascript",
      "history"
    ],
    "html": "<h1>JS의 소리를 찾아서 시리즈</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>시리즈</th></tr></thead><tbody><tr><td><a href=\"https://witch.work/posts/javascript-history-start\">JS의 소리를 찾아서 - 시작하면서</a></td></tr><tr><td><a href=\"https://witch.work/posts/javascript-history-the-birth\">JS의 소리를 찾아서 - Javascript의 탄생</a></td></tr><tr><td><a href=\"https://witch.work/posts/javascript-history-initial-decisions\">JS의 소리를 찾아서 - Javascript의 초기 실수와 선택들</a></td></tr></tbody></table>\n<p>이 글은 Javascript가 탄생하던 시절의 역사적인 배경에 대해 다룬다.</p>\n<h1>1. Javascript 이전의 상황</h1>\n<blockquote>\n<p>넷스케이프는 웹이 더 동적이어야 함을 빨리 깨달았습니다.</p>\n<p>악셀 라우슈마이어 저, 한선용 옮김, '자바스크립트를 말하다' 97쪽, '자바스크립트는 어떻게 만들어졌는가?</p>\n</blockquote>\n<h2>1.1. 브라우저의 등장</h2>\n<p>1989년에서 1991년 사이에 팀 버너스-리가 개발자라면 한번쯤 들어보았을 HTML을 만들었다. 그리고 이 HTML로 만들어진 페이지를 볼 수 있는 브라우저 WorldWideWeb도 제작하여 배포했다.</p>\n<p>하지만 당시에는 별로 큰 주목을 받지 못했다. 이것이 주목받기 시작한 건 1993년 1월 마크 앤드리슨과 에릭 비나가 만든 웹브라우저 모자이크가 출시되면서였다.</p>\n<p>모자이크 브라우저는 기술적인 지식이 없는 사람들도 쉽게 사용할 수 있었고 윈도우즈를 지원했다. 그리고 사진 등의 멀티미디어를 페이지 내에서 볼 수 있었다. 기존 브라우저에서는 이미지 등의 멀티미디어를 보기 위해서 링크를 클릭하여 새 창에 이미지를 띄워야만 했다.</p>\n<p>이런 여러 장점을 갖췄던 모자이크는 초기 웹이 널리 퍼져나가는 데에 큰 역할을 했다. 이 모자이크 브라우저를 개발한 리드 개발자들은 곧 인터넷의 역사에서 꽤나 자주 등장하는 넷스케이프를 설립한다.</p>\n<p>넷스케이프는 1994년 12월 더 세련된 브라우저인 넷스케이프 네비게이터 1.0을 출시했다. 이는 빠르게 모자이크를 대체하고 주류가 되었다.</p>\n<h2>1.2. 브라우저에 멀티미디어 넣기</h2>\n<p>이제 웹 브라우저에서 HTML로 만들어진 문서를 보고 공유할 수 있게 되었다. 이는 엄청난 혁신이었다. 그러나 넷스케이프는 영리 기업이었기에 초기의 웹에 가치를 더하여 뭔가 돈을 벌 방법을 찾아야 했다.</p>\n<p>그렇게 하기 위해서는 웹의 콘텐츠가 풍부해져야 했다. 그리고 그걸 위해서는 당연하게도 웹에서 멀티미디어를 잘 볼 수 있도록 해야 했다. 하지만 당시에는 멀티미디어를 페이지에 삽입하는 태그가 없었다. 따라서 사용자들은 이미지를 보려면 링크를 클릭하여 새 창에 이미지를 띄워야 했다.</p>\n<p>이는 1993년 이미 마크 앤드리슨이 모자이크를 만들 때부터 고려되었다. 그는 그때부터 이미지를 페이지 중간에 삽입하여 보여주는 <code>&#x3C;img></code> 태그를 HTML 표준으로 제안하기도 했다. 또 1993년 마크 앤드리슨은 HTML 표준에 <code>&#x3C;img></code>가 들어가지 않았음에도 모자이크에 해당 기능을 포함시켰다. 모자이크는 그렇게 멀티미디어를 페이지 내부에 삽입할 수 있다는 장점과 함께 널리 퍼졌다.</p>\n<p>그 다음에는 무엇을 해야 했을까? 당시에는 웹 페이지가 정적인 문서로만 존재했다. 이를 사용자와 상호작용할 수 있도록 하는 게 문제였다. 이 문제는 우리가 모두 아는 Javascript가 등장함으로써 해결된다.</p>\n<p>하지만 당시에 넷스케이프는 그 문제에 당장 착수할 수 없었다. 당시에는 웹의 속도가 끔찍하게 느렸기에, 이런 환경 하에서 브라우저가 기본적인 멀티미디어를 더 잘 다룰 수 있게 하는 데에 집중해야 했기 때문이다. 당시 넷스케이프 1.0 브라우저에서는 사용자가 보려는 이미지를 로딩하는 동안 텍스트를 먼저 보여주는 최적화 등의 작업이 진행되었다.</p>\n<h2>1.3. 동적인 웹을 향해서</h2>\n<p>1995년 즈음에는 웹에서 멀티미디어를 다루는 작업이 어느 정도 안정되었다. 그래서 이제 넷스케이프는 웹에서 멀티미디어를 다루는 걸 넘어 웹 페이지와 사용자의 상호작용이 가능하도록 만들고자 했다. 넷스케이프의 창립자 마크 앤드리슨 또한 웹이 더 동적으로 동작해야 한다고 꾸준히 생각했다.</p>\n<p>이 시기의 웹페이지들은 페이지가 로드되고 나면 서버와의 상호작용 없이는 동적으로 뭔가를 할 수 없었다. 당시에는 사용자가 폼에 입력한 값을 검증할 때조차도 서버에 데이터를 보내고 피드백을 받아야 했다!</p>\n<p>당시의 HTML만으로는 페이지가 동적으로 움직이고 사용자와 제대로 상호작용하는 게 불가능했다. 웹 페이지에 동적인 무언가를 넣을 수 있게 해줄 언어가 필요했다. HTML에 프로그래밍 언어를 삽입할 수 있도록 해야 했다.</p>\n<p>이제야 새로운 언어, 우리가 아는 Javascript의 이야기가 나온다.</p>\n<h1>2. Javascript가 없을 뻔한 이야기</h1>\n<blockquote>\n<p>이미 잘 알려져 있겠지만 1995년 5월, 나는 '자바와 비슷해야 하고', '초보자에게도 쉬워야 하며', '넷스케이프 브라우저 내의 거의 모든 것을 제어할 수 있어야 한다'는 강압적이고도 강제적인 관리 명령하에 열흘 만에 Javascript를 만들었다.</p>\n<p>데이비드 허먼 저, 김준기 옮김, '이펙티브 자바스크립트'에 실린 브랜든 아이크의 추천사</p>\n</blockquote>\n<h2>2.1. 아이크의 등장</h2>\n<p>넷스케이프는 네비게이터 브라우저에 동적인 기능을 추가할 수 있는 언어를 구현하기로 했다. HTML에 프로그래밍 언어의 코드를 임베딩할 수 있게 하려고 한 것이다.</p>\n<p>그리고 1995년 4월, 브랜든 아이크를 고용했다. 이 브랜든 아이크는 이후 Javascript의 창시자가 된다. 그가 고용된 이유는 Silicon Graphics Inc.와 MicroUnity라는 회사에서 \"커널과 네트워크 작업을 할 수 있는 작은 특수목적 언어\"를 만들어 본 경험이 있기 때문이었다.</p>\n<p>하지만 아이크가 처음부터 새로운 언어를 만들고자 한 건 아니었다. 그는 기존 언어인 Scheme을 브라우저에 구현하겠다고 생각하고 있었다. 넷스케이프에서도 그렇게 하라고 이야기했다.</p>\n<p>왜 Scheme이었는가 하면, 아이크가 Silicon Graphics Inc. 소속일 때 닉 톰슨이라는 사람이 아이크에게 SICP를 추천하여 읽게 했다고 한다. 그게 매우 감명깊었던 아이크는 리스프의 방언 중 하나인 Scheme을 사용하기로 결정했다. SICP는 표지의 마법사 그림을 따서 \"마법사책\"이라고도 불리는 프로그래밍 계의 고전인데 리스프로 쓰여 있다.</p>\n<p>리스프의 방언이었던 Scheme은 매우 문법이 가벼웠고 동적이었으며 강력했고, 함수를 일급 객체로 다루는 함수형 패러다임을 받아들이고 있었다.</p>\n<h2>2.2. 상황의 전개</h2>\n<blockquote>\n<p>\"Netscape plus Java kills Windows.\"</p>\n<p>Marc Andreessen, 1995, 넷스케이프 회의</p>\n</blockquote>\n<p>아이크는 1995년 4월 3일 넷스케이프의 클라이언트 팀으로 고용되었다. 하지만 고용되자마자 웹 서버와 프록시 제품들을 만드는 서버 그룹으로 옮겨져서 차세대 HTTP 관련 설계를 만드는 일을 한 달 정도 했다. 그래서 바로 웹에 필요한 스크립트 언어를 만드는 데 착수할 수 없었다.</p>\n<p>그렇게 아이크가 Javascript를 만드는 작업을 시작하지 못하고 있는 동안 당시의 소프트웨어 회사들 간의 경쟁은 상황을 다른 구도로 끌고 간다.</p>\n<p>넷스케이프는 1994년 말 마이크로소프트의 저가 인수 제안을 거절했다. 이후 넷스케이프 경영진은 마이크로소프트에게 직접적으로 공격받을 것으로 예상했고 따라서 먼저 웹 시장을 선점하려고 했다. 이를 위해서 썬 마이크로시스템즈와 손을 잡는다.</p>\n<p>1995년 5월 23일 썬 마이크로시스템즈는 그 유명한 Java를 발표했다. 그리고 넷스케이프는 같은 날, Java를 넷스케이프 네비게이터 브라우저에서 사용할 수 있도록 하겠다는 발표를 했다. 이는 당시 마이크로소프트에 대항하기 위한 공동 전선이었다. 넷스케이프 창립자 마크 앤드리슨은 회의에서 \"넷스케이프와 자바가 합쳐지면 윈도우를 이깁니다\"라고 외쳤다.</p>\n<p>여담이지만 지금 상황을 보면 알 수 있듯이 이런 시도들은 Javascript만 빼고 모두 실패하였다. 넷스케이프는 IE에 졌고 Java Applet은 실패했다. Javascript만 남아서 지금의 웹을 이끌고 있다.</p>\n<p>아무튼 그런 이유로 브라우저에 넣을 언어에 대한 계획은 변경되었다. 사업 계획이나 출시 기간을 고려하면 Scheme, Python, Perl, Tcl같은 기존의 언어를 브라우저에 넣는 것은 불가능했다.</p>\n<p>따라서 넷스케이프의 마크 앤드리슨과 썬의 빌 조이 등 \"높으신 분들\"은 어차피 브라우저에 들어갈 Java를 보완하는 작은 스크립트 언어를 설계하고 구현하기로 했다.</p>\n<h2>2.3. 초기의 토론</h2>\n<p>당시 넷스케이프 내부에서는 열띤 토론이 있었다. Java를 브라우저에 넣을 것인데 다른 언어가 왜 필요하냐는 것이었다. 이런 주장을 하는 사람들은 썬과 넷스케이프의 주류였는데 그들의 의문은 이랬다.</p>\n<ol>\n<li>Java는 브라우저에서 쓰일 스크립트 언어로 부적합한가?</li>\n<li>왜 2개의 언어가 굳이 필요한가?</li>\n<li>넷스케이프가 새로운 언어를 만들 만큼의 전문성이 있는가?</li>\n</ol>\n<p>첫번째 의문은 쉽게 반박되었다. Java는 물론 지금도 주류를 차지하고 있을 만큼 좋은 언어다. 하지만 2024년 현재까지도 상대적으로 '쉬운 언어'의 포지션은 아니다. 하지만 브라우저에서는 누구나 간단하게 쓸 수 있는 스크립트 언어가 필요하다는 공감대가 있었다. 하지만 Java는 대부분의 웹 구성원들이 간단하게 사용하기에는 너무 복잡했다.</p>\n<p>Java를 쓰려면 클래스와 메서드를 알아야 했고 타입과 변수, 리턴값에 대한 개념 등등이 모두 필요했다. 다음 코드는 Java로 Hello World를 출력하는 코드인데, 이 간단한 작업을 하는 코드조차 제대로 읽기 위해서는 클래스, 메서드, 패키지, 타입과 변수 등의 개념을 모두 알아야 한다.</p>\n<pre><code class=\"language-java\">// Java로 Hello World 출력하기\nimport java.util.*;\n\npublic class Main{\n\tpublic static void main(String args[]) {\n    System.out.println(\"Hello World!\");\n\t}\n}\n</code></pre>\n<p>따라서 넷스케이프는 더 가볍고, 배우기 쉬운 스크립트 언어가 필요하다고 판단했다. 지금도 Python등의 언어가 스크립트 언어라는 이유로 배우기 쉽다고 여겨지는데, 당시에도 가볍고 쉬운 언어를 위해서는 스크립트 언어가 트렌드였다고 한다.</p>\n<p>두번째 의문은 경쟁자였던 마이크로소프트의 제품 전략을 인용하는 것으로 해결되었다. 당시 마이크로소프트는 전문 프로그래머들에게는 C++을, 아마추어나 디자이너 등 비전문가들에게는 Visual Basic을 제공하고 있었다. 즉 C++로 작성된 웹 컴포넌트들을 조립해 사용하기 위한 접착제 언어(원문은 <code>glue language</code>)로써 Visual Basic이 존재했던 것이다.</p>\n<p>새로 만들어질 스크립트 언어 또한 Visual Basic과 비슷한 포지션이 될 것으로 보였다. 즉 새로 만들어질 스크립트 언어는 이미지나 플러그인, Java Applet 등으로 작성된 컴포넌트를 사용해서 컨텐츠를 만들 디자이너나 파트타임 프로그래머들을 위한 \"초보자용\" 언어였다.</p>\n<p>Java와 Javascript를 마이크로소프트의 C++(전문 프로그래머를 위한 어려운 언어)과 Visual Basic(비전문가를 위한 쉬운 언어)에 대응되는 존재로 만들고자 한 것이다. 빌 조이(썬의 공동 창립자) 또한 그 아이디어에 동의했다.</p>\n<p>이때 넷스케이프의 경영진들은 새로운 스크립트 언어는 Java의 보완재 같은 역할이므로 Java와 비슷한 문법을 가져야 한다고 결정했다. 이는 Perl, Python, TCL, Scheme과 같은 기존 언어들을 도입하는 선택지를 배제하도록 했다.</p>\n<p>결국 이 토론은 Java와 새롭게 브라우저에 들어갈 언어가 서로 다른 목적을 가지고 있었기 때문으로 결론이 났다.</p>\n<p>브라우저의 Java는 C++이나 Java를 기존에 사용했던 웹 컴포넌트 제작자들을 위한 언어였고, 브라우저에 들어갈 새로운 언어는 웹 디자이너와 같은 비전문가들을 위한 언어였던 것이다.</p>\n<p>하지만 아직 세번째 의문이 남았다. 넷스케이프가 새로운 언어를 만들 만큼의 전문성이 있는가? 1995년 9월 출시될 넷스케이프 네비게이터 2.0에 새로운 언어가 들어갈 수 있겠는가?</p>\n<p>이건 브랜든 아이크가 Mocha(당시 마크 앤드리슨이 지은 이름)를 만듦으로써 직접 증명해내야 했다.</p>\n<h1>3. Javascript의 첫 개발</h1>\n<h2>3.1. 새로운 언어의 개발</h2>\n<p>아이크가 개발할 언어는 이제 Scheme과 비슷하면 안 되었다. 새로운 언어의 중요한 요구사항은 바로 'Java와 비슷해야 한다'는 거였다. Java의 보완재 역할을 해야 했기 때문이다.</p>\n<p>하지만 그건 Java처럼 클래스 기반이 아니라 다른 방식으로 객체를 모델링해야 했다. 그리고 Java를 보완하는 언어로 포지셔닝되어 있었기 때문에 너무 고평가되면 안 되었다. 즉, 홍보를 위해서 Java와 비슷하면서도 약간 모자라 보여야 했다.</p>\n<p>그런데 그런 것보다 가장 큰 문제가 있었다. 아이크에게는 시간이 없었다. 넷스케이프 네비게이터 2.0은 1995년 9월에 출시되어야 했고 새로운 스크립트 언어는 그 브라우저에 들어가야 했다. 즉 1995년 9월 전에 완성되어야 했다.</p>\n<p>또한 이 새로운 스크립트 언어는 브라우저 개발에서 그렇게 우선순위가 높은 작업도 아니었기 때문에 시간도 많이 주어지지 않았다. 그래서 아이크는 1995년 5월, 단 10일만에 새로운 스크립트 언어의 프로토타입을 만들었다. 당연히 실수도 많았고 날림으로 개발된 부분도 많았다.</p>\n<p>그래도 열흘의 프로토타이핑 기간 이후 이루어진 시연은 성공적이었다. 그리고 이는 넷스케이프 네비게이터 2.0의 프리알파 버전에 데모로 들어갔다.</p>\n<h2>3.2. Javascript의 이름에 관해서</h2>\n<p>Javascript의 처음 이름은 마크 앤드리슨이 지은 \"Mocha\"였다. 넷스케이프의 홍보팀은 잠재적인 상표권 충돌의 가능성을 보고 이후 이 이름을 \"LiveScript\"로 이름을 바꾸었다. 당시 넷스케이프에서 내놓은 다른 제품들의 이름도 \"Live\"로 시작했는데 이것들과 이름을 맞추려고 하는 의도도 있었다.</p>\n<p>그 뒤 9월까지 아이크는 새로운 언어를 개선하고 네비게이터 2.0에 들어갈 수 있도록 준비했다. 그리고 1995년 9월 넷스케이프 네비게이터 2.0이 출시되었다. 여기에는 아이크의 새로운 언어가 LiveScript라는 이름으로 들어갔고 12월 초에 LiveScript는 Javascript로 이름이 바뀌었다.</p>\n<p>참고로 새로운 언어의 이름이 결국 Javascript가 된 건 잘 알려진 대로 Java의 인기를 빌려서 인기를 얻기 위해서였다. 1995년 Java는 새로나온 핫한 언어였고 넷스케이프와 썬 마이크로시스템즈는 그 유명세를 이용하기로 한 것이다.</p>\n<p>1995년 12월의 넷스케이프와 썬의 보도자료에서도 Javascript를 \"객체 스크립트 언어\"이면서 \"Java 객체의 프로퍼티와 동작을 동적으로 수정할 수 있고\" \"쉬운 온라인 어플리케이션 개발을 위한 Java의 보완재\"라고 소개하는 등 Java와의 연관성을 강조했다.</p>",
    "excerpt": "JS의 소리를 찾아서 시리즈\n|시리즈|\n|---|\n|JS의 소리를 찾아서 - 시작하면서|\n|JS의 소리를 찾아서 - Javascript의 탄생|\n|JS의 소리를 찾아서 - Javascript의 초기 실수와 선택들|\n이 글은 Javascript가 탄생하던 시절의 역사적인 배경에 대해 다룬다.\n1. Javascript 이전의 상황\n\n넷스케이프는 웹이 더 동적이어야 함을 빨리 깨달았습니다.\n악셀 라우슈마이어 저, 한선용 옮김, '자바스크립트를 말하다' 97쪽, '자바",
    "headingTree": [
      {
        "title": "JS의 소리를 찾아서 시리즈",
        "url": "#js의-소리를-찾아서-시리즈",
        "items": []
      },
      {
        "title": "1. Javascript 이전의 상황",
        "url": "#1-javascript-이전의-상황",
        "items": [
          {
            "title": "1.1. 브라우저의 등장",
            "url": "#11-브라우저의-등장",
            "items": []
          },
          {
            "title": "1.2. 브라우저에 멀티미디어 넣기",
            "url": "#12-브라우저에-멀티미디어-넣기",
            "items": []
          },
          {
            "title": "1.3. 동적인 웹을 향해서",
            "url": "#13-동적인-웹을-향해서",
            "items": []
          }
        ]
      },
      {
        "title": "2. Javascript가 없을 뻔한 이야기",
        "url": "#2-javascript가-없을-뻔한-이야기",
        "items": [
          {
            "title": "2.1. 아이크의 등장",
            "url": "#21-아이크의-등장",
            "items": []
          },
          {
            "title": "2.2. 상황의 전개",
            "url": "#22-상황의-전개",
            "items": []
          },
          {
            "title": "2.3. 초기의 토론",
            "url": "#23-초기의-토론",
            "items": []
          }
        ]
      },
      {
        "title": "3. Javascript의 첫 개발",
        "url": "#3-javascript의-첫-개발",
        "items": [
          {
            "title": "3.1. 새로운 언어의 개발",
            "url": "#31-새로운-언어의-개발",
            "items": []
          },
          {
            "title": "3.2. Javascript의 이름에 관해서",
            "url": "#32-javascript의-이름에-관해서",
            "items": []
          }
        ]
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 137
    },
    "url": "/posts/javascript-history-the-birth",
    "thumbnail": {
      "local": "/thumbnails/javascript-history-the-birth-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-javascript-history-the-birth-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAjklEQVR4nGNYuXKlpaVlVlaWsbGxurq6mZlZWlraixcvGCZMmKirq2tvb29gYMDNzS0pKSknJweSWLt2bWRkZHBwcFhYWG5u7rlz5/bv3//792+GU6dOdYJBT09PU1PT79+//4MBw/Ubt27fufPkyZMvX778////NxiAJKbOnDtp8pTFixadO3cOIgHRAQAf6VpUBFyQQgAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "javascript-json-object",
    "title": "JSON은 무엇인가? 그리고 어떻게 검증하는가?",
    "date": "2023-08-27T01:00:00Z",
    "description": "JSON의 구조와 사용법, 그리고 검증 방법을 알아보자",
    "tags": [
      "javascript"
    ],
    "html": "<h1>1. JSON이란?</h1>\n<p>인터넷이 발전하면서 네트워크를 통해서 점점 양도 많고 다양한 종류의 데이터를 주고받게 되었다. 그런데 이런 복잡한 데이터를 단순한 문자열만으로 보낼 수는 없었다. 그래서 특정한 형식으로 보내게 되었다. XML, JSON, CSV 등이 그것이다.</p>\n<p>하지만 XML은 데이터를 만들기 너무 복잡했다. <a href=\"https://json.org/example.html\">JSON 공식 홈페이지에서는 JSON의 예시를 보여주면서 같은 데이터를 XML로 작성한 예시도 보여주는데 HTML 형식이라 익숙하기야 하지만 JSON에 비해 매우 복잡한 걸 볼 수 있다.</a></p>\n<p>그리고 CSV는 엑셀과 비슷한 표 형식이라 고차원 데이터를 표현하기 힘들었다. 그래서 <a href=\"https://en.wikipedia.org/wiki/Douglas_Crockford\">더글라스 크록포드</a>가 JS의 객체 리터럴과 비슷한 문법을 따르는(JSON의 원래 이름도 <code>JavaScript Object Notation</code>이다) JSON을 만들고 이를 홍보하는 사이트 <a href=\"https://www.json.org/json-ko.html\">json.org(한국어 버전)</a>도 만들었다.</p>\n<p>이는 XML보다 가볍고 CSV보다 표현력이 좋아서 널리 쓰이게 되었다. 또한 JSON 관련된 문법도 Javascript 문법에 편입되고 <code>JSON.stringify</code>와 <code>JSON.parse</code>와 같은 메서드도 생겼다.</p>\n<p>그래서 지금은 JSON이 네트워크를 통해 데이터를 주고받는 가장 표준적인 형식 중 하나가 되었다. firebase의 실시간 데이터베이스나 로컬 스토리지와 같은 데에 데이터를 저장할 때도 JSON을 쓴다.</p>\n<p>YAML같은 대체 형식도 많지만 이미 JSON이 JS 문법에도 어느 정도 끼어 있을 정도로 너무 널리 쓰이고 있어서 덜 쓰이는 편이다.</p>\n<h1>2. JSON의 구조</h1>\n<p>JSON은 JavaScript Object Notation이라는 이름 그대로 JS의 객체 리터럴 문법을 따르는 문자열이다. JS의 기본 타입인 문자열, 숫자, 배열, 불린, null, 다른 객체를 포함할 수 있다.</p>\n<p>json.org에서도 다음과 같이 JSON의 값으로 쓰일 수 있는 것들을 나열하고 있다.</p>\n<p><img src=\"/static/json_value-ad4dd4d0.png\" alt=\"JSON의 값 형식\"></p>\n<p>다음과 같이 쓸 수 있다. 이 예시는 <a href=\"https://json.org/example.html\">json.org의 공식 예시에서 가져왔다.</a></p>\n<pre><code class=\"language-json\">{\n  \"menu\": {\n  \"header\": \"SVG Viewer\",\n  \"items\": [\n      {\"id\": \"Open\"},\n      {\"id\": \"OpenNew\", \"label\": \"Open New\"},\n      null,\n      {\"id\": \"ZoomIn\", \"label\": \"Zoom In\"},\n      {\"id\": \"ZoomOut\", \"label\": \"Zoom Out\"},\n      {\"id\": \"OriginalView\", \"label\": \"Original View\"},\n      null,\n      {\"id\": \"Quality\"},\n      {\"id\": \"Pause\"},\n      {\"id\": \"Mute\"},\n      null,\n      {\"id\": \"Find\", \"label\": \"Find...\"},\n      {\"id\": \"FindAgain\", \"label\": \"Find Again\"},\n      {\"id\": \"Copy\"},\n      {\"id\": \"CopyAgain\", \"label\": \"Copy Again\"},\n      {\"id\": \"CopySVG\", \"label\": \"Copy SVG\"},\n      {\"id\": \"ViewSVG\", \"label\": \"View SVG\"},\n      {\"id\": \"ViewSource\", \"label\": \"View Source\"},\n      {\"id\": \"SaveAs\", \"label\": \"Save As\"},\n      null,\n      {\"id\": \"Help\"},\n      {\"id\": \"About\", \"label\": \"About Adobe CVG Viewer...\"}\n    ]\n  }\n}\n</code></pre>\n<p>이런 JSON 객체를 <code>.json</code>확장자를 가진 텍스트 파일에 저장할 수 있다. 그 경우 MIME 타입은 <code>application/json</code>이 된다.</p>\n<p>JS 객체와의 차이는 undefined와 심볼 자료형이 없고 문자열이나 프로퍼티 키 작성시 큰따옴표만을 써야 한다는 것이다. 프로퍼티 키 또한 큰따옴표로 반드시 묶여 있어야 한다. 또한 JSON은 함수를 포함할 수 없다. <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/JSON\">더 자세한 규칙은 MDN의 JSON 문서를 참고하자.</a></p>\n<h1>3. JS에서 JSON 사용하기</h1>\n<p>JS에서 JSON을 사용하기 위한 함수로 <code>JSON.stringify</code>와 <code>JSON.parse</code>가 있다. 이 함수들은 JSON을 JS 객체로 변환하거나 JS 객체를 JSON으로 변환하는 데 사용된다. 이 함수들에 대해 알아보자.</p>\n<h2>3.1. stringify, parse</h2>\n<p>객체와 JSON간의 변환을 지원하기 위한 함수로 <code>JSON.stringify</code>와 <code>JSON.parse</code>가 있다. <code>JSON.stringify</code>는 객체를 JSON으로 변환하고 <code>JSON.parse</code>는 JSON을 객체로 변환한다. 이 함수들은 중첩 객체나 중첩 객체가 변환된 JSON 문자열도 잘 처리한다.</p>\n<pre><code class=\"language-js\">let myStudy={\n  name:\"Javascript\",\n  level:\"Beginner\",\n  time:\"2 months\",\n  isCompleted:true,\n  members:[\n    \"John\",\n    \"Peter\",\n    \"Mary\",\n    \"Bessy\",\n  ]\n}\n\nlet myStudyJSON=JSON.stringify(myStudy);\n/* {\"name\":\"Javascript\",\"level\":\"Beginner\",\"time\":\"2 months\",\"isCompleted\":true,\"members\":[\"John\",\"Peter\",\"Mary\",\"Bessy\"]} */\nconsole.log(myStudyJSON);\n</code></pre>\n<p>이렇게 변경된 문자열은 JSON으로 인코딩된, 직렬화 처리된, 문자열로 변환된, 결집된 객체(JSON-encoded, serialized, stringified, marshalled object)라 한다. 이 문자열은 네트워크를 통해 전송하거나 저장소에 저장할 수 있다.</p>\n<p>또한 <code>JSON.stringify</code>는 객체뿐 아니라 배열, 문자열, 숫자, 불린, null도 JSON으로 변환할 수 있다. 함수나 undefined, 심볼 자료형은 변환할 수 없으며 이러한 프로퍼티를 가진 객체에 대해서는 해당 프로퍼티를 무시한다.</p>\n<pre><code class=\"language-js\">let myStudy={\n  name:\"Javascript\",\n  level:\"Beginner\",\n  time:\"2 months\",\n  isCompleted:true,\n  sayHello:function(){\n    console.log(\"Hello\");\n  }\n}\n\nlet myStudyJSON=JSON.stringify(myStudy);\n/* 결과에서 sayHello 함수는 무시된다 */\nconsole.log(myStudyJSON);\n</code></pre>\n<p>단 주의할 점은 순환 참조가 있을 때 객체를 JSON 문자열로 바꾸는 것이 실패한다는 점이다. 순환 참조를 JSON으로 바꾸려고 한다는 <code>Error: Converting circular structure to JSON</code> 오류가 발생한다.</p>\n<p>그리고 <code>JSON.parse</code>를 사용하면 JSON으로 인코딩된 객체를 다시 객체로 변환할 수 있다.</p>\n<h2>3.2. stringify 심화</h2>\n<p>JSON의 전체 형식은 다음과 같다.</p>\n<pre><code class=\"language-js\">JSON.stringify(value[, replacer[, space]])\n</code></pre>\n<p>value는 당연히 인코딩하려는 값이다. <code>replacer</code>는 JSON으로 인코딩하려는 프로퍼티들이 담긴 배열 혹은 매핑 함수이다. <code>space</code>는 직렬화 시 중간에 삽입해 줄 공백 문자 수를 나타낸다.</p>\n<h3>3.2.1. replacer</h3>\n<p>JSON으로 객체를 직렬화할 때 특정 프로퍼티만 포함하거나 특정 프로퍼티만 제외하고 싶을 수 있다. 그럴 때 이 인자를 사용할 수 있다. 예를 들어 다음과 같이 하면 <code>members</code> 프로퍼티를 제외한 나머지 프로퍼티만 JSON으로 변환된다. 그렇게 replacer 배열을 전달해 줬기 때문이다.</p>\n<pre><code class=\"language-js\">let myStudy={\n  name:\"Javascript\",\n  level:\"Beginner\",\n  time:\"2 months\",\n  isCompleted:true,\n  members:[\"John\",\"Peter\",\"Mary\",\"Bessy\"]\n}\n\nlet myStudyJSON=JSON.stringify(myStudy, [\"name\",\"level\",\"time\",\"isCompleted\"]);\nconsole.log(myStudyJSON);\n</code></pre>\n<p>하지만 이보다 훨씬 더 객체의 프로퍼티 갯수가 많은 경우가 있을 수 있으므로, 특정 프로퍼티를 직렬화에서 제외할 때는 함수를 쓰는 게 더 간편하다.</p>\n<p><code>replacer</code>에 넘기는 함수는 key, value를 인자로 받으며 객체의 각 프로퍼티를 재귀적으로 순회한다. value값이 객체라면 해당 객체로 진입해서 프로퍼티들을 순회한다는 뜻이다. 그리고 해당 함수는 기존 프로퍼티 값을 대신해 사용할 값을 반환하게 된다.</p>\n<p>즉 만약 프로퍼티 값 그대로 직렬화하려면 value를 반환하도록 하면 되고 누락시키려는 프로퍼티에 대해서는 undefined를 반환하면 된다. 물론 value 대신 사용할 다른 값을 반환해도 된다. 다음과 같이 하면 members 프로퍼티는 누락된다.</p>\n<pre><code class=\"language-js\">let myStudy={\n  name:\"Javascript\",\n  level:\"Beginner\",\n  time:\"2 months\",\n  isCompleted:true,\n  members:[\"John\",\"Peter\",\"Mary\",\"Bessy\"]\n}\n\nlet myStudyJSON=JSON.stringify(myStudy, (key, value)=>{\n  if(key===\"members\"){\n    return undefined;\n  }\n  return value;\n});\n</code></pre>\n<p>참고로 replacer 내에서 <code>this</code>는 현재 처리하고 있는 프로퍼티가 위치한 객체를 가리키게 된다. 중첩 객체일 수도 있으므로 이게 꼭 전체 객체를 가리키는 것은 아니다.</p>\n<p>그리고 <code>replacer</code>함수에서 처리하는 key, value 쌍을 모두 훑어보면 신기한 것을 발견할 수 있다. 다음과 같은 코드를 실행해보자.</p>\n<pre><code class=\"language-js\">let myStudy={\n  name:\"Javascript\",\n  level:\"Beginner\",\n  time:\"2 months\",\n  isCompleted:true,\n  members:[\"John\",\"Peter\",\"Mary\",\"Bessy\"],\n}\n\nlet myStudyJSON=JSON.stringify(myStudy, (key, value)=>{\n  console.log(key, value);\n  if(key==\"name\"){\n    return \"My study\";\n  }else{\n    return value;\n  }\n});\nconsole.log(myStudyJSON);\n</code></pre>\n<p>그러면 다음과 같은 출력 결과가 나온다. <code>name</code>이 key인 프로퍼티에 대해서는 값이 <code>My study</code>로 바뀐 것을 볼 수 있다.</p>\n<p><img src=\"/static/stringify-iteration-d4575b86.png\" alt=\"출력 결과\"></p>\n<p>배열이야 사실 객체니까 인덱스와 그 값을 순회하는 건 이상할 게 없다. 아마 결과값을 만들 때 걸러낼 것이다. 그런데 맨 윗줄 출력에 전체 객체가 출력되는 것은 뭘까?</p>\n<p>이는 <code>replacer</code>함수가 처음으로 호출될 때 전체 객체를 감싸는 래퍼 객체가 만들어지기 때문이다. 즉 <code>replacer</code>함수는 <code>key</code>가 <code>\"\"</code>이고 <code>value</code>가 전체 객체인 래퍼 객체부터 순회하게 된다. 그래서 처음에 전체 객체가 1번 출력된 것이다.</p>\n<h3>3.2.2. space</h3>\n<p><code>JSON.stringify</code>의 세 번째 인수 space는 가독성을 위해서 들여쓰기에 삽입해줄 공백 문자 수를 나타낸다. space는 가독성을 위한 목적일 뿐이므로 데이터 전달만을 위한다면 space 인수를 전달하지 않는 편이다.</p>\n<p>하지만 만약 space 인수를 전달하면 space 수만큼의 들여쓰기와 함께 stringify 결과가 포매팅된다.</p>\n<pre><code>- space를 2로 전달했을 때의 stringify 결과\n{\n  \"name\": \"My study\",\n  \"level\": \"Beginner\",\n  \"time\": \"2 months\",\n  \"isCompleted\": true,\n  \"members\": [\n    \"John\",\n    \"Peter\",\n    \"Mary\",\n    \"Bessy\"\n  ]\n}\n</code></pre>\n<h3>3.2.3. toJSON</h3>\n<p>객체에 <code>toJSON</code>메서드가 구현되어 있으면 <code>JSON.stringify</code>에서는 이를 감지하고 객체의 <code>toJSON</code>을 자동으로 호출해 반영해준다. 따라서 특정 객체에 대해서 <code>stringify</code>결과를 적당히 변경하고 싶다면 해당 객체에 <code>toJSON</code>메서드를 구현하면 된다.</p>\n<pre><code class=\"language-js\">let obj={\n  test:{\n    name:\"Javascript test\",\n    time:\"1 hour\",\n    toJSON(){\n      return this.time;\n    }\n  }\n}\n\n// {\"test\":\"1 hour\"}\nlet myJSON=JSON.stringify(obj);\nconsole.log(myJSON);\n</code></pre>\n<h2>3.3. parse 심화</h2>\n<p><code>JSON.parse</code>의 전체 형태는 다음과 같다.</p>\n<pre><code class=\"language-js\">JSON.parse(text[, reviver])\n</code></pre>\n<p>여기서 당연히 text는 JSON 형식 문자열이다. 그럼 <code>reviver</code>는 무슨 역할일까? 특정 값을 변경해야 한다는 것을 <code>JSON.parse</code>에게 알리는 역할을 한다.</p>\n<p>다음과 같이 하면 <code>JSON.parse</code>는 객체를 반환할 때 <code>age</code>프로퍼티의 값을 5 늘려서 변환한다.</p>\n<pre><code class=\"language-js\">let obj={\n  name:\"John\",\n  age:30,\n  city:\"New York\"\n}\n\nlet myJSON=JSON.stringify(obj);\nconsole.log(myJSON);\n\nlet myObj=JSON.parse(myJSON, (key, value)=>{\n  if(key=='age') return value+5;\n  else return value;\n});\n// {name: 'John', age: 35, city: 'New York'}\nconsole.log(myObj);\n</code></pre>\n<h2>3.4. fetch API</h2>\n<p>JSON을 그대로 import해서 사용하는 방법도 몇 가지 있지만(<a href=\"https://ui.toast.com/posts/ko_20211209\">JS에서의 JSON 모듈</a>, <a href=\"https://stackoverflow.com/questions/34944099/how-to-import-a-json-file-in-ecmascript-6\">ES6로 JSON 가져오기</a>) 복잡하기도 하고 어차피 JSON은 데이터 전달이 목적이므로 잘 쓰이지는 않는다.</p>\n<p>대신 서버를 통한 데이터 전달이나 클라이언트 스토리지 등에 자주 쓰이는 편이다. 데이터를 서버에서 전달받을 때도 JSON을 쓸 때가 많은데, 그래서 서버 통신을 위한 API나 라이브러리에는 JSON을 쉽게 다룰 수 있도록 도와주는 기능이 많다.</p>\n<p>예를 들어 <code>fetch</code>를 사용하면 <code>json()</code>메서드를 활용하여 Response를 JSON으로 파싱한 결과를 감싼 Promise를 얻을 수 있다.</p>\n<pre><code class=\"language-js\">const requestURL =\n  \"https://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json\";\n\nasync function getJSON(url) {\n  try {\n    const response = await fetch(url);\n    const data = await response.json();\n    console.log(data);\n  } catch (error) {\n    throw error;\n  }\n}\n\n// 가져온 JSON 객체가 콘솔에 출력된다\ngetJSON(requestURL);\n</code></pre>\n<p><code>getJSON</code>에서 <code>data</code>를 반환하도록 하면 JSON으로부터 추출된 객체를 반환받을 수도 있다.</p>\n<h1>4. JSON 검증하기</h1>\n<p>JSON은 데이터를 전달할 때 많이 사용된다. 서버에서 데이터를 받는다든지 할 때 JSON으로 받는 게 굉장히 흔하다. 하지만 서버에서 도착한 JSON이 우리가 원하는 형식을 갖추었는지 검증할 수 있을까?</p>\n<p>일단 typescript로는 안된다. ts의 타입들은 컴파일되면서 전부 사라지는데 JSON이 서버에서 도착하는 데이터라고 한다면 이는 런타임에 도착하기 때문에 ts로는 검증할 수 없다.</p>\n<p>값을 검증하기 위한 API를 따로 사용할 수 있다. <a href=\"https://github.com/colinhacks/zod\">zod</a>나 <a href=\"https://github.com/jquense/yup\">Yup</a>과 같은 유명한 라이브러리들이 나와 있다.</p>\n<p>예를 들어 Yup의 경우 다음과 같이 <code>validate</code>함수를 통한 런타임 값 검증을 지원하고, <code>InferType</code>을 통해서 타입 추론도 지원한다. 다음 코드는 Yup의 공식 github에서 가져왔다. ts를 다뤄본 사람이라면 쓱 보고도 대충 무슨 뜻들인지 알 수 있을 만큼 직관적이다.</p>\n<pre><code class=\"language-ts\">import { object, string, number, date, InferType } from 'yup';\n\nlet userSchema = object({\n  name: string().required(),\n  age: number().required().positive().integer(),\n  email: string().email(),\n  website: string().url().nullable(),\n  createdOn: date().default(() => new Date()),\n});\n\n// parse and assert validity\nconst user = await userSchema.validate(await fetchUser());\n\ntype User = InferType&#x3C;typeof userSchema>;\n/* {\n  name: string;\n  age: number;\n  email?: string | undefined\n  website?: string | null | undefined\n  createdOn: Date\n}*/\n</code></pre>\n<p>하지만 좀더 JSON에 특화된 형식으로 검증을 할 수는 없을까? 이를 위해 JSON schema, JSON typedef가 있다.</p>\n<h2>4.1. JSON schema</h2>\n<p>JSON의 검증을 위한 유명한 포맷으로 <a href=\"https://json-schema.org/\">JSON schema</a>라는 게 있다. JSON schema는 JSON의 형식을 표현하고 검증하기 위한 규칙을 만드는 선언적인 포맷이다.</p>\n<p>이 JSON schema 또한 JSON 형식으로 표현된다. <code>example.schema.json</code>과 같은 형식으로 파일을 만들고 그 내부에 작성하는 것이다.(중간에 <code>.schema</code>는 꼭 붙이지는 않아도 된다.)</p>\n<p>예를 들어서 다음과 같이 작성할 수 있다. 해당 예제는 <a href=\"https://json-schema.org/learn/getting-started-step-by-step\">JSON schema 공식 홈페이지의 getting started</a>에서 가져왔다.</p>\n<p><code>type</code>으로 해당 프로퍼티의 타입을 나타내고 <code>properties</code>로 객체에 있어야 할 프로퍼티들을 나열하는 식이라는 것을 쉽게 눈치챌 수 있다.</p>\n<pre><code class=\"language-json\">{\n  \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n  \"$id\": \"https://example.com/product.schema.json\",\n  \"title\": \"Product\",\n  \"description\": \"A product from Acme's catalog\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"productId\": {\n      \"description\": \"The unique identifier for a product\",\n      \"type\": \"integer\"\n    },\n    \"productName\": {\n      \"description\": \"Name of the product\",\n      \"type\": \"string\"\n    },\n    \"price\": {\n      \"description\": \"The price of the product\",\n      \"type\": \"number\",\n      \"exclusiveMinimum\": 0\n    },\n    \"tags\": {\n      \"description\": \"Tags for the product\",\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\"\n      },\n      \"minItems\": 1,\n      \"uniqueItems\": true\n    }\n  },\n  \"required\": [ \"productId\", \"productName\", \"price\" ]\n}\n</code></pre>\n<p><code>type</code>은 <code>string</code>, <code>number</code>, <code>boolean</code>, <code>object</code>, <code>array</code>, <code>null</code>이 가능하다.</p>\n<p>특정 타입의 프로퍼티에 대해서는 추가적인 검증 조건을 지정할 수 있다. 예를 들어서 <code>array</code>타입의 경우 <code>items</code>를 통해서 배열의 아이템들의 타입을 지정할 수 있다. 그리고 <code>object</code>타입의 경우 <code>properties</code>를 통해서 객체의 프로퍼티들의 타입을 지정할 수 있다.</p>\n<pre><code class=\"language-json\">{\n  \"title\": \"Person\",\n  \"description\": \"Schema for a person\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"age\": {\n      \"type\": \"number\"\n    }\n  }\n}\n</code></pre>\n<p>또한 <code>type</code>대신 <code>enum</code>으로 배열의 요소 중 하나를 갖도록 하는 검증 조건을 만들 수도 있고 <code>required</code>, <code>minItems</code>, <code>uniqueItems</code> 등으로 필수 프로퍼티, 최소 아이템 갯수, 중복 아이템 허용 여부 등의 검증 조건을 지정하는 등 다른 여러 옵션이 가능하다.</p>\n<p>이러한 검증 조건들은 <a href=\"https://json-schema.org/specification.html\">JSON Schema spec</a>을 참고하거나 <a href=\"https://madplay.github.io/post/understanding-json-schema\">MadPlay님의 블로그 글</a>을 참고하여 더 알아볼 수 있다.</p>\n<h2>4.2. JSON type definition</h2>\n<p>JSON type definition(이제 그냥 jtd라고 하겠다)은 JSON schema와 비슷하게 JSON 문서의 형식을 표현하는 JSON 포맷이다.</p>\n<p>앞서 살펴본 JSON schema와 달리 <a href=\"https://datatracker.ietf.org/doc/html/rfc8927\">RFC 표준</a>에도 등록되어 있다.</p>\n<p>다음 8가지 종류의 스키마를 사용할 수 있다.</p>\n<p>먼저 typescript의 <code>any</code>와 같은 empty form이다. 이는 어떤 값이든 허용한다는 뜻이고 <code>{}</code>으로 나타낼 수 있다.</p>\n<p>typescript의 원시값 타입과 같은 type form을 쓸 수 있다. <code>string</code>, <code>int32</code>, <code>int64</code>, <code>float32</code>, <code>float64</code>, <code>bool</code>, <code>timestamp</code>등을 쓸 수 있다.</p>\n<p>enum은 <code>enum</code>프로퍼티를 통해서 지정할 수 있고 <code>enum</code>프로퍼티의 값은 <code>string</code>의 배열이다. enum form에 지정된 배열에 들어 있는 값 외에는 쓸 수 없다는 것을 뜻한다. typescript의 enum과 비슷하다.</p>\n<pre><code class=\"language-json\">{\n  \"enum\": [\"red\", \"green\", \"blue\"]\n}\n</code></pre>\n<p>elements form은 배열의 요소들의 타입을 나타낼 때 쓰인다.</p>\n<pre><code class=\"language-json\">{\n  \"elements\": { \"type\": \"string\" }\n}\n</code></pre>\n<p>properties form을 이용해서 객체의 프로퍼티들의 타입을 지정할 수 있다. 또한 <code>optionalProperties</code>를 이용해서 선택적으로 사용할 수 있는 프로퍼티를 지정할 수도 있고 <code>\"additionalProperties\": true</code>를 지정함으로써 추가 프로퍼티를 허용할 것인지를 선택할 수 있다. 물론 기본값은 추가 프로퍼티를 허용하지 않는 쪽이다.</p>\n<pre><code class=\"language-json\">{\n  \"properties\": {\n    \"name\": { \"type\": \"string\" },\n    \"age\": { \"type\": \"int32\" }\n  },\n  \"optionalProperties\": {\n    \"address\": { \"type\": \"string\" }\n  }\n}\n</code></pre>\n<p>values form은 객체의 key에 대해서는 알 수 없지만 객체 프로퍼티가 갖는 값들의 타입을 제한하고 싶을 때 쓸 수 있다. typescript의 <code>Record&#x3C;string, T></code>와 비슷하다.</p>\n<pre><code class=\"language-json\">{\n  \"values\": { \"type\": \"string\" }\n}\n</code></pre>\n<p>discriminator form은 객체의 프로퍼티 중 하나를 통해서 객체의 타입을 구분하고 싶을 때 쓸 수 있다. typescript의 tagged union과 비슷하다. <code>discriminator</code>값을 통해서 어떤 값을 discriminator로 검증할 것인지를 명시하고 <code>mapping</code>으로 가능한 스키마 값들을 나열한다.</p>\n<p>예를 들어서 다음과 같이 스키마를 지정했을 경우 Person의 키 값은 <code>STUDENT</code>나 <code>TEACHER</code>에서 지정한 형태만 될 수 있다.</p>\n<pre><code class=\"language-json\">{\n  \"discriminator\": \"Person\",\n  \"mapping\":{\n    \"STUDENT\":{\n      \"properties\":{\n        \"name\":{\"type\":\"string\"},\n        \"age\":{\"type\":\"int32\"},\n        \"school\":{\"type\":\"string\"}\n      }\n    },\n    \"TEACHER\":{\n      \"properties\":{\n        \"name\":{\"type\":\"string\"},\n        \"age\":{\"type\":\"int32\"},\n        \"subject\":{\"type\":\"string\"}\n      }\n    }\n  }\n}\n</code></pre>\n<p>마지막으로 <code>ref</code>폼은 다른 스키마를 재사용하고 싶을 때 사용한다.</p>\n<pre><code class=\"language-json\">{\n  // \"definitions\" 프로퍼티에 coordinates가 정의되어 있다고 하자.\n  \"properties\": {\n    \"userLoc\": { \"ref\": \"coordinates\" },\n    \"serverLoc\": { \"ref\": \"coordinates\" }\n  }\n}\n</code></pre>\n<p>더 자세한 정보는 <a href=\"https://jsontypedef.com/docs/jtd-in-5-minutes/\">Learn JSON Typedef in 5 Minutes</a>이나 <a href=\"https://datatracker.ietf.org/doc/html/rfc8927\">RFC 8927</a>문서를 보고 배울 수 있다. 혹은 <a href=\"https://ajv.js.org/json-type-definition.html\">ajv 라이브러리에서 제공하는 비공식 레퍼런스</a>도 참고할 만 하다.</p>\n<h2>4.3. JSON Schema vs type def</h2>\n<p>자세한 비교는 <a href=\"https://ajv.js.org/guide/schema-language.html\">ajv의 두 JSON 검증 스키마 비교 문서</a>를 참고할 수 있다.</p>\n<p>하지만 둘의 공식 문서를 보고 개인적으로 느낀 바는 전반적으로 jtd가 약간은 더 사용하기 편하고 간결한 느낌이었다. 물론 JSON schema가 좀더 복잡한 형태의 검증을 지원한다는 장점이 있다.</p>\n<p>하지만 JSON에서 그런 복잡한 형태의 검증이 필요할 일이 생길 일이 많지는 않다고 생각하고, ajv 등의 라이브러리에서 약간의 비표준 검증을 지원하기 때문에 이런 단점을 어느 정도 극복할 수 있다.</p>\n<p>그러나 ajv나 typia, typebox 같은 주류 JSON 검증, 스키마 생성 라이브러리에서 JSON schema를 주력으로 사용하고 있기 때문에, 커뮤니티까지 고려했을 때는 JSON schema를 사용하는 편이 좋을 것 같다. jtd가 더 간결하다고 했지만 아주 큰 차이는 아니기 때문이다.</p>\n<h1>정리와 예고</h1>\n<p>JSON이 무엇이고, 어떻게 구성되며 JS에서는 어떻게 사용하는지에 대해 간단히 알아보았다. 또한 JSON에서 값 검증을 위한 포맷 2가지인 JSON schema와 jtd에 대해서도 간략히 알아보았다.</p>\n<p>그러면 JSON schema와 jtd를 이용한 검증은 실제로 어떻게 하는 걸까? JSON schema를 이용한 검증을 지원하는 메이저한 라이브러리로 ajv, typia(이 라이브러리의 이름은 원래 typescript-json이었다)가 있다. 다음 글에서는 이런 라이브러리들에 대해 알아보겠다.</p>\n<h1>참고 자료</h1>\n<p>코딩애플 - JSON (존슨) 은 자바스크립트 문법이 아닙니다 <a href=\"https://www.youtube.com/watch?v=1ID6pfTViXo\">https://www.youtube.com/watch?v=1ID6pfTViXo</a></p>\n<p>JSON으로 작업하기 <a href=\"https://developer.mozilla.org/ko/docs/Learn/JavaScript/Objects/JSON\">https://developer.mozilla.org/ko/docs/Learn/JavaScript/Objects/JSON</a></p>\n<p>JSON과 메서드 <a href=\"https://ko.javascript.info/json\">https://ko.javascript.info/json</a></p>\n<p>JSON 스키마란 무엇인가? <a href=\"https://madplay.github.io/post/understanding-json-schema\">https://madplay.github.io/post/understanding-json-schema</a></p>\n<p>ajv 공식 문서의 스키마 비교\n<a href=\"https://ajv.js.org/guide/schema-language.html\">https://ajv.js.org/guide/schema-language.html</a></p>\n<p>JSON typedef 시작하기\n<a href=\"https://jsontypedef.com/docs/jtd-in-5-minutes/\">https://jsontypedef.com/docs/jtd-in-5-minutes/</a></p>\n<p>클라이언트에서 데이터 검증하기 <a href=\"https://ethansup.net/blog/client-runtime-validator\">https://ethansup.net/blog/client-runtime-validator</a></p>",
    "excerpt": "1. JSON이란?\n인터넷이 발전하면서 네트워크를 통해서 점점 양도 많고 다양한 종류의 데이터를 주고받게 되었다. 그런데 이런 복잡한 데이터를 단순한 문자열만으로 보낼 수는 없었다. 그래서 특정한 형식으로 보내게 되었다. XML, JSON, CSV 등이 그것이다.\n하지만 XML은 데이터를 만들기 너무 복잡했다. JSON 공식 홈페이지에서는 JSON의 예시를 보여주면서 같은 데이터를 XML로 작성한 예시도 보여주는데 HTML 형식이라 익숙하기야 하지만 JSON에 ",
    "headingTree": [
      {
        "title": "1. JSON이란?",
        "url": "#1-json이란",
        "items": []
      },
      {
        "title": "2. JSON의 구조",
        "url": "#2-json의-구조",
        "items": []
      },
      {
        "title": "3. JS에서 JSON 사용하기",
        "url": "#3-js에서-json-사용하기",
        "items": [
          {
            "title": "3.1. stringify, parse",
            "url": "#31-stringify-parse",
            "items": []
          },
          {
            "title": "3.2. stringify 심화",
            "url": "#32-stringify-심화",
            "items": [
              {
                "title": "3.2.1. replacer",
                "url": "#321-replacer",
                "items": []
              },
              {
                "title": "3.2.2. space",
                "url": "#322-space",
                "items": []
              },
              {
                "title": "3.2.3. toJSON",
                "url": "#323-tojson",
                "items": []
              }
            ]
          },
          {
            "title": "3.3. parse 심화",
            "url": "#33-parse-심화",
            "items": []
          },
          {
            "title": "3.4. fetch API",
            "url": "#34-fetch-api",
            "items": []
          }
        ]
      },
      {
        "title": "4. JSON 검증하기",
        "url": "#4-json-검증하기",
        "items": [
          {
            "title": "4.1. JSON schema",
            "url": "#41-json-schema",
            "items": []
          },
          {
            "title": "4.2. JSON type definition",
            "url": "#42-json-type-definition",
            "items": []
          },
          {
            "title": "4.3. JSON Schema vs type def",
            "url": "#43-json-schema-vs-type-def",
            "items": []
          }
        ]
      },
      {
        "title": "정리와 예고",
        "url": "#정리와-예고",
        "items": []
      },
      {
        "title": "참고 자료",
        "url": "#참고-자료",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 4,
      "wordCount": 975
    },
    "url": "/posts/javascript-json-object",
    "thumbnail": {
      "local": "/static/json_value-ad4dd4d0.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-json_value-ad4dd4d0-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAYAAAD+Bd/7AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAkklEQVR4nGNgYGCQW7VqVcKWLVtKOzo6rHbv3l3R2NhovnXr1pZly5Z5MIDApk2buOrr69kaGxtNt2/f3pKSkqIIEtu2bRs7SJ7x////jCBGfX29ydatW9uToqLkQXyYOIjBBKLb29sNjxw50hwdHS2DrgBmgtGpU6eaAgMDsSuYNGmSxrFjxyrT0tJEwBIMDIwA1DlJiim5m6cAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "javascript-making-ball-object",
    "title": "Canvas로 객체 실습해보기",
    "date": "2023-08-24T00:00:00Z",
    "description": "MDN 객체 실습 - 날아다니는 공들 만들기",
    "tags": [
      "javascript"
    ],
    "html": "<h1>시작</h1>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_building_practice\">MDN에서는 JS 객체의 실습을 해보라고 Canvas API를 이용한 예제를 제공한다. 공이 날아다니는 걸 구현해보는 예제인데 생각보다 재미있다.</a></p>\n<h1>1. 기본 구조</h1>\n<h2>1.1. HTML</h2>\n<p>다음과 같은 HTML을 만든다.</p>\n<pre><code class=\"language-html\">&#x3C;!DOCTYPE html>\n&#x3C;html lang=\"en-us\">\n  &#x3C;head>\n    &#x3C;meta charset=\"utf-8\">\n    &#x3C;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    &#x3C;meta name=\"viewport\" content=\"width=device-width\">\n    &#x3C;title>공튀기기&#x3C;/title>\n    &#x3C;link rel=\"stylesheet\" href=\"index.css\">\n  &#x3C;/head>\n\n  &#x3C;body>\n    &#x3C;h1>공튀기기&#x3C;/h1>\n    &#x3C;canvas>&#x3C;/canvas>\n\n    &#x3C;script src=\"main.js\">&#x3C;/script>\n  &#x3C;/body>\n&#x3C;/html>\n</code></pre>\n<h2>1.2. JS</h2>\n<p>그리고 <a href=\"https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_building_practice#getting_started\">여기</a>에 있는 css, js 파일을 복사하자. 스크롤바를 숨기고 캔버스를 화면에 꽉 차게 만들며 기본적인 함수 선언이 된 코드다.</p>\n<p>그리고 JS 파일에 다음처럼 공 클래스를 작성한다.</p>\n<pre><code class=\"language-js\">class Ball{\n  /*\n  x, y는 공의 2차원 좌표, velX, velY는 공의 2차원 속도\n  color,size는 공의 색상과 크기(px단위 반지름)\n  */\n  constructor(x, y, velX, velY, color, size){\n    this.x = x;\n    this.y = y;\n    this.velX = velX;\n    this.velY = velY;\n    this.color = color;\n    this.size = size\n  }\n\n  // 공을 canvas 객체(ctx)에 그린다.\n  draw(){\n    ctx.beginPath();\n    ctx.fillStyle = this.color;\n    ctx.arc(this.x, this.y, this.size, 0, 2*Math.PI);\n    ctx.fill();\n  }\n}\n</code></pre>\n<p>이제 Ball 클래스 생성자를 통해 공을 만들고 <code>ball.draw()</code>를 호출하면 공을 그릴 수 있다. 그리고 공의 위치를 업데이트하는 함수를 클래스 내에 작성한다. 공이 벽에 부딪쳐서 튕겨나오는 것을 구현한 것을 볼 수 있다.</p>\n<pre><code class=\"language-js\">update(){\n  // 공이 반대 방향으로 튀기는 것\n  if(this.x+this.size>=width){\n    this.velX = -(this.velX);\n  }\n\n  if(this.x-this.size&#x3C;=0){\n    this.velX = -(this.velX);\n  }\n\n  if(this.y+this.size>=height){\n    this.velY = -(this.velY);\n  }\n\n  if(this.y-this.size&#x3C;=0){\n    this.velY = -(this.velY);\n  }\n  //공 위치 업데이트\n  this.x+=this.velX;\n  this.y+=this.velY;\n}\n</code></pre>\n<p>이제 공들을 캔버스에 만들어 보자. 다음 코드는 랜덤하게 위치와 속도, 크기를 지정한 공을 만들고 캔버스에 그리는 코드다.</p>\n<pre><code class=\"language-js\">const balls=[];\n\nwhile(balls.length&#x3C;25){\n  let size = random(10,20);\n  let ball = new Ball(\n    random(0+size,width-size),\n    random(0+size,height-size),\n    random(-7,7),\n    random(-7,7),\n    randomRGB(),\n    size\n  );\n  balls.push(ball);\n}\n\nfunction loop(){\n  ctx.fillStyle = 'rgba(0,0,0,0.25)';\n  ctx.fillRect(0,0,width,height);\n\n  for(let i=0;i&#x3C;balls.length;i++){\n    balls[i].draw();\n    balls[i].update();\n  }\n  // loop를 재귀적으로 호출\n  requestAnimationFrame(loop);\n}\n\nloop();\n</code></pre>\n<p>이를 브라우저에서 열어보면 검은 배경에 공들이 움직이는 걸 볼 수 있다.</p>\n<h1>2. 충돌 구현</h1>\n<p>충돌도 구현해보자. 다음 메서드를 Ball 생성자에 추가한다.</p>\n<pre><code class=\"language-js\">collisionDetect(){\n  for(const ball of balls){\n    if(this!==ball){\n      const dx = this.x-ball.x;\n      const dy = this.y-ball.y;\n      const distance = Math.sqrt(dx*dx+dy*dy);\n      // 물리적인 충돌 시뮬레이션이 목적은 아니므로, 충돌시 색만 같게 한다.\n      if(distance&#x3C;this.size+ball.size){\n        ball.color = this.color = randomRGB();\n      }\n    }\n  }\n}\n</code></pre>\n<p>그리고 loop 함수의 모든 공을 순회하는 부분에 공 각각의 collisionDetect 메서드를 호출하도록 추가한다.</p>\n<pre><code class=\"language-js\">function loop(){\n  ctx.fillStyle = 'rgba(0,0,0,0.25)';\n  ctx.fillRect(0,0,width,height);\n\n  for(let i=0;i&#x3C;balls.length;i++){\n    balls[i].draw();\n    balls[i].update();\n    // 이 부분 추가\n    balls[i].collisionDetect();\n  }\n  // loop를 재귀적으로 호출\n  requestAnimationFrame(loop);\n}\n</code></pre>\n<p>공들이 화면에서 서로 부딪히면 색이 바뀌는 걸 볼 수 있다.</p>\n<h1>3. 예제 발전시키기</h1>\n<h2>3.1. 사용자 조작 기능</h2>\n<p>사용자가 조작할 수 있는 공을 추가하고 거기에 공이 닿으면 공이 사라지도록 해보자. 또한 클래스 설계를 좀더 잘해보자.</p>\n<p>먼저 사용자가 조작할 수 있는 공과 그냥 공이 상속받을 일반적인 <code>Shape</code>클래스를 정의하자. <code>Shape</code>클래스는 <code>Ball</code>클래스와 <code>EvilCircle</code>클래스의 공통점인 위치와 속도만을 담는다.</p>\n<pre><code class=\"language-js\">class Shape{\n  constructor(x,y,velX,velY){\n    this.x = x;\n    this.y = y;\n    this.velX = velX;\n    this.velY = velY;\n  }\n}\n</code></pre>\n<p>그리고 <code>Ball</code> 클래스가 Shape를 상속받는 걸로 하고 생성자를 바꾸자. canvas에 공이 존재하는지를 뜻하는 exists 프로퍼티도 추가하고 충돌 감지 함수도 exist 시에만 체크하도록 변경한다.</p>\n<pre><code class=\"language-js\">class Ball extends Shape{\n  constructor(x, y, velX, velY, color, size){\n    super(x,y,velX,velY);\n    this.color = color;\n    this.size = size\n    // 공이 존재하는지(사용자 공에게 먹히면 false가 됨)\n    this.exists = true;\n  }\n  // ...\n\n  collisionDetect(){\n    for(const ball of balls){\n      if(this!==ball &#x26;&#x26; ball.exists){\n        const dx = this.x-ball.x;\n        const dy = this.y-ball.y;\n        const distance = Math.sqrt(dx*dx+dy*dy);\n        // 물리적인 충돌 시뮬레이션이 목적은 아니므로, 충돌시 색만 같게 한다.\n        if(distance&#x3C;this.size+ball.size){\n          ball.color = this.color = randomRGB();\n        }\n      }\n    }\n  }\n}\n</code></pre>\n<p>이제 사용자가 조작할 공, 공을 먹어치우는 EvilCircle을 정의하자. EvilCircle은 Shape를 상속받고, 공을 먹어치우는 메서드를 추가한다. 이런 공은 하나밖에 없을 예정이긴 하지만 연습을 위해 클래스를 사용한다. <a href=\"https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Adding_bouncing_balls_features\">예제</a>에서 시키는 그대로 하면 된다.</p>\n<pre><code class=\"language-js\">class EvilCircle extends Shape{\n  constructor(x,y){\n    super(x,y,20,20);\n    this.color = 'white';\n    this.size = 10;\n    // 사용자가 키로 조작할 수 있도록 키다운 이벤트 리스너 추가\n    window.addEventListener('keydown',(e)=>{\n      switch(e.key){\n        case 'a':\n          this.x-=this.velX;\n          break;\n        case 'd':\n          this.x+=this.velX;\n          break;\n        case 'w':\n          this.y-=this.velY;\n          break;\n        case 's':\n          this.y+=this.velY;\n          break;\n      }\n    })\n  }\n\n  // EvilCircle을 canvas 객체(ctx)에 그린다.\n  draw(){\n    ctx.beginPath();\n    ctx.lineWidth = 5;\n    ctx.strokeStyle = this.color;\n    ctx.arc(this.x, this.y, this.size, 0, 2*Math.PI);\n    ctx.stroke();\n  }\n\n  // 공이 화면을 벗어나지 않도록 한다.\n  update(){\n    // 공이 밖으로 벗어나는 걸 막는다\n    if(this.x+this.size>=width){\n      this.x=width-this.size;\n    }\n\n    if(this.x-this.size&#x3C;=0){\n      this.x=this.size;\n    }\n\n    if(this.y+this.size>=height){\n      this.y=height-this.size;\n    }\n\n    if(this.y-this.size&#x3C;=0){\n      this.y=this.size;\n    }\n  }\n\n  collisionDetect(){\n    for(const ball of balls){\n      // 존재하는 공만 따지면 된다.\n      if(ball.exists){\n        const dx = this.x-ball.x;\n        const dy = this.y-ball.y;\n        const distance = Math.sqrt(dx*dx+dy*dy);\n        // 물리적인 충돌 시뮬레이션이 목적은 아니므로, 충돌시 색만 같게 한다.\n        if(distance&#x3C;this.size+ball.size){\n          ball.exists = false;\n        }\n      }\n    }\n  }\n}\n</code></pre>\n<p>그리고 evilCircle을 생성하고 loop 함수에 추가하자.</p>\n<pre><code class=\"language-js\">const evilCircle = new EvilCircle(50,50);\n\nfunction loop(){\n  ctx.fillStyle = 'rgba(0,0,0,0.25)';\n  ctx.fillRect(0,0,width,height);\n\n  evilCircle.draw();\n  evilCircle.update();\n  evilCircle.collisionDetect();\n\n  for(let i=0;i&#x3C;balls.length;i++){\n    if(balls[i].exists){\n      balls[i].draw();\n      balls[i].update();\n      balls[i].collisionDetect();\n    }\n  }\n  // loop를 재귀적으로 호출\n  requestAnimationFrame(loop);\n}\n\nloop();\n</code></pre>\n<h2>3.2. 공 개수 표시하기</h2>\n<p>이제 공의 개수를 화면에 표시해 보자. h1 요소 아래 p태그를 배치한다. 스타일링은 예제에 있는 걸 복사하자.</p>\n<pre><code class=\"language-html\">&#x3C;h1>공튀기기&#x3C;/h1>\n&#x3C;p>Ball count :&#x3C;/p>\n&#x3C;canvas>&#x3C;/canvas>\n</code></pre>\n<p>그리고 공의 개수를 loop 함수의 호출마다 세주어서 p 태그의 내용을 업데이트한다.</p>\n<pre><code class=\"language-js\">function loop(){\n  ctx.fillStyle = 'rgba(0,0,0,0.25)';\n  ctx.fillRect(0,0,width,height);\n\n  evilCircle.draw();\n  evilCircle.update();\n  evilCircle.collisionDetect();\n  // ball 개수 업데이트\n  let ballCount=0;\n\n  for(let i=0;i&#x3C;balls.length;i++){\n    if(balls[i].exists){\n      // 존재하는 공만 센다.\n      ballCount++;\n      balls[i].draw();\n      balls[i].update();\n      balls[i].collisionDetect();\n    }\n  }\n  para.textContent = `Ball count: ${ballCount}`;\n  // loop를 재귀적으로 호출\n  requestAnimationFrame(loop);\n}\n</code></pre>\n<p>이다음 브라우저에서 실행해 보면 유저가 w,a,s,d로 컨트롤할 수 있는 하얀색 원이 생기고, 공을 먹어치우면 공의 개수가 줄어드는 걸 볼 수 있다.</p>\n<h1>참고</h1>\n<p>객체 만들기 실습 <a href=\"https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_building_practice\">https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_building_practice</a></p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Adding_bouncing_balls_features\">https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Adding_bouncing_balls_features</a></p>",
    "excerpt": "시작\nMDN에서는 JS 객체의 실습을 해보라고 Canvas API를 이용한 예제를 제공한다. 공이 날아다니는 걸 구현해보는 예제인데 생각보다 재미있다.\n1. 기본 구조\n1.1. HTML\n다음과 같은 HTML을 만든다.\n<!DOCTYPE html>\n<html lang=\"en-us\">\n  <head>\n    <meta charset=\"utf-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">",
    "headingTree": [
      {
        "title": "시작",
        "url": "#시작",
        "items": []
      },
      {
        "title": "1. 기본 구조",
        "url": "#1-기본-구조",
        "items": [
          {
            "title": "1.1. HTML",
            "url": "#11-html",
            "items": []
          },
          {
            "title": "1.2. JS",
            "url": "#12-js",
            "items": []
          }
        ]
      },
      {
        "title": "2. 충돌 구현",
        "url": "#2-충돌-구현",
        "items": []
      },
      {
        "title": "3. 예제 발전시키기",
        "url": "#3-예제-발전시키기",
        "items": [
          {
            "title": "3.1. 사용자 조작 기능",
            "url": "#31-사용자-조작-기능",
            "items": []
          },
          {
            "title": "3.2. 공 개수 표시하기",
            "url": "#32-공-개수-표시하기",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 3,
      "wordCount": 674
    },
    "url": "/posts/javascript-making-ball-object",
    "thumbnail": {
      "local": "/thumbnails/javascript-making-ball-object-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-javascript-making-ball-object-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAeklEQVR4nD2MMQrEIBBF7XK1OYaV4C3mDN5AslssrNXUth7AymKSQDora2HAJTHsK//7/6sQgrUWEbXWAGCMGWOIiELE5QYAYozMPG6U9945l1Ji3nrvM71EzpmIaq3zQUQecZzntu/M3Fr71y/x/nzX9UVEpZQ5muIHar5wsbBeXKcAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "javascript-lodash-basic",
    "title": "JS 탐구생활 - JS의 역사와 lodash",
    "date": "2023-01-03T00:00:00Z",
    "description": "lodash도 시대를 풍미했었다",
    "tags": [
      "javascript"
    ],
    "html": "<h1>1. lodash</h1>\n<p>lodash는 2023년 1월 첫째 주, 현재 약 <a href=\"https://github.com/lodash/lodash/network/dependents\">2천만개</a>정도의 github레포지토리에서 쓰이고 있고 주당 <a href=\"https://www.npmjs.com/package/lodash\">2500만회</a> 정도의 다운로드가 일어나고 있는 굉장히 유명한 라이브러리이다.</p>\n<p>그래서 lodash의 튜토리얼을 살펴보았다. map, filter, flatten, remove, every, find, findIndex, forEach 등등 편리한 함수들이 많았다.</p>\n<p>하지만 JS를 시작한 지 얼마 되지 않은 나로서는 의문이 들었다. 이 함수들은 JS에서 이미 제공하는 함수들이 아닌가? 그렇다면 lodash는 왜 필요한가?</p>\n<p>물론 lodash에서 지원하는 함수들은 JS에서 지원하는 그것보다 더 나은 퍼포먼스를 보인다. 또 좀더 안전하고 광범위한 사용을 보장한다. 하지만 그것이 lodash가 이 정도로 유명해지게 된 이유는 아닌 것 같았다.</p>\n<h1>2. lodash의 역사</h1>\n<p><img src=\"/static/lodash-is-history-f97b5489.jpeg\" alt=\"lodash-is-history\"></p>\n<p>lodash는 underscore.js로부터 시작된다. underscore.js는 2009년 JS에 함수형 프로그래밍 유틸리티를 제공하기 위해 만들어졌다.</p>\n<p>그리고 2012년 John-David Dalton이라는 사람이 underscore.js를 포크하여 lodash를 만들었다. 더 많은 함수들을 제공했으며 더 빠르고 안전했다. 그리고 v3.0.0부터는 underscore.js와 근본적인 차이들이 생겼다. 물론 둘의 합병 시도가 없었던 건 아니나 메인테이너들의 반대로 실패했다고 한다.</p>\n<h2>2.1 당시 상황</h2>\n<p><img src=\"/static/js-good-part-724c651c.png\" alt=\"js-past\"></p>\n<p><a href=\"https://pitzcarraldo.medium.com/javascript%EB%8A%94-%EC%9E%98%EB%AA%BB%EC%9D%B4-%EC%97%86%EB%8B%A4-%EC%A0%95%EB%A7%90%EB%A1%9C-fb9b8e033b10\">이미지 출처</a></p>\n<p>지금에 비하면 JS는 암흑이나 다름없었다. 이땐 JS 클래스 문법도 없었고, fetch도 없었다. ES6의 수많은 편의기능도 없었고 브라우저들은 각자의 표준으로 경쟁했기에(특히 IE) 브라우저들의 호환성도 좋지 않았다. 이렇게 부실했던 JS를 그나마 낫게 만들어준 라이브러리들이 있었다. 부트스트랩과 제이쿼리, underscorejs, prototypejs와 같은 것들이다.</p>\n<p>ES6같은 건 그저 프론트 개발자들-이때는 프론트 개발자라는 말이 잘 쓰이지도 않았지만-의 바람 중 하나였고 ES5는 널리 쓰이지도 않았다. ES3이 대세이던 시절이다. 참고로 map, filter, forEach와 같은 함수들은 ES5에 도입되었다. findIndex, fill과 같은 함수들은 ES6에 도입되었다.</p>\n<p>클래스 문법, 불변성을 지키게 해주는 함수들과 같이 지금은 당연한 JS기능들은 아직 나오기 몇 년 전이거나 나왔다 해도 아직 널리 쓰이지 않고 있었다. 그런 상황에서 lodash는 일관적이고 깔끔한 인터페이스를 제공하며 등장했다. underscore와 같이 <code>_</code>를 이용해 쓰일 수 있었으므로 편리하기도 했다. lodash는 이렇게 유명세를 탄 것이다.</p>\n<h1>3. 현재</h1>\n<h2>3.1. lodash의 장점</h2>\n<p>lodash는 지금도 여러 장점들이 있다. 함수에 따라 다르지만 JS의 네이티브 메서드에 비해 더 나은 성능을 가지며 지금도 JS에 없어서 직접 구현해야 하는 여러 함수들을 제공한다. 예를 들어 배열을 특정 사이즈들로 쪼개 주는 chunk 함수가 있다.</p>\n<pre><code class=\"language-js\">_.chunk(['a', 'b', 'c', 'd'], 2);\n// => [['a', 'b'], ['c', 'd']]\n</code></pre>\n<p>이를 네이티브 코드로 작성하면 다음과 같이 짜야 한다. 이 코드의 출처는 <a href=\"https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_chunk\">여기</a></p>\n<pre><code class=\"language-js\">const chunk = (input, size) => {\n  return input.reduce((arr, item, idx) => {\n    return idx % size === 0\n      ? [...arr, [item]]\n      : [...arr.slice(0, -1), [...arr.slice(-1)[0], item]];\n  }, []);\n};\n\nchunk(['a', 'b', 'c', 'd'], 2);\n// => [['a', 'b'], ['c', 'd']]\n</code></pre>\n<p>또는 깊은 복사를 해주는 <code>_.cloneDeep</code> 함수도 있다. spread 연산이나 Object.assign 혹은 JSON.parse(JSON.stringify())(객체 내부에 함수가 있으면 작동 안 함)를 이용해 대체할 수 있긴 하지만 그 대체법들이 다 나사 하나씩 빠져 있다.</p>\n<p>좀더 광범위한 함수들을 제공해 준다는 것도 그렇다. JS의 forEach가 주어진 함수를 배열 요소 각각에 대해 실행한 후 리턴값 없이(undefined 반환) 그냥 끝나 버리는 것과 반대로 lodash의 forEach는 객체도 인수로 받을 수 있으며 인수로 받은 객체 혹은 배열에 특정 함수를 모두 적용한 후 그 결과 배열을 리턴한다.</p>\n<p>함수형 프로그래밍을 지원하는 lodash-fp나 es6로 작성되어 트리쉐이킹을 잘 해주는 lodash-es등 최근에도 여러 변형 버전들이 나오는 등 지원도 잘 되는 편이다. 2천만개나 되는 곳에서 쓰고 있으니 당연할지도 모르지만.</p>\n<h2>3.2. lodash, 써야 할까?</h2>\n<p>lodash는 여전히 편리한 기능을 많이 제공한다. 그러나 그 중 또 많은 기능은 이제 JS에서 직접적으로 지원하거나, 없다면 짧게 구현될 수도 있다. 그렇게 lodash 함수들을 대체하는 코드를 모아 놓은 <a href=\"https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore\">레포지토리</a>도 있다.</p>\n<p>따라서 여러 글들을 찾아본 결과 이제는 선택의 영역으로 넘어왔다는 게 주류 의견으로 보인다. 곧 lodash도 역사의 뒤안길로 사라질지도 모른다는 말도 많다. 제이쿼리나 프로토타입js를 이제 신규 프로젝트에서 쓰지 않듯이.</p>\n<p>하지만 분명 JS의 한 시대를 풍미했던 라이브러리이고 그 당시의 가치는 분명히 있었다. 지금 이 순간도 2천만개의 레포지토리에서 쓰인다는 게 그것을 증명해 준다. 그중엔 신규 프로젝트도 많다. 하지만 지금에 와서는 lodash를 쓰는 것이 더 나은지, lodash를 쓰지 않는 것이 더 나은지는 상황에 따라 다른 선택의 문제가 된 듯 하다.</p>\n<p>아무튼 프론트를 배우다 보면 가끔 눈에 밟혔던 lodash라는 이름은 JS의 어두운 시대를 밝혀주었던 등불 중 하나였다.</p>\n<h1>참고</h1>\n<p>lodash map이 Array.prototype.map이 널리 쓰이기 전부터 있었다는 댓글 <a href=\"https://stackoverflow.com/questions/42861080/what-is-the-reason-to-use-lodash-underscore-map-function\">https://stackoverflow.com/questions/42861080/what-is-the-reason-to-use-lodash-underscore-map-function</a></p>\n<p><a href=\"https://www.w3schools.com/jsref/jsref_map.asp\">map</a>, <a href=\"https://www.w3schools.com/jsref/jsref_filter.asp\">filter</a>, <a href=\"https://www.w3schools.com/jsref/jsref_foreach.asp\">forEach</a></p>\n<p>underscore.js 위키백과 문서 <a href=\"https://en.wikipedia.org/wiki/Underscore.js#History\">https://en.wikipedia.org/wiki/Underscore.js#History</a></p>\n<p>이제 lodash를 보내주자는 글 <a href=\"https://thejs.dev/jmitchell/its-time-to-let-go-of-lodash-nqc\">https://thejs.dev/jmitchell/its-time-to-let-go-of-lodash-nqc</a></p>\n<p>프로토타입js 소개 <a href=\"http://runean.com/introduce-prototype-js/\">http://runean.com/introduce-prototype-js/</a></p>\n<p>You Don't Need Lodash Underscore <a href=\"https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore\">https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore</a></p>\n<p>JS와 lodash 함수들의 성능 비교 <a href=\"https://ui.toast.com/weekly-pick/ko_20190515\">https://ui.toast.com/weekly-pick/ko_20190515</a></p>\n<p>lodash-es <a href=\"https://yrnana.dev/post/2021-11-28-lodash-lodash-es\">https://yrnana.dev/post/2021-11-28-lodash-lodash-es</a></p>",
    "excerpt": "1. lodash\nlodash는 2023년 1월 첫째 주, 현재 약 2천만개정도의 github레포지토리에서 쓰이고 있고 주당 2500만회 정도의 다운로드가 일어나고 있는 굉장히 유명한 라이브러리이다.\n그래서 lodash의 튜토리얼을 살펴보았다. map, filter, flatten, remove, every, find, findIndex, forEach 등등 편리한 함수들이 많았다.\n하지만 JS를 시작한 지 얼마 되지 않은 나로서는 의문이 들었다. 이 함수들은 ",
    "headingTree": [
      {
        "title": "1. lodash",
        "url": "#1-lodash",
        "items": []
      },
      {
        "title": "2. lodash의 역사",
        "url": "#2-lodash의-역사",
        "items": [
          {
            "title": "2.1 당시 상황",
            "url": "#21-당시-상황",
            "items": []
          }
        ]
      },
      {
        "title": "3. 현재",
        "url": "#3-현재",
        "items": [
          {
            "title": "3.1. lodash의 장점",
            "url": "#31-lodash의-장점",
            "items": []
          },
          {
            "title": "3.2. lodash, 써야 할까?",
            "url": "#32-lodash-써야-할까",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 214
    },
    "url": "/posts/javascript-lodash-basic",
    "thumbnail": {
      "local": "/static/lodash-is-history-f97b5489.jpeg",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-lodash-is-history-f97b5489-jpeg",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAICAIAAABVpBlvAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAg0lEQVR4nGOQswuNqp/DIO3KIOsBRQpR9X////crmcgg6cwgBxZiMA05dOlBTP1sBik3qCoGeePm+Vv14xsZpGFCMo5RHfO3MdgkMfBaMyh4glWJa8zeciK/ZxmXXxHUOMmg0i+//s3ZcpzBMQOqVyKs+vHTF6u2Hzp49qZTbj+DoC0AiP8u8BQQ75wAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "javascript-proxy",
    "title": "JS 탐구생활 - Proxy와 Reflect",
    "date": "2023-10-22T00:00:00Z",
    "description": "ES6에서 도입된 Proxy, Reflect에 대해 알아보자",
    "tags": [
      "javascript"
    ],
    "html": "<p>TS의 데코레이터를 공부하다가 어디선가 Proxy에 대해서 언급한 것을 보아서, 이전부터 한번 정리하려고 했던 해당 부분을 정리해보았다.</p>\n<h1>1. Proxy의 기본</h1>\n<h2>1.1. Proxy 선언</h2>\n<p>프록시는 객체를 감싸서 객체에 가해지는 작업을 가로채서 처리하거나 어떤 추가 작업을 하는 객체이다. 추가 작업 이후에는 원래 객체가 처리하도록 전달하기도 한다.</p>\n<p>프록시 객체는 다음과 같은 형태로 생성한다.</p>\n<pre><code class=\"language-js\">let proxy = new Proxy(target, handler);\n</code></pre>\n<p><code>target</code>은 프록시가 감쌀 객체로 JS의 모든 객체가 가능하다. <code>handler</code>는 프록시가 가로챌 작업과 가로챘을 때의 동작을 정의하는 객체로 반드시 필요하다. 객체의 동작을 가로채는 <code>handler</code>의 각 메서드는 <code>trap</code>이라고 부른다.</p>\n<p>이렇게 생성한 프록시 객체에 작업이 가해졌을 때 <code>handler</code>에 해당 작업에 대응하는 트랩이 있다면 트랩이 실행되고, 트랩이 없다면 프록시는 원래 객체에 작업을 전달한다.</p>\n<p>다음과 같은 경우 <code>handler</code>에 아무 트랩도 없으므로 <code>proxy</code>에 가해지는 모든 작업은 그대로 <code>target</code>에 전달된다. proxy는 일반 객체와 달리 프로퍼티가 없다.</p>\n<pre><code class=\"language-js\">let target = {};\nlet proxy = new Proxy(target, {});\n</code></pre>\n<h2>1.2. 트랩의 종류</h2>\n<p>트랩을 사용해 프록시가 가로챌 수 있는 작업은 다음과 같다. 이들은 원래 객체의 내부 메서드가 하는 작업인데 프록시의 트랩을 통해서 이런 내부 메서드 호출을 가로챌 수 있다.</p>\n<p>해당 표는 <a href=\"https://ko.javascript.info/proxy\">Proxy와 Reflect</a>글에서 가져왔다.</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>트랩 이름</th><th>대응하는 내부 메서드</th><th>호출 시점</th></tr></thead><tbody><tr><td>get</td><td>[[Get]]</td><td>프로퍼티를 읽을 때</td></tr><tr><td>set</td><td>[[Set]]</td><td>프로퍼티에 값을 쓸 때</td></tr><tr><td>has</td><td>[[HasProperty]]</td><td>in 연산자를 사용할 때</td></tr><tr><td>deleteProperty</td><td>[[Delete]]</td><td>delete 연산자를 사용할 때</td></tr><tr><td>apply</td><td>[[Call]]</td><td>함수 호출 시</td></tr><tr><td>construct</td><td>[[Construct]]</td><td>new 연산자 사용시</td></tr><tr><td>getPrototypeOf</td><td>[[GetPrototypeOf]]</td><td>Object.getPrototypeOf</td></tr><tr><td>setPrototypeOf</td><td>[[SetPrototypeOf]]</td><td>Object.setPrototypeOf</td></tr><tr><td>isExtensible</td><td>[[IsExtensible]]</td><td>Object.isExtensible</td></tr><tr><td>preventExtensions</td><td>[[PreventExtensions]]</td><td>Object.preventExtensions</td></tr><tr><td>defineProperty</td><td>[[DefineOwnProperty]]</td><td>Object.defineProperty, Object.defineProperties</td></tr><tr><td>getOwnPropertyDescriptor</td><td>[[GetOwnProperty]]</td><td>Object.getOwnPropertyDescriptor, for..in, Object.keys/values/entries</td></tr><tr><td>ownKeys</td><td>[[OwnPropertyKeys]]</td><td>Object.getOwnPropertyNames, Object.getOwnPropertySymbols, for..in, Object.keys/values/entries</td></tr></tbody></table>\n<h3>1.2.1. 트랩 사용 규칙</h3>\n<p>트랩을 사용할 때는 다음과 같은 규칙을 지켜야 한다.</p>\n<p>값을 쓰는 처리가 성공했다면 <code>[[Set]]</code>은 true를 반환하고 그렇지 않은 경우 false를 반환해야 한다.</p>\n<p>값을 지우는 처리가 성공했다면 <code>[[Delete]]</code>는 true를 반환하고 그렇지 않은 경우 false를 반환해야 한다.</p>\n<p>프록시 객체에 <code>[[GetPrototypeOf]]</code>가 적용되면 target 객체에 <code>[[GetPrototypeOf]]</code>를 적용한 것과 동일한 값이 반환되어야 한다. 둘의 프로토타입은 같은 것이 당연하기 때문이다.</p>\n<p>다른 규칙들은 <a href=\"https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots\">프록시의 내장 메서드들 명세의 각 NOTE들에서 찾을 수 있다.</a></p>\n<h1>2. 트랩 사용 예시</h1>\n<h2>2.1. get 트랩</h2>\n<p><code>get</code> 트랩은 프로퍼티를 읽을 때 실행된다. <code>get</code> 트랩은 <code>get(target, property, receiver)</code> 형태로 정의된다.</p>\n<p><code>target</code>은 동작을 전달할 객체, <code>property</code>는 프로퍼티 이름, <code>receiver</code>는 프록시 객체 또는 프록시 객체를 상속받은 객체로 getter가 호출되는 시점의 this이다. receiver는 일단 없어도 된다.</p>\n<p>객체에 해당 key를 갖는 프로퍼티가 없을 경우 메시지를 출력하고 주어진 key를 그대로 반환하도록 해보자.</p>\n<pre><code class=\"language-js\">let target={};\nlet proxy=new Proxy(target, {\n  get(target, property, receiver){\n    if(property in target){\n      return target[property];\n    }\n    else{\n      console.log(\"no such property in the given target!\");\n      return property;\n    }\n  }\n})\n\ntarget[1]=\"A\";\n// A\nconsole.log(proxy[1]);\n// no such ...\n// 2\nconsole.log(proxy[2]); \n</code></pre>\n<h2>2.2. set 트랩</h2>\n<p><code>set</code>트랩은 프로퍼티에 값을 쓰려고 할 때 호출된다. <code>set(target, property, value, receiver)</code> 형태로 정의된다.</p>\n<p>당연히 <code>target</code>은 동작을 전달할 객체, <code>property</code>는 프로퍼티 이름, <code>value</code>는 프로퍼티에 쓰려는 값, <code>receiver</code>는 get 트랩에서와 같다.</p>\n<p>배열에 숫자만 추가되도록 하려면 다음과 같이 한다.</p>\n<pre><code class=\"language-js\">let target=[];\n\nlet proxy=new Proxy(target, {\n  set(target, property, value){\n    if(typeof value===\"number\"){\n      console.log(value, \"is added to the array!\")\n      target[property]=value;\n      return true;\n    }\n    else{\n      console.log(\"only number can be added to the array!\");\n      return false;\n    }\n  }\n})\n</code></pre>\n<p><code>push</code>와 같은 메서드들도 내부적으로 <code>[[Set]]</code>을 사용하기 때문에 값 추가 메서드들에 대해서도 프록시가 잘 동작한다.</p>\n<p><code>set</code>트랩을 사용할 때는 지켜야 할 규칙이 있다. 값을 쓰는 처리가 성공했다면 <code>[[Set]]</code>은 true를 반환하고 그렇지 않은 경우 false를 반환해야 한다. falsy 값을 반환시 <code>TypeError</code>가 발생하기 때문이다.</p>\n<h2>2.3. has 트랩</h2>\n<p><code>has</code> 트랩은 <code>in</code> 연산자를 사용할 때 호출된다. <code>has(target, property)</code> 형태로 정의된다.</p>\n<p>property에 대한 특정 검증을 하도록 할 수 있다. 예를 들어서 다음과 같이 하면 <code>in</code> 연산자를 호출했을 때 range의 범위를 넘어가는지 검증할 수 있다.</p>\n<pre><code class=\"language-js\">let range={\n  start:1,\n  end:10\n};\n\nrange=new Proxy(range, {\n  has(target, property){\n    return target.start&#x3C;=property &#x26;&#x26; property&#x3C;=target.end;\n  }\n});\n\nconsole.log(5 in range); // true\n</code></pre>\n<p>이외에도 참고 자료 페이지들에서 여러 트랩의 사용을 볼 수 있다.</p>\n<h1>프록시의 한계점</h1>\n<p>프록시는 기존 객체의 동작을 가로채서 추가 작업을 할 수 있게 해준다. 하지만 프록시에도 한계점이 있다. 프록시는 객체의 내부 메서드를 가로채는 방식으로 동작하는데 몇몇 객체들은 다른 내부 메서드를 통해서 동작하기 때문이다.</p>\n<p><code>Map</code>객체는 <code>[[Set]]</code>과 <code>[[Get]]</code>을  <code>[[MapData]]</code>라는 특수 슬롯에 데이터를 저장한다. 따라서 프록시가</p>\n<h1>3. Reflect</h1>\n<h2>3.1. Reflect의 기본</h2>\n<p><code>Reflect</code>는 Proxy와 비슷하게 내부 메서드들을 직접 사용할 수 있는 방법을 제공한다. 하지만 새로운 객체를 만드는 것이 아니라 기존 객체의 내부 메서드를 사용할 수 있게 해준다. 생성자 함수나 클래스가 아니므로 인스턴스를 만들거나 <code>new</code>로 호출할 수는 없다.</p>\n<p><code>Reflect</code>가 가진 메서드들은 <code>Proxy</code>에서 제공하는 핸들러와 완전히 같다. 첫 번째 인수는 내부 메서드를 적용할 <code>target</code>이고 나머지 인수들은 <code>Proxy</code>의 각 핸들러와 같다.</p>\n<p>예를 들어 <code>Reflect.get</code>은 <code>[[Get]]</code>내부 메서드를 사용하도록 해준다.</p>\n<pre><code class=\"language-js\">const obj={\n  foo:1,\n  bar:2,\n}\n\nconsole.log(Reflect.get(obj, \"foo\")); // 1\n</code></pre>\n<p>물론 <code>Proxy</code>와 함께 사용할 수도 있다.</p>\n<pre><code class=\"language-js\">const obj={\n  foo:1,\n  bar:2,\n}\n\nconst proxy=new Proxy(obj, {\n  get(target, property){\n    console.log(\"get is called!\");\n    return Reflect.get(target, property);\n  }\n})\n</code></pre>\n<p><code>new</code>, <code>delete</code>같은 호출 연산자들도 각각 <code>Reflect.construct</code>, <code>Reflect.deleteProperty</code>를 통해 함수처럼 사용할 수 있다.</p>\n<p>그런데 이런 동작들은 굳이 <code>Reflect</code>를 사용하지 않아도 할 수 있다. 그냥 <code>obj.foo</code>를 하면 되지 않는가? 따라서 <code>Reflect</code>를 쓰는 것의 장점을 알아보자.</p>\n<h2>3.2. Reflect의 장점</h2>\n<p><code>name</code>속성을 다음과 같이 핸들링하는 객체가 있다고 하자. 그리고 프록시 객체를 통해서 해당 객체의 <code>name</code>속성을 가져온다.</p>\n<pre><code class=\"language-js\">let user={\n  _name:\"김성현\",\n  get name(){\n    return this._name;\n  }\n};\n\nlet userProxy=new Proxy(user, {\n  get(target, property, receiver){\n    return target[property];\n  }\n})\n\nconsole.log(userProxy.name); // 김성현\n</code></pre>\n<p>이렇게 한번 <code>userProxy</code>를 만들고 나면 <code>user</code>대신 <code>userProxy</code>를 쓰는 게 맞다. 하지만 이렇게 하고 나서 <code>userProxy</code>를 상속하는 객체가 생기면 어떻게 될까?</p>\n<pre><code class=\"language-js\">let userOnline={\n  __proto__:userProxy,\n  _name:\"마녀\",\n}\n\n// this의 작동 방식 상 `마녀`가 나오는 게 맞는 것 같은데 `김성현`이 나온다.\nconsole.log(userOnline.name);\n</code></pre>\n<p><code>userOnline</code>에는 <code>name</code>속성이 없으므로 프로토타입인 <code>userProxy</code>로 가서 처리하게 되는데 <code>userProxy</code>의 get 트랩은 <code>target[property]</code>를 반환하도록 되어 있으므로 <code>user</code>의 <code>name</code>속성을 반환하게 된다.</p>\n<p><code>Reflect</code>를 사용하면 이런 문제를 해결할 수 있다. <code>Reflect</code>를 사용하여 <code>userProxy</code>의 get 트랩을 다음과 같이 바꾼다.</p>\n<p>이제 <code>receiver</code>가 알맞은 <code>this</code>에 대한 레퍼런스를 보관하고 <code>Reflect.get</code>에 전달하므로 제대로 <code>userOnline</code>의 <code>name</code>속성을 반환하게 된다.</p>\n<pre><code class=\"language-js\">let user={\n  _name:\"김성현\",\n  get name(){\n    return this._name;\n  }\n};\n\nlet userProxy=new Proxy(user, {\n  get(target, property, receiver){\n    // return Reflect.get(...arguments)로 쓸 수도 있다\n    return Reflect.get(target, property, receiver);\n  }\n})\n\nlet userOnline={\n  __proto__:userProxy,\n  _name:\"마녀\",\n}\n// 마녀 출력\nconsole.log(userOnline.name);\n</code></pre>\n<h1>참고</h1>\n<p>모던 JS 튜토리얼, Proxy와 Reflect <a href=\"https://ko.javascript.info/proxy\">https://ko.javascript.info/proxy</a></p>\n<p>JavaScript Proxy. 근데 이제 Reflect를 곁들인\n<a href=\"https://ui.toast.com/posts/ko_20210413\">https://ui.toast.com/posts/ko_20210413</a></p>\n<p>자바스크립트의 프록시 <a href=\"https://yceffort.kr/2021/03/javascript-proxy\">https://yceffort.kr/2021/03/javascript-proxy</a></p>",
    "excerpt": "TS의 데코레이터를 공부하다가 어디선가 Proxy에 대해서 언급한 것을 보아서, 이전부터 한번 정리하려고 했던 해당 부분을 정리해보았다.\n1. Proxy의 기본\n1.1. Proxy 선언\n프록시는 객체를 감싸서 객체에 가해지는 작업을 가로채서 처리하거나 어떤 추가 작업을 하는 객체이다. 추가 작업 이후에는 원래 객체가 처리하도록 전달하기도 한다.\n프록시 객체는 다음과 같은 형태로 생성한다.\nlet proxy = new Proxy(target, handler);\n\n",
    "headingTree": [
      {
        "title": "1. Proxy의 기본",
        "url": "#1-proxy의-기본",
        "items": [
          {
            "title": "1.1. Proxy 선언",
            "url": "#11-proxy-선언",
            "items": []
          },
          {
            "title": "1.2. 트랩의 종류",
            "url": "#12-트랩의-종류",
            "items": [
              {
                "title": "1.2.1. 트랩 사용 규칙",
                "url": "#121-트랩-사용-규칙",
                "items": []
              }
            ]
          }
        ]
      },
      {
        "title": "2. 트랩 사용 예시",
        "url": "#2-트랩-사용-예시",
        "items": [
          {
            "title": "2.1. get 트랩",
            "url": "#21-get-트랩",
            "items": []
          },
          {
            "title": "2.2. set 트랩",
            "url": "#22-set-트랩",
            "items": []
          },
          {
            "title": "2.3. has 트랩",
            "url": "#23-has-트랩",
            "items": []
          }
        ]
      },
      {
        "title": "프록시의 한계점",
        "url": "#프록시의-한계점",
        "items": []
      },
      {
        "title": "3. Reflect",
        "url": "#3-reflect",
        "items": [
          {
            "title": "3.1. Reflect의 기본",
            "url": "#31-reflect의-기본",
            "items": []
          },
          {
            "title": "3.2. Reflect의 장점",
            "url": "#32-reflect의-장점",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 2,
      "wordCount": 424
    },
    "url": "/posts/javascript-proxy",
    "thumbnail": {
      "local": "/thumbnails/javascript-proxy-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-javascript-proxy-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAgklEQVR4nGNYv369g4NDSkqKmppaYWHh////f//+/f//f4ba2lpDMODh4ZGTk/P29j5y5AhIYtu2bVlZWSkpKTt37rx48eK2bdseP34Mkjhy5EhLS8vEiRPv3LkDNwckcefe/YePHj1+/Pjjx48QCagdcxYsnjV79ooVK65evYqsAwBYOGeMQB+KFgAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "javascript-semicolon-insertion",
    "title": "JS 탐구생활 - 세미콜론 자동 삽입",
    "date": "2022-12-16T01:00:00Z",
    "description": "JS는 코드에 세미콜론을 자동으로 넣어준다. 그 규칙을 알아보자.",
    "tags": [
      "javascript"
    ],
    "html": "<h1>1. 시작 - 세미콜론을 삽입하자</h1>\n<p>JS에서는 줄바꿈이 일어나는 부분에 대해 대부분의 경우 세미콜론을 자동으로 삽입해 준다. 하지만 그렇지 않은 경우가 몇 가지 있고 만약 세미콜론을 명시적으로 삽입하지 않았을 경우 원하지 않는 동작이 일어날 수 있다. 따라서 세미콜론을 명시적으로 삽입해 주는 것이 권장된다.</p>\n<p>하지만 규칙을 말하기 전에, 세미콜론 자동 삽입이 어떤 규칙에 따라 일어나며 어떻게 문제가 될 수 있는지 알아보자.</p>\n<p><a href=\"https://ko.javascript.info/structure\">이 글</a>에서는 먼저 다음과 같은 예시를 든다.</p>\n<pre><code class=\"language-js\">alert(3 + \n1\n+ 2);\n</code></pre>\n<p>직관적으로 3+1+2 가 하나의 표현식으로 해석되는 게 맞기 때문에 이렇게 동작한다는 것을 느낄 수 있다. 그러나 다음과 같은 경우는 어떨까? 이 역시 위 글에서 든 예시이다.</p>\n<pre><code class=\"language-js\">alert(\"에러가 발생합니다.\")\n\n[1, 2].forEach(alert)\n</code></pre>\n<p>새롭게 추가한 alert만 잘 실행되고 그 뒤에 에러가 발생한다. 이는 js가 대괄호 앞에는 세미콜론을 자동 삽입하지 않기 때문이다. 그래서 위 코드는 다음과 같이 해석된다.</p>\n<pre><code class=\"language-js\">alert(\"에러가 발생합니다.\")[1, 2].forEach(alert)\n</code></pre>\n<p>이렇게 변환해 보니 에러가 발생하는 게 당연한 코드가 되었다.</p>\n<p>그럼 대체 세미콜론 자동삽입이라는 게 어떤 규칙을 따르는 것이길래 이런 일이 일어나는지 알아보자.</p>\n<h1>2. 기본 규칙</h1>\n<p>몇몇 종류의 JS statement들은 세미콜론으로 끝나야 한다. 이들은 다음과 같다.</p>\n<ul>\n<li>빈 statement</li>\n<li>let, const, var statement</li>\n<li>import, export statement, 모듈 선언</li>\n<li>expression statement</li>\n<li>debugger</li>\n<li>continue, break, throw, return</li>\n</ul>\n<p>따라서 위의 종류들은 자동 세미콜론 삽입에 영향을 받게 된다. 이때 좀 낯선 것 2개가 있어서 간단히 설명하였다.</p>\n<h1>3. statement 설명</h1>\n<h2>3.1. 빈 statement</h2>\n<p>말 그대로 아무것도 하지 않는 statement이다. 이는 세미콜론으로 끝나야 한다.</p>\n<pre><code class=\"language-js\">;\n</code></pre>\n<p>예를 들어서 for문의 body에 쓸 수 있다. for문이 시행하는 반복 그 자체가 중요한 경우이다.</p>\n<pre><code class=\"language-js\">let arr=[1,2,3,4,5];\nfor(let i=0;i&#x3C;arr.length;arr[i]=0,i++);\n</code></pre>\n<p>위와 같이 한 경우 for문의 body는 빈 statement가 된다. 단 이를 일부러 사용할 경우 실수를 유발할 수 있으므로 주석을 꼭 달아주자.</p>\n<pre><code class=\"language-js\">if(something);\n  func(); //if문이 빈 statement로 해석되었으므로 func는 무조건 실행된다\n</code></pre>\n<h2>3.2. expression statement</h2>\n<p>단순히 어떤 표현으로 이루어지는 statement이다. 이 표현은 평가되고 그 결과는 버려진다. 간단하게는 다음과 같은 것을 들 수 있다.</p>\n<pre><code class=\"language-js\">1+2;\n</code></pre>\n<p>변수에 값을 할당하는 할당 연산자도 연산자기 때문에 할당문도 하나의 expression이다. 이런 식으로 side effect가 있는 expression이 사용된다.</p>\n<pre><code class=\"language-js\">a=3; //이는 3으로 평가되지만 결과는 버려진다\n</code></pre>\n<h1>4. 자동 세미콜론 삽입 규칙</h1>\n<p>ECMAscript에서 설명하는 세미콜론 자동 삽입의 규칙들은 다음과 같다.</p>\n<h2>4.1. 첫번째 규칙</h2>\n<p>코드가 왼쪽에서 오른쪽으로 파싱되는 중에 문법에 의해 허용되지 않는 토큰(이를 offending token이라 한다)이 나올 때가 있다. 이때 다음 조건 중 하나 이상이 만족되면 해당 토큰 앞에 세미콜론을 삽입한다.</p>\n<ul>\n<li>offending token이 이전 토큰과 line terminator(라인 피드, 캐리지 리턴, 줄 구분 기호, 단락 구분 기호, 캐리지리턴+라인피드)로 구분되어 있을 때</li>\n<li>offending token이 }일 때</li>\n<li>이전 토큰이 )이고 삽입된 세미콜론이 do-while문을 끝내는 세미콜론이 될 때</li>\n</ul>\n<p>예를 들어서 <code>{1 2} 3</code>에서 <code>}</code>이 파싱되면서 문법적으로 맞지 않으므로, offending token인 } 이전에 세미콜론을 삽입한다. 따라서 <code>{1 2;} 3</code>으로 해석된다.</p>\n<h2>4.2. 두번째 규칙</h2>\n<p>토큰들을 왼쪽에서 오른쪽으로 파싱하다가, 토큰들의 스트림이 끝났고 파서가 토큰 스트림을 하나의 완전한 프로그램으로 파싱할 수 없다면 입력 스트림의 끝에 세미콜론을 삽입한다.</p>\n<p>예를 들어서 다음과 같은 프로그램을 보자.</p>\n<pre><code class=\"language-js\">let a=1\n++a;\n</code></pre>\n<p>그러면 파서는 먼저 <code>let a=1</code> 뒤에 세미콜론을 삽입한다. <code>++</code>와 <code>1</code>사이에 줄바꿈 문자, 즉 line terminator가 있기 때문이다.</p>\n<p>그리고 <code>++a</code>를 파싱하면서 스트림이 끝나고 이는 완벽한 프로그램이 아니므로 자동으로 끝에 세미콜론을 삽입한다.</p>\n<p>즉 자동 세미콜론 삽입의 결과는 다음과 같다.</p>\n<pre><code class=\"language-js\">let a=1;\n++a;\n</code></pre>\n<h2>4.3. 세번째 규칙</h2>\n<p>특정한 statement 뒤에 line terminator가 나올 때 자동으로 그 뒤에 세미콜론이 삽입된다. 즉 다음과 같은 statement 뒤에 line terminator가 있을 때 자동으로 세미콜론이 삽입된다.</p>\n<ul>\n<li>continue</li>\n<li>break</li>\n<li>return</li>\n<li>yield, yield*</li>\n<li>module</li>\n<li>postfix expression(++, --)</li>\n</ul>\n<pre><code class=\"language-js\">return\na+b\n</code></pre>\n<p>따라서 위 코드는 다음과 같이 변환된다. return 뒤에 세미콜론이 자동 삽입된 것이다.</p>\n<pre><code class=\"language-js\">return;\na+b;\n</code></pre>\n<h2>4.4. 네번째 규칙</h2>\n<p>위 세 가지 규칙들에 우선하는 규칙이 또 있다. 만약 세미콜론이 삽입되었을 경우 empty statement로 파싱되게 되거나 for문의 헤더에 필요한 2개의 세미콜론 중 하나로 간주되게 된다면, 세미콜론은 절대 삽입되지 않는다.</p>\n<pre><code class=\"language-js\">for(let i=0\ni&#x3C;n;i++){\n  console.log(i);\n}\n</code></pre>\n<p>만약 <code>let i=0</code>뒤에 세미콜론이 삽입된다면 for문의 헤더에 있는 2개의 세미콜론 중 하나로 간주될 것이다. 이런 경우에는 세미콜론이 삽입되지 않는다. empty statement로 파싱되는 경우도 마찬가지이다.</p>\n<pre><code class=\"language-js\">while(true)\n</code></pre>\n<p>여기의 뒤에 세미콜론이 삽입된다면 empty statement로 파싱되게 된다. 이런 경우에도 세미콜론이 삽입되지 않는다.</p>\n<h1>5. 세미콜론을 넣어야 하는 이유</h1>\n<p>JS에서도 명시적으로 세미콜론을 넣어 주는 것이 일반적으로 권장되고 있다. 그 이유는 위에서 본 것과 같이 자동 세미콜론 삽입의 규칙이 복잡하기 때문이다. 예를 들어서 다음과 같은 코드를 보자.</p>\n<pre><code class=\"language-js\">a=b\nfunc();\n</code></pre>\n<p>위 코드를 파싱할 때는 다음과 같이 해석될 것이다.</p>\n<pre><code class=\"language-js\">a=b func();\n</code></pre>\n<p>이는 문법적으로 말이 되지 않는다. 문법에 맞지 않도록 만든 토큰은 func이고 이는 원래 코드를 보면 앞선 토큰과 line terminator로 구분되어 있다. 따라서 자동 세미콜론 삽입의 첫번째 규칙에 의해 <code>a=b; func()</code>로 해석된다.</p>\n<p>그러나 다음 코드는 어떤가?</p>\n<pre><code class=\"language-js\">a=b\n(func());\n</code></pre>\n<p>다음 코드를 파싱하면 <code>a=b(func())</code>가 되는데 이는 b가 만약 함수라면 문법적으로 말이 된다. 그리고 js에서는 함수 또한 객체이기 때문에 b가 변수든 함수든 객체로 취급되고, 따라서 컴파일 타임에 파서가 <code>a=b(func())</code>의 오류를 잡아낼 수 없다.</p>\n<p>세미콜론 자동 삽입은 파싱한 토큰이 제대로 작동할 수 없을 때만 일어난다. 하지만 이는 컴파일 타임에 알아낼 수 있는 부분만 해당된다. <code>문법적으로 말이 되기만 하면</code> 자동 세미콜론 삽입이 일어나지 않는다는 것이다.</p>\n<p>따라서 자동 세미콜론 삽입을 믿으면서 코드를 짠다면 일단 <code>(, [, +, -, /</code>의 앞에서는 절대 세미콜론을 생략하면 안 되며, <code>return, throw, break, continue, ++, --</code>의 앞에서도 절대 세미콜론을 생략하면 안 된다. for문 헤더의 세미콜론도 그렇다.</p>\n<p>세미콜론 넣어주는 게 어려운 일도 아닌데, 굳이 위같은 점을 고려하면서 자동 세미콜론 삽입을 믿고 코드를 짜는 것은 좋지 않다..</p>\n<p>자동 세미콜론 삽입은 결국 파서가 에러를 정정할 기회를 주는 것 뿐인데 이를 신뢰하면서 코드를 짜는 건 에러를 일부러 발생시키는 것과 다름없다.</p>\n<h1>참고</h1>\n<p><a href=\"https://en.wikibooks.org/wiki/JavaScript/Automatic_semicolon_insertion\">https://en.wikibooks.org/wiki/JavaScript/Automatic_semicolon_insertion</a></p>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Lexical_grammar\">https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Lexical_grammar</a></p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/Empty\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/Empty</a></p>\n<p><a href=\"https://tc39.es/ecma262/#sec-rules-of-automatic-semicolon-insertion\">https://tc39.es/ecma262/#sec-rules-of-automatic-semicolon-insertion</a></p>\n<p><a href=\"https://www.informit.com/articles/article.aspx?p=1997934&#x26;seqNum=6\">https://www.informit.com/articles/article.aspx?p=1997934&#x26;seqNum=6</a></p>",
    "excerpt": "1. 시작 - 세미콜론을 삽입하자\nJS에서는 줄바꿈이 일어나는 부분에 대해 대부분의 경우 세미콜론을 자동으로 삽입해 준다. 하지만 그렇지 않은 경우가 몇 가지 있고 만약 세미콜론을 명시적으로 삽입하지 않았을 경우 원하지 않는 동작이 일어날 수 있다. 따라서 세미콜론을 명시적으로 삽입해 주는 것이 권장된다.\n하지만 규칙을 말하기 전에, 세미콜론 자동 삽입이 어떤 규칙에 따라 일어나며 어떻게 문제가 될 수 있는지 알아보자.\n이 글에서는 먼저 다음과 같은 예시를 든다",
    "headingTree": [
      {
        "title": "1. 시작 - 세미콜론을 삽입하자",
        "url": "#1-시작---세미콜론을-삽입하자",
        "items": []
      },
      {
        "title": "2. 기본 규칙",
        "url": "#2-기본-규칙",
        "items": []
      },
      {
        "title": "3. statement 설명",
        "url": "#3-statement-설명",
        "items": [
          {
            "title": "3.1. 빈 statement",
            "url": "#31-빈-statement",
            "items": []
          },
          {
            "title": "3.2. expression statement",
            "url": "#32-expression-statement",
            "items": []
          }
        ]
      },
      {
        "title": "4. 자동 세미콜론 삽입 규칙",
        "url": "#4-자동-세미콜론-삽입-규칙",
        "items": [
          {
            "title": "4.1. 첫번째 규칙",
            "url": "#41-첫번째-규칙",
            "items": []
          },
          {
            "title": "4.2. 두번째 규칙",
            "url": "#42-두번째-규칙",
            "items": []
          },
          {
            "title": "4.3. 세번째 규칙",
            "url": "#43-세번째-규칙",
            "items": []
          },
          {
            "title": "4.4. 네번째 규칙",
            "url": "#44-네번째-규칙",
            "items": []
          }
        ]
      },
      {
        "title": "5. 세미콜론을 넣어야 하는 이유",
        "url": "#5-세미콜론을-넣어야-하는-이유",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 208
    },
    "url": "/posts/javascript-semicolon-insertion",
    "thumbnail": {
      "local": "/thumbnails/javascript-semicolon-insertion-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-javascript-semicolon-insertion-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAkklEQVR4nGNYv369lZVVXFycnJxcVlZWXFwcDw+PpKQkQ2FhIQ8Pj6Ghobe397Nnz27cuLFz587Vq1czbNu2rbi4ODw8vKura8WKFY8fP/4PBgynTp3s7e3duXPnjRs3jh8//uXLl99gwHDn3v379+8/e/bs48ePELVQHXMWLJ41e/aqlSsvXrz4////379/QyQAowBigBFHwGwAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "javascript-object-object",
    "title": "JS 탐구생활 - [object Object]가 나오는 이유",
    "date": "2023-02-09T05:00:00Z",
    "description": "객체의 문자열 변환시 [object Object]가 나오는 이유 탐구",
    "tags": [
      "javascript"
    ],
    "html": "<h1>1. 시작</h1>\n<p>JS를 하다 보면 <code>[object Object]</code>라는 결과물을 종종 보게 된다. 가령 다음과 같이 객체가 문자열로 변환되는 경우에 보인다.</p>\n<pre><code class=\"language-js\">let obj = { a: 1, b: 2 };\nalert(obj);\n</code></pre>\n<p>그런데 이렇게 toString을 사용했을 때 나오는 <code>[object Object]</code>는 그렇게 좋아 보이지 않는다. 객체가 왜 저런 문자열이 되어야 하는가? 오히려 <code>JSON.stringify</code>의 결과물이 훨씬 더 그럴듯하다.</p>\n<pre><code class=\"language-js\">let obj = {\n  a: 1,\n  b: 2,\n};\nconsole.log(JSON.stringify(obj));\n// {\"a\":1,\"b\":2}\n</code></pre>\n<p>그럼 왜 객체의 문자열 변환 결과물은 <code>[object Object]</code>가 나오는 걸까? 이는 <code>Object.prototype.toString</code>의 작동 방식 때문이다.</p>\n<h1>2. Object.prototype.toString 호출 이유</h1>\n<p>프로토타입을 따로 지정하지 않은 모든 객체는 Object.prototype을 프로토타입으로 가진다. 즉 위의 obj 객체의 <code>[[Prototype]]</code>은 Object.prototype이다. 이때 Object.prototype의 프로토타입은 없다.</p>\n<p>이 Object.prototype에는 toString과 같은 다양한 메소드가 구현되어 있다. 그래서 기본적으로 모든 객체는 문자열 변환 시 toString을 사용하게 되고 위의 obj도 마찬가지다. 그리고 그 메서드의 결과물은 <code>[object Object]</code>이다.</p>\n<h2>2.1. Object.prototype.toString은?</h2>\n<p>이 메서드는 인자로 넘겨준 객체의 클래스 이름을 반환하는 메서드이며 <code>alert</code>의 인자로 쓰이는 등 문자열 값이 기대되는 곳에 쓰일 때 호출된다.</p>\n<p>그리고 JS가 가진 불린, null, undefined, 숫자, 문자열, 심볼, BigInt, 객체의 모든 타입 중 null, undefined를 빼면 모두 Object의 인스턴스이다. 따라서 프로토타입 체이닝을 통해 Object.prototype의 메서드를 쓸 수 있다.</p>\n<h1>3. Object.prototype.toString의 작동방식</h1>\n<p>이 메서드는 인자로 들어온 값의 클래스 타입을 검사해서 알려준다. 그리고 <a href=\"https://262.ecma-international.org/6.0/#sec-object.prototype.tostring\">ECMAscript 명세서</a>에서는 toString 동작 방식을 다음과 같이 서술한다.</p>\n<p><img src=\"/static/ecma6_toString-0016ca71.png\" alt=\"ecma6\"></p>\n<p>조금 부족한 부분이 있을 수 있지만 해석해 보면 다음과 같다.</p>\n<ol>\n<li>this에 해당하는 값이 undefined이면 \"[object Undefined]\"을 반환한다.</li>\n<li>this에 해당하는 값이 null이면 \"[object Null]\"을 반환한다.</li>\n<li>this를 ToObject(this)로 변환한다. 이 함수의 동작은 <a href=\"https://witch.work/posts/dev/javascript-spread-object#4.2.1.-CopyDataProperties\">여기</a>에 정리해 놓았다.</li>\n<li>Toobject(this)가 배열인지 검사하고 배열이라면 builtinTag를 \"Array\"로 설정한다. 이때 ReturnIfAbrupt(isArray)를 호출하여 에러 검사를 한다. ReturnIfAbrupt에 대한 자세한 내용은 <a href=\"https://ui.toast.com/posts/ko_20221116_1\">여기</a>를 참고.</li>\n<li>그 외 타입들에 대해서도 타입에 맞게 builtinTag를 설정한다. 예를 들어, 문자열이라면 \"String\", 함수라면 \"Function\" 등이다.</li>\n<li>만약 객체에 well-known symbol인 Symbol.toStringTag라는 키가 있다면 이 키의 값을 tag로, 없다면 builtinTag를 tag로 설정한다.</li>\n<li>\"[object \" + tag + \"]\"을 반환한다.</li>\n</ol>\n<p>또한 내부 슬롯에 따른 객체의 다양한 구분을 볼 수 있는데, 위의 toString 4번 동작에서 생략된 부분을 보면 다음과 같다. 이런 복잡한 방식은 기존의 <code>[[Class]]</code> 내부 슬롯을 쓰던 방식과의 하위 호환성을 위한 것이다. 아래 별첨에서 더 자세히 설명한다.</p>\n<ul>\n<li>exotic String 객체면 String</li>\n<li><code>[[ParameterMap]]</code>내부 슬롯이 있으면 함수 인수를 담는 유사 배열 객체 Arguments</li>\n<li><code>[[Call]]</code> 내부 슬롯이 있으면 함수</li>\n<li><code>[[ErrorData]]</code> 내부 슬롯이 있으면 에러</li>\n<li><code>[[BooleanData]]</code> 내부 슬롯이 있으면 불린</li>\n<li><code>[[NumberData]]</code> 내부 슬롯이 있으면 숫자</li>\n<li><code>[[DateValue]]</code> 내부 슬롯이 있으면 Date 객체</li>\n<li><code>[[RegExpMatcher]]</code> 내부 슬롯이 있으면 정규식</li>\n<li>그게 아니라면 그냥 객체</li>\n</ul>\n<p>명세에 보면 이는 this를 조작하고 있으므로 call을 사용해서 위의 명세를 시험해 볼 수 있다.</p>\n<pre><code class=\"language-js\">function test(obj) {\n  console.log(Object.prototype.toString.call(obj));\n}\n\ntest(undefined); // [object Undefined]\ntest(null); // [object Null]\ntest([1, 2]); // [object Array]\ntest(\"test\"); // [object String]\n(function () {\n  // [object Arguments]\n  test(arguments);\n})();\ntest(function () {}); // [object Function]\ntest(new RangeError()); // [object Error]\ntest(true); // [object Boolean]\ntest(1); // [object Number]\ntest(new Date()); // [object Date]\ntest(/a-z/); // [object RegExp]\ntest({}); // [object Object]\n</code></pre>\n<h1>4. Object.prototype.toString 별첨 해석</h1>\n<p>그리고 위 명세에는 별첨도 붙어 있다. 이를 해석해 보자.</p>\n<pre><code>Historically, this function was occasionally used to access the String value of the [[Class]] internal slot that was used in previous editions of this specification as a nominal type tag for various built-in objects. The above definition of toString preserves compatibility for legacy code that uses toString as a test for those specific kinds of built-in objects. It does not provide a reliable type testing mechanism for other kinds of built-in or program defined objects. In addition, programs can use @@toStringTag in ways that will invalidate the reliability of such legacy type tests.\n</code></pre>\n<p><a href=\"https://262.ecma-international.org/5.1/#sec-8.6.2\">ECMA5</a>에는 모든 객체에 <code>[[Class]]</code> 내부 프로퍼티가 존재했었다. 그리고 이는 객체의 분류를 나타내는 문자열이었다. 객체가 문자열일 경우 <code>String</code>을 저장하는 식이었다.</p>\n<p>이런 문자열이 객체마다 내부적으로 있었기에 <a href=\"https://262.ecma-international.org/5.1/#sec-15.2.4.2\">ECMA5의 toString</a> 메서드는 이 문자열을 tag로 해서 \"[object \" + tag + \"]\"를 반환하는 단순한 방식이었다. 길이부터가 차이난다.</p>\n<p><img src=\"/static/ecma5_toString-8805718e.png\" alt=\"ecma5\"></p>\n<p>하지만 ECMA6부터는 <code>[[Class]]</code> 객체 내부 프로퍼티가 사라졌다. 그런데 특정 빌트인 객체들의 종류를 구분하는 데에 toString을 쓰는 레거시 코드들의 하위 호환성을 보장해 줘야 했으므로 위와 같은 복잡한 builtinTag 결정 방식이 생긴 것이다.</p>\n<p>하지만 이 방식은 레거시 코드를 위한 것이므로 다른 빌트인 객체나 사용자 정의 객체에 대한 신뢰성 있는 타입 검사를 제공해 주지 않는다. 또한, <code>@@toStringTag</code>를 사용하는 프로그램들은 이러한 레거시 타입 테스트의 신뢰성을 무효화할 수 있다.</p>\n<h1>5. toString 커스터마이징</h1>\n<p>위의 별첨에서 추측할 수 있다시피 <code>@@toStringTag</code>를 사용하면 toString을 커스터마이징할 수 있다.</p>\n<p>물론 이런 걸 쓰지 않고 그냥 <code>toString</code>을 오버라이딩할 수도 있다.</p>\n<pre><code class=\"language-js\">function Person(name) {\n  this.name = name;\n\n  this.toString = function () {\n    return this.name;\n  };\n}\n\nlet me = new Person(\"김성현\");\nconsole.log(me.toString());\n// 김성현\n</code></pre>\n<p>하지만 좀더 잘 해볼 수 없을까? 바로 위에 나와 있는 <code>@@toStringTag</code>를 사용하는 것이다. 이는 위의 명세에서 보면 toString이 \"[object \" + tag + \"]\"를 반환할 때 tag에 가장 기본적으로 지정하는 값이다. 객체의 가장 기본적인 설명 문자열이라는 것이다.</p>\n<pre><code class=\"language-js\">function Person(name) {\n  this.name = name;\n\n  this[Symbol.toStringTag] = name;\n}\n\nlet me = new Person(\"김성현\");\nconsole.log(me.toString());\n// [object 김성현]\n</code></pre>\n<p>대괄호와 object 문자열이 붙어서 좀 못생기긴 했지만 오버라이드에 성공했다! 다만 이를 타입 체크에 사용하기 위해서는 <code>[object tag]</code>형태에서 tag만 깔끔하게 파싱해야 하므로 추가적인 작업이 필요할 것 같다.</p>\n<p>이는 실용적으로 쓸 수 있을지는 아직 의문이지만, JS의 빌트인 객체들이 이를 사용한다.</p>\n<pre><code class=\"language-js\">function test(obj) {\n  console.log(Object.prototype.toString.call(obj));\n}\n\ntest(new Map()); // [object Map]\ntest(function* (a) {\n  // [object GeneratorFunction]\n  yield a;\n});\ntest(new Set()); // [object Set]\ntest(new WeakMap()); // [object WeakMap]\ntest(Promise.resolve()); // [object Promise]\n</code></pre>\n<p>또한 이제 브라우저들에서 DOM 프로토타입 객체들에 대해서도 <code>@@toStringTag</code>를 지원한다고 한다.</p>\n<pre><code class=\"language-js\">const button = document.createElement(\"div\");\nconsole.log(button.toString()); // [object HTMLDivElement]\nconsole.log(button[Symbol.toStringTag]); // HTMLDivElement\n</code></pre>\n<p>typeof 연산자는 <a href=\"https://262.ecma-international.org/6.0/#sec-typeof-operator\">명세</a>에 따르면 기본적으로 <code>undefined</code>, <code>boolean</code>, <code>string</code>, <code>number</code>, <code>symbol</code>, <code>bigint</code>, <code>function</code>, <code>object</code>를 반환한다. 하지만 toString은 기본적으로 훨씬 더 많은 종류의 객체를 감지하고, 커스터마이징도 가능하다. 따라서 많은 타입 체크가 필요하다면 toString을 사용하는 것도 생각해 볼 수 있을 것 같다.</p>\n<h1>6. 결론</h1>\n<p>결국 원래대로 돌아간다면, 일반적인 객체를 문자열로 변환할 때 <code>[object Object]</code>같은 못생긴 문자열이 반환되는 이유는 그것이 Object.prototype.toString의 동작이기 때문이다.</p>\n<p>(2023.10.13 추가 내용)</p>\n<h1>7. 암시적으로 <code>toString()</code>이 호출되는 경우</h1>\n<p>객체의 프로퍼티 키는 문자열과 심볼만 가능하다. 하지만 객체의 키로 숫자를 넣을 수도 있는 것을 우리는 알고 있다. 타입스크립트에서도 이를 허용한다. 어떻게 된 걸까?</p>\n<p>이는 문자열과 심볼 이외에 다른 속성의 값이 객체의 프로퍼티 키로 쓰이게 되면 자동으로 문자열로 변환되어서 사용되기 때문이다. 예를 들어 다음과 같은 코드를 보면 <code>{}</code>이 객체의 키로 쓰였을 때 자동으로 <code>toString()</code>이 호출되어 그 결과가 키로 들어가는 것을 볼 수 있다.</p>\n<pre><code class=\"language-ts\">const obj={};\nobj[{}]=1;\nobj; // { '[object Object]': 1 }\nobj['[object Object]']=2;\nobj[{}]; // 2\n</code></pre>\n<h1>참고</h1>\n<p><a href=\"https://medium.com/%EC%98%A4%EB%8A%98%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%97%90%EC%84%9C-object-object-%EA%B0%80-%EB%8C%80%EC%B2%B4-%EB%AD%98%EA%B9%8C-fe55b754e709\">https://medium.com/%EC%98%A4%EB%8A%98%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%97%90%EC%84%9C-object-object-%EA%B0%80-%EB%8C%80%EC%B2%B4-%EB%AD%98%EA%B9%8C-fe55b754e709</a></p>\n<p><a href=\"http://xahlee.info/js/js_Object.prototype.toString.html\">http://xahlee.info/js/js_Object.prototype.toString.html</a></p>\n<p><a href=\"https://stackoverflow.com/questions/35900557/is-there-away-to-change-the-internal-class-property-of-a-javascript-object\">https://stackoverflow.com/questions/35900557/is-there-away-to-change-the-internal-class-property-of-a-javascript-object</a></p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toStringTag\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toStringTag</a></p>\n<p><code>Object.create</code> <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/create\">https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/create</a></p>",
    "excerpt": "1. 시작\nJS를 하다 보면 [object Object]라는 결과물을 종종 보게 된다. 가령 다음과 같이 객체가 문자열로 변환되는 경우에 보인다.\nlet obj = { a: 1, b: 2 };\nalert(obj);\n\n그런데 이렇게 toString을 사용했을 때 나오는 [object Object]는 그렇게 좋아 보이지 않는다. 객체가 왜 저런 문자열이 되어야 하는가? 오히려 JSON.stringify의 결과물이 훨씬 더 그럴듯하다.\nlet obj = {\n  a: ",
    "headingTree": [
      {
        "title": "1. 시작",
        "url": "#1-시작",
        "items": []
      },
      {
        "title": "2. Object.prototype.toString 호출 이유",
        "url": "#2-objectprototypetostring-호출-이유",
        "items": [
          {
            "title": "2.1. Object.prototype.toString은?",
            "url": "#21-objectprototypetostring은",
            "items": []
          }
        ]
      },
      {
        "title": "3. Object.prototype.toString의 작동방식",
        "url": "#3-objectprototypetostring의-작동방식",
        "items": []
      },
      {
        "title": "4. Object.prototype.toString 별첨 해석",
        "url": "#4-objectprototypetostring-별첨-해석",
        "items": []
      },
      {
        "title": "5. toString 커스터마이징",
        "url": "#5-tostring-커스터마이징",
        "items": []
      },
      {
        "title": "6. 결론",
        "url": "#6-결론",
        "items": []
      },
      {
        "title": "7. 암시적으로 toString()이 호출되는 경우",
        "url": "#7-암시적으로-tostring이-호출되는-경우",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 2,
      "wordCount": 532
    },
    "url": "/posts/javascript-object-object",
    "thumbnail": {
      "local": "/static/ecma6_toString-0016ca71.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-ecma6_toString-0016ca71-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAnElEQVR4nGNYtmxZQkJCVFTkhAn9S5cuWbp0yYMH99+/f8fw/v270NBQFWW19PS0KVMnbdmy+cWLFyCJFy+e+/sHq6qqOzo6lhWXdXZ2rFq18sGD+wwPHtwPDg5SVlbi4xZUklXl4mJzd3cD6Xjw4L6NjYOkpJStje28OfOXLl0CNu05SCIzMyc0NLSmpqqtvfXAwQM3blx/8OA+ACW0Ts2uPelUAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "javascript-symbol-usage",
    "title": "JS 탐구생활 - 심볼은 대체 어디에 쓰일까?",
    "date": "2023-08-30T00:00:00Z",
    "description": "JS의 심볼, 어디에 쓰이는 걸까?",
    "tags": [
      "javascript"
    ],
    "html": "<h1>시작</h1>\n<p>JS를 처음 배울 때는 보통 JS에서 다루는 기본적인 값인 원시값이라는 것들이 무엇인지를 배운다. 어디선가 다음과 비슷한 설명을 보면서 말이다.</p>\n<blockquote>\n<p>JavaScript에서 원시 값(primitive, 또는 원시 자료형)이란 객체가 아니면서 메서드도 가지지 않는 데이터입니다. 원시 값에는 7종류, string, number, bigint, boolean, undefined, symbol, 그리고 null이 존재합니다.</p>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Glossary/Primitive\">MDN Web Docs - 원시 값</a></p>\n</blockquote>\n<p>그리고 이 7종류의 원시 값들 중 대부분은 개발하다 보면 꽤나 보게 되고 목적도 명확하다. 가령 JS를 써서 개발하는 사람이라면 string 값이 어디에 쓰이는지 의심할 사람은 없다고 생각한다. bigint같은 경우 자주 보이지는 않지만 이름만 보아도 그 목적과 쓰임새를 알 수 있다.</p>\n<p>이중 상대적으로 매우 낯설게 느껴지는 값이 있다. 바로 심볼이다. 다른 원시값들이 JS에서 얼마나 중요하게 그리고 많이 쓰이고 있는지를 생각하면 왜 이 심볼이 원시값의 한 자리를 차지하고 있는지조차 의심스럽기도 하다.</p>\n<p>그래서 심볼이 무엇이고 어디에 쓰이는지 알아보았다. 심볼은 어플리케이션 레벨에서는 잘 쓰이지 않아도 그 특유의 고유값을 만드는 로직으로 JS의 내부 구현에서 매우 중요하게 쓰이고 있었다.</p>\n<h1>1. 심볼 소개</h1>\n<p>먼저 심볼이 무엇이고 어떤 방식으로 사용할 수 있는지 간략하게 알아보자.</p>\n<h2>1.1. 심볼이란?</h2>\n<p>심볼은 원시형 중에 하나로 ES2015에 도입되었다. <code>Symbol()</code> 생성자 함수를 사용해서 심볼을 생성할 수 있고 이는 고유하고 프로그램 전체에서 유일한 값임이 보장된다. 혼동을 막기 위해 <code>Symbol</code> 생성자 함수에 new를 쓰는 것은 지원하지 않는다.</p>\n<pre><code class=\"language-js\">// 심볼 생성하기\nlet id1 = Symbol();\nlet id2 = Symbol();\n// 심볼 각각은 유일하기에 다음 수식은 false로 평가된다\nconsole.log(id1 == id2);\n\n// 이렇게 new를 쓰면 TypeError 발생\nlet newSymbol = new Symbol();\n</code></pre>\n<h2>1.2. 심볼의 설명 인자</h2>\n<p>앞에서 보았듯이 <code>Symbol()</code> 생성자 함수를 이용해서 심볼을 생성할 수 있다.</p>\n<p>심볼을 만들 때 생성자 <code>Symbol()</code>의 인수에 문자열을 전달함으로써 설명을 붙일 수 있다. 이는 디버깅 시 유용하게 쓰일 수 있다.</p>\n<pre><code class=\"language-js\">let id1 = Symbol(\"id\");\nconsole.log(id1);\n</code></pre>\n<p>또한 이 설명은 심볼을 <code>toString()</code>메서드로 문자열 변환했을 때 표시된다. 참고로 심볼은 문자열으로 자동 형변환될 수 없다. 가령 alert의 인수로 심볼을 넘기면 다음과 같은 에러가 발생한다.</p>\n<pre><code>Uncaught TypeError: Cannot convert a Symbol value to a string\n</code></pre>\n<p>그래서 앞서 말한 <code>toString()</code>메서드를 사용해서 심볼을 문자열 형태로 출력해 줄 수 있다.</p>\n<pre><code class=\"language-js\">let id1 = Symbol(\"id\");\nalert(id1.toString()); //Symbol(id)\n</code></pre>\n<p>아니 사실 앞서 <code>Symbol()</code>에 전달한 인수는 디버깅 외에는 딱히 쓸 수 있는 곳이 없다. 물론 <code>description</code> 프로퍼티를 사용하면 심볼을 생성할 때 전달했던 설명을 가져올 수 있다. 하지만 이런 설명을 활용해서 심볼의 비교를 한다거나 하는 경우 굳이 고유값인 심볼을 사용할 이유가 없으므로 이 설명은 정말 쓸 필요가 없다.</p>\n<pre><code class=\"language-js\">let id1 = Symbol(\"id\");\nalert(id1.toString()); //Symbol(id)\nalert(id1.description); //id\n</code></pre>\n<p>설명이 동일한 심볼을 여러 개 만들어도 심볼 각각은 유일하기에 생성자 함수에 인수로 전달한 설명은 그저 우리가 식별할 수 있는 이름표 역할을 할 뿐이다.</p>\n<h2>1.3. 전역 심볼 레지스트리</h2>\n<p>앞서 말했듯이 심볼은 생성자 인수로 전달한 문자열 같은 것에 관계없이 <code>Symbol()</code> 생성자로 생성되었다면 모두가 고유하고 유일한 값임이 보장된다.</p>\n<p>하지만 이는 여러 스크립트에서 공통으로 쓸 수 없고 또한 처음 심볼을 생성한 곳 외에 다른 곳에서 접근하기 쉽지 않다는 단점이 있다. 어떤 객체 내부에서 심볼 키를 생성했다면 그 키를 어떻게 가져올 것인가?</p>\n<pre><code class=\"language-js\">// 다음과 같은 객체의 키에 어떻게 접근할 것인가?\n{\n  [Symbol()]: {\n    msg:\"안녕하세요\"\n  }\n}\n</code></pre>\n<p>하지만 전역 심볼 레지스트리를 사용하면 이름이 같은 심볼이 같은 개체를 가리키도록 할 수 있다.</p>\n<h3>1.3.1 Symbol.for(key)</h3>\n<p><code>Symbol.for(key)</code>는 인수로 주어진 <code>key</code>를 사용해서 런타임 범위의 심볼 레지스트리에서 해당 키를 가진 심볼을 찾고 존재할 경우 이를 반환한다. 만약 그런 심볼이 없을 경우에는 해당 키를 사용해 전역 심볼 레지스트리에 새로운 심볼을 만든 후 리턴한다.</p>\n<p>즉 이름이 같은 <code>key</code>를 사용해서 이 함수를 호출할 경우 같은 런타임 범위에서는 항상 같은 심볼을 반환해 준다.</p>\n<pre><code class=\"language-js\">// 전역 심볼 레지스트리에 id 심볼 등록됨\nlet id = Symbol.for(\"id\");\n// 이미 등록된 심볼을 반환함\nlet id2 = Symbol.for(\"id\");\n// true\nalert(id === id2);\n</code></pre>\n<h3>1.3.2 Symbol.keyFor(sym)</h3>\n<p><code>Symbol.for(key)</code>를 사용해 만든 심볼은 <code>Symbol.keyFor(sym)</code>를 사용해 해당 심볼을 생성할 때 사용했던 <code>key</code>를 얻을 수 있다.</p>\n<pre><code class=\"language-js\">let id = Symbol.for(\"id\");\nlet witch = Symbol.for(\"witch\");\n// id\nconsole.log(Symbol.keyFor(id));\n// witch\nconsole.log(Symbol.keyFor(witch));\n</code></pre>\n<p>이 함수는 전역 심볼 레지스트리를 뒤져 인수로 받은 심볼의 이름을 얻어낸다. 전역 심볼 레지스트리에 등록되지 않은 심볼이라면 <code>undefined</code>를 반환한다. 이후에 살펴보겠지만 well-known symbol들은 전역 심볼 레지스트리에 등록되어 있는 심볼이 아니다.</p>\n<pre><code class=\"language-js\">console.log(Symbol.keyFor(Symbol.iterator)); // undefined\n</code></pre>\n<p>만약 전역 심볼이 아닌 심볼의 생성시 이름으로 전달한 문자열 인수를 얻고 싶다면 앞서 언급한 <code>description</code> 프로퍼티를 사용하면 된다.</p>\n<pre><code class=\"language-js\">let id = Symbol(\"test\");\nconsole.log(id.description); // test\n</code></pre>\n<h1>2. 심볼형이 만들어진 목적</h1>\n<p>그럼 이런 심볼은 왜 만들어진 걸까? <a href=\"https://exploringjs.com/es6/ch_symbols.html#_can-i-use-symbols-to-define-private-properties\">원래 목적은 private property를 만드는 것이었다.</a> 클래스 대신 객체를 프로토타입으로 사용하는 JS의 특성상 아마 객체 내부에서만 접근할 수 있는 어떤 프로퍼티를 만드는 게 목적이었을 것이다.</p>\n<p><a href=\"https://starkying.tistory.com/entry/Javascript-Closure-%EA%B7%B8%EB%A6%AC%EA%B3%A0-IIFE%EC%9D%98-%ED%99%9C%EC%9A%A9\">즉시 실행 함수(IIFE)를 이용하면 클로저를 활용한 private 속성을 만들기도 가능하지만</a> 아마 이를 객체 속성에도 적용하고 싶었던 모양이다.</p>\n<p>그러나 <code>Reflect.ownKeys</code>등 객체 내부의 심볼 키를 알 수 있는 방법들이 생김에 따라서 심볼은 원래 목적과는 멀어졌다.</p>\n<p>그래도 키값의 중복이 원천적으로 일어날 수 없는 고유값이라는 이 심볼형의 특성은 여전히 유용해서, 이름 충돌을 걱정하지 않고 어떤 객체 특성을 만들 때 쓰인다.</p>\n<p>Python의 <code>__</code>을 붙이는 private 속성명 컨벤션과 비슷하다고 할 수도 있겠다. 하지만 Python의 그러한 컨벤션으로 선언한 속성은 <code>_클래스명__변수명</code>으로 접근할 수 있다. 그런 점에서 이름이 아니라 완전한 고유값을 만들어 주는 심볼이 좀더 세련된 방식이다.</p>\n<p>그럼 이 심볼을 어디에 쓸 수 있을지, 얼마 없는 어플리케이션 레벨의 사용처를 알아보도록 하자.</p>\n<h1>3. 상수 정의에 사용</h1>\n<p>enum과 같이 값에는 의미가 없고 상수 이름에 의미가 있는 경우가 있다. JS에서 enum과 같은 사용을 하려는 경우 <code>Object.freeze</code>로 동결한 객체를 사용한다.</p>\n<p>예를 들어 다음과 같이 상수를 정의해서 쓰는 것을 생각해볼 수 있다.</p>\n<pre><code class=\"language-js\">const Direction=Object.freeze({\n  UP:'up',\n  DOWN:'down',\n  LEFT:'left',\n  RIGHT:'right',\n})\n</code></pre>\n<p>이러면 <code>Direction.UP</code>은 사실 문자열 <code>'up'</code>과 같기 때문에 상수의 실제 값이 중복될 가능성이 있다. 예를 들어 <code>Direction.DOWN===COMMAND.DOWN</code>이 같아지는 상황이 생길 수 있는 것이다.</p>\n<p>그러면 방향을 지시했는데 어떤 중요한 명령을 내려버리는 경우가 생길 수 있다. 이럴 때 값의 중복을 막기 위해 심볼을 사용하면 더 견고한 코드를 작성할 수 있다.</p>\n<p>이러면 각 상수의 실제 값이 고유한 값을 갖게 되고 심볼의 생성 시 인수로 넣어준 문자열을 이용해 각 심볼에 대한 디버깅을 수행할 수도 있다.</p>\n<pre><code class=\"language-js\">const Direction = Object.freeze({\n\tUP: Symbol('up'),\n\tDOWN: Symbol('down'),\n\tLEFT: Symbol('left'),\n\tRIGHT: Symbol('right'),\n})\n</code></pre>\n<p>이런 경우가 흔치는 않지만 이 방식을 <a href=\"https://github.com/facebook/react/blob/ba9582da27481677cdac2dd000a438147a5df88e/packages/react-devtools-shared/src/hydration.js#L21\">React 프로젝트 코드</a>에서도 사용하고 있다.</p>\n<pre><code class=\"language-js\">export const meta = {\n  inspectable: Symbol('inspectable'),\n  inspected: Symbol('inspected'),\n  name: Symbol('name'),\n  preview_long: Symbol('preview_long'),\n  preview_short: Symbol('preview_short'),\n  readonly: Symbol('readonly'),\n  size: Symbol('size'),\n  type: Symbol('type'),\n  unserializable: Symbol('unserializable'),\n};\n</code></pre>\n<h1>4. 심볼형으로 숨김 프로퍼티 만들기</h1>\n<p>심볼은 문자열과 함께 객체의 프로퍼티 키로 사용할 수 있다. 심볼 키는 <code>for..in</code>이나 <code>Object.getOwnProperties()</code>, <code>Object.keys()</code>와 같은 일반적인 객체 속성 조회 방법에서는 무시된다.</p>\n<pre><code class=\"language-js\">const mySymbol = Symbol('mySymbol');\n\nconst obj={\n  nickname: 'witch',\n  age: 18,\n  [mySymbol]: 'hello'\n}\n\n/* nickname witch\nage 18 */\nfor(let key in obj){\n  console.log(key, obj[key]);\n}\n\nconsole.log(Object.keys(obj)); // [ 'nickname', 'age' ]\n</code></pre>\n<p>심볼의 이런 특성을 사용하면 객체 내부에 일반적으로는 조회할 수 없는 프로퍼티를 만들 수 있다. 이를 이용해서 객체에 숨김 프로퍼티를 만들 수 있다.</p>\n<h2>4.1. 객체의 숨겨진 속성 만들기</h2>\n<p>이런 숨김 프로퍼티는 먼저 객체의 메타 데이터를 기록하는 데에 쓰일 수 있다. 외부 코드에서 쉽게 접근할 수도, 값을 덮어쓸수도 없는 프로퍼티를 만드는 것이다.</p>\n<pre><code class=\"language-js\">const userInternalKey = Symbol('userInternalKey');\nlet user={\n  nickname:'witch',\n  [userInternalKey]:32951235,\n}\n</code></pre>\n<p>이를 클래스나 생성자 함수 단위에서 이용할 수도 있다. 이러면 이 생성자나 클래스의 모든 인스턴스에 숨김 프로퍼티가 추가된다.</p>\n<pre><code class=\"language-js\">const mySymbol = Symbol('mySymbol');\n\nclass MyClass{\n  constructor(){\n    this[mySymbol] = 'foo';\n    this.prop = 'bar';\n  }\n  getMyValue(){\n    return this[mySymbol];\n  }\n}\n\nconst myClass = new MyClass();\nconsole.log(myClass.getMyValue()); // foo\nconsole.log(Object.getOwnPropertyNames(myClass)); // [ 'prop' ]\n</code></pre>\n<h2>4.2. 외부 객체에 속성 추가하기</h2>\n<p>이를 실질적으로 활용할 수 있는 방법이 있을까? 객체에서 쉽게 조회할 수 없고 이름 충돌도 걱정할 필요 없는 어떤 프로퍼티를 만들어야 하는 상황이 무엇일까?</p>\n<p>여러가지 있을 수 있겠지만 대표적으로는 외부 라이브러리 코드에서 가져온 객체에 나만의 속성을 추가해야 할 때를 들 수 있다.</p>\n<p>외부 라이브러리에서 가져온 <code>user</code>객체가 있다고 해보자. 이 객체는 다음과 같이 구성되어 있다.</p>\n<pre><code class=\"language-js\">const user={\n  name:\"witch\",\n  nickname:\"witch\",\n  position:\"developer\",\n  age:25\n}\n</code></pre>\n<p>여기에 내가 추가적으로 <code>isWorking</code>속성을 붙여 주고 싶다고 하자. 물론 이렇게 바로 추가해 줄 수도 있다.</p>\n<pre><code class=\"language-js\">user.isWorking = true;\n</code></pre>\n<p>하지만 이렇게 할 경우 몇 가지 문제가 발생할 수 있다.</p>\n<p>가장 대표적인 문제로는 외부 라이브러리의 코드에서 해당 객체를 <code>for..in</code>이나 <code>Object.keys()</code>와 같이 객체 속성들을 전부 조회하는 함수에 사용하고 있을 시 내가 추가한 속성 때문에 어떤 문제가 발생할 수 있다. 이 부분에 관해서는 이후 섹션에서 더 이야기할 것이다.</p>\n<p>그리고 라이브러리 제작자가 추후에 <code>user</code>객체에 <code>isWorking</code>속성을 추가하는 바람에 내 속성이 라이브러리에서 추가한 속성과 충돌을 일으킬 수 있다. 심지어는 표준 위원회가 모든 객체에 <code>isWorking</code>속성을 추가하도록 결정할 수도 있다.</p>\n<p>이런 문제들은 심볼을 외부 객체의 key로 쓰면 해결할 수 있다. 앞서 말했듯이 심볼은 프로그램 전체에서 유일한 값으로 보장된 값이며 <code>for..in</code>과 같은 객체 속성 조회 코드에서도 무시되기 때문이다. 또한 당연히 <code>Symbol(\"isWorking\")</code>과 <code>\"isWorking\"</code>은 다르기 때문에 이름 충돌도 걱정할 것 없다.</p>\n<pre><code class=\"language-js\">const user={\n  name:\"witch\",\n  nickname:\"witch\",\n  position:\"developer\",\n  age:25\n}\n\nconst isWorking = Symbol(\"isWorking\");\nuser[isWorking] = true;\n</code></pre>\n<p>외부 스크립트는 심볼 키를 가진 프로퍼티에 쉽게 접근하지 못한다는 점을 이용한 것이다.(이게 private를 의미하는 건 아니다. <code>sym in obj</code>처럼 내부 검사 로직에서는 심볼 키에 접근할 수 있기도 하고 위에서 본 것처럼 <code>Object.getOwnPropertySymbols()</code>나 <code>Reflect.ownKeys()</code>같은 메서드도 있다. 또한 <code>Object.assign</code>은 심볼 키를 무시하지 않고 객체 내 모든 프로퍼티를 복사한다)</p>\n<p>이를 좀더 발전시켜서 아예 어떤 객체에 심볼 속성을 붙여 주는 함수를 짤 수도 있다. 다음 코드의 <code>addPropertyBySymbol</code>함수는 객체에 고유한 심볼 키를 가진 프로퍼티를 추가해 준다.</p>\n<pre><code class=\"language-js\">const user={\n  name:\"witch\",\n  nickname:\"witch\",\n  position:\"developer\",\n  age:25\n}\n\nconst isWorking = Symbol(\"isWorking\");\n\nfunction addPropertyBySymbol(obj) {\n  obj[isWorking] = true;\n}\n\naddPropertyBySymbol(user);\n// user 객체가 id 심볼을 가지고 있는지에 따라 판단\nif (user[isWorking]) {\n  console.log(\"id exists\");\n}\n</code></pre>\n<p>아예 생성자 단위에서 클래스 인스턴스 생성 시 자동으로 숨김 프로퍼티를 추가해 주도록 할 수도 있다. 다음 코드의 경우 생성자 함수의 <code>prototype</code>속성을 이용했지만 클래스 문법을 사용한다면 클래스의 <code>constructor</code>메서드를 이용해서도 같은 효과를 낼 수 있다.</p>\n<pre><code class=\"language-js\">function Person(age){\n  this.age = age;\n}\n\nPerson.prototype[isWorking] = function(){\n  return this.age > 18;\n};\n\nconst person = new Person(25);\nconsole.log(person[isWorking]()); // true\n</code></pre>\n<p>이렇게 숨김 프로퍼티를 추가해 놓으면 특정 객체나 인스턴스에 대한 어떤 판단을 내리거나 객체를 식별하는 데에 해당 프로퍼티를 사용할 수 있다. 그리고 기존의 코드나 외부 라이브러리의 코드, 혹은 미래에 추가될 어떤 코드와도 충돌을 걱정할 필요 없이 내가 만든 프로퍼티를 사용할 수 있다.</p>\n<h2>4.3. 다른 방법과의 비교</h2>\n<p>이런 숨김 프로퍼티는 앞서 보았듯 다른 코드에서 관여할 수 없는 프로퍼티를 만들거나 마치 팝업창이나 알림창과 같이 각각을 식별할 수 있는 값을 만들어 줘야 할 때 사용할 수 있다. 앞에서 <code>user</code>객체에 새로운 프로퍼티를 만들어 준 것과 같다. (이번에는 대괄호를 이용해서 객체 리터럴에 바로 심볼 키를 넣어 주었다.)</p>\n<pre><code class=\"language-js\">let id1 = Symbol(\"id\");\nlet id2 = Symbol(\"id\");\n\nlet cafe1 = {\n  name: \"스타벅스\",\n  [id1]: 1,\n};\n\nlet cafe2 = {\n  name: \"이디야\",\n  [id2]: 2,\n};\n</code></pre>\n<p>하지만 꼭 이렇게 해야 할까? 이미 uuid와 같은 라이브러리들이 이미 잘 나와 있다. 따라서 이는 uuid 라이브러리를 이용하면 다음과 같이도 쓸 수 있을 것이다.</p>\n<pre><code class=\"language-js\">const { v4: uuidv4 } = require(\"uuid\");\n\nconst id = uuidv4();\n\nfunction addPropertyByRandom(obj) {\n  obj[id] = 1;\n}\n\nlet user = {\n  name: \"김성현\",\n};\n\naddPropertyByRandom(user);\n\nif (user[id]) {\n  console.log(\"id exists\");\n}\n</code></pre>\n<p>물론 이는 거의 똑같이 동작한다. uuid 라이브러리는 그렇게 무거운 라이브러리도 아니라서 번들 사이즈를 그렇게 많이 늘리지도 않을 것이다. 혹은 최신 브라우저에서는 <code>crypto.randomUUID()</code>를 사용해서 아예 라이브러리를 사용하지 않는 방법도 있다.</p>\n<p>물론 여기서는 라이브러리를 쓰는지 여부가 중요한 문제는 아니므로 그냥 유명한 라이브러리인 uuid을 사용하여서 코드를 작성할 것이다.</p>\n<p>아무튼 이런 랜덤 문자열 생성 방식의 문제는 이렇게 랜덤 문자열 키를 사용할 경우 외부에서 접근하기가 너무 쉽다는 것이다. 심볼도 완전한 private는 아니지만 그래도 <code>for..in</code>을 통한 접근이나 <code>JSON.stringify</code>, <code>Object.keys()</code>같은 웬만한 객체 속성 접근방식으로부터는 안전하다.</p>\n<p>예를 들어 다음 코드를 보자. 심볼을 통해 정의한 속성은 일반적인 방식의 접근 대상에서 빠지지만 랜덤 문자열을 이용하면 속성이 노출되는 것을 볼 수 있다.</p>\n<pre><code class=\"language-js\">const { v4: uuidv4 } = require(\"uuid\");\n\nconst id = uuidv4();\nconst symbolId = Symbol(\"id\");\n\nfunction addPropertyByRandom(obj) {\n  obj[id] = 1;\n}\n\nfunction addPropertyBySymbol(obj) {\n  obj[symbolId] = 1;\n}\n\nlet user1 = {\n  name: \"김성현\",\n};\n\nlet user2 = {\n  name: \"마녀\",\n};\n\naddPropertyByRandom(user1);\naddPropertyBySymbol(user2);\n\n// {\"name\":\"김성현\",\"8f2aeb41-eb10-43f0-944d-fd994926b63e\":1}\n// 랜덤 문자열은 매번 달라진다\nconsole.log(JSON.stringify(user1));\n// {\"name\":\"마녀\"}\nconsole.log(JSON.stringify(user2));\n\n// name과 랜덤 문자열이 출력됨\nfor (let i in user1) {\n  console.log(i);\n}\n// name만 출력됨\nfor (let i in user2) {\n  console.log(i);\n}\n</code></pre>\n<p>물론 랜덤 문자열 속성을 사용자 접근으로부터 숨길 수 있다. <code>Object.defineProperty</code>를 사용하면 된다. 가령 위 코드의 <code>addPropertyByRandom</code>함수를 다음과 같이 변경하면 랜덤 문자열을 이용한 방법도 심볼을 통한 접근과 비슷하게 쓸 수 있을 것이다.</p>\n<pre><code class=\"language-js\">function addPropertyByRandom(obj) {\n  Object.defineProperty(obj, id, {\n    enumerable: false,\n    value: uuidv4(),\n  });\n}\n</code></pre>\n<p>하지만 심볼을 쓸 수 있는 환경이라면 만에 하나 충돌이 일어날 수도 있는 랜덤 문자열 생성과 복잡한 <code>Object.defineProperty</code>를 통한 속성 설정보다는 심볼을 쓰는 게 더 간단하고 안전하다.</p>\n<h1>5. 잘 알려진 심볼</h1>\n<h2>5.1. 배경</h2>\n<p>심볼이 등장하기 이전에 JS는 몇몇 내장 작업에 그냥 객체의 내장 함수 속성을 사용했다. <a href=\"https://witch.work/posts/javascript-json-object#3.2.3.-toJSON\">JSON.stringify 함수는 지금도 객체의 <code>toJSON()</code> 메서드를 사용한다.</a> <code>toString()</code> 메서드도 객체의 일반 속성으로 정의되어 있다.</p>\n<p>하지만 이런 객체 내장 함수 속성이 늘어날수록 이름 충돌로 인해 하위 호환성이 깨질 가능성이 높아지고 사용자가 객체 속성을 만들 때 고려해야 할 점이 늘어난다.</p>\n<p>이런 내장 함수를 심볼 키에 대응시킴으로써 이런 문제를 해결할 수 있어졌다. 그리고 이때 쓰이는 심볼 키를 well-known symbol이라고 한다.</p>\n<h2>5.2. 잘 알려진 심볼 소개</h2>\n<p><code>Symbol</code>생성자 함수의 정적 속성은 모두 그 자체로 심볼이다. 이 심볼들은 잘 알려진 심볼(well-known symbol)이라 불리며 JS 내장 작업에서 일종의 프로토콜로 동작한다.</p>\n<p>이런 잘 알려진 심볼은 보통 이름 앞에 <code>@@</code>를 붙여 구분한다. <code>@@toPrimitive</code>같은 식으로 말이다. 심볼에는 리터럴이 존재하지 않기도 하고 <code>Symbol.toPrimitive</code>처럼 쓰면 다른 별칭으로 같은 심볼을 가리킬 수 있다는 게 드러나지 않기 때문이다.</p>\n<p>예를 들어서 ECMA의 JS 명세를 읽다 보면 <code>ToPrimitive</code>라는 내장 작업을 숱하게 보게 된다. 이 작업은 객체를 원시형으로 변환할 때 사용되는데 이때 가장 우선적으로 사용되는 메서드가 바로 <code>@@toPrimitive</code>이다. 이 메서드가 객체에 없으면 <code>toString</code>과 <code>valueOf</code>를 사용한다.</p>\n<p><img src=\"/static/ecma-toprimitive-59947c43.png\" alt=\"ToPrimitive 명세\"></p>\n<p>다른 잘 알려진 심볼로는 <code>@@iterator</code>, <code>@@toStringTag</code>등이 있다. 이런 식으로 JS는 내장 작업을 위해 잘 알려진 심볼을 우선적으로 사용하는데 다음 섹션에서는 이런 잘 알려진 심볼 중 대표적인 몇 개만 알아볼 것이다. 이 글에서 중요한 것은 잘 알려진 심볼 각각이 아니라 심볼이라는 값이 JS의 내부 구현에 많이 녹아 있다는 것을 알아두는 것이기 때문이다.</p>\n<p>참고로 이런 잘 알려진 심볼들은 프로그램의 수명 내내 고유하게 유지되기 때문에 가비지 컬렉션 여부와 같은 문제를 고려하지 않아도 된다. 그냥 늘 존재하는 것이다.</p>\n<h1>6. 잘 알려진 심볼 예시</h1>\n<p>JS에는 다음과 같은 잘 알려진 심볼들이 있다.</p>\n<h2>6.1. Symbol.unscopables</h2>\n<p>이 심볼은 특정 객체의 속성을 with 바인딩에서 제외하는데, with에서 발생하는 충돌을 해결하기 위해 만들어졌다.</p>\n<p>다음과 같이 Symbol.unscopables를 이용하여 객체의 일반 속성을 with 바인딩에서 가릴 수 있다.</p>\n<pre><code class=\"language-js\">const human = {\n  name: 'John',\n  age: 30,\n  [Symbol.unscopables]: {\n    age: true\n  }\n};\n\nwith(human) {\n  console.log(age); // Uncaught ReferenceError: age is not defined\n}\n</code></pre>\n<p>객체에 기존에 정의되어 있는 프로퍼티 혹은 메서드와 with 바인딩의 이름이 충돌할 때 기존 프로퍼티를 가리기 위해 이 <code>@@unscopables</code>를 사용할 수 있다.</p>\n<h2>6.2. Symbol.toPrimitive</h2>\n<p>객체를 원시형으로 형 변환시 사용되는 메서드로 hint에 따라 다른 원시형으로 변환하도록 설계할 수 있다. 하지만 딱히 제한이 있는 건 아니고 원시형을 반환하기만 하면 된다.</p>\n<pre><code class=\"language-js\">const user = {\n  name: \"김성현\",\n  age: 30,\n  // 원시형으로 변환해 주는 메서드. \n  // hint에 따라 다른 원시형으로 변환하도록 할 수 있다.\n  // 하지만 반환형이 원시형이기만 하면 형에 대한 제약은 없다.\n  [Symbol.toPrimitive](hint) {\n    return this.age;\n  },\n};\n\nconsole.log(String(user)); //30\n// 숫자로 형변환\nconsole.log(+user); // 30\n</code></pre>\n<p><a href=\"https://262.ecma-international.org/13.0/#sec-date.prototype-@@toprimitive\">빌트인 Date 객체 등이 이런 커스텀 toPrimitive를 가지고 있다.</a></p>\n<h2>6.3. Symbol.toStringTag</h2>\n<p>ECMA5에는 모든 객체에 객체의 분류를 나타내는 <code>[[Class]]</code> 내부 프로퍼티가 존재했었다. 그리고 이를 <code>toString()</code>메서드에 사용했다.</p>\n<p>하지만 ES6부터는 이 <code>[[Class]]</code>프로퍼티가 사라졌고 호환성을 위해 <code>@@toStringTag</code>가 정의었다. 따라서 class에서 다음과 같이 <code>@@toStringTag</code>를 오버로딩하면 <code>toString()</code>메서드를 호출할 때 사용된다.</p>\n<pre><code class=\"language-js\">class MyClass{\n  get [Symbol.toStringTag](){\n    return '내 클래스';\n  }\n}\n\nconst myClass = new MyClass();\n\nconsole.log(myClass.toString()); // [object 내 클래스]\n</code></pre>\n<p><a href=\"https://witch.work/posts/javascript-object-object#3.-Object.prototype.toString%EC%9D%98-%EC%9E%91%EB%8F%99%EB%B0%A9%EC%8B%9D\">이 <code>toString()</code>의 동작이 더 자세하게 설명된 글이 있으니 필요하면 참고할 수 있다.</a></p>\n<h2>6.4. Symbol.iterator</h2>\n<p><code>for..of</code>루프는 <code>obj[Symbol.iterator]()</code>를 호출하면서 시작된다. 따라서 <code>Symbol.iterator</code> 메서드를 이용하면 반복도 오버로딩할 수 있다.</p>\n<h3>6.4.1. 이터레이터 프로토콜</h3>\n<p>이때 반복을 담당하는 함수는 iterator 프로토콜로 정의되는데 객체가 next 메서드를 가지고 있고 다음 규칙에 따라 구현되었다면 그 객체는 iterator 프로토콜을 따른다고 할 수 있다.</p>\n<p>이때 next는 다음 2개의 속성을 가진 object를 반환하고 인수가 없는 함수여야 한다는 규칙이 있다.</p>\n<ul>\n<li>done(boolean) : Iterator(반복자)가 마지막 반복 작업을 마쳤을 경우 true. 만약 iterator(반복자)에 return 값이 있다면 value의 값으로 지정된다. 반복자의 작업이 남아있을 경우 false이다.</li>\n<li>value : iterator로부터 반환되는 모든 자바스크립트 값. done이 true면 생략될 수 있다.</li>\n</ul>\n<p>String의 기본 반복자를 통해 볼 수 있다.</p>\n<pre><code class=\"language-js\">let word = \"witch\";\nlet it = word[Symbol.iterator]();\n// {value: 'w', done: false}\nconsole.log(it.next());\n// {value: 'i', done: false}\nconsole.log(it.next());\n</code></pre>\n<p>이를 이용해 <code>Symbol.iterator</code> 오버로딩을 하면 반복을 다르게 작동시킬 수 있다. 다음 코드를 보면 user 객체의 Symbol.iterator를 오버로딩하여, user 객체를 for..of로 순회할 때 name이 아닌 전혀 다른 문자열이 나오게 하였다.</p>\n<pre><code class=\"language-js\">let user = {\n  name: \"witch\",\n\n  [Symbol.iterator]: function () {\n    return {\n      next: function () {\n        if (this._first) {\n          this._first = false;\n          return { value: \"work\", done: false };\n        } else {\n          return { done: true };\n        }\n      },\n      _first: true,\n    };\n  },\n};\n\nlet it = user[Symbol.iterator]();\n// {value: 'work', done: false}\nconsole.log(it.next());\n// {done: true}\nconsole.log(it.next());\n\n// Symbol.iterator에 의해 work가 출력된다.\nfor (let i of user) {\n  console.log(i);\n}\n</code></pre>\n<h3>6.4.2. 제너레이터 만들기</h3>\n<p>제너레이터는 복잡한 데이터 구조를 순차 접근할 수 있는 배열처럼 쉽게 다룰 수 있게 해준다. 제너레이터가 데이터를 한 번에 하나씩 반환하도록 해주기 때문이다.</p>\n<p>또한 제너레이터는 함수가 호출되었을 때 끝까지 실행하지 않고 빠져나갔다가 다시 돌아올 수 있는 함수이기도 하다. 여러 개의 값을 필요한 만큼만 반환할 수 있는 것이다.</p>\n<p>제너레이터는 function 키워드 뒤에 <code>*</code>을 붙여 만들 수 있으며 yield 키워드를 통해 정보를 반환한다. next()메서드도 쓸 수 있는데 이 메서드의 구체적 사양은 위에서 본 것과 같다. 실제로는 데이터를 하나씩 가져오는 역할이다.</p>\n<p>다음 코드를 실행시켜 보면, member의 next를 호출할 때마다 getStudyMember에서 yield하는 값이 하나씩 반환되는 것을 볼 수 있다. 이는 정보가 매우 많고 일부씩만 접근해야 할 때 유용하다.</p>\n<pre><code class=\"language-js\">function* getStudyMember() {\n  yield \"멤버 AAA\";\n  yield \"멤버 BBB\";\n  yield \"멤버 CCC\";\n  yield \"멤버 DDD\";\n  yield \"멤버 EEE\";\n  yield \"멤버 FFF\";\n}\n\nconst member = getStudyMember();\nconsole.log(member.next());\nconsole.log(member.next());\nconsole.log(member.next());\nconsole.log(member.next());\n</code></pre>\n<p>이렇게 제너레이터를 만들면 이 제너레이터를 반복 가능한 객체처럼 쓸 수 있다. spread, for..of 등등 다 가능하다.</p>\n<pre><code class=\"language-js\">const member = getStudyMember();\n// 이름이 하나씩 출력됨\nfor (const m of member) {\n  console.log(m);\n}\n</code></pre>\n<p>이 제너레이터를 이용하면 앞서 말했다시피 복잡한 데이터 구조를 다룰 때 순차 접근하는 순서를 정해 줄 수 있다. 복잡하게 연관된 데이터를 배열처럼 순차 반복할 수 있게 되면 훨씬 간단하게 다룰 수 있다.</p>\n<p>그리고 이 제너레이터 함수를 Symbol.iterator에 할당해 주면, 제너레이터를 통해 복잡한 객체를 마치 배열과 같은 반복 가능한 객체로서 다룰 수 있게 된다.</p>\n<p>다음과 같은 코드를 볼 수 있다. 스터디 멤버들이 친구 관계로 중첩되어 묶여 있는 객체에 제너레이터를 만들어 주면 쉽게 순회할 수 있게 되고, 제너레이터를 더 잘 쓰면 한번에 n개씩만 순회하는 것도 가능하다. 이렇게 내가 만든 객체의 기능을 확장하는 데에도 잘 알려진 심볼이 쓰일 수 있다.</p>\n<pre><code class=\"language-js\">function Study() {\n  this.members = {\n    name: \"멤버 AAA\",\n    friend: {\n      name: \"멤버 BBB\",\n      friend: {\n        name: \"멤버 CCC\",\n        friend: {\n          name: \"멤버 DDD\",\n        },\n      },\n    },\n  };\n\n  this[Symbol.iterator] = function* () {\n    let node = this.members;\n    while (node) {\n      yield node.name;\n      node = node.friend;\n    }\n  };\n}\n\nconst myStudy = new Study();\nfor (let m of myStudy) {\n  console.log(m);\n}\n</code></pre>\n<p>또한 이렇게 제너레이터를 만들면 내가 만든 객체의 복잡도를 숨길 수 있다. 그럼으로써 다른 개발자가 내가 만든 데이터 구조를 간편하게 사용할 수 있다.</p>\n<p>이 제너레이터의 구조와 내부적인 동작에 대해서 더 알고 싶다면 <a href=\"https://witch.work/posts/callstack-and-iteration#5.-%ED%95%9C-%EA%B1%B8%EC%9D%8C-%EB%8D%94-%EB%82%98%EC%95%84%EA%B0%80%EA%B8%B0\">반복문에서 동시성까지</a>의 <code>#5</code>에서 간략히나마 다루고 있고 괜찮은 아티클도 많다.</p>\n<h2>6.5. Symbol.hasInstance</h2>\n<p>instanceof 연산자는 객체가 특정 클래스의 인스턴스인지 확인할 때 쓰인다. 이때 호출되는 것이 바로 Class의 constructor 혹은 생성자 함수의 <code>prototype</code>속성에 있는 <code>@@hasInstance</code>메서드이고 instanceof는 그 결과를 불리언으로 강제 변환된 결과를 반환한다.</p>\n<p>따라서 이를 내가 원하는 대로 커스텀할 수도 있다. 예를 들어서 다음과 같이 클래스 생성자의 <code>@@hasInstance</code>를 오버로딩하면 <code>instanceof</code>연산자를 통해 내가 원하는 대로 동작하도록 할 수 있다.</p>\n<p>다음과 같이 하면 <code>MyClass</code>는 모든 객체의 instanceof에 대해 true를 반환하게 된다.</p>\n<pre><code class=\"language-js\">class MyClass{\n  static [Symbol.hasInstance](obj){\n    return true;\n  }\n}\n\nconsole.log({} instanceof MyClass); // true\nconsole.log(1 instanceof MyClass); // true\nconsole.log('foo' instanceof MyClass); // true\n</code></pre>\n<p>이외에도 잘 알려진 심볼은 몇 가지 더 있는데, 잘 알려진 심볼들의 전체 목록 같은 경우 <a href=\"https://infoscis.github.io/2018/01/27/ecmascript-6-symbols-and-symbol-properties/\">개발자의 기록 보관소 블로그의 글</a>나 <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Symbol#%EC%A0%95%EC%A0%81_%EC%86%8D%EC%84%B1\">관련 MDN 문서</a>를 참고할 수 있다.</p>\n<h2>6.6. 잘 알려진 심볼들의 특성</h2>\n<p>이런 잘 알려진 심볼들은 엔진에 의해 모든 영역에서 공유된다. 앞서 살펴본 전역 심볼 레지스트리의 심볼과 같이 작동하는 것이다. 하지만 모든 영역에서 공유된다는 특성만 같을 뿐 잘 알려진 심볼들을 전역 심볼 레지스트리에서 찾을 수는 없다.</p>\n<h1>7. 결론</h1>\n<p>심볼은 ES6에서 새로 도입된 원시형으로, 다른 값과 중복되지 않는 유일무이한 값이다. 따라서 심볼을 키로 사용하면 다른 프로퍼티와 충돌할 위험이 없고 이를 이용해서 많은 객체의 내부 구현이 작동한다.</p>\n<p>하지만 어디에도 겹치지 않는 고유한 값이며 객체에서 어느 정도 은닉된 속성을 제공할 수 있다는 것이 그렇게까지 큰 매력은 되지 못하여, 어플리케이션 제작 시 심볼을 쓰는 경우는 많지 않다. 심지어 요즘 대세인 TS에서는 <code>enum</code>을 지원하기 때문에 심볼의 사용 가능성은 더 줄어들었다고 할 수 있겠다.</p>\n<p>어플리케이션 레벨에서는 이름 충돌 이슈를 고려하면서 숨김 속성이나 enum 비슷한 것을 만들 때 고려해 볼 만한 옵션 정도로 머리에 넣어 둘 수 있겠다. 하지만 JS 내부 구현이나 라이브러리 제작 시에 심볼은 꽤 소중한 속성이다.</p>\n<h1>참고</h1>\n<p>MDN의 symbol 문서 <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Symbol\">https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Symbol</a></p>\n<p>모던 자바스크립트 튜토리얼의 심볼형 <a href=\"https://ko.javascript.info/symbol\">https://ko.javascript.info/symbol</a></p>\n<p>nhn cloud, JavaScript Symbol의 근황 <a href=\"https://meetup.nhncloud.com/posts/312\">https://meetup.nhncloud.com/posts/312</a></p>\n<p>symbol의 쓰임에 관한 글 <a href=\"https://medium.com/intrinsic-blog/javascript-symbols-but-why-6b02768f4a5c\">https://medium.com/intrinsic-blog/javascript-symbols-but-why-6b02768f4a5c</a></p>\n<p>symbol의 쓰임에 관한 다른 글 <a href=\"https://roseline.oopy.io/dev/javascript-back-to-the-basic/symbol-usage\">https://roseline.oopy.io/dev/javascript-back-to-the-basic/symbol-usage</a></p>\n<p><a href=\"http://hacks.mozilla.or.kr/2015/09/es6-in-depth-symbols/\">http://hacks.mozilla.or.kr/2015/09/es6-in-depth-symbols/</a></p>\n<p>Symbol.iterator 참고 <a href=\"https://valuefactory.tistory.com/279\">https://valuefactory.tistory.com/279</a></p>\n<p>자바스크립트 코딩의 기술 41장, '제너레이터로 이터러블 속성을 생성하라'</p>\n<p>Symbol.species <a href=\"https://www.bsidesoft.com/5370\">https://www.bsidesoft.com/5370</a></p>\n<p>심볼의 본래 목적 <a href=\"https://exploringjs.com/es6/ch_symbols.html#_can-i-use-symbols-to-define-private-properties\">https://exploringjs.com/es6/ch_symbols.html#_can-i-use-symbols-to-define-private-properties</a></p>\n<p>Symbol.species 심볼과 용례\n<a href=\"https://jake-seo-dev.tistory.com/333\">https://jake-seo-dev.tistory.com/333</a></p>\n<p>crypto.randomUUID\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Crypto/randomUUID\">https://developer.mozilla.org/en-US/docs/Web/API/Crypto/randomUUID</a></p>\n<p>JavaScript Symbols: the Most Misunderstood Feature of the Language? <a href=\"https://blog.bitsrc.io/javascript-symbols-the-most-misunderstood-feature-of-the-language-282b6e2a220e\">https://blog.bitsrc.io/javascript-symbols-the-most-misunderstood-feature-of-the-language-282b6e2a220e</a></p>\n<p>ECMAScript 6 Symbol과 Symbol 프로퍼티\n<a href=\"https://infoscis.github.io/2018/01/27/ecmascript-6-symbols-and-symbol-properties/\">https://infoscis.github.io/2018/01/27/ecmascript-6-symbols-and-symbol-properties/</a></p>",
    "excerpt": "시작\nJS를 처음 배울 때는 보통 JS에서 다루는 기본적인 값인 원시값이라는 것들이 무엇인지를 배운다. 어디선가 다음과 비슷한 설명을 보면서 말이다.\n\nJavaScript에서 원시 값(primitive, 또는 원시 자료형)이란 객체가 아니면서 메서드도 가지지 않는 데이터입니다. 원시 값에는 7종류, string, number, bigint, boolean, undefined, symbol, 그리고 null이 존재합니다.\nMDN Web Docs - 원시 값\n\n그리",
    "headingTree": [
      {
        "title": "시작",
        "url": "#시작",
        "items": []
      },
      {
        "title": "1. 심볼 소개",
        "url": "#1-심볼-소개",
        "items": [
          {
            "title": "1.1. 심볼이란?",
            "url": "#11-심볼이란",
            "items": []
          },
          {
            "title": "1.2. 심볼의 설명 인자",
            "url": "#12-심볼의-설명-인자",
            "items": []
          },
          {
            "title": "1.3. 전역 심볼 레지스트리",
            "url": "#13-전역-심볼-레지스트리",
            "items": [
              {
                "title": "1.3.1 Symbol.for(key)",
                "url": "#131-symbolforkey",
                "items": []
              },
              {
                "title": "1.3.2 Symbol.keyFor(sym)",
                "url": "#132-symbolkeyforsym",
                "items": []
              }
            ]
          }
        ]
      },
      {
        "title": "2. 심볼형이 만들어진 목적",
        "url": "#2-심볼형이-만들어진-목적",
        "items": []
      },
      {
        "title": "3. 상수 정의에 사용",
        "url": "#3-상수-정의에-사용",
        "items": []
      },
      {
        "title": "4. 심볼형으로 숨김 프로퍼티 만들기",
        "url": "#4-심볼형으로-숨김-프로퍼티-만들기",
        "items": [
          {
            "title": "4.1. 객체의 숨겨진 속성 만들기",
            "url": "#41-객체의-숨겨진-속성-만들기",
            "items": []
          },
          {
            "title": "4.2. 외부 객체에 속성 추가하기",
            "url": "#42-외부-객체에-속성-추가하기",
            "items": []
          },
          {
            "title": "4.3. 다른 방법과의 비교",
            "url": "#43-다른-방법과의-비교",
            "items": []
          }
        ]
      },
      {
        "title": "5. 잘 알려진 심볼",
        "url": "#5-잘-알려진-심볼",
        "items": [
          {
            "title": "5.1. 배경",
            "url": "#51-배경",
            "items": []
          },
          {
            "title": "5.2. 잘 알려진 심볼 소개",
            "url": "#52-잘-알려진-심볼-소개",
            "items": []
          }
        ]
      },
      {
        "title": "6. 잘 알려진 심볼 예시",
        "url": "#6-잘-알려진-심볼-예시",
        "items": [
          {
            "title": "6.1. Symbol.unscopables",
            "url": "#61-symbolunscopables",
            "items": []
          },
          {
            "title": "6.2. Symbol.toPrimitive",
            "url": "#62-symboltoprimitive",
            "items": []
          },
          {
            "title": "6.3. Symbol.toStringTag",
            "url": "#63-symboltostringtag",
            "items": []
          },
          {
            "title": "6.4. Symbol.iterator",
            "url": "#64-symboliterator",
            "items": [
              {
                "title": "6.4.1. 이터레이터 프로토콜",
                "url": "#641-이터레이터-프로토콜",
                "items": []
              },
              {
                "title": "6.4.2. 제너레이터 만들기",
                "url": "#642-제너레이터-만들기",
                "items": []
              }
            ]
          },
          {
            "title": "6.5. Symbol.hasInstance",
            "url": "#65-symbolhasinstance",
            "items": []
          },
          {
            "title": "6.6. 잘 알려진 심볼들의 특성",
            "url": "#66-잘-알려진-심볼들의-특성",
            "items": []
          }
        ]
      },
      {
        "title": "7. 결론",
        "url": "#7-결론",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 4,
      "wordCount": 1093
    },
    "url": "/posts/javascript-symbol-usage",
    "thumbnail": {
      "local": "/static/ecma-toprimitive-59947c43.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-ecma-toprimitive-59947c43-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAHCAYAAAA1WQxeAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA1ElEQVR4nGMwMDT8LyQi+j8gIvK/qY3Nfy//wP8Nza3/m9p7/m/bve8/g4qK2n8zC+v/Lp4+/z28vf8HhUX8V9fU/K+qrv5/7sKF/xkqqir/Wzu5/M8pKPg/e/6C/5u27vh/+fKV/+/fvfv/7du3/wxPnjz5n1lY+J9HTOy/gIDA/0ePH///9u37fxhgABHz5y/4n11U9H/KjOn/3759C5cEKwAZExEb+5+Blfu/qpb2/03bt/8HmQpXMG3atL8gKypq6v/XNbb8n7d86f/jJ07AFQAAlLuZupNGL2UAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "javascript-settimeout",
    "title": "JS 탐구생활 - setTimeout의 부정확성과 이벤트 루프",
    "date": "2023-01-30T01:00:00Z",
    "description": "JS의 setTimeout 함수는 정확하지 않다. 그 이유는?",
    "tags": [
      "javascript"
    ],
    "html": "<h1>1. setTimeout</h1>\n<p>setTimeout 함수는 브라우저에서 제공하는 함수로, 주어진 시간이 지난 후에 함수를 실행시킨다.</p>\n<pre><code class=\"language-js\">let tid=setTimeout(func, time, arg1, arg2, ...);\n</code></pre>\n<p>그런데 이렇게 사용하면, 정확한 시간이 지난 후에 함수가 실행되지 않을 수 있다. 이런 이유들은 여러 가지 있는데 이를 하나씩 알아보자.</p>\n<h1>2. 중첩 타임아웃</h1>\n<p>HTML 표준은 중첩 타이머의 실행 간격에 관한 제약도 정의하고 있다. 5번째 중첩 타이머 이후에는 대기시간을 최소 4ms로 강제하는 것이다. setTimeout, setInterval 모두 마찬가지다.</p>\n<pre><code class=\"language-js\">let start = Date.now();\nlet times = [];\n\nsetTimeout(function tick() {\n  times.push(Date.now() - start);\n  // 시작한 지 100ms가 지나면 각 함수의 호출 시간들을 담은 배열을 출력\n  if (start + 100 &#x3C; Date.now()) {\n    console.log(times);\n  } else {\n    setTimeout(tick, 0);\n  }\n});\n// [0, 0, 1, 1, 5, 10, 14, 19, 24, 29, 34, 39, 44, 49, 54, 59, 64, 69, 74, 79, 84, 89, 94, 99, 104]\n</code></pre>\n<p>아래 코드를 실행하면 물론 세부적인 배열의 숫자들은 약간 다를 수 있겠지만 5번째 중첩 호출부터는 함수의 호출 간에 최소 4ms의 지연이 있다는 것을 알 수 있다. 실제로 setTimeout에는 0의 딜레이만 지정했는데도 말이다.</p>\n<p>이런 제약 때문에 setTimeout은 완벽히 정확한 시간 간격을 보장하지 않는다.</p>\n<h1>3. 브라우저의 비활성 탭 관리</h1>\n<p>다음 코드는 1초마다 'tick'이라는 로그를 찍도록 하는 코드이다.</p>\n<pre><code class=\"language-js\">setTimeout(function tick() {\n  console.log(\"tick\");\n  setTimeout(tick, 1000);\n}, 1000);\n</code></pre>\n<p>그런데 이 코드를 실행하고 브라우저의 탭을 비활성화(그냥 다른 탭을 보고 있으면 된다)한 후 10초를 세고 다시 탭을 열어 보면, 로그가 10개 미만으로 찍혀 있는 것을 볼 수 있다.</p>\n<p>이는 브라우저가 비활성화된 탭에서는 최소 딜레이를 강제하기 때문이다. 백그라운드 탭으로 인한 부하를 줄이기 위해서다.</p>\n<h1>4. 늦은 타임아웃</h1>\n<p>페이지나 OS, 브라우저가 다른 작업으로 인해 바쁠 경우 타임아웃이 더 지연될 수 있다. setTimeout을 호출한 스레드의 종료 이전에는 setTimeout의 콜백이 실행되지 않기 때문이다.</p>\n<p>다음 코드로 이를 확인할 수 있다.</p>\n<pre><code class=\"language-js\">setTimeout(() => {\n  console.log(\"a\");\n});\nconsole.log(\"b\");\n// b a\n</code></pre>\n<p>위 코드는 브라우저에서 실행하면 'b'가 먼저 출력되고 'a'가 출력된다. 현재 스레드에서 처리하고 있던 스크립트가 먼저 완료되어 'b'가 출력되고 그 이후에서야 'a'가 출력되는 것이다.</p>\n<p>그런데 만약 위 코드에서 <code>console.log('b')</code>에 해당하는 부분이 시간이 굉장히 많이 걸리는 코드라면 setTimeout에 전달한 함수의 실행은 매우 늦어질 것이다. 이런 이유로 setTimeout이 지정한 지연 시간이 부정확하게 적용될 수 있다.</p>\n<h2>4.1. setTimeout의 실행 과정</h2>\n<p>setTimeout 실행 과정은 다음과 같다.</p>\n<ol>\n<li>setTimeout이 실행된다.</li>\n<li>이 setTimeout은 WebAPI에 전달된다.</li>\n<li>WebAPI는 setTimeout이 지정한 delay가 지나면 setTimeout의 콜백 함수를 태스크 큐로 전달한다.</li>\n<li>이벤트 루프가 돌다가 콜스택이 비어있으면 태스크 큐의 top에 있는 콜백 함수를 꺼내서 콜스택에 넣는다.</li>\n</ol>\n<p>그런데 만약 콜스택이 현재 어떤 코드를 실행시키고 있다면 이벤트 루프는 block된다. 즉, 만약 브라우저에서 어떤 작업을 굉장히 바쁘게 실행하고 있다면 이벤트 루프는 계속 block되어 있을 테고 따라서 setTimeout의 콜백은 태스크 큐에서 콜스택으로 전달되지 못할 것이다.</p>\n<p>이런 JS의 비동기 실행에 관한 것은 <a href=\"https://www.witch.work/javascript-event-loop-dive/\">이 글</a>에 더 자세히 다루었다.</p>\n<h1>5. 기타 이유들</h1>\n<p>파이어폭스는 현재 탭이 로딩중일 시 setTimeout의 타이머 실행을 지연시킨다.</p>\n<p>그리고 WebExtension에서는 setTimeout을 신뢰할 수 없으므로 alarm API를 사용해야 한다.</p>\n<p>IE, 크롬, 파이어폭스 등의 브라우저는 딜레이를 내부적으로 32비트 부호있는 정수로 저장한다. 따라서 2147483647ms(약 24.8일)보다 큰 딜레이를 주면 정수 오버플로우로 인해 타이머가 즉시 만료된다.</p>\n<h1>참고</h1>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/API/setTimeout#%EB%94%9C%EB%A0%88%EC%9D%B4%EA%B0%80_%EC%A7%80%EC%A0%95%ED%95%9C_%EA%B0%92%EB%B3%B4%EB%8B%A4_%EB%8D%94_%EA%B8%B4_%EC%9D%B4%EC%9C%A0\">https://developer.mozilla.org/ko/docs/Web/API/setTimeout#%EB%94%9C%EB%A0%88%EC%9D%B4%EA%B0%80_%EC%A7%80%EC%A0%95%ED%95%9C_%EA%B0%92%EB%B3%B4%EB%8B%A4_%EB%8D%94_%EA%B8%B4_%EC%9D%B4%EC%9C%A0</a></p>\n<p><a href=\"https://ssocoit.tistory.com/249\">https://ssocoit.tistory.com/249</a></p>\n<p><a href=\"https://ko.javascript.info/settimeout-setinterval\">https://ko.javascript.info/settimeout-setinterval</a></p>\n<p><a href=\"https://negabaro.github.io/archive/js-async-detail\">https://negabaro.github.io/archive/js-async-detail</a></p>\n<p><a href=\"https://velog.io/@seongkyun/fetch-setTimeout%EC%9D%80-%ED%91%9C%EC%A4%80-API%EC%9D%BC%EA%B9%8C-len7n3gc\">https://velog.io/@seongkyun/fetch-setTimeout%EC%9D%80-%ED%91%9C%EC%A4%80-API%EC%9D%BC%EA%B9%8C-len7n3gc</a></p>\n<p><a href=\"https://joooing.tistory.com/entry/%EC%9D%B4%EB%B2%A4%ED%8A%B8%EB%A3%A8%ED%94%84-setTimeout%EC%9D%98-%EC%8B%9C%EA%B0%84%EC%9D%80-%EC%A0%95%ED%99%95%ED%95%A0%EA%B9%8C\">https://joooing.tistory.com/entry/%EC%9D%B4%EB%B2%A4%ED%8A%B8%EB%A3%A8%ED%94%84-setTimeout%EC%9D%98-%EC%8B%9C%EA%B0%84%EC%9D%80-%EC%A0%95%ED%99%95%ED%95%A0%EA%B9%8C</a></p>\n<p><a href=\"https://felixgerschau.com/javascript-event-loop-call-stack/#web-apis\">https://felixgerschau.com/javascript-event-loop-call-stack/#web-apis</a></p>",
    "excerpt": "1. setTimeout\nsetTimeout 함수는 브라우저에서 제공하는 함수로, 주어진 시간이 지난 후에 함수를 실행시킨다.\nlet tid=setTimeout(func, time, arg1, arg2, ...);\n\n그런데 이렇게 사용하면, 정확한 시간이 지난 후에 함수가 실행되지 않을 수 있다. 이런 이유들은 여러 가지 있는데 이를 하나씩 알아보자.\n2. 중첩 타임아웃\nHTML 표준은 중첩 타이머의 실행 간격에 관한 제약도 정의하고 있다. 5번째 중첩 타이머 ",
    "headingTree": [
      {
        "title": "1. setTimeout",
        "url": "#1-settimeout",
        "items": []
      },
      {
        "title": "2. 중첩 타임아웃",
        "url": "#2-중첩-타임아웃",
        "items": []
      },
      {
        "title": "3. 브라우저의 비활성 탭 관리",
        "url": "#3-브라우저의-비활성-탭-관리",
        "items": []
      },
      {
        "title": "4. 늦은 타임아웃",
        "url": "#4-늦은-타임아웃",
        "items": [
          {
            "title": "4.1. setTimeout의 실행 과정",
            "url": "#41-settimeout의-실행-과정",
            "items": []
          }
        ]
      },
      {
        "title": "5. 기타 이유들",
        "url": "#5-기타-이유들",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 221
    },
    "url": "/posts/javascript-settimeout",
    "thumbnail": {
      "local": "/thumbnails/javascript-settimeout-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-javascript-settimeout-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAk0lEQVR4nCWNoQ3DMBAADTxDFgh+YulJUGC4aQaIInkAA09galK1E1QyKDL4ASI9C2mY57AU8FWToyfdKSKapmldV0T03otIa+08TxVjBABrLSIOw5BSEpG/cM51Xdf3vTEGALTWy7KM46iY2XsfQmDmWmspZd/3bdvU4/ma59k5dxzHHZEL9c6fnDMRfS/RWrsfP5WRWKeasA8dAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "javascript-template-literal",
    "title": "JS 탐구생활 - 템플릿 리터럴",
    "date": "2022-12-22T00:00:00Z",
    "description": "JS의 템플릿 리터럴에 관하여",
    "tags": [
      "javascript"
    ],
    "html": "<p>JS의 템플릿 리터럴 문법에 대해 정리하였다.</p>\n<h1>1. 개념</h1>\n<p>템플릿 리터럴은 ES6에 새로 들어온 문자열 표기법으로 문자열을 표기할 때 사용한다. 그리고 기존에 따옴표를 사용하던 표기 대신 백틱(`)을 사용한다. 다음과 같이 기존 문자열 표기와 똑같은 방식으로도 사용할 수 있다.</p>\n<pre><code class=\"language-js\">let word=`witch`;\nconsole.log(word);\n</code></pre>\n<p>그리고 기본적으로 여러 줄 문자열과 표현식 삽입이 가능하다. <code>${}</code>로 싸인 부분에 들어간 표현식은 평가되어서 문자열에 삽입된다.</p>\n<pre><code class=\"language-js\">// 여러 줄 문자열 예시\nlet word=`저는\n김성현\n입니다`;\nconsole.log(word);\n\n// 표현식 삽입\nlet myName=\"김성현\"\nlet word=`저는 ${myName}입니다`;\nconsole.log(word);\n</code></pre>\n<p>그리고 템플릿 리터럴 안에서 `을 사용하기 위해서는 앞에 백슬래시를 붙여야 한다.</p>\n<pre><code class=\"language-js\">let word=`\\` &#x3C;- 이건 백틱입니다.`;\nconsole.log(word);\n</code></pre>\n<h1>2. 태그 함수</h1>\n<p>이를 발전시킨 방식이 tagged template이다. 태그 함수를 사용해 템플릿 리터럴을 함수로 파싱하여 여러 동작을 할 수 있는 것이다. 태그 함수는 템플릿 리터럴을 인자로 받아서 처리한 후에 반환한다. 꼭 문자열을 반환할 필요는 없다.</p>\n<p>사용 방식은 다음과 같다.</p>\n<pre><code class=\"language-js\">태그함수명`템플릿 리터럴`\n</code></pre>\n<p>이때 태그함수의 첫번째 인자로는 <code>${}</code>로 감싸이지 않은 일반 문자열들이 <code>${}</code>를 단위로 구분되어 split된 배열이 들어가고 두번째 인자부터는 <code>${}</code>로 감싸인 표현식들이 들어간다.</p>\n<p>예를 들어서 다음과 같은 코드가 있다고 하자.</p>\n<pre><code class=\"language-js\">function tag(strings, arg1, arg2){\n  console.log(strings, arg1, arg2);\n}\n\nlet myName=\"김성현\"\nlet myAge=25;\n\ntag`저는 ${myName}이고 ${myAge}살입니다.`;\n</code></pre>\n<p>위 코드에서 tag 함수는 템플릿 리터럴을 파싱한 결과들이 인수로 들어가서 호출된다. 첫번째 인자로는 <code>${}</code>로 감싸이지 않은 문자열들 즉 <code>\"저는 \", \"이고 \", \"살입니다\"</code>가 담긴 배열이 들어가고 두번째 인자부터는 <code>${}</code>로 감싸인 표현식들이 들어간다. 즉, <code>myName</code>과 <code>myAge</code>가 들어간다.</p>\n<p>따라서 tag 함수 내부의 console.log는 다음과 같은 결과를 출력한다.</p>\n<pre><code class=\"language-js\">[\"저는 \", \"이고 \", \"살입니다\"] \"김성현\" 25\n</code></pre>\n<p>주의할 점은 일반 문자열이 <code>${}</code>를 기준으로 split되므로 마지막 <code>${}</code>뒤에 아무 내용이 없더라도 빈 문자열이 들어간다는 것이다.</p>\n<p>예를 들어서 아래 코드의 tag 함수가 호출될 때 strings에는 <code>[\"저는 \", \"\"]</code>이 들어간다. <code>${myName}</code>뒤에 아무 내용이 없음에도 불구하고 빈 문자열이 파싱되어 들어간다.</p>\n<pre><code class=\"language-js\">function tag(strings, arg1){\n  console.log(strings, arg1);\n}\n\nlet myName=\"김성현\"\n\ntag`저는 ${myName}`;\n</code></pre>\n<h2>2.1. raw string</h2>\n<p>태그 함수로 String.raw를 사용하면 템플릿 리터럴의 원시 문자열을 얻을 수 있다. <code>${}</code>로 감싸인 문자열은 대체되지만 이스케이프 문자는 처리되지 않는 것이다.</p>\n<pre><code class=\"language-js\">let str = String.raw`Hi \\n${myName}!`;\n// 이스케이프 문자가 처리되지 않아 Hi \\nwitch! 가 출력된다.\nconsole.log(str);\n</code></pre>\n<h1>3. 응용</h1>\n<h2>3.1. HTML 템플릿 만들기</h2>\n<p>이런 템플릿 리터럴을 어떻게 사용할 수 있을까? 가장 대표적인 예로는 HTML 템플릿을 만드는 데에 사용할 수 있다.</p>\n<p>예를 들어 다음과 같은 내 정보 객체가 있다고 하자.</p>\n<pre><code class=\"language-js\">const me={\n  name:\"Kim Sung Hyun\",\n  blog:\"https://www.witch.work/\"\n}\n</code></pre>\n<p>이 객체를 이용해서 다음과 같은 재사용 가능한 HTML 템플릿을 만드는 함수를 만들 수 있다.</p>\n<pre><code class=\"language-js\">function makeMarkUp({name, blog}){\n  return `\n    &#x3C;div class=\"me\">\n      &#x3C;h1>${name}&#x3C;/h1>\n      &#x3C;a href=\"${blog}\">${blog}&#x3C;/a>\n    &#x3C;/div>\n  `;\n}\n\nconsole.log(makeMarkUp(me));\n</code></pre>\n<p>태그 함수를 이용하면 같은 동작을 더 세련되게도 할 수 있다.</p>\n<p>먼저 다음과 같은 태그 함수를 만들자. 위와 같은 동작을 위해서는 즉시 실행 함수를 리턴해 줘야 한다.</p>\n<pre><code class=\"language-js\">function templater(strings, ...keys){\n  return function(data){\n    // strings 복사본 만들기\n    let temp = strings.slice();\n    // 각 strings의 뒤에 오는 표현식(${}로 감싸였던 것)의 결과를 붙여 준다. \n    keys.forEach((key, idx)=>{\n      temp[idx] = temp[idx] + data[key];\n    });\n    // 나눠진 문자열들을 붙여 준다.\n    return temp.join('');\n  }\n}\n</code></pre>\n<p>그럼 똑같이 <code>makeMarkUp</code> 함수를 만들 수 있다.</p>\n<pre><code class=\"language-js\">const makeMarkUp = templater`\n  &#x3C;div class=\"me\">\n    &#x3C;h1>${'name'}&#x3C;/h1>\n    &#x3C;a href=\"${'blog'}\">${'blog'}&#x3C;/a>\n  &#x3C;/div>\n`;\nconsole.log(makeMarkUp(me));\n</code></pre>\n<p>또한 이 templater 함수를 사용하면 다른 템플릿도 얼마든지 만들 수 있다.</p>\n<pre><code class=\"language-js\">const costInfo={\n\tgoods:\"카페라떼\",\n  cost:4500,\n}\n\nconst makeCostMarkUp = templater`\n  &#x3C;div class=\"cost\">\n    &#x3C;h1>${'goods'}&#x3C;/h1>\n    &#x3C;h2>${'cost'}원&#x3C;/h2>\n  &#x3C;/div>\n`;\n\nconsole.log(makeCostMarkUp(costInfo));\n</code></pre>\n<h2>3.2. typescript 타입 정의</h2>\n<p><a href=\"https://youthfulhps.dev/typescript/typescript-essentials-you-should-know/#9-%ED%83%80%EC%9E%85-%EC%84%A0%EC%96%B8%EB%8F%84-dry-%EC%9B%90%EC%B9%99%EC%9D%84-%EC%A4%80%EC%88%98%ED%95%B4%EC%95%BC-%ED%95%9C%EB%8B%A4\">JS의 예시는 아니지만 여러 개의 유니온 타입을 확장하여 새로운 문자열 리터럴 타입을 정의하는 데에 쓸 수 있다.</a></p>\n<pre><code class=\"language-ts\">type DrinkType = 'ade' | 'juice';\ntype Flavor = 'lemon' | 'graphfruit' | 'Strawberry'\n\ntype DrinkMenu = `${Flavor}${DrinkType}`;\n//type DrinkMenu = \"lemonade\" | \"lemonjuice\" | \"graphfruitade\" | \"graphfruitjuice\" | \"Strawberryade\" | \"Strawberryjuice\"\n</code></pre>\n<h1>참고</h1>\n<p>MDN의 템플릿 리터럴 문서 <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Template_literals\">https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Template_literals</a></p>\n<p>MDN String.raw() <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/raw\">https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/raw</a></p>\n<p>poiemaweb의 템플릿 리터럴 설명 <a href=\"https://poiemaweb.com/es6-template-literals\">https://poiemaweb.com/es6-template-literals</a></p>\n<p>CSS Tricks의 템플릿 리터럴에 관한 글 <a href=\"https://css-tricks.com/template-literals/\">https://css-tricks.com/template-literals/</a></p>\n<p>문자열 리터럴 타입 정의 <a href=\"https://youthfulhps.dev/typescript/typescript-essentials-you-should-know/\">https://youthfulhps.dev/typescript/typescript-essentials-you-should-know/</a></p>",
    "excerpt": "JS의 템플릿 리터럴 문법에 대해 정리하였다.\n1. 개념\n템플릿 리터럴은 ES6에 새로 들어온 문자열 표기법으로 문자열을 표기할 때 사용한다. 그리고 기존에 따옴표를 사용하던 표기 대신 백틱(`)을 사용한다. 다음과 같이 기존 문자열 표기와 똑같은 방식으로도 사용할 수 있다.\nlet word=`witch`;\nconsole.log(word);\n\n그리고 기본적으로 여러 줄 문자열과 표현식 삽입이 가능하다. ${}로 싸인 부분에 들어간 표현식은 평가되어서 문자열에 삽",
    "headingTree": [
      {
        "title": "1. 개념",
        "url": "#1-개념",
        "items": []
      },
      {
        "title": "2. 태그 함수",
        "url": "#2-태그-함수",
        "items": [
          {
            "title": "2.1. raw string",
            "url": "#21-raw-string",
            "items": []
          }
        ]
      },
      {
        "title": "3. 응용",
        "url": "#3-응용",
        "items": [
          {
            "title": "3.1. HTML 템플릿 만들기",
            "url": "#31-html-템플릿-만들기",
            "items": []
          },
          {
            "title": "3.2. typescript 타입 정의",
            "url": "#32-typescript-타입-정의",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 262
    },
    "url": "/posts/javascript-template-literal",
    "thumbnail": {
      "local": "/thumbnails/javascript-template-literal-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-javascript-template-literal-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAfklEQVR4nGPYtm2br69vTk62rq5ueXm5r6+vjIzM3r17Gdra2piZmYODg48dO3bp0qXDhw9v3rz55cuXDHv37mtra7t06dJ/VMBw8uTJGTNmvHnz5v///39gACRx/9Hj+/cf3Llz5/379yg6lq5cs3jxks2bN9+4cQOiCSIBAAeLbhlWNde1AAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "javascript-spread-object",
    "title": "JS 탐구생활 - 스프레드 구문의 동작",
    "date": "2023-01-22T00:00:00Z",
    "description": "스프레드 구문 탐구일지",
    "tags": [
      "javascript"
    ],
    "html": "<h1>1. 스프레드 구문</h1>\n<p>스프레드라고 불리는 <code>...</code>구문은 배열, 문자열과 같이 반복 가능한 객체에 쓸 수 있다. 0개 이상의 인수가 기대되는 함수 호출이나 배열 리터럴의 내부에 쓰여서 반복 가능한 객체를 확장해 준다.</p>\n<p>예를 들어 스프레드 구문을 이용해 배열 원소들을 전부 함수 인수로 전달할 수 있다.</p>\n<pre><code class=\"language-js\">const numbers = [1, 3, -8, 37, 5, -324, 623];\n\nconsole.log(Math.max(...numbers)); //623\n</code></pre>\n<p>또한 객체 리터럴에도 쓰일 수 있는데 그렇게 사용하면 스프레드 구문은 객체의 프로퍼티를 열거(enumerate)하고 생성되는 객체에 키-값 쌍을 더한다.</p>\n<p>이때 나머지 구문과는 다르다. 물론 같은 <code>...</code>이지만 나머지 구문은 여러 원소들을 모아서 하나의 원소(배열)로 만드는 역할을 한다.</p>\n<p>여기서 다루는 <code>...</code>의 역할은 요소 스프레드(SpreadElement) 즉 <code>let arr=[a,b,...c]</code>와 같이 새로운 이터러블에 들어가는 이터러블을 확장하는 것, 그리고 인수 스프레드, <code>func(a,b,...c)</code>와 같이 요소들을 개별적으로 함수 인수로 전달하기 위해 이터러블을 확장하는 것을 말한다.</p>\n<h1>2. 스프레드 연산자?</h1>\n<p>인터넷을 찾아보면 스프레드 연산자라고 쓰인 문서를 많이 발견할 수 있다. 그러나 이는 절대로 연산자가 아니다. 이유들은 다음과 같다.</p>\n<h2>2.1. 연산자의 조건 불만족</h2>\n<p>연산자는 기본적으로 인수를 받고 그 결과가 <code>하나의 값</code>으로 평가되는 함수이다. 그 결과값은 그냥 값(rvalue)이거나 할당을 허용하는 객체(lvalue)이다. 예를 들어서 <code>2+3</code>은 인수 2,3을 받고 5라는 결과값으로 평가될 것이다.</p>\n<p>그런데 <code>...</code>는 하나의 값으로 평가되지 못한다. <code>...arr</code>는 이터러블 arr의 원소들을 하나하나 펼치고 결국 여러 개의 값으로 평가된다. 따라서 <code>...</code>은 연산자의 기본적인 조건부터 만족하지 못한다.</p>\n<p>또한 <code>...</code>은 단독으로 쓰일 수 없다. 배열이나 함수 호출의 맥락에서만 쓰일 수 있다. 그런 맥락에서만 <code>...</code>이 배열이나 객체 등을 확장한 여러 값들을 받아낼 수 있기 때문이다. 따라서 다른 맥락에서 사용하는 것은 허용되지 않는다. 예를 들어 다음 코드는 <code>...</code>에 대한 에러를 발생시킬 것이다.</p>\n<pre><code class=\"language-js\">let a=[1,2,3];\nb=...a;\n</code></pre>\n<p>만약 <code>...</code>이 연산자였다면 당연히 피연산자와 함께 단독으로 쓰일 수 있었을 것이다. 이렇게 연산자로서 단독으로 쓰일 수 없다는 것도 <code>...</code>이 연산자가 아니라는 것을 뒷받침한다.</p>\n<h2>2.2. 표준에서</h2>\n<p>그리고 <code>...</code>이 연산자라면 단항에 prefix 연산자일 것이다. 그런데 ECMA 표준 문서의 <a href=\"https://tc39.es/ecma262/#sec-unary-operators\">단항 연산자 부분</a>을 눈을 씻고 찾아봐도 <code>...</code>에 대한 언급은 없다. 물론 연산자에 대한 다른 내용들을 보아도 <code>...</code>은 없다. 이때 이 표준은 <code>...</code>이 처음 소개되었을 때를 기준으로 한다.</p>\n<p><code>...</code>이 언급되는 곳은 배열 리터럴에 대한 부분 그리고 함수 호출에 대한 부분뿐이다. 이런 맥락이 있어야만 <code>...</code>을 쓸 수 있다는 것이다. 따라서 표준에도 <code>...</code>은 연산자로 언급되어 있지 않으며 특정 맥락에서만 쓰일 수 있다고 되어 있다.</p>\n<p>하지만 연산자는 앞에서 말했듯 단독으로 쓰여서 평가받을 수 있어야 하므로 <code>...</code>은 연산자라 할 수 없다.</p>\n<h2>2.3. 맥락에 따라 달라지는 작동방식</h2>\n<p>연산자는 언제나 같은 방식으로 동작한다. <code>2+3</code>을 어떤 맥락에서 하든지 간에 결과는 똑같을 것이다. 그러나 <code>...</code>구문이 스프레드와 나머지 인수 2가지로 해석된다는 것은 이미 너무 잘 알려져 있다.</p>\n<pre><code class=\"language-js\">const arr=[1,2,3];\nconsole.log(Math.max(...arr)); //스프레드로 사용\nconsole.log([...arr]);\nfunction foo(arg1, ...rest){} // 나머지 인수로 사용\n</code></pre>\n<p>즉 <code>...</code>이 어떻게 작동하는지가 쓰이는 맥락에 따라 달라지는 것이다. 어떨 때는 원소들을 펼쳐주고 어떨 때는 모아 준다. 연산자는 이렇게 맥락에 따라 실행 결과가 달라지면 안 된다.</p>\n<p>앞서 말한 이유들로 인해 <code>...</code>은 스프레드 연산자가 아니라 스프레드 구문으로 쓰는 게 맞을 것이다. syntax라는 용어를 쓰자는 주장도 있다. 하지만 어떤 용어를 쓰던지 간에 연산자가 아니라는 것은 똑같다.</p>\n<h2>2.4. 그럼 왜 스프레드 연산자라는 말이 쓰이는가?</h2>\n<p><code>...a</code>꼴로 쓰이는 게 단항 prefix 연산자처럼 보여서 그런 듯 하다. 또한 <a href=\"https://stackoverflow.com/questions/37151966/what-is-spreadelement-in-ecmascript-documentation-is-it-the-same-as-spread-synt/37152508#37152508\">이 글</a>에서는, <code>...</code>을 이용해 함수 인수를 전달하는 것에 대한 이름이 공식 문서에는 존재하지 않는데 이를 부르는 이름으로 사람들이 '스프레드 연산자'라는 말을 만들어낸 게 아닐까 추측하고 있다.</p>\n<h1>3. 배열에서의 작동 방식</h1>\n<p><code>...</code>이 이터러블에 쓰여서 함수 호출이나 배열 리터럴 내에서 펼쳐지는 즉 SpreadElement 목적으로 쓰인다고 하자. 그럼 이것의 내부 동작은 어떻게 될까?</p>\n<p><code>...args</code>가 감지되면 js엔진은 args의 이터레이터를 가져오려고 한다. 이는 이터레이터 프로토콜이며 <code>Symbol.iterator</code>를 통해 정의된 값이다. 만약 args가 이터러블 객체가 아니라면 타입 에러가 발생할 것이다. 단 객체 리터럴은 예외인데 이는 따로 설명한다.</p>\n<pre><code class=\"language-js\">console.log(...100);\n</code></pre>\n<p>100은 이터러블이 아니므로 당연히 에러가 발생할 것이다. 이 에러 메시지를 보면 우리가 앞에서 이야기한 <code>Symbol.iterator</code>가 <code>...</code>사용에 요구된다는 것을 명확히 언급하고 있다.</p>\n<pre><code>Uncaught TypeError: Spread syntax requires ...iterable[Symbol.iterator] to be a function\n</code></pre>\n<p>아무튼 <code>...args</code>가 호출되면 엔진은 args의 이터레이터에 접근해서 반복이 끝날 때까지 iterator.next를 호출할 것이다. 예를 들어서 다음 코드를 보자.</p>\n<pre><code class=\"language-js\">let cnt = 1;\n\nconst it = {\n    [Symbol.iterator]() {\n        const arr = [\"김\", \"성\", \"현\"];\n        let idx = arr.length;\n        console.log(\"이터레이터 호출\");\n        return {\n            next() {\n                console.log(cnt++);\n                return {\n                    value: arr[--idx],\n                    done:idx&#x3C;0\n                }\n            }\n        }\n    }\n}\n\nfunction func() {}\n\nlet temp = [...it];\nconsole.log(temp);\nfunc(...it);\n</code></pre>\n<p>이 코드의 실행 결과는 다음과 같다. <code>...it</code>를 js엔진이 감지하면, it의 Symbol.iterator가 호출되고 반복이 끝날 때까지 next가 호출되는 것을 알 수 있다. arr이 temp에 담긴 순서도 이를 뒷받침한다. 이는 for..of의 작동 방식과 같다.</p>\n<p><img src=\"/static/iterator_exec-bd5d7ee2.PNG\" alt=\"exec1\"></p>\n<h1>4. 객체 스프레드</h1>\n<p>우리는 <code>...</code>이 이터러블에만 사용될 수 있다고 지금까지 다뤄왔다. 그런데 다음 코드를 보자.</p>\n<pre><code class=\"language-js\">let me = {\n    name: \"김성현\",\n    blog:\"witch.work\"\n}\n\nlet meCopy = { ...me };\nconsole.log(meCopy); // 객체가 잘 복사되었다\n</code></pre>\n<p><code>me</code>객체에는 Symbol.iterator 같은 게 없다. 그런데 스프레드가 잘 동작하는 것을 볼 수 있다. 대체 어떻게?</p>\n<p>이는 스프레드 프로퍼티 프로포절에 객체 리터럴에 대해서도 스프레드 문법을 사용할 수 있도록 <a href=\"https://github.com/tc39/proposal-object-rest-spread\">제안</a>되었고 이게 받아들여졌기 때문이다. 그럼 이건 어떤 내부 동작을 가지고 있는 걸까?</p>\n<p>그전에 이 제안이 어떤 건지 한번 알아보자. 객체를 스프레드하는 건 뭘까? 프로포절 문서에 들어가 보았다.</p>\n<h2>4.1. 기본</h2>\n<h3>4.1.1. 나머지 문법</h3>\n<p>나머지 프로퍼티 문법은 구조 분해 할당에서 아직 할당되지 않은 프로퍼티들 중 enumerable 속성을 갖는 프로퍼티들을 모아 준다. key, value들은 copy된다.</p>\n<pre><code class=\"language-js\">let temp = {\n    x: 1,\n    y: 2,\n    z: 3,\n    a: 6,\n    b: 7,\n}\n\nlet { x, y, ...rest } = temp;\nlet { ...c } = temp; //c는 temp를 copy한다\nconsole.log(x, y, rest); // 1 2 {z: 3, a: 6, b: 7}\nconsole.log(c, temp);\nconsole.log(c === temp); // c는 temp의 복사본이므로 false\n</code></pre>\n<p>단 이는 깊은 복사를 뜻하는 건 아니다. 내부 객체 등은 참조 복사된다.</p>\n<pre><code class=\"language-js\">let temp = {\n    x: 1,\n    y: 2,\n    z: 3,\n    obj: {\n        a:10, b:20,\n    }\n}\n\nlet { ...t } = temp;\nconsole.log(t === temp);\nconsole.log(t.obj === temp.obj);\n//true이다. t는 temp의 shallow copy이기 때문\n</code></pre>\n<p>또한 함수 선언시에도 사용할 수 있다. 객체가 함수 인수로 전달되면 그 객체의 프로퍼티 중 키가 함수의 인수명과 같은 인수들이 자동으로 함수에 인수로 전달된다. 그리고 <code>...</code>이 들어간 인수에는 그 외 나머지들이 모이는 것이다.</p>\n<p>아래 코드를 보면 temp가 foo 함수에 전달되었는데 temp의 x,y는 같은 이름의 인수를 foo에서 구조 분해 할당하고 있으므로 foo에 인수로 잘 전달된다. 그리고 그 외의 인수들은 rest에 객체 형태로 저장되는 것을 알 수 있다.</p>\n<pre><code class=\"language-js\">let temp = {\n    x: 1,\n    y: 2,\n    z: 3,\n    a: 12,\n    b: 17,\n}\n\nfunction foo({ x, y, ...rest }) {\n    console.log(x, y, rest);\n}\n\nfoo(temp); // 1 2 {z: 3, a: 12, b: 17}\n</code></pre>\n<p>또한 이렇게 나머지 문법으로 받은 객체에 스프레드를 사용하여 객체를 재구조화할 수도 있다. 이 말은 나머지 문법으로 만든 객체도 스프레드하여 다른 객체에 넣을 수 있다는 것이다.</p>\n<pre><code class=\"language-js\">let temp = {\n    x: 1,\n    y: 2,\n    z: 3,\n    a: 12,\n    b: 17,\n}\n\nlet { x, y, ...rest } = temp;\nlet reassembled = { x, y, ...rest };\nconsole.log(reassembled);\n</code></pre>\n<p>주의할 점도 언급하는데 나머지 문법으로 쓰일 때도 프로토타입 체이닝을 사용하기 때문에 다음 2가지는 같지 않다고 한다.</p>\n<pre><code class=\"language-js\">let { x, y, ...z } = a;\n// is not equivalent to\nlet { x, ...n } = a;\nlet { y, ...z } = n;\n// because x and y use the prototype chain\n</code></pre>\n<h3>4.1.2. 스프레드 문법</h3>\n<p>객체를 얕은 복사해서 스프레드해 준다.</p>\n<pre><code class=\"language-js\">let objCopy={...obj}\n</code></pre>\n<p>이는 <code>Object.assign</code>을 이용하면 다음처럼도 할 수 있다.</p>\n<pre><code class=\"language-js\">let objCopy=Object.assign({}, a);\n</code></pre>\n<p>당연히 두 객체를 합칠 때도 쓸 수 있다.</p>\n<pre><code class=\"language-js\">let ab={...a, ...b}\n</code></pre>\n<p>그리고 스프레드하는 객체와 다른 프로퍼티를 함께 넣을 수도 있다.</p>\n<pre><code class=\"language-js\">let temp = {\n    x: 1,\n    y: 2,\n    z: 3,\n    a: 12,\n    b: 17,\n}\n\nlet objWithDefaults = { x: 10, y: 20, k: 5, ...temp };\nconsole.log(objWithDefaults);\n</code></pre>\n<h2>4.2. 작동 방식</h2>\n<p>그럼 이렇게 객체를 스프레드할 때는 어떤 방식이 사용되는가? 이터러블이 아닌 객체에 대해서는 위처럼 <code>Symbol.iterator</code>를 사용할 수 없다.</p>\n<p>여기에는 ECMAScript에서 정의하는 추상 연산인 <a href=\"https://tc39.es/ecma262/#sec-copydataproperties\">CopyDataProperties</a>가 사용된다. 이 연산의 형태는 다음과 같다.</p>\n<pre><code class=\"language-js\">CopyDataProperties(target, source, excludedItems)\n</code></pre>\n<p>source를 target에 복사하는데 이때 excludedItems는 제외하고 복사하는 것이다. 세부 동작도 좀 살펴보자.</p>\n<h3>4.2.1. CopyDataProperties</h3>\n<p>이 함수의 동작은 다음과 같다.</p>\n<p>먼저 source가 null이나 undefined이면 함수를 끝내고 target을 그대로 리턴한다.</p>\n<p>그리고 <code>ToObject(arg)</code>를 통해 source를 객체로 변환하는데 이 동작은 다음과 같다.</p>\n<ol>\n<li>\n<p>arg가 null, undefined이면 TypeError. 그러나 여기서는 source가 null/undefined인 경우를 미리 걸렀으므로 상관없다.</p>\n</li>\n<li>\n<p>arg가 불린, 숫자, 문자열, 심볼, BigInt이면 해당하는 자료형의 객체를 만들고 내부 슬롯을 arg로 세팅한다. 예를 들어 arg가 Number형이면 Number 객체를 생성하고 그 객체의 내부 <code>[[NumberData]]</code>슬롯을 arg로 설정한 후 리턴한다.</p>\n</li>\n<li>\n<p>arg가 객체면 그대로 리턴한다.</p>\n</li>\n</ol>\n<p>이렇게 ToObject(source)가 리턴한 객체에서 enumerable한 요소들을 모두 target에 쓴다. 그러면 target은 source의 enumerable 요소들을 모두 얕은 복사한 새로운 객체가 되는 것이다.</p>\n<h3>4.2.2. 작동 예시</h3>\n<p>요약하면 객체 스프레드는 다음과 같이 진행된다. 먼저 스프레드 대상은 객체로 변환된다. 그렇게 변환된 객체 중 enumerable한 요소들이 얕은 복사가 되어 스프레드 자리에 들어간다. 당연히 일반적인 객체에는 잘 작동할 것이다.</p>\n<pre><code class=\"language-js\">let temp = {\n    x: 1,\n    y: 2,\n    z: 3,\n    a: 12,\n    b: 17,\n}\n\nlet obj = { ...temp };\nconsole.log(obj);\n</code></pre>\n<p>하지만 위의 동작을 자세히 보면, ToObject에 들어갈 수 있는 어떤 형이든 다 스프레드 대상이 될 수 있다. 만약 null이나 undefined가 스프레드된다면 스프레드의 동작 중 <code>CopyDataProperties</code>가 스스로의 source가 null/undefined인 걸 감지하고 그대로 끝나버릴 것이므로 아무 일도 일어나지 않을 것이다.</p>\n<pre><code class=\"language-js\">let obj = { ...null, ...undefined };\nconsole.log(obj); // 빈 객체\n</code></pre>\n<p>그리고 숫자, 불린, 심볼형의 래퍼 객체는 아무런 프로퍼티를 갖지 않으므로 이것들을 스프레드해도 아무 일도 없을 것이다.</p>\n<pre><code class=\"language-js\">let obj = { ...1, ...true, ...Symbol() };\nconsole.log(obj); // 빈 객체\n</code></pre>\n<p>하지만 문자열의 래퍼 객체는 length와 인덱스-문자를 키-값으로 하는 쌍을 프로퍼티로 가지며 그중 인덱스-문자 쌍은 enumerable이다. 따라서 스프레드를 사용하면 문자열의 인덱스-문자 쌍을 갖는 객체를 만들 수 있다.</p>\n<pre><code class=\"language-js\">let obj = { ...\"witch\" };\nconsole.log(obj); // {0: 'w', 1: 'i', 2: 't', 3: 'c', 4: 'h'}\n</code></pre>\n<p>객체의 특정 프로퍼티의 enumerable 플래그를 조작하면 이 객체의 스프레드에 포함되지 않도록 할 수도 있다.</p>\n<pre><code class=\"language-js\">let obj1 = {\n    x: 1,\n    y: 2,\n}\n\nlet obj2 = Object.defineProperties({}, {\n    name: {\n        value: \"김성현\",\n        enumerable: true,\n    },\n    blog: {\n        value: \"witch.work\",\n        enumerable: false,\n    },\n    age: {\n        value: 26,\n        enumerable: true,\n    }\n});\n\n// {x: 1, y: 2}\nconsole.log({ ...obj1 });\n// {name: '김성현', age: 26}\n// enumerable이 아닌 항목은 빠진 것을 확인할 수 있다\nconsole.log({ ...obj2 });\n</code></pre>\n<h1>5. 결론</h1>\n<p>이터러블에 쓰이는 <code>...</code>은 이터레이터 프로토콜 즉 <code>Symbol.iterator</code>를 호출하여 이터러블의 요소들을 하나씩 복사한다.</p>\n<p>객체의 <code>...</code>은 추상 연산 <code>CopyDataProperties</code>에 의존하여 객체의 요소들 중 enumerable한 것들을 얕은 복사하는 방식이다.</p>\n<h1>참고</h1>\n<p>객체 스프레드의 프로포절 <a href=\"https://github.com/tc39/proposal-object-rest-spread\">https://github.com/tc39/proposal-object-rest-spread</a></p>\n<p>스프레드는 연산자가 아니다 <a href=\"https://stackoverflow.com/questions/44934828/is-it-spread-syntax-or-the-spread-operator/44934830#44934830\">https://stackoverflow.com/questions/44934828/is-it-spread-syntax-or-the-spread-operator/44934830#44934830</a></p>\n<p>객체의 작동 방식을 잘 설명한 스택오버플로우 질답 <a href=\"https://stackoverflow.com/questions/64603492/i-dont-understand-about-spread-syntax-inside-objects\">https://stackoverflow.com/questions/64603492/i-dont-understand-about-spread-syntax-inside-objects</a></p>\n<p>spread의 기본적 이해 <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Spread_syntax\">https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Spread_syntax</a></p>\n<p>프로퍼티 플래그에 대해 <a href=\"https://ko.javascript.info/property-descriptors\">https://ko.javascript.info/property-descriptors</a></p>\n<p><code>...</code>사용에 대한 구분 <a href=\"https://stackoverflow.com/questions/37151966/what-is-spreadelement-in-ecmascript-documentation-is-it-the-same-as-spread-synt/37152508#37152508\">https://stackoverflow.com/questions/37151966/what-is-spreadelement-in-ecmascript-documentation-is-it-the-same-as-spread-synt/37152508#37152508</a></p>",
    "excerpt": "1. 스프레드 구문\n스프레드라고 불리는 ...구문은 배열, 문자열과 같이 반복 가능한 객체에 쓸 수 있다. 0개 이상의 인수가 기대되는 함수 호출이나 배열 리터럴의 내부에 쓰여서 반복 가능한 객체를 확장해 준다.\n예를 들어 스프레드 구문을 이용해 배열 원소들을 전부 함수 인수로 전달할 수 있다.\nconst numbers = [1, 3, -8, 37, 5, -324, 623];\n\nconsole.log(Math.max(...numbers)); //623\n\n또한 객체",
    "headingTree": [
      {
        "title": "1. 스프레드 구문",
        "url": "#1-스프레드-구문",
        "items": []
      },
      {
        "title": "2. 스프레드 연산자?",
        "url": "#2-스프레드-연산자",
        "items": [
          {
            "title": "2.1. 연산자의 조건 불만족",
            "url": "#21-연산자의-조건-불만족",
            "items": []
          },
          {
            "title": "2.2. 표준에서",
            "url": "#22-표준에서",
            "items": []
          },
          {
            "title": "2.3. 맥락에 따라 달라지는 작동방식",
            "url": "#23-맥락에-따라-달라지는-작동방식",
            "items": []
          },
          {
            "title": "2.4. 그럼 왜 스프레드 연산자라는 말이 쓰이는가?",
            "url": "#24-그럼-왜-스프레드-연산자라는-말이-쓰이는가",
            "items": []
          }
        ]
      },
      {
        "title": "3. 배열에서의 작동 방식",
        "url": "#3-배열에서의-작동-방식",
        "items": []
      },
      {
        "title": "4. 객체 스프레드",
        "url": "#4-객체-스프레드",
        "items": [
          {
            "title": "4.1. 기본",
            "url": "#41-기본",
            "items": [
              {
                "title": "4.1.1. 나머지 문법",
                "url": "#411-나머지-문법",
                "items": []
              },
              {
                "title": "4.1.2. 스프레드 문법",
                "url": "#412-스프레드-문법",
                "items": []
              }
            ]
          },
          {
            "title": "4.2. 작동 방식",
            "url": "#42-작동-방식",
            "items": [
              {
                "title": "4.2.1. CopyDataProperties",
                "url": "#421-copydataproperties",
                "items": []
              },
              {
                "title": "4.2.2. 작동 예시",
                "url": "#422-작동-예시",
                "items": []
              }
            ]
          }
        ]
      },
      {
        "title": "5. 결론",
        "url": "#5-결론",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 2,
      "wordCount": 500
    },
    "url": "/posts/javascript-spread-object",
    "thumbnail": {
      "local": "/static/iterator_exec-bd5d7ee2.PNG",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-iterator_exec-bd5d7ee2-PNG",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAIAAAA8r+mnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAWUlEQVR4nGMICwsPCg6+f//BPTB49+6dj7c3Ozsnw/z5C7dt2XLp4sV3YPD//38PDw8GJiYGT08vG0vLfbt3P370CCIB1XH+/IX/////+v0LrsPH25uXhxcAnzs8h/dlU6kAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "javascript-trip-of-js-value-1",
    "title": "JS 탐구생활 - 값은 어디서 왔고 무엇이며 어디로 가는가 시리즈",
    "date": "2024-03-01T00:00:00Z",
    "description": "JS의 값은 어디서 왔고 무엇이며 어디로 가는가",
    "tags": [
      "javascript",
      "jsvalue"
    ],
    "html": "<p>어느 날 <a href=\"https://twitter.com/finalchildmc/status/1751818395669106722\">파차님의 트윗</a>을 보았다. 파차님이 트위터에서 Javascript 엔진이 어떻게 값을 저장하는지에 대해서 설명하셨고 여기에 영감을 받아 추가적인 조사를 통해 이 시리즈를 작성한다.</p>\n<p><img src=\"/static/image-503a1906.png\" alt=\"시리즈 이미지\"></p>\n<h1>개요</h1>\n<p>Javascript의 모든 값은 저장되고 다루어지다가 언젠가 쓰이지 않게 되어 가비지 컬렉션된다. 그럼 이 과정은 어떻게 이루어질까? 이에 대한 답은 물론 간단하게 답할 수도 있겠지만 구체적으로는 그렇게 간단하지 않다.</p>\n<p>앞서 언급한 Javascript의 값이 거치는 과정은 3가지로 나눌 수 있을 것이다.</p>\n<ol>\n<li>값이 저장된다</li>\n<li>값이 사용된다</li>\n<li>값이 가비지 컬렉션된다</li>\n</ol>\n<p>따라서 이 각각에 대해서 다루는 글들을 써 볼 예정이다. Javascript에서 내부적으로 값이 어떻게 저장되고 사용되고 청소되는지 그리고 각 엔진들에서 이를 어떻게 구현했는지에 대해 가능한 한 많이 조사하여 다룰 것이다.</p>\n<p>이 시리즈에서 다룰 모든 주제에 대해서, 각 엔진들은 자신만의 특수한 기법들을 많이 사용한다. 하지만 그것을 모두 깊이 파기에는 시간도 지식도 부족하기 때문에 각 글은 대부분 거의 모든 엔진에 적용되는 전반적인 부분을 다룬 후 V8과 SpiderMonkey(주요 2개 엔진)에 대해서만 다룰 것이다. 이제 Edge 브라우저에서도 V8을 사용하게 되었기 때문에 사실상 대부분의 경우에 대해 다룰 수 있을 것이다.</p>\n<h1>값의 저장</h1>\n<p>값이 저장되는 것에 대한 이야기는 지금까지의 조사를 토대로 3가지 정도로 나누어 볼 수 있다.</p>\n<p>먼저 값은 '어디에' 저장되는가? 우리는 프로그램이 사용하는 메모리가 대표적으로 스택과 힙으로 나뉜다는 사실을 알고 있다. 물론 V8등의 엔진에서는 가비지 컬렉션을 위해서 값을 여러 공간에 나누어서 저장한다. 하지만 그것은 엔진에 특화된 이야기이고 기본적으로는 스택과 힙으로 나뉜다. 따라서 우리는 JS의 값이 어디에 저장되는지에 대해 다룰 것이다.</p>\n<p>그 다음 값은 '어떤 형식으로' 저장되는가? 에 관해 다룬다. 아무래도 값이든 포인터 주소든 비트 형식으로 메모리에 저장되겠지만 그래도 더 적은 메모리를 사용하고 더 빨리 불러올 수 있는 형식으로 저장하기 위해 쓰이는 기법들이 있다. tagged pointer, NaN boxing 등의 메모리 기법에 대한 이야기가 될 것이다. 그리고 각 엔진에서 적용하는 몇몇 최적화에 대해서도.</p>\n<p>그런데 문자열이나 객체 등, 포인터를 통해서 저장되는 값들도 있다. 그럼 그 포인터를 따라가면 어떤 식으로 값이 저장되어 있을까? 즉 값이 저장되어 있다고 하는 포인터를 따라가면 실제 값은 어떤 형식일까?</p>\n<ul>\n<li>값은 어디에 저장되는가? 스택 vs 힙</li>\n</ul>\n<p><a href=\"https://witch.work/posts/javascript-trip-of-js-value-where-value-stored\">JS 탐구생활 - JS의 값은 스택과 힙 중 어디에 저장되는가?</a></p>\n<ul>\n<li>값은 어떤 형식으로 저장되는가? tagged pointer, NaN boxing</li>\n</ul>\n<p><a href=\"https://witch.work/posts/javascript-trip-of-js-value-tagged-pointer-nan-boxing\">JS 탐구생활 - JS 엔진이 값을 저장하는 방법, tagged pointer와 NaN boxing</a></p>\n<ul>\n<li>포인터로 저장된 값은 어떤 형식인가? 히든 클래스</li>\n</ul>\n<h1>값의 사용</h1>\n<p>값이 사용되는 과정에 대해서는 저장된 값을 꺼내 씀에 있어서 캐싱 등 어떤 최적화가 이루어지는지에 집중하여 다룰 것이다.</p>\n<p>작성 중...</p>\n<ul>\n<li>인라인 캐싱</li>\n</ul>",
    "excerpt": "어느 날 파차님의 트윗을 보았다. 파차님이 트위터에서 Javascript 엔진이 어떻게 값을 저장하는지에 대해서 설명하셨고 여기에 영감을 받아 추가적인 조사를 통해 이 시리즈를 작성한다.\n\n개요\nJavascript의 모든 값은 저장되고 다루어지다가 언젠가 쓰이지 않게 되어 가비지 컬렉션된다. 그럼 이 과정은 어떻게 이루어질까? 이에 대한 답은 물론 간단하게 답할 수도 있겠지만 구체적으로는 그렇게 간단하지 않다.\n앞서 언급한 Javascript의 값이 거치는 과정",
    "headingTree": [
      {
        "title": "개요",
        "url": "#개요",
        "items": []
      },
      {
        "title": "값의 저장",
        "url": "#값의-저장",
        "items": []
      },
      {
        "title": "값의 사용",
        "url": "#값의-사용",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 27
    },
    "url": "/posts/javascript-trip-of-js-value-1",
    "thumbnail": {
      "local": "/static/image-503a1906.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-image-503a1906-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAeklEQVR4nGP4DwYfP3789u3bDzCAiDCART/duX09MyWwoqLizp07Hz9+hEq8evXq0aMHooKshoYGd+7cefXqFUTi3/ETZ/OK23KKWmOSypIyas6euwjV8fjx4zt37qakZsTFJ125eg2u4/+PHz/AcncePXr08uULiP0AyyB1X2c2gf0AAAAASUVORK5CYII="
    }
  },
  {
    "slug": "javascript-trip-of-js-value-tagged-pointer-nan-boxing",
    "title": "JS 탐구생활 - JS 엔진이 값을 저장하는 방법, tagged pointer와 NaN boxing",
    "date": "2024-03-14T00:00:00Z",
    "description": "Javascript 엔진은 어떻게 값을 최대한 적은 메모리에 구겨넣는가",
    "tags": [
      "javascript",
      "jsvalue"
    ],
    "html": "<p><img src=\"/static/thumbnail-8c978598.png\" alt=\"썸네일\"></p>\n<h1>시리즈</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>제목</th><th>링크</th></tr></thead><tbody><tr><td>JS의 값은 스택과 힙 중 어디에 저장되는가?</td><td><a href=\"https://witch.work/posts/javascript-trip-of-js-value-where-value-stored\">https://witch.work/posts/javascript-trip-of-js-value-where-value-stored</a></td></tr><tr><td>JS 엔진이 값을 저장하는 방법, tagged pointer와 NaN boxing</td><td><a href=\"https://witch.work/posts/javascript-trip-of-js-value-tagged-pointer-nan-boxing\">https://witch.work/posts/javascript-trip-of-js-value-tagged-pointer-nan-boxing</a></td></tr></tbody></table>\n<p>이 글은 Javascript 엔진에서 참조와 값들을 저장할 때 사용하는 테크닉에 대해 조사한 글 중 첫번째 글이다.</p>\n<h1>1. 의문</h1>\n<h2>1.1. Javascript 엔진은 어떻게 값을 저장하는가</h2>\n<p>앞선 글인 <a href=\"https://witch.work/posts/javascript-trip-of-js-value-where-value-stored\">JS 탐구생활 - JS의 값은 스택과 힙 중 어디에 저장되는가?</a>에서 Javascript의 값은 기본적으로 힙에 저장되며 그 값을 가리키는 참조도 대부분 힙에 저장된다는 것을 보았다. 예외들도 있지만 따로 다룰 만큼 중요한 것은 아니기에 해당 내용에 대해서는 그 내용을 다룬 글을 참고할 수 있다.</p>\n<p>그럼 정수는 대부분의 엔진 구현에서 값 그대로 메모리 상에 저장된다는 걸 감안하면 Javascript 엔진의 메모리 상에는 이런 식으로 값들이 저장되어 있을 거라 생각할 수 있다.</p>\n<p><img src=\"/static/engine-memory-af3da161.png\" alt=\"대략 엔진의 메모리\"></p>\n<p>이 이미지 상에서 아래쪽에 그려진 객체, 문자열 등의 실제 값은 힙에 동적 할당을 통해서 저장할 것이다. 엔진 구현에서도 여러 가지 최적화(이후 글에서 다룰 예정이다)를 거치기는 하지만 <code>new</code>를 통해서 생성한 클래스 인스턴스를 통해서 이런 값들을 관리한다.</p>\n<p>그런데 위쪽에 그려진 값들, 그러니까 정수값이나 참조 등은 Javascript 엔진 구현에서 어떻게 저장될까?</p>\n<h2>1.2. 동적 타입의 문제</h2>\n<p>Javascript가 C/C++과 같이 정적 타입을 제공하는 언어였다면 이는 바보같은 질문일 수 있다. 당연히 정수는 <code>int</code>로, 참조는 참조하는 객체 타입에 따라 <code>char*</code> 혹은 클래스 인스턴스의 포인터로 저장할 수 있고 아예 <code>void*</code>로 저장할 수도 있다.</p>\n<p>문제는 Javascript가 동적 타입을 사용하는 언어라는 것이다. 변수가 <code>1</code>을 저장하다가 <code>\"Hello\"</code>를 저장하게 될 수 있고 또 <code>{a:1}</code>과 같은 객체를 저장하게 될 수도 있다. 하지만 엔진 내부적으로는 이 값이 어떤 타입인지에 대한 정보를 가지고 있어야 한다. 메모리 상에 저장된 비트를 어떤 형식으로 읽어 올지를 알고 있어야 하기 때문이다.</p>\n<p>그럼 우리는 이렇게 무엇이든지 될 수 있는 Javascript의 값들을 어떻게 저장해야 할까? 값 그리고 값이 어떤 형식인지까지 가지고 있기 위해서는 어떤 방식으로 저장해야 할까? 당연하지만 메모리는 최대한 적게, 그리고 값을 읽어오는 것은 빠르게 할 수 있는 방식으로 저장해야 한다.</p>\n<h2>1.3. 글에서 다룰 것</h2>\n<p>이 글에서는 Javascript 엔진의 관점에서 어떻게 값을 효율적으로 저장하는지에 대해서 다룰 것이다. 매우 기초적인 테크닉인 discriminated union부터 시작해서 실제 엔진에서 쓰는 대표적인 2개의 테크닉인 tagged pointer, NaN boxing에 대해 다룬다.</p>\n<p>이 글에서는 그런 테크닉의 '개념'에 대해 주로 다룬다. 참조와 메모리에 그대로 저장되는 값들을 메모리에 저장하는 방식을 이론적으로 다루고 실제 엔진의 값 저장 로직 구현을 단순화한 예시를 통해 설명할 것이다.</p>\n<p>실제 엔진에서 정말로 이를 어떻게 구현하는지에 대해서는 다음 글에서 다룰 것이다. 여러 가지 최적화와 객체나 문자열 등의 실제 값이 저장되는 로직(히든 클래스 등)과 얽혀 있기 때문에 글의 분량 문제로 글을 나누었다.</p>\n<h1>2. discriminated union</h1>\n<p>이제 엔진 제작자의 관점이 되어서 이러한 Javascript 값들을 어떻게 효율적으로 저장할지 고민해 보자. 여기부터는 기본적인 C/C++ 지식이 필요하다. 그리고 지금부터는 애매한 '참조'라는 단어 대신 C/C++에서 사용하는 '포인터'를 사용할 것이다.</p>\n<p>다만 본격적인 C/C++ 글이 아니기 때문에 1바이트는 사실 꼭 8비트인 건 아니라거나 포인터 변환은 어떻게 일어나고 등등 C/C++ 표준에 있어서 엄격하게 모든 조건을 명시하지는 않았다. 일반적으로 통용되는 C/C++ 지식을 상정하고 읽으면 된다.</p>\n<p>먼저 우리가 어떤 값들을 저장해야 할지 생각해 보자. Javascript는 다음과 같은 종류의 값들을 지원한다. 이들을 지원할 수 있는 여러 가지 방법이 있다. 편의상 심볼과 BigInt는 제외하였다.</p>\n<ul>\n<li>정수(32비트)</li>\n<li>부동소수점 실수</li>\n<li>문자열</li>\n<li>객체</li>\n<li>불리언</li>\n<li>null</li>\n<li>undefined</li>\n</ul>\n<p>Javascript에서는 정수 타입과 실수 타입이 나누어져 있지 않지만 대부분의 엔진에서 이 둘을 나누어 저장하고 있기 때문에 둘을 구분하였다.</p>\n<h2>2.1. discriminated union 구현</h2>\n<p>꽤나 메모리를 적게 쓰면서도 간단한 방법은 discriminated union이다. <code>union</code>을 이용해서 여러 타입의 값을 하나의 메모리 공간에 저장하고 <code>enum</code>으로 정의된 타입 태그를 통해 해당 값을 어떤 타입으로 읽어야 하는지 결정하는 방식이다. <code>union</code>은 여러 타입 값들 간에 메모리를 공유하므로 메모리도 적게 쓸 수 있다.</p>\n<pre><code class=\"language-c\">typedef struct {\n  enum { \n    TYPE_DOUBLE,\n    TYPE_INT,\n    TYPE_STRING,\n    TYPE_OBJECT,\n    TYPE_BOOLEAN\n    TYPE_NULL,\n    TYPE_UNDEFINED\n   } typeTag;\n  union {\n    double as_double;\n    int32_t as_int;\n    char* as_string;\n    void* as_object;\n    bool as_boolean;\n  } value;\n} Value;\n</code></pre>\n<p><code>enum</code>으로 표현된 타입 태그를 통해 <code>union</code>으로 저장된 값을 어떻게 읽어 올지 정할 수 있다. 예를 들어 다음과 같이 하면 값을 문자열 형태로 읽어 올 것이다.</p>\n<pre><code class=\"language-c\">Value v;\nv.typeTag = TYPE_STRING;\nv.value.string = \"hello\";\n\nif(v.typeTag == TYPE_STRING){\n  printf(\"%s\\n\", v.value.string);\n}\n</code></pre>\n<p>Javascript가 맨 처음 만들어질 당시의 엔진이었던 Mocha가 이 방식을 사용했다. Mocha가 이후 SpiderMonkey 엔진이 되면서 이 방식은 더 이상 사용되지 않는다.</p>\n<h2>2.2. discriminated union의 문제</h2>\n<p>이렇게 할 경우 <code>enum</code>을 위해 4바이트가 쓰이고 <code>union</code>은 가장 큰 멤버의 메모리 사이즈를 따르므로 8바이트(<code>double</code>의 크기, 64비트 아키텍처에서는 포인터의 크기이기도 하다)가 쓰인다. 즉 12바이트가 필요하다.</p>\n<p><code>enum</code> 타입 태그로 나타내는 타입의 종류가 많지 않으므로 <code>enum</code> 대신 1바이트를 사용하는 <code>char</code>를 사용할 수도 있다. 하지만 이는 큰 차이를 만들지 못한다. 거의 모든 아키텍처에서 메모리 할당은 워드 단위로 이루어지고 주로 쓰이는 64비트 아키텍처에서는 워드 하나가 8바이트이기 때문이다.</p>\n<p>즉 만약 discriminated union을 사용하여 값을 표현할 때 9바이트만이 필요하더라도(1바이트 <code>char</code> 타입 태그, 8바이트 값) 8바이트 워드 단위로 메모리를 할당하는 64비트 아키텍처에서는 16바이트가 할당된다. 실제 저장해야 하는 값은 8바이트인데 타입 정보를 저장하기 위해 2배나 되는 메모리를 사용하게 된다!</p>\n<p><code>#pragma pack</code>과 같이 패딩 없이 딱 맞게 메모리를 할당하도록 하는 컴파일 옵션도 있는 경우가 있지만 이는 플랫폼에 의존적이고 프로그램 속도를 느리게 만들 수 있다.</p>\n<p>그럼 우리가 해야 할 일은 어떻게든 8바이트, 64비트 아키텍처의 워드 하나에 모든 값을 저장하는 방법을 찾는 것이다. discriminated union에서 타입 태그로 <code>char</code>를 사용한다고 했을 때 9바이트를 사용한다. 단 1바이트라도 줄이면 된다. 그런데, 여기서 어떻게 메모리를 줄일 수 있을까?</p>\n<h1>3. tagged pointer</h1>\n<h2>3.1. tagged pointer 개요</h2>\n<p>앞서 일반적으로 메모리가 할당될 때는 cpu 워드 하나, 즉 64비트 아키텍처 기준으로 8바이트씩이 할당된다는 것을 설명했다. 따라서 <code>malloc</code> 등으로 메모리 할당을 수행할 시 할당 연산은 8의 배수인 주소를 가지는 포인터를 반환한다.</p>\n<p>이는 심지어 32비트 아키텍처에서 사용되는 것을 포함한 거의 모든 메모리 할당 함수에서 그렇다. 물론 플랫폼이 그걸 보장하지 않더라도 <code>mmap</code> 등을 이용하여 그렇게 보장시킬 수 있으므로 이는 큰 문제가 되지 않는다. 또한 포인터 간의 연산도 어떤 경우에도 최소 1바이트 단위로 이루어지므로 우리가 사용하는 모든 포인터 주소 또한 8의 배수이다.</p>\n<p>따라서 우리는 동적 할당된 메모리 주소 포인터 그리고 우리가 사용하는 모든 포인터 주소가 8의 배수라고 할 수 있다. 그 말은 일반적인 포인터들의 마지막 3비트는 늘 0이라는 것이다! 그럼 어차피 사용하지 않는 이 비트들에 정보를 저장할 수 있지 않을까?</p>\n<p>포인터의 사용되지 않는 하위 3비트에 정보를 저장한 후 해당 포인터 값을 사용할 때는 하위 3비트를 다시 0으로 만들어서 사용하는 것이다. 이렇게 특정 비트에 저장된 정보(태그)와 함께 포인터를 저장하는 기법을 tagged pointer라고 한다.</p>\n<p><img src=\"/static/tagged-pointer-structure-2ec2469a.png\" alt=\"tagged pointer 대략적인 구조\"></p>\n<p>우리는 이 사용되지 않는 3비트에 총 8($2^{3}$)가지의 정보를 저장할 수 있다. 우리가 사용할 타입 종류는 8가지가 안되기 때문에 이걸로 충분하다. 특히 null, undefined, boolean 같은 값들은 정해진 값의 종류가 적어서 따로 표현해 줄 수 있기 때문에 표현해야 할 타입 종류는 더 적어진다.</p>\n<p>여기서 문제가 되는 부분이 있다. 포인터는 언제나 8의 배수로 사용된다는 사실을 이용하여 8바이트의 하위 3비트에 정보를 저장하기로 했는데 IEEE 754 규격으로 표현되는 <code>double</code>에 대해서는 이게 보장되지 않는다는 것이다.</p>\n<p>이는 단순히 <code>double</code> 타입의 실제 값은 다른 곳에 저장해 놓고 그 포인터를 저장하는 방식으로 해결할 수 있다. 포인터의 하위 3비트에 <code>double</code> 타입 태그를 저장하면 되니까 문제없다.</p>\n<pre><code class=\"language-c\">typedef union {\n  uint64_t as_uint64;\n  void* as_object_ptr;\n} Value;\n</code></pre>\n<h2>3.2. tagged pointer 구현</h2>\n<p>tagged pointer 기법을 이용하여 하위 비트에 다음과 같은 형식으로 태그를 붙여서 저장할 수 있다. 다음 이미지의 태그 값들은 실제로 초기 SpiderMonkey 엔진에서 사용했던 태그들이다.</p>\n<p><img src=\"/static/pointers-in-memory2-2027565e.png\" alt=\"메모리 상의 포인터\"></p>\n<p>null, undefined가 빠져 있다. 이들은 유일한 값이므로 <code>JSVAL_VOID</code>, <code>JSVAL_NULL</code>같은 특별한 값으로 나타낼 수 있기 때문이다. 글을 쓰면서 참고한 초기 SpiderMonkey의 코드에서는 undefined는 $-2^{30}$, null은 <code>NULL</code>을 이용해 나타냈다.</p>\n<p>그럼 다음과 같은 매크로 함수들로 타입 태그를 판별하고 포인터 값을 읽어올 수 있다. 실제 엔진에서는 boolean 타입의 <code>true</code>, <code>false</code>도 tagged pointer를 사용하여 저장하는 것이 아니라 따로 값을 만들어 저장함으로써(V8의 <code>ODDBALL</code>과 같이) 필요한 타입의 갯수를 하나 줄이곤 한다.</p>\n<pre><code class=\"language-c\">// JSVAL_IS_VOID는 undefined를 판별한다\n// 타입을 판별하는 매크로들\n#define JSVAL_IS_VOID(v) ((v)==JSVAL_VOID)\n#define JSVAL_IS_NULL(v) ((v)==JSVAL_NULL)\n#define JSVAL_IS_OBJECT(v) ((v.as_uint64 &#x26; 0x7) == 0x0)\n#define JSVAL_IS_STRING(v) ((v.as_uint64 &#x26; 0x7) == 0x4)\n#define JSVAL_IS_DOUBLE(v) ((v.as_uint64 &#x26; 0x7) == 0x2)\n#define JSVAL_IS_INT(v) ((v.as_uint64 &#x26; 0x1))\n#define JSVAL_IS_BOOLEAN(v) ((v.as_uint64 &#x26; 0x7) == 0x6)\n\n// 하위 비트를 마스킹해서 실제 값을 읽어오는 매크로들\n#define JSVAL_TO_INT(v) ((int32_t)(v.as_uint64 >> 1))\n#define JSVAL_TO_OBJECT(v) (v.as_object_ptr)\n#define JSVAL_TO_STRING(v) ((char*)(v.as_uint64 ^ 0x4))\n#define JSVAL_TO_DOUBLE(v) ((double*)(v.as_uint64 ^ 0x2))\n#define JSVAL_TO_BOOLEAN(v) ((char)(v.as_uint64 >> 3))\n\n// 포인터에 타입 태그를 붙이는 매크로들\n#define MAKE_OBJECT_PTR(p) ((uint64_t)(p))\n#define MAKE_STRING_PTR(p) ((uint64_t)(p) | 0x4)\n#define MAKE_DOUBLE_PTR(p) ((uint64_t)(p) | 0x2)\n#define MAKE_INT(i) (((uint64_t)(i) &#x3C;&#x3C; 1) | 0x1)\n\nValue foo;\nchar* some_string;\n\nfoo.as_uint64 = MAKE_STRING_PTR(some_string);\nfoo.as_uint64 = MAKE_INT(234);\n</code></pre>\n<p>이렇게 포인터 주소에 타입 정보를 저장하는 tagged pointer 기법은 매우 고전적인 방식이기도 하다. <a href=\"https://www.gnu.org/software/guile/manual/html_node/Faster-Integers.html\">2000년 이전에 쓰인 Guile 언어 매뉴얼</a>에서도 이 테크닉을 소개할 정도이다.</p>\n<p>2010년 이전까지의 SpiderMonkey 등 모든 Javascript 엔진 구현체가 처음에는 이 방식을 사용했다. Javascript V8 엔진에서는 현재도 이 방식을 사용하고 있고 SpiderMonkey 등의 다른 엔진도 tagged pointer 방식을 어느 정도 취하고 있다.</p>\n<p>예를 들어 V8 엔진 내부에서는 31비트 부호 있는 정수를 smi(Small Integer)라고 부르고 tagged pointer 기법을 이용해서 smi를 다른 객체들과 구분해 저장한다. smi는 최하위 비트가 0으로 끝나고 다른 모든 값들은 최하위 비트가 1로 끝난다. 엔진마다의 구체적인 구현은 다음 글에서 더 자세히 쓸 것이다.</p>\n<h1>4. NaN boxing 개요</h1>\n<h2>4.1. tagged pointer의 문제점</h2>\n<p>tagged pointer 방식으로 모든 값을 저장하려고 하면 작은 문제가 있다. <code>double</code>은 8바이트이므로 tagged pointer를 사용할 경우 값을 직접 저장할 수 없고 포인터를 이용해야 한다.</p>\n<p>또 tagged pointer의 기본적인 방식으로는 고작 8개의 타입만 표현할 수 있다. Javascript의 새로운 타입인 <code>Symbol</code>, <code>BigInt</code> 그리고 Weak Reference와 같이 내부적으로 사용되어야 하는 타입까지 생각하면 8개의 타입은 부족하다(참고로 다른 글에서 보겠지만 V8과 같이 tagged pointer를 사용하는 엔진은 HeapObject의 내부 구조에 따로 타입을 저장하는 방식으로 이를 해결한다).</p>\n<p>이런 문제를 해결할 수 있는 방법은 없을까? NaN boxing이라는 방법을 사용하면 이 문제를 어느 정도 해결할 수 있다.</p>\n<p>NaN boxing 또한 <a href=\"https://www.cs.arizona.edu/sites/default/files/TR93-27.pdf\">1993년의 한 보고서</a>에서도 언급되었을 만큼 오래된 방식이다. 그래서 역사적으로 보았을 때 NaN boxing이 tagged pointer의 이러한 문제를 해결하기 위해 나왔는지는 명확하지 않다. 그래도 NaN boxing이 tagged pointer의 몇몇 문제를 해결할 수 있는 방식이라는 것은 분명하다.</p>\n<h2>4.2. IEEE 754와 NaN</h2>\n<p>IEEE 754는 부동소수점을 표현하기 위한 표준이다. 그 중 배정밀도 <code>double</code> 형식은 64비트를 이용해서 실수를 표현한다. 1비트로 부호를, 11비트로 지수(exponent)를, 나머지 52비트로 가수(fraction / mantissa)를 표현한다.</p>\n<p>이 형식을 통해 구체적으로 어떻게 부동 소수점을 표현하는지는 이 글의 핵심이 아니기에 다루지 않는다. <a href=\"https://ko.wikipedia.org/wiki/IEEE_754\">위키백과의 IEEE 754 항목</a>등을 참고할 수 있다.</p>\n<p>중요한 건 IEEE 754 표준에서 \"NaN\"이라는 특별한 값을 정의하고 있다는 사실이다. 이 값은 <code>0/0</code>과 같이 계산에 대한 입력이 잘못되었을 때 생기는 값이다.</p>\n<p>IEEE 754 규격에서는 지수부가 모두 1로 채워지고 가수부가 모두 0은 아닐 때(즉 가수부가 <code>000...000</code>이 아닐 때) <code>NaN</code>이라고 한다. 참고로 만약 지수부가 모두 1이고 가수부가 모두 0이면 그건 무한대를 의미한다.</p>\n<p>이때 NaN에는 quiet NaN(<code>qNaN</code>)과 signaling NaN(<code>sNaN</code>)이 있다.</p>\n<ul>\n<li>quiet NaN(qNaN)</li>\n</ul>\n<p>quiet NaN은 연산 결과가 정의되지 않은 경우 발생하며 연산의 흐름을 계속 유지할 수 있도록 한다. 에러를 발생시키지 않고 연산의 흐름을 유지하면서 에러를 나중에 처리할 수 있도록 한다. 대부분의 시스템에서 잘못된 연산의 결과로서 NaN을 나타내기 위해 qNaN을 사용한다.</p>\n<p>NaN 조건을 만족하면서 가수부의 첫 비트가 1일 경우 qNaN이 된다.</p>\n<ul>\n<li>signaling NaN(sNaN)</li>\n</ul>\n<p>signaling NaN은 연산이 수행될 때 FPU(float point unit)에서 즉시 예외를 발생시키도록 한다. 이는 연산이 잘못되었음을 빠르게 알 수 있도록 한다. 일반적으로 부동 소수점 객체는 sNaN으로 초기화되며 값이 들어가지 않은 부동 소수점 객체에 연산이 가해졌을 때 에러를 발생시키기 위해 사용된다.</p>\n<p>NaN 조건을 만족하면서 가수부의 첫 비트가 0일 경우 sNaN이 된다.</p>\n<p>이때 일반적인 시스템에서는 NaN의 표현을 위해 qNaN을 사용한다(근거에 대해서는 <a href=\"https://anniecherkaev.com/the-secret-life-of-nan\">the secret life of NaN</a>을 참고할 수 있다).</p>\n<p>그런데 qNaN을 표현하기 위해서는 지수부 11비트가 모두 1이고 가수부의 첫 비트가 1이기만 하면 된다. 그럼 우리는 <code>64 - 11 - 1 = 52</code>비트를 다른 용도로 사용할 수 있다! 부호 비트를 빼더라도 51비트나 사용할 수 있다.</p>\n<p>이는 표준에서도 간접적으로 허용하는 방식이다. NaN에 포함된 정보의 전파를 위해서는 연산의 결과로 나온 NaN에 정보를 보존해야 한다고 표준에서 규정하고 있기 때문이다.</p>\n<blockquote>\n<p>To facilitate propagation of diagnostic information contained in NaNs, as much of that information as possible should be preserved in NaN results of operations.</p>\n</blockquote>\n<p>그럼 이 51비트의 여유 공간(보통 payload라고 부르므로 이후에도 payload라고 부르겠다)을 이용해서 다른 값을 저장할 수 있다! 이렇게 하는 기법을 NaN boxing이라고 한다.</p>\n<h2>4.3. NaN boxing 설계</h2>\n<p>IEEE 754 규격에서 qNaN을 표현하기 위해 사용할 수 있는 $2^{51}$ (부호 비트까지 감안하면 $2^{52}$)개의 값에서 실제 qNaN을 표현하는 데 쓰이는 값은 하나뿐이다.</p>\n<p>그러니 여기서 남는 표현들의 payload 비트들을 이용해서 값을 저장하는 방식이 NaN boxing이다. 앞서 보았던 NaN의 payload를 이용하여 값을 저장한 후 이를 다시 읽어오는 것이다.</p>\n<p>여러 가지 구현이 있겠지만 기본적으로는 값이 제대로 된 IEEE 754 규격의 값이면 그 값을 <code>double</code>로 해석하고 아니면 NaN boxing으로 저장된 값이라고 판단하여 읽어오면 된다.</p>\n<p>먼저 우리가 저장해야 할 값들은 다음과 같다. 이들을 64비트에 넣기 위한 설계를 해보자.</p>\n<ul>\n<li>부동 소수점 실수 : IEEE 754 표준에 따르면 이 값을 저장하는 데 8바이트(64비트)가 필요하다.</li>\n<li>포인터 주소 : 일반적인 64비트 아키텍처에서 포인터는 하위 48비트만 사용해서 표현된다. 심지어 일반적으로 사용자가 접근하게 되는 메모리는 모두 \"positive address\"이기 때문에 하위 47비트만 사용해서 저장할 수 있다.</li>\n<li>정수 : 부호 있는 32비트 정수를 저장해야 한다. 당연히 저장하는 데에 32비트가 필요하다.</li>\n<li>boolean(true, false), null, undefined : 이들의 값은 총 4개밖에 안되기 때문에 적당한 값으로 정의해서 매칭하면 된다.</li>\n</ul>\n<p>먼저 <code>double</code>은 IEEE 754 표준에 따라 그대로 저장하면 된다. 나머지 종류 값들은 NaN의 payload에 저장한다. payload는 50비트가 넘는데 저장해야 할 값(<code>double</code> 제외)은 최대 47비트(포인터 주소값)이므로 충분하다.</p>\n<p>그런데 payload에 저장될 값의 타입이 매우 다양하기 때문에 이를 구분하기 위한 태그가 필요하다. 이 태그는 payload의 상위 비트에 저장된다.</p>\n<p>payload에 저장할 값들은 최대 47비트인 것 그리고 quiet NaN임을 표현하기 위해 가수부(mantissa)의 최상위 1비트가 1이어야 한다는 점을 감안하면(이는 값이 <code>double</code>인지 체크할 때도 유용하다) 다음과 같이 값의 비트 구조를 설계해 볼 수 있다.</p>\n<p><img src=\"/static/nan-memory-778fd5ec.png\" alt=\"NaN boxing의 비트 구조\"></p>\n<p>이는 SpiderMonkey 엔진이 값을 저장하는 구조를 참고하여 만들었다. 예시를 위해 약간의 단순화를 했지만 이와 정말 비슷한 구조를 가진다.</p>\n<h1>5. NaN boxing 구현</h1>\n<h2>5.1. 타입 태그 정의</h2>\n<p>다음과 같은 태그들을 먼저 정의하자. payload의 상위 비트에 표기되어 payload에 저장된 값의 타입을 나타내는 것이다.</p>\n<pre><code class=\"language-c\">// 실제 SpiderMonkey 엔진에서의 정의를 빌려왔다\n// https://searchfox.org/mozilla-central/source/js/public/Value.h#162\n// magic은 에러 처리 등 내부적으로 특별한 값을 위해 사용되는 타입이라고 생각하면 된다\nenum JSValueType {\n  JSVAL_TYPE_DOUBLE = 0,\n  JSVAL_TYPE_INT32 = 1,\n  JSVAL_TYPE_BOOLEAN = 2,\n  JSVAL_TYPE_UNDEFINED = 3,\n  JSVAL_TYPE_NULL = 4,\n  JSVAL_TYPE_MAGIC = 5,\n  JSVAL_TYPE_STRING = 6,\n  JSVAL_TYPE_OBJECT = 7,\n};\n</code></pre>\n<p>그리고 다음과 같이 NaN의 상위 비트에 붙을 태그 비트열을 정의한다.</p>\n<pre><code class=\"language-c\">enum JSValueTag {\n  JSVAL_TAG_CLEAR = 0x1FFF0,\n  JSVAL_TAG_INT32 = JSVAL_TAG_CLEAR | JSVAL_TYPE_INT32,\n  JSVAL_TAG_BOOLEAN = JSVAL_TAG_CLEAR | JSVAL_TYPE_BOOLEAN,\n  JSVAL_TAG_UNDEFINED = JSVAL_TAG_CLEAR | JSVAL_TYPE_UNDEFINED,\n  JSVAL_TAG_NULL = JSVAL_TAG_CLEAR | JSVAL_TYPE_NULL,\n  JSVAL_TAG_MAGIC = JSVAL_TAG_CLEAR | JSVAL_TYPE_MAGIC,\n  JSVAL_TAG_STRING = JSVAL_TAG_CLEAR | JSVAL_TYPE_STRING,\n  JSVAL_TAG_OBJECT = JSVAL_TAG_CLEAR | JSVAL_TYPE_OBJECT,\n}\n</code></pre>\n<p><code>JSVAL_TAG_CLEAR</code>의 값인 <code>0x1FFF0</code>은 갑자기 튀어나온 것 같다. 하지만 이는 NaN boxing으로 값을 집어넣기 위해 비워 놓은 것이다. tag와 payload를 이용해서 값을 만드는 이 함수를 보면 이해할 수 있다.</p>\n<pre><code class=\"language-c\">#define JSVAL_TAG_SHIFT 47\n\nuint64_t bitsFromTagAndPayload(JSValueType tag, uint64_t payload){\n  return (uint64_t(tag) &#x3C;&#x3C; JSVAL_TAG_SHIFT) | payload;\n}\n</code></pre>\n<p><code>tag</code>를 47비트 왼쪽으로 shift해서 payload와 합치는 로직이다. 그런데 이때 <code>JSVAL_TAG_CLEAR</code>의 값인 <code>0x1FFF0</code>를 47비트만큼 왼쪽으로 shift하면 부호비트와 지수부의 11비트가 모두 1로 채워지고 가수부의 첫 비트까지 1이 된다.</p>\n<p>이는 하드웨어의 sign bit 기본값에 따라 다르지만 일반적으로 딱 quiet NaN의 값이다. 그러니 여기에 <code>JSVAL_TAG_*</code>와 payload를 합치면 NaN boxing으로 값을 저장할 수 있는 것이다.</p>\n<h2>5.2. 값 저장 함수</h2>\n<p>이제 이를 기반으로 값을 저장하는 클래스를 만들 수 있다. 이제부터는 union도 필요 없고 그냥 uint64_t로 값을 저장하면 된다. 어차피 형변환을 통해서 값을 읽어올 것이므로 비트만이 중요하기 때문이다.</p>\n<p>생성자에서는 기본적으로 undefined로 값을 초기화하고, 생성자에 비트열을 제공할 시 다른 값을 저장할 수 있게 한다.</p>\n<pre><code class=\"language-cpp\">class Value {\n  private:\n  uint64_t valueAsBits;\n\n  public:\n  Value(): valueAsBits(bitsFromTagAndPayload(JSVAL_TAG_UNDEFINED, 0)) {}\n  Value(uint64_t bits): valueAsBits(bits) {}\n}\n</code></pre>\n<h2>5.3. double의 저장과 판정</h2>\n<p><code>double</code> 타입 부동 소수점은 IEEE 754 표준에 따라 저장하면 된다. 그런데 이 정보를 <code>uint64_t</code>에 어떻게 저장할 수 있을까? 포인터 형변환을 이용해서 다음과 같이 할 수 있다.</p>\n<pre><code class=\"language-cpp\">class Value {\n  static uint64_t bitsFromDouble(double d){\n    return *(uint64_t*)(&#x26;d);\n  }\n}\n</code></pre>\n<p>포인터 형변환에 대해서는 <a href=\"https://panty.run/pointertype/\">예전에 다른 사이트에서 내가 썼던 '포인터의 형변환' 글을 참고할 수 있다.</a> 참고로 실제 Javascript 엔진들은 C++이기 때문에 <code>reinterpret_cast</code>등 C++에서 지원하는 형변환 문법을 사용하지만 포인터 형변환 쪽이 더 원리를 잘 드러낸다 생각해서 이렇게 썼다.</p>\n<p>그럼 다음과 같은 static 메서드들을 통해 <code>double</code>을 값으로 갖는 <code>Value</code>를 만들 수도 있다.</p>\n<pre><code class=\"language-cpp\">class Value {\n  static Value fromRawBits(uint64_t bits){\n    return Value(bits);\n  }\n\n  static Value fromDouble(double d){\n    return Value(bitsFromDouble(d));\n  }\n}\n</code></pre>\n<p>그럼 저장된 값이 <code>double</code>인지는 어떻게 판단할까? 물론 <code>JSVAL_TAG_DOUBLE</code>를 이용해서 판단할 수 있지만 더 쉬운 방식도 있다. IEEE 754에서는 exponent bit 들이 모두 1인 경우를 무한대 혹은 NaN 즉 정상적인 <code>double</code>이 아닌 값으로 판단하는 걸 이용하는 것이다.</p>\n<p>이 값은 <code>uint64_t</code>로 생각했을 때 당연히 상한이 있고 그건 부호 비트까지 감안하면 <code>0xfff8000000000000</code>이다. 이 값보다 작거나 같으면 exponent가 전부 1이 아닌 것이므로 정상적인 <code>double</code> 값이라고 판단할 수 있다.</p>\n<p>즉 다음과 같은 코드로 <code>double</code>인지 판단할 수 있다(실제 엔진에서는 여러 가지 이유로 좀 더 큰 값을 사용하지만 원리는 똑같다).</p>\n<pre><code class=\"language-cpp\">bool ValusIsDouble(uint64_t v){\n  return (v &#x3C;= 0xfff8000000000000);\n}\n\nclass Value {\n  bool isDouble(){\n    return ValusIsDouble(valueAsBits);\n  }\n}\n\n// SpiderMonkey 엔진에서는 다음과 같이 구현되어 있다.\n// https://searchfox.org/mozilla-central/source/js/public/Value.h#302\nconstexpr bool ValueIsDouble(uint64_t bits) {\n  return bits &#x3C;= JSVAL_SHIFTED_TAG_MAX_DOUBLE;\n}\n</code></pre>\n<h2>5.4. 다른 값들의 저장과 타입 판단</h2>\n<p><code>double</code>을 제외하면 이 값들을 앞서 보았던 NaN에서 남는 51비트의 payload에 저장하면 된다. 여기에서 payload에 저장된 값의 태그를 나타내는 비트는 앞서 정의하였다. 태그와 payload를 이용해서 값을 만드는 <code>bitsFromTagAndPayload</code>도 보았다.</p>\n<pre><code class=\"language-c\">uint64_t bitsFromTagAndPayload(JSValueType tag, uint64_t payload){\n  return (uint64_t(tag) &#x3C;&#x3C; JSVAL_TAG_SHIFT) | payload;\n}\n</code></pre>\n<p>그럼 앞서 정의한 태그를 이용하여 <code>Value</code> 클래스에 <code>double</code>을 제외한 다른 타입 값들을 저장하는 메서드를 만들 수 있다.</p>\n<pre><code class=\"language-cpp\">class Value {\n  // ...생략\n\n  void setInt32(int32_t i){\n    valueAsBits = bitsFromTagAndPayload(JSVAL_TYPE_INT32, uint32_t(i));\n  }\n\n  void setBoolean(bool b){\n    valueAsBits = bitsFromTagAndPayload(JSVAL_TYPE_BOOLEAN, uint32_t(b));\n  }\n\n  void setUndefined(){\n    valueAsBits = bitsFromTagAndPayload(JSVAL_TYPE_UNDEFINED, 0);\n  }\n\n  void setNull(){\n    valueAsBits = bitsFromTagAndPayload(JSVAL_TYPE_NULL, 0);\n  }\n\n  void setString(char* str){\n    valueAsBits = bitsFromTagAndPayload(JSVAL_TYPE_STRING, uint64_t(str));\n  }\n\n  void setObject(void* obj){\n    valueAsBits = bitsFromTagAndPayload(JSVAL_TYPE_OBJECT, uint64_t(obj));\n  }\n}\n</code></pre>\n<p>타입 판정도 쉽다. 값을 오른쪽 shift해서 payload를 없앤 후 <code>JSValueTag</code>와 비교하여 tag를 판정하면 된다.</p>\n<pre><code class=\"language-cpp\">class Value {\n  // 생략...\n\n  private:\n  JSValueTag toTag(){\n    return JSValueTag(valueAsBits >> JSVAL_TAG_SHIFT);\n  }\n  \n  public:\n  bool isInt32(){ return toTag() == JSVAL_TAG_INT32; }\n  bool isBoolean(){ return toTag() == JSVAL_TAG_BOOLEAN; }\n  bool isUndefined(){ return toTag() == JSVAL_TAG_UNDEFINED; }\n  bool isNull(){ return toTag() == JSVAL_TAG_NULL; }\n  bool isString(){ return toTag() == JSVAL_TAG_STRING; }\n  bool isObject(){ return toTag() == JSVAL_TAG_OBJECT; }\n}\n</code></pre>\n<h2>5.5. 값 불러오기</h2>\n<p>이제 저장된 값에서 실제 값을 불러오는 메서드를 만들어 보자. 태그를 없앤 후 payload를 적당히 반환하면 된다.</p>\n<pre><code class=\"language-cpp\">class Value {\n  public:\n  // 32비트로 캐스팅하면 태그 비트들이 자동으로 없어진다\n  int32_t toInt32(){\n    return int32_t(valueAsBits);\n  }\n\n  // true인지 false인지는 끝 비트만 보면 알 수 있다\n  bool toBoolean(){\n    return bool(valueAsBits &#x26; 0x1);\n  }\n\n  double toDouble(){\n    return *(double*)(&#x26;valueAsBits);\n  }\n\n  char* toString(){\n    uint64_t shiftedTag = uint64_t(JSVAL_TAG_STRING) &#x3C;&#x3C; JSVAL_TAG_SHIFT;\n    return (char*)(valueAsBits ^ shiftedTag);\n  }\n\n  void* toObject(){\n    uint64_t shiftedTag = uint64_t(JSVAL_TAG_OBJECT) &#x3C;&#x3C; JSVAL_TAG_SHIFT;\n    return (void*)(valueAsBits ^ shiftedTag);\n  }\n}\n</code></pre>\n<h2>5.6. Value 클래스</h2>\n<p>지금까지 구현한 것을 종합하면 다음과 같이 NaN boxing을 이용하는 <code>Value</code> 클래스를 만들 수 있다. <code>enum</code>의 정의는 생략하였다. 이 예시를 만들며 주로 참고한 <a href=\"https://searchfox.org/mozilla-central/source/js/public/Value.h#532\">SpiderMonkey의 <code>Value</code> 클래스</a>는 더 많은 기능을 가지고 있다.</p>\n<pre><code class=\"language-cpp\">#define JSVAL_TAG_SHIFT 47\n\nclass Value {\n  private:\n  uint64_t valueAsBits;\n\n  JSValueTag toTag(){\n    return JSValueTag(valueAsBits >> JSVAL_TAG_SHIFT);\n  }\n\n  public:\n  Value(): valueAsBits(bitsFromTagAndPayload(JSVAL_TAG_UNDEFINED, 0)) {}\n  Value(uint64_t bits): valueAsBits(bits) {}\n\n  static uint64_t bitsFromDouble(double d){\n    return *(uint64_t*)(&#x26;d);\n  }\n\n  static uint64_t bitsFromTagAndPayload(JSValueType tag, uint64_t payload){\n    return (uint64_t(tag) &#x3C;&#x3C; JSVAL_TAG_SHIFT) | payload;\n  }\n\n  static Value fromRawBits(uint64_t bits){\n    return Value(bits);\n  }\n\n  static Value fromDouble(double d){\n    return Value(bitsFromDouble(d));\n  }\n\n  static bool ValusIsDouble(uint64_t bits){\n    return bits &#x3C;= 0xfff8000000000000;\n  }\n\n  void setInt32(int32_t i){\n    valueAsBits = bitsFromTagAndPayload(JSVAL_TYPE_INT32, uint32_t(i));\n  }\n\n  void setBoolean(bool b){\n    valueAsBits = bitsFromTagAndPayload(JSVAL_TYPE_BOOLEAN, uint32_t(b));\n  }\n\n  void setUndefined(){\n    valueAsBits = bitsFromTagAndPayload(JSVAL_TYPE_UNDEFINED, 0);\n  }\n\n  void setNull(){\n    valueAsBits = bitsFromTagAndPayload(JSVAL_TYPE_NULL, 0);\n  }\n\n  void setString(char* str){\n    valueAsBits = bitsFromTagAndPayload(JSVAL_TYPE_STRING, uint64_t(str));\n  }\n\n  void setObject(void* obj){\n    valueAsBits = bitsFromTagAndPayload(JSVAL_TYPE_OBJECT, uint64_t(obj));\n  }\n\n  int32_t toInt32(){\n    return int32_t(valueAsBits);\n  }\n\n  bool toBoolean(){\n    return bool(valueAsBits &#x26; 0x1);\n  }\n\n  double toDouble(){\n    return *(double*)(&#x26;valueAsBits);\n  }\n\n  char* toString(){\n    uint64_t shiftedTag = uint64_t(JSVAL_TAG_STRING) &#x3C;&#x3C; JSVAL_TAG_SHIFT;\n    return (char*)(valueAsBits ^ shiftedTag);\n  }\n\n  void* toObject(){\n    uint64_t shiftedTag = uint64_t(JSVAL_TAG_OBJECT) &#x3C;&#x3C; JSVAL_TAG_SHIFT;\n    return (void*)(valueAsBits ^ shiftedTag);\n  }\n\n  bool isInt32(){ return toTag() == JSVAL_TAG_INT32; }\n  bool isDouble(){ return ValusIsDouble(valueAsBits); }\n  bool isBoolean(){ return toTag() == JSVAL_TAG_BOOLEAN; }\n  bool isUndefined(){ return toTag() == JSVAL_TAG_UNDEFINED; }\n  bool isNull(){ return toTag() == JSVAL_TAG_NULL; }\n  bool isString(){ return toTag() == JSVAL_TAG_STRING; }\n  bool isObject(){ return toTag() == JSVAL_TAG_OBJECT; }\n}\n</code></pre>\n<h1>6. tagged pointer vs NaN boxing</h1>\n<p>지금까지 discriminated union이라는 가장 원시적인 기법에서 시작해서 tagged pointer, NaN boxing 테크닉까지 알아보고 간단한 구현을 해보았다. discriminated union의 경우 SpiderMonkey의 전신인 Mocha가 잠시 사용했을 뿐이다. 하지만 tagged pointer와 NaN boxing은 현재도 잘 사용되고 있다.</p>\n<p>크롬과 Edge 브라우저에서 사용하는 V8 엔진에서 tagged pointer를 사용한다. 파이어폭스의 SpiderMonkey와 사파리의 JavascriptCore를 비롯한 다른 엔진들에서도 그 아이디어를 일부 사용하고 있다. NaN boxing은 SpiderMonkey와 JavascriptCore에서 사용하는 방식이다.</p>\n<p>그럼 어떤 게 더 나은 방식일까? 당연하지만 각각의 장단점이 있다. 단 두 기법 자체의 전반적인 동작 속도는 비슷하다. 경우에 따라 장단점이 갈리는 것이다.</p>\n<h2>6.1. tagged pointer</h2>\n<p>먼저 tagged pointer는 앞서 언급했듯 <code>double</code>을 그대로 저장할 수 없다. HeapObject라는 별도의 객체로 감싸서 저장해야 한다. 이는 tagged pointer 방식을 사용할 시 <code>double</code> 타입 값에 접근하기 위해서 포인터를 한 번 거쳐야 한다는 것을 의미한다. 이는 성능상 불리할 수 있다.</p>\n<p>반면 tagged pointer는 V8의 구현 기준으로, 부호 있는 31비트 정수 범위에서 조금 더 빠른 연산이 가능하다. tagged pointer 기법을 사용하면 시프트 연산 1번만으로 태그를 제거하고 값에 접근할 수 있기 때문이다.</p>\n<p>물론 V8의 최적화 컴파일러 Turbofan은 경우에 따라서 부동 소수점 값을 별도의 포인터 할당 없이 그대로 저장하도록 최적화해줄 수 있다. NaN boxing을 사용하는 다른 엔진들의 최적화 컴파일러들 역시 정수 연산에 대한 최적화가 가능하다. 하지만 기본적인 동작만 보았을 때 그렇다는 것이다.</p>\n<p>tagged pointer의 가장 두드러지는 장점은 메모리 소비량에 있다.</p>\n<p>NaN boxing은 대부분의 경우 8바이트를 사용해서 값을 저장해야 하고 이는 32비트 아키텍처에서도 마찬가지다. 64비트 아키텍처에서는 포인터 주소에 일반적으로 47비트만 쓰이지만 32비트 아키텍처에서는 32비트 전부를 주소로 저장해야 하기 때문에 늘 8바이트를 사용해야 한다.</p>\n<p>그러나 tagged pointer는 32비트 아키텍처에서는 4바이트만 사용해서 값을 저장할 수 있다. 또한 다음 글에서 다룰 <a href=\"https://v8.dev/blog/pointer-compression\">Pointer Compression</a> 기법을 쓰면 64비트 아키텍처에서도 4바이트만 사용해서 값을 저장할 수 있다.</p>\n<h2>6.2. NaN boxing</h2>\n<p>NaN boxing은 부동 소수점 값을 그대로 저장할 수 있다. 따라서 tagged pointer와 달리 포인터를 한 번 거치지 않고 바로 <code>double</code> 값을 가져올 수 있다. 따라서 실수 연산을 조금 더 빠르게 할 수 있다.</p>\n<p>tagged pointer에 비해서 더 많은 타입을 저장할 수 있다는 것도 장점이다. tagged pointer는 대부분의 아키텍처에서 동적 할당된 포인터 주소가 8의 배수로 align된다는 것을 이용하기 때문에 $2^3 = 8$개의 타입만 저장할 수 있다. 다른 타입은 <code>map</code> 혹은 <code>Shape</code>등으로 표현하는, 객체의 모양을 나타내는 내부 객체를 이용하여 저장한다. 따라서 특정 타입의 태그를 알아내기 위해서 별도의 참조를 거쳐야 할 수 있다.</p>\n<p>반면 NaN boxing은 5비트의 payload가 있기 때문에 여러 가지를 감안하여도 30개 이상의 타입을 저장할 수 있다. 또한 구현에 따라 다르지만 null, undefined, true, false와 같은 특별한 값들은 유효하지 않은 포인터 주소를 이용하여 따로 담아둘 수도 있다. 이는 값의 비트열을 이용해서 타입을 바로 알아낼 수 있다는 의미이기 때문에 성능상 이점이 될 수 있다.</p>\n<p>NaN boxing의 단점은 이해하기 상대적으로 복잡하다는 것(내부 구현이기 때문에 실제 사용자에게는 큰 영향이 없을 수도 있지만) 그리고 늘 8바이트를 이용하여 값을 저장하기 때문에 메모리 낭비가 클 수 있다는 것이다.</p>\n<p>또한 메모리 주소는 늘 하위 47비트를 이용하여 저장된다는 것, qNaN의 형식 등 여러 가지 가정 하에 작동한다는 것도 단점이 될 수 있다. 실제로 Solaris 같은 몇몇 운영체제에서는 값이 비트를 통해 저장되는 방식이 약간 달라서 NaN boxing을 사용하기 위해 추가적인 처리가 필요하다.</p>\n<p>하지만 두 방식 모두 IT 업계의 공룡들이 유지보수(V8은 구글과 마이크로소프트, JavascriptCore는 주로 애플, SpiderMonkey는 모질라 재단에서 유지보수하고 있다)하고 있는 엔진들에서 잘 사용하고 있는 방식이고 어떤 것에 명확한 우세가 있는 건 아니다. 두 방식 모두 장단점이 있고 실제로는 어떤 방식이 더 나은지는 사용하는 환경에 따라 다르다. 심지어 요즘은 복잡한 최적화 컴파일러들도 Javascript 코드의 실행에 깊게 관여하기 때문에 이런 기법들의 성능상 차이가 점점 작아지고 있다.</p>\n<p>그러니 각 엔진들이 값을 최대한 적은 메모리에 저장하고 빠르게 접근할 수 있도록 최적화하는 이런 테크닉들이 있으며 수많은 엔진 개발자들이 이런 기법들을 연구하고 개발하고 있다는 것을 이 글을 통해 알았다면 충분하다.</p>\n<h1>7. 남은 이야기</h1>\n<p>우리는 NaN boxing을 이용해서 값들을 저장하고 각 값의 타입을 판단할 수 있는 <code>Value</code> 클래스를 만들었다.</p>\n<p>이외에 의문이 될 만한 자잘한 이야기들을 몇 가지 간략히 소개한다. 이후에 쓰일 다른 글의 일부가 될 내용도 있다.</p>\n<h2>7.1. unsigned 타입을 쓰는 이유</h2>\n<p>지금까지 작성한 코드를 보면 <code>toInt32()</code>와 같이 정말로 부호 있는 정수가 필요한 경우가 아니면 unsigned 타입인 <code>uint32_t</code>, <code>uint64_t</code>를 사용한 것을 볼 수 있다. 이는 실제 엔진 코드에서도 마찬가지다. 가령 SpiderMonkey의 <code>Value</code> 클래스에서도 다음과 같은 코드를 볼 수 있다.</p>\n<pre><code class=\"language-cpp\">// https://searchfox.org/mozilla-central/source/js/public/Value.h#604\n// Value 클래스에 int32_t 값을 저장하는 메서드\nvoid setInt32(int32_t i) {\n  asBits_ = bitsFromTagAndPayload(JSVAL_TAG_INT32, uint32_t(i));\n  MOZ_ASSERT(toInt32() == i);\n}\n</code></pre>\n<p>생각해 보면 <code>uint32_t</code>와 같이 부호 없는 정수보다는 <code>int32_t</code>와 같이 부호 있는 정수 타입이 훨씬 직관적이다. 그런데 왜 이렇게 했을까? 이는 부호 있는 정수 타입을 사용했을 때 sign extension 때문에 상위 비트의 오염 문제가 생길 수 있기 때문이다. 앞선 <code>setInt32</code> 코드를 다시 보자.</p>\n<pre><code class=\"language-cpp\">void setInt32(int32_t i){\n  valueAsBits = bitsFromTagAndPayload(JSVAL_TYPE_INT32, uint32_t(i));\n}\n\n#define JSVAL_TAG_SHIFT 47\n\nuint64_t bitsFromTagAndPayload(JSValueType tag, uint64_t payload){\n  return (uint64_t(tag) &#x3C;&#x3C; JSVAL_TAG_SHIFT) | payload;\n}\n</code></pre>\n<p>여기서 만약 <code>bitsFromTagAndPayload</code>에 <code>int32_t</code> 타입의 <code>i</code>를 그대로 넘긴다고 하자. 다음과 같이 말이다. 그리고 인자로 <code>-1</code>을 넘겼다고 하자.</p>\n<pre><code class=\"language-cpp\">void setInt32(int32_t i){\n  valueAsBits = bitsFromTagAndPayload(JSVAL_TYPE_INT32, i);\n}\n\nValue v;\nv.setInt32(-1);\n</code></pre>\n<p>그러면 <code>v.valueAsBits</code>는 이런 값이 될 것이다.</p>\n<pre><code class=\"language-cpp\">bitsFromTagAndPayload(JSVAL_TYPE_INT32, -1);\n</code></pre>\n<p>이때 <code>int32_t</code> 타입의 <code>-1</code>은 payload 인수 타입인 <code>uint64_t</code>로 암묵적으로 형변환된다. 그리고 부호 있는 정수 타입이 더 크기가 큰 타입으로 형변환될 때는 sign extension이 일어난다. 즉 부호 비트가 1이면 상위 비트가 1로 채워지고 0이면 0으로 채워진다. <code>-1</code>은 음수이므로 부호 비트가 1이고 따라서 <code>uint64_t</code>로 형변환시 <code>0xffffffffffffffff</code>가 된다.</p>\n<p>이렇게 되면 <code>bitsFromTagAndPayload</code>의 로직을 생각해 볼 때 <code>bitsFromTagAndPayload</code>는 무조건 <code>JSVAL_TAG_INT32</code>와 <code>0xffffffffffffffff</code>를 반환하게 된다. 이는 당연히 우리가 원하는 값이 아니다.</p>\n<p>이런 상황을 방지하기 위해서는 위에서 우리가 한 것처럼 정수를 다룰 때 <code>uint32_t</code>로 형변환을 해야 한다. 부호 없는 정수형의 경우 sign extension이 아니라 zero extension, 그러니까 상위 비트가 모두 0으로 채워지는 방식으로 형변환이 일어나기 때문에 이런 문제가 생기지 않는다.</p>\n<h2>7.2. NaN boxing의 다른 구현</h2>\n<p>앞선 부분에서 SpiderMonkey 엔진이 NaN boxing을 구현한 방식이 마음에 들지 않을 수 있다.</p>\n<p>실제로 이 방식은 다음과 같은 문제점이 있다.</p>\n<ul>\n<li>Javascript에서 double보다는 포인터 값이 쓰일 때가 훨씬 많다. 그런데 위의 구현에서 포인터 값에 접근하기 위해서는 비트 연산을 통한 마스킹이 필요하다. 프로그램에서 포인터 값이 더 많이 쓰인다면 이는 성능상 불리할 수 있다.</li>\n<li>null, undefined, boolean 값들은 매우 적은 비트를 사용해서 표현할 수 있는데 모두 64비트를 통해서 표현되며 4비트의 tag로만 구분되기 때문에 여러 종류의 null, undefined, true, false 값이 존재할 수 있다.</li>\n</ul>\n<p>JavascriptCore 엔진에서는 앞서 본 것과 다른 NaN-boxing 방식을 사용한다. 이를 이용하면 이 문제들을 조금이나마 해결할 수 있다. 다음 글에서 더 자세히 다루겠지만 간략히 설명하면 64비트 비트열이 기본적으로 <code>double</code> 대신 포인터로 해석되도록 하는 것이다.</p>\n<p>앞서 본 방식에서는 <code>double</code>을 기본으로 하고 다른 값들에 접근하기 위해서는 비트마스킹이 필요했다. 하지만 이번에는 <code>double</code>을 저장할 때 $2^{49}$ 의 offset을 사용해 저장하고 그 offset을 통해 생긴 공간에 포인터 값을 저장한다. 그리고 포인터 값은 별도의 비트 연산 없이 그대로 사용할 수 있다. 예시 코드는 다음과 같다. JavascriptCore 엔진의 코드를 예시를 위해 단순화하였다.</p>\n<pre><code class=\"language-cpp\">const size_t DoubleEncodeOffsetBit = 49;\nconst int64_t DoubleEncodeOffset = 1ll &#x3C;&#x3C; DoubleEncodeOffsetBit;\n\nclass JSValue {\n  union {\n    int64_t asInt64;\n    double asDouble;\n    // JSCell은 값에 대한 포인터들을 통칭해서 나타내는 타입이라 생각하면 된다\n    JSCell* asCellPtr;\n\n    // 32비트 int 타입의 값들을 저장하기 위한 비트 필드\n    // tag에는 int를 뜻하는 tag가 들어가고 \n    // payload에는 실제 32비트 정수 값이 들어간다\n    struct {\n      int32_t tag;\n      int32_t payload;\n    } asBits;\n  } u;\n\n  // 2^49의 offset을 더해서 저장한다\n  JSValue(double d) {\n    u.asInt64 = bitwise_cast&#x3C;int64_t>(d) + DoubleEncodeOffset;\n  }\n\n  // 포인터 주소는 그대로 저장한다. 대부분의 64비트 아키텍처에서 포인터 주소의 저장은\n  // 하위 48비트만 사용하기 때문에 offset을 통해 만들어진 범위에 그대로 저장될 수 있다\n  // Solaris 같은 몇몇 운영체제에서는 mmap등을 이용한 추가적인 처리가 필요할 수 있다\n  JSValue(JSCell* ptr) {\n    u.asCellPtr = ptr;\n  }\n\n  JSValue(int32_t i) {\n    u.asBits.tag = Int32Tag;\n    u.asBits.payload = i;\n  }\n}\n</code></pre>\n<p>또한 tagged pointer 섹션에서 본 것과 같이 동적 할당된 포인터 주소는 거의 모든 아키텍처에서 8의 배수로 align되어 있다. 그럼 8의 배수가 아닌 포인터 주소들, 이를테면 <code>0x02</code>와 같은 값들은 유효하지 않은 포인터 주소이다. 이들은 null, undefined와 같이 특별한 값들을 저장하는 데에 사용될 수 있다.</p>\n<pre><code class=\"language-cpp\">/*\n *     False:     0x06\n *     True:      0x07\n *     Undefined: 0x0a   \n *     Null:      0x02\n */\n\nconst int32_t ValueFalse = 0x06;\nconst int32_t ValueTrue = 0x07;\nconst int32_t ValueUndefined = 0x0a;\nconst int32_t ValueNull = 0x02;\n</code></pre>\n<p>JavascriptCore에서는 이 값들을 각각 <code>enum</code>을 이용해 타입으로 정의한 뒤 <code>JSValue</code> 내부 값으로 저장한다. 이 방식에 대해서는 이후 글에서 더 자세히 살펴볼 것이다. 일단 이 방식에서는 포인터 주소로 유효하지 않은 매우 작은 수들을 이용하여 null, undefined, true, false 값을 저장할 수 있다는 것만 알아두자.</p>\n<p>또한 <code>double</code> 값을 저장할 때 offset을 더해서 저장함으로써 포인터 주소를 마스킹 없이 <code>JSValue</code>로부터 가져와 사용할 수 있게 되었다.</p>\n<p>그럼 이 방식에서 <code>JSValue</code>에 저장한 포인터가 어떤 타입 객체를 참조하는지는 어떻게 알까? 그것은 임의의 객체를 나타내는 <code>JSCell</code>이라는 클래스 내부에 있는, 타입을 나타내는 별도의 필드를 이용한다. 이는 많은 개념과 얽혀 있는 긴 이야기가 될 것이기 때문에 이후 다른 글에서 다룰 것이다.</p>\n<h1>참고</h1>\n<ul>\n<li>How is data stored in V8 JS engine memory?</li>\n</ul>\n<p>V8에서 값이 어떻게 저장되는지에 대한 글이다. 주로 객체를 어떻게 저장하는지에 대한 내용이라 글의 내용과 직접적인 연관성은 적지만 전반적인 V8의 메모리 구조 이해에 도움을 준다.</p>\n<p><a href=\"https://www.dashlane.com/blog/how-is-data-stored-in-v8-js-engine-memory\">https://www.dashlane.com/blog/how-is-data-stored-in-v8-js-engine-memory</a></p>\n<ul>\n<li>NaN boxing or how to make the world dynamic</li>\n</ul>\n<p>tagged pointer와 NaN boxing에 대한 글이다. tagged pointer와 NaN boxing을 직접 구현하고 각각의 장단점을 비교하고 있다.</p>\n<p><a href=\"https://piotrduperas.com/posts/nan-boxing\">https://piotrduperas.com/posts/nan-boxing</a></p>\n<ul>\n<li>The history of “typeof null”</li>\n</ul>\n<p>댓글에 보면 Brandon Eich가 Mocha 엔진을 만들 때 discriminated union(tagged union)을 사용했다고 언급한다. 또한 초기 SpiderMonkey 엔진에서 사용한 tagged pointer 값들도 볼 수 있다.</p>\n<p><a href=\"https://2ality.com/2013/10/typeof-null.html\">https://2ality.com/2013/10/typeof-null.html</a></p>\n<ul>\n<li>IEEE 754 floating-point(부동소수점)에 대하여</li>\n</ul>\n<p>IEEE 754 표준에 대한 글이다. NaN에 대한 내용도 다루고 있다.</p>\n<p><a href=\"https://nybounce.wordpress.com/2016/06/24/ieee-754-floating-point%EB%B6%80%EB%8F%99%EC%86%8C%EC%88%98%EC%A0%90-%EC%82%B0%EC%88%A0%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC/\">https://nybounce.wordpress.com/2016/06/24/ieee-754-floating-point%EB%B6%80%EB%8F%99%EC%86%8C%EC%88%98%EC%A0%90-%EC%82%B0%EC%88%A0%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC/</a></p>\n<ul>\n<li>V8 개발자 중 하나인 Leszek Swirski이 Y Combinator에 남긴 글</li>\n</ul>\n<p>V8이 NaN boxing을 사용하지 않는 이유에 대해 간략히 설명한다. 최적화 컴파일러에서는 double을 그대로 저장하는 최적화를 한다는 언급도 있다.</p>\n<p><a href=\"https://news.ycombinator.com/item?id=16985390\">https://news.ycombinator.com/item?id=16985390</a></p>\n<ul>\n<li>the secret life of NaN</li>\n</ul>\n<p>NaN이 어떻게 값 표현에 쓰일 수 있고 표준에서는 어떻게 다루어지며 JavascriptCore에서 이를 어떻게 구현하는지 다룬 글이다.</p>\n<p><a href=\"https://anniecherkaev.com/the-secret-life-of-nan\">https://anniecherkaev.com/the-secret-life-of-nan</a></p>\n<ul>\n<li>Pointer Compression in V8</li>\n</ul>\n<p>글에서 직접적으로 다룬 내용은 아니지만 tagged pointer에 대한 간략한 설명과 V8의 포인터 메모리 압축 기법에 대한 글이다.</p>\n<p><a href=\"https://v8.dev/blog/pointer-compression\">https://v8.dev/blog/pointer-compression</a></p>\n<ul>\n<li>value representation in javascript implementations</li>\n</ul>\n<p>NaN boxing의 개념과 각 엔진의 구현을 간략히 설명한다. 참고한 많은 글에서도 레퍼런스로 사용되었다.</p>\n<p><a href=\"https://wingolog.org/archives/2011/05/18/value-representation-in-javascript-implementations\">https://wingolog.org/archives/2011/05/18/value-representation-in-javascript-implementations</a></p>\n<ul>\n<li>Representing Type Information in Dynamically Typed Languages</li>\n</ul>\n<p>1993년에 나온 보고서이다. <code>2.6.1 Using IEEE NaN Codes</code>에서 NaN boxing에 대한 설명이 있다.</p>\n<ul>\n<li>Rob Sayre, Mozilla’s New JavaScript Value Representation</li>\n</ul>\n<p>SpiderMonkey가 NaN boxing을 처음 사용하게 되었을 때의 글이다.</p>\n<p><a href=\"https://tomschuster.name/sayrer-fatval-backup/cache.aspx.htm\">https://tomschuster.name/sayrer-fatval-backup/cache.aspx.htm</a></p>\n<ul>\n<li>JavascriptCore</li>\n</ul>\n<p><a href=\"https://trac.webkit.org/wiki/JavaScriptCore\">https://trac.webkit.org/wiki/JavaScriptCore</a></p>\n<p>JavascriptCore 소스코드 1</p>\n<p><a href=\"https://trac.webkit.org/browser/trunk/Source/JavaScriptCore\">https://trac.webkit.org/browser/trunk/Source/JavaScriptCore</a></p>\n<p>JavascriptCore 소스코드 2</p>\n<p><a href=\"https://github.com/WebKit/WebKit/tree/main/Source/JavaScriptCore\">https://github.com/WebKit/WebKit/tree/main/Source/JavaScriptCore</a></p>\n<p><a href=\"https://github.com/WebKit/WebKit/blob/main/Source/JavaScriptCore/runtime/JSCJSValue.h\">https://github.com/WebKit/WebKit/blob/main/Source/JavaScriptCore/runtime/JSCJSValue.h</a></p>\n<ul>\n<li>What is the difference between quiet NaN and signaling NaN?</li>\n</ul>\n<p>quiet NaN과 signaling NaN의 차이에 대한 질문과 답변이다.</p>\n<p><a href=\"https://stackoverflow.com/questions/18118408/what-is-the-difference-between-quiet-nan-and-signaling-nan\">https://stackoverflow.com/questions/18118408/what-is-the-difference-between-quiet-nan-and-signaling-nan</a></p>\n<ul>\n<li>Dynamic Typing and NaN Boxing</li>\n</ul>\n<p>NaN boxing에 대한 글이다. NaN boxing의 구현을 다루고 있다.</p>\n<p><a href=\"https://leonardschuetz.ch/blog/nan-boxing/\">https://leonardschuetz.ch/blog/nan-boxing/</a></p>\n<ul>\n<li>Why does V8 uses pointer tagging and not NaN boxing?</li>\n</ul>\n<p>V8가 NaN boxing을 사용하지 않는 이유에 대한 질문과 V8 개발자 중 한 명의 답변이다.</p>\n<p><a href=\"https://stackoverflow.com/questions/63550957/why-does-v8-uses-pointer-tagging-and-not-nan-boxing\">https://stackoverflow.com/questions/63550957/why-does-v8-uses-pointer-tagging-and-not-nan-boxing</a></p>\n<ul>\n<li>SpiderMonkey 소스 코드와 문서</li>\n</ul>\n<p>SpiderMonkey 엔진의 공식 사이트로 SpiderMonkey의 소스 코드와 <code>[SMDOC]</code>으로 표기된 문서 주석들을 볼 수 있다.</p>\n<p><a href=\"https://spidermonkey.dev/\">https://spidermonkey.dev/</a></p>",
    "excerpt": "\n시리즈\n| 제목 | 링크 |\n|------|------|\n| JS의 값은 스택과 힙 중 어디에 저장되는가? | https://witch.work/posts/javascript-trip-of-js-value-where-value-stored |\n| JS 엔진이 값을 저장하는 방법, tagged pointer와 NaN boxing | https://witch.work/posts/javascript-trip-of-js-value-tagged-pointer-nan-b",
    "headingTree": [
      {
        "title": "시리즈",
        "url": "#시리즈",
        "items": []
      },
      {
        "title": "1. 의문",
        "url": "#1-의문",
        "items": [
          {
            "title": "1.1. Javascript 엔진은 어떻게 값을 저장하는가",
            "url": "#11-javascript-엔진은-어떻게-값을-저장하는가",
            "items": []
          },
          {
            "title": "1.2. 동적 타입의 문제",
            "url": "#12-동적-타입의-문제",
            "items": []
          },
          {
            "title": "1.3. 글에서 다룰 것",
            "url": "#13-글에서-다룰-것",
            "items": []
          }
        ]
      },
      {
        "title": "2. discriminated union",
        "url": "#2-discriminated-union",
        "items": [
          {
            "title": "2.1. discriminated union 구현",
            "url": "#21-discriminated-union-구현",
            "items": []
          },
          {
            "title": "2.2. discriminated union의 문제",
            "url": "#22-discriminated-union의-문제",
            "items": []
          }
        ]
      },
      {
        "title": "3. tagged pointer",
        "url": "#3-tagged-pointer",
        "items": [
          {
            "title": "3.1. tagged pointer 개요",
            "url": "#31-tagged-pointer-개요",
            "items": []
          },
          {
            "title": "3.2. tagged pointer 구현",
            "url": "#32-tagged-pointer-구현",
            "items": []
          }
        ]
      },
      {
        "title": "4. NaN boxing 개요",
        "url": "#4-nan-boxing-개요",
        "items": [
          {
            "title": "4.1. tagged pointer의 문제점",
            "url": "#41-tagged-pointer의-문제점",
            "items": []
          },
          {
            "title": "4.2. IEEE 754와 NaN",
            "url": "#42-ieee-754와-nan",
            "items": []
          },
          {
            "title": "4.3. NaN boxing 설계",
            "url": "#43-nan-boxing-설계",
            "items": []
          }
        ]
      },
      {
        "title": "5. NaN boxing 구현",
        "url": "#5-nan-boxing-구현",
        "items": [
          {
            "title": "5.1. 타입 태그 정의",
            "url": "#51-타입-태그-정의",
            "items": []
          },
          {
            "title": "5.2. 값 저장 함수",
            "url": "#52-값-저장-함수",
            "items": []
          },
          {
            "title": "5.3. double의 저장과 판정",
            "url": "#53-double의-저장과-판정",
            "items": []
          },
          {
            "title": "5.4. 다른 값들의 저장과 타입 판단",
            "url": "#54-다른-값들의-저장과-타입-판단",
            "items": []
          },
          {
            "title": "5.5. 값 불러오기",
            "url": "#55-값-불러오기",
            "items": []
          },
          {
            "title": "5.6. Value 클래스",
            "url": "#56-value-클래스",
            "items": []
          }
        ]
      },
      {
        "title": "6. tagged pointer vs NaN boxing",
        "url": "#6-tagged-pointer-vs-nan-boxing",
        "items": [
          {
            "title": "6.1. tagged pointer",
            "url": "#61-tagged-pointer",
            "items": []
          },
          {
            "title": "6.2. NaN boxing",
            "url": "#62-nan-boxing",
            "items": []
          }
        ]
      },
      {
        "title": "7. 남은 이야기",
        "url": "#7-남은-이야기",
        "items": [
          {
            "title": "7.1. unsigned 타입을 쓰는 이유",
            "url": "#71-unsigned-타입을-쓰는-이유",
            "items": []
          },
          {
            "title": "7.2. NaN boxing의 다른 구현",
            "url": "#72-nan-boxing의-다른-구현",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 7,
      "wordCount": 1948
    },
    "url": "/posts/javascript-trip-of-js-value-tagged-pointer-nan-boxing",
    "thumbnail": {
      "local": "/static/thumbnail-8c978598.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-thumbnail-8c978598-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAa0lEQVR4nGP4jwMwQKiPH16HB9kWFBYiS/z7////+XNn2RgYRMXErl69itDx6PHz4sru8MhYNzc3axu7x48fQyV+/Pi5aNmmjNzGjNzGeQvW/vjxE2HHjx8/r167c/HKrW/ff/z+9fv///8ACJB1c1IE1ToAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "just-give-it-a-try-ux",
    "title": "일단 해보라구요? UX를 읽으며 메모",
    "date": "2023-12-02T00:00:00Z",
    "description": "이경민, 일단 해보라구요? UX를 읽으며 메모",
    "tags": [
      "study"
    ],
    "html": "<p>우연히 도서관에서 <code>일단 해보라구요? UX</code>라는 책을 찾아서 읽게 되었다. 얇아서 금방 읽었는데 몇몇 부분을 메모로 남긴다. <a href=\"https://product.kyobobook.co.kr/detail/S000001078504\">해당 도서 판매 링크</a></p>\n<h1>감상</h1>\n<p>프론트로서 UX에 늘 어느 정도 관심을 가지고 있다. 이 글을 쓰고 있는 블로그를 만들 때도 어떻게 하면 사용자가 상호작용을 좀 덜 하면서 원하는 페이지를 찾을 수 있을까? 하는 생각을 하곤 했다.</p>\n<p>그런 과정에서 UX 관련 글들도 몇 개 읽었기 때문에 이 책에 있는 내용도 이미 들어본 내용이 좀 있었다. 하지만 이 책에서 새롭게 느낀 것들을 두 가지 꼽자면 이런 게 있겠다.</p>\n<p>첫째로 보기에 단순한 것이 다 좋은 건 아니라는 것. 가령 몇몇 기기의 경우 UI를 단순화한답시고 버튼을 한 개, 혹은 두 개만 만들어 놓은 경우를 볼 수 있는데 나에게는 이런 기기를 사용하는 게 정말 형편없는 경험이었다. 들어가야 하는 기능은 많은데 그걸 고작 한두 개 버튼에 우겨넣으려 하니 1번 버튼을 누르고 2번 버튼을 오래 누른다든지 하는 이상한 조작을 해야 하는 경우가 많았던 것이다.</p>\n<p>여기서는 보기에 단순하거나 복잡한 것이 중요한 게 아니라는 것을 확실히 한다. 그 예시로 리모컨을 드는데 물론 리모컨의 버튼은 복잡하지만 필요한 게 많기 때문에 그럴 수밖에 없고, 대신 잘 만들어진 리모컨은 그 복잡한 정보를 잘 체계화한다는 점을 강조한다.</p>\n<p>즉 보기에 단순하고 복잡한 게 문제가 아니라 필요한 정보들을 모두 넣으면서 자연스러운 체계를 갖추는 것이 중요하다는 것이다.</p>\n<p>둘째로 UX는 사용자가 느끼는 모든 순간을 고려해야 한다는 것이다. 그 예시로 저자는 애플의 언박싱 경험을 이야기한다. 언박싱은 분명 아이폰이나 맥북의 주 기능과는 전혀 상관없는 부분이지만 잘 포장된 박스를 뜯고, 처음 전원을 켜고 사용자에 대한 웰컴 메시지를 보고 초기 설정을 하는 경험은 사용자에게 브랜드에 대한 좋은 경험을 준다.</p>\n<p>이런 브랜드 이미지 외에도, 제품의 본 기능도 중요하지만 사용자가 제품을 접하고 사용하기 시작하고 또 어쩌면 사용을 멈추는 시기까지도 모두 UX의 영역이라고 강조한다. 예를 들어 스마트폰이라면 스마트폰을 집어드는 부분까지도 UX의 영역이라는 것이다.</p>\n<p>책에서 UX에 대해 새로 느낄 수 있었던 점은 이 정도고 이제 책 내용 일부를 메모한 부분을 남긴다.</p>\n<h1>메모</h1>\n<h2>21~22쪽</h2>\n<p>그 당시 내가 빠르게 배우고 실무에 적응할 수 있도록 가장 큰 도움이 된 방법은 이전에 진행했던 프로젝트들의 문서를 자세히 정독하는 것이었다. 특히 프로젝트의 일정을 정리한 문서를 꼼꼼하게 살펴보았다. 모든 프로젝트는 일정을 정리한 문서가 있게 마련이다. 이 일정에는 생각보다 많은 정보가 담겨 있다. 우선 관련된 모든 부서와 그 부서가 끝내야 하는 일들이 날짜와 함께 간략하게 정리되어 있다.</p>\n<p>이를 통해 이 프로젝트에 어떤 부서들이 관여하고 있으며 각 부서가 하는 일이 대충 무엇인지 알 수 있었다. 또한 부서별 하는 일의 소요 기간을 비교해 파악할 수 있었다. 뿐만 아니라 프로젝트 중간중간에 확인하고 넘어가야 하는 일들이 순차적으로 나열되어 있기 때문에 전체적으로 어떤 프로세스로 일이 진행되는지도 알 수 있었다.</p>\n<p>또 다른 방법은 프로젝트의 UI 시나리오를 이것저것 많이 보는 것이었다. 앞에서 말한 일정 관리 문서들을 살펴 보는 것이 자율 선행학습이었다면 시나리오를 보는 일은 마치 내일모레가 시험인데도 학습 내용을 하나도 몰라서 절망적인 심정을 부여잡고 돌입하는 벼락치기 학습 같았다. 닥치는 대로 이런저런 시나리오를 많이 보았다. 그렇게 많이 보다 보면 우선 회사에서 쓰는 시나리오의 공용 포맷을 알게 된다. 그 포맷에 따라 전체적인 구조와 각각의 정보가 어떻게 기술되는지도 알 수 있다. 그리고 시간이 쌓이면서 가장 중요한 메인 신을 단번에 구별해내고 로직이 안 맞는 부분도 찾아낼 수 있다.</p>\n<h2>87쪽</h2>\n<p>그런데 사실 요즘은 트렌드가 모두 플랫한 디자인 스타일로 가기 때문에 스타일링 자체는 예전만큼 그렇게 중요하지 않아요. 요즘은 GUI 디자인이 다 비슷해졌어요. 차별점을 찾기가 어렵죠. 요즘은 정말 데이터 혹은 사용성을 기반으로 기능에 초점을 더 맞추어야 할 때인 것 같습니다. 정보를 사용자에게 잘 보여주고 사용자가 클릭하게 만들고 마지막으로 실행까지 이어지게 디자인하는 게 더 중요해졌습니다.</p>\n<h2>148쪽</h2>\n<p>또한 사용자는 제품이나 서비스가 제공하는 여러 경험을 직접 접하는 모든 순간을 통해 그 브랜드의 이미지를 느끼고 결정한다. 온라인이든 오프라인이든 상관없다. 그런 순간은 Moment of Truth, 즉 진실의 순간이라고 불리는데 이런 순간의 좋은 경험이 많이 쌓이면 쌓일수록 브랜드의 이미지는 좋아진다. 이는 곧 UX 디자이너가 단지 디스플레이 안에서의 경험뿐 아니라 사용자가 제품이나 서비스를 사용했을 때 만날 수 있는 모든 순간을 고려해야 한다는 뜻이다. 특히 모든 세상이 긴밀한 네트워크와 IoT로 연결되는 세상이 되면서 이는 더욱 중요해졌다. 온라인과 오프라인의 경계가 모호해졌고 사실상 우리가 말하는 사용자 경험이 이제는 하나의 생활 패턴 혹은 방식이 되어가고 있기 때문이다.</p>\n<p>사용자가 제품과 서비스를 만나고 느끼는 순간을 분석하고 거기서 발생할 수 있는 문제점이나 기회 영역을 파악해야 한다. 그리고 가장 어려우면서 중요한 점은 그 문제점이나 기회 영역을 통해 매 순간 같은 브랜드의 목소리를 느낄 수 있는 UX를 제공해야 한다는 것이다.</p>\n<h2>156쪽</h2>\n<ul>\n<li>UX적으로 브랜드가 느껴지는 경험을 디자인하려면 어떻게 해야 할까요? 브랜드 아이덴티티를 어떻게 사용자 경험에 녹일 수 있을까요?</li>\n</ul>\n<p>제일 중요한 건 회사의 색깔을 먼저 찾는 것 같아요. 그리고 그것을 계속 단순화해야죠. 모든 미사어구를 동원해서 회사를 설명하는 것이 아니라 한마디로 정의할 수 있어야 합니다. 예를 들어 구글은 플레이풀니스playfulness, 애플은 엘리티스트elitist등의 단어 이미지가 떠오르잖아요. 인터랙션이나 모션, 색상 등 UX 전반의 모든 것이 그 단어를 염두에 두고 수없이 아이디어를 검증해나가는 과정이 있어야 한다고 생각합니다. 플레이풀니스가 어떤 색상일까, 인터랙션에서는 어떻게 해야 할까, 형태는 어떤 것일까, 그런 아이디어가 있어야 합니다. 이런 생각의 과정을 겪다 보면 회사의 독특한 그리고 적정한 경험을 만들어낼 수 있다고 생각합니다.</p>\n<h2>166~167쪽</h2>\n<p>평범하고 익숙한 모든 것에는 우리가 원하는 힌트와 단서가 있다. 그래서 UX디자이너는 항상 무언가를 관찰하고 따져보는 습관을 가져야 한다. 특히 무언가에 불편을 느꼈다면 절대 그냥 넘어가지 말아야 한다. UX디자이너가 불편했다면 남들도 똑같이 불편함을 느끼는 경우가 많기 때문이다.</p>\n<p>불편함을 그냥 흘려보내지 말고 왜 불편한지 어떻게 하면 개선할 수 있는지 고민하는 습관을 가져야 한다.</p>\n<p>(...)</p>\n<p>이처럼 직관적인 UX란 익숙함에서 느끼고 생각하는 것으로부터 시작된다. 이것이 직관적 UX의 아이디어를 얻을 수 있는 가장 좋은 방법이다. 또한 익숙한 것으로부터 나오는 직관성은 자연스러워야 한다. 이는 익숙하고도 미묘해야 한다는 것을 의미한다. 자연스럽고 늘 그렇듯이 아무렇지 않게 이뤄져야 한다는 뜻이다. 그냥 대놓고 이야기할 거면 직관적인 방법보다는 아예 설명서로 자세하게 알려주는 것이 차라리 나을지 모른다.</p>\n<h2>179쪽</h2>\n<p>UX에서 단순함과 복잡함의 문제는 제공되는 구조로 혼란을 느끼느냐 느끼지 않느냐에 따라 좋고 나쁨을 따질 수 있다. 단순함과 복잡함 그 자체로 좋고 나쁨을 따질 수는 없다.</p>\n<h2>184쪽</h2>\n<p>세상은 점점 더 복잡해지고 있다. 수많은 기능이 필요해지고 할 말은 많아지고 보여주고 싶은 것은 너무 많다. 이런 상황에서 사람들은 더욱더 단순해 보이는 것을 추구할지 모른다. 하지만 보이는 단순함과 사용하는 단순함은 다르다. 세상에는 여전히 복잡함이 주는 아름다움과 필요성이 존재한다. 이 차이를 혼동하지 말자. 그리고 만약 UX에서 복잡함과 단순함 사이에서 고민이 생긴다면, 즉 구조에서 오는 혼란을 막기 위해서는 명확함과 간결함으로 판댄해야 한다는 점을 명심하자.</p>\n<h2>210쪽</h2>\n<p>폴 : 당연히 자연스러운 연결을 고민해야죠. 이를 위해 중요한 것은 메타포가 일치해야 한다는 점입니다. 사용자가 음성으로 듣는 메타포와 눈으로 보는 메타포가 일치해야 합니다. 예를 들어 사과가 연결된 모든 기기에서 사과를 빨갛고 먹는 것으로 일치해서 알아들어야 합니다. 이 부분을 맥락적으로 이해하여 그 메타포를 알아듣고 UX적으로 시각, 청각 등을 통해 일관되게 전달해줘야 할 것 같습니다. 이것도 어쨌든 기술이 바탕이 돼야겠죠.</p>\n<p>대니얼 : 디스플레이 간의 심리스한 경험은 여러 가지 커뮤니케이션이 일관적인 경험을 줘야 한다고 했을 때, 전체적인 톤 앤드 매너tone &#x26; manner를 맞춰야 한다고 생각합니다. 그러니까 시각, 청각 등 모든 감각에 동원되어 전달되는 톤 앤드 매너가 같아야 한다는 거죠. 그래야 기기와 기기 사이의 경계를 느낄 수 없을 것 같습니다.</p>\n<h2>227쪽</h2>\n<p>UX 디자이너로서 나는 언제나 '사람'을 위해 일하고 있다. 지금은 물론이고 미래에도 변하지 않을 UX의 기본 목적은 사람에게 편리한 사용성을 제공하는 것이며, 사람 혹은 기계와의 원활한 커뮤니케이션을 도와주는 것이다. 무엇이 가장 중요하고 무엇이 목적인지 무엇을 고려해서 무엇을 미리 배려해야 하는지 등 그동안 나는 사람을 잘 이해하고 커뮤니케이션하기 위해 끊임없이 노력해왔다. 상상하는 미래의 모든 것을 실현하는 최전선에서 사람들을 위해 일하고 있다는 사실에 오늘도 나는 가슴이 뛴다. 이것이 UX 디자이너로서 내가 자랑스러운 이유다.</p>",
    "excerpt": "우연히 도서관에서 일단 해보라구요? UX라는 책을 찾아서 읽게 되었다. 얇아서 금방 읽었는데 몇몇 부분을 메모로 남긴다. 해당 도서 판매 링크\n감상\n프론트로서 UX에 늘 어느 정도 관심을 가지고 있다. 이 글을 쓰고 있는 블로그를 만들 때도 어떻게 하면 사용자가 상호작용을 좀 덜 하면서 원하는 페이지를 찾을 수 있을까? 하는 생각을 하곤 했다.\n그런 과정에서 UX 관련 글들도 몇 개 읽었기 때문에 이 책에 있는 내용도 이미 들어본 내용이 좀 있었다. 하지만 이 ",
    "headingTree": [
      {
        "title": "감상",
        "url": "#감상",
        "items": []
      },
      {
        "title": "메모",
        "url": "#메모",
        "items": [
          {
            "title": "21~22쪽",
            "url": "#2122쪽",
            "items": []
          },
          {
            "title": "87쪽",
            "url": "#87쪽",
            "items": []
          },
          {
            "title": "148쪽",
            "url": "#148쪽",
            "items": []
          },
          {
            "title": "156쪽",
            "url": "#156쪽",
            "items": []
          },
          {
            "title": "166~167쪽",
            "url": "#166167쪽",
            "items": []
          },
          {
            "title": "179쪽",
            "url": "#179쪽",
            "items": []
          },
          {
            "title": "184쪽",
            "url": "#184쪽",
            "items": []
          },
          {
            "title": "210쪽",
            "url": "#210쪽",
            "items": []
          },
          {
            "title": "227쪽",
            "url": "#227쪽",
            "items": []
          }
        ]
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 32
    },
    "url": "/posts/just-give-it-a-try-ux",
    "thumbnail": {
      "local": "/thumbnails/just-give-it-a-try-ux-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-just-give-it-a-try-ux-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAgElEQVR4nGOora0NCAjw9vZ2dXWNjIxMSkqqr68XEBBgyMjIUFBQUFZWZmFhWbVq1cOHD69fv759+3aG2bNnr1279unTp0eOHHn37t1/GGDYtGnT7du34fzfMMDw4OGjm7du3bt37/Xr13BpkI7Fy1bNX7ho48aN169fh+iASAAAsBdpJ19euDIAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "javascript-why-typeof-null-is-object",
    "title": "JS 탐구생활 - JS의 typeof null은 왜 object일까?",
    "date": "2023-12-23T00:00:00Z",
    "description": "자바스크립트의 typeof 연산자가 null을 object로 판단하는 이유",
    "tags": [
      "javascript"
    ],
    "html": "<p>이 글은 <code>typeof null</code>이 왜 <code>\"object\"</code>일까에 대한 의문으로 시작되었다. 그래서 그 답을 찾는 과정을 정리해 기술한다.</p>\n<h1>선 요약</h1>\n<p><img src=\"/static/typeof-result-1a7bc682.png\" alt=\"typeof의 결과표\"></p>\n<ul>\n<li><code>null</code>은 원래 객체의 의미를 내재하고 있는 값으로 만들어졌다.</li>\n<li>또한 초기의 <code>typeof</code> 구현에서 <code>null</code> 검사 로직이 따로 없었다.</li>\n<li>그래서 <code>typeof null</code>은 <code>\"object\"</code>로 굳어졌고 이후 고치려는 시도가 있었지만 실패했다.</li>\n</ul>\n<h1>1. 시작</h1>\n<p>Javascript에는 <code>typeof</code> 연산자가 있다. 이 연산자는 피연산자의 타입을 문자열로 반환한다. 예를 들어 <code>typeof 1</code>은 <code>\"number\"</code>를 반환하고 <code>typeof \"hello\"</code>는 <code>\"string\"</code>을 반환한다.</p>\n<pre><code class=\"language-javascript\">typeof 1; // \"number\"\ntypeof \"hello\"; // \"string\"\n</code></pre>\n<p>그런데 <code>typeof null</code>은 <code>\"object\"</code>를 반환한다. 분명 뭔가 없는 값을 나타낼 때 쓰이는 값인데 타입이 <code>\"object\"</code>라니 이상하지 않은가?</p>\n<p>이 사실을 내가 알게 된지는 1년은 넘은 것 같다. 하지만 예전에 이유를 찾아보았을 때 대부분의 문서에서는 역사적인 이유라는 말밖에 찾을 수 없었다. 제대로 된 설명은 <a href=\"https://github.com/FEDevelopers/tech.description/wiki/%E2%80%9Ctypeof-null%E2%80%9D%EC%9D%98-%EC%97%AD%EC%82%AC\">“typeof null”의 역사</a>와 그 원문에서 정도만 조금 찾을 수 있었다.</p>\n<p>그런데 이후 Javascript의 역사를 조금은 더 공부했고, 그 과정에서 <code>typeof null</code>의 결과에 대해 몇 마디를 더 덧붙일 수 있게 되었다. 그래서 위의 글에 새로 알게 된 점 몇 개를 더해 이 글을 쓴다.</p>\n<h1>2. 역사적인 이유</h1>\n<p>이 섹션은 다음과 같은 자료를 주로 참고하였다.</p>\n<ul>\n<li>ECMAScript 6 에디터 Allen Wirfs-Brock과 Javascript 창시자 Brendan Eich가 Javascript의 역사를 정리한 <a href=\"https://dl.acm.org/doi/10.1145/3386327\">Javascript: the first 20 years</a></li>\n<li><a href=\"https://twitter.com/rauschma/status/333252517628628992\">Brandan Eich의 트윗, 링크 외에도 다수</a></li>\n<li><a href=\"https://2ality.com/2013/10/typeof-null.html\">\"자바스크립트를 말하다\"등 여러 Javascript 책을 쓴 Axel Rauschmayer가 typeof에 대해 해설한 글과 거기 달린 Brandan Eich의 댓글</a></li>\n</ul>\n<hr>\n<p><code>typeof null</code>이 왜 <code>\"object\"</code>인지에 대해서는 2가지 맥락으로 생각해볼 수 있다. 하나가 이 섹션에서 다룰 역사적인 의미에 따른 부분이고 나머지 하나는 기술적인 부분이다.</p>\n<p>역사적인 의미를 찾아보면 <code>typeof null</code>이 <code>\"object\"</code>인 이유는, <code>null</code>이 원래 이곳에 객체 참조가 있어야 하는데 참조가 없음을 나타내는 값으로 만들어졌기 때문이다.</p>\n<p>Javascript를 보면 \"없다\"는 의미를 나타내는 값이 <code>null</code>과 <code>undefined</code> 2가지가 있다. 이 둘은 비슷하게 \"없다\"는 의미를 나타내기 때문에 이 차이는 면접의 단골 질문 중 하나다.</p>\n<p>물론 유명한 면접 질문인 만큼 이미 이 둘의 차이를 설명한 글도 많고 해당 주제에 대해서 탐구한 글을 나도 따로 작성하고 있다.(TODO : 이후에 해당 글 작성시 링크 추가) 그러니 여기서는 우리의 처음 질문에 대해 답하는 데에 필요한 부분만 알아보자.</p>\n<blockquote>\n<p>왜 <code>typeof null</code>은 <code>\"object\"</code>일까?</p>\n</blockquote>\n<h2>2.1. null과 undefined</h2>\n<p>많은 프로그래밍 언어들에서 '값이 없음'이나 '빈 참조'를 나타내는 값은 하나이다. Java에서는 <code>null</code>이고, Python에는 <code>None</code>이 있다.(이 \"없다\"라는 값의 존재도 많은 문제를 일으키지만 글의 주제를 벗어나므로 넘어간다) 그런데 Javascript는 <code>null</code>과 <code>undefined</code> 2가지가 있다.</p>\n<p>그럼 다른 언어들은 하나의 값으로 이런 \"없다\"는 의미를 나타내고 있었는데 Javascript는 왜 2가지로 나누었을까? 이는 Javascript의 역사와 연관되어 있다.</p>\n<p>Javascript가 처음 나오던 시절 Javascript는 Java의 보조 언어로서 비전문가들을 위해 만들어진 언어였다. 또 Java Applet이나 C++로 만들어진 웹 컴포넌트들을 조립하는 데에 사용하는 것도 Javascript의 주요 목적 중 하나였다. 그래서 초기 Javascript는 Java와 비슷한 문법을 가지고 있어야 한다는 요구사항이 있었다. 더 자세한 Javascript의 역사에 대해서는 다른 글(현재 작성 중)을 참고할 수 있다.</p>\n<p>그 요구사항 때문에 Javascript는 Java에서 따온 것들이 몇 개 있다. 그렇게 따온 것중에는 Java에서 원시값과 객체로 값을 구분하는 것도 있었다. 따라서 Javascript에서도 \"없다\"는 의미를 가지는 값도 할당된 값이 없다는 것과 객체 참조가 없다는 것을 나타내는 값으로 나누려고 했다.</p>\n<p>그런데 문제가 있었다. Java에서는 \"없다\"를 나타내는 값이 <code>null</code> 하나지만 변수의 정적 타입이 있어서 변수가 객체 타입이면 있어야 할 객체 참조가 없는 것, 다른 타입이면 할당된 값이 없는 것으로 의미를 구분할 수 있었다. 하지만 Javascript에는 타입이 없었고 하나의 변수에 객체 참조도 값도 담을 수 있었다. 그래서 변수의 정적 타입을 통해 <code>null</code>이 나타내는 게 할당된 값이 없다는 건지 객체 참조가 없다는 건지 구분하는 방법을 쓸 수 없었다.</p>\n<p>그래서 <code>null</code>은 원래 객체 참조가 들어 있어야 하는데 참조가 없음을 나타내는 값으로 하고, 그리고 그냥 할당된 값이 없다는 걸 나타내는 값으로 <code>undefined</code>를 만들었다.</p>\n<p>즉 <code>null</code>은 객체 값이 기대되는 맥락에서 \"객체가 없다\"는 것을 나타내기 위해 쓰였다. 이는 Java의 <code>null</code>을 따온 것이고 Java로 구현된 객체와 Javascript의 통합을 용이하게 해주었다.</p>\n<h2>2.2. typeof</h2>\n<p>Javascript 1.1에서는 <code>delete</code>, <code>typeof</code>, <code>void</code>연산자가 들어왔다. 이중 <code>typeof</code> 연산자는 피연산자의 원시형 타입을 문자열로 반환하는 연산자였다.</p>\n<p>이렇게 <code>typeof</code>가 최초로 나올 때에도 <code>typeof null</code>은 <code>\"object\"</code>였다. 그리고 현재의 JS에서도 마찬가지다. 이는 위에서 설명한 것처럼 <code>null</code>은 객체 참조가 없음을 나타내는 값이었기 때문이다.</p>\n<p>따라서 <code>null</code> 스스로가 객체는 아니지만 객체의 의미를 가지고 있다고 볼 수 있고 그래서 <code>typeof null</code>은 <code>\"object\"</code>가 되었다.</p>\n<p>다만 문제는 Java에는 <code>typeof</code>와 대응되는 무언가가 없었고 그냥 <code>null</code>을 초기화되지 않은 변수의 기본값으로 사용했다는 사실이다. 위에서 보았듯이 해당 <code>null</code>이 객체인지 원시값인지는 변수의 정적 타입을 기반으로 구분했다. Java에서는 딱히 <code>null</code> 자체에 객체라는 의미가 내재되어 있지는 않았던 것이다.</p>\n<p>즉 이런 <code>typeof</code>의 구현은 나름대로 배경이 있는 것이기는 했으나 실제로 아주 합리적으로 보이는 동작은 아니었다.</p>\n<p>Javascript 제작자 브랜든 아이크는 이 <code>typeof null</code>의 값은 Mocha(Javascript의 극초기 코드네임) 구현의 <a href=\"http://rapapa.net/?p=3266\">Leaky Abstraction</a>이었다고 회상하기도 한다. 구현 세부 사항을 알아야 하는 경우가 발생하는, 추상화의 구멍이었다는 것이다.</p>\n<h1>3. 기술적인 이유</h1>\n<p><code>typeof null</code>이 <code>\"object\"</code>인 데에는 다른 이유도 있다. 말하자면 기술적인 버그라고 할 수 있다. 이를 위해서는 먼저 <code>undefined</code>와 <code>null</code>이 내부적으로 가지는 값이 어떤 식으로 구현되었는지를 알아야 하고 <code>typeof</code>가 값의 타입을 어떻게 판단했는지 알아야 한다.</p>\n<h2>3.1. undefined와 null의 구현</h2>\n<p><code>null</code>은 앞서 보았듯이 객체 참조가 있어야 하는 자리에 \"없다\"는 의미를 나타내는 값이었다. 따라서 C에서 <code>NULL</code> 포인터를 0으로 정의하는 선례를 따라 <code>null</code>은 0으로 숫자 형변환되는 값으로 정의했다.</p>\n<p>그럼 <code>undefined</code>는 원시값이 없다는 의미를 나타내야 하니까 참조도 아니고(참조라면 객체인 것이니까) 0으로 형변환되지도 않는 값이 필요했다. 따라서 <code>undefined</code>는 정수 범위를 벗어나는 값인 $-2^{30}$ 으로 정의되었다.</p>\n<p>여담이지만 이런 이유로 지금도 Javascript에서는 <code>null</code>은 0으로, <code>undefined</code>는 NaN으로 형변환된다. <code>undefined</code>는 참조도 아니고, 0으로 변환되지도 않는 값이니까!</p>\n<pre><code class=\"language-js\">Number(undefined); // NaN\nNumber(null); // 0\n</code></pre>\n<p><a href=\"https://twitter.com/rauschma/status/332953297294086144\">이렇게 <code>null</code>의 형변환 결과를 0으로 하는 건 좋은 선택이었다고 한다.</a> <code>null</code>의 자동 형변환 결과가 0인 게 당시 쓰임새가 좀 있었던 듯 하다.</p>\n<p>아무튼 이렇게 <code>null</code>은 0, <code>undefined</code>는 NaN으로 형변환되었다는 사실을 기억하고, <code>typeof</code>가 어떻게 값을 판단했는지 알아보자.</p>\n<h2>3.2. 극초기 typeof의 구현</h2>\n<p>Javascript 프로토타입(당시 이름은 Mocha)이 만들어지던 1995년 5월 쓰였던 엔진에서는 값을 C의 discriminated union으로 저장했다.</p>\n<p>구조체를 만들고 그곳에 type tag를 나타내는 변수와 union으로 저장된 값을 저장한 후 tag를 통해 union 값을 어떤 방식으로 읽을지를 결정하는 것이었다.</p>\n<p>남아 있는 코드는 없지만 몇몇 자료들을 취합해 보면 아마 당시 Javascript의 값들은 각각 이런 모습이었을 거라고 생각한다. <a href=\"https://twitter.com/BrendanEich/status/226310723691741185\">해당 엔진은 오픈소스가 아니었고 공개된 적이 없기 때문에 정확한 구현은 알 수 없다.</a></p>\n<pre><code class=\"language-c\">enum TypeTag {\n    OBJECT,\n    NUMBER,\n    STRING,\n    BOOLEAN,\n};\n\nstruct Value {\n    enum TypeTag tag;\n    union {\n        double number;\n        char* string;\n        struct Object* object;\n        bool boolean;\n    } value;\n};\n</code></pre>\n<p>그리고 실제로 값을 읽을 때는 tag를 통해 어떤 방식으로 읽을지를 결정했다. 예를 들어 값을 출력하는 <code>printValue</code>라는 함수가 있었다면 다음과 같이 구현되었을 것이다.</p>\n<pre><code class=\"language-c\">void printValue(struct Value* value) {\n    switch (value->tag) {\n        case NUMBER:\n            printf(\"%f\", value->value.number);\n            break;\n        case STRING:\n            printf(\"%s\", value->value.string);\n            break;\n        case OBJECT:\n            printf(\"%p\", value->value.object);\n            break;\n        case BOOLEAN:\n            printf(\"%s\", value->value.boolean ? \"true\" : \"false\");\n            break;\n    }\n}\n</code></pre>\n<p>따라서 당연히 <code>typeof</code>는 <code>tag</code>를 읽어서 적절한 타입 문자열을 반환하는 식으로 구현되었을 거라 보인다.</p>\n<p>그럼 특별한 값 <code>undefined</code>와 <code>null</code>은 어떻게 구현되었을까? 앞서 보았다. 당시 <code>undefined</code>는 NaN으로 형변환되었고 $-2^{30}$이라는 특수한 값을 가졌다. 그러니 해당 값이랑 비교하면 되었다. <code>null</code>은 NULL 포인터와 같은 값을 가졌다. 이는 0과 같았다.</p>\n<p>하지만 <code>typeof</code>에는 이 <code>null</code>을 위한 특별한 처리 로직이 없었다. 당시에는 Java와 비슷해야 한다는 요구사항과 함께 10일간의 프로토타이핑 시간밖에 주어지지 않았기 때문에 그냥 위의 역사적 맥락으로 인해 <code>null</code>을 그냥 객체로 판단했던 거라 생각한다.</p>\n<p>이 또한 몇몇 자료를 통해 추정해볼 때 다음과 비슷한 느낌이었을 걸로 추정한다. 따로 <code>null</code>을 위한 처리 로직을 넣지 않고 <code>typeof</code>를 구현했을 때 <code>null</code>의 태그 값은 <code>OBJECT</code>와 같았다. 앞서 말했듯이 당시의 <code>null</code>은 객체의 의미를 내재하고 있는 값이었기 때문이다. 그래서 <code>typeof null</code>은 <code>object</code>를 반환하게 되었다.</p>\n<pre><code class=\"language-c\">JS_TYPE typeof(struct Value* value) {\n  JS_TYPE type = value->tag;\n  JS_OBJECT* obj;\n\n  if(JSVAL_IS_VOID(value)) {\n    type = JS_TYPE_VOID;\n  } else if(JSVAL_IS_NUMBER(value)) {\n    type = JS_TYPE_NUMBER;\n  } else if(JSVAL_IS_STRING(value)) {\n    type = JS_TYPE_STRING;\n  } else if(JSVAL_IS_BOOLEAN(value)) {\n    type = JS_TYPE_BOOLEAN;\n  } else if(JSVAL_IS_OBJECT(value)) {\n    obj = JSVAL_TO_OBJECT(value);\n    if(obj &#x26;&#x26; ...함수 판단 로직...) {\n      type = JS_TYPE_FUNCTION;\n    }\n    else{\n      type = JS_TYPE_OBJECT;\n    }\n  }\n  return type;\n}\n</code></pre>\n<p>혹은, 타입 태그 중 객체를 나타내는 값이 0이었기에 모든 비트가 0으로 초기화된 null 구조체의 태그 값을 판단했을 때 <code>OBJECT</code>와 같았을 거라는 추측도 가능하다(위 코드의 <code>enum</code>도 그런 것을 의도해서 작성하였다).</p>\n<p>이럴 경우 아마 이런 식의 코드가 되었을 것이다.</p>\n<pre><code class=\"language-c\">JS_TYPE typeof(struct Value* value) {\n  JS_TYPE type = JS_TYPE_VOID;\n  JS_OBJECT* obj;\n\n  switch (value->tag){\n    case JS_TYPE_OBJECT:\n    // tag가 0이므로 모든 비트가 0인 null 구조체의 태그 값도 여기 들어간다\n      obj = JSVAL_TO_OBJECT(value);\n      if(obj &#x26;&#x26; ...함수 판단 로직...) {\n        type = JS_TYPE_FUNCTION;\n      } else{\n        type = JS_TYPE_OBJECT;\n      }\n      break;\n    case JS_TYPE_VOID:\n      type = JS_TYPE_VOID;\n      break;\n    case JS_TYPE_NUMBER:\n      type = JS_TYPE_NUMBER;\n      break;\n    case JS_TYPE_STRING:\n      type = JS_TYPE_STRING;\n      break;\n    case JS_TYPE_BOOLEAN:\n      type = JS_TYPE_BOOLEAN;\n      break;\n  }\n  return type;\n}\n</code></pre>\n<p>이렇게 초기 엔진에서도 <code>typeof null</code>은 <code>\"object\"</code>에 해당하는 값으로 판단되게 되었다.</p>\n<h1>4. 고쳐지지 않은 버그</h1>\n<p>이는 당연히 버그였지만 한동안 제대로 고쳐지지 않았다.</p>\n<h2>4.1. 타입 태그 도입</h2>\n<p>1996년 표준화 등 여러가지 목적으로 Javascript 초기 구현의 기술 부채를 청산하는 작업이 진행되었다. 그동안 값을 표현하는 방식을 원시값 그대로를 포함하는 tagged pointer로 변경했다. 이 새로운 엔진은 'SpiderMonkey'라는 이름으로 출시되었다.</p>\n<p>이 엔진에서는 discriminated union을 사용하지 않았다. 대신 값의 타입을 나타내는 태그를 포함하는 tagged pointer를 사용했다. 변수의 값은 32비트 단위로 저장되었는데 1~3번째 비트는 타입 태그로 변수의 타입에 대해 저장했고 나머지 비트들은 실제 값이나 참조를 저장했다.</p>\n<p>타입 태그는 다음과 같이 5종류가 있었다.</p>\n<ul>\n<li>000 : 객체. 데이터는 객체에 대한 참조다.</li>\n<li>1: 정수. 데이터는 31비트의 부호를 가진 정수다.</li>\n<li>010: 실수. 데이터는 double 부동 소수점에 대한 참조다.</li>\n<li>100: 문자. 데이터는 문자에 대한 참조다.</li>\n<li>110: 참/거짓. 데이터는 참/거짓이다.</li>\n</ul>\n<p>즉 타입 태그의 lowest bit(만약 비트가 110이면 lowest bit는 0)가 1이면 타입 태그는 길이가 1이었고 lowest bit가 0이면 타입 태그는 길이가 3이었다. lowest bit가 0이고 길이가 3인 타입 태그로 4개의 타입을 나타내는 식이었다(2개의 비트를 쓸 수 있으므로).</p>\n<p>그리고 $-2^{30}$ 으로 나타났던 <code>undefined</code>와 NULL 포인터(사실 0)으로 나타났던 <code>null</code>이라는 특수한 값이 있었다.</p>\n<h2>4.2. 새로운 typeof 구현</h2>\n<p>이 엔진에서는 <code>typeof</code>의 구현도 달라졌다. <code>typeof</code>는 타입 태그를 읽어서 적절한 타입 문자열을 반환하는 식으로 구현되었다. 그런데 문제는 <code>null</code>값을 명시적으로 검사하는 로직이 따로 없었다는 것이다.</p>\n<p>이때 <code>null</code>은 0으로 나타나므로 만약 <code>null</code>의 값의 타입 태그를 검사하게 되면 당연히 0, 즉 객체 타입을 나타내는 태그가 나오게 된다. 당시 <code>typeof</code> 코드는 다음과 같았는데 이 코드를 따라가 보면 왜 <code>null</code> 즉 0에 해당하는 값이 <code>\"object\"</code>로 판단되는지 알 수 있다.</p>\n<pre><code class=\"language-c\">JS_PUBLIC_API(JSType) JS_TypeOfValue(JSContext *cx, jsval v) {\n    JSType type = JSTYPE_VOID;\n    JSObject *obj;\n    JSObjectOps *ops;\n    JSClass *clasp;\n\n    CHECK_REQUEST(cx);\n    if (JSVAL_IS_VOID(v)) {  // (1)\n        type = JSTYPE_VOID;\n    } else if (JSVAL_IS_OBJECT(v)) {  // (2)\n        obj = JSVAL_TO_OBJECT(v);\n        if (obj &#x26;&#x26;\n            (ops = obj->map->ops,\n              ops == &#x26;js_ObjectOps\n              ? (clasp = OBJ_GET_CLASS(cx, obj),\n                clasp->call || clasp == &#x26;js_FunctionClass) // (3,4)\n              : ops->call != 0)) {  // (3)\n              // 함수 혹은 클래스인지 검사하는 부분\n            type = JSTYPE_FUNCTION;\n        } else {\n            type = JSTYPE_OBJECT;\n        }\n    } else if (JSVAL_IS_NUMBER(v)) {\n        type = JSTYPE_NUMBER;\n    } else if (JSVAL_IS_STRING(v)) {\n        type = JSTYPE_STRING;\n    } else if (JSVAL_IS_BOOLEAN(v)) {\n        type = JSTYPE_BOOLEAN;\n    }\n    return type;\n}\n</code></pre>\n<p><code>(1)</code>에서는 값이 <code>undefined</code>인지 검사한다. <code>(2)</code>에서는 값이 객체인지 검사한다. 그런데 <code>null</code>의 타입 태그에 해당하는 상위 3비트를 조사했을 때 이는 당연히 <code>000</code>이므로 <code>(2)</code>로 넘어가고 <code>null</code>에 함수 혹은 클래스 속성이 붙어 있을 리 없으므로 반환되는 타입은 <code>JSTYPE_OBJECT</code>가 된다.</p>\n<p>이런 검사를 통해서 <code>null</code>을 가려낼 수 있었을 것이다. 하지만 엔진은 급하게 만들어지느라 그런 로직이 없었다. 그래서 <code>null</code>은 <code>typeof</code>에서 <code>\"object\"</code>로 판단되었다.</p>\n<pre><code class=\"language-c\">#define JSVAL_IS_NULL(v)  ((v) == JSVAL_NULL)\n</code></pre>\n<p>즉 정리하면 당시 <code>typeof</code> 연산자의 구현은 값의 내부에 들어 있는 어떤 태그 값을 읽어오는 식이었다. 그런데 <code>null</code>의 태그 값은 객체의 타입을 나타내는 것과 같은 내부 태그값을 가졌었다. 따라서 <code>typeof</code>는 어떤 특별한 처리 로직 없이 <code>null</code>에 대해서 <code>\"object\"</code>를 반환하게 되었다.</p>\n<p>모두 알다시피 이는 <code>typeof</code> 연산자를 통해서 값이 실제 객체인지를 알아보고 싶어하는 사람들에게 큰 혼란을 주었다. <code>typeof obj === \"object\"</code>라는 코드는 <code>obj</code>가 <code>null</code>일 때도 <code>true</code>를 반환하기 때문이다. 그리고 <code>null</code>의 프로퍼티 접근은 런타임 에러다...</p>\n<h1>5. 여담</h1>\n<blockquote>\n<p>\"I think it is too late to fix typeof. The change proposed for typeof null will break existing code.\"</p>\n</blockquote>\n<p>이는 당연히 버그였고 이후 이를 고치려는 시도나 제안도 몇 번 있었다. 그러나 이미 너무 많은 코드가 해당 <code>typeof</code>를 기반으로 돌아가고 있었기 때문에 breaking change를 만들기 어렵다는 이유로 실패했다.</p>\n<p>물론 <code>typeof null===\"object\"</code>가 버그라는 것은 Javascript 제작자 브랜든 아이크조차 인정하는 사실이다. 하지만 이걸 지금 와서 고치기에는 시간이 너무 많이 지났고, 그래서 <code>typeof</code>를 지금 고쳐서 기존 코드를 안 돌아가게 하기보다는 서서히 deprecated 시키는 편이 낫다고 한다.</p>\n<h1>참고</h1>\n<p>“typeof null”의 역사 <a href=\"https://github.com/FEDevelopers/tech.description/wiki/%E2%80%9Ctypeof-null%E2%80%9D%EC%9D%98-%EC%97%AD%EC%82%AC\">https://github.com/FEDevelopers/tech.description/wiki/%E2%80%9Ctypeof-null%E2%80%9D%EC%9D%98-%EC%97%AD%EC%82%AC</a></p>\n<p>NaN and Infinity in JavaScript <a href=\"https://2ality.com/2012/02/nan-infinity.html\">https://2ality.com/2012/02/nan-infinity.html</a></p>\n<p>Categorizing values in JavaScript <a href=\"https://2ality.com/2013/01/categorizing-values.html\">https://2ality.com/2013/01/categorizing-values.html</a></p>\n<p>JavaScript history: undefined <a href=\"https://2ality.com/2013/05/history-undefined.html\">https://2ality.com/2013/05/history-undefined.html</a></p>\n<p>JavaScript quirk 1: implicit conversion of values <a href=\"https://2ality.com/2013/04/quirk-implicit-conversion.html\">https://2ality.com/2013/04/quirk-implicit-conversion.html</a></p>\n<p>JavaScript quirk 2: two “non-values” – undefined and null <a href=\"https://2ality.com/2013/04/quirk-undefined.html\">https://2ality.com/2013/04/quirk-undefined.html</a></p>\n<p>The history of “typeof null”(그리고 댓글의 브랜든 아이크의 첨언) <a href=\"https://2ality.com/2013/10/typeof-null.html\">https://2ality.com/2013/10/typeof-null.html</a></p>\n<p>왜 undefined와 null이 둘 다 있는지에 대한 브랜든 아이크의 트윗 <a href=\"https://twitter.com/rauschma/status/333252517628628992\">https://twitter.com/rauschma/status/333252517628628992</a></p>\n<p>JavaScript의 타입과 자료구조 <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Data_structures\">https://developer.mozilla.org/ko/docs/Web/JavaScript/Data_structures</a></p>\n<p>JavaScript: the first 20 years <a href=\"https://dl.acm.org/doi/10.1145/3386327\">https://dl.acm.org/doi/10.1145/3386327</a> 12~13페이지</p>\n<p>Conversion from null to int possible? <a href=\"https://stackoverflow.com/questions/6588856/conversion-from-null-to-int-possible\">https://stackoverflow.com/questions/6588856/conversion-from-null-to-int-possible</a></p>\n<p>개발에서의 Leaky Abstraction <a href=\"http://rapapa.net/?p=3266\">http://rapapa.net/?p=3266</a></p>\n<p>C/C++ Tagged/Discriminated Union <a href=\"https://medium.com/@almtechhub/c-c-tagged-discriminated-union-ecd5907610bf\">https://medium.com/@almtechhub/c-c-tagged-discriminated-union-ecd5907610bf</a></p>\n<p>브랜든 아이크의 트윗</p>\n<p><a href=\"https://twitter.com/BrendanEich/status/330775086208524288\">https://twitter.com/BrendanEich/status/330775086208524288</a></p>\n<p>ECMAScript-regrets <a href=\"https://github.com/DavidBruant/ECMAScript-regrets\">https://github.com/DavidBruant/ECMAScript-regrets</a></p>",
    "excerpt": "이 글은 typeof null이 왜 \"object\"일까에 대한 의문으로 시작되었다. 그래서 그 답을 찾는 과정을 정리해 기술한다.\n선 요약\n\n\nnull은 원래 객체의 의미를 내재하고 있는 값으로 만들어졌다.\n또한 초기의 typeof 구현에서 null 검사 로직이 따로 없었다.\n그래서 typeof null은 \"object\"로 굳어졌고 이후 고치려는 시도가 있었지만 실패했다.\n\n1. 시작\nJavascript에는 typeof 연산자가 있다. 이 연산자는 피연산자의 타",
    "headingTree": [
      {
        "title": "선 요약",
        "url": "#선-요약",
        "items": []
      },
      {
        "title": "1. 시작",
        "url": "#1-시작",
        "items": []
      },
      {
        "title": "2. 역사적인 이유",
        "url": "#2-역사적인-이유",
        "items": [
          {
            "title": "2.1. null과 undefined",
            "url": "#21-null과-undefined",
            "items": []
          },
          {
            "title": "2.2. typeof",
            "url": "#22-typeof",
            "items": []
          }
        ]
      },
      {
        "title": "3. 기술적인 이유",
        "url": "#3-기술적인-이유",
        "items": [
          {
            "title": "3.1. undefined와 null의 구현",
            "url": "#31-undefined와-null의-구현",
            "items": []
          },
          {
            "title": "3.2. 극초기 typeof의 구현",
            "url": "#32-극초기-typeof의-구현",
            "items": []
          }
        ]
      },
      {
        "title": "4. 고쳐지지 않은 버그",
        "url": "#4-고쳐지지-않은-버그",
        "items": [
          {
            "title": "4.1. 타입 태그 도입",
            "url": "#41-타입-태그-도입",
            "items": []
          },
          {
            "title": "4.2. 새로운 typeof 구현",
            "url": "#42-새로운-typeof-구현",
            "items": []
          }
        ]
      },
      {
        "title": "5. 여담",
        "url": "#5-여담",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 3,
      "wordCount": 773
    },
    "url": "/posts/javascript-why-typeof-null-is-object",
    "thumbnail": {
      "local": "/static/typeof-result-1a7bc682.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-typeof-result-1a7bc682-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAFCAIAAAD38zoCAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAe0lEQVR4nC3JIQKDIBQAUMq8AJGjjCtIJU4qUagzCnFyCaJQpUrmUyXLORa2+h5yzgkhGGMYY0IIpdRaG8KOpJTe+5QOSp8AJecz5xOgIKXmEPaUjml69X73frd2tXYhxsZheGzbR6n5R/8wZuWcAxSt9bK8jVljjLXWL7XSRayAonyGAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "javascript-various-comments",
    "title": "JS 탐구생활 - JS의 주석은 //과 /* */뿐만이 아니다",
    "date": "2024-01-06T00:00:00Z",
    "description": "JS 주석의 종류, 그리고 이야기들",
    "tags": [
      "javascript"
    ],
    "html": "<h1>썸네일</h1>\n<p><img src=\"/static/js-comment-4286d81c.webp\" alt=\"JS 주석 이미지\"></p>\n<h1>시작</h1>\n<p>Javascript 명세 등 여러 자료를 보면서 알게 된 주석 관련 이야기들을 정리하였다.</p>\n<p><code>//</code>와 <code>/* */</code>로 각각 한 줄 주석과 여러 줄 주석을 만들 수 있다는 것은 알고 있었다.</p>\n<p>하지만 명세에는 <code>#!</code>로 시작하는 Hashbang Comments와 HTML 주석 형식인 <code>&#x3C;!--</code>와 <code>--></code>로 감싸는 HTML-like Comments등 다른 것도 정의되어 있었다.</p>\n<p>또한 주석은 일반적으로 공백처럼 동작하는 것, <code>/* */</code>주석이 어디에서 유래되었는지 등도 알게 되었다. 이렇게 알게 된 점들을 여기 기록한다.</p>\n<p>먼저 기본적인 주석 문법부터 시작하자.</p>\n<h1>1. 한 줄 주석</h1>\n<p>JS를 처음 배울 때 주석은 <code>//</code>로 시작하는 한 줄 주석과 <code>/* */</code>로 감싸는 여러 줄 주석이 있다는 것을 배운다. 당연하게도 이는 명세에도 잘 정의되어 있다. 이것들이 어떻게 명세에 정의되어 있는지 먼저 알아보자.</p>\n<h2>1.1. 문법</h2>\n<p>한 줄 주석은 간단하다. <code>//</code>로 시작하는 한 줄을 주석 처리한다. 한 줄 주석은 <code>LineTerminator</code>를 제외한 모든 유니코드 글자를 포함할 수 있다. 토큰은 가능한 한 길게 해석되는 규칙이 있기 때문에 한 줄 주석은 항상 <code>//</code> 부터 줄 끝까지의 모든 글자로 구성된다.</p>\n<p>이때 LineTerminator란 말 그대로 줄바꿈을 의미하는 문자인데 명세상 다음과 같은 것들이 LineTerminator에 해당한다.</p>\n<ul>\n<li>LF: Line Feed, U+000A</li>\n<li>CR: Carriage Return, U+000D</li>\n<li>LS: Line Separator, U+2028</li>\n<li>PS: Paragraph Separator, U+2029</li>\n</ul>\n<p>명세에서 한 줄 주석은 <code>SingleLineComment</code>로 정의되어 있다. <code>//</code> 다음에 오는 <code>SingleLineCommentChars</code> 형식이다.</p>\n<pre><code>SingleLineComment ::\n  // SingleLineCommentChars(option)\n</code></pre>\n<p><code>SingleLineCommentChars</code>는 <code>LineTerminator</code>가 아닌 모든 글자로 이루어진 시퀀스라는 걸 알 수 있다.</p>\n<pre><code>SingleLineCommentChars ::\n  SingleLineCommentChar SingleLineCommentChars(option)\n\nSingleLineCommentChar ::\n  SourceCharacter but not LineTerminator\n</code></pre>\n<h2>1.2. 취급</h2>\n<p>한 줄 주석은 일반적으로 공백처럼 동작한다. 그리고 줄 끝의 LineTerminator는 한 줄 주석에 속한 걸로 간주되지 않는다. 이는 문법적으로 별도로 인식된다.</p>\n<p>따라서 한 줄 주석은 LineTerminator를 포함하지 않으므로 자동 세미콜론 삽입에 영향을 주지 않는다. 자동 세미콜론 삽입에 대해서는 <a href=\"https://witch.work/posts/javascript-semicolon-insertion\">JS 탐구생활 - 세미콜론 자동 삽입</a>을 참고할 수 있다.</p>\n<h1>2. 여러 줄 주석</h1>\n<h2>2.1. 문법</h2>\n<p>여러 줄 주석은 <code>/*</code>로 시작해서 <code>*/</code>로 끝나는 주석이다. 여러 줄 주석은 중첩될 수 없다. 명세를 보면 <code>MultiLineComment</code>로 정의되어 있다. 이는 <code>/*</code>, <code>*/</code>로 감싸인 <code>MultiLineCommentChars</code>이다.</p>\n<pre><code>MultiLineComment ::\n  /* MultiLineCommentChars(option) */\n</code></pre>\n<p><code>MultiLineCommentChars</code>는 <code>*</code>로 시작하는 <code>PostAsteriskCommentChars</code>혹은 <code>*</code>이 아닌 글자로 시작하는 <code>MultiLineCommentChars</code>이다. 그리고 <code>PostAsteriskCommentChars</code>는 <code>*</code>도 <code>/</code>도 아닌 글자로 시작하는 <code>MultiLineCommentChars</code>이거나 <code>*</code>로 시작하는 <code>PostAsteriskCommentChars</code>자기 자신이다.</p>\n<pre><code>MultiLineCommentChars ::\n  * PostAsteriskCommentChars(option)\n  MultiLineNotAsteriskChar MultiLineCommentChars(option)\n\nPostAsteriskCommentChars ::\n  MultiLineNotForwardSlashOrAsteriskChar MultiLineCommentChars(option)\n  * PostAsteriskCommentChars(option)\n</code></pre>\n<p><code>PostAsteriskCommentChars</code>가 <code>/</code>로 시작하면 안되는 이유는 해당 토큰 이전에는 <code>*</code>이 오는데 이 토큰이 <code>/</code>로 시작하면 <code>*/</code>이 완성되어 여러 줄 주석이 끝나버리기 때문이다.</p>\n<p>즉 풀어 써보면 여러 줄 주석은 다음과 같은 형태를 가진다. 여러 줄 주석은 <code>/* */</code> 사이에 있는 문자열인데 <code>*</code>로 시작하는 줄은 <code>/</code>로 시작하면 안되고 나머지는 상관없는 것이다.</p>\n<pre><code>/*\n  MultiLineNotAsteriskChar MultiLineCommentChars(option)\n  * MultiLineNotForwardSlashOrAsteriskChar MultiLineCommentChars(option)\n*/\n</code></pre>\n<h2>2.2. 취급</h2>\n<p><code>/* */</code>형식의 주석이 한 줄이라면 한 줄 주석과 같이 공백으로 취급된다.</p>\n<p>단 만약 여러 줄 주석이 LineTerminator를 포함하면 전체 주석은 파싱을 위해 LineTerminator로 간주된다.</p>\n<h2>2.3. 유래</h2>\n<p><code>/* */</code> 로 감싼 여러 줄 주석 형식은 C보다도 먼저 나왔던 PL/1이라는 언어에서 비롯되었다. 이 언어는 1964년에 IBM에서 만들었는데 당시에 용도별로 분리되어 있던 많은 언어들을 하나로 통합하고자 하는 시도였다.</p>\n<p>PL/1에서는 문자열 리터럴을 제외하고는 <code>/* */</code>이 문자 조합이 거의 나타나지 않았기 때문에 이를 주석으로 사용하였다. 하지만 JS에서는 정규 표현식에서도 이런 조합이 나타날 수 있다. 그래서 이 주석 방식은 문제를 일으킬 수 있다.</p>\n<p>더글라스 크락포드의 '자바스크립트 핵심 가이드'에서는 다음과 같은 코드를 예시로 제시한다. 이 코드는 구문 오류를 발생시킨다.</p>\n<pre><code class=\"language-js\">/*\n  var rm_a = /a*/.match(s);\n*/\n</code></pre>\n<p>그래서 Javascript에서는 <code>//</code>를 사용하는 게 권장될 때가 많다.</p>\n<h1>3. Hashbang Comments</h1>\n<p>ECMA 명세에는 다른 종류의 주석들도 정의되어 있다. Hashbang Comments와 HTML-like Comments이다. 이 섹션에서는 Hashbang Comments에 대해서 알아보자.</p>\n<h2>3.1. 문법</h2>\n<p>이는 hashbang 혹은 shebang이라고 부르는 <code>#!</code>로 시작하는 한 줄 주석이다. 그리고 <code>#!</code> 이전에 공백이 있으면 안된다.</p>\n<p>한 줄 주석이므로 역시 주석을 끝내는 <code>LineTerminator</code>를 제외한 모든 글자를 쓸 수 있다. 명세는 다음과 같다.</p>\n<pre><code>HashbangComment ::\n  #! SingleLineCommentChars(option)\n</code></pre>\n<p>이 주석은 그 특성상 스크립트 혹은 모듈의 첫 시작 부분에서만 유효하다. 어떤 특성인지는 다음 섹션에서 알아본다.</p>\n<h2>3.2. Hashbang Comments의 목적</h2>\n<p>이는 원래 Unix계열의 운영체제에서 사용되던 것이다. <code>#!</code>로 시작하는 문자열이 첫 줄에 있는 파일은 해당 파일을 실행할 때 <code>#!</code> 이후의 문자열을 인터프리터로 사용한다. 예를 들어 <code>#!bin/bash</code>로 시작하는 파일은 bash 쉘 인터프리터로 실행된다.</p>\n<p>Javascript에서도 비슷한 목적으로 해당 주석 형식이 도입되었다. 이는 스크립트나 모듈 파일에 처음에 선언되어서 해당 코드를 실행할 때 어떤 Javascript 인터프리터를 사용할지 명시하는 역할을 한다. 그리고 문법적으로는 한 줄 주석과 같다.</p>\n<p>스크립트가 쉘에서 돌아가지 않는 이상 이 주석은 일반적인 한 줄 주석과 완전히 같은 의미를 갖는다.</p>\n<pre><code class=\"language-js\">#!/usr/bin/env node\n\nconsole.log(\"Hello world\");\n</code></pre>\n<p>이는 서버사이드 Javascript에서 유용하다. 서버에는 여러 Javascript 인터프리터가 있을 수 있는데 이 주석을 통해서 어떤 인터프리터를 사용할지 명시할 수 있기 때문이다.</p>\n<p>그런 유용한 점 때문에 표준에 도입되기 전에도 Node.js와 같은 브라우저 이외의 Javascript 환경에서 사실상의 표준(de facto standard)로 사용되었다.</p>\n<p>당연하지만 이 hashbang comment를 한 줄 주석을 위해 써서는 안된다. 스크립트 혹은 모듈의 첫 줄에서만 유효하기 때문이다. 사용할 인터프리터를 명시하기 위함이라는 주석의 목적을 생각해도 한 줄 주석을 위해 쓰면 안된다.</p>\n<h1>4. HTML-like Comments</h1>\n<p>ECMA-262 명세의 <a href=\"https://tc39.es/ecma262/#sec-additional-syntax\">B.1 Additional Syntax</a>항목을 보면 첫 항목에 HTML-like comments가 정의되어 있다. 이는 HTML 주석 문법인 <code>&#x3C;!--</code>와 <code>--></code>를 이용한 주석이다.</p>\n<h2>4.1. 문법</h2>\n<p><code>&#x3C;!--</code>은 <code>SingleLineHTMLOpenComment</code>로 정의되어 있다. 한 줄 주석과 똑같이 작동하여 <code>LineTerminator</code>를 제외한 모든 글자를 포함할 수 있다.</p>\n<pre><code>SingleLineHTMLOpenComment ::\n  &#x3C;!-- SingleLineCommentChars(option)\n</code></pre>\n<p>이런 식으로 쓰일 수 있다.</p>\n<pre><code class=\"language-js\">console.log(1); &#x3C;!-- 한줄주석\n</code></pre>\n<p><code>--></code>은 <code>SingleLineHTMLCloseComment</code>로 정의되어 있다. 주석 내용 자체는 한 줄 주석과 똑같이 작동하여 <code>--></code> 다음에 오는 같은 줄의 글자들을 주석 처리한다. 단 <code>--></code>이전에는 공백, 줄바꿈 혹은 한 줄로 제한된 주석만 있어야 하고 다른 글자가 있으면 안된다.</p>\n<p>명세의 구조를 풀어 쓰면 다음과 같다.</p>\n<pre><code>SingleLineHTMLCloseComment ::\n  LineTerminatorSequence WhiteSpaceSequence(option)  SingleLineDelimitedCommentSequence(option) --> SingleLineCommentChars(option)\n</code></pre>\n<p>이런 식으로 쓰는 것이다.</p>\n<pre><code class=\"language-js\">*/ --> 주석내용\n--> 한줄주석\nconsole.log(1); --> 한줄주석 // 이건 --> 이전에 다른 글자가 와서 안된다.\n</code></pre>\n<h2>4.2. 목적<sup><a href=\"#user-content-fn-1\" id=\"user-content-fnref-1\" data-footnote-ref=\"\" aria-describedby=\"footnote-label\">1</a></sup></h2>\n<p>Javascript는 1995년에 처음 나왔는데, 그 이전에 나온 브라우저들도 있었다. 따라서 Javascript의 초기에는 Javascript를 지원하지 않는 구식 브라우저들이 많았다.</p>\n<p>예를 들어 1993년에 나온 모자이크에는 Javascript를 처리하는 기능이 없었다. Javascript를 처음으로 도입했던 건 1995년 9월에 나온 넷스케이프 네비게이터 2라는 브라우저였다. 당연히 Javascript를 포함하는 <code>&#x3C;script></code>태그를 제대로 처리할 수도 없었다.</p>\n<p>따라서 Javascript를 HTML 문서의 <code>&#x3C;script></code>태그에 포함한 경우 구식 브라우저에서의 호환성 문제가 있었다. 구식이지만 당시 많은 사람들이 사용하고 있었던, Javascript를 지원하지 않는 브라우저들의 경우 <code>&#x3C;script></code> 요소를 만나면 해당 요소의 본문을 웹 페이지에 일반 텍스트로 표시해버렸다.</p>\n<p>이 문제는 HTML 주석으로 스크립트 본문을 감싸는 것으로 방지할 수 있었다. 이런 식으로 말이다.</p>\n<pre><code class=\"language-html\">&#x3C;script>\n  &#x3C;!-- This is an HTML comment surrounding a script body\n  alert(\"this is a message from JavaScript\"); // not visible to old browsers\n  // the following line ends the HTML comment\n  -->\n&#x3C;/script>\n</code></pre>\n<p>이런 코딩 패턴을 사용하면 구식 브라우저는 전체 스크립트 본문을 HTML 주석으로 인식하고 페이지에 표시하지 않았다. 하지만 이런 패턴을 사용시 HTML의 주석 구분자 <code>&#x3C;!--</code>이 Javascript 코드에서 문법적으로 유효하지 않았기 때문에 Javascript를 지원하는 브라우저가 스크립트 본문을 제대로 파싱하고 실행하지 못했다.</p>\n<p>이 문제를 피하기 위해 Javascript 1.0에서는 <code>&#x3C;!--</code>가 한 줄 주석의 시작으로 인식되도록 했다. 당시에는 <code>--></code>는 주석이 아니기는 했다. 이 패턴을 사용할 때 <code>--></code>의 앞에 <code>//</code>를 두는 것으로 충분했기 때문이다.</p>\n<p>아무튼 HTML 문서에 Javascript를 삽입할 때 이제 다음과 같이 하면 하위 호환성을 지킬 수 있었다.</p>\n<pre><code class=\"language-html\">&#x3C;script>\n  &#x3C;!-- This is an HTML comment in old browsers and a JS single line comment\n  alert(\"this is a message from JavaScript\"); // not visible to old browsers\n  // the following line ends the HTML comment and is a JS single line comment\n  // -->\n&#x3C;/script>\n</code></pre>\n<p>이런 방법이 오래도록 많은 웹 개발자들에게 사용된 결과 표준화된 것이 위의 문법이다.</p>\n<h1>5. 결론</h1>\n<p>이렇게 Javascript에 존재하는 여러 주석 형식들을 알아보았다. 이 중에서도 Hashbang Comments와 HTML-like Comments는 특별한 목적을 위해 도입된 것이다. 따라서 결국은 <code>//</code>을 한 줄 주석으로, <code>/* */</code>를 여러 줄 주석으로 사용하는 게 가장 좋다. 코드 작성시에 굳이 다른 주석 형식을 사용할 필요는 없다.</p>\n<p>하지만 이런 주석 형식들이 왜 도입되었는지, 어떤 목적을 위해 도입되었는지 알아보는 것은 많은 토막지식들을 전해 주었다. 브라우저가 아닌 환경에서 Javascript 실행시 사용할 인터프리터를 정하는 Hashbang Comments, Javascript의 초기에 브라우저 호환성을 위해 사용되던 HTML-like Comments 등은 Javascript가 걸어온 길들의 단면을 보여 준다.</p>\n<h1>참고</h1>\n<p>더글라스 크락포드 저, 김명신 옮김, 더글라스 크락포드의 자바스크립트 핵심 가이드, 한빛미디어, 2008</p>\n<p>ECMA-262의 12.4 Comments <a href=\"https://tc39.es/ecma262/#sec-comments\">https://tc39.es/ecma262/#sec-comments</a></p>\n<p>ECMA-262의 B.1 Additional Syntax <a href=\"https://tc39.es/ecma262/#sec-additional-syntax\">https://tc39.es/ecma262/#sec-additional-syntax</a></p>\n<p>Hashbang Comments - The Third Way of Adding Comments in Javascript Code <a href=\"https://usefulangle.com/post/273/javascript-hashbang-comments\">https://usefulangle.com/post/273/javascript-hashbang-comments</a></p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#hashbang_comments\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#hashbang_comments</a></p>\n<p>Javascript HTML-like Comments <a href=\"https://pakss328.medium.com/javascript-commnet-%EC%A2%85%EB%A5%98-b047be8a8696\">https://pakss328.medium.com/javascript-commnet-%EC%A2%85%EB%A5%98-b047be8a8696</a></p>\n<p>해시뱅(#!)에 대해서... <a href=\"https://blog.outsider.ne.kr/698\">https://blog.outsider.ne.kr/698</a></p>\n<p>JavaScript: the first 20 years <a href=\"https://dl.acm.org/doi/10.1145/3386327\">https://dl.acm.org/doi/10.1145/3386327</a></p>\n<section data-footnotes=\"\" class=\"footnotes\"><h2 class=\"sr-only\" id=\"footnote-label\">Footnotes</h2>\n<ol>\n<li id=\"user-content-fn-1\">\n<p>이 문단은 Javascript의 20년간의 역사를 다룬 <a href=\"https://dl.acm.org/doi/10.1145/3386327\">Javascript: the first 20 years</a>를 참고해서 쓰였다. <a href=\"#user-content-fnref-1\" data-footnote-backref=\"\" aria-label=\"Back to reference 1\" class=\"data-footnote-backref\">↩</a></p>\n</li>\n</ol>\n</section>",
    "excerpt": "썸네일\n\n시작\nJavascript 명세 등 여러 자료를 보면서 알게 된 주석 관련 이야기들을 정리하였다.\n//와 /* */로 각각 한 줄 주석과 여러 줄 주석을 만들 수 있다는 것은 알고 있었다.\n하지만 명세에는 #!로 시작하는 Hashbang Comments와 HTML 주석 형식인 <!--와 -->로 감싸는 HTML-like Comments등 다른 것도 정의되어 있었다.\n또한 주석은 일반적으로 공백처럼 동작하는 것, /* */주석이 어디에서 유래되었는지 등도 ",
    "headingTree": [
      {
        "title": "썸네일",
        "url": "#썸네일",
        "items": []
      },
      {
        "title": "시작",
        "url": "#시작",
        "items": []
      },
      {
        "title": "1. 한 줄 주석",
        "url": "#1-한-줄-주석",
        "items": [
          {
            "title": "1.1. 문법",
            "url": "#11-문법",
            "items": []
          },
          {
            "title": "1.2. 취급",
            "url": "#12-취급",
            "items": []
          }
        ]
      },
      {
        "title": "2. 여러 줄 주석",
        "url": "#2-여러-줄-주석",
        "items": [
          {
            "title": "2.1. 문법",
            "url": "#21-문법",
            "items": []
          },
          {
            "title": "2.2. 취급",
            "url": "#22-취급",
            "items": []
          },
          {
            "title": "2.3. 유래",
            "url": "#23-유래",
            "items": []
          }
        ]
      },
      {
        "title": "3. Hashbang Comments",
        "url": "#3-hashbang-comments",
        "items": [
          {
            "title": "3.1. 문법",
            "url": "#31-문법",
            "items": []
          },
          {
            "title": "3.2. Hashbang Comments의 목적",
            "url": "#32-hashbang-comments의-목적",
            "items": []
          }
        ]
      },
      {
        "title": "4. HTML-like Comments",
        "url": "#4-html-like-comments",
        "items": [
          {
            "title": "4.1. 문법",
            "url": "#41-문법",
            "items": []
          },
          {
            "title": "4.2. 목적[^1]",
            "url": "#42-목적1",
            "items": []
          }
        ]
      },
      {
        "title": "5. 결론",
        "url": "#5-결론",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 356
    },
    "url": "/posts/javascript-various-comments",
    "thumbnail": {
      "local": "/static/js-comment-4286d81c.webp",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-js-comment-4286d81c-webp",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAADCAIAAAAhqtkfAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAVklEQVR4nAFLALT/AP/1WuzWEv/wJUtFAF9WACERAGddAP/zWAD351TLtgD/6B9BOgB+cgBxZgAuIwDk2E4A//9c/+wjq5sAKBwAcmgAopMAHAQAf3g43SgeYl8q3HkAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "javascript-trip-of-js-value-where-value-stored",
    "title": "JS 탐구생활 - JS의 값은 스택과 힙 중 어디에 저장되는가?",
    "date": "2024-03-02T01:00:00Z",
    "description": "Javascript는 어디에 값을 저장하는가",
    "tags": [
      "javascript",
      "jsvalue"
    ],
    "html": "<p><img src=\"/static/image-1-7d2deb00.png\" alt=\"썸네일\"></p>\n<h1>시리즈</h1>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>제목</th><th>링크</th></tr></thead><tbody><tr><td>JS의 값은 스택과 힙 중 어디에 저장되는가?</td><td><a href=\"https://witch.work/posts/javascript-trip-of-js-value-where-value-stored\">https://witch.work/posts/javascript-trip-of-js-value-where-value-stored</a></td></tr><tr><td>JS 엔진이 값을 저장하는 방법, tagged pointer와 NaN boxing</td><td><a href=\"https://witch.work/posts/javascript-trip-of-js-value-tagged-pointer-nan-boxing\">https://witch.work/posts/javascript-trip-of-js-value-tagged-pointer-nan-boxing</a></td></tr></tbody></table>\n<p>이 글은 <a href=\"https://twitter.com/finalchildmc/status/1751818395669106722\">파차님의 트윗</a>을 보고 영감을 얻어 작성하게 되었다.</p>\n<p>이 글은 \"Javascript에서 원시값은 스택에, 객체는 힙에 저장된다\"는 흔한 설명이 틀렸다는 것을 보여주고, Javascript의 모든 값이 왜 힙에 저장되어야 하는지 설명한다. 또한 Javascript의 명세와 엔진 구현체에서 어떻게 값을 저장하도록 하는지 간략히 설명한다.</p>\n<h1>1. 흔한 설명</h1>\n<p>Javascript의 값은 원시값과 객체로 나뉜다. 원시값은 숫자, 문자열, 불리언, null, undefined, 심볼이 있고 객체는 함수, 배열, Map 등 원시값을 제외한 모든 것이다. 그럼 이러한 값들은 어디에 저장될까?</p>\n<p>일반적으로 널리 퍼진 설명은 원시값들은 스택에 값 그대로 저장되며 객체는 힙에 저장된다고 이야기한다. 이런 설명은 쉽게 찾을 수 있고 <a href=\"https://github.com/leonardomso/33-js-concepts?tab=readme-ov-file#3-value-types-and-reference-types\">60K가 넘는 스타를 받은 33-js-concepts에도 이렇게 값으로 저장되는 타입과 참조로 저장되는 타입이 있다는 가정을 기반으로 한 항목이 있다.</a></p>\n<p><strong>그러나 이런 설명은 틀렸다.</strong> Javascript에서는 원시값을 포함한 모든 것이 원칙적으로 힙에 저장되고 그걸 가리키는 포인터를 통해 사용된다.</p>\n<p>물론 엔진마다 약간씩 다른 최적화 기법들이 있고 여기에 따라 몇몇 값들이 스택에 직접 저장되기도 한다. 언젠가 이에 대해서도 다룰 예정이다. 하지만 그것들은 어디까지나 동작에 영향을 주지 않는 선에서 진행되는 최적화이며 Javascript의 모든 값은 원래 힙에 저장된다.</p>\n<h1>2. 흔한 설명의 문제</h1>\n<p>객체는 유명한 설명대로 힙에 저장된다고 치고, 원시값이 스택에 그대로 저장된다고 하자. 그렇게 하면 대표적으로 2가지의 문제가 생긴다.</p>\n<h2>2.1. 메모리 할당 문제</h2>\n<p>스택에 어떤 값을 저장하기 위해서는 해당 값이 얼만큼의 크기를 가지고 있는지를 미리 알아야 한다. 그런데 Javascript는 동적 타입 언어이기 때문에 변수에 할당되는 값의 타입이 언제든지 바뀔 수 있으며 변수 생성 시점에 이 타입을 알 수도 없다.</p>\n<p>또한 Javascript는 실행 컨텍스트 생성 시점에 모든 변수 선언을 최상단으로 끌어올리고 메모리 할당 작업을 하기 때문에 얼만큼의 메모리를 할당해야 하는지 아는 것은 더 힘들어진다. <code>let</code>, <code>const</code>도 변수 초기화 작업을 하지 않을 뿐 선언은 끌어올려진다.</p>\n<p>만약 특정 변수에 늘 같은 타입의 원시값만 저장된다고 해도 원시값에 문자열도 포함된다는 게 문제다. 문자열은 길이에 따라 차지하는 메모리 크기가 달라지기 때문에 문자열을 값 그대로 저장하기 위해서는 얼만큼의 메모리를 할당해야 하는지 미리 알 수는 없다.</p>\n<h2>2.2. 클로저의 문제</h2>\n<p>물론 이는 문자열 등 필요한 메모리를 미리 알 수 없는 원시값의 경우 참조를 통해 다루고 이 참조를 스택에 저장하면 된다고 할 수도 있다. 하지만 그렇게 한다 해도 클로저 때문에 발생하는 문제가 있다.</p>\n<p>스택에 저장된 값들은 원칙적으로 함수가 종료되어서 콜스택에서 사라짐과 동시에 없어져야 한다. 하지만 Javascript에는 클로저가 있기 때문에 함수가 종료되어도 함수 내부의 변수가 메모리에서 사라지지 않아야 하는 경우가 있다.</p>\n<p>가령 다음과 같은 흔한 클로저 예시 코드에서 <code>count</code>는 원시값이므로 스택에 저장된다고 하자. <code>count</code>는 숫자이므로 메모리 할당에 대한 문제도 없다. 하지만 <code>count</code>는 내부 함수의 클로저를 통해 접근 가능하다. 따라서 함수가 종료되어도 <code>count</code>는 메모리에서 사라지지 않아야 한다.</p>\n<p>그런데 <code>count</code>를 포함하는 함수인 <code>makeCounter</code>가 이미 콜스택에서 사라졌는데, 그 내부 변수인 <code>count</code>는 스택의 어디에 남아있어야 하는가?</p>\n<pre><code class=\"language-js\">function makeCounter() {\n  let count = 0;\n  return function() {\n    return count++;\n  }\n}\n\nlet counter = makeCounter();\n</code></pre>\n<p>하지만 Javascript에서는 이런 문제가 발생하지 않는다. 이는 값이 스택에 저장되지 않고 힙에 저장되기 때문이다.</p>\n<h1>3. 명세에서</h1>\n<p>그럼 ECMA-262 명세에서는 값의 저장에 대해서 어떻게 정의하고 있을까? 모든 Javascript 구현체는 ECMA-262 명세를 따르기 때문에 이를 통해서 값이 어떻게 저장되어 있는지 엿볼 수 있을 것이다.</p>\n<p>ECMA-262 명세에서는 \"Reference Record\"라는 명세상의 타입을 정의한다. 변수나 프로퍼티에 접근하거나 값을 할당할 때, 해당 값을 어디에 읽고 쓸지 그 위치를 가리키는 역할을 한다. 이 타입은 실제로 Javascript 문법에 존재하는 건 아니고 명세를 위해 도입된 타입이다.</p>\n<p>그런데 여기에는 <code>[[Value]]</code>같이 무언가 값을 직접적으로 가리키는 필드가 없다. 여기에 값을 저장하는 것에 관해서는 <a href=\"https://tc39.es/ecma262/#sec-reference-record-specification-type\">Reference Record의 <code>[[Base]]</code> 필드의 설명에서 찾을 수 있다.</a></p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>Field Name</th><th>Value</th><th>Meaning</th></tr></thead><tbody><tr><td>[[Base]]</td><td>an ECMAScript language value, an Environment Record, or UNRESOLVABLE</td><td>The value or Environment Record which holds the binding. A [[Base]] of UNRESOLVABLE indicates that the binding could not be resolved.</td></tr></tbody></table>\n<p>보면 <code>[[Base]]</code> 필드는 ECMAScript language value, Environment Record, UNRESOLVABLE 중 하나를 가리킨다. 이 중 \"ECMAScript language value\"가 바로 값인데 이에 대한 명세를 보면 우리가 흔히 Javascript의 값 종류라고 부르는 다음과 같은 것들이 여기 해당한다.</p>\n<ul>\n<li>Undefined</li>\n<li>Null</li>\n<li>Boolean</li>\n<li>String</li>\n<li>Symbol</li>\n<li>Number</li>\n<li>Object</li>\n</ul>\n<p>즉 Javascript에서 값은 Reference Record의 <code>[[Base]]</code> 필드가 가리키는 \"ECMAScript language value\"이다. 이는 값이 힙에 저장된다는 것을 정확히 명시하지는 않지만, 적어도 직접적으로 저장되지 않는다는 점을 암시한다.</p>\n<p>많은 언어 명세에서 무엇이 스택에 저장되고 힙에 저장되는지는 커녕 스택, 힙이라는 단어의 언급조차 하지 않는 것을 생각해 볼 때 이렇게 값이 간접적으로 참조된다고 명시하는 것은 값을 힙에 저장한다는 것을 꽤나 명확하게 암시하는 것이라고 볼 수 있다.</p>\n<p>그럼 이제 Javascript 엔진에서 이를 어떻게 구현하는지 간단히 살펴보자.</p>\n<h1>4. 실제 구현에서</h1>\n<p>이 섹션에서는 거의 모든 엔진에서 값을 저장할 때 공통적으로 사용하는 방식을 설명한다. 엔진에서 구체적으로 어떻게 구현되어 있는지는 다음 섹션들에서 다룬다.</p>\n<h2>4.1. 변수와 값</h2>\n<p>먼저 '변수'와 '변수가 가리키는 것' 즉 실제 값을 구별해야 한다. 변수는 최적화를 고려하지 않으면 일종의 포인터로 볼 수 있고 다른 어딘가에 저장된 객체를 가리키는 참조를 가지고 있다.</p>\n<p>이는 모든 변수가 포인터 하나만큼의 크기만을 차지하며 변수가 시간에 따라 다른 객체를 참조하게 되는 경우에도 변수가 필요로 하는 메모리 크기가 변하지 않는다는 것을 의미한다.</p>\n<p>가령 배열을 순회하는 경우에도 순회하는 값을 가리키는 변수는 항상 포인터 하나만큼의 메모리만 차지한다.</p>\n<pre><code class=\"language-js\">let arr = [1, \"Hi my name is...\", true, null, Symbol(\"symbol\")];\nlet elem;\nfor (let i = 0; i &#x3C; arr.length; i++) {\n  // arr[i]가 가리키는 객체는 계속 달라지지만 elem은 항상 포인터 하나만큼의 메모리만 차지한다.\n  elem = arr[i];\n}\n</code></pre>\n<p>반면 변수가 가리키는 값이란 변수에 저장된 포인터가 가리키는 값 그 자체를 가리킨다. 예를 들어 <code>var a = \"hello\"</code> 같은 문장에서 <code>a</code>는 변수, <code>\"hello\"</code>는 값이다. 값은 당연히 크기가 고정되어 있지 않다.</p>\n<p>그리고 변수와 값, 이 모든 것은 원래는 힙에 저장되어야 한다.</p>\n<h2>4.2. 저장</h2>\n<p>앞서 언급했듯이 Javascript에서 모든 것은 원칙적으로 힙에 저장된다. 따라서 모든 변수(에 담긴 포인터)와 변수가 가리키는 값들 모두가 힙에 저장되어도 문제없다.</p>\n<p>하지만 실제로는 몇 가지 최적화가 들어간다. 이 섹션에서 다룰 내용은 \"원래 모든 것이 힙에 저장되는 것\"이지만 거의 모든 Javascript 엔진에서 공통으로 적용하는 예외 사항에 대해 다룬다. 언제까지나 기본은 모든 것이 힙에 저장된다는 거라는 걸 잊지 말아야 한다.</p>\n<h3>4.2.1. 최적화 - 지역 변수</h3>\n<p>먼저 최신 Javascript 엔진들은 보통 함수의 지역 변수들을 스택에 저장한다. <strong>변수가 가리키는 값을 저장하는 게 아니고 변수를 저장하는 것이다.</strong> 변수가 무엇을 가리키건 포인터 하나만큼의 메모리씩만 차지하고 있기에 메모리 할당에 대한 문제도 없고 속도도 빠르기 때문이다.</p>\n<p>그런데 만약 클로저, <code>eval</code>의 사용 등의 문제로 함수가 종료된 이후에도 변수가 메모리에 남아 있어야 한다면 이러한 값은 스택에 저장할 수 없다.</p>\n<p>따라서 엔진은 어떤 변수가 함수 종료 이후에도 메모리에 존재해야 하는지 추적하고 이 변수들은 힙에 저장한다. 보통 클로저에 사용되는 변수들이 이에 해당한다.</p>\n<h3>4.2.2. 최적화 - 정수</h3>\n<p>변수가 가리키는 값도 원시값이든 객체든 원래는 모두 힙에 저장되지만 예외들이 좀 있다. 가장 흔한 예외는 정수에 관한 것인데 정수는 프로그램에서 너무 많이 쓰이기 때문에 보통 최신 엔진들은 일정 범위의 부호 있는 정수는 스택에 값 그대로 저장한다.</p>\n<p>V8의 tagged pointer, SpiderMonkey의 NaN-boxing 등의 기법이 여기에 해당한다. 이는 최적화로서 엔진마다 구현은 다르지만 정수를 스택에 그대로 저장할 수 있게 한다는 건 동일하다.</p>\n<p>이외에도 함수의 호출이 많아져서 특정 부분의 코드가 최적화가 요구될 만큼 'hot'해지면 객체의 특정 프로퍼티를 스택에 저장하는 등 엔진에서 다른 최적화를 하기도 한다. 이후 글에서 다룰지도 모른다.</p>\n<h1>5. 실제 엔진에서 - SpiderMonkey</h1>\n<p>그럼 이제 실제 Javascript 엔진에서는 값이 어떻게 저장되는지 알아보자. 먼저 주요 엔진 중 하나인 SpiderMonkey에서는 어떻게 값이 저장되는지 알아보자.</p>\n<p><a href=\"https://spidermonkey.dev/\">SpiderMonkey 공식 사이트</a>에서는 <a href=\"https://searchfox.org/mozilla-central/source/js/src\">SpiderMonkey의 코드를 찾아볼 수 있는 페이지</a>가 있다. 이곳의 검색 기능을 활용하면 이 글과 같은 코드를 찾아볼 수 있다.</p>\n<h2>5.1. 문자열의 저장</h2>\n<p>이 글의 시작을 돌아보면 \"원시값은 값 그대로 스택에 저장된다\"는 흔한 설명이 틀렸으며 Javascript의 거의 모든 값은 힙에 저장된다는 사실을 설명하기 위해서였다. 그러면 SpiderMonkey는 대표적인 원시값인 문자열을 어떻게 저장할까?</p>\n<p>SpiderMonkey 중간중간에 있는 <code>[SMDOC]</code> 주석은 SpiderMonkey의 동작 방식을 대략적으로 설명하는데 <a href=\"https://searchfox.org/mozilla-central/source/js/src/vm/StringType.h#80\"><code>src/vm/StringType.h</code> 파일의 주석</a>을 참고하면 문자열이 어떻게 저장되는지 알 수 있다. 사실상 설명의 초반 부분이 우리가 원하는 핵심이다.</p>\n<p>선형 문자열의 가장 일반적인 형태는 GC \"heap\"과 malloc된 char 배열로 구성된다고 한다. 어쨌든 힙에 저장된다는 건 확실하다! 물론 이후 찾아보면 스택에 저장되는 경우도 있다는 주석이 있지만 일반적으로는 힙에 저장된다.</p>\n<pre><code class=\"language-cpp\">/*\n * [SMDOC] JavaScript Strings\n *\n * Conceptually, a JS string is just an array of chars and a length. This array\n * of chars may or may not be null-terminated and, if it is, the null character\n * is not included in the length.\n *\n * To improve performance of common operations, the following optimizations are\n * made which affect the engine's representation of strings:\n *\n *  - The plain vanilla representation is a \"linear\" string which consists of a\n *    string header in the GC heap and a malloc'd char array.\n *\n *  - To avoid copying a substring of an existing \"base\" string , a \"dependent\"\n *    string (JSDependentString) can be created which points into the base\n *    string's char array.\n *\n (이후 최적화에 관한 부분들 생략)\n */\n</code></pre>\n<p>이는 코드를 통해서도 어느 정도 확인할 수 있다.</p>\n<p>SpiderMonkey의 <code>JSString</code> 클래스에는 경우에 따라 다르긴 하지만 많은 경우에 실제 문자열 데이터를 담고 있는 <code>Data</code>라는 내부 클래스가 있다. 해당 클래스는 <code>JSLinearString</code> 등의 클래스를 이용하여 내부 데이터를 표현한다.</p>\n<p>그런데 이들은 어떻게 관리될까? 이후 가비지 컬렉터 관련 글에서 다시 보겠지만 대부분의 Javascript 엔진은 힙을 여러 영역으로 나누어 관리한다.</p>\n<p>가장 대표적인 구분은 생긴지 얼마 안 된 객체와 오래된 객체를 나누는 것인데 SpiderMonkey에서는 이를 <code>nursery</code>와 <code>tenured</code>로 나누어 관리한다. 당연히 이름대로 <code>nursery</code>에는 생긴지 얼마 안 된 객체들이 있고 <code>tenured</code>에는 오래된 객체들이 있다.</p>\n<p>만약 문자열이 <code>nursery</code>에서 생긴다면 결과적으로 <code>cx->newCell</code>이라는 함수를 호출하게 된다. 그 함수의 원형은 <code>src/gc/Allocator-inl.h</code>에서 찾을 수 있다.</p>\n<p>함수 본문에서 <code>NewString</code>이라는 함수를 호출한다는 것만 보면 된다.</p>\n<pre><code class=\"language-cpp\">// js/src/gc/Allocator-inl.h\ntemplate &#x3C;typename T, AllowGC allowGC, typename... Args>\nT* CellAllocator::NewCell(JSContext* cx, Args&#x26;&#x26;... args) {\n  // ...생략...\n\n  // \"Normal\" strings (all of which can be nursery allocated). Atoms and\n  // external strings will fall through to the generic code below. All other\n  // strings go through NewString, which will forward the arguments to the\n  // appropriate string class's constructor.\n  else if constexpr (std::is_base_of_v&#x3C;JSString, T> &#x26;&#x26;\n                     !std::is_base_of_v&#x3C;JSAtom, T> &#x26;&#x26;\n                     !std::is_base_of_v&#x3C;JSExternalString, T>) {\n    return NewString&#x3C;T, allowGC>(cx, std::forward&#x3C;Args>(args)...);\n  }\n    // ...생략...\n}\n</code></pre>\n<p>그리고 <code>NewString</code> 함수는 같은 파일에 다음과 같이 정의되어 있다. <code>new</code> 를 이용해서 새 인스턴스를 생성하므로 힙에 저장될 거라는 사실을 알 수 있다.</p>\n<pre><code class=\"language-cpp\">template &#x3C;typename T, AllowGC allowGC, typename... Args>\n/* static */\nT* CellAllocator::NewString(JSContext* cx, gc::Heap heap, Args&#x26;&#x26;... args) {\n  // ...생략...\n  return new (mozilla::KnownNotNull, ptr) T(std::forward&#x3C;Args>(args)...);\n}\n</code></pre>\n<p>그러다가 문자열이 생성된 지 오래되어서 <code>tenured</code>로 옮겨지게 되면 <code>ensureNonNursery</code>라는 함수를 호출하게 된다. 이것의 원형은 <code>src/vm/StringType-inl.h</code>에서 찾을 수 있다.</p>\n<pre><code class=\"language-cpp\">template &#x3C;typename CharT>\nvoid JSString::OwnedChars&#x3C;CharT>::ensureNonNursery() {\n  // 생략\n\n  CharT* ptr = js_pod_arena_malloc&#x3C;CharT>(js::StringBufferArena, length);\n  if (!ptr) {\n    oomUnsafe.crash(chars_.size(), \"moving nursery buffer to heap\");\n  }\n  mozilla::PodCopy(ptr, oldPtr, length);\n  chars_ = mozilla::Span&#x3C;CharT>(ptr, length);\n  isMalloced_ = needsFree_ = true;\n}\n</code></pre>\n<p>여기서 중요한 건 <code>js_pod_arena_malloc</code> 함수를 호출한다는 것이다. 이 함수는 <code>src/gc/Allocator.cpp</code>에 정의되어 있다. 이 함수를 따라가다 보면 <code>moz_arena_malloc</code>이 나오고 더 따라가면 직접 힙 주소를 관리하는 <code>MaybePageAlloc</code> 을 호출하거나 결국은 <code>malloc</code>을 호출하도록 이어지는 <code>MozJemalloc::malloc</code>을 호출하게 된다.</p>\n<p>결국 문자열은 <code>new</code>를 사용해서 생성된 인스턴스로 관리되든, 엔진이 직접 주소를 관리하는 힙에 들어가든, <code>malloc</code>으로 할당된 메모리에 들어가든 결국은 힙에 저장된다는 것이다.</p>\n<p>원시값 중 하나인 문자열은, SpiderMonkey에서도 역시 힙에 저장된다!</p>\n<h2>5.2. 객체의 저장</h2>\n<p>우리는 객체가 힙에 저장된다는 걸 이미 알고 있긴 하지만, SpiderMonkey에서 객체가 어떻게 힙에 저장되는지도 간단히 살펴보자.</p>\n<p>key-value 쌍으로 이루어진 대부분의 Javascript 객체는 SpiderMonkey에서 <code>JSObject</code>를 상속하는 <code>NativeObject</code>라는 클래스를 이용하여 저장된다. 이 클래스는 <code>src/vm/NativeObject.h</code>에 정의되어 있다.</p>\n<p>먼저 SpiderMonkey에서는 Javascript 객체를 생성할 때 <code>JS_NewObject</code> 함수를 호출한다. 만약 특정 클래스의 객체가 아니라면 <code>js::NewPlainObject</code>를 호출한다.</p>\n<p>그러면 내부적으로 객체의 모양을 나타내는 히든 클래스(spidermonkey에서는 shape라 한다)와 함께 <code>js::PlainObject::createWithShape</code>를 호출한다. 이는 따라가 보면 위에서 보았던 <code>js/src/gc/Allocator-inl.h</code>의 <code>NewCell</code> 함수를 호출하게 된다.</p>\n<p>그럼 여기서는 또 같은 파일의 <code>NewObject</code>를 호출하는데 <code>NewObject</code> 함수에서도 <code>new</code>로 새 인스턴스를 생성하므로 결국은 객체가 힙에 저장된다는 것을 알 수 있다.</p>\n<pre><code class=\"language-cpp\">// js/src/jsapi.cpp\nJS_PUBLIC_API JSObject* JS_NewObject(JSContext* cx, const JSClass* clasp)\n// js/src/vm/PlainObject.cpp\nPlainObject* js::NewPlainObject(JSContext* cx, NewObjectKind newKind)\n// js/src/vm/PlainObject-inl.h\njs::PlainObject* js::PlainObject::createWithShape(\n    JSContext* cx, JS::Handle&#x3C;SharedShape*> shape, gc::AllocKind kind,\n    NewObjectKind newKind)\n// js/src/vm/NativeObject.h 와 NativeObject-inl.h\nstatic inline NativeObject* create(JSContext* cx, gc::AllocKind kind,\n                                     gc::Heap heap, Handle&#x3C;SharedShape*> shape,\n                                     gc::AllocSite* site = nullptr);                               \n// js/src/gc/Allocator-inl.h\nT* CellAllocator::NewCell(JSContext* cx, Args&#x26;&#x26;... args)\n// js/src/gc/Allocator-inl.h\ntemplate &#x3C;typename T, AllowGC allowGC>\n/* static */\nT* CellAllocator::NewObject(JSContext* cx, gc::AllocKind kind, gc::Heap heap,\n                            const JSClass* clasp, gc::AllocSite* site) {\n\n  // ...생략...\n  return new (mozilla::KnownNotNull, cell) T();\n}\n</code></pre>\n<h1>6. 실제 엔진에서 - V8</h1>\n<p>이제 V8에서는 값이 어떻게 저장하는지 살펴보고 값이 힙에 저장된다는 것을 마지막으로 다시 한 번 확인해보자.</p>\n<p>V8의 소스 코드는 <a href=\"https://chromium.googlesource.com/v8/v8/\">google git의 V8 페이지</a>에서 볼 수 있다. 이 글은 레포를 클론받아서 보면서 작성하였다. 또한 <a href=\"https://github.com/danbev/learning-v8/blob/master/notes/heap.md\">RedHat의 Daniel Bevenius가 작성한 learing V8</a>이 많은 도움이 되었다.</p>\n<h2>6.1. V8의 메모리 할당</h2>\n<p>V8에서 값을 저장하기 위한 메모리를 관리하는 건 일단 <code>src/heap</code> 폴더의 코드들을 통해 이루어진다. 여기서 일단 값들이 힙에 저장된다는 걸 1차적으로 알 수 있다. 그리고 대부분 종류의 값, 특히 원시값들을 처음 생성하는 함수는 <code>heap/factory-base.cc</code>에 정의되어 있다. 그리고 그 대부분은 <code>AllocateRawWithImmortalMap</code>이라는 함수를 호출한다.</p>\n<pre><code class=\"language-cpp\">// src/heap/factory-base.cc\ntemplate &#x3C;typename Impl>\nTagged&#x3C;HeapObject> FactoryBase&#x3C;Impl>::AllocateRawWithImmortalMap(\n    int size, AllocationType allocation, Tagged&#x3C;Map> map,\n    AllocationAlignment alignment) {\n  // TODO(delphick): Potentially you could also pass a immortal immovable Map\n  // from OLD_SPACE here, like external_map or message_object_map, but currently\n  // no one does so this check is sufficient.\n  DCHECK(ReadOnlyHeap::Contains(map));\n  Tagged&#x3C;HeapObject> result = AllocateRaw(size, allocation, alignment);\n  DisallowGarbageCollection no_gc;\n  result->set_map_after_allocation(map, SKIP_WRITE_BARRIER);\n  return result;\n}\n</code></pre>\n<p>그리고 이건 같은 파일의 <code>AllocateRaw</code>를 호출하고 이걸 따라가 보면 결국 힙의 주소를 직접 관리하는 <code>LinearAllocationArea</code>클래스 메서드를 호출하게 된다.</p>\n<pre><code class=\"language-cpp\">// src/heap/factory-base.cc\ntemplate &#x3C;typename Impl>\nTagged&#x3C;HeapObject> FactoryBase&#x3C;Impl>::AllocateRaw(\n    int size, AllocationType allocation, AllocationAlignment alignment) {\n  return impl()->AllocateRaw(size, allocation, alignment);\n}\n\n// 중간 과정 생략\n// 생략된 중간 과정은 https://github.com/danbev/learning-v8/blob/master/notes/heap.md#pagealloctor 에서 더 볼 수 있다.\n\n// src/heap/main-allocator-inl.h\nAllocationResult MainAllocator::AllocateFastUnaligned(int size_in_bytes,\n                                                      AllocationOrigin origin) {\n  size_in_bytes = ALIGN_TO_ALLOCATION_ALIGNMENT(size_in_bytes);\n  if (!allocation_info().CanIncrementTop(size_in_bytes)) {\n    return AllocationResult::Failure();\n  }\n  Tagged&#x3C;HeapObject> obj =\n      HeapObject::FromAddress(allocation_info().IncrementTop(size_in_bytes));\n\n  MSAN_ALLOCATED_UNINITIALIZED_MEMORY(obj.address(), size_in_bytes);\n\n  return AllocationResult::FromObject(obj);\n}\n\n// src/heap/linear-allocation-area.h\n// 직접 메모리를 관리한다\n// A linear allocation area to allocate objects from.\n//\n// Invariant that must hold at all times:\n//   start &#x3C;= top &#x3C;= limit\nclass LinearAllocationArea final {\n public:\n  LinearAllocationArea() = default;\n  LinearAllocationArea(Address top, Address limit)\n      : start_(top), top_(top), limit_(limit) {\n    Verify();\n  }\n  // ...생략...\n  V8_INLINE Address IncrementTop(size_t bytes) {\n    Address old_top = top_;\n    top_ += bytes;\n    Verify();\n    return old_top;\n  }\n  // ...생략...\n}\n</code></pre>\n<p>그럼 이렇게 직접 관리되는 주소가 힙의 것일까? 어떤 트릭으로 인해 스택의 주소를 관리하도록 한 건 아닐까? 이는 V8의 메모리 공간이 어떻게 생성되는지를 살펴보면 확인할 수 있다.</p>\n<h2>6.2. V8 메모리 공간 생성 과정</h2>\n<p>V8, 정확히는 Blink 엔진에서 스레드는 <code>Isolate</code>라는 것에 대응된다. 이 <code>Isolate</code>는 초기화될 때 <code>execution/isolate.cc</code>의 <code>Isolate::Init</code>을 호출하고 여기서는 또 <code>heap/heap.cc</code>의 <code>Heap::SetUpSpaces</code>를 호출한다.</p>\n<p>이 함수에서는 V8에서 gc를 위해 관리하는 메모리 공간들을 생성하는데 실제 구현은 <code>std::make_unique</code>등을 사용해 좀 더 복잡하지만 핵심적인 로직을 간단히 나타내면 다음과 같이 <code>new</code>를 이용해 공간들을 위한 메모리를 할당하는 것이다.</p>\n<pre><code class=\"language-cpp\">void Heap::SetUpSpaces() {\n  space_[NEW_SPACE] = new_space_ =\n      new NewSpace(this, memory_allocator_->data_page_allocator(),\n                   initial_semispace_size_, max_semi_space_size_);\n  space_[OLD_SPACE] = old_space_ = new OldSpace(this);\n  space_[CODE_SPACE] = code_space_ = new CodeSpace(this);\n  space_[MAP_SPACE] = map_space_ = new MapSpace(this);\n  space_[LO_SPACE] = lo_space_ = new OldLargeObjectSpace(this);\n  space_[NEW_LO_SPACE] = new_lo_space_ =\n      new NewLargeObjectSpace(this, new_space_->Capacity());\n  space_[CODE_LO_SPACE] = code_lo_space_ = new CodeLargeObjectSpace(this);\n  ...\n}\n</code></pre>\n<p>그런데 이 <code>new</code>는 어디서 왔을까? 이 <code>new</code> 또한 C++의 원래 <code>new</code>가 아니라 오버로딩된 것이다. V8에서 읽기 전용이 아닌 모든 공간은 기본적으로 <code>BaseSpace</code> 클래스를 상속하는데 <code>heap/base-space.h</code>에 정의된 <code>BaseSpace</code>를 보면 <code>Malloced</code>를 상속함을 볼 수 있다. 그리고 이 <code>Malloced</code>의 <code>new</code> 연산자는 <code>malloc</code>을 이용하여 정의되어 있다.</p>\n<pre><code class=\"language-cpp\">// heap/base-space.h\nclass V8_EXPORT_PRIVATE BaseSpace : public Malloced {\n  // ...생략...\n}\n\n// utils/allocation.cc\nvoid* Malloced::operator new(size_t size) {\n  void* result = AllocWithRetry(size);\n  if (V8_UNLIKELY(result == nullptr)) {\n    V8::FatalProcessOutOfMemory(nullptr, \"Malloced operator new\");\n  }\n  return result;\n}\n\n// 여기서 malloc_fn은 malloc을 래핑한 base::Malloc이라는 기본값을 가지기 때문에 늘 malloc을 사용한다.\nvoid* AllocWithRetry(size_t size, MallocFn malloc_fn) {\n  void* result = nullptr;\n  for (int i = 0; i &#x3C; kAllocationTries; ++i) {\n    result = malloc_fn(size);\n    if (V8_LIKELY(result != nullptr)) break;\n    OnCriticalMemoryPressure();\n  }\n  return result;\n}\n</code></pre>\n<p>즉 Javascript에서 스레드가 처음 생성될 때 V8에서 관리하는 메모리 공간들이 <code>malloc</code>을 통해 힙에 할당되고, 그 이후 힙의 메모리 주소는 V8에 의해 관리된다. 또한 이 힙 주소를 관리하는 함수들은 Javascript에 원시값이든 객체든 새로운 값이 저장될 때마다 스택이 아니라 \"힙에\" 메모리를 할당해 준다.</p>\n<h1>7. 결론</h1>\n<p>Javascript의 값들은 원래 모두 힙에 저장되어야 하고 참조를 통해 다루어져야 한다. 원시값은 스택에 그대로 저장된다는 흔한 설명은 물론 엔진의 최적화를 고려할 경우 맞는 경우가 있을 수 있지만 대부분의 경우에는 틀린 설명이다.</p>\n<p>이는 명세에서도 암시되고, 대부분의 Javascript 엔진에 대한 설명에서 그렇게 이야기하며 실제로 엔진에서 구현된 코드를 보면 이를 확인할 수 있다. 이 글에서는 SpiderMonkey과 V8를 중심으로 설명했지만 다른 엔진들도 대부분 비슷한 방식으로 동작한다.</p>\n<p>다음 글에서는 이 힙에 포인터들을 저장할 때 사용되는 테크닉에 대해 알아보고 또한 그 포인터를 통해서 저장되는 값은 어떻게 관리되는지 알아보겠다.</p>\n<h1>참고</h1>\n<ul>\n<li><code>1. 흔한 설명</code>, <code>2. 흔한 설명의 문제</code>의 참고 링크</li>\n</ul>\n<p>이 글의 시작이 된 파차님의 트윗 <a href=\"https://twitter.com/finalchildmc/status/1751818395669106722\">https://twitter.com/finalchildmc/status/1751818395669106722</a></p>\n<p>관련해서 파차님이 푸신 타래 <a href=\"https://twitter.com/finalchildmc/status/1664895964115607556\">https://twitter.com/finalchildmc/status/1664895964115607556</a></p>\n<p>33 js Concepts에 파차님이 올리신 이슈 <a href=\"https://github.com/leonardomso/33-js-concepts/issues/481\">https://github.com/leonardomso/33-js-concepts/issues/481</a></p>\n<p>Y combinator 해커뉴스에 V8 개발자가 쓴 댓글 <a href=\"https://news.ycombinator.com/item?id=33006653\">https://news.ycombinator.com/item?id=33006653</a></p>\n<p>How v8 handle stack allocated variable in closure? 라는 질문에 V8 개발자가 단 답변 <a href=\"https://stackoverflow.com/a/74008746\">https://stackoverflow.com/a/74008746</a></p>\n<p>How is data stored in V8 Javascript engine memory? <a href=\"https://www.dashlane.com/blog/how-is-data-stored-in-v8-js-engine-memory\">https://www.dashlane.com/blog/how-is-data-stored-in-v8-js-engine-memory</a></p>\n<ul>\n<li><code>3. 명세에서</code>의 참고 링크</li>\n</ul>\n<p>What Are JavaScript Variables Made Of <a href=\"https://www.zhenghao.io/posts/javascript-variables\">https://www.zhenghao.io/posts/javascript-variables</a></p>\n<p>ECMA-262,  6.2.5 The Reference Record Specification Type <a href=\"https://tc39.es/ecma262/#sec-reference-record-specification-type\">https://tc39.es/ecma262/#sec-reference-record-specification-type</a></p>\n<ul>\n<li><code>4.</code> 이후 엔진 관련 내용의 참고 링크</li>\n</ul>\n<p><code>1.</code>의 참고 문헌과 같음</p>\n<p>JavaScript engine fundamentals: Shapes and Inline Caches(번역)\n<a href=\"https://mathiasbynens.be/notes/shapes-ics\">원래 글</a>은 구글의 V8엔진 개발에 관여한 Mathias Bynens가 작성한 글이기 때문에 신뢰할 만 하다.</p>\n<p><a href=\"https://shlrur.github.io/javascripts/javascript-engine-fundamentals-shapes-and-Inline-caches/\">https://shlrur.github.io/javascripts/javascript-engine-fundamentals-shapes-and-Inline-caches/</a></p>\n<p>V8에서 관리되는 자바스크립트 변수 <a href=\"https://yceffort.kr/2022/04/how-javascript-variable-works-in-memory\">https://yceffort.kr/2022/04/how-javascript-variable-works-in-memory</a></p>\n<p>stack and heap in V8 (JavaScript)의 답변 <a href=\"https://stackoverflow.com/questions/6602864/stack-and-heap-in-v8-javascript\">https://stackoverflow.com/questions/6602864/stack-and-heap-in-v8-javascript</a></p>\n<p>garbage collection with node.js <a href=\"https://stackoverflow.com/questions/5326300/garbage-collection-with-node-js/5328761#5328761\">https://stackoverflow.com/questions/5326300/garbage-collection-with-node-js/5328761#5328761</a></p>\n<p>JavaScript Memory Model Demystified <a href=\"https://www.zhenghao.io/posts/javascript-memory\">https://www.zhenghao.io/posts/javascript-memory</a></p>\n<p>SpiderMonkey 를 이용한 개발 일기</p>\n<p><a href=\"http://weongyo.org/docs/SpiderMonkey/AboutSpiderMonkey.pdf\">http://weongyo.org/docs/SpiderMonkey/AboutSpiderMonkey.pdf</a></p>\n<p>Firefox source Docs JS::Value and JSObject</p>\n<p><a href=\"https://firefox-source-docs.mozilla.org/js/index.html#js-value-and-jsobject\">https://firefox-source-docs.mozilla.org/js/index.html#js-value-and-jsobject</a></p>\n<p>spidermonkey source code</p>\n<p><a href=\"https://searchfox.org/mozilla-central/source/js/src\">https://searchfox.org/mozilla-central/source/js/src</a></p>\n<p>V8 source code</p>\n<p><a href=\"https://chromium.googlesource.com/v8/v8/\">https://chromium.googlesource.com/v8/v8/</a></p>\n<p>RedHat의 Daniel Bevenius가 작성한 learing V8 - heap</p>\n<p><a href=\"https://github.com/danbev/learning-v8/blob/master/notes/heap.md\">https://github.com/danbev/learning-v8/blob/master/notes/heap.md</a></p>\n<p>V8 and Blink <a href=\"https://opentutorials.org/course/3527/22807\">https://opentutorials.org/course/3527/22807</a></p>\n<p>C++ std::make_unique <a href=\"https://en.cppreference.com/w/cpp/memory/unique_ptr/make_unique\">https://en.cppreference.com/w/cpp/memory/unique_ptr/make_unique</a></p>",
    "excerpt": "\n시리즈\n| 제목 | 링크 |\n|------|------|\n| JS의 값은 스택과 힙 중 어디에 저장되는가? | https://witch.work/posts/javascript-trip-of-js-value-where-value-stored |\n| JS 엔진이 값을 저장하는 방법, tagged pointer와 NaN boxing | https://witch.work/posts/javascript-trip-of-js-value-tagged-pointer-nan-b",
    "headingTree": [
      {
        "title": "시리즈",
        "url": "#시리즈",
        "items": []
      },
      {
        "title": "1. 흔한 설명",
        "url": "#1-흔한-설명",
        "items": []
      },
      {
        "title": "2. 흔한 설명의 문제",
        "url": "#2-흔한-설명의-문제",
        "items": [
          {
            "title": "2.1. 메모리 할당 문제",
            "url": "#21-메모리-할당-문제",
            "items": []
          },
          {
            "title": "2.2. 클로저의 문제",
            "url": "#22-클로저의-문제",
            "items": []
          }
        ]
      },
      {
        "title": "3. 명세에서",
        "url": "#3-명세에서",
        "items": []
      },
      {
        "title": "4. 실제 구현에서",
        "url": "#4-실제-구현에서",
        "items": [
          {
            "title": "4.1. 변수와 값",
            "url": "#41-변수와-값",
            "items": []
          },
          {
            "title": "4.2. 저장",
            "url": "#42-저장",
            "items": [
              {
                "title": "4.2.1. 최적화 - 지역 변수",
                "url": "#421-최적화---지역-변수",
                "items": []
              },
              {
                "title": "4.2.2. 최적화 - 정수",
                "url": "#422-최적화---정수",
                "items": []
              }
            ]
          }
        ]
      },
      {
        "title": "5. 실제 엔진에서 - SpiderMonkey",
        "url": "#5-실제-엔진에서---spidermonkey",
        "items": [
          {
            "title": "5.1. 문자열의 저장",
            "url": "#51-문자열의-저장",
            "items": []
          },
          {
            "title": "5.2. 객체의 저장",
            "url": "#52-객체의-저장",
            "items": []
          }
        ]
      },
      {
        "title": "6. 실제 엔진에서 - V8",
        "url": "#6-실제-엔진에서---v8",
        "items": [
          {
            "title": "6.1. V8의 메모리 할당",
            "url": "#61-v8의-메모리-할당",
            "items": []
          },
          {
            "title": "6.2. V8 메모리 공간 생성 과정",
            "url": "#62-v8-메모리-공간-생성-과정",
            "items": []
          }
        ]
      },
      {
        "title": "7. 결론",
        "url": "#7-결론",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 5,
      "wordCount": 1374
    },
    "url": "/posts/javascript-trip-of-js-value-where-value-stored",
    "thumbnail": {
      "local": "/static/image-1-7d2deb00.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-image-1-7d2deb00-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAUElEQVR4nGP4jwMwQKifP75mJHtWVFSiSzx69ICfl8HQ0ODx48cIiUePnxdVdIVFxts6uDi5ukHkoDo+ffqyfPW2FWu2f/z48cePHwgJTMsBAkt7EAok7FEAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "maple-share-setting",
    "title": "메이플 분배금 계산기 프로젝트 세팅",
    "date": "2023-09-18T00:00:00Z",
    "description": "메이플 분배금 계산기 프로젝트를 시작해 보자",
    "tags": [
      "web",
      "front",
      "react"
    ],
    "html": "<p>요즘은 마음에 여유가 줄어들어서 거의 접속을 못 하고 있지만 메이플스토리를 열심히 했던 적이 잠깐 있었는데 그때 알게 된 분들이 메이플 보스 보상금 분배 시 쓸 수 있는 분배금 계산기를 만들자고 제안해 주셔서 프론트를 맡게 되었다.</p>\n<p>react를 기본으로 하고 그리고 shadcn-ui와 같은 라이브러리를 팍팍 사용해서 일단 작동하도록 만들어 보고자 한다. shadcn-ui는 radix ui 기반으로 접근성까지 잘 챙기고 있으므로 내가 직접 접근성 등의 요소들을 조율해 주는 것보다 훨 나을 것이다.</p>\n<h1>1. 프로젝트 생성, 세팅</h1>\n<p>vite로 간단히 생성하자.</p>\n<pre><code class=\"language-bash\">yarn create vite maple-share --template react-ts\n</code></pre>\n<p>그리고 포매팅을 위한 툴들을 설치한다. 이번에는 다른 사람들도 코드를 볼 수도 있으니 더욱 강력한 포매팅을 할 것이다.</p>\n<pre><code class=\"language-bash\">yarn add -D prettier eslint-config-prettier eslint-plugin-prettier\n</code></pre>\n<p><code>@typescript-eslint/parser</code>랑 <code>@typescript-eslint/eslint-plugin</code>는 기본적으로 설치되어 있었다.</p>\n<p>그럼 이제 eslint 플러그인들을 설치하자. 이전에 다른 작은 프로젝트를 할 때 사용했던 플러그인들에 <code>eslint-config-airbnb</code>를 더한 것이다. <code>eslint-config-airbnb</code>는 <a href=\"https://github.com/airbnb/javascript\">airbnb의 JS 스타일 가이드</a>를 자동으로 적용해 준다. 이 가이드에 대해서는 추후 더 글을 작성해볼 예정이다.</p>\n<pre><code class=\"language-bash\">yarn add -D eslint-plugin-import eslint-plugin-react eslint-plugin-unused-imports eslint-config-airbnb eslint-plugin-jsx-a11y\n</code></pre>\n<p>그리고 다음과 같이 철저한 포매팅을 위한 <code>.eslintrc.cjs</code>를 작성한다. 이 룰은 <a href=\"https://xo.dev/\">이창희</a>님의 블로그에 있는 lint 파일과 내가 개인적으로 개발하면서 썼던 airbnb 룰 몇 가지를 적절히 섞은 것이다.</p>\n<pre><code class=\"language-js\">// .eslintrc.cjs\nmodule.exports = {\n  root: true,\n  env: { browser: true, es2020: true },\n  extends: [\n    'airbnb',\n    'airbnb/hooks',\n    'eslint:recommended',\n    'plugin:@typescript-eslint/recommended',\n    'plugin:@typescript-eslint/recommended-requiring-type-checking',\n    'plugin:react/jsx-runtime',\n    'plugin:react-hooks/recommended',\n    'plugin:import/recommended',\n  ],\n  ignorePatterns: ['dist', '.eslintrc.cjs', 'vite.config.ts'],\n  parser: '@typescript-eslint/parser',\n  parserOptions: {\n    ecmaVersion: 'latest',\n    sourceType: 'module',\n    project: true,\n    tsconfigRootDir: __dirname,\n  },\n  plugins: ['react-refresh', 'unused-imports'],\n  rules: {\n    'react/prop-types': 'off',\n    'react/jsx-filename-extension': [\n      'warn',\n      {\n        'extensions': [\n          '.js',\n          '.ts',\n          '.jsx',\n          '.tsx'\n        ] // 확장자로 js와 jsx ts tsx 허용\n      }\n    ],\n    'react/no-unescaped-entities': 'warn',\n    'react/jsx-props-no-spreading': 'off',\n    'react/jsx-boolean-value': 'off',\n    'react/jsx-no-bind': 'off',\n    'react/require-default-props': 'off',\n    'react/self-closing-comp': 'warn', // 셀프 클로징 태그 가능하면 적용\n    'react/no-array-index-key': 'off',\n    'react-hooks/exhaustive-deps': ['warn'], // hooks의 의존성배열이 충분하지 않을때 강제로 의존성을 추가하는 규칙을 완화\n    'react-refresh/only-export-components': [\n      'warn',\n      { allowConstantExport: true },\n    ],\n    'jsx-a11y/click-events-have-key-events': 'off', // onClick 사용하기 위해서 onKeyUp,onKeyDown,onKeyPress 하나 이상 사용\n    'indent':[\n      'error',\n      2\n    ],\n    'import/no-named-as-default': 'off',\n    'import/no-unresolved': 'off',\n    'import/extensions': 'off',\n    'import/prefer-default-export': 'off',\n    'import/order': [\n      'warn',\n      {\n        'alphabetize': {\n          'order': 'asc',\n          'caseInsensitive': true\n        },\n        'groups': [\n          'builtin',\n          'external',\n          [\n            'parent',\n            'internal'\n          ],\n          'sibling',\n          [\n            'unknown',\n            'index',\n            'object'\n          ]\n        ],\n        'pathGroups': [\n          {\n            'pattern': '~/**',\n            'group': 'internal'\n          }\n        ],\n        'newlines-between': 'always'\n      }\n    ],\n    'arrow-parens': ['warn', 'as-needed'], // 화살표 함수의 파라미터가 하나일때 괄호 생략\n    'no-console': ['off'], // 콘솔을 쓰면 에러가 나던 규칙 해제\n    'no-alert': ['off'], // alert를 쓰면 에러가 나던 규칙 해제\n    'jsx-quotes': [\n      'error',\n      'prefer-single'\n    ],\n    'keyword-spacing': 'error',\n    'quotes': [\n      'error',\n      'single',\n      {\n        'avoidEscape': true\n      }\n    ],\n    'no-console': [\n      'warn',\n      {\n        'allow': [\n          'warn',\n          'error'\n        ]\n      }\n    ],\n    'no-extra-semi': 'error',\n    'semi': 'off',\n    'space-before-blocks': 'error',\n    'no-shadow': 'off',\n    'unused-imports/no-unused-imports': 'error',\n    '@typescript-eslint/no-shadow': [\n      'error'\n    ],\n    '@typescript-eslint/no-non-null-assertion': 'off',\n    '@typescript-eslint/explicit-function-return-type': 'off',\n    '@typescript-eslint/no-explicit-any': 'warn',\n    '@typescript-eslint/no-unused-vars': 'error',\n    '@typescript-eslint/no-unsafe-assignment': 'warn',\n    '@typescript-eslint/semi': [\n      'error'\n    ],\n    '@typescript-eslint/no-misused-promises': [\n      'error',\n      {\n        'checksVoidReturn': false\n      }\n    ],\n    '@typescript-eslint/type-annotation-spacing': [\n      'error',\n      {\n        'before': false,\n        'after': true,\n        'overrides': {\n          'colon': {\n            'before': false,\n            'after': true\n          },\n          'arrow': {\n            'before': true,\n            'after': true\n          }\n        }\n      }\n    ]\n  },\n}\n</code></pre>\n<p>그런데 이 상태에서는 제대로 자동 수정이 되지 않는다. tsconfig.json에 해당 eslint 파일이 포함되어 있지 않기 때문이라고 한다. 이를 수정하기 위해서는 다음과 같이 tsconfig.json의 <code>include</code>항목을 수정해 주어야 한다.</p>\n<pre><code class=\"language-json\">{\n  /* compilerOptions 생략 */\n  \"include\": [\"src\", \"vite.config.ts\", \".eslintrc.cjs\",],\n  \"references\": [{ \"path\": \"./tsconfig.node.json\" }]\n}\n</code></pre>\n<p>그리고 <code>vite.config.ts</code>에서 이를 인식하도록 하기 위해 <code>vite-tsconfig-paths</code>를 설치한다.</p>\n<pre><code class=\"language-bash\">yarn add -D vite-tsconfig-paths\n</code></pre>\n<p>그리고 <code>vite.config.ts</code>를 다음과 같이 수정한다.</p>\n<pre><code class=\"language-ts\">import { defineConfig } from 'vite'\nimport react from '@vitejs/plugin-react'\nimport tsconfigPaths from 'vite-tsconfig-paths'\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [react(), tsconfigPaths()],\n})\n</code></pre>\n<p>이렇게 하면 자동 수정이 잘 되는 것을 볼 수 있다.</p>\n<p>마지막으로 import alias를 통해 절대 경로 비슷하게 import해올 수 있도록 하자. tsconfig.json의 <code>compilerOptions</code>에 다음과 같이 <code>paths</code>를 추가한다.</p>\n<pre><code class=\"language-json\">{\n  \"compilerOptions\": {\n    /* 생략 */\n    \"paths\": {\n      \"@/*\": [\"./src/*\"],\n    },\n  },\n  /* 생략 */\n}\n</code></pre>\n<h1>2. shadcn ui</h1>\n<p>이 프로젝트에서는 <a href=\"https://ui.shadcn.com/\">shadcn ui</a>를 사용하기로 했다. 원래 mantine ui를 사용하려 했으나 분배금 계산기 기획 특성상 커스텀을 많이 해야 하는 컴포넌트가 많고 따라서 커스텀이 더 쉬운 이쪽이 더 낫다고 생각했기 때문이다.</p>\n<p>shadcn ui가 처음이라 사실 얼마나 장점이 많을지는 모르겠지만, 써본 몇 사람들의 말로는 굉장히 괜찮다고 하여 한번 부딪쳐본다. tailwind도 이전에 써본 적이 있어, 단점도 꽤 있지만 빠르게 무언가를 만들기에 굉장히 좋다는 걸 알고 있기에 이걸 이용하면 상당히 빠르게 프로토타입을 만들 수 있을 거라고 생각한다.</p>\n<h2>2.1. 설치</h2>\n<p>그럼 <a href=\"https://ui.shadcn.com/docs/installation/vite\">shadcn ui의 vite 설치 가이드</a>를 따라해 보자. vite 프로젝트 생성하는 부분은 이미 했으므로 건너뛴다.</p>\n<pre><code class=\"language-bash\">yarn add -D tailwindcss postcss autoprefixer\nyarn tailwindcss init -p\n</code></pre>\n<p><code>tsconfig.json</code>에서 <code>baseUrl</code>도 설정해준다.</p>\n<pre><code class=\"language-json\">\"baseUrl\": \".\",\n\"paths\": {\n  \"@/*\": [\"./src/*\"]\n}\n</code></pre>\n<p>path를 사용하기 위해 <code>@types/node</code> 설치</p>\n<pre><code class=\"language-bash\">yarn add -D @types/node\n</code></pre>\n<p><code>vite.config.ts</code>는 다음과 같이 작성</p>\n<pre><code class=\"language-ts\">import path from \"path\"\nimport react from \"@vitejs/plugin-react\"\nimport { defineConfig } from \"vite\"\n\nexport default defineConfig({\n  plugins: [react()],\n  resolve: {\n    alias: {\n      \"@\": path.resolve(__dirname, \"./src\"),\n    },\n  },\n})\n</code></pre>\n<p>그리고 <code>shadcn-ui</code>를 받아온다. 패키지는 아니기 때문에 설치라고 하기는 좀 그렇고...</p>\n<pre><code class=\"language-bash\">npx shadcn-ui@latest init\n</code></pre>\n<p>이렇게 하면 여러 문답이 나오는데 적당히 응답한다. 주의할 점은 <code>Where is your global CSS file?</code>이라는 질문이 있는데 여기서 기본 응답은 <code>app/globals.css</code>이다. 아마 nextJS를 기본으로 생각하고 만든 것 같다. 하지만 이 프로젝트는 vite를 사용하고 있으므로 <code>src/index.css</code>로 바꿔줘야 한다.</p>\n<p>그렇게 하고 나면 <code>src/index.css</code>가 알아서 초기화된다.</p>\n<h2>2.2. 시험</h2>\n<p>이제 컴포넌트를 받아 와서 사용할 수 있다. 공식 문서에서는 버튼을 하나의 예시로 들고 있다.</p>\n<pre><code class=\"language-bash\">npx shadcn-ui@latest add button\n</code></pre>\n<p>이렇게 하면 <code>src/components/button.tsx</code>가 생성된다. 이제 이걸 사용해 보자. <code>src/App.tsx</code>로 간다. tailwind 클래스를 적용해서 색도 바꿔보자.</p>\n<pre><code class=\"language-tsx\">// src/App.tsx\nimport { Button } from './components/ui/button';\n\nfunction App() {\n  return (\n    &#x3C;div>\n      &#x3C;h1>메이플 분배금 계산기&#x3C;/h1>\n      &#x3C;Button>버튼&#x3C;/Button>\n      &#x3C;Button className='bg-indigo-500'>버튼&#x3C;/Button>\n      &#x3C;Button className='bg-pink-500'>버튼&#x3C;/Button>\n    &#x3C;/div>\n  );\n}\n\nexport default App;\n</code></pre>\n<p>이렇게 하면 다음과 같이 각 색의 버튼 3개가 나온다.</p>\n<p><img src=\"/static/shadcn-button-56b77d6a.png\" alt=\"shadcn 버튼들\"></p>\n<h1>3. react-router-dom</h1>\n<p><code>react-router-dom</code>을 설치하자.</p>\n<pre><code class=\"language-bash\">yarn add react-router-dom\n</code></pre>\n<p>그리고 <code>src/main.tsx</code>에 다음과 같이 기본적인 라우터를 설정한다.</p>\n<pre><code class=\"language-tsx\">const router = createBrowserRouter([\n  {\n    path: '/',\n    element: (\n      &#x3C;App />\n    ),\n  },\n  {\n    path: '/about',\n    element: &#x3C;div>about&#x3C;/div>,\n  },\n]);\n\nReactDOM.createRoot(document.getElementById('root')!).render(\n  &#x3C;React.StrictMode>\n    &#x3C;RouterProvider router={router} />\n  &#x3C;/React.StrictMode>,\n);\n</code></pre>\n<p>이제 개발 환경을 실행하고 <code>/about</code>라우터에 들어가면 작게 about이라는 글씨가 뜨는 페이지가 나오는 것을 볼 수 있다. 라우팅이 잘 설정된 것이다.</p>\n<h1>참고</h1>\n<p>eslint airbnb 사용하기 <a href=\"https://hayjo.tistory.com/111\">https://hayjo.tistory.com/111</a></p>\n<p>shadcn ui 공식 문서 <a href=\"https://ui.shadcn.com/\">https://ui.shadcn.com/</a></p>",
    "excerpt": "요즘은 마음에 여유가 줄어들어서 거의 접속을 못 하고 있지만 메이플스토리를 열심히 했던 적이 잠깐 있었는데 그때 알게 된 분들이 메이플 보스 보상금 분배 시 쓸 수 있는 분배금 계산기를 만들자고 제안해 주셔서 프론트를 맡게 되었다.\nreact를 기본으로 하고 그리고 shadcn-ui와 같은 라이브러리를 팍팍 사용해서 일단 작동하도록 만들어 보고자 한다. shadcn-ui는 radix ui 기반으로 접근성까지 잘 챙기고 있으므로 내가 직접 접근성 등의 요소들을 조",
    "headingTree": [
      {
        "title": "1. 프로젝트 생성, 세팅",
        "url": "#1-프로젝트-생성-세팅",
        "items": []
      },
      {
        "title": "2. shadcn ui",
        "url": "#2-shadcn-ui",
        "items": [
          {
            "title": "2.1. 설치",
            "url": "#21-설치",
            "items": []
          },
          {
            "title": "2.2. 시험",
            "url": "#22-시험",
            "items": []
          }
        ]
      },
      {
        "title": "3. react-router-dom",
        "url": "#3-react-router-dom",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 2,
      "wordCount": 635
    },
    "url": "/posts/maple-share-setting",
    "thumbnail": {
      "local": "/static/shadcn-button-56b77d6a.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-shadcn-button-56b77d6a-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAFCAIAAAD38zoCAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAQklEQVR4nGNg4hCRVwvtD2t8/+jFv/////39+x8MGDx8gvNzF2won//+0bP/yBIQChMwfP/+/dev379//0aXwKUDAOfgaxt+w1eaAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "mdn-css-1",
    "title": "프론트 지식 익히기 CSS-1",
    "date": "2023-03-29T03:00:00Z",
    "description": "MDN CSS 튜토리얼 - 1 ",
    "tags": [
      "web",
      "study",
      "front",
      "CSS"
    ],
    "html": "<p>CSS는 Cascading Style Sheets의 약자로 웹 페이지의 스타일을 지정하는 언어이다. CSS를 통해 HTML에 스타일을 지정할 수 있다. 프론트의 장벽 중 하나이기도 하다. 이를 MDN 튜토리얼을 통해 공부해보자.</p>\n<h1>1. CSS란?</h1>\n<p>CSS는 사용자에게 문서를 표시하는 방법을 지정한다. 폰트의 크기라든가, 문서의 배경색이라든가 하는 것들을 말한다. 이때 문서라는 건 보통 마크업 언어로 구성된 텍스트 파일이다. HTML일 수도 있고 SVG나 XML일 수도 있다.</p>\n<h2>1.1. CSS 구문</h2>\n<p>CSS는 selector를 통해 특정 요소나 요소의 그룹을 선택하고 그 요소에 스타일을 적용한다. 이때 selector는 요소의 이름이나 클래스, 아이디 등을 사용할 수 있다. 그리고 스타일은 속성과 값으로 구성된다. 예를 들어 다음과 같다.</p>\n<pre><code class=\"language-css\">h1 {\n  color: red;\n  font-size: 5em;\n}\n</code></pre>\n<p>h1 요소들을 선택하고 <code>속성:값;</code> 형태로 스타일을 지정했다. 이때 각 스타일의 구분은 <code>;</code>로 한다. 이때 이 속성은 CSS 프로퍼티라고 하는데 각 프로퍼티에 따라 허용되는 값이 있다. color 프로퍼티에는 색상만 올 수 있는 식이다.</p>\n<h2>1.2. CSS 사양</h2>\n<p>다른 웹 표준 기술과 마찬가지로 CSS 또한 표준 조직이 있다. W3C의 CSS Working Group에서 만들고 있다. 새로운 CSS 기능도 여기서 개발한다.</p>\n<p>하지만 새로운 기능을 개발할 땐 언제나 하위 호환성이 고려된다. 오래된 웹사이트도 브라우저에서 잘 작동하도록 하기 위해서이다.</p>\n<h2>1.3. 브라우저 지원</h2>\n<p>브라우저에 따라서 CSS를 지원하는 정도가 다르다. 브라우저에 구현되지 않은 CSS를 사용하면 화면에 출력되지 않는다. 최신 사양의 경우 브라우저에 따라 구현된 브라우저와 안 된 브라우저가 있다.</p>\n<p>이렇게 브라우저가 특정 CSS를 구현했는지를 <a href=\"https://caniuse.com/\">caniuse.com</a>에서 확인할 수 있다. 예를 들어서 <code>grid</code>를 검색하면 다음과 같이 나온다.</p>\n<p><img src=\"/static/caniuse-result-35a2894e.png\" alt=\"caniuse-result\"></p>\n<h1>2. CSS 시작하기</h1>\n<p>CSS는 HTML 문서에 적용된다. HTML 문서에 CSS를 적용하는 방법은 여러 가지가 있는데 가장 일반적인 방법으로 해보자. HTML 문서에 CSS를 연결하는 방법이다.</p>\n<p>CSS 파일을 HTML 문서와 같은 위치에 만들고 HTML 문서의 head 태그 내에 다음을 추가하자. CSS 파일 이름은 <code>index.css</code>라 하자.</p>\n<pre><code class=\"language-html\">&#x3C;link href=\"index.css\" rel=\"stylesheet\" type=\"text/css\" />\n</code></pre>\n<p>이제 CSS 파일에 스타일을 추가해보자. 다음과 같이 하면 된다.</p>\n<pre><code class=\"language-css\">h1 {\n  color: aqua;\n}\n</code></pre>\n<p>그리고 HTML 문서에 h1태그를 하나 추가해 보자. 다음과 같이 <code>index.html</code>을 작성한다.</p>\n<pre><code class=\"language-html\">&#x3C;!DOCTYPE html>\n&#x3C;html lang=\"ko-KR\">\n  &#x3C;head>\n    &#x3C;meta charset=\"utf-8\" />\n    &#x3C;meta name=\"viewport\" content=\"width=device-width\" />\n    &#x3C;title>CSS 시작하기&#x3C;/title>\n    &#x3C;link href=\"index.css\" rel=\"stylesheet\" type=\"text/css\" />\n  &#x3C;/head>\n  &#x3C;body>\n    &#x3C;h1>안녕하세요.&#x3C;/h1>\n  &#x3C;/body>\n&#x3C;/html>\n</code></pre>\n<p>이제 <code>index.html</code>을 브라우저에서 열어보면 \"안녕하세요\"라는 글씨가 aqua 색(쨍한 하늘색)으로 나온다.</p>\n<h2>2.1. 여러 가지 셀렉터</h2>\n<h3>2.1.1. 전체 셀렉터</h3>\n<p><code>*</code>을 사용하면 전체 요소를 선택할 수 있다.</p>\n<pre><code class=\"language-css\">* {\n  color: aqua;\n}\n</code></pre>\n<h3>2.1.2. id 셀렉터</h3>\n<p>id 셀렉터는 <code>#id</code>와 같이 <code>#</code>을 사용한다. 문서 전체에서 특정 id를 가진 요소는 하나뿐이어야 하므로 id 셀렉터는 하나의 요소만 선택할 수 있다.</p>\n<pre><code class=\"language-css\">#title {\n  color: aqua;\n}\n</code></pre>\n<h2>2.1.3. class 셀렉터</h2>\n<p>HTML 요소 전체를 선택하여 스타일링하는 것은 한계가 많다. 클래스를 사용하면 된다. CSS에서 <code>.클래스명</code>과 같이 온점을 쓰면 클래스를 선택하여 스타일링할 수 있다.</p>\n<pre><code class=\"language-css\">.space-list {\n  list-style-type: kannada;\n}\n</code></pre>\n<p>이제 li 태그에 <code>class=\"space-list\"</code>를 추가하면 된다. 그러면 다음과 같이 리스트가 표시될 것이다.</p>\n<p><img src=\"/static/unordered-list-aff1e3b6.png\" alt=\"ul\"></p>\n<p>그리고 특정 태그 중 특정 클래스를 가진 요소를 선택할 수도 있다. <code>태그.클래스명</code>과 같이 쓰면 된다.</p>\n<pre><code class=\"language-css\">li.space-list {\n  color: red;\n}\n</code></pre>\n<p>그리고 하나의 요소가 여러 class값을 가질 수 있기 때문에(공백으로 구분한다) HTML 요소는 이미 스타일링된 클래스를 지정하는 것만으로 스타일을 갖다 쓸 수 있다.</p>\n<h2>2.1.4. 속성 셀렉터</h2>\n<p>특정 속성을 가진 요소를 선택할 수 있다. <code>셀렉터[속성]</code>과 같이 쓰면 그 셀렉터가 선택한 요소 중 특정 속성을 가진 요소를 선택할 수 있다. 다음과 같이 쓰면 a태그 중 target 속성을 가진 요소만 선택할 수 있다.</p>\n<pre><code class=\"language-css\">a[target] {\n  color: aqua;\n}\n</code></pre>\n<p><code>셀렉터[속성=\"값\"]</code>은 속성의 값까지 일치하는 요소들을 선택한다.</p>\n<p><code>셀렉터[어트리뷰트~=”값”]</code>은 어트리뷰트가 지정된 값을 공백으로 분리된 단어로 포함하는 요소를 선택한다. 예를 들어서 <code>h1[title~=\"first\"]</code>라고 썼다면 title 속성이 \"heading-first\"인 요소는 선택되지 않고 \"heading first\"인 요소는 선택된다. first가 단어로 분리되어 있는 것만 선택하기 때문이다.</p>\n<p>그리고 만약 속성값들을 대소문자 상관없이 대조하고 싶다면 닫는 대괄호 바로 이전에 <code>i</code>를 붙여주자.</p>\n<pre><code class=\"language-css\">/* 대소문자 구분을 안 하므로 attr 속성이 A 혹은 a인 것을 선택한다. */\nli[attr=\"a\" i]\n</code></pre>\n<p>이외에도 셀렉터+어트리뷰트의 조건으로 선택하는 셀렉터들이 여럿 있는데 필요해지면 <a href=\"https://poiemaweb.com/css3-selector\">poiemaWeb</a>에서 찾아보자.</p>\n<h3>2.1.5. 복합 셀렉터</h3>\n<p>후손 셀렉터는 <code>parent desc</code>와 같이 쓰면 된다. parent 셀렉터가 선택한 요소의 모든 후손 중 desc 셀렉터에 해당하는 요소들을 선택한다.</p>\n<p>다음과 같이 쓰면 div 태그의 후손인 p 태그를 모두 선택한다.</p>\n<pre><code class=\"language-css\">div p {\n  color: aqua;\n}\n</code></pre>\n<p>그런데 후손이 아니라 직접 자식인 요소만 선택하고 싶다면 자식 셀렉터를 사용하면 된다. <code>parent > child</code>와 같이 쓰면 된다. parent 셀렉터가 선택한 요소의 직접 자식 중 child 셀렉터에 해당하는 요소들을 선택한다.</p>\n<p><code>A + B</code>와 같이 쓰면 A셀렉터 바로 뒤에 위치하는 B셀렉터 요소를 선택한다. 인접 셀렉터라 한다.</p>\n<p><code>A ~ B</code>와 같이 쓰면 A셀렉터 뒤에 위치하는 모든 B셀렉터 요소를 선택한다. 형제 셀렉터라 한다.</p>\n<h3>2.1.6. 가상 클래스 셀렉터</h3>\n<p>pseudo-class 셀렉터는 요소의 상태, 즉 마우스가 올라와 있거나 포커스가 되어 있는 상태 등의 스타일링을 할 수 있다. 이 지정에는 <code>:</code>를 사용하며 <code>셀렉터:가상클래스명</code>과 같이 쓴다.</p>\n<p>다음과 같이 쓰면 a태그에 마우스 호버 상태일 때 a태그 텍스트가 아쿠아색이 된다.</p>\n<pre><code class=\"language-css\">a:hover {\n  color: aqua;\n}\n</code></pre>\n<p>먼저 링크 셀렉터는 다음과 같다. 방문한 링크일 땐 <code>a:visited</code>이고, 방문하지 않은 링크일 땐 <code>a:link</code>이다.</p>\n<p>동적 셀렉터는 다음과 같다. <code>selector:active</code>는 클릭한 상태, <code>selector:focus</code>는 포커스가 되어 있는 상태이다. <code>selector:hover</code>는 마우스가 올라와 있는 상태이다.</p>\n<p>UI 상태 셀렉터는 <code>selector:enabled</code>는 셀렉터가 사용 가능하게 활성화된 상태, <code>selector:disabled</code>는 비활성화된 상태이다. <code>selector:checked</code>는 체크박스나 라디오 버튼이 체크된 상태이다.</p>\n<p>이는 다른 셀렉터와 결합해 쓸 수 있는데 예를 들어서 <code>input:enabled + div</code>처럼 쓰면 활성화된 input 바로 뒤에 있는 div를 선택할 수 있다.</p>\n<p>구조 가상 클래스는 해당 셀렉터가 어떤 위치를 차지하고 있는지에 따라 선택된다.</p>\n<p><code>selector:first-child</code>는 셀렉터 요소 중 첫째 자식인 요소를 선택한다. <code>selector:last-child</code>는 셀렉터 요소 중 마지막 자식인 요소를 선택한다.</p>\n<p><code>selector:nth-child(n)</code>는 셀렉터 요소 중 n번째 자식인 요소를 선택한다. <code>selector:nth-last-child(n)</code>는 셀렉터 요소 중 뒤에서부터 n번째 자식인 요소를 선택한다.</p>\n<p>이때 n이 0과 음수인 경우는 생략된다. 따라서 <code>li:nth-child(2n-1)</code>은 홀수 번째 자식인 li요소를 선택한다.</p>\n<p><code>selector:first-of-type</code>는 형제 요소 중 selector에 해당하는 가장 처음 요소를 선택한다. <code>selector:last-of-type</code>는 형제 요소 중 selector에 해당하는 가장 마지막 요소를 선택한다.</p>\n<p><code>selector:nth-of-type(n)</code>는 형제 요소 중 selector 조건에 해당하는 n번째 요소를 선택한다. <code>selector:nth-last-of-type(n)</code>는 형제 요소 중 selector에 해당하는 뒤에서부터 n번째 요소를 선택한다.</p>\n<p>부정 셀렉터도 있다. <code>selector:not(A)</code>는 A selector에 해당하는 요소를 제외한 나머지 요소를 선택한다.</p>\n<p>정합성 셀렉터 <code>:valid</code>는 input이나 form 요소의 정합성 검증이 성공했을 때 선택한다. <code>:invalid</code>는 검증이 실패했을 때 선택한다. 이런 정합성 검증은 required, pattern 등의 속성을 통해 할 수 있다.</p>\n<h3>2.1.7. 가상 요소 셀렉터</h3>\n<p>가상 요소는 요소의 특정 부분, 예를 들어서 특정 요소의 앞 등에 스타일링을 적용하기 위해 사용된다. <code>::</code>를 사용해 표현하며 CSS 표준에 정의된 이름을 사용해야 한다.</p>\n<p><code>::first-letter</code>는 요소 내용의 첫 번째 글자를 선택한다. <code>::first-line</code>은 요소 내용의 첫 번째 줄을 선택한다.</p>\n<p><code>::before</code>는 요소의 앞에 위치하는 공간을 선택한다. <code>::after</code>는 요소의 내용 뒤에 위치하는 공간을 선택한다. 그리고 <code>::selection</code>은 드래그한 콘텐츠를 선택한다.</p>\n<pre><code class=\"language-css\">::selection{\n  background-color: aqua;\n}\n</code></pre>\n<h3>2.1.8 셀렉터 표</h3>\n<p>위에서 살펴본 셀렉터들을 표로 정리하면 다음과 같다.</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>셀렉터</th><th>예제</th></tr></thead><tbody><tr><td>전체 셀렉터</td><td><code>* {}</code></td></tr><tr><td>태그 셀렉터</td><td><code>h1 {}</code></td></tr><tr><td>아이디 셀렉터</td><td><code>#my-id {}</code></td></tr><tr><td>클래스 셀렉터</td><td><code>.my-class {}</code></td></tr><tr><td>속성 셀렉터</td><td><code>a[target] {}</code></td></tr><tr><td>의사 클래스 셀렉터</td><td><code>a:link {}</code></td></tr><tr><td>의사 요소 셀렉터</td><td><code>::first-line {}</code></td></tr><tr><td>후손 셀렉터</td><td><code>div p {}</code></td></tr><tr><td>자식 셀렉터</td><td><code>div > p {}</code></td></tr><tr><td>인접 형제 셀렉터</td><td><code>h1 + p {}</code></td></tr><tr><td>일반 형제 셀렉터</td><td><code>h1 ~ p {}</code></td></tr></tbody></table>\n<h2>2.2. 셀렉터 결합</h2>\n<p>동일한 CSS를 쓰는 항목이 2개 이상인 경우 <code>,</code>를 사용하여 선택자를 결합할 수 있다.</p>\n<pre><code class=\"language-css\">h1, h2, h3{\n  color: aqua;\n}\n</code></pre>\n<p>위처럼 하면 h1, h2, h3에 스타일이 모두 적용된다. 이때 주의할 점은 이렇게 결합한 선택자 중 하나라도 유효하지 않은 경우 전체 규칙이 무시된다는 것이다.</p>\n<pre><code class=\"language-css\">h1, ..my-class, h2{\n  color: aqua;\n}\n</code></pre>\n<p>위와 같이 하면 <code>..my-class</code>가 유효하지 않은 선택자이므로 전체 규칙이 무시된다.</p>\n<h1>3. CSS의 구조</h1>\n<p>CSS의 언어 구조를 좀더 깊이 살펴보자.</p>\n<h2>3.1. CSS 적용하기</h2>\n<p>CSS 파일을 HTML 문서에 적용하는 방법은 여러 가지가 있다. 첫째는 link 요소를 사용하는 것이다. link 요소의 href 속성에 css 파일 경로를 넣어주면 된다.</p>\n<pre><code class=\"language-html\">&#x3C;link rel=\"stylesheet\" href=\"./styles.css\">\n</code></pre>\n<p>둘째는 head 태그 내부의 style 요소를 사용하는 것이다.</p>\n<pre><code class=\"language-html\">&#x3C;head>\n  &#x3C;style>\n    h1{\n      color: aqua;\n    }\n  &#x3C;/style>\n&#x3C;/head>\n</code></pre>\n<p>셋째는 인라인 스타일을 쓰는 것이다. 인라인 스타일은 HTML 요소의 style 속성에 직접 스타일을 문자열 형태로 작성하는 것이다.</p>\n<pre><code class=\"language-html\">&#x3C;h1 style=\"color:blue;\">안녕하세요.&#x3C;/h1>\n</code></pre>\n<p>하지만 이렇게 인라인 스타일을 사용하는 건 HTML과 CSS 정보를 섞어서 가독성을 떨어뜨리고, CSS의 재사용을 불가능하게 한다.</p>\n<h2>3.2. CSS 셀렉터 우선순위</h2>\n<p>두 선택자가 동일한 요소를 선택하는 경우가 있을 수 있다. 이때의 우선순위는 나중에 더 자세히 다루겠지만 기본적으로 더 구체적인 게 우선순위가 높다.</p>\n<pre><code class=\"language-css\">h1 {\n  color: red;\n}\n\n.hi {\n  color: aqua;\n}\n</code></pre>\n<p>그리고 HTML 요소를 다음과 같이 작성한다.</p>\n<pre><code class=\"language-html\">&#x3C;h1 class=\"hi\">클래스&#x3C;/h1>\n</code></pre>\n<p>이렇게 하면 클래스에 대한 CSS가 더 구체적이므로 클래스에 적용된 스타일이 적용된다.</p>\n<h2>3.3. 함수</h2>\n<p>CSS에서는 몇 가지 함수를 사용할 수 있다. 예를 들어서 calc 함수는 수식을 계산해주는 함수이다.</p>\n<pre><code class=\"language-css\">width: calc(100% - 20px);\n</code></pre>\n<p>위와 같이 쓰면 100% 너비에서 20px를 뺀 것을 너비로 해준다. 그 외에 transform 속성에 쓰이는 rotate등의 함수도 있다.</p>\n<h2>3.4. at-rules</h2>\n<p>@-규칙은 at기호(@)에서 시작해서 세미콜론 또는 다음 CSS 블록까지를 포함하는 규칙이다. 일반적으로 다음과 같은 형태를 띤다.</p>\n<pre><code class=\"language-css\">@IDENTIFIER RULE;\n</code></pre>\n<p>추가 스타일 시트를 가져오는 <code>@import</code>나 미디어 쿼리에 쓰이는 <code>@media</code> 등이 있다.</p>\n<pre><code class=\"language-css\">@media (max-width: 600px) {\n  h1 {\n    color: red;\n  }\n}\n</code></pre>\n<p>이외에도 스타일시트에 사용되는 문자 집합을 정의하는 <code>@charset</code>, 온라인 폰트를 사용할 때 쓰이는 <code>@font-face</code>등 다양한 rule이 있다.</p>\n<p>브라우저가 주어진 기준을 만족하면 해당 콘텐츠를 적용하는 <code>@supports</code>, CSS 애니메이션의 중간 양상을 설명하는 <code>@keyframes</code>도 꽤 쓰인다.</p>\n<h2>3.5. 주석</h2>\n<p>CSS 주석은 <code>/* */</code>로 표현한다.</p>\n<h1>4. CSS 작동 방식</h1>\n<p>브라우저가 웹페이지를 만드는 과정을 살펴본다.</p>\n<p>브라우저는 먼저 HTML을 로드한다. 그리고 HTML을 노드 트리 형태의 DOM으로 만든다. 이때 HTML에 연결된 리소스와 CSS를 가져오지는 않는다.</p>\n<p>DOM 만들기 작업이 끝난 후에 HTML 문서에 연결된 이미지 등의 리소스와 CSS를 가져온다. 이렇게 가져온 CSS를 분석한 후 셀렉터의 유형별로 다른 규칙들을 정렬한다. 그리고 각각의 노드에 어떤 규칙을 적용할지 결정하고 스타일을 첨부해서 렌더 트리를 만든다.</p>\n<p>렌더 트리는 규칙이 적용된 후 최종적으로 화면에 표시되는 노드들의 집합이다. 이렇게 만들어진 렌더 트리를 기반으로 브라우저가 화면에 표시한다.</p>\n<p>만약에 브라우저가 인식하지 못하는 CSS가 있다면 브라우저는 해당 규칙을 무시하고 다음 단계로 넘어간다.</p>\n<h1>참고</h1>\n<p>CSS 셀렉터 <a href=\"https://poiemaweb.com/css3-selector\">https://poiemaweb.com/css3-selector</a></p>",
    "excerpt": "CSS는 Cascading Style Sheets의 약자로 웹 페이지의 스타일을 지정하는 언어이다. CSS를 통해 HTML에 스타일을 지정할 수 있다. 프론트의 장벽 중 하나이기도 하다. 이를 MDN 튜토리얼을 통해 공부해보자.\n1. CSS란?\nCSS는 사용자에게 문서를 표시하는 방법을 지정한다. 폰트의 크기라든가, 문서의 배경색이라든가 하는 것들을 말한다. 이때 문서라는 건 보통 마크업 언어로 구성된 텍스트 파일이다. HTML일 수도 있고 SVG나 XML일 수",
    "headingTree": [
      {
        "title": "1. CSS란?",
        "url": "#1-css란",
        "items": [
          {
            "title": "1.1. CSS 구문",
            "url": "#11-css-구문",
            "items": []
          },
          {
            "title": "1.2. CSS 사양",
            "url": "#12-css-사양",
            "items": []
          },
          {
            "title": "1.3. 브라우저 지원",
            "url": "#13-브라우저-지원",
            "items": []
          }
        ]
      },
      {
        "title": "2. CSS 시작하기",
        "url": "#2-css-시작하기",
        "items": [
          {
            "title": "2.1. 여러 가지 셀렉터",
            "url": "#21-여러-가지-셀렉터",
            "items": [
              {
                "title": "2.1.1. 전체 셀렉터",
                "url": "#211-전체-셀렉터",
                "items": []
              },
              {
                "title": "2.1.2. id 셀렉터",
                "url": "#212-id-셀렉터",
                "items": []
              }
            ]
          },
          {
            "title": "2.1.3. class 셀렉터",
            "url": "#213-class-셀렉터",
            "items": []
          },
          {
            "title": "2.1.4. 속성 셀렉터",
            "url": "#214-속성-셀렉터",
            "items": [
              {
                "title": "2.1.5. 복합 셀렉터",
                "url": "#215-복합-셀렉터",
                "items": []
              },
              {
                "title": "2.1.6. 가상 클래스 셀렉터",
                "url": "#216-가상-클래스-셀렉터",
                "items": []
              },
              {
                "title": "2.1.7. 가상 요소 셀렉터",
                "url": "#217-가상-요소-셀렉터",
                "items": []
              },
              {
                "title": "2.1.8 셀렉터 표",
                "url": "#218-셀렉터-표",
                "items": []
              }
            ]
          },
          {
            "title": "2.2. 셀렉터 결합",
            "url": "#22-셀렉터-결합",
            "items": []
          }
        ]
      },
      {
        "title": "3. CSS의 구조",
        "url": "#3-css의-구조",
        "items": [
          {
            "title": "3.1. CSS 적용하기",
            "url": "#31-css-적용하기",
            "items": []
          },
          {
            "title": "3.2. CSS 셀렉터 우선순위",
            "url": "#32-css-셀렉터-우선순위",
            "items": []
          },
          {
            "title": "3.3. 함수",
            "url": "#33-함수",
            "items": []
          },
          {
            "title": "3.4. at-rules",
            "url": "#34-at-rules",
            "items": []
          },
          {
            "title": "3.5. 주석",
            "url": "#35-주석",
            "items": []
          }
        ]
      },
      {
        "title": "4. CSS 작동 방식",
        "url": "#4-css-작동-방식",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 2,
      "wordCount": 416
    },
    "url": "/posts/mdn-css-1",
    "thumbnail": {
      "local": "/static/caniuse-result-35a2894e.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-caniuse-result-35a2894e-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAADCAIAAAAhqtkfAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAVklEQVR4nAFLALT/ALislbu0n9HIsP303P/23vPp0vTr0/Tr1ACZf2KvlH62nYjczrzWxLHczbrf0Lvi1cAAEy0AAA8ATEIYY21FXVU0kYVoj5Bwk5t5h/gss1789L4AAAAASUVORK5CYII="
    }
  },
  {
    "slug": "mdn-css-2",
    "title": "프론트 지식 익히기 CSS-2",
    "date": "2023-03-30T00:00:00Z",
    "description": "MDN CSS 튜토리얼 - 2",
    "tags": [
      "web",
      "study",
      "front",
      "CSS"
    ],
    "html": "<p><a href=\"https://developer.mozilla.org/ko/docs/Learn/CSS/Building_blocks\">MDN의 CSS 구성요소 파트</a>를 읽고 정리하는 곳이다. CSS의 필수적인 이론들을 알아보는 파트이다.</p>\n<h1>1. 셀렉터</h1>\n<p>앞서 갖가지 셀렉터를 알아보았다. 이제 몇 가지 추가적인 지식을 알아보자. 셀렉터들의 기본 정의와 같은 것들은 이전 글에서 했으므로 넘어간다.</p>\n<h2>1.1. 범용 셀렉터</h2>\n<p><code>*</code>를 사용하여 모든 요소를 선택할 수 있다. 이는 앞서 보았다시피 모든 요소를 선택한다. 하지만 모든 요소에 동시에 스타일링을 해야 할 일은 거의 없다. 그럼 어디 쓰일까?</p>\n<p>가독성을 높이는 데에 쓰는 것이 하나의 예시가 될 수 있다. 만약 div의 후손 중 첫번째 자식인 요소에만 글씨를 굵게 하는 스타일링을 하고 싶다면 다음과 같이 쓸 수 있다.</p>\n<pre><code class=\"language-css\">div :first-child {\n  font-weight: bold;\n}\n</code></pre>\n<p>하지만 이렇게 쓰면 <code>div:first-child</code> 즉 첫번째 자식인 div 태그를 선택하는 것과 혼동된다. 이때 범용 셀렉터를 사용하면 다음과 같이 쓸 수 있다.</p>\n<pre><code class=\"language-css\">div *:first-child {\n  font-weight: bold;\n}\n</code></pre>\n<p>이렇게 하면 div의 후손 중 첫번째 자식인 요소를 선택하는 것을 더 가독성 높게 표현할 수 있다.</p>\n<h2>1.2. 클래스 셀렉터</h2>\n<p>특정 태그 중 특정 클래스를 가진 요소를 선택할 수 있다. 예를 들어 <code>div.box</code>와 같이 사용하면 div 태그 중 box 클래스인 요소들을 선택한다.</p>\n<p>클래스 선택자를 붙여 씀으로써 여러 클래스를 동시에 가진 요소를 선택할 수도 있다. <code>.box.myclass</code>와 같이 쓰면 box 클래스와 myclass 클래스를 동시에 가진 요소를 선택한다. box나 myclass 둘 중 하나만 가진 요소는 선택되지 않는다.</p>\n<h2>1.3. 의사 클래스와 의사 요소</h2>\n<p>의사 클래스와 의사 요소 선택자를 함께 쓰는 것도 가능하다. 예를 들어서 다음 선택자를 보자.</p>\n<pre><code class=\"language-css\">article p:first-child::first-line {\n  font-size: 2em;\n}\n</code></pre>\n<p>위 선택자는 article 태그의 첫번째 자식인 p 태그의 내용 중 첫번째 줄을 선택한다.</p>\n<h2>1.4. ::before와 ::after</h2>\n<p>content 속성과 함께 쓰여서, CSS를 이용해서 문서 내용을 삽입할 수 있는 유사 요소가 있다. 바로 <code>::before</code>와 <code>::after</code>이다. 이들은 각각 선택한 요소의 첫 자식, 마지막 자식으로 의사 요소를 하나씩 생성한다.</p>\n<p>그리고 이렇게 요소를 선택한 후 content 속성을 이용해서 내용을 삽입할 수 있다. 예를 들어 다음과 같이 쓸 수 있다.</p>\n<pre><code class=\"language-css\">.box::before {\n  content: \"before 텍스트\";\n}\n\n.box::after {\n  content: \"after 텍스트\";\n}\n</code></pre>\n<p>이렇게 하면 box클래스를 가진 요소의 첫 자식, 마지막 자식으로 의사 요소가 삽입되고 그 내용으로 우리는 \"before 텍스트\", \"after 텍스트\"를 삽입했다.</p>\n<p>기존 요소의 자식으로 삽입되는 것이므로 기존 요소의 스타일링을 따라간다. 예를 들어서 h1태그, p태그에 위를 적용하자.</p>\n<pre><code class=\"language-html\">&#x3C;p class=\"box\">테스트 문단&#x3C;/p>\n&#x3C;h1 class=\"box\">테스트 제목&#x3C;/h1>\n</code></pre>\n<p>그러면 같은 \"before 텍스트\", \"after 텍스트\"지만 부모의 스타일을 따라간다.</p>\n<p><img src=\"/static/before-after-b7814fe0.png\" alt=\"result\"></p>\n<p>이를 이용해서 중요한 내용을 표시하는 것은 권장되지 않는다. 이렇게 삽입한 텍스트는 몇몇 스크린 리더에 의해 인식되지 못하며 유지보수도 힘들기 때문이다.</p>\n<p>일반적으로는 링크의 끝에 화살표를 삽입하는 등, 스크린 리더에 읽힐 필요는 없지만 시각적인 표시를 할 때 쓰인다. 다음은 링크 끝에 화살표를 삽입하는 예시이다.</p>\n<pre><code class=\"language-css\">a::after {\n  content: \"→\";\n}\n</code></pre>\n<p>그리고 이 유사 요소는 빈 문자열을 삽입하고 임의의 스타일링을 할 때도 쓰인다. 예를 들어서 문단 앞에 네모를 그리고 싶다면, before 유사 요소를 삽입하고 content 속성을 빈 문자열로 설정하고, 임의의 스타일링을 하면 된다.</p>\n<pre><code class=\"language-css\">.box::before {\n  display: block;\n  width: 100px;\n  height: 100px;\n  background: teal;\n  content: \"\";\n}\n</code></pre>\n<p>꼭 빈 문자열을 content로 설정해야 하는 것을 주의하자. 그리고 width, height의 적용을 위해서는 display를 block으로 설정해야 한다.</p>\n<h1>2. 계단식 및 상속</h1>\n<h2>2.1. 규칙 충돌</h2>\n<p>CSS에서 동일한 요소에 적용될 수 있는 규칙이 2가지 이상 있으면 어떻게 될까? 이런 상황을 제어하는 규칙은 계단식(cascade)과 우선순위이다.</p>\n<p>계단식은 우선순위가 같은 규칙들이 하나의 요소에 적용될 때, CSS에서 마지막에 나오는 규칙이 적용됨을 뜻한다.</p>\n<pre><code class=\"language-css\">// 이렇게 하면 h1 태그의 글자색은 나중에 선언된 purple이 적용된다.\nh1 {\n  color: red;\n}\n\nh1 {\n  color: purple;\n}\n</code></pre>\n<p>그럼 우선순위는? 기본적으로 선택자가 선택하는 요소가 얼마나 구체적인지에 따라 결정된다. 더 구체적인 선택자에 점수를 더 크게 매겨서, 큰 점수의 선택자를 적용한다. 예를 들어서 요소 선택자보다는 class 선택자가 구체적이다.</p>\n<p>이렇게 CSS 적용 우선순위를 캐스캐이딩 순서(Cascading Order)라고 한다. 이 순서에는 3가지 규칙이 있다.</p>\n<ol>\n<li>중요도(Importance) 규칙 : CSS의 선언 위치에 따라 우선순위가 달라진다.</li>\n<li>명시도 : 대상을 더 구체적으로 선택하는 선택자가 우선순위가 높다.</li>\n<li>선언 순서 : 나중에 선언된 스타일이 우선적으로 적용된다.</li>\n</ol>\n<h3>2.1.1. 중요도 규칙</h3>\n<p>CSS의 선언 위치에 따른 우선순위는 다음 순서로 결정된다. 인라인 스타일이 최우선이다.</p>\n<ol>\n<li>인라인 스타일</li>\n<li>head 요소 내의 style 요소에 정의된 스타일</li>\n<li>head 요소 내의 style 요소에서 @import한 스타일</li>\n<li>link 태그로 연결된 외부 스타일 시트</li>\n<li>link 태그로 연결된 외부 스타일 시트에서 @import한 스타일</li>\n<li>브라우저 디폴트 스타일시트</li>\n</ol>\n<h3>2.1.2. 명시도</h3>\n<p>앞서 말했듯이 대상을 명확하게 특정한 선택자일수록 우선순위가 높다. 이를 명시도가 높다고 한다.</p>\n<pre><code>!important > 인라인 스타일 > 아이디 선택자 > 클래스/어트리뷰트/가상 선택자 > 태그 선택자 > 전체 선택자 > 상위 요소에 의해 상속된 속성\n</code></pre>\n<p><code>!important</code>라는 게 있는 것을 볼 수 있다. 이는 모든 CSS 우선순위 계산을 무효화하며 특정 속성을 가장 구체적으로 만들어 일반적인 규칙을 무시한다. 하지만 정말 필요한 경우가 아니면 사용하지 않는 것이 좋디.</p>\n<h3>2.1.3. 선언 순서</h3>\n<p>상대적으로 나중에 선언된 스타일이 우선적으로 적용된다.</p>\n<h2>2.2. 상속</h2>\n<p>부모 요소에서 설정된 몇몇 CSS 속성은 자식 요소에도 상속된다. 예를 들어 color 속성을 설정한 요소가 있다면 그 자식 요소 역시 color 속성을 상속받는다. 만약 자식 요소에서 새로운 color 속성을 설정하지 않았다면 자식 요소에서도 부모 요소의 color가 나타난다.</p>\n<p>이렇게 상속되는 속성의 여부는 CSS 속성 참조 페이지의 명세표에서 볼 수 있다. 예를 들어 <a href=\"https://developer.mozilla.org/ko/docs/Web/CSS/color#specifications\">color 속성 페이지</a>의 명세에는 다음과 같이 상속이 yes로 표시되어 있다.</p>\n<p><img src=\"/static/css-color-e9cce0c1.png\" alt=\"color\"></p>\n<p>상속을 제어하기 위해 사용되는 특수한 속성 값도 있다.</p>\n<ul>\n<li>inherit : 해당 속성값을 부모 요소의 속성값과 동일하게 설정한다.</li>\n<li>initial : 해당 속성값을 기본값으로 설정한다.</li>\n<li>unset : 부모로부터 상속할 속성값이 있으면 상속받고, 없으면 기본값으로 설정한다.</li>\n</ul>\n<pre><code class=\"language-css\">h1{\n  color:inherit;\n}\n</code></pre>\n<p>이렇게 하면 h1 태그의 글자색은 부모 요소의 글자색과 동일하게 설정된다.</p>\n<p>그런데 color등의 개별 요소 말고, 요소의 모든 속성의 상속을 제어하고 싶을 수 있다. 이럴 때는 all 속성을 사용한다.</p>\n<pre><code class=\"language-css\">h1{\n  all:inherit;\n}\n</code></pre>\n<p>h1 태그의 모든 속성을 부모 요소의 속성값과 동일하게 설정하였다.</p>\n<h1>3. cascade layer</h1>\n<p>CSS 캐스케이드와 명시도를 기반으로 하는 고급 기능, 캐스케이드 레이어를 소개한다.</p>\n<p>요소에 적용된 각 CSS 속성에는 하나의 값만 있을 수 있다. 배경색이 빨간색이면서 파란색일 수는 없다. 개발자 도구의 '스타일'패널엔 검사 중인 요소에 적용된 모든 속성값이 적용된 셀렉터와 함께 표시된다. 이때 가장 우선순위가 높은 셀렉터의 속성값이 적용된다.</p>\n<p>그리고 개발자 도구에선 요소에 적용되진 않았지만 선택한 요소와 일치하는 셀렉터의 속성값들도 취소선이 그어진 채 표시된다. 이는 캐스케이드 레이어에 의해 취소된 속성값들이다.</p>\n<p>사이트가 더 복잡해지면 스타일시트의 소스 순서가 더 복잡해질 때가 많다. 이때 캐스케이드 레이어를 사용하면 CSS 선언을 더 쉽게 관리할 수 있다.</p>\n<h2>3.1. 캐스케이드란</h2>\n<p>캐스케이딩은 스타일들이 어떻게 적용되는지를 결정하는 방식이다. CSS를 렌더링하는 도구(ex. 브라우저)는 다음과 같은 방식을 통해 모든 요소의 모든 속성값을 어떻게 적용할지 결정한다.</p>\n<ol>\n<li>해당 요소를 선택하는 모든 선택자의 CSS 블록의 규칙들을 찾는다.</li>\n<li>!important 속성을 가진 규칙과 아닌 규칙을 분리한다. !important가 붙은 속성이 우선이다.</li>\n<li>각각의 분리된 속성들에서 author, user, user-agent(브라우저 등) 규칙을 분리한다. author 규칙이 우선이다.</li>\n<li>지금까지 생긴 6개의 우선순위 버킷들을 캐스케이드 레이어 우선순위대로 정렬한다. 이 우선순위는 #5에서 설명한다.</li>\n<li>우선순위가 겹치는 선언들을 명시도로 정렬한다.</li>\n<li>지금까지의 모든 우선순위가 같은 스타일 선언들이 있다면 나중에 선언된 스타일을 우선적으로 적용한다.</li>\n</ol>\n<p>이때 중간에 캐스케이드 레이어라는 것을 고려하는 걸 볼 수 있다. 이는 명시도를 통해서 CSS 우선순위를 구분하는 것보다 좀 더 협업에 좋은 방식을 제공한다. 이는 <a href=\"https://www.witch.work/css-cascade-layer/\">블로그의 CSS 캐스케이드 레이어에 관한 글</a>에 간략히 정리하였다.</p>\n<h1>4. 박스 모델</h1>\n<p>CSS의 모든 요소는 박스로 표현된다. 이 박스를 잘 이해하는 것은 레이아웃을 잘 구성하는 데에 도움이 된다.</p>\n<h2>4.1. 블록 박스와 인라인 박스</h2>\n<p>블록 박스는 다음과 같은 특성을 가진다.</p>\n<ul>\n<li>기본적으로 가로폭 전체의 넓이를 가진다.</li>\n<li>width, height 속성이 적용된다.</li>\n<li>블록 박스 다음에는 줄바꿈이 된다.</li>\n<li>페이지 내에서 공간을 차지하여 다른 요소들을 밀어낸다.</li>\n</ul>\n<p>인라인 박스 특성은 다음과 같다.</p>\n<ul>\n<li>줄바꿈이 되지 않는다.</li>\n<li>width, height 속성이 적용되지 않는다.</li>\n<li>패딩과 마진, border가 다른 인라인 박스들을 멀어지게 하지 않는다.</li>\n</ul>\n<h2>4.2. 디스플레이 유형</h2>\n<p>위의 블록 박스와 인라인 박스는 CSS의 display 속성으로 조절할 수 있다. 그런데 이 디스플레이 유형은 외부와 내부로 나누어진다. 내부 디스플레이 유형은 flex나 grid로, 박스 내부의 요소가 배치되는 방법을 나타낸다. 이러한 내부 디스플레이 유형은 이후에 레이아웃에 대해 배울 때 다룰 것이다.</p>\n<p>지금은 외부 디스플레이 유형에 대해서만 다룰 것이다. 이는 앞서 말했듯 css display 속성을 사용해서 변경할 수 있다. 요소가 블럭인지 인라인인지를 정할 수 있다는 것이다.</p>\n<pre><code class=\"language-css\">display: block;\ndisplay: inline;\n</code></pre>\n<h2>4.3. CSS 박스 모델</h2>\n<p>CSS 박스 모델은 블록 박스에 완전히 적용되며 인라인 박스의 경우 박스 모델의 일부 동작만 사용한다.</p>\n<p>블록 박스는 기본적으로 다음과 같이 구성된다.</p>\n<p><img src=\"/static/box-model-4c57133d.png\" alt=\"box-model\"></p>\n<p>margin은 border의 바깥쪽, padding은 border 안쪽의 여백을 나타낸다.</p>\n<p>콘텐츠 박스는 width와 height로, 패딩 박스는 padding으로, 테두리 박스는 border로, 마진 박스는 margin으로 크기를 조절할 수 있다.</p>\n<p>그리고 박스가 점유하는 전체 크기는 콘텐츠 박스 너비+패딩+테두리 로 계산된다. 즉, margin은 박스의 크기를 결정하지 않는다. 다음과 같은 CSS가 있다고 하자.</p>\n<pre><code class=\"language-css\">.box{\n  width: 100px;\n  height: 100px;\n  padding: 10px;\n  border: 5px solid black;\n  margin: 10px;\n}\n</code></pre>\n<p>그러면 박스가 차지하는 너비는 130px이다. 그리고 이 중 실제 콘텐츠가 표시되는 너비는 100px(width)이다.</p>\n<pre><code>width 100px + padding 10*2px + border 5*2px = 130px\n</code></pre>\n<h3>4.3.1. 대체 박스 모델</h3>\n<p>이는 표준 박스 모델의 경우이다. 대체 박스 모델도 존재한다. 이 모델에서는 우리가 설정한 width가 콘텐츠 박스 너비 + 패딩 박스 너비 + 테두리 박스 너비가 된다.</p>\n<p>예를 들어 위의 CSS를 다시 보자.</p>\n<pre><code class=\"language-css\">.box{\n  width: 100px;\n  height: 100px;\n  padding: 10px;\n  border: 5px solid black;\n  margin: 10px;\n}\n</code></pre>\n<p>이 경우 실제 콘텐츠 박스의 너비는 70px가 된다. 100px에서 패딩 박스 20px와 테두리 박스 10px를 뺀 값이다.</p>\n<p>대체 박스 모델은 다음과 같이 설정할 수 있다.</p>\n<pre><code class=\"language-css\">.box{\n  box-sizing: border-box;\n}\n</code></pre>\n<p>반대로 표준 박스 모델은 <code>box-sizing:content-box</code>로 설정한다.</p>\n<p>만약 모든 요소가 대체 박스 모델을 사용하길 원한다면 다음과 같이 설정하자.</p>\n<pre><code class=\"language-css\">html {\n  box-sizing: border-box;\n}\n*, *::before, *::after {\n  box-sizing: inherit;\n}\n</code></pre>\n<h3>4.3.2. 대체 박스 모델 선언에 대하여</h3>\n<p>위의 대체 박스 모델 선언에 의문이 들 수 있다. 왜 그냥 <code>*</code>를 쓰지 않을까? 다음과 같이 써도 되지 않은가?</p>\n<pre><code class=\"language-css\">* {\n  box-sizing: border-box;\n}\n</code></pre>\n<p>그러나 이렇게 하면 의도치 않은 동작이 발생할 수 있다. 위와 같이 대체 박스 모델을 설정했는데 어떤 하나의 요소에 대해서 표준 박스 모델을 사용하고 싶다고 해보자. 그럼 우리는 다음과 같이 할 것이다.</p>\n<pre><code class=\"language-css\">.my-box{\n  box-sizing: content-box;\n}\n</code></pre>\n<p>이 목적은 보통 my-box 클래스를 가진 요소 내에서는 표준 박스 모델을 사용하려는 것이다. 하지만 이렇게 하고 <code>my-box</code> 클래스를 가진 요소를 만들면 내부 요소는 여전히 대체 박스 모델을 사용한다.</p>\n<pre><code class=\"language-html\">&#x3C;div class=\"my-box\">\n  &#x3C;header> &#x3C;!-- 여전히 대체 박스 모델이 사용되고 있다. -->\n    ...여러 요소들...\n  &#x3C;/header>\n&#x3C;/div>\n</code></pre>\n<p>따라서 최상단 요소인 html에 대체 박스 모델을 설정하고 <code>*</code>에 대해서는 box-sizing을 상속받도록 설정한다. 그것이 바로 다음 CSS이다.</p>\n<pre><code class=\"language-css\">html {\n  box-sizing: border-box;\n}\n*, *::before, *::after {\n  box-sizing: inherit;\n}\n</code></pre>\n<h2>4.4. 마진/패딩</h2>\n<h3>4.4.1. 마진</h3>\n<p>마진은 박스 주변에 여백을 만든다. 이때 margin은 양수뿐 아니라 음수가 될 수도 있다. 만약 마진이 음수이면 박스가 그쪽으로 밀려나게 된다.</p>\n<p>마진 상쇄도 주의해야 한다. 마진이 서로 맞닿아 있는 2개의 요소가 있다면 그 여백들은 그 중 가장 큰 여백의 크기로 합쳐진다.</p>\n<p>다음과 같이 2개의 박스를 만들고 css를 설정했다고 하자.</p>\n<pre><code class=\"language-html\">&#x3C;div class=\"box1\">box 1&#x3C;/div>\n&#x3C;div class=\"box2\">box 2&#x3C;/div>\n</code></pre>\n<pre><code class=\"language-css\">.box1 {\n  margin-bottom: 20px;\n}\n\n.box2 {\n  margin-top: 10px;\n}\n</code></pre>\n<p>그러면 box1과 box2의 아래, 위 마진은 합쳐져서 둘 중에 큰 20px짜리 마진이 된다.</p>\n<p>단 이런 마진 상쇄도 플로팅 요소, 절대 위치(<code>position:absolute</code>)를 지정한 요소에 대해서는 일어나지 않는다. 다음과 같은 3가지 상황에 일어난다.</p>\n<ul>\n<li>두 개의 인접한 형제 요소의 맞닿은 margin 상쇄</li>\n<li>부모 요소와 자식 요소를 분리하는 콘텐츠(테두리, 패딩, 콘텐츠, 자식의 height등)가 없을 경우 부모와 자손의 margin 상쇄</li>\n<li>테두리, 패딩, 콘텐츠, height, min-height, max-height가 없는 빈 블록의 margin-top과 margin-bottom 상쇄</li>\n</ul>\n<h3>4.4.2. 패딩</h3>\n<p>패딩은 테두리와 콘텐츠 사이에 위치한다. 마진과 달리 음수 값을 가질 수 없다.</p>\n<h2>4.5. 인라인 블록 디스플레이</h2>\n<p>display 항목 중 <code>inline-block</code>은 인라인 요소처럼 다른 요소와 같은 줄에 배치되지만(즉 줄바꿈 안 함), 블록 요소처럼 너비와 높이를 가질 수 있다. 공간을 차지하여 다른 요소가 박스에서 밀려나므로 겹침 현상도 피할 수 있다.</p>\n<p>또한 이렇게 inline-block으로 설정된 요소는 크기를 갖춘 하나의 박스로서 기능하게 되므로 다른 블록의 패딩도 존중하게 된다.</p>\n<p>어떤 문서에 링크 텍스트가 들어 있는데 이 텍스트를 줄바꿈 없이 배치하면서도 텍스트가 차지하는 영역을 확대하고 싶다면 이 <code>inline-block</code>을 사용하면 된다. a 태그는 원래는 인라인 요소이다.</p>\n<h1>참고</h1>\n<p><a href=\"https://poiemaweb.com/css3-inheritance-cascading\">https://poiemaweb.com/css3-inheritance-cascading</a></p>\n<p><a href=\"https://stackoverflow.com/questions/6749569/css-which-takes-precedence-inline-or-the-class\">https://stackoverflow.com/questions/6749569/css-which-takes-precedence-inline-or-the-class</a></p>\n<p><a href=\"https://css-tricks.com/inheriting-box-sizing-probably-slightly-better-best-practice/\">https://css-tricks.com/inheriting-box-sizing-probably-slightly-better-best-practice/</a></p>",
    "excerpt": "MDN의 CSS 구성요소 파트를 읽고 정리하는 곳이다. CSS의 필수적인 이론들을 알아보는 파트이다.\n1. 셀렉터\n앞서 갖가지 셀렉터를 알아보았다. 이제 몇 가지 추가적인 지식을 알아보자. 셀렉터들의 기본 정의와 같은 것들은 이전 글에서 했으므로 넘어간다.\n1.1. 범용 셀렉터\n*를 사용하여 모든 요소를 선택할 수 있다. 이는 앞서 보았다시피 모든 요소를 선택한다. 하지만 모든 요소에 동시에 스타일링을 해야 할 일은 거의 없다. 그럼 어디 쓰일까?\n가독성을 높이",
    "headingTree": [
      {
        "title": "1. 셀렉터",
        "url": "#1-셀렉터",
        "items": [
          {
            "title": "1.1. 범용 셀렉터",
            "url": "#11-범용-셀렉터",
            "items": []
          },
          {
            "title": "1.2. 클래스 셀렉터",
            "url": "#12-클래스-셀렉터",
            "items": []
          },
          {
            "title": "1.3. 의사 클래스와 의사 요소",
            "url": "#13-의사-클래스와-의사-요소",
            "items": []
          },
          {
            "title": "1.4. ::before와 ::after",
            "url": "#14-before와-after",
            "items": []
          }
        ]
      },
      {
        "title": "2. 계단식 및 상속",
        "url": "#2-계단식-및-상속",
        "items": [
          {
            "title": "2.1. 규칙 충돌",
            "url": "#21-규칙-충돌",
            "items": [
              {
                "title": "2.1.1. 중요도 규칙",
                "url": "#211-중요도-규칙",
                "items": []
              },
              {
                "title": "2.1.2. 명시도",
                "url": "#212-명시도",
                "items": []
              },
              {
                "title": "2.1.3. 선언 순서",
                "url": "#213-선언-순서",
                "items": []
              }
            ]
          },
          {
            "title": "2.2. 상속",
            "url": "#22-상속",
            "items": []
          }
        ]
      },
      {
        "title": "3. cascade layer",
        "url": "#3-cascade-layer",
        "items": [
          {
            "title": "3.1. 캐스케이드란",
            "url": "#31-캐스케이드란",
            "items": []
          }
        ]
      },
      {
        "title": "4. 박스 모델",
        "url": "#4-박스-모델",
        "items": [
          {
            "title": "4.1. 블록 박스와 인라인 박스",
            "url": "#41-블록-박스와-인라인-박스",
            "items": []
          },
          {
            "title": "4.2. 디스플레이 유형",
            "url": "#42-디스플레이-유형",
            "items": []
          },
          {
            "title": "4.3. CSS 박스 모델",
            "url": "#43-css-박스-모델",
            "items": [
              {
                "title": "4.3.1. 대체 박스 모델",
                "url": "#431-대체-박스-모델",
                "items": []
              },
              {
                "title": "4.3.2. 대체 박스 모델 선언에 대하여",
                "url": "#432-대체-박스-모델-선언에-대하여",
                "items": []
              }
            ]
          },
          {
            "title": "4.4. 마진/패딩",
            "url": "#44-마진패딩",
            "items": [
              {
                "title": "4.4.1. 마진",
                "url": "#441-마진",
                "items": []
              },
              {
                "title": "4.4.2. 패딩",
                "url": "#442-패딩",
                "items": []
              }
            ]
          },
          {
            "title": "4.5. 인라인 블록 디스플레이",
            "url": "#45-인라인-블록-디스플레이",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 360
    },
    "url": "/posts/mdn-css-2",
    "thumbnail": {
      "local": "/static/before-after-b7814fe0.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-before-after-b7814fe0-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAACCAIAAADq9gq6AAAACXBIWXMAAAsTAAALEwEAmpwYAAAANElEQVR4nB3BMQ0AQQwDwSsCIp0ZLIxACE3XBhfppZ95MwN09+7aTmL77t78JAFVBUhK8gHN7RGM+9gB8wAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "mdn-css-3",
    "title": "프론트 지식 익히기 CSS-3",
    "date": "2023-04-04T00:00:00Z",
    "description": "MDN CSS 튜토리얼 - 3",
    "tags": [
      "web",
      "study",
      "front",
      "CSS"
    ],
    "html": "<h1>1. 배경 및 테두리</h1>\n<p>CSS의 배경(background)와 테두리(border)로 무엇을 할 수 있는가?</p>\n<h2>1.1. 배경</h2>\n<p>CSS background 속성은 여러 배경 속성의 shorthand이다. 여기 포함된 속성은 다음과 같다.</p>\n<ul>\n<li>background-attachment</li>\n<li>background-clip</li>\n<li>background-color</li>\n<li>background-image</li>\n<li>background-origin</li>\n<li>background-position</li>\n<li>background-repeat</li>\n<li>background-size</li>\n</ul>\n<p>이를 하나하나 알아보자.</p>\n<h3>1.1.1. background-color</h3>\n<p>요소의 배경색을 설정한다. red, blue 등의 키워드, hex표기, rgb()/rgba() 의 함수 표기 등 유효한 색 표현을 사용할 수 있다.</p>\n<h3>1.1.2. background-image</h3>\n<p>요소의 배경 이미지를 설정한다. url() 함수를 사용하여 이미지의 경로를 지정할 수 있다. 박스보다 작은 이미지를 설정할 경우 이미지가 반복되어 배경으로 설정된다.(background-repeat가 기본값일 경우)</p>\n<p>그리고 이미지 외에 배경색을 지정할 시 이미지가 색상 위로 표시된다.</p>\n<p>이 속성에 그라디언트를 사용하면 요소의 배경을 그라데이션으로 설정할 수 있다. 예를 들어 linear-gradient() 함수를 사용하면 선형 그라데이션을 설정할 수 있다.</p>\n<pre><code class=\"language-css\">{\n  background-image: linear-gradient(to right, red, blue);\n}\n</code></pre>\n<p>radial-gradient, repeating-linear-gradient, repeating-radial-gradient, conic-gradient 등 다른 종류의 그라데이션 함수들도 있다.</p>\n<p>그리고 여러 배경 이미지를 설정할 수도 있다. 쉼표로 구분하면 된다.</p>\n<pre><code class=\"language-css\">background-image: url(\"image1.png\"), url(\"image2.png\");\n</code></pre>\n<p>이러면 이미지는 앞에 온 게 우선적으로 고려되어, image1이 image2보다 위에 표시된다.</p>\n<h3>1.1.3. background-repeat</h3>\n<p>앞서서 background-image를 통해 설정한 이미지가 박스보다 작으면 반복해서 표시된다고 했다. 하지만 이 repeat 속성을 이용하면 그 반복을 막거나 특정 축으로만 반복할 수 있다.</p>\n<h3>1.1.4 background-size</h3>\n<p>배경 이미지를 지정할 경우 이미지가 요소보다 커서 이미지가 잘릴 수 있다. 이 경우 background-size 속성을 이용하여 이미지 크기를 맞출 수 있다. 이때 배경 이미지로 덮이지 않은 공간은 background-color로 지정한 색상으로 채워진다.</p>\n<p>contain, cover 키워드를 사용하면 이미지가 잘리거나 찌그러지지 않는 한도 내에서 크기가 제일 크게 설정된다. cover의 경우 요소에 빈 공간이 생기지 않도록 이미지를 확대 후 잘라내기도 한다.</p>\n<p>또한 명시적으로 size를 줄 수도 있는데 하나만 줄 경우 그 사이즈가 이미지 너비가 되고 높이는 자동으로 설정된다. 두 개를 줄 경우 각각 이미지 너비와 높이가 설정된다.</p>\n<pre><code class=\"language-css\">{\n  background-size: contain;\n  // 너비 설정\n  background-size: 100px;\n  // 높이 설정\n  background-size: 100px 50%;\n}\n</code></pre>\n<h3>1.1.5. background-position</h3>\n<p>배경이 들어갈 박스에서 이미지가 나타나는 위치를 선택할 수 있다. 왼쪽 상단 꼭짓점이 <code>(0,0)</code>이다. 각각 x축, y축의 시작 위치를 설정할 수 있다.</p>\n<p>top, right등의 키워드를 사용하거나 20px, 50%등의 수치를 사용할 수 있다.</p>\n<p>4개의 값을 사용할 수도 있는데 이때 길이 단위는 앞의 키워드 방향과의 간격이다.</p>\n<pre><code class=\"language-css\">{\n  // 오른쪽 위에 배치\n  background-position: top right;\n  // 왼쪽 위 꼭짓점 기준으로 x축은 20px, y축은 50% offset\n  background-position: 20px 50%;\n  // 아래에서 30% 오른쪽에서 30% offset\n  background-position: bottom 30% right 30%;\n}\n</code></pre>\n<h3>1.1.6. background-atatchment</h3>\n<p>내용이 스크롤될 때 스크롤하는 방법을 지정한다.</p>\n<p>scroll로 지정하면 페이지 스크롤시 배경도 같이 스크롤되게 한다. 요소 스크롤과는 상관없다. fixed로 설정 시 배경이 고정되어 스크롤되지 않는다. local은 배경을 설정된 요소로 고정하므로 요소가 스크롤되면 배경도 같이 스크롤된다. 페이지 스크롤에도 반응한다.</p>\n<p><a href=\"https://mdn.github.io/learning-area/css/styling-boxes/backgrounds/background-attachment.html\">각 요소의 스크롤 예시</a></p>\n<h2>1.2. 테두리</h2>\n<p>border CSS는 border-width, border-style, border-color의 shorthand이다.</p>\n<pre><code class=\"language-css\">border: 1px solid red;\n</code></pre>\n<p>만약 상하좌우 border를 다르게 설정하고 싶다면 border-top 등을 사용할 수 있다.</p>\n<h3>1.2.1. 둥근 테두리</h3>\n<p>border-radius 속성을 통해 모서리 둥글기를 설정할 수 있다. 각각의 모서리를 설정할 수도 있고, 모든 모서리를 한 번에 설정할 수도 있다.</p>\n<pre><code class=\"language-css\">{\n  border-radius: 10px;\n  // 모서리 가로반경 10px, 세로반경 20px\n  border-radius: 10px 20px;\n  border-top-left-radius: 1px;\n  border-top-right-radius: 2px;\n}\n</code></pre>\n<h1>2. 텍스트 표시 방향</h1>\n<p>아랍어는 오른쪽에서 왼쪽으로 쓰고, 일본어는 위에서 아래로 쓴다. 이런 쓰기 모드를 변경하기 위해서는 <code>writing-mode</code> 속성을 사용한다.</p>\n<h2>2.1. 표시 방향의 영향</h2>\n<p>이 표시 방향은 어디에 영향을 미칠까? 요소의 배치와 텍스트의 흐름 방향이 바뀐다.</p>\n<p>예를 들어서 다음과 같이 요소들을 배치했다고 하자.</p>\n<pre><code class=\"language-html\">&#x3C;div class=\"blue-box\">Blue&#x3C;/div>\n&#x3C;div class=\"aqua-box\">Aqua&#x3C;/div>\n</code></pre>\n<p>그러면 Blue Box가 Aqua Box 위에 위치하게 된다. 즉 위->아래 방향으로 블록이 쌓인다.</p>\n<p>그럼 표시 방향을 바꾸면?</p>\n<pre><code class=\"language-css\">body {\n  writing-mode: vertical-lr;\n}\n</code></pre>\n<p>body 내의 블록 요소가 왼쪽에서 오른쪽으로 쌓인다.</p>\n<p><img src=\"/static/writing-mode-edc5cdd3.png\" alt=\"dir-result\"></p>\n<p><code>vertical-rl</code>로 설정하면 블록이 오른쪽에서 왼쪽 방향으로 쌓인다.</p>\n<p>즉 읽기 모드를 바꾸면 사람들이 페이지를 읽어야 하는 방향을 바꿀 수 있다.</p>\n<p>블록 요소는 <code>-</code>뒤에 있는 방향을 따른다. 예를 들어서 <code>vertical-rl</code>이면 블록 요소는 오른쪽에서 왼쪽으로 쌓인다. 그리고 인라인 요소는 <code>-</code>앞에 있는 방향을 따른다. <code>vertical-rl</code>이면 인라인 요소는 위에서 아래로 쌓인다.</p>\n<h2>2.2. 텍스트 흐름 방향</h2>\n<p>앞서 아랍어처럼 오른쪽에서 왼쪽으로 쓰이는 언어에 대해서 말했다. 이런 언어는 텍스트 흐름 방향이 오른쪽에서 왼쪽이다.</p>\n<p>웹은 왼쪽에서 오른쪽으로 읽히는 언어만 쓰이는 게 아니므로 최신 CSS는 방향을 참조하지 않는다. 대신 인라인과 블록이라는 아이디어와 함께 시작, 끝을 다룬다. 이는 나중에 다시 이야기할 날이 있을 것이다.</p>\n<h2>2.3. 텍스트 방향과 너비, 높이</h2>\n<p><code>writing-mode: vertical-rl</code>로 설정하면 블록 요소의 방향이 바뀐다. 그럴 때 너비와 높이를 설정하면 어떻게 될까?</p>\n<p>먼저 writing-mode가 없을 때 기본적인 너비와 높이를 설정해보자.</p>\n<pre><code class=\"language-css\">.box {\n  width: 500px;\n  height: 150px;\n  border: 1px solid black;\n}\n</code></pre>\n<p>그리고 여기에 맞게 로렘 입숨 텍스트를 넣어보자.</p>\n<pre><code class=\"language-html\">&#x3C;div class=\"box\">\n  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod\n  tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim\n  veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea\n  commodo consequat. Duis aute irure dolor in reprehenderit in voluptate\n  velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat\n  cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id\n  est laborum.\n&#x3C;/div>\n</code></pre>\n<p>그럼 다음과 같이 박스가 표시될 것이다.</p>\n<p><img src=\"/static/lorem-horizontal-62c4812c.png\" alt=\"lorem-horizontal\"></p>\n<p>그런데 writing-mode를 vertical-rl로 설정하면 어떻게 될까? 그러면 다음과 같이 표시된다.</p>\n<p><img src=\"/static/lorem-vertical-0a118c03.png\" alt=\"lorem-vertical\"></p>\n<p>우리는 페이지의 흐름을 세로로 바꾸었는데 높이와 너비가 본질적으로 바뀌지 않았다.</p>\n<p>이를 위해서 CSS는 <code>block-size</code>와 <code>inline-size</code>라는 속성을 제공한다. 이 속성은 writing-mode에 따라 너비와 높이를 바꿔준다.</p>\n<p>width는 inline-size에, height는 block-size에 대응한다. 위의 CSS를 다음과 같이 바꿔보자.</p>\n<pre><code class=\"language-css\">.box {\n  inline-size: 500px;\n  block-size: 150px;\n  border: 1px solid black;\n}\n</code></pre>\n<p>그러면 이제 writing-mode가 vertical-rl이어도 본질적인 너비와 높이가 바뀌지 않는다.</p>\n<p><img src=\"/static/lorem-fit-8f8017d4.png\" alt=\"lorem-fit\"></p>\n<h2>2.4. 텍스트 방향과 margin, padding</h2>\n<p>방향에 따라 다르게 줄 수 있는 속성은 또 있다. 지난번에 본 마진과 패딩이다. 가령 <code>margin-top</code>같은 속성이 있다.</p>\n<p>이 또한 위에서 너비와 높이에 그랬던 것과 같이 writing-mode에 따라 다른 방향을 가리키게 만들 수 있다. 즉 논리적 방향을 가리키게 만들 수 있다. <code>margin-block-start</code>와 같은 속성을 쓰면 된다.</p>\n<p>블럭의 방향 상에서 위와 아래에 마진을 주고 싶다면 <code>margin-block</code>를 쓰면 되고 좌우에 마진을 주고 싶다면 <code>margin-inline</code>를 쓰면 된다. 그리고 start, end를 붙이면 해당 방향의 시작과 끝에 마진을 줄 수 있다.</p>\n<p>가령 margin-left는 margin-inline-start와 같다. padding도 같은 어미를 쓴다.</p>\n<ul>\n<li>top -> block-start</li>\n<li>bottom -> block-end</li>\n<li>left -> inline-start</li>\n<li>right -> inline-end</li>\n</ul>\n<p>다만 이런 논리적 속성값은 top, bottom과 같은 물리적 속성보다 최신이기 때문에 브라우저에 따라 지원이 안 될 수도 있다.</p>\n<p>따라서 여러 쓰기 방향을 사용하지 않는 경우 물리적 속성을 사용하는 것이 아직은 좋다. 다만 flex, grid 같은 레이아웃 방법을 다루기 시작하면 많은 의미가 생기기 때문에 논리적 속성이 더 많이 쓰이게 될 것이다.</p>\n<h1>3. 콘텐츠 오버플로우</h1>\n<p>박스에 담기에 너무 많은 내용이 박스 내에 포함되어 있을 때 박스 오버플로우가 발생한다. 예를 들어서 높이 100px 짜리 박스에 텍스트 100줄이 들어 있다거나 하는 상황이다.</p>\n<p>CSS는 이런 오버플로우를 다룰 수 있는 방법을 여러 가지 제공한다. overflow 속성을 쓰면 된다.</p>\n<p>overflow 속성의 기본값은 visible인데 이는 오버플로우된 컨텐츠를 보여준다. overflow 속성을 hidden으로 설정하면 오버플로우된 컨텐츠를 잘라낸다.</p>\n<p><code>overflow:scroll</code>이면 오버플로우된 내용에 대해 스크롤이 생긴다. 이때 오버플로우가 없는 방향에도 스크롤이 생길 수 있으므로 <code>overflow-x</code>와 <code>overflow-y</code>를 따로 설정할 수도 있다. 오버플로우가 발생할 때 스크롤을 만드는 걸 브라우저에게 맡기려면 <code>overflow:auto</code>로 설정하면 된다.</p>\n<h2>3.1. 단어 오버플로우</h2>\n<p>작은 박스에서 긴 단어를 처리해야 하는 경우가 있을 수 있다. 즉 x축의 오버플로우가 나는 것이다. 이때 word-break와 overflow-wrap을 사용할 수 있다.</p>\n<p>word-break는 단어가 박스를 넘어가면 어떻게 처리할지를 결정한다. 기본값은 normal인데 이는 단어가 박스를 넘어가면 박스 밖으로 넘어간다.</p>\n<p>이를 <code>word-break:break-all</code>로 설정하면 단어가 박스를 넘어가면 단어의 끊김에 상관없이 박스 내에서 줄바꿈이 일어난다.</p>\n<p><code>overflow-wrap</code> 요소는 어떤 문자가 박스를 넘어가면 줄바꿈을 할지를 결정한다. 기본값인 normal은 두 단어 사이의 공백 등 보통의 줄바꿈 지점에서만 줄을 바꾼다. break-word는 줄바꿈을 할 지점이 없을 시 임의 지점에서 줄을 바꾼다.</p>",
    "excerpt": "1. 배경 및 테두리\nCSS의 배경(background)와 테두리(border)로 무엇을 할 수 있는가?\n1.1. 배경\nCSS background 속성은 여러 배경 속성의 shorthand이다. 여기 포함된 속성은 다음과 같다.\n\nbackground-attachment\nbackground-clip\nbackground-color\nbackground-image\nbackground-origin\nbackground-position\nbackground-repeat\nbac",
    "headingTree": [
      {
        "title": "1. 배경 및 테두리",
        "url": "#1-배경-및-테두리",
        "items": [
          {
            "title": "1.1. 배경",
            "url": "#11-배경",
            "items": [
              {
                "title": "1.1.1. background-color",
                "url": "#111-background-color",
                "items": []
              },
              {
                "title": "1.1.2. background-image",
                "url": "#112-background-image",
                "items": []
              },
              {
                "title": "1.1.3. background-repeat",
                "url": "#113-background-repeat",
                "items": []
              },
              {
                "title": "1.1.4 background-size",
                "url": "#114-background-size",
                "items": []
              },
              {
                "title": "1.1.5. background-position",
                "url": "#115-background-position",
                "items": []
              },
              {
                "title": "1.1.6. background-atatchment",
                "url": "#116-background-atatchment",
                "items": []
              }
            ]
          },
          {
            "title": "1.2. 테두리",
            "url": "#12-테두리",
            "items": [
              {
                "title": "1.2.1. 둥근 테두리",
                "url": "#121-둥근-테두리",
                "items": []
              }
            ]
          }
        ]
      },
      {
        "title": "2. 텍스트 표시 방향",
        "url": "#2-텍스트-표시-방향",
        "items": [
          {
            "title": "2.1. 표시 방향의 영향",
            "url": "#21-표시-방향의-영향",
            "items": []
          },
          {
            "title": "2.2. 텍스트 흐름 방향",
            "url": "#22-텍스트-흐름-방향",
            "items": []
          },
          {
            "title": "2.3. 텍스트 방향과 너비, 높이",
            "url": "#23-텍스트-방향과-너비-높이",
            "items": []
          },
          {
            "title": "2.4. 텍스트 방향과 margin, padding",
            "url": "#24-텍스트-방향과-margin-padding",
            "items": []
          }
        ]
      },
      {
        "title": "3. 콘텐츠 오버플로우",
        "url": "#3-콘텐츠-오버플로우",
        "items": [
          {
            "title": "3.1. 단어 오버플로우",
            "url": "#31-단어-오버플로우",
            "items": []
          }
        ]
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 374
    },
    "url": "/posts/mdn-css-3",
    "thumbnail": {
      "local": "/static/writing-mode-edc5cdd3.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-writing-mode-edc5cdd3-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAIAAAA8r+mnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAQklEQVR4nGNIK7zLwLCKgWEFg8gWw///rcGo4f9/BgbRbQwMiyHIACbhCJJg34hdgtvpJAPDcpBRwltMYBL1//8DAOcwME5KObkmAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "mdn-css-4",
    "title": "프론트 지식 익히기 CSS-4",
    "date": "2023-04-06T00:00:00Z",
    "description": "MDN CSS 튜토리얼 - 4",
    "tags": [
      "web",
      "study",
      "front",
      "CSS"
    ],
    "html": "<h1>1. CSS 값과 단위</h1>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Learn/CSS/Building_blocks/Values_and_units\">참고글 링크</a></p>\n<p>CSS의 모든 속성에는 허용되는 값이 있다. 이런 값은 색, 크기 등이 있는데 이런 값의 이름은 흔히 <code>&#x3C;color></code>와 같이 꺽쇠로 묶여서 표현된다. CSS 속성과 구별하기 위해서이다.</p>\n<p>자주 접할 수 있는 몇 가지 유형의 값을 알아보자.</p>\n<p>숫자, 길이, 백분율 값들이 CSS에서 가장 골치를 썩인다.</p>\n<p><code>&#x3C;integer></code>는 정수를 나타내고, <code>&#x3C;number></code>는 이를 확장하여 10진수 실수까지 포괄한다. <code>&#x3C;dimension></code>은 number에 단위가 붙어 있는, <code>10px</code>와 같은 것이다. 그리고 <code>&#x3C;percentage></code>는 부모 요소의 길이 등 어떤 다른 값을 기준으로 하는 백분율을 나타낸다.</p>\n<p>길이는 절대 단위와 상대 단위로 나뉘는데, 절대 단위는 cm, mm, in 등 항상 동일한 크기로 간주된다. 이런 값들은 인쇄에 사용될 때 유용하며 보통은 px만 사용한다.</p>\n<p>상대 길이 단위는 상위 요소의 글꼴 크기 등 페이지의 다른 요소와 관련이 있다. em, rem, vw, vh 등이 있다.</p>\n<h2>1.1. em, rem</h2>\n<p>em과 rem은 가장 많이 쓰이는 2개의 상대 길이이다. 두 개의 차이는 어떤 요소의 글꼴 크기를 기준으로 하느냐이다.</p>\n<p>em 단위는 부모 요소의 글꼴 크기를 가져온다. 그리고 rem 단위는 루트 요소의 글꼴 크기를 가져온다. 루트 요소는 보통 html 요소이다.</p>\n<p>따라서 다음과 같은 html을 작성하고 rem과 em을 사용해보자.</p>\n<pre><code class=\"language-html\">&#x3C;div class=\"box\">\n  첫번째 박스\n  &#x3C;div class=\"box\">\n    두번째 박스\n    &#x3C;div class=\"box\">세번째 박스&#x3C;/div>\n  &#x3C;/div>\n&#x3C;/div>\n</code></pre>\n<pre><code class=\"language-css\">.box {\n  font-size: 1.5em;\n}\n</code></pre>\n<p>그러면 각각의 중첩된 박스에서 부모의 글꼴 크기를 가져와서 그 1.5배로 글꼴 크기를 설정하므로 박스가 중첩되므로 글꼴이 점점 커진다.</p>\n<p><img src=\"/static/em-example-ed95ef6a.png\" alt=\"em-example\"></p>\n<p>rem은 루트 요소의 글꼴 크기를 가져오므로 다음과 같이 설정하면 모든 박스의 글꼴 크기가 html 요소의 글꼴 크기의 1.5배가 된다.</p>\n<pre><code class=\"language-css\">.box {\n  font-size: 1.5rem;\n}\n</code></pre>\n<p><img src=\"/static/rem-example-3f557fe3.png\" alt=\"rem-example\"></p>\n<p>따라서 html 요소의 글꼴 크기를 변경할 시 모든 rem의 기준이 변한다.</p>\n<h2>1.2. 백분율</h2>\n<p>백분율은 당연히 그 의미상 다른 값에 상대적으로 설정된다. 이는 부모 요소의 같은 값에 대응한다. 예를 들어, 부모 요소의 너비가 100px이고 자식 요소의 너비가 50%라면 자식 요소의 너비는 50px이 된다.</p>\n<p>width 등의 여러 값에서 길이, 백분율 둘 다 쓸 수 있다. 그런데 길이만 허용하는 때도 있는데 이럴 경우 속성이 허용하는 값에 <code>&#x3C;length></code>만 적혀 있다.</p>\n<h2>1.3. 숫자</h2>\n<p>opacity 등의 속성의 경우 단위 없이 숫자만 허용한다.</p>\n<h1>2. 항목 크기 조정</h1>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Learn/CSS/Building_blocks/Sizing_items_in_CSS\">CSS에서 항목 크기 조정</a></p>\n<p>CSS에서의 사물의 여러 크기에 대해 알아보자. 먼저 HTML 요소는 CSS로 크기를 설정하기 이전에도 고유한 크기를 가진다. 예를 들어서 img 태그에 이미지를 삽입 시 이미지의 원래 크기만큼의 크기를 가질 것이다.</p>\n<p>그러나 우리는 width, height로 요소의 크기를 따로 설정해 줄 수도 있다.</p>\n<p>마진과 패딩을 백분율로 설정할 수 있다. 예를 들어서 <code>margin: 10%</code>라고 설정하면 부모 요소의 너비의 10%만큼의 마진이 설정된다. 그런데 이때 백분율은 인라인 크기를 기준으로 계산된다. 따라서 <code>margin-top:10%</code>가 부모 요소의 높이를 기준으로 계산되지 않는 것이다. 늘 부모 요소의 너비를 기준으로 계산된다.</p>\n<p>min-height, max-height, max-width, max-height 등의 속성으로 요소의 최소, 최대 크기를 설정할 수 있다.</p>\n<p>각각 뷰포트 너비의 1%, 높이의 1%를 나타내는 vw, vh도 사용할 수 있다.</p>\n<h1>3. 이미지, 미디어, 양식 요소</h1>\n<p>이미지 등의 미디어 요소들은 CSS를 사용해서 스타일을 지정할 수 있다.</p>\n<p>이미지나 비디오는 iframe과 같이 대체 요소로서, CSS는 이미지 요소의 내부 레이아웃에 영향을 주지 않으며 특수한 CSS 속성으로 제어해야 한다.</p>\n<h2>3.1. object-fit</h2>\n<p>대체 요소의 콘텐츠 크기를 요소에 맞추는 방식을 지정한다. 다음과 같은 종류들이 있다.</p>\n<pre><code class=\"language-css\">object-fit: contain;\n</code></pre>\n<p>콘텐츠의 가로세로비를 유지하면서 부모 요소의 크기에 맞춘다. 요소와 가로세로비가 다르면 빈 공간이 생기게 된다. 즉 요소의 크기에 맞추는 것이 아니라 콘텐츠의 크기에 맞추는 것이다.</p>\n<pre><code class=\"language-css\">object-fit: cover;\n</code></pre>\n<p>콘텐츠의 가로세로비를 유지하면서 부모 요소의 크기에 맞춘다. cover같은 경우에는 요소의 크기만큼 콘텐츠를 늘려서 맞추는 것이다.</p>\n<pre><code class=\"language-css\">object-fit: fill;\n</code></pre>\n<p>요소 박스 크기에 맞게 콘텐츠를 조절한다. 가로세로비를 맞추지 않으면 콘텐츠가 늘어난다.</p>\n<pre><code class=\"language-css\">object-fit: none;\n</code></pre>\n<p>대체 콘텐츠 크기를 조절하지 않는다.</p>\n<pre><code class=\"language-css\">object-fit: scale-down;\n</code></pre>\n<p>none, contain 중 컨텐츠 크기가 더 작아지는 값을 택한다.</p>\n<h2>3.2. form</h2>\n<p>form에는 여러 가지 요소가 쓰이는데 일단 입력 요소들이 있다. input과 textarea와 같은 요소는 다른 박스처럼 동작하고 스타일링하기 쉽다. 이때 속성 선택자를 이용해서 input의 type별로 다른 스타일을 적용할 수 있다.</p>\n<pre><code class=\"language-css\">input[type=\"text\"] {\n  background-color: #f0f0f0;\n}\n\ninput[type=\"submit\"]{\n  background-color: #333;\n}\n</code></pre>\n<p>그리고 몇몇 브라우저에선 양식 요소가 기본적으로 글꼴을 상속하지 않는다. 따라서 양식 요소에 글꼴을 상속하도록 CSS에 추가해 줘야 할 때가 있다.</p>\n<pre><code class=\"language-css\">button,\ninput,\nselect,\ntextarea {\n  font-family : inherit;\n  font-size : 100%;\n}\n</code></pre>\n<h1>4. 표 스타일링 CSS 정보</h1>\n<p>앞에서 HTML로 표를 만드는 방법에 대해서 배웠었다. table, caption, tr, th, td, thead, tbody 등의 태그를 사용한다.</p>\n<pre><code class=\"language-html\">&#x3C;table>\n  &#x3C;caption>\n    table 태그를 사용해서 만들어진 표\n  &#x3C;/caption>\n  &#x3C;thead>\n    &#x3C;tr>\n      &#x3C;th scope=\"col\">이름&#x3C;/th>\n      &#x3C;th scope=\"col\">나이&#x3C;/th>\n      &#x3C;th scope=\"col\">성별&#x3C;/th>\n    &#x3C;/tr>\n  &#x3C;/thead>\n  &#x3C;tbody>\n    &#x3C;tr>\n      &#x3C;td>홍길동&#x3C;/td>\n      &#x3C;td>20&#x3C;/td>\n      &#x3C;td>남&#x3C;/td>\n    &#x3C;/tr>\n    &#x3C;tr>\n      &#x3C;td>김철수&#x3C;/td>\n      &#x3C;td>25&#x3C;/td>\n      &#x3C;td>남&#x3C;/td>\n    &#x3C;/tr>\n    &#x3C;tr>\n      &#x3C;td>이영희&#x3C;/td>\n      &#x3C;td>30&#x3C;/td>\n      &#x3C;td>여&#x3C;/td>\n    &#x3C;/tr>\n  &#x3C;/tbody>\n&#x3C;/table>\n</code></pre>\n<p>이를 브라우저에 렌더링하면 다음과 같이 표시된다.</p>\n<p><img src=\"/static/table-no-style-aeecff91.png\" alt=\"table_no_style\"></p>\n<p>표를 위한 표준 태그들을 사용했기 때문에 시맨틱하게 짜여졌고 접근성도 좋다. 하지만 실제로 렌더링된 표는 읽기 힘들고 볼품없다. 이를 CSS를 써서 꾸밀 수 있다.</p>\n<p>CSS 파일을 만들고 link 태그를 이용해서 HTML 파일과 연결하자.</p>\n<pre><code class=\"language-html\">&#x3C;link href=\"index.css\" rel=\"stylesheet\" type=\"text/css\" />\n</code></pre>\n<p>그리고 우리가 바꿀 몇 가지 CSS 속성들을 알아보자.</p>\n<h2>4.1. table-layout</h2>\n<p>테이블 각 셀의 너비를 어떻게 결정할지를 지정한다. auto와 fixed로 지정할 수 있다.</p>\n<p>auto로 지정할 시 브라우저에 테이블 레이아웃 지정을 맡긴다. 이 경우 테이블과 각 셀의 너비는 셀에 담겨 있는 내용들에 fit하게 결정된다.</p>\n<p>fixed로 지정할 시 table, col 요소의 width 속성을 통해 표와 각 열의 너비를 지정한다. 이렇게 fixed 레이아웃 하에서 셀 너비를 지정할 시 그대로 지정된다. 그런 너비가 없다면 첫 행에 있는 셀들의 너비로 표와 각 열의 너비를 결정한다.</p>\n<p>fixed를 사용할 경우 auto보다 렌더링을 더 빠르게 할 수 있다. 표의 첫 행만 브라우저가 인식하고 나면 전체 표를 바로 렌더링할 수 있기 때문이다. 이렇 첫 행의 셀들의 너비로 열의 너비를 결정하면 아래 행에 있는 셀들에서는 내용이 넘칠 수 있다. 이는 이전에 배운 overflow로 제어한다.</p>\n<h2>4.2. border-collapse</h2>\n<p>표 테두리가 겹칠 때 어떻게 처리할지에 관한 속성이다.</p>\n<p>collapse로 지정할 시 테두리가 겹치는 부분을 하나로 합쳐서 처리한다. 이 경우 테두리의 두께는 가장 두꺼운 테두리의 두께로 결정된다.</p>\n<p>다음과 같이 CSS를 지정해 보자.</p>\n<pre><code class=\"language-css\">table{\n  table-layout: fixed;\n  width:100%;\n  border-collapse: collapse;\n  border: 1px solid #000;\n}\n\n\nth{\n  border: 3px solid #7048e8;\n}\n\ntd{\n  border: 5px solid #74c0fc;\n}\n</code></pre>\n<p>그러면 다음과 같이 겹치는 테두리 두께는 가장 두꺼운 두께로 결정되는 것을 볼 수 있다. 또한 더 두꺼운 두께의 테두리가 더 우선적으로 표시되는 걸 볼 수 있다.</p>\n<p><img src=\"/static/collapse-table-b2be5a0c.png\" alt=\"collapse\"></p>\n<p>separate로 지정할 시 테두리가 겹치는 부분을 각각 처리한다. 이 경우 모든 테두리는 분리되어 표시되며 테두리간 간격은 <code>border-spacing</code>에 지정된 값으로 처리된다. 내 브라우저에서 기본값은 2px로 설정되어 있었다.</p>\n<p>위의 CSS에서 border-collapse만 separate로 설정해서 표를 렌더링하면 다음과 같아진다.</p>\n<p><img src=\"/static/separate-border-table-68543e43.png\" alt=\"separate\"></p>\n<h2>4.3. font-family</h2>\n<p>글꼴을 지정한다. 값은 <code>,</code>로 구분되어 대체될 수 있음을 나타낸다. 브라우저는 이렇게 구분된 글꼴들을 앞에서부터 보면서 컴퓨터에 설치되어 있거나 <code>@font-face</code>로 다운받을 수 있는 폰트 중 가장 첫번째 폰트를 선택해서 사용한다.</p>\n<p>이때 지정한 폰트가 모두 있다는 것을 보장할 수 없기 때문에 마지막에는 반드시 <code>sans-serif</code>나 <code>serif</code>와 같은 generic family를 지정해야 한다.</p>\n<p>이런 generic family는 serif, sans-serif, cursive, monospace, fantasy, system-ui가 있다.</p>\n<h2>4.4. nth-child를 이용한 스타일링</h2>\n<p>nth-child를 이용하면 특정 행이나 열에 스타일을 적용할 수 있다. 각 행에서 두 가지 색깔이 번갈아가며 나타나게 해보자.</p>\n<pre><code class=\"language-css\">tbody tr:nth-child(odd) {\n  background-color: #63e6be;\n}\n\ntbody tr:nth-child(even) {\n  background-color: #c0eb75;\n}\n</code></pre>\n<p>odd, even 키워드를 선택하여 홀수번째, 짝수번째 자식을 선택할 수 있다.</p>\n<p><img src=\"/static/stripe-table-d8f5e629.png\" alt=\"stripe-table\"></p>\n<h2>4.5. caption-side</h2>\n<p>caption 요소의 위치를 지정한다. top과 bottom이 있다. 만약 bottom으로 지정하면 캡션이 표의 아래에 표시된다.</p>\n<pre><code class=\"language-css\">caption{\n  caption-side:bottom;\n}\n</code></pre>\n<p><img src=\"/static/bottom-caption-table-596cbcea.png\" alt=\"bottom\"></p>\n<p>그리고 이 속성은 표의 writing-mode 즉 논리적인 위치를 기준으로 한다. 따라서 논리적인 위/아래 값도 사용할 수 있다.</p>\n<pre><code class=\"language-css\">caption-side: block-start;\ncaption-side: block-end;\ncaption-side: inline-start;\ncaption-side: inline-end;\n</code></pre>\n<h2>4.6. 표 스타일링할 때 요점</h2>\n<ul>\n<li>table-layout:fixed를 써서 레이아웃을 예측 가능하게 한다.</li>\n<li>border-collapse를 써서 테두리가 겹치는 부분을 처리한다.</li>\n<li>text-align으로 텍스트를 적절한 방향으로 정렬.</li>\n</ul>",
    "excerpt": "1. CSS 값과 단위\n참고글 링크\nCSS의 모든 속성에는 허용되는 값이 있다. 이런 값은 색, 크기 등이 있는데 이런 값의 이름은 흔히 <color>와 같이 꺽쇠로 묶여서 표현된다. CSS 속성과 구별하기 위해서이다.\n자주 접할 수 있는 몇 가지 유형의 값을 알아보자.\n숫자, 길이, 백분율 값들이 CSS에서 가장 골치를 썩인다.\n<integer>는 정수를 나타내고, <number>는 이를 확장하여 10진수 실수까지 포괄한다. <dimension>은 number",
    "headingTree": [
      {
        "title": "1. CSS 값과 단위",
        "url": "#1-css-값과-단위",
        "items": [
          {
            "title": "1.1. em, rem",
            "url": "#11-em-rem",
            "items": []
          },
          {
            "title": "1.2. 백분율",
            "url": "#12-백분율",
            "items": []
          },
          {
            "title": "1.3. 숫자",
            "url": "#13-숫자",
            "items": []
          }
        ]
      },
      {
        "title": "2. 항목 크기 조정",
        "url": "#2-항목-크기-조정",
        "items": []
      },
      {
        "title": "3. 이미지, 미디어, 양식 요소",
        "url": "#3-이미지-미디어-양식-요소",
        "items": [
          {
            "title": "3.1. object-fit",
            "url": "#31-object-fit",
            "items": []
          },
          {
            "title": "3.2. form",
            "url": "#32-form",
            "items": []
          }
        ]
      },
      {
        "title": "4. 표 스타일링 CSS 정보",
        "url": "#4-표-스타일링-css-정보",
        "items": [
          {
            "title": "4.1. table-layout",
            "url": "#41-table-layout",
            "items": []
          },
          {
            "title": "4.2. border-collapse",
            "url": "#42-border-collapse",
            "items": []
          },
          {
            "title": "4.3. font-family",
            "url": "#43-font-family",
            "items": []
          },
          {
            "title": "4.4. nth-child를 이용한 스타일링",
            "url": "#44-nth-child를-이용한-스타일링",
            "items": []
          },
          {
            "title": "4.5. caption-side",
            "url": "#45-caption-side",
            "items": []
          },
          {
            "title": "4.6. 표 스타일링할 때 요점",
            "url": "#46-표-스타일링할-때-요점",
            "items": []
          }
        ]
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 328
    },
    "url": "/posts/mdn-css-4",
    "thumbnail": {
      "local": "/static/em-example-ed95ef6a.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-em-example-ed95ef6a-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAFCAIAAAD38zoCAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAR0lEQVR4nGMICwuLioo6c+bMf1TAEBAQwMvLq6+v39PT8/37d4TEhQsXdu7ceeXKlRMnTnz+/BkhgWYCQuI3GPz//x9CwiUAIHNndYJg/tcAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "mdn-css-5",
    "title": "프론트 지식 익히기 CSS-5",
    "date": "2023-04-13T00:00:00Z",
    "description": "MDN CSS 튜토리얼 - 4",
    "tags": [
      "web",
      "study",
      "front",
      "CSS"
    ],
    "html": "<h1>1. CSS 구성</h1>\n<p>CSS를 쉽게 관리할 수 있게 하는 방법들을 알아본다.</p>\n<h2>1.1. 코딩 스타일 가이드라인</h2>\n<p>다른 사람들과 함께 작업하는 경우 프로젝트의 스타일 가이드라인을 정하고 일관성있게 따라야 한다. class의 이름 지정 규칙이나 색상을 표현하는 방법, 형식 등을 정하고 이를 모두가 따라야 한다.</p>\n<p>예를 들어서 <a href=\"https://developer.mozilla.org/ko/docs/MDN/Writing_guidelines/Writing_style_guide/Code_style_guide/CSS\">MDN 코드 예제들의 CSS가이드라인</a>이 있다.</p>\n<p>이런 가이드라인을 정할 때 한 줄에 하나의 규칙만 넣는 등, 가독성을 고려한 선택을 하는 것이 좋다.</p>\n<h2>1.2. 주석 남기기</h2>\n<p>CSS에도 설명을 위한 주석을 남기는 게 좋다. 특히 주석을 남겨야 할 부분은 특정한 이유로 인해 직관적이지 않은 CSS를 작성했을 때이다. 예를 들어 오래된 브라우저에서 지원하지 않는 특성을 사용했을 때 그 대체 속성을 적어둘 수 있는데 이런 경우 왜 대체 속성이 있는지 주석을 남기는 것이 좋다.</p>\n<pre><code class=\"language-css\">.container{\n  /* linear gradient를 지원하지 않는 브라우저의 경우 대비 */\n  background-color: purple;\n  background-image: linear-gradient(to right, #ff0000, #aa0000);\n}\n</code></pre>\n<h2>1.3. 스타일시트에 논리적인 구획 만들기</h2>\n<p>CSS에는 여러 가지 규칙들이 있는데 이들을 역할에 따라 분류하고 다른 구역에 위치시키는 건 가독성을 높인다.</p>\n<p>첫번째로 공통 스타일을 적는 것이 좋다. 흔히 reset CSS라고 불리는 기본 스타일을 지정해 놓는 것이다. <code>p</code>, <code>h1</code>, <code>ul</code>, <code>ol</code>등의 태그 스타일을 보통 정의한다.</p>\n<p>두번째로는 유틸리티 클래스들을 지정한다. 많은 컴포넌트에서 공통으로 사용될 스타일들을 지정하는 것이다.</p>\n<p>세번째로는 사이트에서 전체적으로 사용되는 것들의 스타일을 지정한다. 페이지 레이아웃이라거나, 네비게이션 바 같은 것들이다.</p>\n<p>마지막으로는 특정한 컴포넌트의 스타일을 지정한다. 특정 페이지에서만 사용되는 컴포넌트 등이다. 이것은 가장 마지막에 작성하는 것이 좋다.</p>\n<p>구역의 구분은 주석으로 한다.</p>\n<h2>1.4. 너무 specific하지 않은 셀렉터 쓰기</h2>\n<p>너무 specific한 셀렉터를 쓰게 되면 다른 컴포넌트에 그 스타일을 적용할 때 번거로워질 수 있다. 예를 들어서 다음과 같은 클래스를 쓰는 것이다.</p>\n<pre><code class=\"language-css\">section.container p.title{\n  color: red;\n}\n</code></pre>\n<p>이렇게 하면 container 클래스를 가진 section 컴포넌트의 후손 중 title 클래스를 가진 p 태그에만 적용된다. 이렇게 specific한 셀렉터를 쓰면 이 스타일을 다른 데에 적용하는 것이 거의 불가능하기 때문에, 이 스타일을 또 쓰고 싶다면 새로운 셀렉터를 정의해야 할 것이다.</p>\n<p>따라서 새로운 클래스를 만들어 주는 게 낫다.</p>\n<pre><code class=\"language-css\">.title-box{\n  color: red;\n}\n</code></pre>\n<h2>1.5. OOCSS</h2>\n<p>OOCSS는 Object Oriented CSS의 약자로, CSS를 객체지향적으로 작성하는 방법이다. 이는 CSS를 재사용 가능한 객체들로 분리한다는 발상에 기반을 둔다.</p>\n<p>만약 이런 방식을 사용하지 않는다면 우리는 약간 다른 스타일을 가진 컴포넌트를 만들 때마다 새로운 클래스를 만들어야 한다. 이는 코드의 중복을 증가시키고 유지보수를 어렵게 만든다.</p>\n<p>그러면 어떻게 재사용할 것인가? OOCSS에서는 역할과 디자인을 분리한다. 예를 들어서 버튼을 만든다고 하자. 그러면 <code>.button</code> 클래스에는 버튼에 대한 디자인을 지정한다.</p>\n<p>하지만 이는 버튼의 역할을 위한 클래스이기 때문에 여기에 그라데이션 배경 등을 지정하면 안 된다. 배경을 위한 디자인 클래스를 따로 만든 뒤에 <code>.button</code> 클래스에 덧붙여서 사용해야 한다.</p>\n<p>또한 컨테이너와 콘텐츠를 CSS에서 분리해야 한다. 컴포넌트의 위치에 따라서 콘텐츠의 스타일이 달라지는 건 OOCSS에서 권장되지 않는다.</p>\n<p>예를 들어서 다음과 같이 하면 안된다. li의 위치에 따라 <code>.list-item</code> 클래스의 스타일이 달라지기 때문이다.</p>\n<pre><code class=\"language-css\">ul li.list-item{\n  color: red;\n}\n</code></pre>\n<h2>1.6. BEM</h2>\n<p>BEM은 Block, Element, Modifier의 약자로, CSS를 작성할 때 클래스 이름을 지을 때 사용하는 방법이다. 이 방법을 사용하면 CSS를 작성할 때 클래스 이름을 지을 때 일관성을 유지할 수 있다.</p>\n<p>Block은 독립적으로 존재할 수 있는 컴포넌트를 의미한다. 버튼이나 메뉴, 로고 등이다. 그리고 Element는 Block의 일부분을 이루는 요소를 의미한다. 예를 들어서 버튼의 텍스트나 목록의 아이템(<code>&#x3C;li></code>와 같은)과 같은 것이다.</p>\n<p>Modifier는 Block이나 Element의 상태를 나타낸다. 예를 들어서 버튼이 활성화되었는지, 비활성화되었는지, 또는 버튼의 크기가 큰지 작은지 등이다.</p>\n<p>BEM에서는 클래스 이름을 다음과 같이 지어야 한다.</p>\n<pre><code class=\"language-css\">.block__element--modifier{\n  // CSS 속성\n}\n</code></pre>\n<p>이런 <code>_</code>, <code>-</code>의 많은 사용을 보면 BEM 방법론을 사용한 줄 바로 알 수 있다.</p>\n<p>이외에도 Atomic CSS등 여러 방법론이 있다.</p>\n<h1>2. 사용자 지정 CSS 속성</h1>\n<p>CSS에서도 재사용 가능한 변수를 만들 수 있다. 사용자 지정 속성이라고도 한다. 이런 변수는 <code>--</code>로 시작하는 전용 표기법을 사용해서 정의하며 <code>var()</code>함수를 통해 접근할 수 있다. 유효한 CSS 값이라면 뭐든 넣을 수 있다.</p>\n<p>이때 변수도 일반적인 CSS 속성 정의와 같이 셀렉터 내에서 정의된다.</p>\n<pre><code class=\"language-css\">selector{\n  --main-color: #eebefa;\n}\n</code></pre>\n<p>문서 트리의 루트 요소를 선택하는 <code>:root</code>셀렉터를 사용해서 전역으로 사용하는 패턴이 흔하다. 물론 특정 컴포넌트 내에서만 사용하고 싶은 변수의 경우 해당 컴포넌트의 최상위 요소에 정의하면 된다.</p>\n<pre><code class=\"language-css\">:root{\n  --main-color: #eebefa;\n}\n</code></pre>\n<p>이를 가져올 땐 <code>var()</code>함수를 사용한다.</p>\n<pre><code class=\"language-css\">p{\n  color: var(--main-color);\n}\n</code></pre>\n<h2>2.1. 변수의 상속</h2>\n<p>이러한 변수는 부모 요소로부터 상속되기도 한다. 즉 특정 요소에 변수를 정의하지 않았다면 그 요소의 부모 요소에서 변수를 찾는다.</p>\n<pre><code class=\"language-css\">.parent{\n  --bg-color: #eebefa;\n}\n\n.child{\n  background: var(--bg-color);\n}\n</code></pre>\n<p>위와 같이 CSS를 정의하고 <code>.child</code> 요소를 렌더링하면 <code>.child</code> 요소의 배경색은 <code>#eebefa</code>가 된다.</p>\n<pre><code class=\"language-html\">&#x3C;div class=\"parent\">\n  부모 요소\n  &#x3C;div class=\"child\">자식 요소&#x3C;/div>\n&#x3C;/div>\n</code></pre>\n<p>참고로 이들은 진짜 변수가 아니라 필요할 때만 계산되는 속성이다. 즉 이 요소를 따로 검색하거나 할 수는 없다.</p>\n<h2>2.2. 대체 속성값</h2>\n<p>주어진 변수가 아직 정의되지 않았거나 유효하지 않을 때 대체 속성값을 <code>var()</code>를 이용해 지정할 수 있다.</p>\n<pre><code class=\"language-css\">p{\n  color: var(--main-color, #99e9f2);\n}\n</code></pre>\n<p>위와 같이 하면 <code>--main-color</code>가 정의되어 있지 않거나 유효하지 않을 때 <code>#99e9f2</code>가 적용된다.</p>\n<h2>2.3. 변수 값의 유효성</h2>\n<p>CSS의 변수 값을 계산할 때 브라우저는 이 값들이 어디서 사용될지 모른다. 따라서 거의 모든 값을 유효하게 간주한다. 만약 이런 유효하지 않은 값이 들어가게 되면 브라우저는 우선적으로 부모에게 상속된 값을 사용하고 그런 값이 없을 경우 기본값을 사용한다.</p>\n<pre><code class=\"language-css\">:root{\n  --primary-color: 16px;\n}\n\np{\n  color: var(--primary-color);\n}\n</code></pre>\n<p>이 경우 브라우저는 <code>var(--primary-color)</code>를 16px로 대체하지만 이는 유효한 값이 아니다. 따라서 p태그에는 기본값인 검은색이 사용된다.</p>\n<p>다음과 같이 대체 값을 사용해도 마찬가지이다. 브라우저가 <code>var(--primary-color)</code>라는 변수를 찾을 수 있고 유효하지 않은 값이라도 채워넣을 수 있기 때문이다.</p>\n<pre><code class=\"language-css\">p{\n  color: var(--primary-color, #66d9e8);\n}\n</code></pre>\n<p>즉 위와 같이 해도 대체 속성이 쓰이지는 않는다. p는 기본값인 검은색이 적용된다.</p>\n<h1>3. 글자 박스 만들어보기</h1>\n<p>MDN에서 제공하는 흔한 예제를 한번 따라해 보도록 하겠다. 대강 HTML로 div 박스 하나를 만들자.</p>\n<pre><code class=\"language-html\">&#x3C;!DOCTYPE html>\n&#x3C;html lang=\"ko-KR\">\n  &#x3C;head>\n    &#x3C;meta charset=\"utf-8\" />\n    &#x3C;meta name=\"viewport\" content=\"width=device-width\" />\n    &#x3C;title>박스 만들기&#x3C;/title>\n    &#x3C;link href=\"index.css\" rel=\"stylesheet\" type=\"text/css\" />\n  &#x3C;/head>\n  &#x3C;body>\n    &#x3C;div>\n      &#x3C;p>뭔가 보여드리겠습니다&#x3C;/p>\n    &#x3C;/div>\n  &#x3C;/body>\n&#x3C;/html>\n</code></pre>\n<p>이제 index.css를 작성해 보자.</p>\n<p>박스에 적절한 크기를 만들어 주고 배경색을 넣어서 박스 영역을 식별할 수 있도록 하자. 또한 글자를 가운데 정렬하고 박스도 페이지의 가운데 오도록 하자.</p>\n<pre><code class=\"language-css\">.box{\n  width:200px;\n  height:200px;\n  background-color:var(--bg-color);\n  text-align:center;\n  margin:0 auto;\n}\n</code></pre>\n<p>폰트 크기도 조절하고 색도 넣어주자. 그림자를 넣는 text-shadow 속성도 넣었다.</p>\n<pre><code class=\"language-css\">.text-content{\n  font-size:1rem;\n  color:var(--text-color);\n  text-shadow: 1px 1px 2px black;\n}\n</code></pre>\n<p>아직 박스에 디자인할 게 남았다. 따라서 클래스를 새로 만들어서 디자인을 적용해보자. 모서리를 둥글게 하고 테두리를 넣고, 그라데이션을 적용했으며 박스에 그림자가 지게 만들었다.</p>\n<pre><code class=\"language-css\">.box-layout{\n  width:200px;\n  height:200px;\n  text-align:center;\n  margin:0 auto;\n}\n\n.box-design{\n  background-color:var(--bg-color);\n  border-radius:10px;\n  border:3px solid var(--text-color);\n  background-image: linear-gradient(135deg, rgba(0,0,0,0), rgba(0,0,0,0.2) 30%);\n  box-shadow: 0 0 10px rgba(0,0,0,0.5);\n}\n</code></pre>\n<p>이제 html에 클래스를 적용하고 렌더링해보자.</p>\n<pre><code class=\"language-html\">&#x3C;div class=\"box-layout box-design\">\n  &#x3C;p class=\"text-content\">뭔가 보여드리겠습니다&#x3C;/p>\n&#x3C;/div>\n</code></pre>\n<p><img src=\"/static/cool-box-64153708.png\" alt=\"cool-box\"></p>\n<p>디자인은 정말 별로지만 어쨌든 박스가 완성되었다..</p>\n<h1>참고</h1>\n<p><a href=\"https://clubmate.fi/oocss-acss-bem-smacss-what-are-they-what-should-i-use\">https://clubmate.fi/oocss-acss-bem-smacss-what-are-they-what-should-i-use</a></p>",
    "excerpt": "1. CSS 구성\nCSS를 쉽게 관리할 수 있게 하는 방법들을 알아본다.\n1.1. 코딩 스타일 가이드라인\n다른 사람들과 함께 작업하는 경우 프로젝트의 스타일 가이드라인을 정하고 일관성있게 따라야 한다. class의 이름 지정 규칙이나 색상을 표현하는 방법, 형식 등을 정하고 이를 모두가 따라야 한다.\n예를 들어서 MDN 코드 예제들의 CSS가이드라인이 있다.\n이런 가이드라인을 정할 때 한 줄에 하나의 규칙만 넣는 등, 가독성을 고려한 선택을 하는 것이 좋다.\n1",
    "headingTree": [
      {
        "title": "1. CSS 구성",
        "url": "#1-css-구성",
        "items": [
          {
            "title": "1.1. 코딩 스타일 가이드라인",
            "url": "#11-코딩-스타일-가이드라인",
            "items": []
          },
          {
            "title": "1.2. 주석 남기기",
            "url": "#12-주석-남기기",
            "items": []
          },
          {
            "title": "1.3. 스타일시트에 논리적인 구획 만들기",
            "url": "#13-스타일시트에-논리적인-구획-만들기",
            "items": []
          },
          {
            "title": "1.4. 너무 specific하지 않은 셀렉터 쓰기",
            "url": "#14-너무-specific하지-않은-셀렉터-쓰기",
            "items": []
          },
          {
            "title": "1.5. OOCSS",
            "url": "#15-oocss",
            "items": []
          },
          {
            "title": "1.6. BEM",
            "url": "#16-bem",
            "items": []
          }
        ]
      },
      {
        "title": "2. 사용자 지정 CSS 속성",
        "url": "#2-사용자-지정-css-속성",
        "items": [
          {
            "title": "2.1. 변수의 상속",
            "url": "#21-변수의-상속",
            "items": []
          },
          {
            "title": "2.2. 대체 속성값",
            "url": "#22-대체-속성값",
            "items": []
          },
          {
            "title": "2.3. 변수 값의 유효성",
            "url": "#23-변수-값의-유효성",
            "items": []
          }
        ]
      },
      {
        "title": "3. 글자 박스 만들어보기",
        "url": "#3-글자-박스-만들어보기",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 305
    },
    "url": "/posts/mdn-css-5",
    "thumbnail": {
      "local": "/static/cool-box-64153708.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-cool-box-64153708-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAADCAIAAAAhqtkfAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAVklEQVR4nAFLALT/APn5+f///9vi0hM3AAoiAMrRwP////n5+QD8/Pv////N0sMAGQAAHgDByLP////8/PsA/f/9////7O7ngpRnh5dt5+ri///////+pvg2UZFHQ4wAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "mdn-css-6",
    "title": "프론트 지식 익히기 CSS-6",
    "date": "2023-04-14T00:00:00Z",
    "description": "MDN CSS 튜토리얼 - 5",
    "tags": [
      "web",
      "study",
      "front",
      "CSS"
    ],
    "html": "<p>이제 텍스트를 스타일링하는 부분에 들어섰다. CSS삽질은 그래도 좀 해왔기 때문에 새로 알게 된 부분들만 간략히 정리하겠다.</p>\n<h1>1. 기본적인 텍스트 스타일링</h1>\n<p>요소 내의 텍스트는 마치 인라인 요소처럼 작동하고 CSS의 기본적인 스타일링 속성들을 적용할 수 있다. <code>::first-letter</code>등의 유사 요소를 사용해서 선택할 수도 있다. 이때 텍스트 스타일을 지정하는 CSS속성은 보통 2가지로 분류된다.</p>\n<p>하나는 글꼴과 이탤릭체 등에 영향을 주는 글꼴 스타일이고 다른 하나는 텍스트의 위치와 간격, 정렬 등을 조절하는 텍스트 레이아웃 스타일이다.</p>\n<h2>1.1. 글꼴 스타일 기본</h2>\n<p>몰랐던 속성들만 간단히 정리한다.</p>\n<p>text-decoration속성은 텍스트에 장식용 선을 추가한다. text-decoration-line, text-decoration-color, text-decoration-style, text-decoration-thickness속성의 단축 속성이다. underline, overline, line-through(취소선)등의 속성이 있다. 한번에 여러 스타일 적용도 가능하다.</p>\n<pre><code class=\"language-css\">text-decoration: underline dotted blue 2px;\n// 한번에 여러 스타일 적용\ntext-decoration: underline overline;\n</code></pre>\n<p>글꼴 크기는 px, em, rem 등으로 설정할 수 있는데 em은 부모 요소의 글꼴 크기를 기준으로 하고 rem은 루트 요소의 글꼴 크기를 기준으로 한다는 것을 기억하자. <code>rem은 루트 요소에서 속성을 가져온다</code></p>\n<p>따라서 rem을 쓸 수 있다면 rem을 쓰는 게 크기 계산을 더 간결하게 만든다. 그리고 기본 폰트 사이즈를 10px로 하는 것도 좋은 선택이다. 그렇게 하면 어떤 폰트 크기를 만들어야 할 때 rem 계산이 더 편해지기 때문이다.</p>\n<p>font-style은 이탤릭체를 적용할 수 있게 한다. font-weight는 키워드나 숫자로 글꼴의 굵기를 지정할 수 있다.</p>\n<p>text-transform은 텍스트를 대문자, 소문자, 대문자로 시작하는 형태로 바꿀 수 있다.</p>\n<p>text-shadow는 그림자를 설정한다. 다음과 같이 설정한다</p>\n<pre><code class=\"language-css\">// text-shadow: 텍스트와 그림자의 수평간격, 수직간격, 그림자의 흐린 반지름, 그림자의 색상\ntext-shadow: 2px 2px 2px #000;\n</code></pre>\n<p>텍스트와 그림자의 간격을 양수로 설정하면 그림자가 텍스트의 아래, 그리고 오른쪽에 위치하게 된다. 하지만 이 간격을 음수로 설정함으로써 그림자가 텍스트의 위 혹은 왼쪽에 위치하게 할 수도 있다.</p>\n<p>또한 여러 그림자 값을 쉼표로 구분해서 전달하여 여러 그림자를 적용할 수도 있다.</p>\n<pre><code class=\"language-css\">text-shadow: 2px 2px 2px #pink, -2px -2px 2px #purple;\n</code></pre>\n<h2>1.3. 레이아웃 스타일 기본</h2>\n<p>text-align은 텍스트의 정렬을 설정한다. left, right, center, justify(양쪽 정렬)가 있다. justify는 자칫 이상한 디자인으로 연결될 수 있으므로 조심한다.</p>\n<p>line-height는 말 그대로 한 줄의 높이를 설정한다. <code>line-height:20px</code>와 같이 단위를 사용해 설정할 수도 있지만 단위 없이 값만 줄 수도 있다. 이럴 경우 line-height는 font-size에 그 값을 곱한 값으로 적용된다. <code>line-height: 1.5</code>는 font-size가 10px일 때 <code>line-height: 15px</code>와 같다.</p>\n<p>줄 높이가 적절히 높아서 줄 사이 간격이 있으면 가독성이 좋아진다. 따라서 줄 높이는 1.5~2.0 사이로 설정하는 것이 권장된다.</p>\n<p>letter-spacing, word-spacing은 각각 글자 간의, 단어 간의 간격을 설정한다. 대부분의 길이 단위를 쓸 수 있다.</p>\n<h1>2. 다양한 텍스트 속성들</h1>\n<h2>2.1. 텍스트 스타일 보충</h2>\n<h3>2.1.1. font-variant</h3>\n<p>소문자를 작은 대문자로 바꿀 수 있는 속성이다. 이는 여러 가지 속성의 단축 속성이다. 몇 가지 눈에 들어오는 것을 살펴보았다. 이를 실험하기 위해서는 간단한 예제를 만들어야 한다. 로렘 입숨을 가져왔다.</p>\n<pre><code class=\"language-html\">&#x3C;p>\n  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n&#x3C;/p>\n</code></pre>\n<p>font-variant-caps는 대문자를 작은 대문자로 바꾼다. 이 속성을 적용하면 <code>Lorem</code>이 <code>lorem</code>으로 바뀐다.</p>\n<pre><code class=\"language-css\">font-variant: small-caps;\n</code></pre>\n<p>이 결과물은 다음과 같다. 소문자들이 모두 작은 대문자로 표기되었다.</p>\n<p><img src=\"/static/lorem-small-caps-931db710.png\" alt=\"lorem-small-caps\"></p>\n<h3>2.1.2. font-variant-ligatures</h3>\n<p>font-variant-ligatures는 두 글자를 하나의 모양으로 연결하는 것에 대한 속성이다. 예를 들어서 difficult와 같은 경우 몇몇 글꼴에서 ffi가 하나로 이어져서 표현된다. 이를 ligature라 한다.</p>\n<p>다음과 같이 속성을 설정하면 그런 현상이 일어나지 않게 된다.</p>\n<pre><code class=\"language-css\">font-variant-ligatures: none;\n</code></pre>\n<h3>2.1.3. 기타</h3>\n<p>이외에도 동아시아 문자들의 표현을 위한 font-variant-east-asian, 숫자의 다른 표현(예를 들어 숫자 0의 내부에 사선을 긋는 등)font-variant-numeric 등이 있다.</p>\n<h2>2.2. font-kerning</h2>\n<p>글자 간의 간격을 조절하는 속성이다. 그런데 단순히 글자 간의 간격을 조절하는 것이 아니라 글자의 모양에 따라서 글자 간의 간격을 조절한다.</p>\n<p>예를 들어서 <code>AV</code>와 같은 글자의 경우 A와 V 사이의 간격이 조금 좁아짐으로써 자연스러워 보일 수 있다. 이런 것을 kerning이라 한다.</p>\n<pre><code class=\"language-css\">// 브라우저에 kerning을 맡긴다\nfont-kerning: auto;\n// kerning을 적용하지 않는다\nfont-kerning: none;\n// kerning을 적용한다\nfont-kerning: normal;\n</code></pre>\n<h2>2.3. font-stretch</h2>\n<p>글자를 늘려서 좁게, 혹은 넓게 설정한다.</p>\n<pre><code class=\"language-css\">// 글자를 늘린다\nfont-stretch: expanded;\n// 글자를 좁힌다\nfont-stretch: condensed;\n// 백분율로 글자를 늘린다. 50%~200%\nfont-stretch: 150%;\n</code></pre>\n<h2>2.4. text-underline-position</h2>\n<p>밑줄의 위치를 설정한다. <code>text-underline-position: under;</code>와 같이 under를 설정하면 텍스트의 밑줄이 텍스트 아래첨자보다도 아래로 내려간다.</p>\n<p>auto로 설정하면 브라우저가 알아서 밑줄 위치를 결정한다.</p>\n<h2>2.5. text-indent</h2>\n<p>텍스트의 들여쓰기를 설정한다. 음수 값도 사용할 수 있다. 음수 값을 적용하면 들여쓰기할 텍스트가 왼쪽으로 밀려진다.</p>\n<h2>2.6. text-overflow</h2>\n<p>텍스트가 너무 길어서 텍스트가 넘치는 경우에 대한 처리 방법을 설정한다.</p>\n<p><code>text-overflow: ellipsis;</code>와 같이 ellipsis를 설정하면 텍스트가 넘치면 <code>...</code>으로 표시한다.</p>\n<p><code>text-overflow: clip;</code>와 같이 clip을 설정하면 넘치는 텍스트를 잘라낸다.</p>\n<p>text-overflow 속성은 텍스트가 넘치도록 만들지는 않는다. 자동으로 줄바꿈이 일어나기 때문이다. 따라서 오버플로우를 의도적으로 일으키고 싶다면 <code>white-space: nowrap;</code>과 같이 설정해야 한다.</p>\n<h2>2.7. white-space</h2>\n<p>요소가 공백을 처리하는 방법을 설정한다. 이러한 공백은 띄어쓰기, 들여쓰기, 줄바꿈이 대표적이다. 그런데 이런 공백들이 연속해서 나오더라도, 브라우저는 보통 이를 하나의 공백으로 합쳐 버린다.</p>\n<p>이는 <code>white-space: normal;</code>이 기본값이기 때문이다. 연속된 공백을 하나로 합치고 줄바꿈은 자동으로 일어난다. <code>&#x26;nbsp;</code>나 <code>&#x3C;br/></code>을 쓰지 않는 이상 연속 공백이나 수동 줄바꿈은 불가능하다.</p>\n<p><code>white-space:nowrap</code>으로 설정하면 텍스트가 요소의 너비를 넘어가더라도 자동 줄바꿈이 일어나지 않는다. <code>overflow:hidden; text-overflow: ellipsis;</code>와 같이 설정하여 넘치는 텍스트도 <code>...</code>으로 표시하는 패턴도 많이 쓴다.</p>\n<p>pre로 설정하면 HTML 문서의 연속된 공백들을 그대로 유지한다. pre-wrap도 마찬가지로 연속 공백들을 보존하지만 텍스트 내의 긴 행이 있으면 자동 줄바꿈을 한다. pre-line은 줄바꿈은 그대로 유지하고 연속 공백은 병합한다.</p>\n<h2>2.8. word-break</h2>\n<p>텍스트가 박스 밖으로 넘쳐나올 때 어떻게 줄을 바꿀지에 대해 지정한다. break-all을 지정하면 텍스트 넘침을 방지하기 위해 단어를 쪼개서 줄을 바꾼다.</p>\n<p>keep-all은 CJK 텍스트를 위한 속성인데 지금 볼 필요는 없을 듯 하다.</p>\n<h1>3. 목록 스타일링</h1>\n<p><code>&#x3C;ul></code>과 <code>&#x3C;ol></code>태그는 각각 순서 없는 목록, 순서 있는 목록을 만드는 태그인데 페이지를 만들다 보면 매우 자주 사용하게 된다. 이에 연관된 CSS 속성들을 간단히 정리한다.</p>\n<h2>3.1. list-style-type</h2>\n<p>목록에 쓰이는 기호를 설정한다. 예를 들어서 <code>list-style-type: circle;</code>와 같이 설정하면 순서 없는 목록에 원형 기호가 쓰이게 된다. 또는 <code>list-style-type: upper-roman;</code>과 같이 설정하면 순서 있는 목록의 순서를 나타낼 때 대문자 로마 숫자가 쓰이게 된다.</p>\n<pre><code class=\"language-css\">ol {\n  list-style-type: upper-roman;\n}\n</code></pre>\n<h2>3.2. list-style-position</h2>\n<p>목록은 특별히 설정하지 않으면 각 요소의 시작에 기호가 붙게 된다. 이 기호를 각 목록 요소의 어떤 상대적 위치에 붙일 것인지를 설정한다.</p>\n<p>일반적으로는 outside을 사용하는데 이는 기호가 목록 요소와 상관없는 바깥에 위치하며 목록 요소의 내용과 분리되어 있다는 뜻이다. 이렇게 list-style-position이 outside로 설정된 목록을 만들어 보면, 목록 기호가 목록 박스의 패딩 안에 들어가 있어서 목록과는 실제로 분리되어 있는 것을 볼 수 있다.</p>\n<p>inside를 사용하면 기호가 목록 요소의 내부에, 목록 요소 내용의 첫번째 글자로 등장한다는 뜻이다. 즉 목록 기호가 박스의 패딩에 들어가 있었던 outside와 달리 목록 기호가 목록 박스 안에 들어가 있게 된다.</p>\n<p>실제로 확인해 보자. 다음과 같이 css를 작성해서 마진과 패딩을 제외한 오로지 내용에만 색을 입혀 보자.</p>\n<pre><code class=\"language-css\">ol{\n  background-clip: content-box;\n  background-color:#eebefa;\n}\n\n.bullet-outside{\n  list-style-position:outside;\n}\n\n.bullet-inside{\n  list-style-position:inside;\n}\n</code></pre>\n<p>그리고 다음과 같이 HTML을 작성하자.</p>\n<pre><code class=\"language-html\">&#x3C;ol class=\"bullet-outside\">\n  &#x3C;li>첫번째 요소&#x3C;/li>\n  &#x3C;li>두번째 요소&#x3C;/li>\n  &#x3C;li>세번째 요소&#x3C;/li>\n  &#x3C;li>네번째 요소&#x3C;/li>\n&#x3C;/ol>\n\n&#x3C;ol class=\"bullet-inside\">\n  &#x3C;li>첫번째 요소&#x3C;/li>\n  &#x3C;li>두번째 요소&#x3C;/li>\n  &#x3C;li>세번째 요소&#x3C;/li>\n  &#x3C;li>네번째 요소&#x3C;/li>\n&#x3C;/ol>\n</code></pre>\n<p>그러면 다음과 같이 outside과 inside의 차이를 확인할 수 있다.</p>\n<p><img src=\"/static/list-position-ex-d6b14979.png\" alt=\"list-position-ex\"></p>\n<h2>3.3. list-style-image</h2>\n<p>목록 기호를 이미지로 직접 설정할 수 있다.</p>\n<pre><code class=\"language-css\">ol{\n  list-style-image: url(bullet.svg);\n}\n</code></pre>\n<p>그러나 이렇게 하면 기호의 크기 조절 등 제한되는 부분들이 있다. 따라서 기호를 이미지로 사용하고 싶다면 background 속성을 이용하는 것이 낫다. 과정은 다음과 같다.</p>\n<ol>\n<li>list-style-type을 none으로 설정하여 기호를 없앤다.</li>\n<li>li 태그에 padding을 삽입하여 기호가 들어갈 공간을 만든다.</li>\n<li>background-image로 기호 이미지를 삽입한다.</li>\n<li>background-position으로 기호 이미지의 위치를 조정한다. 보통 요소의 시작에 위치하므로 0 0 이 좋다.</li>\n<li>background-repeat:no-repeat로 기호 이미지가 한번만 나타나도록 한다.</li>\n<li>background-size로 기호 이미지 크기를 적절히 조정한다.</li>\n</ol>\n<h2>3.4. shorthand</h2>\n<p>list-style 키워드로 위 3가지를 모두 지정할 수도 있다.</p>\n<pre><code class=\"language-css\">ol{\n  list-style: outside circle url(bullet.svg);\n}\n</code></pre>\n<h2>3.5. 목록 요소 속성</h2>\n<p>목록 요소에는 몇 가지 속성이 있다. 순서가 있는 목록에서 목록의 시작을 1 말고 다른 숫자로 하고 싶다든지 할 때 사용할 수 있다.</p>\n<p>start 속성은 목록을 셀 때 시작하는 숫자를 달리한다.</p>\n<pre><code class=\"language-html\">&#x3C;ol start=\"3\">\n  &#x3C;li>첫번째 요소&#x3C;/li>\n  &#x3C;li>두번째 요소&#x3C;/li>\n  &#x3C;li>세번째 요소&#x3C;/li>\n  &#x3C;li>네번째 요소&#x3C;/li>\n&#x3C;/ol>\n</code></pre>\n<p>reversed 속성을 지정하면 목록이 거꾸로 세어진다.</p>\n<p>li 태그에 value 속성을 지정하여 특정 순서를 갖도록 강제할 수도 있다. 그러면 그 다음 순서도 자동으로 증가한다. 다음과 같이 작성하면 순서가 <code>1,2,7,8</code>로 표시된다.</p>\n<pre><code class=\"language-html\">&#x3C;ol>\n  &#x3C;li>첫번째 요소&#x3C;/li>\n  &#x3C;li>두번째 요소&#x3C;/li>\n  &#x3C;li value=\"7\">세번째 요소&#x3C;/li>\n  &#x3C;li>네번째 요소&#x3C;/li>\n&#x3C;/ol>\n</code></pre>\n<h1>참고</h1>\n<p><a href=\"https://www.daleseo.com/css-white-space/\">https://www.daleseo.com/css-white-space/</a></p>\n<p><a href=\"https://www.daleseo.com/html-nbsp/\">https://www.daleseo.com/html-nbsp/</a></p>",
    "excerpt": "이제 텍스트를 스타일링하는 부분에 들어섰다. CSS삽질은 그래도 좀 해왔기 때문에 새로 알게 된 부분들만 간략히 정리하겠다.\n1. 기본적인 텍스트 스타일링\n요소 내의 텍스트는 마치 인라인 요소처럼 작동하고 CSS의 기본적인 스타일링 속성들을 적용할 수 있다. ::first-letter등의 유사 요소를 사용해서 선택할 수도 있다. 이때 텍스트 스타일을 지정하는 CSS속성은 보통 2가지로 분류된다.\n하나는 글꼴과 이탤릭체 등에 영향을 주는 글꼴 스타일이고 다른 하나",
    "headingTree": [
      {
        "title": "1. 기본적인 텍스트 스타일링",
        "url": "#1-기본적인-텍스트-스타일링",
        "items": [
          {
            "title": "1.1. 글꼴 스타일 기본",
            "url": "#11-글꼴-스타일-기본",
            "items": []
          },
          {
            "title": "1.3. 레이아웃 스타일 기본",
            "url": "#13-레이아웃-스타일-기본",
            "items": []
          }
        ]
      },
      {
        "title": "2. 다양한 텍스트 속성들",
        "url": "#2-다양한-텍스트-속성들",
        "items": [
          {
            "title": "2.1. 텍스트 스타일 보충",
            "url": "#21-텍스트-스타일-보충",
            "items": [
              {
                "title": "2.1.1. font-variant",
                "url": "#211-font-variant",
                "items": []
              },
              {
                "title": "2.1.2. font-variant-ligatures",
                "url": "#212-font-variant-ligatures",
                "items": []
              },
              {
                "title": "2.1.3. 기타",
                "url": "#213-기타",
                "items": []
              }
            ]
          },
          {
            "title": "2.2. font-kerning",
            "url": "#22-font-kerning",
            "items": []
          },
          {
            "title": "2.3. font-stretch",
            "url": "#23-font-stretch",
            "items": []
          },
          {
            "title": "2.4. text-underline-position",
            "url": "#24-text-underline-position",
            "items": []
          },
          {
            "title": "2.5. text-indent",
            "url": "#25-text-indent",
            "items": []
          },
          {
            "title": "2.6. text-overflow",
            "url": "#26-text-overflow",
            "items": []
          },
          {
            "title": "2.7. white-space",
            "url": "#27-white-space",
            "items": []
          },
          {
            "title": "2.8. word-break",
            "url": "#28-word-break",
            "items": []
          }
        ]
      },
      {
        "title": "3. 목록 스타일링",
        "url": "#3-목록-스타일링",
        "items": [
          {
            "title": "3.1. list-style-type",
            "url": "#31-list-style-type",
            "items": []
          },
          {
            "title": "3.2. list-style-position",
            "url": "#32-list-style-position",
            "items": []
          },
          {
            "title": "3.3. list-style-image",
            "url": "#33-list-style-image",
            "items": []
          },
          {
            "title": "3.4. shorthand",
            "url": "#34-shorthand",
            "items": []
          },
          {
            "title": "3.5. 목록 요소 속성",
            "url": "#35-목록-요소-속성",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 2,
      "wordCount": 438
    },
    "url": "/posts/mdn-css-6",
    "thumbnail": {
      "local": "/static/lorem-small-caps-931db710.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-lorem-small-caps-931db710-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAACCAIAAADq9gq6AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAL0lEQVR4nGNwc3OzsbExMTHR1tY2AQNpaem6ujqGOjAoKSnJysqCkHPmzPn48SMAX5gSdo5Lty8AAAAASUVORK5CYII="
    }
  },
  {
    "slug": "mdn-css-7",
    "title": "프론트 지식 익히기 CSS-7",
    "date": "2023-04-16T00:00:00Z",
    "description": "MDN CSS 튜토리얼 - 7",
    "tags": [
      "web",
      "study",
      "front",
      "CSS"
    ],
    "html": "<p>MDN CSS 튜토리얼의 텍스트 스타일링을 마무리한다.</p>\n<h1>1. 링크 스타일링</h1>\n<p>잘 몰랐던 것만 간단히 정리하자.</p>\n<h2>1.1. 링크의 상태</h2>\n<p>링크는 다음과 같은 상태들을 가지는데 이는 의사 클래스(<code>:hover</code>와 같은) 선택자를 통해 스타일링 가능하다.</p>\n<p><code>:link</code>는 방문하지 않은 링크를 의미한다. 반면 방문한 링크는 <code>:visited</code>로 나타난다. <code>:hover</code>는 마우스를 올렸을 때의 상태를 의미하며, <code>:active</code>는 링크를 클릭했을 때의 상태를 의미한다.</p>\n<p>tab 키나 focus 함수를 통해 링크에 포커스가 갔을 때의 상태는 <code>:focus</code>로 나타난다.</p>\n<p>이런 상태들의 스타일링 순서는 일반적으로 다음과 같다.</p>\n<pre><code class=\"language-css\">a{}\n\na:link{}\n\na:visited{}\n\na:focus{}\n\na:hover{}\n\na:active{}\n</code></pre>\n<p>이런 순서를 따르는 것은 겹치는 상태가 있기 때문이다. 당연히 <code>a{}</code>의 스타일은 나머지 모든 선택자에도 적용될 것이다. 그리고 active상태인 링크는 만약 사용자가 마우스를 사용해 링크를 클릭했다면 hover 상태이기도 할 것이다.</p>\n<p>이런 식으로 중첩되는 상태들이 있기 때문에 위 순서를 지켜 스타일링하는 것이 좋다.</p>\n<h2>1.2. 외부 링크 선택</h2>\n<p>링크를 걸 때 외부 링크를 걸 수도 있고 내부 링크를 걸 수도 있다. 예를 들어서 <code>href=\"#id</code>와 같이 링크를 걸면 해당 페이지에서 해당 id를 가진 요소로 이동한다. 혹은 <code>href=\"/login\"</code>과 같이 상대 경로를 사용할 수도 있다.</p>\n<p>그런데 외부 페이지로 가는 링크에만 특별한 스타일을 적용하고 싶을 수 있다. 그러면 만약 링크를 제대로 사용하고 있다면, 외부 링크는 <code>http</code>로 시작할 것이다.</p>\n<p>따라서 <code>a[href^=\"http\"]</code>와 같은 선택자를 사용하면 외부 링크를 선택할 수 있다. 이는 <code>href</code> 속성이 <code>http</code>로 시작하는 모든 링크를 선택한다.</p>\n<h1>2. 웹 폰트</h1>\n<p>CSS에서는 웹에 있는 폰트를 다운로드받아 사용하는 게 가능하다. 페이지에 접근할 때 해당 폰트를 다운로드 받아 사용할 수 있도록 하는 것이다.</p>\n<p>CSS의 시작 부분에 <code>@font-face</code>를 사용하면 된다. 이는 폰트를 다운로드 받을 때 사용할 이름을 지정해주는 것이다.</p>\n<pre><code class=\"language-css\">@font-face {\n  font-family: \"MyWebFont\";\n  src: url(\"fonts/myfont.woff\") format(\"woff\"),\n       url(\"fonts/myfont.woff2\") format(\"woff2\");\n}\n</code></pre>\n<p>대부분의 브라우저는 <code>woff</code>와 <code>woff2</code>를 지원한다. 이는 웹 폰트를 압축한 파일 형식이다. MDN에서는 <a href=\"https://www.fontsquirrel.com/\">Font squirrel</a>에서 다운받기를 추천하고 있다.</p>\n<p>나같은 경우 따로 폰트를 다운받기 싫어서 특별한 폰트를 쓸 때는 google-font에서 온라인 다운로드를 받는 방법을 많이 썼었다.</p>\n<p>그 다음부터 <code>font-family</code> 속성을 사용해 다운받은 웹 폰트를 사용할 수 있다.</p>\n<h2>2.1. font-face 잘 사용하기</h2>\n<p><code>@font-face</code>는 다음과 같은 양식으로 작성한다.</p>\n<pre><code class=\"language-css\">@font-face {\n  font-family: \"MyWebFont\";\n  src: url(\"fonts/myfont.woff2\") format(\"woff2\"),\n        url(\"fonts/myfont.woff\") format(\"woff\");\n  font-weight: bold;\n  font-style: italic;\n}\n</code></pre>\n<p><code>font-family</code>는 폰트를 다운로드 받을 때 사용할 이름을 지정해주는 것이다. 이는 나중에 <code>font-family</code> 속성을 사용할 때 사용할 이름이다. 사실 이거 말고 나머지 속성이 더 중요하다.</p>\n<p>src에는 위에서 보다시피 쉼표로 구분해서 여러 폰트를 넣어 줄 수 있다. 그리고 format도 전달해 줄 수 있는데 이는 필수는 아니다. 하지만 브라우저가 해당 폰트를 사용할 수 있는 것인지 판단하는 데에 도움을 줄 수 있으므로 넣어주는 게 좋다.</p>\n<p>또한 브라우저는 src에 선언된 폰트를 순서대로 하나씩 시험해 보면서 가장 먼저 사용할 수 있는 것을 사용하므로, <code>woff2</code> 포맷 폰트와 같이 먼저 사용하고 싶은 폰트를 먼저 넣어주자.</p>\n<p><code>font-weight</code>와 <code>font-style</code>은 폰트의 굵기와 기울기를 지정해주는 것이다. 물론 다른 속성을 가진 폰트마다 따로 폰트 이름을 지정할 수 있다. <code>myFont-bold</code> 나 <code>myFont-italic</code>과 같이 말이다.</p>\n<p>하지만 이렇게 <code>@font-face</code>에서 weight, style을 지정해 주면 다른 스타일의 폰트를 같은 이름으로 지정해서 다운로드받더라도 <code>font-weight</code>와 <code>font-style</code>을 사용해 원하는 스타일의 폰트를 사용할 수 있다. 아래 <a href=\"#%EC%B0%B8%EA%B3%A0\">참고에 있는 링크</a> 에서 더 자세히 설명되어 있다.</p>\n<h1>참고</h1>\n<p><a href=\"https://www.456bereastreet.com/archive/201012/font-face_tip_define_font-weight_and_font-style_to_keep_your_css_simple/\">https://www.456bereastreet.com/archive/201012/font-face_tip_define_font-weight_and_font-style_to_keep_your_css_simple/</a></p>",
    "excerpt": "MDN CSS 튜토리얼의 텍스트 스타일링을 마무리한다.\n1. 링크 스타일링\n잘 몰랐던 것만 간단히 정리하자.\n1.1. 링크의 상태\n링크는 다음과 같은 상태들을 가지는데 이는 의사 클래스(:hover와 같은) 선택자를 통해 스타일링 가능하다.\n:link는 방문하지 않은 링크를 의미한다. 반면 방문한 링크는 :visited로 나타난다. :hover는 마우스를 올렸을 때의 상태를 의미하며, :active는 링크를 클릭했을 때의 상태를 의미한다.\ntab 키나 focus",
    "headingTree": [
      {
        "title": "1. 링크 스타일링",
        "url": "#1-링크-스타일링",
        "items": [
          {
            "title": "1.1. 링크의 상태",
            "url": "#11-링크의-상태",
            "items": []
          },
          {
            "title": "1.2. 외부 링크 선택",
            "url": "#12-외부-링크-선택",
            "items": []
          }
        ]
      },
      {
        "title": "2. 웹 폰트",
        "url": "#2-웹-폰트",
        "items": [
          {
            "title": "2.1. font-face 잘 사용하기",
            "url": "#21-font-face-잘-사용하기",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 137
    },
    "url": "/posts/mdn-css-7",
    "thumbnail": {
      "local": "/thumbnails/mdn-css-7-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-mdn-css-7-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAeUlEQVR4nFXJsQlDIRAAUF3kBxzGHSxuFQVHSAwS0t0UTiFYWBgi3AAWdhYWF0Ka/Nc+Ya07jgsAaK0BQCllrWNm4b2XUoYQaq2ttZwzEX0DEY0xMcYxBv8RKSVrXSllrXWK17v33oloznmK++N5vQVELKUw8977Fx/UW2y5lL05FwAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "mdn-css-8",
    "title": "프론트 지식 익히기 CSS-8",
    "date": "2023-04-19T00:00:00Z",
    "description": "MDN CSS 튜토리얼 - 8",
    "tags": [
      "web",
      "study",
      "front",
      "CSS"
    ],
    "html": "<p>이제 레이아웃에 대해서 이해해 보자.</p>\n<h1>1. 레이아웃 입문서</h1>\n<h2>1.1. normal flow</h2>\n<p>이는 페이지 레이아웃을 전혀 제어하지 않을 경우의 기본값이다. 요소를 블록 방향으로 순서대로 배치한다. 이러한 블록 방향은 영어같은 가로쓰기 언어에서 수직 방향의 배치를 의미한다.</p>\n<p>CSS를 사용해서 레이아웃을 만드는 경우 우리는 요소들을 이런 normal flow에서 벗어나게 한다. display, float, position, table(이는 권장되지는 않지만) 등을 통해 레이아웃을 만들 수 있다.</p>\n<h2>1.2. display 속성 개요</h2>\n<p>display 속성을 통해 블록 요소와 인라인 요소가 정해지며 이를 임의로 바꿀 수 있다는 것을 이전에 배웠다. 하지만 다른 속성도 있다.</p>\n<p><code>display:flex</code>로 설정할 시 모든 직계 자식이 플렉스 항목이 된다. 행이나 열 등 1차원 상의 개념으로 사물을 배치할 때 편리하게 사용할 수 있다. 이러면 <code>flex-direction</code>등의 속성을 통해 내부 자식들을 어떻게 배치할지 결정할 수 있다.</p>\n<p><code>display:grid</code>로 설정할 시 모든 직계 자식이 그리드 항목이 된다. 2차원 상의 개념으로 사물을 배치할 때 편리하게 사용할 수 있다. 이러면 <code>grid-template-rows</code>등의 속성을 통해 내부 자식들을 어떻게 배치할지 결정할 수 있다.</p>\n<p>그리드 디스플레이의 부모 요소에서 행과 열의 속성, 그리고 각 칸 사이의 gap 등을 설정해 주면 자식 요소들이 알아서 내부에 자리잡는다. 물론 <code>grid-row</code>등의 속성으로 직접 자식 요소들을 배치할 수도 있다.</p>\n<h2>1.3. float 속성 개요</h2>\n<p>float 속성을 사용하면 요소가 normal flow에서 벗어나 왼쪽이나 오른쪽으로 배치될 수 있게 해준다. 나머지 페이지 내용들은 float된 요소 주위로 떠다니게 된다. 이는 레이아웃을 만들 때 유용하게 사용할 수 있다.</p>\n<pre><code class=\"language-css\">.box{\n  // 요소를 왼쪽에 띄운다. box 클래스 요소에 이어지는 요소들은 box 주변을 떠다니게 된다.\n  float:left;\n}\n</code></pre>\n<h2>1.4. position 속성 개요</h2>\n<p>position 속성을 사용하면 요소를 기존의 배치 위치에서 벗어나 다른 위치로 이동시킬 수 있다. 이는 5가지 유형이 있다.</p>\n<p><code>position:static</code>은 기본값으로 요소를 normal flow에 따라 배치한다.</p>\n<p><code>position:relative</code>는 요소를 normal flow에 따라 배치하되, top, right, bottom, left 속성을 통해 요소의 위치를 조정할 수 있다. 다른 요소와 겹치게 하는 것도 가능하다.</p>\n<p><code>position:absolute</code>는 요소를 normal flow에서 제거하고, 가장 가까운 조상 요소나 html 요소를 기준으로 배치한다. 당연히 같은 부모 내의 다른 요소와 겹칠 수 있다.</p>\n<p><code>position:fixed</code>는 absolute와 비슷한데 요소를 normal flow에서 제거하고, 브라우저 뷰포트를 기준으로 요소를 배치한다. 스크롤해도 고정된 위치에 머물러 있다. 즉 언제나 뷰포트의 같은 위치에 있다.</p>\n<p><code>position:sticky</code>는 static과 같이 작동하다가 기존에 정의된 뷰포트의 지점에 도달하면 fixed와 같이 작동한다. 즉 어느 지점부터는 스크롤에 영향을 받지 않고 같은 위치에서 보이게 된다.</p>\n<h2>1.5. 다단 레이아웃</h2>\n<p>다단 레이아웃은 신문 기사처럼, 여러 개의 컬럼으로 페이지를 구성하는 것이다. 한 블록을 다단 컨테이너로 만들려면 <code>column-count</code>로 몇 단으로 나눌지 지정하거나 <code>column-width</code>로 단의 너비를 지정하면 된다.</p>\n<h1>2. normal flow</h1>\n<p>normal flow는 요소의 레이아웃을 전혀 건드리지 않았을 때 요소의 배치 방식이다. 이때의 배치 방식은 부모 요소의 쓰기 모드(<code>writing-mode</code> 속성)에 따라 달라지지만 일단은 수평 배치라고 생각하자.</p>\n<p>블록 요소는 수직 방향으로 쌓이며 줄바꿈을 해서 나타난다. 그리고 각 요소의 margin에 의해 구분된다. 이때 인접한 요소 둘 다 margin이 있다면 둘 중 더 큰 값만 남는다.</p>\n<p>인라인 요소는 수평 방향으로 쌓이며 줄바꿈을 하지 않고 나타난다. 단 충분한 공간이 없을 경우 넘치는 텍스트나 요소는 새로운 줄에 나타난다. <code>span</code>요소의 배치를 생각해 보면 된다.</p>\n<h1>3. flexbox</h1>\n<p>flexbox는 1차원으로 요소들을 배치하는 방법이다. 이 이전에는 floats나 position 속성을 이용해서 페이지 레이아웃을 배치하였다.</p>\n<h2>3.1. flexbox 구성</h2>\n<p><img src=\"/static/flex-structure-6886062a.png\" alt=\"structure\"></p>\n<p>플렉스 모델은 위와 같은 구조를 하고 있다.</p>\n<p><code>display:flex</code>가 설정된 부모 요소가 flex container이고 그 내부의 자식 요소로 레이아웃되는 항목들을 flex item이라 한다.</p>\n<p>main axis는 컨테이너에서 main start에서 시작해서 main end 방향으로 진행하는 축이다. 이 축을 따라서 컨테이너 내부에 flex item들이 배치된다. cross axis는 main axis와 수직인 축이다.</p>\n<h2>3.2. flexbox 속성</h2>\n<p><code>flex-direction</code>은 row, column, row-reverse, column-reverse 중 하나를 지정할 수 있다. 이 속성을 통해 main axis의 방향을 결정할 수 있다. reverse는 당연히 메인 축을 반대 방향으로 한다.</p>\n<p><code>flex-wrap</code>은 nowrap, wrap, wrap-reverse 중 하나를 지정할 수 있다. nowrap은 기본값으로 한 줄에 모든 flex item을 배치한다. 공간이 부족하면 넘어간다. wrap은 한 줄에 모든 flex item을 배치할 수 없을 때 다음 줄로 넘어간다. wrap-reverse는 wrap과 비슷하지만 반대 방향으로 배치한다.</p>\n<p><code>flex-flow</code>를 지정하면 flex-direction과 flex-wrap을 한 번에 지정할 수 있다. <code>flex-flow:row wrap;</code>와 같이 사용한다.</p>\n<h2>3.3. flex 속성 탐구</h2>\n<p>flex는 <code>flex-grow</code>, <code>flex-shrink</code>, <code>flex-basis</code>의 shorthand이다. 이 속성은 각 아이템에 지정되어서 해당 아이템이 컨테이너 공간에 맞추기 위해 어떻게 크기를 조절할지를 설정한다. 이 각각의 속성은 다음과 같은 것을 지정한다.</p>\n<h3>3.3.1. flex-grow</h3>\n<p>flex-grow는 아이템의 너비 합이 컨테이너 너비보다 작을 때 컨테이너 내부에서 남게 되는 여유 공간을 분배하는 방법을 설정한다.</p>\n<p>영역을 채우는 방식은 다음과 같다. 이후에 다룰 flex-basis에서 지정한 기본 너비를 모든 아이템에 배정한다. 그리고 여유 공간이 남을 경우 flex-grow 값에 따라서 남은 여유 공간을 분배한다.</p>\n<p>예를 들어서 HTML이 다음과 같이 작성되어 있다.</p>\n<pre><code class=\"language-html\">&#x3C;div class=\"container\">\n  &#x3C;div class=\"item\">1번&#x3C;/div>\n  &#x3C;div class=\"item\">2번&#x3C;/div>\n  &#x3C;div class=\"item\">3번&#x3C;/div>\n  &#x3C;div class=\"item\">4번&#x3C;/div>\n&#x3C;/div>\n</code></pre>\n<p>그리고 CSS를 다음처럼 작성한다.</p>\n<pre><code class=\"language-css\">.container{\n  display:flex;\n  flex-wrap:nowrap;\n  gap:0;\n  padding:10px;\n  background:aqua;\n  width:600px;\n}\n\n.item{\n  flex-basis:100px;\n}\n\n.item:nth-child(1){\n  flex-grow:1;\n}\n.item:nth-child(2){\n  flex-grow:2;\n}\n.item:nth-child(3){\n  flex-grow:3;\n}\n.item:nth-child(4){\n  flex-grow:4;\n}\n</code></pre>\n<p>그러면 컨테이너에서 내용에 할애되는 너비는 600px이다. 그리고 각 아이템에는 flex-basis에 따라 100px씩 할당된다. 그리고 남은 여유 공간은 200px이다.</p>\n<p>이 200px의 여유 공간이 flex-grow의 비율에 따라 분배된다. 즉 1번 아이템은 1/10, 2번 아이템은 2/10, 3번 아이템은 3/10, 4번 아이템은 4/10의 여유 공간을 할당받아 각각 120px, 140px, 160px, 180px의 너비를 가진다.</p>\n<h3>3.3.2. flex-shrink</h3>\n<p>flex-shrink는 컨테이너에 <code>flex-wrap:wrap</code>이 지정되어 있을 경우 적용되지 않는다. 컨테이너보다 아이템의 너비가 더 클 때 축소시키는 방법을 지정하는 속성인데, wrap일 경우 아이템 너비가 더 크면 새 줄로 넘어가기 때문이다.</p>\n<p>아무튼 flex-shrink에 설정된 값에 따라서 초과된 요소들이 축소된다. 만약 flex-shrink가 0이면 전혀 축소되지 않는다. 반면 flex-shrink가 형제 요소들에서 모두 같으면 모두 같은 비율로 축소되어 형제 요소들의 크기가 다 같아진다.</p>\n<p>그럼 각 아이템의 flex-shrink 값을 다르게 지정하면 어떻게 되는가? grow에서와 같다. 컨테이너를 넘어간 아이템들의 너비의 합을 flex-shrink 값의 합으로 나눈 비율에 따라서 각 아이템의 너비가 축소된다.</p>\n<p>예를 들어 200px가 초과되었고 각 아이템이 1,2,3,4의 flex-shrink 값을 가지고 있다면 1번 아이템은 20px, 2번 아이템은 40px, 3번 아이템은 60px, 4번 아이템은 80px의 너비를 감소시킨다.</p>\n<h3>3.3.3. flex-basis</h3>\n<p>flex-basis는 flex-grow와 flex-shrink가 적용되기 전에 아이템의 기본 크기를 지정한다. 이 크기는 메인 축의 방향에 따라 다른데 메인 축이 row 방향이면 너비, column 방향이면 높이가 된다.</p>\n<p>만약 flex-basis가 auto이면 아이템에 지정된 width나 height에 따라 크기가 결정된다(내용에도 영향을 받는다). content이면 내용에 따라 크기가 결정된다. 단 content는 오래된 브라우저에서 지원되지 않을 수 있다.</p>\n<p>flex-basis가 0이면 아이템의 기본 크기가 0이 된다. 이 경우 flex-grow와 flex-shrink 값에 따라서 아이템 너비를 배분하게 된다. 컨테이너의 모든 부분이 여백으로 간주되기 때문이다.</p>\n<p>따라서 아이템의 내용에 상관없이 모든 아이템의 너비를 동일하게 하고 싶다면 flex-basis를 0으로 지정하고 flex-grow를 1로 지정하면 된다.</p>\n<h3>3.3.4. flex</h3>\n<p>그럼 shorthand인 flex는 어떨까? flex는 1~3개의 값을 사용해 지정 가능하다.</p>\n<ul>\n<li>\n<p>값이 1개일 때\n숫자를 지정하면 <code>flex-grow</code>이다. 길이(100px등)나 비율을 지정하면 <code>flex-basis</code>이다.</p>\n</li>\n<li>\n<p>값이 2개일 때\n첫째 값은 숫자여야 하며 <code>flex-grow</code>가 된다. 두번째 값의 경우 숫자라면 <code>flex-shrink</code>가 되고, 길이나 비율이라면 <code>flex-basis</code>가 된다.</p>\n</li>\n<li>\n<p>값이 3개일 때\n첫째 값은 <code>flex-grow</code>가 된다. 두번째 값은 <code>flex-shrink</code>가 된다. 세번째 값은 <code>flex-basis</code>가 된다. 당연히 첫번째, 두번째 값은 숫자여야 하고 세번째 값은 길이나 비율이어야 한다.</p>\n</li>\n<li>\n<p>특수한 키워드\ninitial은 아이템 크기가 컨테이너 크기를 넘을 경우 컨테이너 크기에 맞춰 줄어들지만 기본적으로는 각각의 width, height를 따른다. <code>flex:0 1 auto</code>와 같다. 이게 flex의 초기값이다.</p>\n</li>\n</ul>\n<p>auto는 아이템의 기본 크기는 자동으로 정하고 컨테이너 크기에 맞춰 늘어나거나 줄어들도록 한다. <code>flex:1 1 auto</code>와 같다.</p>\n<p>none은 아이템의 크기를 자동으로 지정하고 고정시킨다. <code>flex:0 0 auto</code>와 같다.</p>\n<h2>3.4. 아이템 배치</h2>\n<p><code>justify-content</code>는 아이템을 메인 축 방향으로 어떻게 배치할지 지정한다. <code>align-items</code>는 아이템을 교차 축 방향으로 어떻게 배치할지 지정한다.</p>\n<p>만약 <code>flex-direction</code>이 row라면 <code>justify-content</code>는 아이템들이 행의 어느 부분에 배치되는지를 지정한다. 그리고 <code>align-items</code>는 아이템들이 세로로 어느 부분에 놓이는지를 지정한다.</p>\n<p><code>align-self</code>로 개별 아이템의 cross axis상의 배치를 지정할 수도 있다.</p>\n<h3>3.4.1. justify-content 속성</h3>\n<p>다른 건 일반적으로 생각할 수 있는 속성들이다. <code>space-around</code>는 모든 항목을 기본 축을 따라 고르게 분배한다. 또한 양쪽에 약간의 공간을 남긴다.</p>\n<p>반면 <code>space-between</code>은 양쪽에 공간을 남기지 않고 모든 항목을 기본 축을 따라 고르게 분배한다.</p>\n<h2>3.5. order</h2>\n<p>각 flex item에 order를 지정할 수 있다. 순위값이 낮은 항목들이 먼저 배치되며 기본값은 0이다. 즉 만약 어떤 아이템의 order를 1로 설정하면 뒤쪽에 배치될 것이다.</p>\n<p>음수 order를 지정하여 기본 order를 가진 아이템보다 앞쪽에 배치되게 할 수도 있다.</p>\n<h1>4. grid</h1>\n<p>그리드 레이아웃은 페이지의 요소들을 2차원으로 배치할 수 있도록 한다. 페이지를 행과 열로 나눈 후 몇 행 몇 열에 어떤 요소를 배치할지를 지정하는 것이다. 다음과 같이 그리드 디스플레이 모드를 지정한다.</p>\n<pre><code class=\"language-css\">display: grid;\n</code></pre>\n<h2>4.1. 그리드 만들기 기본</h2>\n<p><code>grid-template-columns</code>와 <code>grid-template-rows</code>를 사용해 행과 열을 만들 수 있다. <code>fr</code>단위를 사용하면 그리드 컨테이너 내부의 사용 가능한 공간을 분할하여 각 행과 열의 크기를 지정할 수 있다.</p>\n<pre><code class=\"language-css\">// 사용 가능한 너비를 1:2:1로 분할하여 열 3개 생성\ngrid-template-columns: 1fr 2fr 1fr;\n// 사용 가능한 높이를 1:1:2로 분할하여 행 3개 생성\ngrid-template-rows: 1fr 1fr 2fr;\n</code></pre>\n<p>행/열 사이 간격은 <code>grid-column-gap</code>과 <code>grid-row-gap</code>을 사용해 지정한다. <code>grid-gap</code>을 사용하면 한 번에 지정할 수도 있다.(row-gap, column-gap의 단축 속성) <code>grid-</code>접두사 없이도 갭을 지정 가능하다.</p>\n<p><code>repeat()</code>함수를 사용하면 반복되는 행/열을 간단하게 지정할 수 있다. <code>repeat(5, 1fr)</code>을 지정하면 5개의 1fr 크기의 행 혹은 열을 생성한다. <code>minmax()</code>도 있는데, 이는 각 행 혹은 열의 최소 크기와 최대 크기를 지정할 수 있다.</p>\n<pre><code class=\"language-css\">grid-template-columns: repeat(5, minmax(50px, auto));\n</code></pre>\n<h2>4.2. 행과 열을 자동으로 설정</h2>\n<p>지금까지 <code>grid-template-rows</code>를 쓸 땐 행의 수를 직접 지정해 주어야 했다. 그런데 설정된 크기가 허용하는 한 최대한 많이 행을 만들고 싶을 수 있다. 이럴 땐 auto-fill이나 auto-fit을 사용한다.</p>\n<pre><code class=\"language-css\">.container{\n  // 100px 크기의 행을 최대한 많이 생성\n  // 만약 높이에서 나머지가 남으면 그냥 다음 줄로 넘어간다\n  grid-template-rows: repeat(auto-fill, 100px);\n}\n</code></pre>\n<p>이를 auto-fit으로 바꾸면, 컨테이너에 남은 공간이 있을 시 그 공간을 채우기 위해 존재하는 행의 크기를 늘리게 된다.</p>\n<p><code>grid-auto-rows</code>, <code>grid-auto-columns</code>를 사용하면 <code>grid-template-</code>으로 통제되고 있는 행/열 외에 있는 행/열의 크기를 지정한다. 만약 <code>grid-template-</code>속성 없이 이 속성만 지정할 경우 모든 행/열을 이 속성이 지정한 크기로 만든다.</p>\n<pre><code class=\"language-css\">// 100px 크기의 행과 열을 자동 생성\ngrid-auto-rows: 100px;\ngrid-auto-columns: 100px;\n</code></pre>\n<h2>4.3. 그리드 아이템 배치</h2>\n<p>grid-row와 grid-column 속성으로 각 그리드 아이템이 몇 행 몇 열에 배치될지 지정할 수 있다. <code>1/3</code>과 같이 시작 라인과 끝 라인을 지정할 수도 있다.</p>\n<p>혹은 grid-row-start, grid-row-end, grid-column-start, grid-column-end 속성을 사용해서 각각 아이템의 시작 라인과 끝 라인을 지정할 수도 있다.</p>\n<h2>4.4. grid-template-areas</h2>\n<p>처음 안 사실인데, <code>grid-template-areas</code>속성을 이용하면 각 그리드 요소에 이름을 지정하고 그 이름을 통해 아이템을 배치할 수 있다.</p>\n<pre><code class=\"language-css\">.container{\n  display:grid;\n  grid-template-areas:\n    \"header header header\"\n    \"main main aside\"\n    \"footer footer footer\";\n  grid-template-columns: 1fr 1fr 1fr;\n  grid-template-rows: 1fr 1fr 1fr;\n}\n\n// header 태그는 header라고 이름붙은 그리드 area들을 차지한다\nheader{\n  grid-area: header;\n}\n\nmain{\n  grid-area: main;\n}\n...\n</code></pre>\n<p>위와 같이 나눠진 그리드에 각각 이름을 붙여서 아이템을 배치하는 데 활용할 수 있다. 이때 area에 지정하는 이름들은 그리드의 모든 셀을 채우도록 해야 한다. 만약 셀을 비우려면 <code>.</code>을 넣어야 한다.</p>\n<p>또한 이름을 통해 지정한 영역은 행/열 번호를 통해 지정한 것과 마찬가지로 반드시 직사각형이어야 하며 영역은 유일해야 한다.</p>\n<h1>참고</h1>\n<p>flex 속성 <a href=\"https://developer.mozilla.org/ko/docs/Web/CSS/flex\">https://developer.mozilla.org/ko/docs/Web/CSS/flex</a></p>\n<p>flex 2 <a href=\"https://blogpack.tistory.com/863\">https://blogpack.tistory.com/863</a></p>\n<p><a href=\"https://velog.io/@garcon/Flexbox-flex-basis-auto%EC%99%80-0%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90\">https://velog.io/@garcon/Flexbox-flex-basis-auto%EC%99%80-0%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90</a></p>\n<p>auto-fill과 auto-fit <a href=\"https://velog.io/@iandr0805/CSS-Grid-auto-fit%EA%B3%BC-auto-fill%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90\">https://velog.io/@iandr0805/CSS-Grid-auto-fit%EA%B3%BC-auto-fill%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90</a></p>\n<p>grid의 좋은 정리자료 <a href=\"https://studiomeal.com/archives/533\">https://studiomeal.com/archives/533</a></p>",
    "excerpt": "이제 레이아웃에 대해서 이해해 보자.\n1. 레이아웃 입문서\n1.1. normal flow\n이는 페이지 레이아웃을 전혀 제어하지 않을 경우의 기본값이다. 요소를 블록 방향으로 순서대로 배치한다. 이러한 블록 방향은 영어같은 가로쓰기 언어에서 수직 방향의 배치를 의미한다.\nCSS를 사용해서 레이아웃을 만드는 경우 우리는 요소들을 이런 normal flow에서 벗어나게 한다. display, float, position, table(이는 권장되지는 않지만) 등을 통해",
    "headingTree": [
      {
        "title": "1. 레이아웃 입문서",
        "url": "#1-레이아웃-입문서",
        "items": [
          {
            "title": "1.1. normal flow",
            "url": "#11-normal-flow",
            "items": []
          },
          {
            "title": "1.2. display 속성 개요",
            "url": "#12-display-속성-개요",
            "items": []
          },
          {
            "title": "1.3. float 속성 개요",
            "url": "#13-float-속성-개요",
            "items": []
          },
          {
            "title": "1.4. position 속성 개요",
            "url": "#14-position-속성-개요",
            "items": []
          },
          {
            "title": "1.5. 다단 레이아웃",
            "url": "#15-다단-레이아웃",
            "items": []
          }
        ]
      },
      {
        "title": "2. normal flow",
        "url": "#2-normal-flow",
        "items": []
      },
      {
        "title": "3. flexbox",
        "url": "#3-flexbox",
        "items": [
          {
            "title": "3.1. flexbox 구성",
            "url": "#31-flexbox-구성",
            "items": []
          },
          {
            "title": "3.2. flexbox 속성",
            "url": "#32-flexbox-속성",
            "items": []
          },
          {
            "title": "3.3. flex 속성 탐구",
            "url": "#33-flex-속성-탐구",
            "items": [
              {
                "title": "3.3.1. flex-grow",
                "url": "#331-flex-grow",
                "items": []
              },
              {
                "title": "3.3.2. flex-shrink",
                "url": "#332-flex-shrink",
                "items": []
              },
              {
                "title": "3.3.3. flex-basis",
                "url": "#333-flex-basis",
                "items": []
              },
              {
                "title": "3.3.4. flex",
                "url": "#334-flex",
                "items": []
              }
            ]
          },
          {
            "title": "3.4. 아이템 배치",
            "url": "#34-아이템-배치",
            "items": [
              {
                "title": "3.4.1. justify-content 속성",
                "url": "#341-justify-content-속성",
                "items": []
              }
            ]
          },
          {
            "title": "3.5. order",
            "url": "#35-order",
            "items": []
          }
        ]
      },
      {
        "title": "4. grid",
        "url": "#4-grid",
        "items": [
          {
            "title": "4.1. 그리드 만들기 기본",
            "url": "#41-그리드-만들기-기본",
            "items": []
          },
          {
            "title": "4.2. 행과 열을 자동으로 설정",
            "url": "#42-행과-열을-자동으로-설정",
            "items": []
          },
          {
            "title": "4.3. 그리드 아이템 배치",
            "url": "#43-그리드-아이템-배치",
            "items": []
          },
          {
            "title": "4.4. grid-template-areas",
            "url": "#44-grid-template-areas",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 2,
      "wordCount": 547
    },
    "url": "/posts/mdn-css-8",
    "thumbnail": {
      "local": "/static/flex-structure-6886062a.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-flex-structure-6886062a-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAFCAIAAAD38zoCAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAiElEQVR4nAF9AIL/AP///5SUlH19fcvLyz4+Ps3NzNra2vPz8wDOzs59fX19fX2pqaeQkZHAwMKenp22trYAfX19U1NUQT05NzMuQkE/amVgQUBAfX19AObm5sLCwl1dWnBsaEVCQZyZlM7Ozubm5gDz8/POzs7Ly8vOzs4ZGRmRkpPLy8vz8/OsaEiIPsd3WAAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "mdn-css-9",
    "title": "프론트 지식 익히기 CSS-9",
    "date": "2023-04-22T00:00:00Z",
    "description": "MDN CSS 튜토리얼 - 9",
    "tags": [
      "web",
      "study",
      "front",
      "CSS"
    ],
    "html": "<h1>1. floats</h1>\n<p>floats는 원래 페이지의 레이아웃을 잡는 데에 가장 널리 사용되는 도구 중 하나였다. 하지만 flex, grid가 나오면서 원래 floats의 목적인 텍스트 블록 내의 부유하는 이미지를 위해 쓰이게 되었다.</p>\n<p>float는 원래 신문 기사에 삽입된 사진처럼, 텍스트 문단 내부에 부유하는 이미지를 포함하고 텍스트가 그 이미지를 둘러싸게 하는 레이아웃을 구현하기 위해 도입되었다. 이러한 float의 원래 용도에 대해 알아보자.</p>\n<pre><code class=\"language-css\">float:left;\n</code></pre>\n<p>위와 같이 요소를 설정하면 해당 요소는 기존의 컴포넌트 배치 흐름에서 벗어나서 부모 컨테이너의 왼쪽에 고정되게 된다. 그리고 부모 컨테이너 내의 HTML 상에서 그 아래에 오는 모든 내용은 float한 요소 주변을 감싸게 된다.</p>\n<p>그런데 float된 요소 주변에 특정 요소까지만 감싸게 하고 싶다면 어떻게 해야 할까? 그럴 때는 clear를 사용하면 된다.</p>\n<pre><code class=\"language-css\">clear: left;\n</code></pre>\n<p>위와 같은 CSS 속성을 설정하면 왼쪽에 float된 요소들을 더 이상 감싸지 않고 새 줄에서 시작하게 된다. 비슷한 원리로 right, both를 사용하면 각각 오른쪽, 양쪽에 float된 요소들을 더 이상 감싸지 않게 된다.</p>\n<h2>1.1. float의 문제 해결</h2>\n<p>다음과 같은 상황을 생각해 보자. 하나의 wrapper 박스 안에 커다란 박스가 있고 이것이 float처리되어 일반 대열에서 벗어나 있다. 그리고 wrapper 박스 안에는 작은 문단이 들어가 있다. 그리고 wrapper 박스에 배경색을 넣는다고 생각해 보자.</p>\n<p>이때 wrapper 박스는 내부에 있는 컨텐츠 크기만큼 늘어나게 되는데 문제는 float 처리된 박스가 일반 흐름에서 벗어나기 때문에 wrapper 박스가 float 처리된 박스를 감싸지 않는다는 것이다. 그래서 wrapper 박스의 배경색이 float 처리된 박스 아래로 내려가지 않는다.</p>\n<p><img src=\"/static/wrapper-and-float-a7260ef9.png\" alt=\"wrapper-and-float\"></p>\n<p>wrapper 박스가 float 박스의 크기를 고려하지 않는 이런 문제를 어떻게 해결할 수 있을까?</p>\n<p>이를 해결하는 방법 하나는 wrapper 박스 이후에 div 클래스를 하나 추가하고 clear: both; 속성을 추가해 주는 것이다. <code>::after</code> 선택자를 사용해서 이를 구현할 수 있다.</p>\n<pre><code class=\"language-css\">.wrapper::after {\n  content: \"\";\n  display: block;\n  clear: both;\n}\n</code></pre>\n<p>이 방식을 clearfix hack이라고 한다. 항목 아래에 빈 블록 요소를 추가한 후 해당 요소 이후로 float가 적용되지 않도록 하는 것이다. 이렇게 하면 wrapper 박스가 float 요소까지 고려해서 늘어나게 된다.</p>\n<p>wrapper 클래스에 <code>overflow:auto</code>를 설정하는 것도 방법이다. 이러면 wrapper 박스 내부에 작은 레이아웃이 생기고 여기에는 float 요소까지 포함되어 있게 된다. 따라서 wrapper 박스가 float 요소까지 고려해서 늘어나게 된다.</p>\n<p>현대적인 방식도 있는데 이는 <code>display:flow-root</code>를 wrapper 박스에 설정하는 것이다. 이러면 wrapper 박스를 요소 흐름의 루트로 만들어서, wrapper 내부에 작은 레이아웃(블록 서식)을 생성하게 된다.</p>\n<p><code>overflow:auto</code>를 한 것과 같은 효과로 인해 wrapper 박스가 float요소까지 고려해서 늘어나게 된다.</p>\n<h1>2. position 속성</h1>\n<p>갖가지 땔감 코딩들을 하면서 너무 많이 맞닥뜨려서 <a href=\"https://witch.work/mdn-css-8/#14-position-%EC%86%8D%EC%84%B1-%EA%B0%9C%EC%9A%94\">이전 글</a>의 내용으로 충분하다.<del>그것이 나유타 분의 1이라 할지라도, 내게는 넘치도록 충분하다!</del></p>\n<h1>3. 다단 레이아웃</h1>\n<p>다단 레이아웃은 흔히 신문기사와 같은 여러 단 배치를 하는 기술이다. 사실 처음 다뤄본다. 하지만 그렇게 복잡한 건 없었다.</p>\n<p><code>column-count</code>는 숫자로 설정하는데 여기 설정한 숫자만큼 해당 요소를 단으로 나눈다.</p>\n<pre><code class=\"language-css\">.container{\n  column-count: 3;\n}\n</code></pre>\n<p><code>column-width</code>는 길이로 지정하며 해당 크기의 단을 최대한 많이 만든다. 만약 나머지 공간이 남으면 지금 있는 단들에게 공평하게 분배된다. 또한 지정한 단 너비가 실제 컨테이너 너비보다 작다면 컨테이너는 부족한 너비로 1단을 이룬다.</p>\n<p>예를 들어서 <code>column-width</code>가 200px인데 컨테이너가 150px라면 150px짜리 한 단으로 컨테이너가 이뤄진다.</p>\n<p><code>column-gap</code>은 단 사이 간격을 지정한다. <code>column-rule</code>은 단을 구분하는 선의 스타일을 지정한다. 선의 색, 선 스타일, 선 너비의 단축 속성이라 다음과 같이 지정한다.</p>\n<pre><code class=\"language-css\">.container{\n  column-count:5;\n  column-rule: 1px solid black;\n}\n</code></pre>\n<h2>3.1. CSS fragmentation</h2>\n<p>만약 컨텐츠가 여러 페이지나 단으로 나뉘어져 있을 경우 어떻게 표시될 것인가를 정하는 속성들이다. 필요하면 <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Fragmentation\">MDN 페이지</a>를 참고하자.</p>\n<p>예를 들어서 <code>break-inside</code>는 프린트 등의 환경에서 요소가 여러 페이지에 걸쳐 있을 때 박스를 페이지에 맞게 나눌지, 아니면 요소를 나누지 않고 한 페이지에 다 표시하기 위해 새 페이지를 시작할지를 결정한다. <code>break-inside:avoid</code>를 지정할 시 요소가 여러 페이지에 걸쳐 나타나지 않게 된다.</p>\n<h1>4. 반응형 디자인</h1>\n<p>다양한 화면 너비, 해상도 등에 맞게 레이아웃 등이 변하는 웹페이지를 말한다. 예전에 모바일 웹이 처음 나왔을 때는 <code>m.naver.com</code>과 같이 모바일 전용 웹페이지를 만들었다. 하지만 이는 유지보수가 어렵고, 사용자 경험도 좋지 않았다.</p>\n<p>그래서 반응형 디자인이 등장했다. 반응형 디자인은 별도의 기술이 아니라 웹을 어떻게 접근했는지나 화면의 크기 등에 따라 반응할 수 있는 레이아웃 사례 전반을 말한다.</p>\n<p>예를 들어서 반응형 이미지는 <code>&#x3C;picture></code>태그의 srcset, sizes 속성을 사용하여 브라우저가 화면 크기와 해상도에 따라 다운로드할 이미지를 선택하게 하는 것을 말한다.</p>\n<p>글자 크기도 <code>vw</code>등의 단위로 설정할 수 있다. 그러나 vw단위만 사용하면 사용자가 텍스트 집합을 확대/축소하지 못하게 된다. 따라서 대안으로 <code>calc()</code>를 사용하여 고정 크기와 <code>vw</code>단위를 함께 사용할 수 있다.</p>\n<pre><code class=\"language-css\">p{\n  font-size: calc(16px + 0.5vw);\n}\n</code></pre>\n<h2>4.1. 뷰포트 메타태그</h2>\n<p>모바일 브라우저는 뷰포트 너비를 제대로 알리지 않는 경우가 있다. 따라서 다음과 같은 메타태그를 사용하여 뷰포트 너비를 장치 너비로 설정하여 문서를 100%크기로 확장해야 한다.</p>\n<pre><code class=\"language-html\">&#x3C;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n</code></pre>\n<p>이런 걸 쓰게 되는 이유는, 처음 스마트폰이 출시되었을 때 대부분 사이트가 모바일 최적화가 되지 않았기 때문이다. 따라서 모바일 브라우저는 뷰포트 너비를 일부러 960px로 지정하곤 했다. 하지만 요즘은 대부분의 사이트가 모바일 최적화가 되어있기 때문에 이런 설정을 항상 해야 한다.</p>\n<h2>4.2. 미디어 쿼리</h2>\n<p>미디어 쿼리는 브라우저나 장치 환경에 따라 다른 CSS를 제공할 수 있도록 해준다. 기본형은 다음과 같다.</p>\n<pre><code class=\"language-css\">@media 미디어타입 and (미디어 피쳐){\n  /* 조건이 만족되었을 때 적용할 CSS */\n}\n</code></pre>\n<p>미디어 유형은 all, print, screen이 있다.</p>\n<h3>4.2.1. 높이와 너비</h3>\n<p>널리 쓰이는 미디어 피쳐는 높이와 너비에 관한 것이다. 예를 들어 <code>min-width</code>는 최소 너비를 지정하는데, 이는 뷰포트 너비가 지정한 너비보다 크거나 같을 때 적용된다.</p>\n<pre><code class=\"language-css\">@media screen and (min-width:768px){\n  /* 화면으로 보고 있으며 뷰포트 너비가 768px 이상일 때 적용할 CSS */\n}\n</code></pre>\n<p><code>max-width</code>등도 적용 가능하다. 또한 <code>width</code>만 사용하면 브라우저가 특정 너비일 때만 적용되는 CSS를 만들 수 있는데 자주 쓰이지는 않는다.</p>\n<h3>4.2.2. 장치 방향</h3>\n<p>장치가 세로 방향인지 가로 방향인지 판단하는 orientation이라는 미디어 피쳐도 있다. 이는 <code>portrait</code>와 <code>landscape</code>로 나뉜다. portrait는 세로 방향, landscape는 가로 방향을 의미한다.</p>\n<pre><code class=\"language-css\">@media screen and (orientation:portrait){\n  /* 장치가 세로 방향일 때 적용할 CSS */\n}\n</code></pre>\n<p>흔히 데스크톱은 가로 방향이고 휴대폰이 세로 방향의 장치이다.</p>\n<h3>4.2.3. 포인팅 장치</h3>\n<p>포인팅 장치는 마우스, 터치 등을 의미한다. 이는 <code>pointer</code>와 <code>hover</code>로 나뉜다. pointer는 마우스를 의미하고 hover는 마우스를 올렸을 때를 의미한다.</p>\n<p>터치스크린과 같은 장치에서는 요소에 포인터를 올릴 수 없다. 따라서 요소에 hover가 가능한 경우에만 적용되는 CSS를 만들고 싶다면 다음과 같이 한다.</p>\n<pre><code class=\"language-css\">@media (hover:hover){\n  /* 요소에 마우스를 올릴 수 있을 때 적용할 CSS */\n}\n</code></pre>\n<p>pointer는 사용자의 포인팅 장치를 의미한다. none, fine, coarse 3가지 값을 취할 수 있다. fine은 사용자가 마우스 혹은 트랙패드를 사용할 경우이다. 그리고 coarse는 터치스크린 상의 손가락을 의미하고 none은 키보드 등으로 조작하는 사용자라 포인팅 장치가 없다는 것을 의미한다.</p>\n<p>사용자가 터치스크린을 사용할 경우 버튼을 더 크게 만드는 등에 사용 가능하다.</p>\n<h3>4.2.4. 미디어 쿼리의 논리</h3>\n<p>and를 통해 쿼리를 논리곱으로 적용할 수 있다. 또한 not을 통해 쿼리를 부정할 수 있다. not을 쓸 경우 전체 미디어 쿼리가 부정된다. 다음과 같이 쓰면 보기 방향이 가로일 경우에만 css가 적용된다.</p>\n<pre><code class=\"language-css\">@media not all and (orientation:portrait){\n  /* 장치가 세로 방향일 때 적용할 CSS */\n}\n</code></pre>\n<p>논리합의 경우 <code>or</code>같은 게 아니라 쉼표를 써서 적용한다.</p>\n<h2>4.3. 반응형 디자인 접근방식</h2>\n<p>반응형 디자인을 할 때는 가장 넓은 뷰에서 시작해서 작아지는 뷰포트에 맞게 디자인할 수도 있고 반대로 가장 작은 뷰로 시작해서 뷰포트가 커짐에 따라 레이아웃을 추가할 수도 있다. 후자는 mobile-first로 불리며 더 많이 쓰인다. tailwind등의 많은 라이브러리에서도 후자를 권장한다.</p>\n<p>물론 미디어 쿼리를 쓰지 않는 방식도 가능하다. 예를 들어서 다음과 같이 쓸 수 있다.</p>\n<pre><code class=\"language-css\">grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));\n</code></pre>\n<p>이렇게 설정할 시 미디어 쿼리를 사용하지 않았지만 뷰포트 크기에 따라 열의 설정이 변한다. 또한 최소 너비도 보장된다. 이런 방식은 미디어 쿼리를 쓰지 않고도 반응형 디자인을 할 수 있게 해준다.</p>\n<p>또한 다단 레이아웃의 <code>column-width</code>등도 뷰포트 너비에 맞게 단을 생성하도록 하여 반응형 디자인에 쓸 수 있다.</p>\n<h1>5. 브라우저 지원</h1>\n<p>흔히 레이아웃을 위해 flex나 grid를 사용한다. 그러나 예전 브라우저의 경우 이러한 현대적인 레이아웃 메서드를 지원하지 않을 수 있다. <a href=\"https://caniuse.com/\">caniuse</a>에서 각 기능의 브라우저 지원을 확인할 수 있다.</p>\n<p>또한 <a href=\"https://developer.mozilla.org/ko/docs/Learn/CSS/CSS_layout/Supporting_Older_Browsers#%EB%8C%80%EC%B2%B4_%EB%A9%94%EC%84%9C%EB%93%9C\">대체 메서드</a>를 사용하여 지원되지 않는 레이아웃 메서드를 대체할 수 있다. 예를 들어 grid 레이아웃 대신 float나 <code>display:table</code>, 혹은 다단 레이아웃을 사용할 수 있다.</p>\n<p>또한 <code>@supports</code>로 사용하는 피쳐 쿼리를 사용해서 특정 기능을 지원하는 브라우저에 대해 다른 CSS를 적용하도록 할 수도 있다. 그러나 이 피쳐 쿼리도 꽤 최신 기능이기 때문에 grid를 적용할 수 없는 브라우저에서는 피쳐 쿼리도 사용할 수 없는 문제가 있다.</p>",
    "excerpt": "1. floats\nfloats는 원래 페이지의 레이아웃을 잡는 데에 가장 널리 사용되는 도구 중 하나였다. 하지만 flex, grid가 나오면서 원래 floats의 목적인 텍스트 블록 내의 부유하는 이미지를 위해 쓰이게 되었다.\nfloat는 원래 신문 기사에 삽입된 사진처럼, 텍스트 문단 내부에 부유하는 이미지를 포함하고 텍스트가 그 이미지를 둘러싸게 하는 레이아웃을 구현하기 위해 도입되었다. 이러한 float의 원래 용도에 대해 알아보자.\nfloat:left;",
    "headingTree": [
      {
        "title": "1. floats",
        "url": "#1-floats",
        "items": [
          {
            "title": "1.1. float의 문제 해결",
            "url": "#11-float의-문제-해결",
            "items": []
          }
        ]
      },
      {
        "title": "2. position 속성",
        "url": "#2-position-속성",
        "items": []
      },
      {
        "title": "3. 다단 레이아웃",
        "url": "#3-다단-레이아웃",
        "items": [
          {
            "title": "3.1. CSS fragmentation",
            "url": "#31-css-fragmentation",
            "items": []
          }
        ]
      },
      {
        "title": "4. 반응형 디자인",
        "url": "#4-반응형-디자인",
        "items": [
          {
            "title": "4.1. 뷰포트 메타태그",
            "url": "#41-뷰포트-메타태그",
            "items": []
          },
          {
            "title": "4.2. 미디어 쿼리",
            "url": "#42-미디어-쿼리",
            "items": [
              {
                "title": "4.2.1. 높이와 너비",
                "url": "#421-높이와-너비",
                "items": []
              },
              {
                "title": "4.2.2. 장치 방향",
                "url": "#422-장치-방향",
                "items": []
              },
              {
                "title": "4.2.3. 포인팅 장치",
                "url": "#423-포인팅-장치",
                "items": []
              },
              {
                "title": "4.2.4. 미디어 쿼리의 논리",
                "url": "#424-미디어-쿼리의-논리",
                "items": []
              }
            ]
          },
          {
            "title": "4.3. 반응형 디자인 접근방식",
            "url": "#43-반응형-디자인-접근방식",
            "items": []
          }
        ]
      },
      {
        "title": "5. 브라우저 지원",
        "url": "#5-브라우저-지원",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 211
    },
    "url": "/posts/mdn-css-9",
    "thumbnail": {
      "local": "/static/wrapper-and-float-a7260ef9.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-wrapper-and-float-a7260ef9-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAACCAIAAADq9gq6AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAPUlEQVR4nAEyAM3/AJubm+7u7lBQUHR0czo6OhIREZ+enqiopwCPj49yc3V2cW1oX1VIQDdCPDS1tbTf399Coxc+zSBK9QAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "mdn-javascript-4",
    "title": "프론트 지식 익히기 Javascript - 4",
    "date": "2023-05-14T00:00:00Z",
    "description": "MDN Javascript 튜토리얼 - 4",
    "tags": [
      "web",
      "study",
      "front",
      "javascript"
    ],
    "html": "<p>클라이언트 사이드 웹 API에 대해 다뤄본다.</p>\n<h1>1. 소개</h1>\n<p>클라이언트의 JS는 개발자들이 사용할 수 있는 많은 API를 제공한다. 이는 JS 언어에 규정된 건 아니지만 클라이언트사이드 JS 상에서 구현되어 있다. 브라우저 API와 서드파티 API로 나뉜다.</p>\n<p>일반적인 브라우저 API에는 DOM을 조작하는 <code>getElementById</code>등의 API, 그리고 <code>fetch</code>와 같은 네트워크 통신 API, <code>requestAnimationFrame</code>과 같은 애니메이션 API 등이 있다. 세션 스토리지 등의 웹 스토리지도 브라우저 API가 제공하는 기능에 해당한다.</p>\n<h2>1.1. JS API들의 특징</h2>\n<p>JS API들은 각각 조금씩 다른 원리로 작동하지만 일반적으로 공유하는 특징들이 있다.</p>\n<p>API들은 대부분 JS 객체로 이루어져 있다. API가 사용하는 데이터와 함수들을 담는 컨테이너로 객체를 쓰는 것이다.</p>\n<p>예를 들어 DOM API들은 <code>document</code> 객체에 담겨있다. <code>document.getElementById</code>와 같은 API를 호출하면 <code>document</code> 객체의 <code>getElementById</code> 함수를 호출하는 것이다.</p>\n<p>그리고 API들은 일반적으로 진입점을 가지고 있다. 예를 들어서 DOM API는 document 객체 혹은 HTML 요소의 인스턴스들을 진입점으로 사용할 수 있다.</p>\n<p>상태 변화를 위해서 일반적으로 이벤트를 이용한다는 것도 특징 중 하나이다. 또 다른 웹 기술들과 같이 보안 메커니즘을 가지고 있는 경우가 있다. 예를 들어서 HTTPS로 서빙하는 페이지에서만 작동하는 API도 있다.</p>\n<h1>2. DOM 조작</h1>\n<p>웹페이지를 만들 때 페이지의 문서 구조를 바꾸고 싶을 때가 많다. 이럴 때 DOM API를 사용하면 된다.</p>\n<h2>2.1. 기타 웹 API</h2>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Client-side_web_APIs/Manipulating_documents#the_important_parts_of_a_web_browser\">여기</a>참고해서 새 글을 쓰자.</p>\n<p>보안상의 이유로 개발자가 조작할 수 없는 브라우저의 부분들도 많다. 그러나 여전히 굉장히 많은 걸 할 수 있는데, 브라우저에서 웹페이지를 띄울 때 일반적으로 쓰이는 부분들은 다음과 같다.</p>\n<p>window는 웹페이지가 뜨는 브라우저 탭을 뜻한다. 이는 JS에서 <code>Window</code> 객체로 표현되며 <code>innerWidth</code> 등의 프로퍼티를 사용할 수 있고 해당 윈도우에 로딩되는 document를 조작하는 등의 동작을 할 수 있다.</p>\n<p>navigator는 브라우저의 상태와 정보를 담고 있다. <code>Navigator</code>객체로 표현된다.</p>\n<p>그리고 document는 윈도우에 띄워지는 실제 페이지이다. <code>Document</code>객체로 표현되며 <code>getElementById</code>와 같은 DOM API를 사용해서 페이지를 구성하는 HTML, CSS 정보를 조작하고 변경할 수 있다. 여기서는 document 객체에 대해 자세히 다룰 것이다.</p>\n<h2>2.2. DOM(Document Object Model) 조작</h2>\n<p>브라우저에 로딩되는 문서는 DOM으로 표현된다. DOM은 트리 구조이고 프로그래밍 언어에 의해 접근될 수 있도록 브라우저에 의해 만들어진다. 이렇게 만들어진 DOM은 브라우저가 스타일링을 적용할 때도 쓰이고 개발자들이 DOM을 조작할 때도 사용할 수 있다.</p>\n<p>예를 들어서 다음과 같은 JS 코드를 쓸 수 있다. <code>querySelector</code>는 CSS 선택자를 통해 DOM에서 요소를 찾는다.</p>\n<pre><code class=\"language-js\">const linkComponent = document.querySelector('a');\n</code></pre>\n<p>그러면 해당 변수는 HTML a 태그 요소에 대한 참조를 가지게 되고 그 요소에 정의된 프로퍼티와 메서드를 사용할 수 있게 된다. 이는 HTMLAnchorElement 혹은 더 일반적인 HTMLElement나 Node(아예 DOM의 모든 일반적인 노드를 뜻함)에 정의된 것들이다. <code>Node.textContent</code>등을 사용할 수 있다.</p>\n<pre><code class=\"language-js\">linkComponent.textContent = 'Click me!';\n</code></pre>\n<p><code>document.createElement</code>나 <code>Node.appendChild</code> 등의 메서드를 이용해 아예 새 요소를 만들고 문서에 추가할 수도 있다.</p>\n<p>요소들을 DOM에서 이동하거나 삭제하는 것도 가능한데 주의할 점은 우리가 요소의 참조를 가지고 있다는 것이다. 다음과 같은 HTML을 실행해 보면, p태그가 section 태그의 자식으로 옮겨진 것을 볼 수 있다. 기존 p태그는 그대로 있고 새로운 p태그가 section의 자식으로 추가되는 것이 <strong>아니다!</strong> 만약 새 자식을 추가하고 싶다면 <code>Node.cloneNode</code>를 사용해야 한다.</p>\n<pre><code class=\"language-html\">&#x3C;body>\n  &#x3C;p>예제 문단&#x3C;/p>\n  &#x3C;section>\n    이건 섹션입니다.\n  &#x3C;/section>\n  &#x3C;script>\n    const para=document.querySelector(\"p\");\n    const sect=document.querySelector(\"section\");\n\n    para.textContent=\"예시 문단의 변경된 텍스트\";\n    sect.appendChild(para);\n  &#x3C;/script>\n&#x3C;/body>\n</code></pre>\n<p>그리고 DOM의 인라인 스타일도 이를 통해 조작할 수 있다. <code>HTMLElement.style</code>의 프로퍼티들을 변경하면 된다.</p>\n<p>혹은 미리 클래스를 정의해둔 뒤 <code>Element.setAttribute</code>를 이용해서 클래스를 추가할 수도 있다. 이렇게 하면 인라인 CSS 스타일이 아니라 클래스를 통한 CSS를 추가할 수 있다.</p>\n<pre><code class=\"language-js\">elem.setAttribute(\"class\", \"newClass\");\n</code></pre>\n<p>이렇게 클래스를 동적으로 설정하는 방법은 사전에 스타일 클래스를 정의해야 한다는 단점이 있지만 CSS와 JS 분리가 더 잘 이루어진다는 장점이 있다. 프로젝트가 커지면 이쪽 방법이 더 많이 쓰인다.</p>\n<h1>3. 서버에서 데이터 가져오기</h1>\n<p>전체 페이지를 다시 로드하는 대신에, 서버에서 가져온 데이터를 통해서 페이지 일부만 업데이트하는 일은 자주 일어난다. 그리고 이 작은 디테일이 큰 퍼포먼스 변화를 만든다. 따라서 이런 것을 가능하게 하는 fetch API를 알아보자.</p>\n<h2>3.1. 개요</h2>\n<p>웹페이지는 일반적으로 HTML, CSS, JS 파일로 구성된다. 그리고 이런 파일들은 서버에서 가져온다. 브라우저가 페이지 로딩을 위해 필요한 파일을 가져오기 위해 서버에 HTTP 요청을 보내면 서버는 요청받은 파일을 보내주는 것이다. 다른 페이지로 넘어가면 새 파일을 요청하고 서버는 그 파일들을 넘겨준다.</p>\n<p>하지만 페이지의 일부만 변경된 데이터로 업데이트해주고 싶을 수 있다. 가령 페이지의 다른 부분은 다 공통이고 닉네임만 바뀐다거나. 이런 경우 JS API를 사용하여 페이지 로드 없이 페이지의 딱 필요한 부분만 업데이트한다. 여기 쓰이는 게 바로 fetch API이다.</p>\n<h2>3.2. fetch API</h2>\n<p>fetch API는 네트워크에서 자원을 얻어오고, 응답이 사용 가능해지면 resolve되는 Promise를 반환한다. 이때 resolve되는 것은 응답을 나타내는 Response 객체이다. 양식은 다음과 같다.</p>\n<pre><code class=\"language-js\">fetch(resource);\nfetch(resource, options);\n</code></pre>\n<p>첫 인수 resource는 가져올 자원의 경로를 넣거나 Request 객체를 넣는다. 2번째 인수는 요청에 적용할 설정들을 포함한 객체이다. 형식은 다음과 같다.</p>\n<pre><code class=\"language-js\">options 객체\n{\n  method: GET, POST 등 요청 메서드,\n  headers: {\n    추가할 헤더들을 넣은 객체\n  },\n  body: 요청에 담을 데이터,\n  mode: cors, no-cors, same-origin 등 요청에 사용할 모드,\n  credentials: omit, same-origin, include 등 요청에 사용할 인증 정보,\n  cache: HTTP 캐시와의 상호작용을 정의하는 부분,\n  redirect: manual, follow, error 등 리다이렉트 처리 방식,\n  referrer: 요청에 사용할 referrer,\n  referrerPolicy: 리퍼러 정책,\n  integrity: 서브 리소스의 무결성 체크를 위한 부분,\n  keepalive: 페이지 수명이 다해도 요청이 백그라운드에서 계속 유지되는지 여부,\n  signal: 요청과 통신하다가 필요한 경우 요청을 중단하는 데 쓰임,\n  priority: 같은 종류의 요청들 중 중요한 정도(high, low, auto),\n}\n</code></pre>\n<p>이때 반환하는 Promise는 네트워크 문제가 있을 때만 reject되며 HTTP 오류 시엔 거부되지 않는다. 따라서 <code>Response.ok</code> 혹은 <code>Response.status</code>를 확인해서 HTTP 오류를 처리해야 한다.</p>\n<p>예시는 다음과 같다.</p>\n<pre><code class=\"language-js\">fetch(URL).then((res)=>{\n  if(res.ok){\n    return res.json();\n  }else{\n    throw new Error(\"HTTP error\");\n  }\n}).then((json)=>{\n  // json 데이터를 사용한다.\n}).catch((err)=>{\n  console.log(err);\n});\n</code></pre>\n<h2>3.3. XHR</h2>\n<p>가끔 낡은 코드들을 보면 XMLHttpRequest 객체를 사용하는 것을 볼 수 있다. 이는 흔히 XHR이라 불리는데, fetch API가 나오기 전에 AJAX 통신을 위해 사용되던 방식이다.</p>\n<p>간단한 예시 코드는 다음과 같다.</p>\n<pre><code class=\"language-js\">const xhr = new XMLHttpRequest();\n\ntry{\n  xhr.open(\"GET\", URL);\n  xhr.responseType = \"json\";\n\n  xhr.onload = () => {\n    if(xhr.status === 200){\n      console.log(xhr.response);\n    }else{\n      throw new Error(\"HTTP error\");\n    }\n  };\n  xhr.onerror = () => {\n    throw new Error(\"XHR error\");\n  };\n  xhr.send();\n}catch(err){\n  console.log(`XHR error ${xhr.status}`);\n}\n</code></pre>\n<h1>4. 그래픽 다루기</h1>\n<p>브라우저는 그래픽 프로그래밍 도구도 제공한다. 여기서는 canvas에 대해 알아보도록 하자.</p>\n<h2>4.1. 웹 그래픽의 역사</h2>\n<p>웹은 원래 문서를 보여주는 것이 목적이라 텍스트뿐이었다. 그 이후 <code>&#x3C;img></code>태그를 통해 이미지를 보여주는 게 가능해졌고 또 시간이 지나서 CSS의 <code>background-image</code>를 통해서도 이미지를 보여줄 수 있게 되었다.</p>\n<p>하지만 이들은 여전히 마크업을 통해서 표현되었기 때문에 비트맵 이미지를 다룰 수 없었고 애니메이션이나 3D 표현 등을 할 수 있는 도구가 없었다. C++과 자바에서는 OpenGL등을 이용해서 가능했는데..</p>\n<p>이후 2004년 canvas 요소와 Canvas API가 나오면서 2D 애니메이션, 데이터 시각화 등을 다룰 수 있게 되었다. 또한 2006~2007년에는 WebGL이 나와서 3D 그래픽을 다룰 수 있게 되었다. 여기서는 2D canvas에 대해서만 다루도록 하자.</p>\n<h2>4.2. canvas 다뤄보기</h2>\n<p>페이지에 2D나 3D 그래픽을 만들려면 canvas 요소를 문서에 넣어 주어야 한다. 이 요소는 페이지에 그래픽을 그릴 영역을 정의한다.</p>\n<pre><code class=\"language-html\">&#x3C;canvas width=\"1920\" height=\"1080\">&#x3C;/canvas>\n</code></pre>\n<p>만약 canvas 요소 내부에 어떤 요소를 넣게 되면, canvas를 지원하지 않는 브라우저에서 보여줄 fallback을 지정할 수 있다. 이미지에 alt text를 지원하는 것과 비슷하다.</p>\n<p>다음과 같은 HTML을 작성하자.</p>\n<pre><code class=\"language-js\">&#x3C;canvas class=\"myCanvas\">\n  &#x3C;p>fallback here&#x3C;/p>\n&#x3C;/canvas>\n</code></pre>\n<p>JS를 이용해서 캔버스의 크기를 설정한다. 페이지를 꽉 채우도록. 그리고 캔버스를 조작하기 위해서는 <code>getContext</code> 메서드를 통해서 캔버스의 그리기 영역에 대한 참조를 가져와야 한다. 이때 인수로는 가져오고 싶은 컨텍스트를 넣을 수 있다. 일단 2d 캔버스를 가져와 보자.</p>\n<pre><code class=\"language-js\">const canvas=document.querySelector('.myCanvas');\nconst width=(canvas.width=window.innerWidth);\nconst height=(canvas.height=window.innerHeight);\n// webgl 등을 컨텍스트로 가져오기도 가능\nconst ctx=canvas.getContext('2d');\n</code></pre>\n<p>이제 ctx는 CanvasRenderingContext2D 객체이며 캔버스에 가해지는 모든 그리기는 이 객체를 조작함으로써 구현된다. 예를 들어 다음과 같은 코드로 황토색 직사각형을 그릴 수 있다.</p>\n<pre><code class=\"language-js\">// rgba()로 투명도 설정까지도 가능\nctx.fillStyle='rgb(176,150,0)';\nctx.fillRect(50,50,100,150);\n</code></pre>\n<p>나중에 그려진 것이 더 위에 그려진다는 것도 알아두자. 따라서 여러 가지 도형을 한번에 그릴 때 순서에 유의해야 한다.</p>\n<h2>4.3. 다른 함수들</h2>\n<p>위에서 쓴 <code>fillRect</code>는 색으로 채워진 직사각형을 그리는 함수이다. 일단 fill과 반대되는 개념으로 선만을 그리는 stroke로 시작하는 함수들이 있다.</p>\n<pre><code class=\"language-js\">ctx.strokeStyle='rgb(176,150,0)';\nctx.strokeRect(50,50,100,150);\n</code></pre>\n<p>lineWidth로 선 굵기도 조정할 수 있다.</p>\n<pre><code class=\"language-js\">ctx.lineWidth=10;\n</code></pre>\n<p>경로를 그릴 수도 있다.</p>\n<pre><code class=\"language-js\">// 경로 시작. 기본적으로 (0,0)에서 시작한다.\nctx.beginPath();\n// 현재 위치를 (100,100)으로 옮긴다.\nctx.moveTo(100,100);\n// (200,100)까지 선을 그린다.\nctx.lineTo(200,100);\n// (200,200)까지 선을 그린다.\nctx.lineTo(200,200);\n// 선을 렌더링한다.\nctx.stroke();\n</code></pre>\n<p>물론 <code>fillStyle</code>, <code>strokeStyle</code>등도 사용할 수 있다.</p>\n<p>원 혹은 호를 그리기 위해서는 <code>arc()</code>함수를 사용한다. 형식은 다음과 같다. x,y를 중심으로 하고 반지름이 radius인 원 혹은 호를 그리는 것이다.</p>\n<pre><code class=\"language-js\">// startAngle, endAngle은 라디안 단위.\narc(x, y, radius, startAngle, endAngle)\narc(x, y, radius, startAngle, endAngle, counterclockwise)\n</code></pre>\n<p>글자는 <code>fillText</code>와 <code>strokeText</code>를 사용한다. 형식은 다음과 같다.</p>\n<pre><code class=\"language-js\">fillText(text, x, y [, maxWidth])\nstrokeText(text, x, y [, maxWidth])\n</code></pre>\n<p>캔버스에 외부 이미지를 렌더링하는 것도 가능하다. <code>drawImage()</code>메서드를 이용한다. 이미지 객체를 만들고 캔버스 내에 그리면 된다. 단 이미지가 로드되기 전에 그리려고 하면 에러가 발생하므로 이벤트 리스너를 이용해서 로드가 완료된 후에 그려야 한다.</p>\n<pre><code class=\"language-js\">const img=new Image();\nimg.src=\"example.png\";\n// drawImage에 파라미터를 더 주면 이미지의 일부만 그리기도 가능\nimg.onload=()=>{\n  ctx.drawImage(img, 0, 0);\n};\n</code></pre>\n<p>이때 캔버스 내용은 스크린 리더가 접근할 수 없기 때문에 <code>aria-label</code>을 설정하거나 fallback content를 canvas 태그 내부에 제공하는 게 좋다. 여기선 aria-label을 설정해보자.</p>\n<pre><code class=\"language-js\">canvas.setAttribute(\"aria-label\", \"example image\");\n</code></pre>\n<h2>4.4. 애니메이션</h2>\n<p>캔버스에선 애니메이션을 만들 수 있는 강력한 기능을 제공한다. 먼저 반복해서 도형을 그리는 간단한 예시부터 살펴보자. 캔버스를 HTML 문서에 넣는 것부터 시작한다.</p>\n<pre><code class=\"language-html\">&#x3C;canvas class=\"myCanvas\">\n  &#x3C;p>fallback here&#x3C;/p>\n&#x3C;/canvas>\n</code></pre>\n<p>그리고 JS에서 캔버스를 가져오고 캔버스의 크기를 설정한 후 원점을 페이지 중앙으로 잡는다.</p>\n<pre><code class=\"language-js\">const canvas=document.querySelector('.myCanvas');\nconst width=(canvas.width=window.innerWidth);\nconst height=(canvas.height=window.innerHeight);\n\nconst ctx=canvas.getContext('2d');\n\nctx.fillStyle='rgb(0,0,0)';\nctx.fillRect(0,0,width,height);\n\nctx.translate(width/2,height/2);\n</code></pre>\n<p>이제 다음 코드를 추가하자. 이렇게 하고 페이지를 실행하면 삼각형이 회전하는 모양이 그려진 것을 볼 수 있다.</p>\n<pre><code class=\"language-js\">function degToRad(degrees){\n  return degrees*Math.PI/180;\n}\n\n// 그려지는 삼각형은 점점 작아지고 서로 멀게 그려진다.\nfor(let i=0, length=250, moveOffset=20;i&#x3C;length;i++, length--, moveOffset+=0.7){\n  // length가 늘어남에 따라 색이 변화하도록\n  ctx.fillStyle=`rgba(${255-length}, 0, ${255-length}, 0.9)`;\n  ctx.beginPath();\n  ctx.moveTo(moveOffset, moveOffset);\n  // 삼각형 그리기\n  ctx.lineTo(moveOffset+length, moveOffset);\n  const triangleHeight=(length / 2) * Math.tan(degToRad(60));\n  ctx.lineTo(moveOffset+length/2, moveOffset+triangleHeight);\n  ctx.lineTo(moveOffset, moveOffset);\n  ctx.fill();\n  // 1번 그릴 때마다 캔버스를 약간씩 회전시킨다\n  ctx.rotate(degToRad(5));\n}\n</code></pre>\n<p>하지만 우리가 원하는 건 반복되어서 실행되는 애니메이션이다. 각 프레임마다 다르게 무언가가 그려지는 것이다. 이렇게 반복해서 함수를 실행하도록 도와주는 JS 함수가 <code>window.requestAnimationFrame()</code>이다.</p>\n<p>해당 함수는 브라우저가 스크린을 업데이트할 준비가 되면 바로바로 인수로 받은 함수를 실행한다. 언제까지? 우리가 <code>requestAnimationFrame</code>을 더 이상 호출하지 않거나 <code>cancelAnimationFrame</code>을 호출할 때까지(애니메이션을 사용하지 않게 되면 이걸 호출해 주는 게 좋다).</p>\n<h2>4.5. 간단한 그림판 만들기</h2>\n<p>그림판을 만드는 건 캔버스를 처음 배우는 사람들이 다들 거쳐가는 관문이다.</p>\n<p><img src=\"/static/canvas_talk-58f22c85.jpeg\" alt=\"talk\"></p>\n<p>MDN에서도 이를 예제로 제시하고 있기에 한번 해보자.</p>\n<p>먼저 다음과 같은 HTML을 작성하자.</p>\n<pre><code class=\"language-html\">&#x3C;!DOCTYPE html>\n&#x3C;html lang=\"en-us\">\n  &#x3C;head>\n    &#x3C;meta charset=\"utf-8\">\n    &#x3C;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    &#x3C;meta name=\"viewport\" content=\"width=device-width\">\n    &#x3C;title>canvas로 만든 그림판&#x3C;/title>\n    &#x3C;script src=\"main.js\" defer>&#x3C;/script>\n    &#x3C;link rel=\"stylesheet\" href=\"index.css\">\n  &#x3C;/head>\n  &#x3C;body>\n    &#x3C;section class=\"toolbar\">\n      &#x3C;input type=\"color\" aria-label=\"select color\" value=\"#ff000\">\n      &#x3C;input type=\"range\" aria-label=\"select line width\" min=\"1\" max=\"50\" value=\"25\">\n      &#x3C;span class=\"output\">25&#x3C;/span>\n      &#x3C;button>캔버스 초기화&#x3C;/button>\n    &#x3C;/section>\n    &#x3C;canvas class=\"myCanvas\">\n      &#x3C;p>그림판 예제의 캔버스&#x3C;/p>\n    &#x3C;/canvas>\n  &#x3C;/body>\n&#x3C;/html>\n</code></pre>\n<p>JS 파일에서는 먼저 기본적인 캔버스 세팅을 해준 후 요소들의 참조를 가져온다.</p>\n<pre><code class=\"language-js\">const canvas=document.querySelector('.myCanvas');\nconst width=(canvas.width=window.innerWidth);\n// 캔버스 높이는 창보다 약간 작게\nconst height=(canvas.height=window.innerHeight-85);\n\nconst ctx=canvas.getContext('2d');\n\nctx.fillStyle='rgb(0,0,0)';\nctx.fillRect(0,0,width,height);\n\nconst colorPicker = document.querySelector('input[type=\"color\"]');\nconst sizePicker = document.querySelector('input[type=\"range\"]');\nconst output = document.querySelector('.output');\nconst clearBtn = document.querySelector('button');\n</code></pre>\n<p>우리가 그림판에서 쓸 펜은 원을 그리는 형태이므로 거기 필요한 각도-라디안 변환 함수와, 펜 굵기를 조절함에 따라 span값을 바꾸는 이벤트 리스너를 만든다.</p>\n<pre><code class=\"language-js\">function degToRad(degrees){\n  return degrees*Math.PI/180;\n}\n\nsizePicker.addEventListener('input',()=>\n  output.textContent=sizePicker.value\n);\n</code></pre>\n<p>그리고 마우스의 좌표를 따라가며 눌린 상태와 눌리지 않은 상태를 트래킹하는 변수를 만들고 이벤트에 반응하게 만든다. 또한 캔버스 초기화 버튼을 누를 시 캔버스를 다시 검은색으로 채워 초기화하는 이벤트 리스너도 만든다.</p>\n<pre><code class=\"language-js\">let curX, curY, pressed=false;\n\ndocument.addEventListener('mousemove',e=>{\n  curX=e.clientX;\n  curY=e.clientY;\n});\n\ndocument.addEventListener('mousedown',()=>(pressed=true));\ndocument.addEventListener('mouseup',()=>(pressed=false));\n\nclearBtn.addEventListener('click',()=>{\n  ctx.fillStyle='rgb(0,0,0)';\n  ctx.fillRect(0,0,width,height);\n});\n</code></pre>\n<p>이제 그리기 로직을 만들어야 한다. 만약 <code>pressed</code>가 true이면 우리는 마우스 위치를 기준으로 펜 굵기만큼의 원을 그리면 된다. 이때 마우스의 위치는 뷰포트의 맨 위에서부터 측정되는데 우리는 캔버스의 맨 위에서부터 측정해야 한다. 따라서 뷰포트의 위에 있는 툴바의 높이를 빼준다.</p>\n<p>이후 <code>requestAnimationFrame</code>을 이용해서 계속해서 그리도록 만들면 된다.</p>\n<pre><code class=\"language-js\">const toolBar=document.querySelector('.toolbar');\n\nfunction draw() {\n  if (pressed) {\n    ctx.fillStyle = colorPicker.value;\n    ctx.beginPath();\n    ctx.arc(\n      curX,\n      curY-toolBar.offsetHeight,\n      sizePicker.value,\n      degToRad(0),\n      degToRad(360),\n      false\n    );\n    ctx.fill();\n  }\n  requestAnimationFrame(draw);\n}\n\ndraw();\n</code></pre>\n<h2>4.6. 3차원 캔버스</h2>\n<p>3차원 캔버스는 WebGL API를 이용한다. 이는 2차원 캔버스와 똑같이 <code>&#x3C;canvas></code>요소를 이용하지만 완전히 다른 API이다. WebGL은 OpenGL에 기반하며 컴퓨터의 GPU를 이용할 수 있게 만든다.</p>\n<p>webGL을 그대로 쓰는 건 매우 어렵기 때문에 많은 사람들이 ThreeJS, BabylonJS와 같은 JS 서드파티 라이브러리를 쓴다. 이는 대부분 그래픽스 기반이므로, 원시 혹은 사용자 정의 모양을 만든 후 거기에 비추는 광원과 카메라를 이동하는 방식으로 작동한다.</p>\n<p>이는 이후에 <a href=\"https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Client-side_web_APIs/Drawing_graphics#using_a_library\">이곳</a>을 참고해서 해보자.</p>\n<h1>5. 비디오/오디오 API</h1>\n<p>HTML은 미디어를 임베딩할 수 있는 요소인 <code>&#x3C;video></code>와 <code>&#x3C;audio></code>도 제공한다. 또한 이들을 조작할 수 있는 API도 제공한다. 이들은 <code>HTMLMediaElement</code>객체에 있으며 <code>HTMLMediaElement.play()</code>등의 메서드를 사용할 수 있다.</p>\n<p>우리는 이런 API들을 이용해서 비디오나 오디오 플레이어를 만들 수 있다. video 태그에 controls 속성을 주기만 해도 플레이어가 뜨긴 한다. 하지만 그렇게 만들어진 플레이어는 브라우저마다 사양이 다르며 대부분 브라우저에서 키보드를 통한 접근이 불가능하다.</p>\n<p>따라서 HTMLMediaElement API를 활용해서 직접 만들 수 있다. 구체적인 과정은 <a href=\"https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Client-side_web_APIs/Video_and_audio_APIs\">여기</a>에서 해볼 수 있다. 혹은 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement\">HTMLMediaElement API</a>를 이용해서 설계해볼 수도 있겠다.</p>\n<h1>참고</h1>\n<p>fetch API <a href=\"https://developer.mozilla.org/ko/docs/Web/API/fetch\">https://developer.mozilla.org/ko/docs/Web/API/fetch</a></p>",
    "excerpt": "클라이언트 사이드 웹 API에 대해 다뤄본다.\n1. 소개\n클라이언트의 JS는 개발자들이 사용할 수 있는 많은 API를 제공한다. 이는 JS 언어에 규정된 건 아니지만 클라이언트사이드 JS 상에서 구현되어 있다. 브라우저 API와 서드파티 API로 나뉜다.\n일반적인 브라우저 API에는 DOM을 조작하는 getElementById등의 API, 그리고 fetch와 같은 네트워크 통신 API, requestAnimationFrame과 같은 애니메이션 API 등이 있다.",
    "headingTree": [
      {
        "title": "1. 소개",
        "url": "#1-소개",
        "items": [
          {
            "title": "1.1. JS API들의 특징",
            "url": "#11-js-api들의-특징",
            "items": []
          }
        ]
      },
      {
        "title": "2. DOM 조작",
        "url": "#2-dom-조작",
        "items": [
          {
            "title": "2.1. 기타 웹 API",
            "url": "#21-기타-웹-api",
            "items": []
          },
          {
            "title": "2.2. DOM(Document Object Model) 조작",
            "url": "#22-domdocument-object-model-조작",
            "items": []
          }
        ]
      },
      {
        "title": "3. 서버에서 데이터 가져오기",
        "url": "#3-서버에서-데이터-가져오기",
        "items": [
          {
            "title": "3.1. 개요",
            "url": "#31-개요",
            "items": []
          },
          {
            "title": "3.2. fetch API",
            "url": "#32-fetch-api",
            "items": []
          },
          {
            "title": "3.3. XHR",
            "url": "#33-xhr",
            "items": []
          }
        ]
      },
      {
        "title": "4. 그래픽 다루기",
        "url": "#4-그래픽-다루기",
        "items": [
          {
            "title": "4.1. 웹 그래픽의 역사",
            "url": "#41-웹-그래픽의-역사",
            "items": []
          },
          {
            "title": "4.2. canvas 다뤄보기",
            "url": "#42-canvas-다뤄보기",
            "items": []
          },
          {
            "title": "4.3. 다른 함수들",
            "url": "#43-다른-함수들",
            "items": []
          },
          {
            "title": "4.4. 애니메이션",
            "url": "#44-애니메이션",
            "items": []
          },
          {
            "title": "4.5. 간단한 그림판 만들기",
            "url": "#45-간단한-그림판-만들기",
            "items": []
          },
          {
            "title": "4.6. 3차원 캔버스",
            "url": "#46-3차원-캔버스",
            "items": []
          }
        ]
      },
      {
        "title": "5. 비디오/오디오 API",
        "url": "#5-비디오오디오-api",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 3,
      "wordCount": 792
    },
    "url": "/posts/mdn-javascript-4",
    "thumbnail": {
      "local": "/static/canvas_talk-58f22c85.jpeg",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-canvas_talk-58f22c85-jpeg",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAICAIAAAC+k6JsAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAdElEQVR4nGO4evFAVlaOqIgIDxgwGBga9vX1WFqYMzMzg/hPb98IDAri4eGCyl/ae8TC2oKBgQEq//vzu4bGxsjISCcnRx4eLoa2uobWthYjIyN1dXWQ/PxJMz29PdXV1YWFBSHmG+zcubOsrFRKUpKTmxsAYn0g7kcuZycAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "mdn-simple-page-test",
    "title": "MDN의 간단한 페이지 만들기 테스트",
    "date": "2023-03-23T01:00:00Z",
    "description": "MDN HTML, 멀티미디어와 임베딩",
    "tags": [
      "web",
      "study",
      "front",
      "HTML"
    ],
    "html": "<h1>간단한 페이지 만들기 테스트</h1>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Mozilla_splash_page\">MDN에서는 간단한 페이지에 미디어를 삽입하는 예제를 제공한다.</a> 한번 해보자.</p>\n<p>먼저 <a href=\"https://github.com/mdn/learning-area/tree/main/html/multimedia-and-embedding/mdn-splash-page-start\">github</a>에서 평가를 위한 파일을 받는다. index.html을 다운받은 후 pattern.png를 같은 폴더에 넣는다. originals 폴더의 이미지도 다운받는다.</p>\n<p>index.html에 있는 CSS는 일단 신경쓰지 말자. 기본으로 제공되는 index.html의 body 태그 구조는 다음과 같다.</p>\n<pre><code class=\"language-html\">&#x3C;body>\n  &#x3C;header>\n    &#x3C;h1>Mozilla&#x3C;/h1>\n    &#x3C;!-- insert &#x3C;img> element, link to the small\n        version of the Firefox logo -->\n  &#x3C;/header>\n\n  &#x3C;main>\n    &#x3C;article>\n      &#x3C;!-- insert iframe from youtube -->\n\n      &#x3C;h2>Rocking the free web&#x3C;/h2>\n\n      &#x3C;p>\n        Mozilla are a global community of technologists, thinkers, and\n        builders, working together to keep the Internet alive and accessible,\n        so people worldwide can be informed contributors and creators of the\n        Web. We believe this act of human collaboration across an open\n        platform is essential to individual growth and our collective future.\n      &#x3C;/p>\n\n      &#x3C;p>\n        Click on the images below to find more information about the cool\n        stuff Mozilla does.\n        &#x3C;a href=\"https://www.flickr.com/photos/mathiasappel/21675551065/\"\n          >Red panda picture&#x3C;/a\n        >\n        by Mathias Appel.\n      &#x3C;/p>\n    &#x3C;/article>\n\n    &#x3C;div class=\"further-info\">\n      &#x3C;!-- insert images with srcsets and sizes -->\n      &#x3C;a href=\"https://www.mozilla.org/en-US/firefox/new/\">\n        &#x3C;img />\n      &#x3C;/a>\n      &#x3C;a href=\"https://www.mozilla.org/\">\n        &#x3C;img />\n      &#x3C;/a>\n      &#x3C;a href=\"https://addons.mozilla.org/\">\n        &#x3C;img />\n      &#x3C;/a>\n      &#x3C;a href=\"https://developer.mozilla.org/en-US/\">\n        &#x3C;img />\n      &#x3C;/a>\n      &#x3C;div class=\"clearfix\">&#x3C;/div>\n    &#x3C;/div>\n\n    &#x3C;div class=\"red-panda\">\n      &#x3C;!-- insert picture element -->\n    &#x3C;/div>\n  &#x3C;/main>\n&#x3C;/body>\n</code></pre>\n<p>이제 주석에 써 있는 대로 하나하나 해보자.</p>\n<p>헤더에 작은 파이어폭스 로고 이미지를 넣는다.</p>\n<pre><code class=\"language-html\">&#x3C;header>\n  &#x3C;h1>Mozilla&#x3C;/h1>\n  &#x3C;!-- insert &#x3C;img> element, link to the small\n      version of the Firefox logo -->\n  &#x3C;img\n    src=\"./firefox_logo-only_RGB.png\"\n    alt=\"small version of the Firefox logo\"\n  />\n&#x3C;/header>\n</code></pre>\n<p>그 다음 main의 article에 <a href=\"https://www.youtube.com/watch?v=ojcNcvb1olg\">유튜브 영상</a>을 iframe으로 임베드한다. 영상에 들어가서 공유 버튼을 누른 후 퍼가기를 선택하여 나오는 iframe 코드를 복사하면 된다.</p>\n<p><img src=\"/static/youtube-iframe-4b4d142b.png\" alt=\"iframe\"></p>\n<p>또한 유튜브 영상의 너비가 400px여야 한다고 시키므로 iframe width를 400으로 설정한다.</p>\n<pre><code class=\"language-html\">&#x3C;!-- insert iframe from youtube -->\n&#x3C;iframe\n  width=\"400\"\n  height=\"315\"\n  src=\"https://www.youtube.com/embed/ojcNcvb1olg\"\n  title=\"YouTube video player\"\n  frameborder=\"0\"\n  allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\"\n  allowfullscreen\n>&#x3C;/iframe>\n</code></pre>\n<p>그 다음 링크에 들어갈 이미지를 추가한다. img 태그는 이미 선언되어 있고 여기에 src, alt, srcset, sizes 속성을 설정해 줘야 한다.</p>\n<p>화면이 500px 이하일 때는 120px 너비의 이미지를 사용하고, 그 이상일 땐 400px 너비의 이미지를 사용하도록 한다. 다음과 같이 링크 이미지들을 세팅해 주면 된다. 이때 이미지의 실제 크기와 srcset에 표기된 크기를 맞춰 주어서 브라우저가 사진의 크기를 제대로 인식할 수 있도록 한다.</p>\n<pre><code class=\"language-html\">&#x3C;img\n  srcset=\"./firefox_logo-only_RGB.png 1200w\"\n  sizes=\"(max-width:500px) 120px, 400px\"\n  src=\"./firefox_logo-only_RGB.png\"\n/>\n</code></pre>\n<p>이제 picture 태그를 사용해 레드 팬더 이미지를 넣어보자. 뷰포트가 600px 이하이면 작은 팬더 이미지를, 그 이상이면 큰 팬더 이미지를 사용하도록 한다. red-panda-small.jpg는 적절히 기존 이미지를 잘라서 만든다.</p>\n<pre><code class=\"language-html\">&#x3C;div class=\"red-panda\">\n  &#x3C;!-- insert picture element -->\n  &#x3C;picture>\n    &#x3C;source media=\"(max-width:600px)\" srcset=\"./red-panda-small.jpg\" />\n    &#x3C;img src=\"./red-panda.jpg\" alt=\"Red panda\" />\n  &#x3C;/picture>\n&#x3C;/div>\n</code></pre>\n<p>이렇게 하면 화면 너비에 따라서 다른 이미지가 나오는 것을 확인할 수 있다. 지금까지 한 대로 하면 MDN의 평가 항목들을 완료할 수 있다.</p>",
    "excerpt": "간단한 페이지 만들기 테스트\nMDN에서는 간단한 페이지에 미디어를 삽입하는 예제를 제공한다. 한번 해보자.\n먼저 github에서 평가를 위한 파일을 받는다. index.html을 다운받은 후 pattern.png를 같은 폴더에 넣는다. originals 폴더의 이미지도 다운받는다.\nindex.html에 있는 CSS는 일단 신경쓰지 말자. 기본으로 제공되는 index.html의 body 태그 구조는 다음과 같다.\n<body>\n  <header>\n    <h1>Mo",
    "headingTree": [
      {
        "title": "간단한 페이지 만들기 테스트",
        "url": "#간단한-페이지-만들기-테스트",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 329
    },
    "url": "/posts/mdn-simple-page-test",
    "thumbnail": {
      "local": "/static/youtube-iframe-4b4d142b.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-youtube-iframe-4b4d142b-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAICAIAAAC6ZnJRAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAu0lEQVR4nAGwAE//AJSKiGxhXywrKyImKCUnJxgeHktNTQAAAwhDJhlnLRomEABJHxRlGglWEAAAAAAGKRoSvEswgjgwxEAsvUc3dSAUABcYHXZyc/Ls6Pbk5vng3v/29oV/gAAEBQ55eXv////w9vbw9/f///+EhIUAXVpYoKCg/Pz88fDw9vLy////srKyAJ6YlsPEw/7+/vz8/Pv7+////9LS0gCXl5a6vMH6/P/7+vr9/f3////Q0NAmimBAHMb9zwAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "memo-project-1",
    "title": "메모장 만들기 프로젝트 - 1. 설계",
    "date": "2021-08-27T00:00:00Z",
    "description": "웹 메모장 프로젝트, 그 삽질의 기록1",
    "tags": [
      "web"
    ],
    "html": "<h1>1. 사이드 프로젝트의 시작</h1>\n<p>약 1년 정도 진행해 온 스터디가 있다. 처음에는 <code>전문가를 위한 파이썬</code> 을 읽고 정리하는 스터디였다. 그 다음에는 Django 백엔드와 React 프론트를 공부하려는 스터디로 넘어갔다.  <code>전문가를 위한 파이썬 책까지 공부했으니 이제 파이썬으로 무언가를 만들어 보자!</code> 라는 마음에서였다. 그러나 Django가 너무 복잡하다는 이야기가 많아서(내 의견도 그랬다. 백엔드가 처음이어서였는지 너무 어려웠다) Express 백엔드로 갈아탔다. 어느새 파이썬과는 전혀 상관없는 스터디가 되어 버렸다.</p>\n<p>그래서 React + Express 조합으로 간단한 클론코딩을 진행해 왔고 이제 그것도 막바지에 다다랐다. 나는 Express를 이용한 백엔드를 맡았고 말이다. 생각보다 지지부진하긴 했지만 나름 배우는 것도 많았다. 꽤 괜찮은 과정이었다고 생각한다. 모든 게 다 완벽하게 착착 맞아돌아갈 수는 없고 심지어 나 자신조차도 그러지 못하니까.</p>\n<p>어쨌거나 그것도 이제 막바지고 하니 이제 지금까지 잡다하게 공부한 것들을 활용해서 간단한 프로젝트를 만들고 그 과정을 정리해서 블로그에 올리고자 한다.</p>\n<p>무엇을 만들까 하다가 웹 메모장을 만들어 보기로 했다. 회원 시스템이 있고 로그인을 하면 내 메모를 관리할 수 있는 그런 간단한 웹 메모장 말이다.</p>\n<h1>2. 설계</h1>\n<p>프론트는 React, 백엔드는 Express, DB는 MySQL을 사용할 것이다. 또 styled-components를 이용해서 스타일링, React Router로 페이지 관리, passport로 로그인/회원가입 시스템을 만들기로 했다. 큰 틀은 이렇게 잡고 중간중간 필요한 라이브러리가 있으면 추가할 것이다. 가령 회원 정보 암호화를 이용한 crypto 라이브러리라든지.</p>\n<p>먼저 가장 핵심적인 메모장 기능을 하는 부분은 이전에 React를 공부하면서 메모장을 간단하게나마 만들어 놓은 적이 있어서, 그것을 조금 고쳐서 사용하고자 한다. <a href=\"https://witch-factory.netlify.app/\">https://witch-factory.netlify.app/</a> 에 올려 놓은 것이다. 물론 디자인만 끌어올 것이고 코드는 처음부터 다시 짤 것이다. 저기에 폴더 기능과 회원별 메모 DB등을 넣을 것이다.</p>\n<p>그리고 로그인과 회원가입 페이지는 메모장과 비슷한 색감의 페이지에 간단한 input 창들 정도만 만들고 나서 디자인을 조금씩 손보려고 한다. 디자인을 먼저 완벽히 해놓기에는 내가 디자인 능력이 없기도 하고 경험이 전혀 없기 때문이다.</p>\n<p>지금 필요하다고 생각하는 페이지는 메모장, 로그인 페이지, 회원가입 페이지뿐이지만 후에 필요하다고 생각되는 페이지가 더 생기면 그때 추가할 것이다. 일단 부딪쳐 보겠다.</p>\n<p>그리고 메모장 디자인에 상당히 많이 참고하는 상용 메모장 사이트가 있다. <a href=\"https://somcloud.com/apps/note\">솜노트</a> 이고 한때 나도 굉장히 애용했었다. 저 디자인이 아주 좋다고 생각하는 건 아니다. 이미 거슬리는 부분들이 있기 때문에 분명 색이나 구성 같은 부분에서 차이를 둘 것이다. 노트를 폴더로 묶어서 관리할 수 있고 수정 버튼을 누르는 것을 통해 삭제가 가능한 등...말로 표현하기는 힘들지만 구성 등에서 유사한 면이 많을 수 있다.</p>\n<p>만약 추후 설계가 더 탄탄해지면 이 글에 내용을 추가할 수도 있다.</p>",
    "excerpt": "1. 사이드 프로젝트의 시작\n약 1년 정도 진행해 온 스터디가 있다. 처음에는 전문가를 위한 파이썬 을 읽고 정리하는 스터디였다. 그 다음에는 Django 백엔드와 React 프론트를 공부하려는 스터디로 넘어갔다.  전문가를 위한 파이썬 책까지 공부했으니 이제 파이썬으로 무언가를 만들어 보자! 라는 마음에서였다. 그러나 Django가 너무 복잡하다는 이야기가 많아서(내 의견도 그랬다. 백엔드가 처음이어서였는지 너무 어려웠다) Express 백엔드로 갈아탔다. 어",
    "headingTree": [
      {
        "title": "1. 사이드 프로젝트의 시작",
        "url": "#1-사이드-프로젝트의-시작",
        "items": []
      },
      {
        "title": "2. 설계",
        "url": "#2-설계",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 25
    },
    "url": "/posts/memo-project-1",
    "thumbnail": {
      "local": "/thumbnails/memo-project-1-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-memo-project-1-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAiElEQVR4nD2LKw4DIRQA4QRoDIpjcAQSDkGC5yr9iIbUbBVuU0UtEkGC60sNYiUSh6DZNNuxM4OMMZRSKSUhRCklhOCcY4zRuj4ZY5TSEAIA5JxTSjHGXWitrbXe+1LKPECvEJxzrbVSyrZt4wC94QMAtdbe+z/fj+vtfjpfHsuSc55zjjF+4gvknmP+hY4BPQAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "memo-project-2",
    "title": "메모장 만들기 프로젝트 - 2. 프로젝트 구성",
    "date": "2021-08-29T00:00:00Z",
    "description": "웹 메모장 프로젝트, 그 삽질의 기록2",
    "tags": [
      "web",
      "react"
    ],
    "html": "<h1>1. 프로젝트의 구성 - 클라이언트</h1>\n<p>프론트를 담당할 client 폴더와 백을 담당할 server 폴더를 따로 분리해서 서로간에 정보를 주고받는 식으로 프로젝트를 구성하려고 한다. 이때 node_modules는 하나로 관리하는 게 좋으므로 모노레포로 구성해 주고자 했다.</p>\n<p>먼저 프로젝트 폴더 내에 <code>yarn init</code>을 한 후 <code>package.json</code> 에 workspace를 편집해 준다. 프로젝트를 모노레포로 구성하기 위해서이다.</p>\n<pre><code class=\"language-json\">{\n  \"name\": \"memo-jang\",\n  \"version\": \"1.0.0\",\n  \"main\": \"index.js\",\n  \"license\": \"MIT\",\n  \"private\": true,\n  \"workspaces\": [\n    \"client\",\n    \"server\"\n  ]\n}\n</code></pre>\n<p>그리고 클라이언트는 create-react-app으로 만들어 준다.</p>\n<pre><code>npx create-react-app client\n</code></pre>\n<p>client 폴더 내에 들어가서 yarn start 를 하면 리액트 기본 페이지가 자동으로 생성되는 것을 알 수 있다.</p>\n<p>그리고 eslint는 airbnb-style-guide를 사용해 주자.</p>\n<p><a href=\"https://velog.io/@_jouz_ryul/ESLint-Prettier-Airbnb-Style-Guide%EB%A1%9C-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0\">https://velog.io/@_jouz_ryul/ESLint-Prettier-Airbnb-Style-Guide%EB%A1%9C-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0</a></p>\n<p>이 블로그를 참고하여 client 폴더에 eslint-config-airbnb를 설치해 주었다.</p>\n<p>그런데 이 상태로 yarn start를 하여 react app을 실행해주게 되면 <code>reportWebVitals.js</code> 의 형식에 문제가 있다면서 에러를 뿜고 만다. 내가 만든 파일도 아닌데 에러가 뜬다.</p>\n<p>구글링한 결과 <a href=\"https://stackoverflow.com/questions/64518226/my-create-react-app-is-failing-to-compile-due-to-eslint-error\">https://stackoverflow.com/questions/64518226/my-create-react-app-is-failing-to-compile-due-to-eslint-error</a> 라는 문서가 있었다. 여길 보면 프로젝트 폴더에 <code>.env</code> 파일을 만들고</p>\n<pre><code>ESLINT_NO_DEV_ERRORS=true\n</code></pre>\n<p>를 넣으면 된다고 한다. 그대로 하니까 되었다. 비록 컴파일 시에 경고 메시지는 뜨지만 eslint 를 쓰는 목적은 내가 쓰는 코드의 스타일을 고치는 거지 내가 작성하지도 않은 파일 때문에 컴파일 에러를 내는 것은 아니니까 말이다.</p>\n<p>또한 jsx를 <code>.js</code>형식 파일에서도 쓸 수 있게 하기 위해 <code>.eslintrc.js</code> 에 다음 문구를 추가했다. 나는 리액트를 사용하여 프론트를 짤 것이기 때문에 필수적이다.</p>\n<pre><code class=\"language-json\">rules: {\n    'react/jsx-filename-extension': [2, { extensions: ['.js', '.jsx', '.ts', '.tsx'] }],\n  }\n</code></pre>\n<p>그리고 페이지 분할을 위해 리액트 라우터를 설치해 주자.</p>\n<pre><code>yarn add react-router-dom\n</code></pre>\n<p>리액트 라우터에 대한 내용은 <a href=\"https://velog.io/@pkbird/React-Router-1\">https://velog.io/@pkbird/React-Router-1</a> 이 블로그를 참고하면서 개발한다.</p>\n<p>그리고  스타일링을 위해 styled-components를 설치해 준다.</p>\n<pre><code>yarn add styled-components\n</code></pre>\n<h1>2. 프로젝트의 구성 - 서버</h1>\n<p>이제 server 폴더를 세팅해 주도록 하자. 기본적인 Express 정도만 설치해 줄 것이다.</p>\n<p>먼저 프로젝트 폴더에 server 폴더를 새로 만들자. 그리고 거기에 들어가서 터미널을 열어 express를 설치한다.</p>\n<pre><code>yarn init\nyarn add express\n</code></pre>\n<p><a href=\"https://velog.io/@ohzzi/Node.js-%EC%97%90%EC%84%9C-importexport-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\">https://velog.io/@ohzzi/Node.js-%EC%97%90%EC%84%9C-importexport-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0</a></p>\n<p>위 글의 내용을 참고하여 node.js에서 import를 사용할 수 있게 한 후 다음과 같은 간단한 예제 코드를 실행해 본다.</p>\n<pre><code class=\"language-jsx\">import express from 'express';\n\nconst app=express();\nconst PORT=3000;\n\napp.get('/', (req, res) => {\n  res.send('Hello World!')\n})\n\napp.listen(PORT, () => {\n  console.log(`Example app listening at http://localhost:${PORT}`)\n})\n</code></pre>\n<p><code>node index.js</code> 로 실행시켜 보면 실행이 잘 되는 걸 확인할 수 있다. <code>localhost:3000</code> 으로 접속하면 <code>Hello World!</code> 가 출력되는 아주 단순한 페이지가 나온다.</p>\n<p>여기에도 eslint-config-airbnb를 적용할 수 있는데 이건 나중에 서버를 작업할 때 할 것이다. 먼저 프론트부터 작업할 것이다. 이제 메모장 프론트 작업을 시작하자. 눈에 바로바로 보이는 작업을 하는 것은 언제나 즐겁다.</p>",
    "excerpt": "1. 프로젝트의 구성 - 클라이언트\n프론트를 담당할 client 폴더와 백을 담당할 server 폴더를 따로 분리해서 서로간에 정보를 주고받는 식으로 프로젝트를 구성하려고 한다. 이때 node_modules는 하나로 관리하는 게 좋으므로 모노레포로 구성해 주고자 했다.\n먼저 프로젝트 폴더 내에 yarn init을 한 후 package.json 에 workspace를 편집해 준다. 프로젝트를 모노레포로 구성하기 위해서이다.\n{\n  \"name\": \"memo-jang",
    "headingTree": [
      {
        "title": "1. 프로젝트의 구성 - 클라이언트",
        "url": "#1-프로젝트의-구성---클라이언트",
        "items": []
      },
      {
        "title": "2. 프로젝트의 구성 - 서버",
        "url": "#2-프로젝트의-구성---서버",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 192
    },
    "url": "/posts/memo-project-2",
    "thumbnail": {
      "local": "/thumbnails/memo-project-2-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-memo-project-2-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAkElEQVR4nC2LMQrDIBRAPUAO4v5HN++Q/UOmnEAQnDIJ3qGE2KGD8FeP4ObkWmiTdHTLFLDQ9K3vPWaMAYBhGIQQ4zgiopSSc86IqO97AOi6TmstpUwp5ZxZjBERlVLOuWma5nluP1hKyVrrvQ8heO9rra218zzZ8/Vet+2z78dxXO3/uD/CbVmIqJRytZf4ArUTX9Quo2OBAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "memo-project-3",
    "title": "메모장 만들기 프로젝트 - 3. 메모장 페이지 기본 만들기",
    "date": "2021-08-30T00:00:00Z",
    "description": "웹 메모장 프로젝트, 그 삽질의 기록3",
    "tags": [
      "web",
      "react"
    ],
    "html": "<h1>1. 시작</h1>\n<p>우리가 만들어야 할 페이지는 현재 설계로는</p>\n<ol>\n<li>메모장 페이지</li>\n<li>로그인 페이지</li>\n<li>회원가입 페이지</li>\n</ol>\n<p>정도가 있다. 아무래도 이 프로젝트의 목적은 회원별로 관리되는 \"메모장\"을 만드는 것이므로 메모장 페이지를 가장 처음으로 만들고자 한다.</p>\n<p>먼저 나는 부드러운 느낌을 주는 색을 좋아하므로 그쪽 계열의 색을 이용해 작업할 것이다. 색을 고를 때는 주로 <a href=\"https://yeun.github.io/open-color/\">open color</a> 를 참고한다. 그러나 나는 디자인 전문가도 아니고, 아주 미려한 디자인을 목표로 하는 프로젝트도 아니므로 내 눈에 아주 거슬리지 않을 정도로만 작업하려고 한다.</p>\n<p>만약 누군가 이 프로젝트를 본다면, 내가 쓴 색이 전혀 부드러워 보이지 않을 수도 있고 내 디자인이 마음에 들지 않을지도 모른다. 따라서 만약 디자인에 대한 대안이 있다면 언제나 지적해 주면 좋을 것 같다. 또한 이런 색 선정에 어떤 업계 표준이 있다면 댓글이나 메일 등으로 내게 알려준다면 정말 감사할 것이다.</p>\n<p>먼저 아주 기본적인 배경만 넣어 보자. <code>src/note.js</code> 를 새로 생성한다.</p>\n<pre><code class=\"language-jsx\">//note.js\nimport React from 'react';\n\nconst Note = () => (\n  &#x3C;>\n    &#x3C;h1>메모장 페이지입니다&#x3C;/h1>\n  &#x3C;/>\n);\n\nexport default Note;\n\n</code></pre>\n<p>이 컴포넌트는 아직 간단한 텍스트 한 줄을 띄우는 것 뿐이다. 참고로 <code>&#x3C;></code> 이 빈 태그는 React.Fragment의 축약형으로 여러 태그들을 하나로 묶는 기능만 하고 싶을 때 자주 쓰인다. <code>&#x3C;div></code>로 묶을 수도 있지만 <code>&#x3C;div></code>를 쓰면 태그의 깊이가 하나 더 늘어나 버린다는 단점이 있어서 <code>&#x3C;></code> 를 사용하였다.</p>\n<p>이제 이 텍스트를 홈 페이지에 띄우고, 배경을 넣어주도록 하자. <code>src/App.js</code> 로 향한다.</p>\n<pre><code class=\"language-jsx\">//App.js\nimport React from 'react';\nimport { Route } from 'react-router-dom';\nimport { createGlobalStyle } from 'styled-components';\nimport Note from './note';\n\nconst NoteGlobalStyle = createGlobalStyle`\n  body{\n    background:#e3fafc\n  }\n`;\n\nfunction App() {\n  return (\n    &#x3C;div>\n      &#x3C;NoteGlobalStyle />\n      &#x3C;Route path=\"/\" component={Note} />\n    &#x3C;/div>\n  );\n}\n\nexport default App;\n\n</code></pre>\n<p><code>createGlobalStyle</code> 은 styled-components 에서 body와 같은, 모든 곳에 적용되는 스타일을 지정하고 싶을 때 쓰는 키워드이다. 이걸로 아주 연한 cyan 색의 배경을 페이지 전체에 설정해 줄 수 있다.</p>\n<p>그리고 홈 페이지(<code>/</code> 경로)에는 Note 컴포넌트를 띄워 주도록 설정하였다. 이대로 <code>yarn start</code>를  실행하면 연한 cyan 색 배경에 <code>메모장 페이지입니다</code> 라는 굵은 글씨가 뜬 페이지가 뜰 것이다.</p>\n<p>이때 주의해 줄 점은 <code>yarn start</code>를 통해 실행되는 index.js에서도 React Router를 쓸 수 있도록 설정해 줘야 한다는 것이다.</p>\n<pre><code class=\"language-jsx\">import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport { BrowserRouter } from 'react-router-dom';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\n// BrowserRouter 사용을 설정한 index.js\n\nReactDOM.render(\n  &#x3C;React.StrictMode>\n    &#x3C;BrowserRouter>\n      &#x3C;App />\n    &#x3C;/BrowserRouter>\n  &#x3C;/React.StrictMode>,\n  document.getElementById('root'),\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n\n</code></pre>\n<h1>2. 메모장의 기본 레이아웃 만들기</h1>\n<h2>2.1 버튼 만들기</h2>\n<p>먼저 노트에 쓰일 기본적인 블럭을 만들어 준다. 내부를 가운데 정렬해 주고 폰트를 흰색으로 칠해 주는 등 기본적인 디자인을 넣어주고 모서리를 적당히 둥글게 만들어서 모양을 다듬는다. 그리고 색을 props로 넣어줄 수 있는 기능 정도를 추가한다.</p>\n<p>노트에 쓰일 버튼들은 이 <code>NoteBasicBlock</code> 의 디자인을 상속해서 만들어질 것이다.</p>\n<pre><code class=\"language-css\">const NoteBasicBlock = styled.div`\n  background: ${(props) => props.color || 'white'};\n  color:white;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  border-radius: 10px;\n  font-size:1rem;\n`;\n</code></pre>\n<p>이제 노트 추가, 삭제를 위한 버튼을 만들 것인데 이건 그저 위의 블럭을 상속해서 크기만 지정해 주면 된다. 추가적으로 margin을 좀 주는 정도.</p>\n<pre><code class=\"language-css\">const NoteListButton = styled(NoteBasicBlock)`\n  width:8rem;\n  height:2.5rem;\n  margin:5px;\n`;\n</code></pre>\n<p>그럼 이제 이를 이용해서 노트 추가, 삭제를 위한 버튼을 쉽게 만들어줄 수 있다.</p>\n<p>간단히 이를 이용해서 버튼을 만들어 준 후 임시로 flex 컨테이너를 만들어서 배치해 주었다.</p>\n<pre><code class=\"language-jsx\">//App.js\nimport React from 'react';\nimport styled from 'styled-components';\n\nconst FlexContainer = styled.div`\n  display:flex;\n`;\n\nconst NoteContainer = styled(FlexContainer)`\n  height:100%;\n  width:100%;\n`;\n\nconst NoteBasicBlock = styled.div`\n  background: ${(props) => props.color || 'white'};\n  color:white;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  border-radius: 10px;\n  font-size:1rem;\n`;\n\nconst NoteListButton = styled(NoteBasicBlock)`\n  width:8rem;\n  height:2.5rem;\n  margin:5px;\n`;\n\nconst Note = () => (\n  &#x3C;>\n    &#x3C;NoteContainer>\n      &#x3C;NoteListButton color=\"#b197fc\">노트 추가&#x3C;/NoteListButton>\n      &#x3C;NoteListButton color=\"#ff6b6b\">노트 삭제&#x3C;/NoteListButton>\n    &#x3C;/NoteContainer>\n  &#x3C;/>\n);\n\nexport default Note;\n\n</code></pre>\n<p>이대로 App.js를 바꿔준 후 <code>yarn start</code> 로 프로젝트를 실행하면 연한 청색 화면에 두 개의 버튼이 떠오를 것이다.</p>\n<p>앞으로 눈에 거슬리지 않을 정도로만 조화를 맞추면서 개별적인 색이나 작은 사이즈 변경 정도는 있을 수 있다. 다만 커다란 어떤 설계상의 변경이 있다면 이전 글로 돌아와서 그 부분도 수정할 것이다. 가령 상속 관계가 바뀐다거나 하는 것들 말이다. 아주 탄탄한 설계를 하고 시작하는 프로젝트가 아니기 때문에 설계도 조금씩 바뀔 수 있다.</p>\n<p><img src=\"/static/button-804594af.png\" alt=\"button\"></p>\n<p>텍스트에 써 있는 대로, 이 버튼을 통해 노트 추가/삭제가 가능하도록 할 것이다. 하지만 레이아웃을 위한 디자인을 모두 구성할 때까지 이런 기능 구현은 잠시 미뤄 두도록 하자.</p>\n<h3>2.1.1 버튼 hover 옵션 넣기</h3>\n<p>우리가 일반적인 프로그램들에서 볼 수 있는 버튼들은 보통 마우스를 올리면 색이 조금 진해지거나 연해지는 방식으로 현재 버튼이 활성 직전의 상태라는 걸 나타낸다. 비슷한 원리로 버튼이 어떤 기능을 켜고 끄는 역할을 담당할 경우 활성 상태일 경우와 비활성 상태일 경우를 색깔로 나타내 주기도 한다.</p>\n<p>이는 css의 hover, active 의사 클래스를 통해서 나타내 줄 수 있다. 그런데 노트를 추가하고 삭제하는 기능은 어떤 활성/비활성 상태가 있는 게 아니라 한번 클릭하면 바로 실행되는 어떤 동작을 하는 것이다. 따라서 굳이 active 옵션을 넣지 않고, 마우스를 올렸을 경우(hover)만 색을 진하게 해 주기로 했다.</p>\n<p>그런데 우리는 아까 <code>props</code>로 색을 받아서 그걸 버튼의 색으로 삼았다. 따라서 버튼의 색은 사용자가 지정하는 어떤 색이든 될 수 있다. 그러면 버튼의 색이 진해지고 밝아지는 것도 직접 색을 하나하나 지정하기보다는 좀더 일반적인 처리가 가능하면 좋을 것이다. 이를 위해 <code>polished</code> 라이브러리를 사용해 주자.</p>\n<pre><code>yarn add polished\n</code></pre>\n<p>그리고 우리가 쓸 기능들을 import해 주자.</p>\n<pre><code class=\"language-jsx\">import styled, { css } from 'styled-components';\nimport { darken } from 'polished';\n</code></pre>\n<p>그리고 hover 조건이 만족될 경우에, props의 color를 받아서 일정 비율만큼 darken 해 주는 간단한 css를 리턴하는 익명 함수의 코드를 추가해 준다.</p>\n<pre><code class=\"language-jsx\">const NoteListButton = styled(NoteBasicBlock)`\n  width:8rem;\n  height:2.5rem;\n  margin:5px;\n  ${(props) => {\n    const selected = props.color;\n    return css`\n      &#x26;:hover {\n        background: ${darken(0.1, selected)};\n      }\n    `;\n  }\n}\n`;\n</code></pre>\n<p>이렇게 하면 마우스를 올렸을 경우 버튼이 기존보다 좀 진해진 색깔로 변하게 된다.</p>\n<h2>2.2 개별 메모장 블럭 만들기</h2>\n<p>설계상으로는, 저 노트 추가/삭제 버튼 밑으로 개별 메모들의 미리보기들이 쭉 늘어져 있고 몇몇 메모를 묶어서 폴더로 관리할 수도 있도록 하고 싶다.일단은 개별 메모들의 미리보기를 관리하기 위한 블럭을 디자인하고자 한다. 아까 만들었던 <code>NoteBasicBlock</code> 을 활용하자.</p>\n<pre><code class=\"language-css\">const NoteListBlock = styled(NoteBasicBlock)`\n  width:18rem;\n  height:2.5rem;\n  border:solid 1px #868e96;\n  background:#f1f3f5;\n  margin:3px;\n`;\n</code></pre>\n<p>이제 이를 시험삼아 몇 개 배치해 보면 잘 되는 것을 확인할 수 있다.</p>\n<pre><code class=\"language-jsx\">const Note = () => (\n  &#x3C;>\n    &#x3C;Noteontainer>\n      &#x3C;NoteListButton color=\"#b197fc\">노트 추가&#x3C;/NoteListButton>\n      &#x3C;NoteListButton color=\"#ff6b6b\">노트 삭제&#x3C;/NoteListButton>\n    &#x3C;/NoteContainer>\n    &#x3C;NoteListBlock />\n    &#x3C;NoteListBlock />\n    &#x3C;NoteListBlock />\n  &#x3C;/>\n);\n</code></pre>\n<p><img src=\"/static/memo_test-5aa0ed02.png\" alt=\"memo_test\"></p>\n<h2>2.3 노트 편집 창 만들기</h2>\n<p>노트의 텍스트를 편집하는 칸을 만들어 준다. 노트의 편집창은 워낙 크므로, 화면에 대비해 적당히 비율을 맞춰 주자.</p>\n<p>메모장에는 줄이 있는 게 보기 편하므로 적절한 간격의 줄도 넣어 준다.</p>\n<pre><code class=\"language-css\">const NoteEditBlock = styled.textarea`\n  width:95%;\n  height:95%;\n  border: 1px solid black;\n  border-radius: 10px;\n  overflow:auto;\n  white-space: pre;\n  font-size:12pt;\n  display:flex;\n  background-attachment: local;\n  background-image:\n    linear-gradient(to right, white 10px, transparent 10px),\n    linear-gradient(to left, white 10px, transparent 10px),\n    repeating-linear-gradient(white, white 30px, #ccc 30px, #ccc 31px, white 31px);\n  line-height: 31px;\n  padding: 8px 10px;\n  resize:none;\n`;\n</code></pre>\n<p>그런데 문제가 있다. 우리가 만든 이 텍스트 편집 영역은 우리가 width와 height를 모두 최대로 해 놓았지만 이 최대는 부모가 되는 요소의 width와 height에 영향을 받는다. 만약 이 영역의 부모 요소가 가로세로 10픽셀에 불과하다면, 우리는 width, height를 모두 상대적으로 정의했기 때문에 우리가 너비와 높이를 아무리 100% 로 지정해도 우리가 원하는 대로 여유 공간을 모두 차지해 주는 일은 일어나지 않는다.</p>\n<p>따라서 개발자 도구를 이용해서 이 영역의 확장을 막는 부분들을 모두 넓혀 줘야 한다.</p>\n<p>먼저 <code>GlobalStyle</code> 에서, 일반적인 html의 최상단 컴포넌트인 html과 body의 width, height를 모두 최대로 지정해 준다.</p>\n<pre><code class=\"language-jsx\">const NoteGlobalStyle = createGlobalStyle`\n  *{\n    box-sizing: border-box;\n  }\n  html{\n    width:100%;\n    height:100%;\n  }\n  body{\n    width:100%;\n    height:100%;\n    background:#e3fafc;\n  }\n`;\n</code></pre>\n<p>box-sizing은 영역의 넓이 확장에 관련된 부분은 아니고, 요소의 크기를 따질 때 border까지 넣어서 따지도록 해주는 옵션이다. 요소들의 배치를 계산할 때 좀더 직관적으로 계산할 수 있도록 해 준다. 우리가 요소의 크기를 계산할 때는 보통 테두리까지 넣어서 생각하기 때문이다.</p>\n<p>그 다음에는, 원래 react는 <code>root</code> 라는 아이디를 가진 html 요소에 모든 내용물을 넣어서 렌더링하는데 이 부분을 바꿔 줘야 한다. 이 부분이 우리가 만들고 있는 영역의 넓이를 제한하고 있기 때문이다.</p>\n<pre><code class=\"language-jsx\">// public/index.html의 body 부분\n&#x3C;body>\n    &#x3C;noscript>You need to enable JavaScript to run this app.&#x3C;/noscript>\n    &#x3C;div style=\"width:100%; height:100%;\" id=\"root\">&#x3C;/div>\n    &#x3C;!--\n      This HTML file is a template.\n      If you open it directly in the browser, you will see an empty page.\n\n      You can add webfonts, meta tags, or analytics to this file.\n      The build step will place the bundled scripts into the &#x3C;body> tag.\n\n      To begin the development, run `npm start` or `yarn start`.\n      To create a production bundle, use `npm run build` or `yarn build`.\n    -->\n  &#x3C;/body>\n</code></pre>\n<p>그리고 요소들을 더 잘 배치하기 위해 컨테이너도 바꿔 준다. 내부 아이템들이 column 기준으로 쌓이는 <code>ColumnContainer</code> (즉 열은 하나이고 그 열 내부에 요소들이 세로 방향으로 쌓이는 것) 와 row기준으로 쌓이는 <code>RowContainer</code> (행은 하나이고 그 행 내부에 요소들이 가로 방향으로 쌓이는 것)를 만들어 주었다. 이때 width와 height는 컨테이너에 따라 달라질 수 있으므로 props로 줄 수 있도록 했다.</p>\n<pre><code class=\"language-jsx\">const FlexContainer = styled.div`\n  display:flex;\n`;\n\nconst ColumnContainer = styled(FlexContainer)`\n  height: ${(props) => props.height || 'auto'};\n  width: ${(props) => props.width || 'auto'};\n  flex-direction: column;\n`;\n\nconst RowContainer = styled(FlexContainer)`\n  height: ${(props) => props.height || 'auto'};\n  width: ${(props) => props.width || 'auto'};\n  flex-direction: row;\n`;\n</code></pre>\n<p>이제 컨테이너들을 이용해서 <code>Note</code> 컴포넌트 안에 지금까지 만든 요소들을 적절히 배치해 주면 된다.</p>\n<pre><code class=\"language-jsx\">const Note = () => (\n  &#x3C;ColumnContainer width=\"100%\" height=\"100%\">\n    &#x3C;RowContainer>\n      &#x3C;NoteListButton color=\"#b197fc\">노트 추가&#x3C;/NoteListButton>\n      &#x3C;NoteListButton color=\"#ff6b6b\">노트 삭제&#x3C;/NoteListButton>\n    &#x3C;/RowContainer>\n    &#x3C;RowContainer width=\"100%\" height=\"100%\">\n      &#x3C;ColumnContainer>\n        &#x3C;NoteListBlock />\n        &#x3C;NoteListBlock />\n        &#x3C;NoteListBlock />\n      &#x3C;/ColumnContainer>\n      &#x3C;ColumnContainer width=\"100%\" height=\"100%\">\n        &#x3C;NoteEditBlock />\n      &#x3C;/ColumnContainer>\n    &#x3C;/RowContainer>\n  &#x3C;/ColumnContainer>\n);\n</code></pre>\n<p>이 상태로 실행하면, 아직 고쳐야 할 게 많긴 하지만 적당히 메모장 같아 보이는 화면 구성은 완성된다. 마지막으로 <code>note.js</code>의 전체 코드를 첨부한다.</p>\n<pre><code class=\"language-jsx\">import React from 'react';\nimport styled, { css } from 'styled-components';\nimport { darken } from 'polished';\n\nconst FlexContainer = styled.div`\n  display:flex;\n`;\n\nconst ColumnContainer = styled(FlexContainer)`\n  height: ${(props) => props.height || 'auto'};\n  width: ${(props) => props.width || 'auto'};\n  flex-direction: column;\n`;\n\nconst RowContainer = styled(FlexContainer)`\n  height: ${(props) => props.height || 'auto'};\n  width: ${(props) => props.width || 'auto'};\n  flex-direction: row;\n`;\n\nconst NoteBasicBlock = styled.div`\n  background: ${(props) => props.color || 'white'};\n  color:white;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  border-radius: 10px;\n  font-size:1rem;\n`;\n\nconst NoteListButton = styled(NoteBasicBlock)`\n  width:8rem;\n  height:2.5rem;\n  margin:5px;\n  ${(props) => {\n    const selected = props.color;\n    return css`\n      &#x26;:hover {\n        background: ${darken(0.1, selected)};\n      }\n    `;\n  }\n}\n`;\n\nconst NoteListBlock = styled(NoteBasicBlock)`\n  width:18rem;\n  height:2.5rem;\n  border:solid 1px #868e96;\n  background:#f1f3f5;\n  margin:3px;\n`;\n\nconst NoteEditBlock = styled.textarea`\n  width:95%;\n  height:95%;\n  border: 1px solid black;\n  border-radius: 10px;\n  overflow:auto;\n  white-space: pre;\n  font-size:12pt;\n  display:flex;\n  background-attachment: local;\n  background-image:\n    linear-gradient(to right, white 10px, transparent 10px),\n    linear-gradient(to left, white 10px, transparent 10px),\n    repeating-linear-gradient(white, white 30px, #ccc 30px, #ccc 31px, white 31px);\n  line-height: 31px;\n  padding: 8px 10px;\n  resize:none;\n`;\n\nconst Note = () => (\n  &#x3C;ColumnContainer width=\"100%\" height=\"100%\">\n    &#x3C;RowContainer>\n      &#x3C;NoteListButton color=\"#b197fc\">노트 추가&#x3C;/NoteListButton>\n      &#x3C;NoteListButton color=\"#ff6b6b\">노트 삭제&#x3C;/NoteListButton>\n    &#x3C;/RowContainer>\n    &#x3C;RowContainer width=\"100%\" height=\"100%\">\n      &#x3C;ColumnContainer>\n        &#x3C;NoteListBlock />\n        &#x3C;NoteListBlock />\n        &#x3C;NoteListBlock />\n      &#x3C;/ColumnContainer>\n      &#x3C;ColumnContainer width=\"100%\" height=\"100%\">\n        &#x3C;NoteEditBlock />\n      &#x3C;/ColumnContainer>\n    &#x3C;/RowContainer>\n  &#x3C;/ColumnContainer>\n);\n\nexport default Note;\n\n</code></pre>\n<p>일단 먼저 각 페이지의 뼈대를 잡고 나서 구체적인 부분들을 고치려고 하므로 다음으로는 로그인 페이지를 만들어 볼 것이다.</p>",
    "excerpt": "1. 시작\n우리가 만들어야 할 페이지는 현재 설계로는\n\n메모장 페이지\n로그인 페이지\n회원가입 페이지\n\n정도가 있다. 아무래도 이 프로젝트의 목적은 회원별로 관리되는 \"메모장\"을 만드는 것이므로 메모장 페이지를 가장 처음으로 만들고자 한다.\n먼저 나는 부드러운 느낌을 주는 색을 좋아하므로 그쪽 계열의 색을 이용해 작업할 것이다. 색을 고를 때는 주로 open color 를 참고한다. 그러나 나는 디자인 전문가도 아니고, 아주 미려한 디자인을 목표로 하는 프로젝트도",
    "headingTree": [
      {
        "title": "1. 시작",
        "url": "#1-시작",
        "items": []
      },
      {
        "title": "2. 메모장의 기본 레이아웃 만들기",
        "url": "#2-메모장의-기본-레이아웃-만들기",
        "items": [
          {
            "title": "2.1 버튼 만들기",
            "url": "#21-버튼-만들기",
            "items": [
              {
                "title": "2.1.1 버튼 hover 옵션 넣기",
                "url": "#211-버튼-hover-옵션-넣기",
                "items": []
              }
            ]
          },
          {
            "title": "2.2 개별 메모장 블럭 만들기",
            "url": "#22-개별-메모장-블럭-만들기",
            "items": []
          },
          {
            "title": "2.3 노트 편집 창 만들기",
            "url": "#23-노트-편집-창-만들기",
            "items": []
          }
        ]
      }
    ],
    "metadata": {
      "readingTime": 3,
      "wordCount": 849
    },
    "url": "/posts/memo-project-3",
    "thumbnail": {
      "local": "/static/button-804594af.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-button-804594af-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAIAAAA8r+mnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAYElEQVR4nGPw82w11S4wNiwK1Iq0Z2BwY2BwYmDYd+QEQ0vPlvKK5WU1K9oqpjd5+XeGRjV6Bx2/dpPhwf//9///f/D//93//6/D0c8/DJc+foOgKx+/Xf74GYKufvsJAK5IP6biJ2rXAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "memo-project-4",
    "title": "메모장 만들기 프로젝트 - 4. 로그인 페이지 기본 만들기",
    "date": "2021-09-04T00:00:00Z",
    "description": "웹 메모장 프로젝트, 그 삽질의 기록4",
    "tags": [
      "react",
      "web"
    ],
    "html": "<h1>1. 페이지 라우터 설정</h1>\n<p>로그인 페이지를 제작하기 전에 먼저 로그인 페이지가 들어갈 주소를 만들어 줘야 한다. 개별 페이지에서 조건부 렌더링을 해 주는 게 아니고 회원가입 페이지 - 로그인 페이지 - 메모장 페이지 이 3개를 각각 다른 주소에서 라우팅되도록 하려고 하므로 이는 필수적이다.</p>\n<p>먼저 로그인 페이지를 라우팅해줄 주소에 들어갈 페이지를 간단하게 만들자. client/src 폴더에 <code>login.js</code> 를 생성하자.</p>\n<pre><code class=\"language-jsx\">//src/login.js\nimport React from 'react';\n\nconst Login = () => (\n  &#x3C;h1>로그인 페이지입니다&#x3C;/h1>\n);\n\nexport default Login;\n\n</code></pre>\n<p>그리고 client/src/App.js의 라우팅 경로에 <code>/login</code> 을 추가해 준다. 하는 김에 아까 <code>Note</code> 컴포넌트를 홈 페이지에서 뜨도록 한 것도 <code>/memo</code> 경로에서 뜨도록 바꿔 주자.</p>\n<pre><code class=\"language-jsx\">//App 컴포넌트\nfunction App() {\n  return (\n    &#x3C;>\n      &#x3C;NoteGlobalStyle />\n      &#x3C;Route path=\"/memo\" component={Note} exact />\n      &#x3C;Route path=\"/login\" component={Login} exact />\n    &#x3C;/>\n  );\n}\n</code></pre>\n<p>참고로 Route 컴포넌트의 exact 옵션은 '정확히' 그 경로일 때만 우리가 지정한 컴포넌트를 보여주게 하는 옵션이다. 그렇지 않으면 그걸 포함하는 모든 경로에서 저 컴포넌트를 띄워 준다. 가령 <code>\"/\"</code> 경로에 지정한 컴포넌트가 있다면 <code>/login</code> 경로에서도 뜬다. <code>/login</code>은 <code>/</code> 를 포함하기 때문이다.</p>\n<p>이 상태로 <code>yarn start</code> 를 실행하면 <code>http://localhost:3000/memo</code> 에서 <code>Note</code> 컴포넌트에 만들어 둔 메모장이, 또 <code>http://localhost:3000/login</code> 에서는 <code>Login</code> 컴포넌트에 넣어 둔 간단한 텍스트가 뜨게 된다. 이제 우리가 할 것은 <code>Login</code> 컴포넌트에 실제 로그인 페이지 레이아웃이 들어가도록 하는 것이다.</p>\n<h1>2. 로그인 페이지 컴포넌트 작업</h1>\n<h2>2.0 컨테이너 사용하기</h2>\n<p>로그인 페이지 작업을 시작하기 전에 먼저 아까 만든 컨테이너들을 재사용할 수 있도록 따로 파일로 분리하자. <code>src/container.js</code> 를 생성한다. 그리고 아까 만들었던 컨테이너들을 이곳으로 옮겨 주자.</p>\n<pre><code class=\"language-jsx\">//container.js\nimport styled from 'styled-components';\n\nconst FlexContainer = styled.div`\n  display:flex;\n`;\n\nconst ColumnContainer = styled(FlexContainer)`\n  height: ${(props) => props.height || 'auto'};\n  width: ${(props) => props.width || 'auto'};\n  flex-direction: column;\n`;\n\nconst RowContainer = styled(FlexContainer)`\n  height: ${(props) => props.height || 'auto'};\n  width: ${(props) => props.width || 'auto'};\n  flex-direction: row;\n`;\n\nexport { FlexContainer, ColumnContainer, RowContainer };\n\n</code></pre>\n<p>물론 note.js에서는 <code>ColumnContainer, RowContainer</code> 를 import 해줘야 한다.</p>\n<h2>2.1 아이디/비밀번호 창 넣기</h2>\n<p>로그인 페이지에는 사실 대단한 무언가가 없다. 아이디와 비밀번호를 입력할 창 2개와 제출 버튼만 있으면 사실 더 필요한 것은 없다. 따라서 일단 가장 필수적인 입력창과 제출 버튼부터 만들자. 그 다음에 조금 꾸며 볼 것이다.</p>\n<p>input tag를 조금 고쳐서 기본적인 input보다 좀 큼지막한 입력창을 만들자. 알아보기 쉬우라고 매우 크게 만들었다. 추후 조금 조정될 수도 있다.</p>\n<pre><code class=\"language-jsx\">const UserInput = styled.input`\n  width:20rem;\n  height:3rem;\n  margin:5px;\n  font-size: 1.5rem;\n`;\n</code></pre>",
    "excerpt": "1. 페이지 라우터 설정\n로그인 페이지를 제작하기 전에 먼저 로그인 페이지가 들어갈 주소를 만들어 줘야 한다. 개별 페이지에서 조건부 렌더링을 해 주는 게 아니고 회원가입 페이지 - 로그인 페이지 - 메모장 페이지 이 3개를 각각 다른 주소에서 라우팅되도록 하려고 하므로 이는 필수적이다.\n먼저 로그인 페이지를 라우팅해줄 주소에 들어갈 페이지를 간단하게 만들자. client/src 폴더에 login.js 를 생성하자.\n//src/login.js\nimport Rea",
    "headingTree": [
      {
        "title": "1. 페이지 라우터 설정",
        "url": "#1-페이지-라우터-설정",
        "items": []
      },
      {
        "title": "2. 로그인 페이지 컴포넌트 작업",
        "url": "#2-로그인-페이지-컴포넌트-작업",
        "items": [
          {
            "title": "2.0 컨테이너 사용하기",
            "url": "#20-컨테이너-사용하기",
            "items": []
          },
          {
            "title": "2.1 아이디/비밀번호 창 넣기",
            "url": "#21-아이디비밀번호-창-넣기",
            "items": []
          }
        ]
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 132
    },
    "url": "/posts/memo-project-4",
    "thumbnail": {
      "local": "/thumbnails/memo-project-4-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-memo-project-4-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAmElEQVR4nCXLIQrDMBSA4ecjcolCTVV8ISeIqnrzmckBAjlFL1C2EShrKbNRPUNURCEurio6IoX1lx/8oLVu2xYRGWNKqWEYOOdN08A0TZxzIQQhhFLa933XdYgIWmtCiDEmxhhCSCl574/jgG1dH4jjOM7zfJ5nzrn+g9f7I6V8SqmUstbu+15rLaXAd/sty+KcizHedB8XKXlTWORW79QAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "my-life-map",
    "title": "돌아보며 쓰는 글",
    "date": "2023-11-07T00:00:00Z",
    "description": "삶의 지도",
    "tags": [
      "life"
    ],
    "html": "<h1>시작</h1>\n<p>1학년 때 나는 내가 내 본전공인 기계공학과의 교수가 되는 상상을 하곤 했다.</p>\n<p>높은 학점으로 학교를 졸업하고 석사 학위를 받는다. 정든 친구들과 부모님을 잠시 뒤로하고 먼 미국으로 날아가서 박사과정을 밟는다. 험난한 과정을 어떻게든 이겨내고 열심히 논문을 쓰고 박사후과정을 할 수도 있겠다. 그렇게 오랜 과정을 거쳐서 드디어 교수가 된다.</p>\n<p>첫 강의 날 나는 강의실 문을 열고 들어와서 말한다. \"15년 전 여기 이 자리에 저도 앉아 있었습니다.\" 그리고 강단으로 한 걸음 올라서면서 말한다. \"제가 이 계단 하나를 올라오기까지 15년이 걸렸습니다.\"</p>\n<p>오글거리는 상상이다. 하지만 만약 저렇게 할 수 있다면 멋있을 거라고 지금도 생각한다. 1학년 때는, 저 멋있는 상상을 실현하는 것에 평생을 바치는 게 내 삶에 있어 좋은 답이자 꿈이라고 생각했다.</p>\n<p>그리고 그때 교수가 되는 데 걸리리라 생각했던 15년의 반 가까이가 지나서 지금이 되었다. 난 내가 1학년 때 상상은커녕 그런 게 존재하는지 알지도 못했던 프론트엔드 개발자라는 직업을 갖고 있다.</p>\n<p>솔직히 뭔가 위대한 뜻을 품고 살아서 이렇게 된 건 아니다. 그저 멋진 사람들이 내는 빛을 따라가다 보니 여기까지 왔을 뿐이다. 그들과 함께하며 여기까지 오고 보니 앞으로도 그렇게 살고 싶었다. 또 이런 말에 맞는 사람으로 살려고 했다. 그렇게 보낸 시간이 마치 내가 내린 삶의 답처럼 보였다.</p>\n<h1>기계공학의 시간</h1>\n<p>내 본전공은 기계공학이다. 내 수능 성적으로 선택할 수 있는 가장 좋은 과였다. 또한 그때의 많은 고3들이 그랬듯 나도 내가 점수에 맞춰 간 과를 좋아할 거로 생각했다.</p>\n<p>위에 말했듯 나는 내가 기계공학과 교수가 될 거라고 쉽게 생각했다. 앞으로 더욱 승승장구하며 성공의 사다리를 오를 거라고 당연히 생각한 것이다. 마치 내가 꽤 좋은 수능 점수를 얻고 괜찮은 대학에 왔듯이 말이다. 내 삶이 일차함수 그래프처럼 단조로운 상승 곡선을 그리리라고 믿었다.</p>\n<p>하지만 세상 모든 분야가 그렇듯 기계공학을 잘하기도 좋아하기도 쉽지 않았다. 입학한 지 1년도 되지 않은 새내기가 알 수 있는 건 얼마 없었지만, 내가 상상하던 걸 실제로 이루는 건 정말 어려운 일이라는 것 하나는 쉽게 깨달을 수 있었다. 내가 그 어려운 일을 이루기 위한 뚜렷한 동기부여가 없는 사람이라는 것도 역시 알기 쉬웠다.</p>\n<p>그래서 아무것도 하지 않았다. 무엇을 해야 할지도 몰랐다. 수업에는 그럭저럭 출석했다. 수업을 듣지는 않았다. 시험 기간에는 대세를 따라 도서관에 가기도 했다. 하지만 몇 시간씩 멍하니 있다가 오기 일쑤였다.</p>\n<p>아무 곳에도 흥미도 정도 붙이지 못하고 아는 사람이라고는 거의 없이, 내려가는 학점을 안고 2년이란 시간을 지루하게 흘려보냈다. 그렇게 2학년을 마치고 부모님에게 떠밀려 군대에 갔다.</p>\n<h1>군대의 시간과 프로그래밍의 시작</h1>\n<p>군대는 아무 생각 없이 지내기 참 좋은 곳이었다. 좋아하지 않는 학과도 남은 학기를 어떻게 보낼지 하는 걱정도 진로 고민도 모두 내려놓고 단순하게 살았다. 훈련을 받고 근무를 서고 군복을 빨고 휴가를 나오며 1년이 넘게 지났다.</p>\n<p>그러던 어느 날 누군가가 업무용 컴퓨터에 간단한 매크로를 만들어 놓았다. 이 매크로는 반복적으로 복사-붙여넣기를 하고 하나하나 변환하던 작업을 단축키 한 번에 처리해 주었다.</p>\n<p>알아보니 그걸 만든 사람은 서울대 컴퓨터공학과 출신의 한 후임이었다. 그를 찾아가 어떻게 그런 매크로를 만드냐고 물었고 그는 파이썬이라는 대답을 해주었다. 당시 별로 할 일도 없었던 나는 그가 말한 파이썬을 배우기 시작했다.</p>\n<p>사지방에서 점프 투 파이썬을 떼고, 그 후임과 함께 매크로를 만지작거렸다. 그리고 전역 한 달 전부터 검색하다가 우연히 찾은 <a href=\"https://www.acmicpc.net/\">백준 온라인 저지(이하 백준)</a>라는 사이트에서 문제를 풀기 시작했다. 특별한 알고리즘이 필요 없는 단순한 문제들을 주로 풀었다. 전역할 때쯤은 200문제 정도가 풀려 있었던 걸로 기억한다.</p>\n<h1>알고리즘의 시간</h1>\n<p>전역하고 나니 같이 프로그래밍을 공부할 사람이 없었다. 그래서 2019년, 학교에 있던 알고리즘 학회 <a href=\"https://icpc.team/\">Sogang ICPC Team</a>과 카카오톡 오픈채팅방인 <a href=\"https://bbconf.kr/about/\">'백준푸는방'</a>을 찾아 들어가게 되었다. 사실 커뮤니티의 이름은 그렇게 중요하지 않다. 중요한 건 그곳에서 나를 기다리고 있던 사람들이었다.</p>\n<p>그곳에 들어가자 몇몇 사람들이 마치 무언가에 홀리기라도 한 것처럼 백준을 풀고 있었다. 그들은 매일같이 DP니 네트워크 플로우니 무슨무슨 트리니 하는 이야기를 했다.</p>\n<p>그들은 수업을 듣는 대신 백준을 풀었고 길을 가면서도 문제 생각을 했고 매일같이 자신이 푼 문제를 올리고 서로서로 풀이를 공유했다. 내가 질문을 하면 다들 신이 나서 친절하게 알려주었다.</p>\n<p>얼마 지나지 않아 그들을 직접 만날 기회도 있었다. 그들은 만나서도 백준 푸는 방법을 담은 ppt로 발표했고 백준을 풀었다. 그리고 그들 중 몇몇은 자신은 1조 원이 있어도 백준을 풀 것 같다고 말했다.</p>\n<p>나는 그렇게 무언가에 흥미를 느끼고 스스로 찾아 공부하는 사람들을 만난 게 처음이었다. 그건 내게 아주 큰 충격이었다. 나는 대학에 와서 지금까지 학과 공부는커녕 흥미 있는 것 단 하나도 없었는데, 그게 뭐건 간에 이렇게 열심히 공부하는 사람들이 있다니! 나는 그들이 굉장히 멋있다고 생각했다. 지금도 그게 멋있다고 생각하는 건 마찬가지다.</p>\n<p>그런 사람들과 교류하다가 나는 2020년에 복학했다. 흥미도 아는 사람도 거의 없는 기계공학과가 나를 반겼다. 그런 학교에서 가끔 컴퓨터공학과 사람들과 밥을 먹고 백준을 풀면서, 이럴 거면 컴퓨터공학과에 가고 싶다고 생각했다.</p>\n<p>하지만 그때까지도 나는 쉽게 진로를 틀 수 없었다. 기계공학과는 쉽게 버리기에는 여전히 많은 수요가 있는 전공이었다. 또 학점은 낮았지만 이미 쏟은 시간도 있었다. 그래서 나는 일단 자료구조와 같은 컴퓨터공학과의 기초 과목만 몇 개 들어보기로 했다.</p>\n<h1>병원의 시간</h1>\n<p>2020년 2학기에는 기계공학 과목 5개와 함께 자료구조를 수강했다. 그런데 중간고사가 끝날 즈음부터 갑자기 배가 너무 아팠다. 긴 진료 과정과 여러 검사를 거쳐 나온 진단은 크론병이라는 희귀 난치병이었다. 상태가 매우 좋지 않았기 때문에 즉시 입원했고 곧 수술을 받았다. 휴학도 불가피했다. 고통스러운 시간이었다.</p>\n<p>나는 20대에 '합법적으로' 펜타닐을 맞아 본 얼마 안 되는 사람 중 하나다. 그 당시에도 펜타닐은 신종 마약이라고 뉴스에 심심하면 나오던 약물이었기 때문에 신기해서 그때 찍어 놓았던 사진이다. 아프기는 했지만 이렇게 수술을 받고 병원을 드나드는 것 자체가 20대에 드문 경험이다 보니 왠지 사진을 찍어야겠다는 생각이 드는 이런 순간들이 있었다.</p>\n<p><img src=\"/static/fentanyl-070d4bb4.jpeg\" alt=\"펜타닐\"></p>\n<p>병원에 있는 건 단순히 몸이 아픈 것 이상으로 엄청난 심리적 고통을 줬다. 안 그래도 휴학하고 논 시간 등으로 인해 뒤처졌는데 더욱더 뒤처지지 않았을까 하는 걱정, 앞으로 건강을 지킬 수 있을까 하는 걱정 등등이 밀려왔다.</p>\n<p>특히, 내가 지금까지처럼 제법 건강과 활기를 지키면서 살 수 있는 시간이 얼마 남지 않았을지도 모른다는 느낌이 가장 강렬하게 들었다. 내가 아파서 호출벨을 누르면 달려와서 \"얼마나 아프세요? 1에서 10까지 중에서 말씀해 주세요\"하는 질문을 던지는 신규 간호사들도 나보다 어린데 나는 이렇게 아무 역할도 하지 못하고 누워만 있다는 무력감도 많이 들었다.</p>\n<p>기계공학이 수요가 많든 괜찮은 전공이든 내가 나중에 교수가 되든 그게 정말 중요한가 하는 생각이 문득 들었다. 그간 내가 해왔고 해야 한다고 생각했던 것들의 대부분은 미래를 위해 현재를 희생하는 행동들이었다. 기계공학 전공 공부는 재미가 없지만 취업해야 하니까 하고, 또 취직에 필요한 관련 경험을 쌓기 위해 재미없는 학부연구생을 해야 하고, 그런 것들 말이다.</p>\n<p>하지만 나는 내가 꿈꾸던 미래가 아니라 바로 지금, 이렇게 상상도 못 했던 병에 걸려 아픈 배를 부여잡고 누워 있었다. 앞으로 5년 뒤나 10년 뒤에 무엇이 된들 그게 무슨 상관이고 의미란 말인가? 애초에 진짜 그런 미래가 펼쳐지는 게 확실하기나 하단 말인가? 내가 스물네 살에 병원 침대에 눕게 될 거라고 상상하지 못했듯 어떤 미래가 올지 같은 건 알 수 없다.</p>\n<p>그렇다면 이왕 이렇게 된 거 지금 약간의 단서와 흥미라도 보이는 곳으로 가는 것도 좋지 않을까? 지금까지 쏟은 시간을 아쉬워하며 본전공을 붙잡고 있는 대신 내가 본 멋진 사람들이 가는 길을 따라가 보는 것도 괜찮지 않을까?</p>\n<p>1조 원이 있어도 백준을 풀겠다던 사람들. 자신이 무엇을 하고 싶어하고 무엇을 즐거워하는지 확실히 아는 것 같은 사람들. 자기가 하는 것을 사랑한다고 단 1초도 망설임 없이 말할 수 있는 사람들. 그들은 뭔가를 알지 않을까? 그들과 함께 가면 나도 뭔가 알게 되지 않을까? 먼 미래 같은 건 아무래도 좋고 지금 내게는 이 컴퓨터맨들이 너무 멋있어 보이니까 이들을 따라가 보아도 좋지 않을까?</p>\n<h1>다시 한 번 기계공학의 시간</h1>\n<p>퇴원 후 요양을 끝내고 2021년 1학기에 복학했다. 그리고 바로 컴퓨터공학 복수전공을 시작했다. 그때에는 이미 함께 알고리즘을 하는 지인들도 있었고 학회에서도 충분히 자리를 잡은 상태였다. 여러 사람이 내 복수전공 첫걸음을 환영해 주었다.</p>\n<p>그러나 군대를 다녀오면서 머리를 한번 비워낸 뒤 다시 한 기계공학은 크게 재미는 없었지만 할 만했다. 예전에는 왜 이걸 그렇게 어려워했나 싶어질 정도였다. 이대로 이 전공을 버리기는 아깝다는 생각이 들었다.</p>\n<p>그래서 기계공학과의 로보틱스 연구실에 들어갔다. 컴퓨터공학 복수전공도 좀 살릴 수 있을 것 같았고 이 분야는 조금은 재밌어 보여서 그랬다.</p>\n<p>그 연구실에서 만난 사람들은 어떻게 보아도 멋있고 빛나는 사람들이었다. 나는 내가 새내기 때 혹은 군대에 가기 전에 그 연구실 사람들을 만났다면 어땠을까, 그러면 나는 그 멋진 사람들과 함께 기계공학과에서 행복할 수도 있지 않았을까 하는 상상을 지금도 가끔 하곤 한다.</p>\n<p>교수님은 부임한 지 얼마 안 되어 열정이 넘쳤다. 로보틱스라는 유망한 분야의 연구실답게 같이 있는 대학원생들이나 학부생들도 똑똑하고 연구를 좋아하는 사람들이었다. 또한 나는 창립 멤버라 연구실 선반부터 조립하며 처음부터 함께 시작했다. 그래서 다른 연구실과 달리 텃세 같은 걸 걱정할 일도 없었다. 만약 내가 그 연구실에서 석사를 하겠다고 했다면 교수님과 그때의 동료들은 흔쾌히 받아줬으리라고 확신한다.</p>\n<p>하지만 그런 완벽한 연구실의 유일한 단점이 있었다. 그 공부가 내게는 재미가 없었다는 사실이었다. 열정 넘치고 흥미도 가진 동료들을 억지로 따라가는 시간이었다. 그래서 이 정도로 완벽한 연구실에서조차 내가 흥미를 느낄 수 없다면 기계공학은 정말 내 길이 아닌가 보다 하는 생각을 했다.</p>\n<p>교수님을 찾아가 이런 말씀을 드렸다. 교수님은 카이스트 출신이셨는데 거기서 흥미 없이 마치 정해진 길을 따라가듯이 대학원에 진학했다가 방황하는 사람을 너무 많이 보았다는 이야기를 들려주셨다. 그리고 내가 이 분야에 흥미가 없다는 사실을 빨리 찾은 걸 축하한다고 해주셨다.</p>\n<p>그렇게 나는 기계공학에서 완전히 마음을 떠나보냈다. 이후에도 몇몇 전공과목을 들었고 성적도 나쁘지 않았다. 하지만 더 이상 필수 학점 채우기 이상의 의미를 내게 갖지는 못했다.</p>\n<h1>개발자의 길</h1>\n<p>완전히 컴퓨터공학으로 진로를 변경했다. 학회 사람들을 비롯한 같은 길을 가는 친구들이 내 앞을 밝혀 주었다. 내 동기 부여도 확실했기 때문에 그들과 함께 공부하며 좋은 학점도 받았다. 여기서는 뭔가 답을 얻을 수 있을지도 모르겠다고 생각했다.</p>\n<p>하지만 이제는 정말 진로 생각을 해야 했다. 알고리즘이 재밌어서 알고리즘을 했고 스터디 같은 활동도 많이 했다. <a href=\"https://witch.work/posts/sinchon-camp-2021-summer\">관련해서 2021년에 썼던 알고리즘 대회 회고</a>도 있다. 하지만 사실 그때도 내가 알고리즘의 세계에서 대성할 싹이 아니라는 정도는 감을 잡고 있었다.</p>\n<p>알고리즘을 하면서 알게 된 사람을 한 명 찾아가 솔직하게 물었다. 소위 말하는 '네카라쿠배'에 간 사람이었다.</p>\n<p>'알고리즘이 재밌고 사람들이 좋아서 여기까지 왔다. 하지만 내가 알고리즘 판에서 대성할 사람은 아닌 거 같은데 먹고는 살아야겠고, 나도 높이 가보고 싶은 사람이니까 그 이름 높은 네카라에 가고 싶기도 하다, 어떡하지?'</p>\n<p>그러자 그가 소프트웨어 마에스트로(이하 소마)라는 활동을 추천해 주었다. 일단 여기 지원해 보고 만약 떨어지면 42서울과 싸피에 차례로 지원하라고. 그리고 백엔드가 제일 무난하니까 남은 시간 동안 백엔드를 공부하라고 했다.</p>\n<p>그렇게 2022년 초, 나는 소마에 지원하기까지를 돌아보면서 자기소개를 작성하고 지원했다. 그때의 자기소개가 지금 블로그에서 나를 나타내는 소개가 되었다. 알고리즘 하던 사람들 하나만 보다가 거기까지 도달했었으니 그때 기준으로도 그렇게 틀린 말은 아니었다고 생각한다.</p>\n<p><img src=\"/static/swm-apply-788e14aa.png\" alt=\"소마 지원 당시 자기소개\"></p>\n<blockquote>\n<p>대단한 뜻을 품고 사는 사람은 아닙니다. 그저 멋진 사람들이 내는 빛을 따라가다 보니 여기까지 왔고, 앞으로도 그렇게 살 수 있었으면 좋겠다고 생각하는 사람입니다. 이곳에 찾아오신 당신과도 함께할 수 있어 영광입니다. <code>마녀</code>라는 닉네임을 주로 씁니다.</p>\n<p>지금 내 블로그의 자기소개</p>\n</blockquote>\n<p>알고리즘은 꾸준히 해왔기에 코딩테스트는 수월하게 통과할 수 있었다. 면접도 있는 열정 없는 열정 다 끌어모아 통과했다. 그렇게 소마 13기에 합격했고 2022년 동안 소마 활동을 하면서 나는 백엔드 개발자로서의 첫 발을 내딛었다...고 생각했다. 나는 지금 프론트엔드 개발자가 되어 있다.</p>\n<h1>실패?</h1>\n<p>소마에서는 사회인 밴드 운영을 도와주고 그들 간의 교류를 할 수 있는 플랫폼 사이트를 만들었다. 그 과정에서 어차피 백엔드나 프론트나 모르니까 아무거나 하다 보니 프론트를 맡게 되어버렸다. 그런데 이것이 꽤 재미있었다. 반면 거기서 만난 백엔드들이 하는 것을 보고 나도 비슷한 것을 조금 공부해 보고는 했는데 프론트 역할을 버리고 그쪽으로 갈 만큼 흥미롭지는 않았다. 그렇게 나는 프론트 개발자의 길을 가게 되었다.</p>\n<p><img src=\"/static/bandwagon-1a34a26a.png\" alt=\"당시 만들었던 밴드 사이트의 로고\"></p>\n<p>소마는 사실 내게 있어 그렇게 성공적인 결과물이 남은 시기는 아니다. 팀원들하고는 일 외의 이야기는 잘하지 못했고 지금도 그다지 연락하지 않는다. 크게 싸운 것조차 아니라는 것이 내게 더 큰 실패로 다가온다. 디자인 외주 비용까지 들여가며 작은 사이트를 구성했지만 배포도 금방 내려가 버렸다.</p>\n<p>다만 그 시간은 내게 그런 실패들을 반복하지 않기 위한 생각을 하게 했다. 그 생각들이 자잘하게 내가 몰랐던 빈 부분들을 채워주었지 않았나 한다. 프로젝트 초반에 어떻게 해야 했는지, 그리고 나는 어떤 사람을 찾고 함께했어야 했는지 또 그런 사람들을 가려내고 얻어내는 데 도움을 주는 나만의 기준들은 무엇인지 같은 것들.</p>\n<p>또 내가 원하는 모습의 팀은 뭔지, 소마 프로젝트에 주어진 환경은 꽤 괜찮았는데 대체 무엇이 문제였기에 이렇게 되었는지 같은 것들을 생각했다. 거기에 대한 나름의 결론도 조금씩 내리면서 가치관을 한 번 더 다질 수 있었다. 또 소마라는 느슨하지만 든든한 커뮤니티도 하나 얻어서 언제든 그곳에서 스터디건 뭐건 구할 수 있게 되었다.</p>\n<h1>실패의 영향</h1>\n<p>신기하게 소마 그 자체에서는 많이 남은 게 없었지만 파생 효과로 얻은 건 꽤 많았다. 먼저 지금까지 이어지고 있는 공부 방향을 잡을 수 있었다. 소마 활동 후반에 다른 취준생들과 함께 '네카라쿠배' 중 한 회사에 지원하여 면접을 볼 기회가 있었다. 나는 그때 프론트를 깊이 해보지 않았기 때문에 기껏해야 디자인이 나온 페이지를 겨우겨우 찍어내는 게 전부였다.</p>\n<p>그런데 그 면접에서는 내가 신경도 쓰지 못했던 자바스크립트의 깊은 내용에 대한 질문들이 쉴 새 없이 들어왔다. 1시간 반 동안 털린 나는 당연히 떨어졌고 매우 큰 후회를 느꼈다. 그렇게 바뀐 공부 방향이 기본부터 다지는 것이었고 그 결과가 이 블로그에 썼고 요즘도 쓰고 있는 글들이다.</p>\n<p>또 소마 활동에 대하여 다른 학교에서 발표할 기회를 얻을 수 있었다. 그곳에서 많은 좋은 사람들을 만날 수 있었다. 그때 만난 사람들과는 아직도 교류한다. 같이 스터디를 하기도 하고 자주 생각도 나누곤 한다. 소마 발표를 하다가 오히려 소마에서보다 훨씬 깊은 동료들을 얻을 수 있었다.</p>\n<p>마지막으로 소마를 했던 6개월 동안 인간관계에서의 실패를 많이 겪었기에 어떻게 하면 그러지 않을 수 있을까 하는 생각을 많이 했다. 나름의 대안들을 세웠고 이후에 진행한 스터디나 프로젝트에서는 그 대안들을 적용해 보기도 했다. 그게 어느 정도 먹혀서, 이후에 했던 활동들에서는 활동의 목적 자체는 실패한 것들도 있었지만 언제나 사람들은 남았다.</p>\n<p>지금 생각해 보면 오히려 소마에서 약간의 실패를 함으로써 얻을 수 있었던 게 더 많았던 것 같기도 하다.</p>\n<h1>2022년, 정리</h1>\n<p>2022년에는 여러 대외 활동을 했었다. 소마에서는 프로젝트뿐 아니라 많은 사람과 인사를 나누고 밥을 먹고 스터디를 조직해 이끌었다. 내 첫걸음을 끌어 주었던 알고리즘 학회에서 임원으로 활동했고 신촌지역 대학교들의 알고리즘 동아리들이 모여 만든 연합에서 알고리즘을 가르쳤다. '백준푸는방'에서 정기적으로 여는 세미나에서도 간단한 발표를 했다.</p>\n<p>기존의 나의 모습에 비교했을 때 정말 많은 사람을 만났다. 그러면서 개발자도 결국 사람이고 사람과 함께하는 직업이라는 생각을 하고 굳혀 나갔다. 나는 개발자로서의 실력과 커리어라는 게 정량화되어 있는 것처럼 생각했었다. 마치 내 실력이 100이고 네 실력이 70이면 너는 내 밑이야, 같은 생각을 조금 가지고 있었다. 그래서 나는 한 1000쯤 되는 개발자가 되어서 다 이기고 다녀야지! 하는 생각을 했다.</p>\n<p>하지만 그게 전부는 아니었다. 물론 확실히 표현되는 실력이라는 것이 존재했다(그게 어떤 숫자로 딱 떨어질 수 있는 것은 아니었지만). 하지만 사람을 만나다 보니 한없이 부족한 사람이라도 함께하고 싶어 미칠 것 같은 사람도 있었고, 나에 비해 압도적인 실력을 가졌어도 약간은 꺼려지는 사람도 있었다.</p>\n<p>그러고 보면 내게 너무 멋있어 보였던 컴퓨터공학과 사람들도 누가 봐도 엄청난 실력을 가진 그런 사람들은 아니었다. 그들도 알고리즘을 좋아하는 대학생이거나 평범한 주니어 개발자일 뿐이었다. 나를 단숨에 매료시킨 건 그들의 대단한 실력이 아니라 자신이 하는 것을 사랑하고, 망설임 없이 자기 일을 사랑한다고 말하는 모습이었다.</p>\n<p>나는 그런 빛나는 말들을 따라 여기까지 왔고 대단한 사람들이 아니라 함께하고 싶은 사람들과 함께해 왔으면서도 그걸 머리로는 잊고 있었다. 당장 하고 싶은 일과 보고 싶은 사람들을 찾아가자고 하면서 컴퓨터공학과에 왔으면서, 또 무슨 엘리트코스를 밟아서 엄청난 실력을 가진 사람이 되겠다고 생각하고 있었다. 또 너무 멀리만 보아 버렸다.</p>\n<p>아무도 모르고 아무것도 모르던 기계공학과의 복학생이 컴퓨터공학과 학회 임원이 되었고 알고리즘 강사가 되었고 여러 스터디의 장이 되었다. 그리고 그 길을 함께했던 멋진 사람들이 내 옆에 있었다. 사실 강사니 임원이니 하는 지위 따위는 아무런 의미가 없었다. 내가 보았던 빛나는 그들이 이제는 먼 곳이 아니라 내 옆에 있다. 이제 내가 좇아가야 할 먼 목표 따위는 어디 있는지 모르겠고 그들도 그런 건 모르는 것 같지만 함께하고 있으니 된 거 아닌가.</p>\n<h1>졸업</h1>\n<p>2023년 2월 졸업을 했다. 많은 사람들이 와서 축하를 해주었다. 따로 만난 후배들은 케이크와 편지를 주었다. dart와 city는 내가 백준에서 쓰는 아이디고, 나는 보통 온라인에서 <code>마녀</code>라는 닉네임을 쓴다.</p>\n<p><img src=\"/static/graduate-cake-4f71b786.jpeg\" alt=\"졸업 때 받은 케이크\"></p>\n<p>오래 다닌 학교를 떠난다는 게 아쉽기는 했다. 하지만 몇 년간 이미 함께한 사람들이 있었고, 그들은 내가 졸업한다고 관계가 끊기는 사람들이 아니었다. 그들은 요즘도 나와 가끔 백준 이야기를 한다. 그래서 졸업이 크게 나를 변하게 하지는 않았다. 나는 똑같이 문제를 풀었고 자바스크립트를 공부했고 일기를 쓰곤 하면서 취준을 했다. 지금은 요행히 취업해서 잘 다니고 있다.</p>\n<h1>지금</h1>\n<p>나는 내가 기계공학과 교수가 되리라 생각했다. 그보다 더 예전에는 경제학자를 내 미래로 생각했고 그전에는 판사를 생각했다. 거기까지 가는 시간이 쉬우리라 생각한 적은 한 번도 없다. 하지만 그 어려움에 대한 상상이란 건 아주 막연했다. '어려움이 있겠지만 나는 그걸 힘겹게 극복하고는 목표를 이룰 것이다'정도로 말이다. 마치 나는 결국은 위기를 극복해 내는 소설 주인공이고 닥쳐오는 시련들은 그저 소설의 장치인 것처럼 상상했다. 내가 그 위기를 넘기지 못하거나 위기로 인해 변하거나 하는 건 완전히 내 상상 밖이었다.</p>\n<p>그리고 얼마 지나지 않아 진짜 시간과 거기 담긴 시련이 내게 닥쳤다. 좋은 일도 있고 나쁜 일도 있었다. 남들보다 특별히 더 힘들었다고 생각하지는 않는다. 나는 몇몇 경우에 꽤 운이 좋았다. 그래서 그 시간 중에 박혀 있던 몇몇 위기들은 상대적으로 쉽게 넘길 수도 있었다.</p>\n<p>하지만 좋고 나쁘고를 떠나서, 존재조차도 전혀 상상하지 못한 일을 맞이한다는 것은 나를 나조차도 알 수 없는 방향으로 끌고 갔다. 아니, 이런 병이 세상에 존재해서 나를 이렇게 힘들게 하다니! 아니, 이렇게 멋있어서 따라가지 않고는 못 배길 사람들이 있다니! 그것들을 어떻게든 넘기고 나면 나는 좋든 나쁘든 많이 다른 사람이 되어 있었다.</p>\n<p>그 과정에서 나는 꽤 오랫동안, 내가 어디로 갈지에 대한 답이 있다고 생각했다. 누군가는 그걸 알 거라고 생각했고 무엇인가는 인생의 마스터키 같은 거라 그것만 하면 될 거라 생각하기도 했다. 당연히 그것들은 다 정답이 아니었고 정답 같은 건 아무도 몰랐다. 어쩌면 정답이란 건 없는지도 모른다는 생각을 한다. 하지만 내가 그렇게 답을 찾으면서 지나왔던 시간이 이제는 내가 찾은 답처럼 보였다.</p>\n<p>그리고 이제는 그 답들이 들어 있는 내 주변의 사람들과 함께, 우리의 답이 맞았다는 것을 스스로 세상에 증명하기를 꿈꾼다.</p>",
    "excerpt": "시작\n1학년 때 나는 내가 내 본전공인 기계공학과의 교수가 되는 상상을 하곤 했다.\n높은 학점으로 학교를 졸업하고 석사 학위를 받는다. 정든 친구들과 부모님을 잠시 뒤로하고 먼 미국으로 날아가서 박사과정을 밟는다. 험난한 과정을 어떻게든 이겨내고 열심히 논문을 쓰고 박사후과정을 할 수도 있겠다. 그렇게 오랜 과정을 거쳐서 드디어 교수가 된다.\n첫 강의 날 나는 강의실 문을 열고 들어와서 말한다. \"15년 전 여기 이 자리에 저도 앉아 있었습니다.\" 그리고 강단으",
    "headingTree": [
      {
        "title": "시작",
        "url": "#시작",
        "items": []
      },
      {
        "title": "기계공학의 시간",
        "url": "#기계공학의-시간",
        "items": []
      },
      {
        "title": "군대의 시간과 프로그래밍의 시작",
        "url": "#군대의-시간과-프로그래밍의-시작",
        "items": []
      },
      {
        "title": "알고리즘의 시간",
        "url": "#알고리즘의-시간",
        "items": []
      },
      {
        "title": "병원의 시간",
        "url": "#병원의-시간",
        "items": []
      },
      {
        "title": "다시 한 번 기계공학의 시간",
        "url": "#다시-한-번-기계공학의-시간",
        "items": []
      },
      {
        "title": "개발자의 길",
        "url": "#개발자의-길",
        "items": []
      },
      {
        "title": "실패?",
        "url": "#실패",
        "items": []
      },
      {
        "title": "실패의 영향",
        "url": "#실패의-영향",
        "items": []
      },
      {
        "title": "2022년, 정리",
        "url": "#2022년-정리",
        "items": []
      },
      {
        "title": "졸업",
        "url": "#졸업",
        "items": []
      },
      {
        "title": "지금",
        "url": "#지금",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 7
    },
    "url": "/posts/my-life-map",
    "thumbnail": {
      "local": "/static/fentanyl-070d4bb4.jpeg",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-fentanyl-070d4bb4-jpeg",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAICAIAAABVpBlvAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAo0lEQVR4nAGYAGf/AOjm5tnKwcvRznF2drStoKqgjgDr5+nbzcnd3t6FhoWimo2jmIEA9Pb1+fr46uXkkYaGk4l6o5N4APn6+f77+PLr6rKem5WCdJyMcgDu8O708+/w5uK0nJOjj32fj3IA5ubi9vX16+jkjoZ8X1dKn5J1AIKHgouRi62noGNdUw8EAG1fSAAAJiMAGhYlJyBnV0pfUEEvIgt7lFlFHgCcZwAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "nextjs-13-trouble-1",
    "title": "NextJS metadata 오류 해결",
    "date": "2023-09-13T00:00:00Z",
    "description": "Nextjs 13 마이그레이션 중 메타데이터 문제",
    "tags": [
      "front",
      "blog"
    ],
    "html": "<h1>1. 시작</h1>\n<p>지금 이 블로그는 NextJS 13의 app router로 마이그레이션 중이다. 이 과정은 추후 블로그에 올릴 예정이다. 여기서는 마이그레이션 과정에서 발생한 사소한, 그런데 시간을 꽤 잡아먹었던 문제를 하나 정리한다.</p>\n<p>먼저 앱 라우터로 구성한 페이지 구조는 다음과 같이 짜여 있다.</p>\n<pre><code>app\n├── (doc)\n│   ├── about\n│   │   ├── page.tsx\n│   ├── posts\n│   │   ├── [slug]\n│   │   │   ├── page.tsx\n│   ├── layout.tsx\n├── (page)\n│   ├── posts\n│   │   ├── all\n│   │   │   ├── page.tsx\n│   │   │   ├── [page]\n│   │   │   │   ├── page.tsx\n│   │   ├── tag/[tag]\n│   │   │   ├── page.tsx\n│   │   │   ├── [page]\n│   │   │   │   ├── page.tsx\n│   │   ├── page.tsx\n├── 메인 페이지\n</code></pre>\n<p>그리고 <code>/posts</code>페이지는 검색창이 있는 특성 상 client state 관리가 필요해서 클라이언트 컴포넌트로 관리되고 있었다. 따라서 서버 컴포넌트에서만 쓸 수 있는 <code>generateMetadata</code>와 같은 api들은 사용하지 않았다.</p>\n<p>그런데 뜬금없이 <code>/posts/tag/[tag]/[page]</code>페이지에서 다음과 같은 에러가 발생했다. 해당 페이지는 서버 컴포넌트로 구성되어 있는데도 말이다.</p>\n<pre><code>You are attempting to export \"generateMetadata\" from a component marked with \"use client\", which is disallowed. Either remove the export, or the \"use client\" directive. Read more: https://nextjs.org/docs/getting-started/react-essentials#the-use-client-directive\n</code></pre>\n<p>그래서 문제를 해결해 보려고 여러 시도를 하였는데 그걸 여기 적는다.</p>\n<h1>2. 문제 해결 시도</h1>\n<h2>2.1. 클라이언트 컴포넌트 분리</h2>\n<p><code>generateMetadata</code> api는 서버 사이드에서만 쓰일 수 있다. 그리고 오류 메시지로 추측해 보건대 <code>/posts</code>페이지가 <code>use client</code>모드로 렌더링되는 게 영향을 주는 것이 아닐까 추측하여 이를 먼저 바꾸어 보았다. 지금 <code>/posts</code>페이지 즉 <code>/posts/page.tsx</code>는 다음과 같이 짜여 있다.</p>\n<pre><code class=\"language-tsx\">'use client';\n/* import들 생략 */\nfunction PostSearchPage() {\n  const searchPosts: CardProps[] = getSearchPosts();\n  const [searchKeyword, debouncedKeyword, setSearchKeyword] = useSearchKeyword();\n  const [filteredPostList, setFilteredPostList] = useState&#x3C;CardProps[]>(searchPosts);\n  const [page, setPage] = useState&#x3C;number>(1);\n  const debouncedPage = useDebounce(page.toString(), 300);\n\n  const infiniteScrollRef = useRef&#x3C;HTMLDivElement>(null);\n  const totalPage = Math.ceil(filteredPostList.length / ITEMS_PER_PAGE);\n\n  const onKeywordChange = useCallback((event: ChangeEvent&#x3C;HTMLInputElement>) => {\n    setSearchKeyword(event.target.value);\n  }, [setSearchKeyword]);\n\n  useEffect(() => {\n    setFilteredPostList(filterPostsByKeyword(searchPosts, debouncedKeyword));\n  }, [debouncedKeyword]);\n\n  useInfiniteScroll(infiniteScrollRef, useCallback(()=>{\n    if (page &#x3C; totalPage) {\n      setPage(prev=>prev + 1);\n    }\n  }, [debouncedPage, totalPage]));\n\n  return (\n    &#x3C;>\n      &#x3C;Title heading='h2' size='md'>전체 글 검색&#x3C;/Title>\n      &#x3C;SearchConsole \n        value={searchKeyword}\n        onChange={onKeywordChange}\n      />\n      {filteredPostList.length === 0 ?\n        &#x3C;p>검색 결과가 없습니다.&#x3C;/p> : null\n      }\n      &#x3C;PostList postList={filteredPostList.slice(0, ITEMS_PER_PAGE * page)} />\n      &#x3C;div ref={infiniteScrollRef} />\n    &#x3C;/>\n  );\n}\n</code></pre>\n<p>그래서 <code>useState</code>를 쓰는 것과 같이 클라이언트 렌더링이 필요한 부분을 <code>SearchPageBody</code>와 같은 컴포넌트로 분리하여 <code>pageBody.tsx</code> 파일을 만들었다. 해당 컴포넌트는 <code>use client</code>모드로 렌더링하도록 하였다. 또한 <code>/posts/page.tsx</code>는 서버 사이드 렌더링으로 바꾸었다.</p>\n<pre><code class=\"language-tsx\">// posts/page.tsx\n/* import 생략 */\n\nfunction PostSearchPage() {\n\n  return (\n    &#x3C;>\n      &#x3C;Title heading='h2' size='md'>전체 글 검색&#x3C;/Title>\n      &#x3C;SearchPageBody />\n    &#x3C;/>\n  );\n}\n</code></pre>\n<p>하지만 오류가 여전히 해결되지 않았다.</p>\n<h2>2.2. 라우트 변경해보기</h2>\n<p>오류 메시지를 다시 한번 잘 읽어보자.</p>\n<pre><code>You are attempting to export \"generateMetadata\" from a component marked with \"use client\", which is disallowed. Either remove the export, or the \"use client\" directive. Read more: https://nextjs.org/docs/getting-started/react-essentials#the-use-client-directive\n\n    ,-[/Users/kimsunghyun/Desktop/nextjs-blog/src/app/(page)/posts/tag/[tag]/[page]/page.tsx:86:1]\n 86 |   return paths;\n 87 | }\n 88 | \n 89 | export async function generateMetadata({ params }: Props): Promise&#x3C;Metadata> {\n    :                       ^^^^^^^^^^^^^^^^\n    ...대충 generateMetadata 내용(생략)...\n    `----\n\nFile path:\n  ./src/app/(page)/posts/tag/[tag]/[page]/page.tsx\n  ./src/app/(page)/posts/page.tsx\n</code></pre>\n<p>아래에 보면 File Path라고 해서 어떤 파일에서 문제가 생긴지 알려주는 것 같다. 그리고 오류 메시지도 <code>/posts/tag/[tag]/[page]/page.tsx</code>를 가리키고 있다.</p>\n<p><a href=\"https://nextjs.org/docs/app/building-your-application/optimizing/metadata#ordering\">Nextjs 공식 문서의 optimizing - Metadata - ordering</a>문서를 보면 메타데이터는 루트 세그먼트에서 시작해서 해당 페이지의 <code>page.js</code>에 도달할 때까지 탐색하면서 메타데이터를 생성한다고 한다. 그러면 <code>/posts/tag/[tag]/[page]</code>의 메타데이터를 생성할 때도 <code>/posts</code>라우트를 지날 테고 그래서 오류가 발생하는 것이 아닐까 했다.</p>\n<p>그래서 <code>/posts</code>에서 렌더링하는 컴포넌트를 다른 곳으로 옮겨보았다. <code>/posts/page.tsx</code>를 <code>/search</code>로 바꾸었다. 하지만 그렇게 해도 오류가 뜨는 파일 경로가 <code>./src/app/(page)/search/page.tsx</code>로 바뀔 뿐이었다.</p>\n<p>그런데 보면 해당 파일의 동적 라우트 중 하나에 해당하는 곳, 그러니까 가령 <code>/posts/tag/study/2</code>와 같은 라우트에 접속할 때는 저런 버그가 발생하지 않았다. <code>generateMetadata</code>의 위치도 <code>/posts/tag/[tag]/[page]/page.tsx</code>에 있었는데도 엉뚱한 <code>/posts</code>에서만 버그가 발생하고 있었던 것이다.</p>\n<h2>2.3. import의 문제</h2>\n<p>위와 같은 실험들을 통해서 <code>/posts</code>경로에서 뭔가 <code>/posts/tag/[tag]/[page]</code>에 의존성이 있는 부분이 있다는 추측을 할 수 있었다.</p>\n<p>import들이 정적으로 의존성 그래프를 생성할 때 <code>/posts</code>경로에서 <code>/posts/tag/[tag]/[page]</code>를 참조하고, 거기에는 <code>generateMetadata</code>가 있으니까 마치 <code>/posts</code>에서 <code>generateMetadata</code>를 사용한 것처럼 취급됨에 따라 위와 같은 오류가 뜨는 게 아닐까 했다.</p>\n<p>아니나 다를까, <code>/posts/page.tsx</code>의 import문들을 보니...</p>\n<pre><code class=\"language-tsx\">'use client';\n\nimport { useCallback, ChangeEvent, useEffect, useState, useRef } from 'react';\n\nimport Title from '@/components/atoms/title';\nimport SearchConsole from '@/components/molecules/searchConsole';\nimport { CardProps } from '@/components/organisms/card';\nimport PostList from '@/components/templates/postList';\nimport filterPostsByKeyword from '@/utils/filterPosts';\nimport { getSearchPosts } from '@/utils/post';\nimport { useDebounce } from '@/utils/useDebounce';\nimport { useInfiniteScroll } from '@/utils/useInfiniteScroll';\nimport useSearchKeyword from '@/utils/useSearchKeyword';\n\n/* 이 부분이 문제다 */\nimport { ITEMS_PER_PAGE } from './tag/[tag]/[page]/page';\n\nfunction PostSearchPage() {\n  /* 검색 페이지 컴포넌트 구현 */\n}\n</code></pre>\n<p>따라서 다음 부분을 이렇게 고쳐 주면 문제가 해결된다. 정말 별거 아닌 원인이었다.</p>\n<pre><code class=\"language-tsx\">'use client';\n\n/* 앞선 import문들 생략 */\nimport useSearchKeyword from '@/utils/useSearchKeyword';\n\nconst ITEMS_PER_PAGE = 10;\n\nfunction PostSearchPage() {\n  /* 검색 페이지 컴포넌트 구현 */\n}\n</code></pre>\n<h1>3. 후속조치</h1>\n<p>위에서 수정한 이 <code>ITEMS_PER_PAGE</code>라는 변수는 상당히 많은 곳에서 쓰이고 있으므로 이렇게 파일마다 정의해 주는 건 좋은 선택이 아니다. 따라서 이를 글을 가져오는 함수들이 있는 <code>src/utils/post.ts</code>에 배치시켰다.</p>\n<pre><code class=\"language-ts\">// src/utils/post.ts\n/* 페이지당 몇 개의 글이 보이는가 */\nexport const ITEMS_PER_PAGE = 10;\n/* 첫 번째 페이지 */\nexport const FIRST_PAGE = 1;\n</code></pre>\n<p>그리고 해당 변수를 쓰는 모든 곳의 import 경로를 수정했다. 가령 다음과 같이 말이다.</p>\n<pre><code class=\"language-tsx\">// src/app/(page)/posts/page.tsx\nimport { getSearchPosts, ITEMS_PER_PAGE } from '@/utils/post';\n</code></pre>\n<p>그러자 generateMetadata 관련 오류는 사라졌다. 비슷한 이유로 <code>FIRST_PAGE</code>같은 변수도 <code>src/utils/post.ts</code>에 배치시켰다. 원래는 <code>src/app/(page)/posts/all/page.tsx</code>같은 뜬금없는 곳에 있었다.</p>\n<p>이런 작은 이유로 일어난 버그로 약 2일을 소모하고 나니 작은 변수 하나라도 구조에 맞게 잘 배치하는 것이 중요하다는 것을 다시 한번 느낄 수 있었다.</p>\n<h1>참고</h1>\n<p>Nextjs optimizing metadata 문서 <a href=\"https://nextjs.org/docs/app/building-your-application/optimizing/metadata\">https://nextjs.org/docs/app/building-your-application/optimizing/metadata</a></p>",
    "excerpt": "1. 시작\n지금 이 블로그는 NextJS 13의 app router로 마이그레이션 중이다. 이 과정은 추후 블로그에 올릴 예정이다. 여기서는 마이그레이션 과정에서 발생한 사소한, 그런데 시간을 꽤 잡아먹었던 문제를 하나 정리한다.\n먼저 앱 라우터로 구성한 페이지 구조는 다음과 같이 짜여 있다.\napp\n├── (doc)\n│   ├── about\n│   │   ├── page.tsx\n│   ├── posts\n│   │   ├── [slug]\n│   │   │   ├",
    "headingTree": [
      {
        "title": "1. 시작",
        "url": "#1-시작",
        "items": []
      },
      {
        "title": "2. 문제 해결 시도",
        "url": "#2-문제-해결-시도",
        "items": [
          {
            "title": "2.1. 클라이언트 컴포넌트 분리",
            "url": "#21-클라이언트-컴포넌트-분리",
            "items": []
          },
          {
            "title": "2.2. 라우트 변경해보기",
            "url": "#22-라우트-변경해보기",
            "items": []
          },
          {
            "title": "2.3. import의 문제",
            "url": "#23-import의-문제",
            "items": []
          }
        ]
      },
      {
        "title": "3. 후속조치",
        "url": "#3-후속조치",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 2,
      "wordCount": 498
    },
    "url": "/posts/nextjs-13-trouble-1",
    "thumbnail": {
      "local": "/thumbnails/nextjs-13-trouble-1-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-nextjs-13-trouble-1-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAfUlEQVR4nGOoq6uLiooqKipKSEgICwsLCQmxsrK6e/cuQ0VFhZSUFCMjo7e394ULF3aDwcePHxmWL1/e3d29b9++M2fO/P////fv3//BgOHo0aPd3d07dux49+4dRAIix3Dn7r37D0AAIgEHDPMXL5s7b/66dWuvXruGbBQAoQVqI3wL6vUAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "os-1",
    "title": "운영체제 공룡책 1단원 정리",
    "date": "2022-10-21T00:00:00Z",
    "description": "운영체제 1단원 정리",
    "tags": [
      "study",
      "CS"
    ],
    "html": "<p>운영체제 중간고사를 맞아서 내용을 정리한다. 수업 ppt와 OSTEP, Operating System Concepts 책을 참고하였다. 또한 <a href=\"https://parksb.github.io/article/5.html\">박성범 님의 블로그</a>도 큰 도움이 되었다.</p>\n<h1>1. 운영체제 기본 개념</h1>\n<h2>1.1 운영체제의 역할</h2>\n<p>프로그램이 실행될 때는 어떤 일이 일어나는가? 프로그램을 실행하는 프로세서는 명령어를 반입(fetch)하고, 해석(decode)하고, 실행(execute)한다. 프로그램이 끝날 때까지.</p>\n<p>그런데 이 과정에서 프로그램을 동시에 실행하기도 하고, 프로그램끼리 메모리 공유를 하기도 하고 프로그램과 하드웨어 장치가 상호작용하는 등 다양한 일이 일어난다. 이런 일들을 관리하는 것이 운영체제이다.</p>\n<p>그리고 사용자에게는 이런 시스템 자원 배분을 운영체제에 맡기고 복잡한 부분을 신경쓰지 않고 프로그램을 실행할 수 있도록 해준다. 즉 하드웨어와 응용 프로그램 사이의 조율을 해준다.</p>\n<h2>1.2 컴퓨터 시스템 구조</h2>\n<p>컴퓨터 시스템의 구조는 어떻게 되어 있을까? 현대의 컴퓨터는 하나 이상의 CPU와 여러 개의 디바이스 컨트롤러로 이루어져 있으며 CPU, 디바이스 컨트롤러는 common bus를 통해 공유 메모리에 접근할 수 있도록 되어 있다. 버스는 데이터를 주고받을 수 있게 해주는 매개체 정도로 생각하면 된다.</p>\n<p>각 디바이스 컨트롤러는 연결된 특정 장치를 제어한다. 컨트롤러에 따라 둘 이상의 장치가 연결될 수도 있다. 이때 이 컨트롤러는 로컬 버퍼와 레지스터를 가지고 있다. 그리고 디바이스 컨트롤러는 담당하고 있는 주변 기기와 로컬 버퍼 사이의 데이터 전송을 관리한다.</p>\n<p>그리고 CPU와 디바이스 컨트롤러는 병렬로 실행될 수 있는데 그러면 CPU와 디바이스 컨트롤러는 메모리 사이클을 얻기 위해 경쟁한다. 어떤 디바이스 컨트롤러가 공유 메모리에 먼저 접근할지를 결정하기 위한 메모리 컨트롤러도 따로 있다.</p>\n<h2>1.3 인터럽트</h2>\n<p>일반적인 입출력을 수행하는 프로그램을 생각한다. 그러면 디바이스 드라이버가 컨트롤러의 적절한 레지스터에 값을 로드한다. 디바이스 컨트롤러는 이 레지스터에 담긴 정보를 읽고 어떤 행동을 취할지 결정한다. (가령 키보드에서 입력 읽어오기). 그리고 디바이스 컨트롤러는 장치에서 로컬 버퍼로 데이터를 전송하기 시작한다.</p>\n<p>이게 끝나면 디바이스 컨트롤러는 디바이스 드라이버에게 operation을 끝냈다는 신호를 보내고 디바이스 드라이버가 운영체제의 다른 부분에 제어를 넘긴다. 이때 컨트롤러가 드라이버에게 작업 완료 사실을 알리는 건 인터럽트를 통해 이루어진다. 이 인터럽트는 운영체제-하드웨어 간 상호작용의 핵심이다.</p>\n<p>CPU가 인터럽트되면 하던 일을 중단하고 즉시 특정한 고정 위치로 실행을 옮긴다. 이 고정 위치는 일반적으로 인터럽트의 서비스 루틴 시작 주소를 가지고 있다. 이 루틴의 실행이 완료되면 CPU는 원래 하던 일을 다시 시작한다.</p>\n<p>인터럽트는 하드웨어, 소프트웨어 둘 모두에 의해 발생될 수 있다. 하드웨어는 시스템 버스를 통해 인터럽트를 발생시키고 소프트웨어적으로는 시스템 콜을 통해 인터럽트를 발생시킨다. 소프트웨어에 의한 인터럽트는 <code>트랩</code>이라고 하기도 한다.</p>\n<p>인터럽트는 결과적으로 적절한 서비스 루틴으로 프로그램 제어를 전달하는 것이다. 이때 사용할 수 있는 방법은 인터럽트가 발생했을 때 그 정보를 조사하는 핸들러를 호출하는 것이다. 이 핸들러는 인터럽트가 발생한 원인을 파악하고 적절한 서비스 루틴을 호출한다.</p>\n<p>하지만 이는 인터럽트의 처리 속도를 늦춘다. 따라서 테이블을 통해서 간접적으로 인터럽트가 호출되도록 하는 방법이 있다. 이 테이블은 인터럽트 벡터라고 불리며 인터럽트 번호와 서비스 루틴의 주소를 매핑한다. 인터럽트가 발생하면 CPU는 해당 인터럽트 번호를 테이블에서 찾아 해당 서비스 루틴의 주소를 얻는다. 이 주소로 CPU가 이동하고 서비스 루틴을 실행한다.</p>\n<p>그리고 인터럽트가 실행 종료된 이후 다시 원래 하던 일을 계속해야 한다. 따라서 인터럽트 루틴으로 넘어가기 전에 현재 상태를 저장해 놓아야 한다.</p>\n<h2>1.4 DMA</h2>\n<p>인터럽트 기반의 I/O 처리는 다음과 같이 작동한다. 어떤 입출력 작업이 시작되면 장치 드라이버가 장치 컨트롤러 레지스터에 값을 로드한다. 그러면 장치 컨트롤러는 이 레지스터 내용을 검사후 작업을 수행하고 CPU에 인터럽트를 전달한다. CPU는 인터럽트를 받아서 인터럽트 핸들러를 호출하고 이 핸들러는 인터럽트가 발생한 원인을 파악하고 적절한 서비스 루틴을 호출한다. 그리고 그 서비스 루틴이 종료되면 CPU가 원래 진행하고 있던 작업(인터럽트로 인해 중단)으로 복귀한다.</p>\n<p>하지만 이는 장치 컨트롤러가 전달한 데이터를 CPU를 거쳐 로드하기 때문에 CPU의 처리 속도에 영향을 받는다. 따라서 CPU를 거치지 않고 장치 컨트롤러가 직접 메모리에 데이터를 로드하는 방법이 있다. 이를 DMA(Direct Memory Access)라고 한다. DMA는 CPU가 데이터를 메모리에 로드하는 것이 아니라 장치 컨트롤러가 직접 메모리에 데이터를 로드한다.</p>\n<p>따라서 하나의 데이터 블록에 하나의 인터럽트만 발생한다. 이 하나의 인터럽트는 디바이스 컨트롤러 -> 메인 메모리 데이터 전달이 끝났다고 CPU에게 알려주는 인터럽트이다. 그리고 CPU는 디바이스 컨트롤러가 메인 메모리에 데이터를 전달하는 시간 동안 다른 일을 할 수 있다.</p>\n<h2>1.5 컴퓨터 시스템 구조</h2>\n<h3>싱글 프로세서</h3>\n<p>싱글 프로세서 시스템은 하나의 CPU만을 가지고 있다. 그리고 그 CPU는 하나의 처리 코어를 가지고 있다. <code>코어는 명령을 실행하고 로컬로 데이터를 저장하기 위한 레지스터를 포함하는 하나의 구성 요소로 CPU의 기본 계산 단위</code>이다.</p>\n<h3>멀티 프로세서</h3>\n<p>멀티 프로세서 시스템은 하나 이상의 CPU를 가진 2개 이상의 프로세서가 있다. 그리고 각 CPU는 하나 이상의 코어를 가지고 있다. 멀티 프로세서 시스템은 버스, 메인 메모리 및 주변 장치를 공유한다. 이렇게 프로세서 수를 늘리면 처리량이 늘어난다.</p>\n<p>물론 N개의 프로세서를 쓴다고 처리량이 N배 정확하게 늘어나는 건 아니다. 여러 프로세서가 협력할 때 모든 프로세서가 올바르게 작동하게 유지하는 데 드는 오버헤드가 있다. 또한 공유 자원에 대한 경합도 문제가 된다.</p>\n<h3>멀티 프로그래밍</h3>\n<p>멀티 프로그래밍은 여러 프로그램을 동시에 실행하는 것이다. 다중 프로그래밍은 CPU가 항상 프로그램 한 개는 실행할 수 있도록 프로그램을 구성한다. 즉 여러 프로세스를 동시에 메모리에 유지한다. 하나의 프로그램이 유휴 상태가 되면 다른 프로그램을 실행한다. 이렇게 하면 CPU가 항상 프로그램을 실행할 수 있게 된다.</p>\n<p>멀티태스킹은 시분할(Time sharing)이라고도 하는데 여러 프로세스를 전환하며 프로세스를 실행하는 것이다. 전환이 자주 발생하므로 사용자에게 빠른 응답 시간을 제공한다. 이때 여러 프로세스가 동시에 실행할 준비가 되면 시스템은 스케줄링을 통해 다음에 실행할 프로세스를 선택한다. 또한 가상 메모리의 사용은 메모리에 일부만 적재되어 있는 프로세스를 실행할 수 있게 한다. 즉 프로세스 크기가 물리 메모리 크기보다 커도 된다! (또한 사용자에게 보이는 논리 메모리를 물리 메모리와 분리시킬 수 있는 이점도 있다)</p>\n<h2>1.6 운영체제의 안전 보장</h2>\n<p>운영체제는 잘못되거나 악의적인 프로그램으로 인해 다른 프로그램까지 잘못 실행되는 것을 막아야 한다. 이를 위해 운영체제는 다음과 같은 기능을 제공한다.</p>\n<ul>\n<li>이중 모드</li>\n<li>입출력 보호</li>\n<li>메모리 보호</li>\n<li>타이머</li>\n</ul>\n<h3>이중 모드</h3>\n<p>운영체제는 사용자 모드와 커널 모드, 2개의 독립된 연산 모드를 필요로 한다. 이는 모드 비트로 나타나며 0이 커널 모드, 1이 사용자 모드를 나타낸다. 이를 통해 운영체제를 위해 실행되는 작업/사용자를 위해 실행되는 작업을 구분할 수 있다.</p>\n<p>몇몇 명령어는 커널 모드일 때만 실행되도록 설계되어 있는데 이는 특권 명령(privileged instruction)이라고 한다. 사용자 모드에서는 특권 명령을 실행할 시 불법적인 명령으로 간주되어 예외가 발생한다. 사용자는 시스템 콜을 통해서 운영체제에 특정 작업을 요청할 수 있다.</p>\n<h3>입출력 보호</h3>\n<p>모든 입출력 명령어는 특권 명령으로 커널 모드에서만 실행될 수 있다.</p>\n<h3>메모리 보호</h3>\n<p>인터럽트 벡터(각 인터럽트별로 실행할 작업의 주소가 저장된 테이블)와 인터럽트 서비스 루틴이 저장된 메모리 위치는 보호해야 한다. 따라서 이런 메모리 보호를 위해서, 프로그램이 접근할 수 있는 메모리 범위를 결정하는 두 개의 레지스터를 사용한다.</p>\n<p>프로그램이 접근할 수 있는 최소의 물리 메모리 주소를 저장하는 Base register, 접근 가능한 메모리의 range를 저장하는 Limit register가 그것이다. 이 범위를 벗어나는 메모리는 보호된 것으로 간주한다.</p>\n<h3>타이머</h3>\n<p>타이머는 운영체제에게 제어권을 보장하는 수단이다. 이를 위해 일정 주기마다 인터럽트를 발생시킨다. 이렇게 지정된 시간 후 컴퓨터를 인터럽트하도록 하는 것을 타이머라고 한다.</p>\n<p>운영체제 타이머는 특정 값을 설정하고 클럭 틱마다 1씩 감소시킨다. 이 값이 0이 되면 인터럽트를 발생시키는 방식이다. 이 타이머 값을 변경하는 명령은 특권 명령으로 커널 모드에서만 실행될 수 있다.</p>\n<h2>1.7 시스템 콜</h2>\n<p>시스템 콜은 운영체제의 기능을 사용하기 위해 프로그램이 운영체제에 요청하는 방법이다. 사용자는 시스템 콜을 이용해서 운영체제가 제공하는 기능을 사용할 수 있다.</p>\n<p>일반적으로 각 시스템 콜은 특정 번호와 연결되어 있으며 이 관계를 저장한 시스템 콜 테이블이 존재한다. 이 시스템 콜을 사용하는 사용자는 각 시스템 콜의 내부 구현을 알 필요 없이 API를 통해 사용할 수 있다.</p>\n<p>이때 시스템 콜에 파라미터를 전달해야 할 때가 있는데 이태는 3가지 방법이 있다.</p>\n<ol>\n<li>레지스터를 통해 전달\n레지스터에 그대로 파라미터를 전달한다. 그런데 이렇게 하면 레지스터의 수가 부족할 수 있다.</li>\n<li>블럭을 통해 전달\n파라미터들을 메모리 내의 블럭이나 테이블에 저장하고 그 블럭의 주소를 레지스터에 전달한다.</li>\n<li>스택을 통해 전달\n파라미터들을 스택에 저장하고 스택 포인터를 레지스터에 전달한다.</li>\n</ol>\n<h3>시스템 콜의 종류</h3>\n<ul>\n<li>프로세스 제어 Process Control</li>\n<li>파일 조작 File Management</li>\n<li>장치 조작 Device Management</li>\n<li>정보 유지 Information Maintenance</li>\n<li>통신 Communication</li>\n<li>보호(자원 권한 관리 등) Protection</li>\n</ul>\n<h2>1.8. 시스템 부팅</h2>\n<p>시스템 부팅은 커널을 로드하는 것부터 시작한다.</p>\n<p>시스템 전원이 들어오면 비휘발성 메모리에 있는 부트스트랩 프로그램이라는 프로그램이 실행된다. 이 프로그램은 커널을 메모리에 로드하고 커널을 실행한다.</p>\n<p>가끔은 부트스트랩 로더가 디스크에서 더 복잡한 부트 프로그램을 로드하고 이 부트 프로그램이 커널을 로드하는 경우도 있다.</p>",
    "excerpt": "운영체제 중간고사를 맞아서 내용을 정리한다. 수업 ppt와 OSTEP, Operating System Concepts 책을 참고하였다. 또한 박성범 님의 블로그도 큰 도움이 되었다.\n1. 운영체제 기본 개념\n1.1 운영체제의 역할\n프로그램이 실행될 때는 어떤 일이 일어나는가? 프로그램을 실행하는 프로세서는 명령어를 반입(fetch)하고, 해석(decode)하고, 실행(execute)한다. 프로그램이 끝날 때까지.\n그런데 이 과정에서 프로그램을 동시에 실행하기도 ",
    "headingTree": [
      {
        "title": "1. 운영체제 기본 개념",
        "url": "#1-운영체제-기본-개념",
        "items": [
          {
            "title": "1.1 운영체제의 역할",
            "url": "#11-운영체제의-역할",
            "items": []
          },
          {
            "title": "1.2 컴퓨터 시스템 구조",
            "url": "#12-컴퓨터-시스템-구조",
            "items": []
          },
          {
            "title": "1.3 인터럽트",
            "url": "#13-인터럽트",
            "items": []
          },
          {
            "title": "1.4 DMA",
            "url": "#14-dma",
            "items": []
          },
          {
            "title": "1.5 컴퓨터 시스템 구조",
            "url": "#15-컴퓨터-시스템-구조",
            "items": [
              {
                "title": "싱글 프로세서",
                "url": "#싱글-프로세서",
                "items": []
              },
              {
                "title": "멀티 프로세서",
                "url": "#멀티-프로세서",
                "items": []
              },
              {
                "title": "멀티 프로그래밍",
                "url": "#멀티-프로그래밍",
                "items": []
              }
            ]
          },
          {
            "title": "1.6 운영체제의 안전 보장",
            "url": "#16-운영체제의-안전-보장",
            "items": [
              {
                "title": "이중 모드",
                "url": "#이중-모드",
                "items": []
              },
              {
                "title": "입출력 보호",
                "url": "#입출력-보호",
                "items": []
              },
              {
                "title": "메모리 보호",
                "url": "#메모리-보호",
                "items": []
              },
              {
                "title": "타이머",
                "url": "#타이머",
                "items": []
              }
            ]
          },
          {
            "title": "1.7 시스템 콜",
            "url": "#17-시스템-콜",
            "items": [
              {
                "title": "시스템 콜의 종류",
                "url": "#시스템-콜의-종류",
                "items": []
              }
            ]
          },
          {
            "title": "1.8. 시스템 부팅",
            "url": "#18-시스템-부팅",
            "items": []
          }
        ]
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 65
    },
    "url": "/posts/os-1",
    "thumbnail": {
      "local": "/thumbnails/os-1-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-os-1-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAfElEQVR4nGOoqalRVVXl4+MLCgri5OTU1dVNSkry8fFhWLRokb+/f05OTn5+wZo1ay5cuHDw4MFdu3YxvH379tatW0+fPr1169aPHz/+wwADnPX////fSIDh2rUbV69du3Xr1tu3b5EVMcyZt3Da9BkrV668fPkyRBNEAgDNAGxt28Y+2wAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "os-2",
    "title": "운영체제 공룡책 3단원 정리",
    "date": "2022-11-25T00:00:00Z",
    "description": "운영체제 3단원 정리",
    "tags": [
      "study",
      "CS"
    ],
    "html": "<p>운영체제 3단원, 프로세스 관련 내용을 정리한다.</p>\n<h1>1. 프로세스의 개념</h1>\n<p>프로세스는 현재 실행중인 프로그램을 의미한다. 프로그램은 디스크에 존재하는 것이며 이것이 메모리에 로드되어 프로그램 카운터를 가지고 실행되면 프로세스가 된다. 이런 프로세스는 컴퓨팅 시스템에서 작업 단위로도 쓰인다.</p>\n<p>메모리에는 여러 프로그램이 로드될 수 있고 하나의 프로그램에 의해 여러 프로세스가 만들어질 수도 있다.</p>\n<p>하나의 프로세스는 개별 메모리와 프로그램 카운터를 가지고 있으며, 이것은 프로세스가 독립적으로 실행되는 것을 의미한다. 그리고 프로세스의 메모리 배치는 코드(텍스트), 데이터, 스택, 힙 영역으로 구분된다.</p>\n<p>이때 텍스트, 데이터 섹션은 프로그램 실행 동안 크기가 불변이고 스택, 힙 섹션은 실행 중에 동적으로 크기가 변경될 수 있다. 이때 힙 영역에는 유저가 동적으로 할당하는 메모리가 들어가고 스택 영역에는 함수가 호출될 때마다 그 activation record가 들어가게 된다. 자세한 내용은 일반적으로 시스템이나 PL 과목에 있다.</p>\n<h2>1.1. 프로세스의 상태</h2>\n<p>프로세스는 실행되면서 그 상태가 변한다. 프로세스의 상태는 크게 5가지로 나눌 수 있다. new, ready, running, waiting, terminated가 그것이다.</p>\n<ul>\n<li>new : 프로세스가 생성 중이다. 여기서 프로세스는 프로세스 테이블에 등록되지 않은 상태이며 승인되면 ready 상태로 넘어간다.</li>\n<li>ready : 프로세스가 cpu에 할당되기를 기다리고 있다. cpu에 프로세스가 할당되어 스케줄링되면 running 상태로 넘어간다.</li>\n<li>running : 프로세스가 cpu에 할당되어 실행 중이다. 프로세스가 I/O로 넘어가거나 특정 이벤트를 기다리는 상태가 되면 waiting 상태로 넘어간다. 그리고 프로세스가 종료되면 terminated 상태로 넘어간다. 또 인터럽트가 걸리면 ready 상태로 넘어간다.</li>\n<li>Waiting : 프로세스가 I/O를 기다리거나 특정 이벤트를 기다리는 상태이다. I/O가 완료되거나 특정 이벤트가 발생하면 ready 상태로 넘어간다.</li>\n<li>Terminated : 프로세스가 종료되었다. 프로세스는 종료되면 프로세스 테이블에서 제거된다.</li>\n</ul>\n<p>한 코어에서는 한 프로세스만이 실행 중에 있을 수 있다.</p>\n<h2>1.2 Process Control Block</h2>\n<p>각 프로세스는 os에서 Process Control Block에 의해 표현된다. 이 PCBs는 프로세스 생성시 만들어지며 프로세스 관리자에 의해 관리된다. 다음과 같은 정보를 갖고 있다.</p>\n<ul>\n<li>Process state</li>\n<li>Process number</li>\n<li>Program counter</li>\n<li>CPU registers</li>\n<li>CPU scheduling information</li>\n<li>Memory management information</li>\n<li>Accounting information (CPU 사용 시간, 경과된 시간, 시간 제한 등)</li>\n<li>I/O 상태 정보</li>\n</ul>\n<h1>2. 프로세스 스케줄링</h1>\n<p>멀티프로그래밍의 목적은 CPU가 언제나 어떤 프로세스를 실행하고 있도록 하는 데에 있다. time-sharing은 사용자가 여러 프로그램을 쓸 수 있도록 CPU가 실행하고 있는 프로세스를 빈번하게 교체한다.</p>\n<p>하나의 프로세서는 하나의 프로세스만 실행할 수 있으므로, 여러 프로세스를 실행하기 위해서는 프로세스를 스케줄링해야 한다. 이때 현재 메모리에 있는 프로세스의 수를 Degree of Multiprogramming이라고 한다.</p>\n<p>이를 위해 프로세스를 2가지로 분류하자.</p>\n<ul>\n<li>I/O bound 프로세스 : 계산보다 입출력에 소비하는 시간이 많다. 즉 프로세스에서 입출력 연산이 지배적이다.</li>\n<li>CPU bound 프로세스 : 입출력보다 계산에 소비하는 시간이 많다. 즉 프로세스에서 계산 연산이 지배적이다.</li>\n</ul>\n<h2>2.1 스케줄링 큐</h2>\n<p>메인 메모리에 있으면서 실행되길 기다리는 ready 상태 프로세스들은 연결 리스트 형태로 저장되며 준비 큐라고 한다. 이 준비 큐에는 PCB들이 연결되어 있다.</p>\n<p>I/O장치의 완료를 기다리고 있는 프로세스들은 I/O Wait 큐(디바이스 큐라고도 한다)에 저장된다. 혹은 핀토스 프로젝트에서 볼 수 있듯이 자식 프로세스의 종료를 기다리는 sleep 큐도 존재한다.</p>\n<h2>2.2 CPU 스케줄링</h2>\n<p>cpu 스케줄러는 레디 큐의 프로세스 중 어떤 프로세스가 실행될지 선택하고 선택된 프로세스에 CPU를 할당한다. 스케줄러는 ms단위 정도로 매우 자주 실행된다.</p>\n<p>스케줄러는 스와핑이라 불리는 동작을 하기도 한다. 핵심 아이디어는 메모리에서 프로세스를 제거하고 나중에 다시 불러와서 실행하는 것이 더 좋을 수도 있다는 데에서 온다. 스와핑에 대해서는 9장에서 자세히 다룬다.</p>\n<h2>2.3 컨텍스트 스위칭(문맥 교환)</h2>\n<p>프로그램 카운터, 프로세스 상태 등 프로세스의 상태를 나타내는 정보를 프로세스의 컨텍스트라 한다.</p>\n<p>CPU가 실행하고 있는 프로세스를 다른 프로세스로 교환하는 작업을 컨텍스트 스위칭이라 한다. 이때 기존 프로세스의 컨텍스트를 저장하고 후에 다시 되돌려야 한다. 즉 기존에 실행되고 있는 프로세스의 PCB를 저장하고 새로운 프로세스를 실행해야 한다(컨텍스트는 PCB내에 표현되기 때문이다). 새 프로세스의 실행이 끝나면 기존 프로세스의 PCB를 불러와서 그 프로세스의 실행으로 돌아와야 하기 때문이다.</p>\n<p>이 컨텍스트 스위칭 도중에는 CPU가 아무런 일도 하지 못하므로 컨텍스트 스위칭이 발생하는 시간은 순수한 오버헤드이다. 이 스위칭 속도는 디바이스마다 다르다.</p>\n<h1>3. 프로세스 연산</h1>\n<p>프로세스 생성 기법에 대해 살펴보자. 시스템 내 프로세스들은 대부분 병행 실행 가능하며 반드시 동적으로 생성/제거해야 한다. 따라서 운영체제에 프로세스 생성 및 종료를 위한 기능은 필수적이다.</p>\n<h2>3.1 프로세스 생성</h2>\n<p>프로세스는 pid(process identifier)라는 고유한 식별자를 통해 관리되고 식별된다. 그리고 각 프로세스는 여러 자식 프로세스를 만들 수 있고 이런 관계에 따라 트리를 형성한다. 언제나 pid가 1인 systemd(혹은 init, 운영체제마다 다르다) 프로세스가 최상위 프로세스이다.</p>\n<p>이 pid 1인 루트 프로세스는 모든 프로세스의 부모가 되는 프로세스이고 시스템이 부트될 때 생성된다.</p>\n<p>프로세스가 자식 프로세스를 생성할 때 정할 수 있는 옵션이 있다.</p>\n<p>자식 프로세스가 자원을 어디서 가져오게 할 것인가?</p>\n<ul>\n<li>부모 프로세스의 자원을 모두 공유한다.</li>\n<li>부모 프로세스 자원의 일부를 공유한다.</li>\n<li>부모 프로세스 자원을 전혀 공유하지 않는다.(이 경우 자식 프로세스에 따로 자원을 제공해야 한다)</li>\n</ul>\n<p>자식 프로세스의 실행은?</p>\n<ul>\n<li>부모 프로세스가 자식과 병행해서 실행을 계속한다.</li>\n<li>부모 프로세스가 자식 프로세스가 끝날 때까지 기다린다.(보통 이걸 쓴다)</li>\n</ul>\n<p>자식 프로세스의 주소 공간은?</p>\n<ul>\n<li>자식 프로세스가 부모 프로세스의 주소 공간을 그대로 사용한다. 즉 같은 프로그램과 데이터를 가진다.</li>\n<li>자식 프로세스가 자신에게 로드될 새로운 프로그램을 가지고 있다.</li>\n</ul>\n<h2>3.2 실제 UNIX 운영체제의 예시</h2>\n<p>유닉스에서 새로운 프로세스는 <code>fork()</code> 시스템 콜로 생성된다. 이 함수를 호출시 부모 프로세스는 자신과 똑같은 자식 프로세스를 생성한다.</p>\n<p>이 자식 프로세스는 부모 프로세스의 주소 공간의 복사본이다. 그리고 이 2개의 프로세스는 <code>fork</code>시스템 콜 다음의 명령어에서부터 각자 실행을 계속한다.</p>\n<p>이때 부모 프로세스와 자식 프로세스의 차이점은 fork가 반환하는 pid값의 차이이다. 부모 프로세스에서의 fork는 자식 프로세스의 pid를 반환하고, 자식 프로세스에서의 fork는 0을 반환한다. 이 두 프로세스는 동시에 작동한다.</p>\n<p>자식 프로세스에서는 <code>exec()</code>를 통해 자신만의 프로그램을 로드할 수 있다. 그러면 자식 프로세스는 원래 프로그램의 메모리 이미지를 파괴하고 exec()를 통해 로드된 프로그램을 실행한다.</p>\n<p>이러한 프로그램 코드를 보면 다음과 같다.</p>\n<pre><code class=\"language-c\">#include &#x3C;stdio.h>\n#include &#x3C;unistd.h>\n#include &#x3C;sys/types.h>\n\nint main(void) {\n    pid_t pid;\n    pid = fork();\n    if(pid &#x3C; 0){\n        fprintf(stderr, \"Fork Failed\");\n        exit(-1);\n    }\n    else if(pid == 0){ // 자식 프로세스는 fork가 0을 반환한다.\n    // 자식 프로세스가 새로운 프로그램을 실행한다.\n    // getpid 함수를 사용하면 이 자식 프로세스의 진짜 pid를 얻을 수 있다.\n        execlp(\"/bin/ls\", \"ls\", NULL);\n    }\n    else{\n        wait(NULL); // 부모는 자식 프로세스가 끝날 때까지 기다린다.\n        printf(\"Child Complete\");\n        exit(0);\n    }\n    return 0;\n}\n</code></pre>\n<p>부모 프로세스는 자식 프로세스가 끝날 때까지 기다린다. 자식 프로세스가 <code>exec()</code>를 호출했다면 프로세스 주소 공간을 새 프로그램으로 덮어쓰기 때문에 오류가 발생하지 않는 한 제어를 넘기지 않는다.</p>\n<p>물론 자식 프로세스가 <code>exec()</code>를 호출하지 않고 부모 프로세스의 복사본을 계속 실행할 수도 있다.</p>\n<h2>3.3. 프로세스 종료</h2>\n<p>프로세스가 마지막 명령을 실행하고 나서 exit() 시스템 콜을 사용해서 운영체제에 이 프로세스 삭제 요청을 한다. 그리고 자신을 기다리고 있는 부모 프로세스에 wait(&#x26;status) 시스템 콜을 통해 상태 값을 반환한다. 또한 자식 프로세스의 모든 자원이 할당 해제되어 운영체제에 반환된다.</p>\n<p>혹은 부모나 사용자가 kill 시스템 콜을 통해 자식 프로세스를 임의로 종료시킬 수 있다. 이런 kill을 하는 이유는 다음과 같다.</p>\n<ul>\n<li>자식 프로세스가 할당된 자원 이상을 사용한다.</li>\n<li>자식 프로세스의 작업이 더 이상 필요없다.</li>\n<li>부모 프로세스가 종료되었으며(exit) 운영체제가 부모 exit 이후 자식 프로세스가 계속 실행되는 걸 허용하지 않음(몇몇 os는 프로세스가 종료되면 운영체제가 그 프로세스의 자식 프로세스들을 모두 종료시킨다. 이를 cascading termination이라고 한다.)</li>\n</ul>\n<p>이때 kill(pid) 와 같이 부모가 자식 프로세스를 종료시키기 위해서는 자식 프로세스의 pid가 필요하다.</p>\n<h2>3.4 고아 프로세스, 좀비 프로세스</h2>\n<p>좀비 프로세스는 <code>종료되었지만 부모 프로세스가 아직 wait 호출을 하지 않은 프로세스</code>이다. 따라서 모든 프로세스는 종료하게 되면 잠깐 동안은 좀비 프로세스가 된다. 그리고 부모가 wait을 호출하면 좀비 상태였던 자식 프로세스는 종료된다. 즉 이미 종료되었지만 아직 프로세스 테이블에는 올라가 있는 프로세스가 좀비 프로세스이다.(부모는 아직 실행 중)</p>\n<p>반면 고아 프로세스는 <code>부모가 죽었지만 자식이 아직 종료되지 않은 프로세스이다</code>. 유닉스 같은 경우 init 프로세스가 고아 프로세스를 자신의 자식 프로세스로 만들어서 관리함으로써 고아 프로세스를 해결한다. 그리고 init 프로세스는 주기적으로 wait을 호출하여 자식 프로세스의 종료 상태를 수집한다.</p>\n<p>이런 고아 프로세스는 부모 프로세스가 wait을 호출하지 않고 종료되었을 때 생긴다.</p>\n<h1>4. 프로세스 주소 공간</h1>\n<p>각 프로세스는 가상 주소 공간을 가진다. 이 가상 주소 공간의 메모리는 실제 물리 메모리와 매핑되어 있다. 흔히 말하는 스택, 힙, 데이터, 코드 영역이 프로세스의 가상 주소 공간에 해당한다. 이런 가상 주소 공간은 보통 연속된 주소 공간(0~MAX)으로 구성되어 있다. 하지만 실제 이 가상 주소 공간의 메모리와 매핑된 물리 메모리 공간들은 꼭 연속된 주소 공간일 필요는 없다.</p>\n<p>그럼 이런 가상 주소 공간을 어떻게 구성하고, 어떻게 물리 메모리와 매핑하는가? 거기에는 여러 기법과 페이징이라는 중요한 개념이 나오는데 이는 이후 단원에서 자세히 나올 것이다.</p>\n<h1>5. 프로세스 간 통신</h1>\n<p>프로세스가 실행 중인 다른 프로세스들과 영향을 주고받는다면 cooperating process(협력적인 프로세스)이다. 다른 프로세스들과 영향을 주고받지 않는 프로세스는 독립 프로세스(independent process)라고 한다. 이렇게 협력 프로세스를 쓰는 것의 장점은 다음과 같다.</p>\n<ul>\n<li>여러 프로세스가 같은 정보에 접근하는 경우 정보에 같이 접근할 수 있다</li>\n<li>특정 작업을 여러 프로세스가 병렬로 실행하게 하기</li>\n<li>시스템 기능을 별도의 프로세스/스레드로 나눠서 모듈식으로 시스템 구성</li>\n<li>편의성 증가</li>\n</ul>\n<p>이때 프로세스 간 협력을 위해서는 프로세스 간 통신(interprocess communication, IPC)이 필요하다. 이 IPC에는 크게 두 가지 방법이 있다.</p>\n<ul>\n<li>공유 메모리(shared memory)</li>\n<li>메시지 전달(message passing)</li>\n</ul>\n<h2>5.1 공유 메모리 방식</h2>\n<p>공유 메모리 방식에서는 협력 프로세스들이 공유하는 메모리 영역이 구축된다. 이 메모리 영역에는 프로세스들이 공유하는 데이터가 저장된다. 프로세스들은 그 영역을 읽고 씀으로써 정보를 교환할 수 있다. 이때 각 프로세스는 공유 메모리 세그먼트를 자신의 주소 공간에 추가해야 한다.</p>\n<p>공유 메모리 방식은 공유 메모리 영역을 구축할 때만 시스템 콜을 사용하며 일단 이 영역이 구축되면 모든 접근은 일반 메모리 접근으로 취급되어 커널의 도움이 필요 없어진다. 따라서 메시지 접근 방식보다 빠르다. 단 메모리에 동시 접근하는 것을 막기 위한 구현이 필요하다.(동시에 동일한 위치에 쓰게 되면 데이터가 꼬일 수 있다)</p>\n<h3>5.1.1 생산자-소비자 문제</h3>\n<p>공유 메모리 방식은 생산자-소비자 문제의 해결책이 될 수 있다. 두 프로세스가 동시에 동작할 때 일어나는 이슈인데, 정보의 생산 속도가 소비 속도보다 보통 빠르기 때문에 일어나는 동기화 문제이다. 생산자와 소비자 프로세스가 공유하는 메모리 영역에 버퍼를 만드는 것으로 이를 해결할 수 있다.</p>\n<p>생산자가 생산한 정보는 버퍼에 저장되고 소비자는 버퍼에서 정보를 꺼내서 소비한다. 이때 버퍼에 저장된 정보가 없으면 소비자는 대기하고, 버퍼가 가득 차면 생산자는 대기한다. 이렇게 생산자와 소비자가 동시에 동작할 때 생기는 동기화 문제를 해결할 수 있다.</p>\n<h2>5.2 메시지 전달 방식</h2>\n<p>메시지 전달 방식에서는 프로세스간 통신이 프로세스들 간에 교환되는 메시지를 통해서 이루어진다. 이 방식에선 메모리를 프로세스간에 공유할 필요가 없다.</p>\n<p>메시지 전달 방식은 최소 2가지 연산을 제공한다.</p>\n<ul>\n<li>send: 메시지를 전송. 메시지 길이는 고정 길이일 수도 가변 길이일 수도 있다.</li>\n<li>receive : 메시지를 수신. 메시지를 수신할 때까지 대기한다.</li>\n</ul>\n<p>이 send/receive를 통해 프로세스간 메시지를 주고받기 위해서는 communication link가 설정되어 있어야 한다. 그리고 그 링크에서 send, receive를 이용해 메시지를 주고받는다. 이런 메시지 전달 방식 설계에서 고려해야 할 것은 다음과 같다.</p>\n<ul>\n<li>Naming : 통신할 프로세스들이 어떻게 서로를 식별할 것인가?</li>\n<li>Syncronization : 메시지를 주고받는 프로세스들이 어떻게 동기화할 것인가?</li>\n<li>Buffering : 프로세스들 간의 메시지 큐를 어떻게 관리할 것인가?</li>\n</ul>\n<h3>5.2.1 Naming</h3>\n<p>직접 통신의 경우 프로세스는 식별을 위해 상대방의 주소를 알고 있어야 한다. 즉 P에게 msg를 보내려면 send(P, msg)를 쓰고 Q에서 메시지를 수신하는 것은 receive(Q, msg)를 쓰는 식이다.</p>\n<p>mailbox(or port)를 통해서 통신하는 간접 통신의 방법도 있다. 이 방식의 경우 메시지들은 mailbox로 송신되고 거기로부터 수신된다. 즉 프로세스 - 메일박스 - 프로세스의 구조이다.</p>\n<p>각 메일박스는 고유 id를 가진다. 그리고 두 프로세스가 통신하기 위해서는 서로가 공유하는 메일박스가 있어야 한다. send(A, msg), receive(A, msg) 를 통해 메일박스 A와 메시지를 송수신할 수 있다. 이 경우 다수 프로세스간 통신도 가능하다. 단 메시지를 저장할 메일박스가 따로 있어야 한다는 단점이 있다.</p>\n<h3>5.2.2 Syncronization</h3>\n<p>프로세스간 통신은 블로킹, 논블로킹이 있다. 블로킹=동기=synchronous, 논블로킹=비동기=asynchronous. 각각의 특징은 다음과 같다.</p>\n<p>blocking send : 송신한 메시지를 수신자(혹은 mailbox)가 받을 때까지 새로운 송신을 할 수 없다.\nnon-blocking send : 송신한 메시지를 수신자가 받을 때까지 기다리지 않고 송신 과정만 끝나면 송신자는 바로 새로운 송신을 할 수 있다.\nblocking receive : 메시지가 이용 가능할 때까지 수신 프로세스가 블락된다.\nnon-blocking receive : 송신하는 프로세스가 유효한 메시지 혹은 null을 받는다.</p>\n<h3>5.2.3 Buffering</h3>\n<p>통신하는 프로세스들이 교환하는 메시지는 큐에 들어 있다. 이 큐의 방식은 3가지가 있다.</p>\n<ol>\n<li>zero capacity : 큐 최대 길이 0. 메시지를 따로 보관할 곳이 없으므로 송신자는 수신자가 메시지를 수신할 때까지 기다려야만 한다.</li>\n<li>bounded capacity : 큐 최대 길이가 정해져 있다. 큐가 꽉 차 있다면 송신자는 큐가 꽉 차지 않을 때까지 기다려야 한다.</li>\n<li>unbounded capacity : 큐 최대 길이가 없으며 송신자는 절대 기다리지 않는다.</li>\n</ol>\n<h2>5.3 비교</h2>\n<p>대부분 운영체제에서는 2가지 방식을 모두 구현한다. 메시지 전달 방식은 충돌을 회피할 필요가 없다. 그래서 적은 양의 데이터를 공유하는 데 유용하고 분산 시스템에서 구현하기 쉽다.</p>\n<p>그러나 공유 메모리 방식은 빠르다. 메시지 전달 방식은 일반적으로 시스템 콜을 이용해 구현하므로 커널 간섭 등 때문에 느리다. 하지만 공유 메모리 방식은 공유 메모리 영역을 구축할 때만 시스템 콜이 필요하고 그 이후에는 커널의 도움이 필요 없다.</p>\n<h1>6. 실제 IPC 기법</h1>\n<h2>6.1 파이프</h2>\n<p>파이프는 두 프로세스가 통신할 수 있게 하는 전달자 역할을 한다. 일반적인 파이프는 단방향 통신만 가능하다. 한쪽에서는 데이터를 쓰고 한쪽에서는 읽는다. 만약 양방향 통신이 필요하다면 각각 다른 방향의 파이프 2개를 써야 한다.</p>\n<p>이는 일반적으로 커맨드라인에서 명령을 연결할 때 사용한다. 예를 들어 <code>ls | grep</code> 명령을 실행하면 <code>ls</code> 명령의 결과가 <code>grep</code> 명령의 입력으로 들어간다.</p>\n<p>또한 파이프는 구조화된 통신이 없기 때문에 파이프에 포함된 데이터의 크기, 송신자와 수신자를 알 수 없다.</p>\n<p>일반 익명 파이프의 제한은 조상 프로세스와만 통신이 가능하다는 것이다.. 따라서 파이프를 사용하려면 부모 프로세스가 파이프를 생성하고 자식 프로세스에게 fork를 이용해서 파이프를 복사해야 한다.</p>\n<p>익명 파이프를 만드는 건 pipe 함수를 통해 가능하다. <code>pipe(fd)</code> 함수는 파이프를 생성하고 fd[0]과 fd[1]에 각각 읽기와 쓰기를 위한 파일 디스크립터를 저장한다.</p>\n<ul>\n<li>fd[0] : 읽기 전용 파일 디스크립터</li>\n<li>fd[1] : 쓰기 전용 파일 디스크립터</li>\n</ul>\n<p>실제 코드를 통해 보면 다음과 같다.</p>\n<pre><code class=\"language-c\">#include &#x3C;stdio.h>\n#include &#x3C;unistd.h>\n\nint main(void){\n  int n, fd[2], pid;\n  char line[100];\n\n  if(pipe(fd) &#x3C; 0){\n    fprintf(stderr, \"pipe error\\n\");\n    exit(-1);\n  }\n  if((pid=fork()) &#x3C; 0){exit(-1);}\n  else if(pid > 0){ // parent\n    close(fd[0]); // 읽기 종료\n    write(fd[1], \"hello world\\n\", 12); // 부모 프로세스에서 쓴다.\n    wait(NULL); // 자식 프로세스 기다리기\n  }\n  else{ // child\n    close(fd[1]); // 쓰기 종료\n    n = read(fd[0], line, 100); // 자식 프로세스에서 읽는다\n    write(STDOUT_FILENO, line, n); // 받은 문자열을 표준 입출력에 출력\n  }\n}\n</code></pre>\n<h2>6.2 지명 파이프</h2>\n<p>지명 파이프는 일반 파이프의 제한들을 완화시킨다. 지명 파이프는 통신을 양방향으로 가능하게 하고 부모 프로세스와 자식 프로세스가 아닌 다른 프로세스와도 통신이 가능하다.</p>\n<p>또 파일 시스템에 존재하여 통신 프로세스가 종료되어도 사라지지 않는다. 실제로 파일처럼 존재하여 <code>open, read, write, close</code> 시스템 콜로 조작할 수 있다.</p>\n<h2>6.3 소켓</h2>\n<p>소켓은 통신의 endpoint이다. 각 소켓은 IP 주소와 포트 번호를 가지고 있다. 소켓은 네트워크를 통해 통신을 하기 위한 인터페이스로 정의된다. 그리고 일반적으로 서버-클라이언트가 통신하는 방식이다.</p>\n<p>IP주소와 포트 번호로 이루어진 소켓은 일종의 주소 같은 것이라고 생각하면 된다(<code>146.86.5.20:1625</code>와 같이 나타난다). 서버와 클라이언트가 통신을 하기 위해서는 서로의 소켓 주소를 알고 있어야 한다. 그래서 서버는 자신의 소켓 주소를 알려주고 클라이언트는 서버의 소켓 주소를 알아야 한다.</p>\n<p>그렇게 클라이언트와 서버가 서로의 소켓 주소를 알고 있으면 TCP, UDP 등의 기법으로 통신을 할 수 있다. 그런데 이때 소켓을 생성한 두 프로세스가 다른 네트워크에 있는 게 아니라 같은 컴퓨터의 같은 운영체제 상에서 실행되고 있다면 소켓을 통한 프로세스 간 통신도 가능하다.</p>",
    "excerpt": "운영체제 3단원, 프로세스 관련 내용을 정리한다.\n1. 프로세스의 개념\n프로세스는 현재 실행중인 프로그램을 의미한다. 프로그램은 디스크에 존재하는 것이며 이것이 메모리에 로드되어 프로그램 카운터를 가지고 실행되면 프로세스가 된다. 이런 프로세스는 컴퓨팅 시스템에서 작업 단위로도 쓰인다.\n메모리에는 여러 프로그램이 로드될 수 있고 하나의 프로그램에 의해 여러 프로세스가 만들어질 수도 있다.\n하나의 프로세스는 개별 메모리와 프로그램 카운터를 가지고 있으며, 이것은 ",
    "headingTree": [
      {
        "title": "1. 프로세스의 개념",
        "url": "#1-프로세스의-개념",
        "items": [
          {
            "title": "1.1. 프로세스의 상태",
            "url": "#11-프로세스의-상태",
            "items": []
          },
          {
            "title": "1.2 Process Control Block",
            "url": "#12-process-control-block",
            "items": []
          }
        ]
      },
      {
        "title": "2. 프로세스 스케줄링",
        "url": "#2-프로세스-스케줄링",
        "items": [
          {
            "title": "2.1 스케줄링 큐",
            "url": "#21-스케줄링-큐",
            "items": []
          },
          {
            "title": "2.2 CPU 스케줄링",
            "url": "#22-cpu-스케줄링",
            "items": []
          },
          {
            "title": "2.3 컨텍스트 스위칭(문맥 교환)",
            "url": "#23-컨텍스트-스위칭문맥-교환",
            "items": []
          }
        ]
      },
      {
        "title": "3. 프로세스 연산",
        "url": "#3-프로세스-연산",
        "items": [
          {
            "title": "3.1 프로세스 생성",
            "url": "#31-프로세스-생성",
            "items": []
          },
          {
            "title": "3.2 실제 UNIX 운영체제의 예시",
            "url": "#32-실제-unix-운영체제의-예시",
            "items": []
          },
          {
            "title": "3.3. 프로세스 종료",
            "url": "#33-프로세스-종료",
            "items": []
          },
          {
            "title": "3.4 고아 프로세스, 좀비 프로세스",
            "url": "#34-고아-프로세스-좀비-프로세스",
            "items": []
          }
        ]
      },
      {
        "title": "4. 프로세스 주소 공간",
        "url": "#4-프로세스-주소-공간",
        "items": []
      },
      {
        "title": "5. 프로세스 간 통신",
        "url": "#5-프로세스-간-통신",
        "items": [
          {
            "title": "5.1 공유 메모리 방식",
            "url": "#51-공유-메모리-방식",
            "items": [
              {
                "title": "5.1.1 생산자-소비자 문제",
                "url": "#511-생산자-소비자-문제",
                "items": []
              }
            ]
          },
          {
            "title": "5.2 메시지 전달 방식",
            "url": "#52-메시지-전달-방식",
            "items": [
              {
                "title": "5.2.1 Naming",
                "url": "#521-naming",
                "items": []
              },
              {
                "title": "5.2.2 Syncronization",
                "url": "#522-syncronization",
                "items": []
              },
              {
                "title": "5.2.3 Buffering",
                "url": "#523-buffering",
                "items": []
              }
            ]
          },
          {
            "title": "5.3 비교",
            "url": "#53-비교",
            "items": []
          }
        ]
      },
      {
        "title": "6. 실제 IPC 기법",
        "url": "#6-실제-ipc-기법",
        "items": [
          {
            "title": "6.1 파이프",
            "url": "#61-파이프",
            "items": []
          },
          {
            "title": "6.2 지명 파이프",
            "url": "#62-지명-파이프",
            "items": []
          },
          {
            "title": "6.3 소켓",
            "url": "#63-소켓",
            "items": []
          }
        ]
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 310
    },
    "url": "/posts/os-2",
    "thumbnail": {
      "local": "/thumbnails/os-2-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-os-2-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAdElEQVR4nGNoaGjQ0NAQFRUNDQ1lYmY2NjYOCgry9PRkmD59upubW0xMTGVl5a5duy5cuHDw4MFdu3Yx7Nm7t7m5ecKECc3Nzf+RAAMy5zcSYLh+6/bly5evX7/+9u1bFB1z5i2cNn3G8hXLL1++DNEEkQAAbzJorlPoIdMAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "os-3",
    "title": "운영체제 공룡책 4단원 정리",
    "date": "2022-11-30T00:00:00Z",
    "description": "운영체제 4단원 정리",
    "tags": [
      "study",
      "CS"
    ],
    "html": "<p>운영체제 4단원, 스레드와 병행성 부분을 정리한다.</p>\n<h1>1. 스레드</h1>\n<p>하나의 프로세스가 오직 하나의 실행 흐름만 가지고 있다고 하자. 그러면 하나의 어플리케이션은 여러 프로세스를 만들어야 한다. 예를 들어서 웹브라우저에 관련된 프로세스는 하나는 웹페이지를 렌더링하고 하나는 네트워크에서 데이터를 검색한다고 생각할 수 있다.</p>\n<p>하지만 이렇게 하나의 어플리케이션을 여러 프로세스로 나누는 것은 비효율적이다. 프로세스 생성 횟수도 많아지고, 컨텍스트 스위칭도 많이 발생하고 프로세스 간 통신도 많아진다. 그래서 운영체제는 프로세스 내에서 여러 실행 흐름을 만들 수 있도록 스레드라는 개념을 도입했다.</p>\n<h2>1.1 스레드의 개념</h2>\n<p>스레드는 CPU 이용의 기본 단위라고 할 수 있다. 일종의 실행 흐름이라고 생각하면 된다. 이는 스레드 id(tid), 각자의 PC, 레지스터 집합, 스택으로 구성된다. 그리고 스레드는 프로세스 내에 여러 개 있을 수 있는데 같은 프로세스의 다른 스레드와 코드, 데이터 영역 등의 운영체제 자원을 공유한다.</p>\n<p>즉 하나의 프로세스가 여러 개의 실행 흐름(스레드)을 가질 수 있다는 것이다. 이런 다중 스레드 프로그래밍의 장점은 다음과 같다.</p>\n<ul>\n<li>여러 실행 흐름이 동시에 진행되므로 대화형 프로그램에서 사용자에게 더 즉각적인 응답을 제공할 수 있다.</li>\n<li>스레드는 프로세스 내 자원을 공유하므로 자원을 프로세스에 비해서 더 쉽게 공유할 수 있다.</li>\n<li>스레드를 만들고 스레드간 흐름을 스위칭하는 건 프로세스로 같은 작업을 하는 것보다 훨씬 비용이 적다.</li>\n<li>다중 처리기 시스템에서는 각 스레드가 다른 처리기에서 병렬로 수행될 수 있다.</li>\n</ul>\n<h2>1.2 멀티코어 프로그래밍</h2>\n<p>요즘 나오는 컴퓨터 시스템은 하나의 컴퓨팅 칩에 여러 코어를 설치한다. 그리고 운영체제는 각 코어를 하나의 CPU로 인식하게 된다. 이런 멀티코어 시스템에서는 하나의 프로세스를 여러 개의 스레드로 나누어서 각각의 스레드를 다른 코어에서 동시에 실행시킬 수 있다. 이는 일부 스레드가 정말로 동시에, 병렬적으로 실행될 수 있음을 의미한다.</p>\n<p>여기서 동시성(concurrency)과 병렬성(parallelism)의 차이가 나온다. 병렬성은 코어(혹은 cpu)여러 개를 사용하여 실제로 스레드 여러 개를 동시에 실행하는 것이다. 아래 사진을 보면 스레드 여러 개가 정말로 같이 진행되는 것을 볼 수 있다.</p>\n<p><img src=\"/static/parallel-60be7dce.png\" alt=\"parallel\"></p>\n<p>하지만 코어가 하나뿐이라도 여러 개의 작업을 동시에 진행할 수는 있다. 여러 개의 스레드 사이를 빠르게 전환해 가며 하나의 프로세서에서 실행시키면 사용자는 여러 개의 작업이 동시에 진행되는 것처럼 느낄 수 있다. 이렇게 여러 작업을 동시에 진행하는 것을 동시성(concurrency)이라고 한다.</p>\n<p>다음 사진은 동시성에 관한 사진인데 CPU가 하나밖에 없어서 스레드 3개가 번갈아가면서 실행되는 것을 볼 수 있다. 따라서 병렬성 없이도 동시성이 가능하다.</p>\n<p><img src=\"/static/concurrency-3a722b84.png\" alt=\"concurrency\"></p>\n<p>CPU가 하나뿐이라도 동시성을 실현해서 여러 스레드를 프로세서에 올리는 게 뭐가 좋을까? 아무런 이득도 없을 것 같지만 계산이 빨라진다. 여러 스레드 중 입출력 작업이 많은 스레드 블럭을 진행할 때(I/O bound block) 다른 스레드는 계산을 진행할 수 있기 때문이다. 이렇게 하면 하나의 프로세서라도 더 효율적으로 작업할 수 있다.</p>\n<p>하지만 이런 병렬 프로그래밍은 쉽지 않다. 먼저 프로그램을 분석해서 독립된 병렬 가능한 작업으로 나눌 수 있어야 한다. 그리고 그 작업들을 코어마다 균등하게 나눠서 진행할 수 있어야 하고 각 작업이 접근하는 데이터가 독립적으로 나눠져 있어야 한다. 그리고 마지막으로 작업들이 서로 의존하지 않아야 한다. 이렇게 작업들이 독립적이고 서로 의존하지 않는다면 병렬 프로그래밍이 가능하다. 병렬 프로그래밍은 디버깅도 일반적인 단일 스레드 프로그래밍보다 어렵다.</p>\n<h1>2. 다중 스레드 모델</h1>\n<h2>2.1 스레드의 유형</h2>\n<p>스레드는 사용자 스레드와 커널 스레드로 분류될 수 있다.</p>\n<h3>2.1.1 사용자 스레드</h3>\n<p>사용자 스레드는 사용자 공간에서 제공되고 커널의 지원 없이 관리된다. 그리고 스레드 라이브러리를 통해 관리된다. 모든 것이 커널에 의존하지 않고 사용자 영역에서 이루어지므로 운영체제에서 스레드를 지원할 필요가 없고 OS 스케줄러에서 컨텍스트 스위칭이 발생하지도 않는다. 같은 이유로 커널을 호출하지 않기 때문에 인터럽트 발생 시 커널 스레드보다 오버헤드가 적다.</p>\n<h3>2.1.2 커널 스레드</h3>\n<p>커널 스레드는 커널 레벨에서 동작하고 커널에 의해 직접 관리된다. 따라서 커널에 종속적이다. 이는 장점도 있는데 커널이 각 스레드를 개별적으로 관리해 줄 수 있고 커널이 직접 관리하는 스레드라 안정성과 다양한 기능이 제공된다.</p>\n<p>단 사용자 모드-커널 모드 전환이 빈번해 성능 저하가 발생하고 구현이 어렵다. 또한 자원도 더 많이 소비하는 편이다. 스케줄링, 동기화를 위해 커널 스레드에서 커널을 호출할 때 이 연산이 무겁고 오래 걸리는 단점도 있다.</p>\n<p>단 이 커널 스레드의 수는 병렬성의 성능을 결정하는데 멀티스레드 환경에서 결국 연산을 처리하는 것은 커널 스레드이기 때문이다.</p>\n<h2>2.2 스레드 매핑 모델</h2>\n<p>스레드에는 사용자 스레드와 커널 스레드가 있지만 멀티스레드 환경의 경우 둘 사이에는 모종의 연관이 존재해야 한다. 멀티스레드 환경이 아니라면 유저 레벨 스레드가 그냥 프로세서에서 바로 실행되면 되므로 굳이 매핑이 필요 없다.</p>\n<p>하지만 현재 대부분의 운영체제 환경은 멀티스레드이므로 이 유저 스레드-커널 스레드 매핑은 중요하다. 다대일 모델, 일대일 모델, 다대다 모델이 존재한다.</p>\n<h3>2.2.1 다대일 모델</h3>\n<p>다대일 모델은 유저 스레드가 여러 개 있을 때 이를 하나의 커널 스레드로 매핑하는 방식이다. 스레드 관리는 사용자 공간의 스레드 라이브러리가 한다.</p>\n<p>문제는 하나의 스레드가 block 시스템 콜을 하면 유일한 커널 스레드가 봉쇄되므로 다른 스레드도 모두 block 되어 버린다는 것이다(blocking problem). 그리고 멀티프로세서나 멀티코어 환경에서 효율적으로 사용하기 어렵다.</p>\n<p>한 번에 하나의 스레드만 커널에 접근할 수 있기 때문에 실제 연산의 흐름이 하나뿐이기 때문이다.(사용자 스레드에서 아무리 많은 작업을 실행하더라도 결국 실제 연산은 커널 레벨에서 이루어지니까)</p>\n<h3>2.2.2 일대일 모델</h3>\n<p>일대일 모델은 하나의 유저 스레드를 하나의 커널 스레드로 매핑한다. 하나의 스레드가 blocking 시스템 콜을 호출해도 다른 커널 스레드가 연산을 처리할 수 있기 때문에 더 많은 병렬성을 제공한다.</p>\n<p>사용자 스레드를 만들기 위해서는 하나의 커널 스레드를 만들어야 하기 때문에 커널 스레드가 많아지면 많아질수록 오버헤드가 커진다는 것이 단점이다. 윈도우, 리눅스에서 이 모델을 쓴다.</p>\n<h3>2.2.3 다대다 모델</h3>\n<p>다대다 모델은 여러 유저 스레드를 그보다 작거나 같은 수의 커널 스레드로 매핑한다. 이때 커널 스레드 수는 기기나 응용 프로그램에 따라 다르다.</p>\n<p>다대다 모델에서는 사용자가 원하는 만큼 유저 스레드를 생성할 수 있다. 그리고 거기에 대응되는 커널 스레드가 병렬로 수행될 수 있고 blocking 시스템 콜을 호출해도 다른 커널 스레드가 연산을 처리할 수 있다.</p>\n<p>즉 다대다 모델에서 사용자는 원하는 만큼 유저 스레드를 생성한다. 운영체제는 그 유저 스레드들에 대응하는 커널 스레드를 여러 개 만들어서 알아서 유저스레드-커널스레드를 대응시킨다.</p>\n<h3>2.2.4 2수준 모델</h3>\n<p>다대다 모델의 변형이다. 이는 여전히 사용자 스레드 N개에 대해 N보다 작거나 같은 커널 스레드를 대응시킨다. 하지만 특정 사용자 스레드를 위해서는 커널 스레드와의 1-1 매핑을 제공한다. 이는 빨리 처리해야 하거나 점유율이 높은 사용자 스레드를 빠르게 처리하는 데에 유리하다.</p>\n<p>다대다 모델이 제일 좋아 보이지만 실제로는 구현이 어렵다. 또한 대부분의 시스템에서 처리 코어 수가 많기에 커널 스레드 수를 제한하는 것의 중요성이 줄었다. 따라서 윈도, 리눅스 등 대부분의 운영체제에서 일대일 모델을 채택하고 있다.</p>\n<h2>2.3 스레드와 코어</h2>\n<p>그럼 유저스레드와 커널 스레드는 어떻게 상호작용하는가? 일단 다대다 모델을 채택하는 시스템에서는 대부분 유저 스레드와 커널 스레드 간에 중간 자료구조를 둔다. 이것이 가상 프로세서(virtual processor)이다. 경량 프로세스(LightWeight Processor, LWP)라고도 한다.</p>\n<p>아무튼 사용자 스레드 라이브러리는 실행될 유저스레드를 선택하고 LWP를 구성함으로써 사용자 레벨 스케줄링을 한다. LWP는 또 각각 하나의 커널 스레드에 매핑되어 있다.</p>\n<p>즉 사용자가 사용자 스레드 라이브러리를 이용해 스레드들에 작업을 할당하면 라이브러리는 알아서 스케줄링을 하고 LWP를 구성한다. 그리고 커널에서는 LWP들을 이용해 물리적인 코어들에 작업을 스케줄링하는 것이다.</p>\n<p>따라서 진짜 병렬성이라고 할 수 있는 건 사실 사용자 스레드가 여러 개 있는 것이 아니고 물리적인 코어가 여러 개 있는 것이다. 스레드와 코어가 1:1 대응이 될 때 true parallelism을 실현할 수 있다.</p>\n<h1>3. 스레드 풀</h1>\n<p>요청이 있을 때마다 스레드를 매번 만들어 주고 요청이 끝나면 없애 주는 것은 물론 프로세스에 대해 그런 일을 하는 것보다는 효율적이지만 여전히 비용이 드는 작업이다. 이를 해결하는 방법 중 하나가 스레드 풀이다. 프로세스를 시작할 때 일정한 수의 스레드들을 pool로 만들어 주고 요청이 올 때마다 풀에서 스레드를 할당해 주는 방식이다.</p>\n<p>만약 풀에 사용 가능한 스레드가 없다면 사용 가능한 스레드가 생길 때까지 작업이 대기된다. 또한 요청을 완료한 스레드는 다시 사용 가능한 상태로 풀에 돌아간다.</p>\n<p>이렇게 하면 새 스레드를 만들어서 요청에 대응하는 것보다 기존 스레드를 사용하는 게 더 빠르기 때문에 더 빠르게 스레드를 활용할 수 있다. 또한 존재할 수 있는 스레드 개수에 제한을 둘 수 있다. 스레드 개수는 풀의 크기를 넘어갈 수 없기 때문이다.</p>\n<h1>4. 스레드와 관련된 문제들</h1>\n<h2>4.1 fork, exec 시스템 콜</h2>\n<p>멀티스레드 환경에서는 fork에 문제가 좀 있다. 한 프로그램의 스레드가 fork를 호출했다면 새 프로세스는 fork를 호출한 그 스레드만 복제해야 하는가, 아니면 모든 스레드를 다 복제해야 하는가?</p>\n<p>이는 exec에 달렸다. 만약 fork 이후 exec가 실행된다면 어차피 자식 프로세스는 exec의 매개변수로 전달된 프로그램으로 대체될 것이므로 모든 스레드를 복제할 필요가 없다(즉 fork를 호출한 스레드만 복제하면 된다).</p>\n<p>그러나 fork 후에 exec를 하지 않는다면 모든 스레드를 다 복사해 줘야 한다. 몇몇 유닉스 기종은 이러한 2가지 fork를(모든 스레드 전부 복사하는 fork, fork를 호출한 스레드만 복사하는 fork)모두 지원한다.</p>\n<h2>4.2 신호</h2>\n<p>신호는 유닉스 시스템에서 어떤 특정한 이벤트가 발생했다고 알려주는 데 쓰인다. 신호에는 동기식(synchronous)신호와 비동기식(asynchronous) 신호가 있다. 둘의 차이는 다음과 같다.</p>\n<ul>\n<li>\n<p>동기식 신호 : 신호를 발생시킨 연산을 수행한 프로세스와 같은 프로세스로 전달되는 신호. 허용되지 않은 메모리 접근이나 0으로 나누는 등의 신호이다.</p>\n</li>\n<li>\n<p>비동기식 신호 : 실행 중인 프로세스 외부로부터 발생한 신호. <code>Ctrl+C</code> 와 같이 특정 키 입력에 의해 프로세스가 종료되거나 타이머 만료, kill 명령어를 통한 프로세스 종료 등이 있다. A 프로세스를 종료시키는 신호는 A 프로세스 외부에서 오는 것이 자연스럽다.</p>\n</li>\n</ul>\n<p>그런데 이 신호를 어떻게 처리할지에서도 문제가 발생한다. 각 프로세스가 단일 스레드만 가진다면 간단하다. 신호가 발생하면 프로세스에 그냥 전달하면 된다. 어차피 그 신호를 받을 스레드는 하나뿐일 것이기 때문이다.</p>\n<p>문제는 하나의 프로세스가 여러 스레드를 가질 때 발생한다. 어떤 프로세스가 신호를 받았다면 그 신호를 프로세스 내의 어떤 스레드에 전달할 것인가? 다음과 같은 선택지들이 있다.</p>\n<ul>\n<li>\n<p>신호가 적용될 스레드에 전달</p>\n</li>\n<li>\n<p>프로세스 내 모든 스레드에 전달</p>\n</li>\n<li>\n<p>몇몇 스레드를 선택해 전달</p>\n</li>\n<li>\n<p>특정 스레드를 지정해 모든 신호를 전달받도록 설정</p>\n</li>\n</ul>\n<h2>4.3 스레드 취소</h2>\n<p>스레드가 끝나기 전에 강제 종료하는 경우가 있을 수 있다. 이렇게 취소되어야 할 스레드를 target thread라고 한다. 이런 스레드 취소엔 2가지 방식이 있다.</p>\n<ul>\n<li>\n<p>비동기식 취소(asynchronous cancellation) : 타깃 스레드를 즉시 종료. pthreads에선 이렇게 스레드를 즉시 종료하는 함수로 pthread_cancel(tid)를 제공한다. 문제는 target thread에 할당된 자원을 온전히 회수하지 못할 수도 있다는 것이다.</p>\n</li>\n<li>\n<p>지연 취소(deferred cancellation) : 목적 스레드가 주기적으로 자신이 종료되어야 할지를 점검하도록 한다. 그리고 만약 종료되어야 한다면 종료한다. 예를 들어 pthreads api에선 pthread_testcancel 이라는 함수를 제공한다. 이 함수는 스레드에 대해 취소 요청이 보류중인 걸로 확인되면 스레드를 취소시킨다.</p>\n</li>\n</ul>\n<h2>4.4 Thread Local Storage(TLS)</h2>\n<p>TLS는 각 스레드가 가지는, 자신만이 접근할 수 있는 데이터 영역이다. 함수 하나에 종속된 지역 변수가 아니라 전체 함수 호출에 걸쳐서 보인다는 점에서 static과 비슷하다.</p>\n<p>예를 들어서 A라는 함수가 있고 TLS의 특정 변수를 1씩 증가시키는 역할을 한다고 하자. 그러면 A라는 함수가 실행될 때마다 TLS의 그 변수는 0부터 시작한다고 하면 1,2,3...으로 늘어나는 식으로 작동하는 것이다. 단 다른 스레드에서의 그 변수는 여전히 0일 것이다.</p>\n<h1>참고</h1>\n<p>사용자 스레드와 커널 스레드에 관하여 <a href=\"https://www.crocus.co.kr/1255\">https://www.crocus.co.kr/1255</a></p>",
    "excerpt": "운영체제 4단원, 스레드와 병행성 부분을 정리한다.\n1. 스레드\n하나의 프로세스가 오직 하나의 실행 흐름만 가지고 있다고 하자. 그러면 하나의 어플리케이션은 여러 프로세스를 만들어야 한다. 예를 들어서 웹브라우저에 관련된 프로세스는 하나는 웹페이지를 렌더링하고 하나는 네트워크에서 데이터를 검색한다고 생각할 수 있다.\n하지만 이렇게 하나의 어플리케이션을 여러 프로세스로 나누는 것은 비효율적이다. 프로세스 생성 횟수도 많아지고, 컨텍스트 스위칭도 많이 발생하고 프로",
    "headingTree": [
      {
        "title": "1. 스레드",
        "url": "#1-스레드",
        "items": [
          {
            "title": "1.1 스레드의 개념",
            "url": "#11-스레드의-개념",
            "items": []
          },
          {
            "title": "1.2 멀티코어 프로그래밍",
            "url": "#12-멀티코어-프로그래밍",
            "items": []
          }
        ]
      },
      {
        "title": "2. 다중 스레드 모델",
        "url": "#2-다중-스레드-모델",
        "items": [
          {
            "title": "2.1 스레드의 유형",
            "url": "#21-스레드의-유형",
            "items": [
              {
                "title": "2.1.1 사용자 스레드",
                "url": "#211-사용자-스레드",
                "items": []
              },
              {
                "title": "2.1.2 커널 스레드",
                "url": "#212-커널-스레드",
                "items": []
              }
            ]
          },
          {
            "title": "2.2 스레드 매핑 모델",
            "url": "#22-스레드-매핑-모델",
            "items": [
              {
                "title": "2.2.1 다대일 모델",
                "url": "#221-다대일-모델",
                "items": []
              },
              {
                "title": "2.2.2 일대일 모델",
                "url": "#222-일대일-모델",
                "items": []
              },
              {
                "title": "2.2.3 다대다 모델",
                "url": "#223-다대다-모델",
                "items": []
              },
              {
                "title": "2.2.4 2수준 모델",
                "url": "#224-2수준-모델",
                "items": []
              }
            ]
          },
          {
            "title": "2.3 스레드와 코어",
            "url": "#23-스레드와-코어",
            "items": []
          }
        ]
      },
      {
        "title": "3. 스레드 풀",
        "url": "#3-스레드-풀",
        "items": []
      },
      {
        "title": "4. 스레드와 관련된 문제들",
        "url": "#4-스레드와-관련된-문제들",
        "items": [
          {
            "title": "4.1 fork, exec 시스템 콜",
            "url": "#41-fork-exec-시스템-콜",
            "items": []
          },
          {
            "title": "4.2 신호",
            "url": "#42-신호",
            "items": []
          },
          {
            "title": "4.3 스레드 취소",
            "url": "#43-스레드-취소",
            "items": []
          },
          {
            "title": "4.4 Thread Local Storage(TLS)",
            "url": "#44-thread-local-storagetls",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 90
    },
    "url": "/posts/os-3",
    "thumbnail": {
      "local": "/static/parallel-60be7dce.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-parallel-60be7dce-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAADCAIAAAAhqtkfAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAVklEQVR4nAFLALT/AK+3penr6Pf4+vn5+f///5CTihQbAIWKfACRm4HPz8rj4OLs6un49viEh3wADgB/hnMA3N3X1tHQqqSko5ub49zc29vYr7Oq2NrVh8oy+q/CWgEAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "os-4",
    "title": "운영체제 공룡책 5단원 정리",
    "date": "2022-12-04T00:00:00Z",
    "description": "운영체제 5단원 정리",
    "tags": [
      "study",
      "CS"
    ],
    "html": "<p>운영체제 5단원, CPU 스케줄링 부분을 정리한다.</p>\n<h1>1. 기본 개념들</h1>\n<h2>1.1 CPU 스케줄링이란</h2>\n<p>우리는 하나의 프로세서(CPU)에 여러 개의 프로세스를 올려서 멀티프로그래밍을 한다. 이것의 가장 큰 목적은 프로세서가 항상 실행 중인 프로세스를 가지게 해서 CPU 이용률을 최대화하는 것이다. 따라서 어떤 프로세스가 입출력 작업 등으로 인해 대기해야 할 경우 운영체제는 프로세서를 다른 프로세스에 양도한다. 이런 것이 바로 스케줄링이다.</p>\n<p>사실 최신 운영체제에서는 프로세스가 아니라 커널 스레드를 스케줄링한다. 하지만 프로세스 스케줄링, 스레드 스케줄링이라는 용어가 섞여서 쓰인다. 따라서 우리는 스레드에 한정된 개념을 설명할 때만 스레드 스케줄링이라는 용어를 사용하기로 한다.</p>\n<p>이런 스케줄링이 필요한 또다른 이유는 다음과 같다. 프로세스들은 CPU의 실행과 입출력 대기의 사이클로 이루어진다. CPU 실행 -> 입출력 대기 -> CPU 실행...순으로 이루어지는 것이다. 그러나 대부분의 프로세스가 CPU 실행 시간은 짧고 입출력 대기 시간은 상대적으로 긴 I/O bound 프로세스이다. 이런 I/O 처리 시간에 프로세서가 다른 프로세스를 처리할 수 있도록 하는 게 스케줄러이다.</p>\n<h2>1.2 CPU 스케줄러</h2>\n<p>프로세서가 유휴 상태가 될 때마다 운영체제의 스케줄러는 레디 큐의 프로세스 중 하나를 선택해 거기에 CPU를 할당하고 실행한다. 그럼 이런 선택은 어느 상황에 이루어지는가?</p>\n<ol>\n<li>\n<p>프로세스가 실행 상태에서 대기 상태로 전환된다.(I/O 요청 등)</p>\n</li>\n<li>\n<p>프로세스가 실행 상태에서 준비 상태로 전환된다.(인터럽트 등)</p>\n</li>\n<li>\n<p>프로세스가 대기 상태에서 준비 상태로 전환된다(I/O 완료 등)</p>\n</li>\n<li>\n<p>프로세스 종료</p>\n</li>\n</ol>\n<p>1,4의 상황에서는 스케줄러의 선택이 무조건 필요하다. 새로운 프로세스가 선택되어서 실행되어야 한다. 하지만 2,3의 경우 스케줄링을 할지 안 할지 선택할 수 있다. 이 선택에 따라 선점 스케줄링과 비선점 스케줄링이 나뉜다.</p>\n<p>1,4의 경우에만 스케줄링이 일어날 경우 이를 비선점(non-preemptive)스케줄링이라 한다. CPU가 한 프로세스에 할당되면 프로세스가 종료되거나 대기 상태가 될 때까지 그 프로세스가 CPU를 점유한다.</p>\n<p>반면 1,4를 제외한 다른 경우 스케줄링이 일어날 경우 선점(preemptive)스케줄링이라 한다. 한 프로세스가 실행 중에 다른 프로세스가 와서 끼어들고 CPU를 선점하는 게 가능하다는 뜻이다.</p>\n<p>단 선점 스케줄링의 경우, 프로세스들이 특정 데이터를 공유할 때 문제가 생길 수 있다. A 프로세스가 데이터를 수정 중에 있는데 B 프로세스가 와서 CPU를 선점하고 그 데이터를 읽으면 데이터 일관성이 깨질 수 있는 것이다. 이 문제는 mutex등을 이용해 해결할 수 있는데 이것과 관련해서는 6장에서 자세히 다룬다.</p>\n<h2>1.3 디스패처</h2>\n<p>CPU 스케줄링에 관련된 다른 요소로 디스패처가 있다. 디스패처는 스케줄러가 선택한 프로세스에 CPU의 제어를 넘기는 기능을 한다.</p>\n<ul>\n<li>\n<p>한 프로세스에서 다른 프로세스로 컨텍스트 스위칭</p>\n</li>\n<li>\n<p>사용자 모드로 전환</p>\n</li>\n<li>\n<p>프로그램 재시작을 위해 사용자 프로그램의 적절한 위치로 점프</p>\n</li>\n</ul>\n<p>이때 기존에 실행되던 프로세스를 정지하고 PCB를 다른 곳에 저장한 후 새로운 프로세스의 PCB를 불러와 새 프로세스를 실행하는 데까지 걸리는 시간을 dispatch latency라고 한다. 당연히 가능한 한 빨라야 한다.</p>\n<h2>1.4 스케줄링 평가 기준</h2>\n<p>그럼 스케줄링 알고리즘들의 좋은 정도는 어떻게 판단하는가? 다음과 같은 기준들이 있다.</p>\n<ul>\n<li>\n<p>CPU 이용률</p>\n</li>\n<li>\n<p>처리량(throughput) : 단위 시간 당 처리 작업 수. 당연히 많으면 좋다.</p>\n</li>\n<li>\n<p>총 처리 시간(turnaround time) : 프로세스가 CPU를 썼다가 사용 안 하게 될 때까지 걸리는 시간. 즉 프로세스가 처음 CPU를 점유하고 종료할 때까지 걸리는 시간이다. 중간중간 waiting time이나 다른 프로세스가 선점하고 들어와 수행되는 시간까지를 포함한다. 짧으면 좋다.</p>\n</li>\n<li>\n<p>waiting time : 프로세스가 레디 큐에서 대기한 시간들의 합.</p>\n</li>\n<li>\n<p>response time : 하나의 요청 제출 후 첫 응답이 나오기까지 걸리는 시간. 응답이 시작되기까지 걸리는 시간이지 응답을 출력하는 데 걸리는 시간은 포함하지 않는다.</p>\n</li>\n</ul>\n<p>CPU 이용률과 처리량은 당연히 크면 좋고, 나머지는 작으면 좋다. 따라서 일반적으로는 각 기준들의 평균값을 최대/최소로 하려고 한다.</p>\n<p>하지만 대화형 시스템 같은 경우 응답 시간의 편차를 줄이는 것이 응답 시간의 평균값 최소화보다 중요할 수 있다. 이런 상황 등에서 꼭 평균값의 최적화만이 답은 아닐 수 있다.</p>\n<h1>2. 스케줄링 알고리즘</h1>\n<p>본격적으로 스케줄링 알고리즘에 대해 알아보자. 설명의 편의를 위해 스케줄링할 처리 코어는 하나뿐이라고 가정한다. 다음과 같은 알고리즘들을 알아본다.</p>\n<ul>\n<li>\n<p>FCFS(First Come First Served)</p>\n</li>\n<li>\n<p>SJF(Shortest Job First)</p>\n</li>\n<li>\n<p>Priority Scheduling</p>\n</li>\n<li>\n<p>RR(Round-Robin)</p>\n</li>\n<li>\n<p>Multilevel Queue Scheduling</p>\n</li>\n<li>\n<p>Multilevel Feedback Queue Scheduling</p>\n</li>\n</ul>\n<h2>2.1 FCFS</h2>\n<p>이름답게 먼저 온 프로세스부터 먼저 실행하는 방식이다. 당연히 가장 쉽고 구현하기도 쉽다. 그냥 FIFO 큐를 이용해 구현하면 되기 때문이다. 그러나 평균 대기 시간이 길 때가 많고 시분할 시스템(각 프로세스가 규칙적으로 CPU를 얻는 게 중요)에서 특히 좋지 않다. <strong>비선점 스케줄링이다.</strong></p>\n<p>여기서 참여한 각 프로세스의 시작 시간, 종료 시간을 포함해 스케줄링 결과를 표시하는 간트 차트Gantt Chart를 이용해서 알고리즘을 검토하자. 다음과 같은 프로세스들이 도착한다고 하자. Burst time 단위는 ms이다.</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>Process</th><th>Burst Time</th></tr></thead><tbody><tr><td>P1</td><td>24</td></tr><tr><td>P2</td><td>3</td></tr><tr><td>P3</td><td>3</td></tr></tbody></table>\n<p>그러면 Gantt Chart는 다음과 같이 그려진다.</p>\n<pre><code>+----+----+----+----+----+----+----+----+----+----+----+\n|                     P1                     | P2 | P3 |\n+----+----+----+----+----+----+----+----+----+----+----+\n0                                            24   27  30\n</code></pre>\n<p>평균 대기시간은 (0 + 24 +27)/3=17ms이다. 대기 시간이 매우 길다...앞에서 언급했듯이 FCFS가 평균 대기 시간이 길다는 것을 보여준다.</p>\n<p>그러나 만약 P2, P3, P1순으로 프로세스가 실행되면 평균 대기 시간은 (6+0+3)/3=3ms가 된다. 아까는 실행시간이 긴 P1이 다른 모든 프로세스들을 기다리게 해서 대기 시간이 길어진 것이다. 이렇게 수행 시간이 큰 프로세스가 먼제 들어와서 그 뒤의 프로세스들이 불필요하게 기다리게 하는 것을 convoy effect라 한다. 이는 FCFS 스케줄링에서 긴 CPU burst를 가지고 있는 프로세스가 있으면 CPU 이용률이 낮아지는 결과를 낳는다.</p>\n<h2>2.2 SJF</h2>\n<p>각 프로세스에 다음 CPU 버스트 길이를 연관시킨다. 그리고 CPU가 이용 가능해지면 이를 가장 작은 next CPU burst를 가지는 프로세스에 할당한다. 그러니까 가장 빠르게 끝낼 수 있는 작업부터 실행하는 것이다.</p>\n<p>SJF는 주어진 프로세스 집합에 대해 최소의 평균 대기 시간을 가진다는 사실을 증명할 수 있다. 하지만 다음 CPU 버스트의 길이를 아는 것은 불가능하다. 따라서 지난 CPU 버스트의 길이를 이용해서 예측을 해야 한다. 다만 이 근사 알고리즘은 여기서 크게 중요한 부분은 아니고, 그런 이유로 실질적인 구현이 어렵다는 것만 알아두자.</p>\n<p>SJF는 선점형, 비선점형 2가지가 있다. 선점형은 CPU를 할당받은 프로세스가 CPU burst를 끝내기 전에 실행 시간이 더 짧은 다른 프로세스가 도착하면 그 프로세스가 CPU를 빼앗을 수 있다. 비선점형은 CPU를 할당받은 프로세스가 CPU burst를 끝낼 때까지 CPU를 빼앗을 수 없다.</p>\n<p>또한 같은 CPU burst를 가지는 프로세스가 여러 개 있을 때는 어떤 프로세스를 먼저 실행할지 정해야 한다. 이는 FCFS로 간단히 해결할 수 있다.</p>\n<h3>2.2.1 선점형 SJF</h3>\n<p>선점형 SJF의 예시는 다음과 같다.</p>\n<p><img src=\"/static/preemptive_sjf-7815d2a4.png\" alt=\"pre_sjf\"></p>\n<p>각 프로세스의 대기 시간은 다음과 같이 계산된다.\nP1 : 11 - 0(도착 시간) - 2(11ms시점에 이미 수행한 시간) = 9\nP2 : 5 - 2(도착시간) - 2(이미 수행한 시간) = 1\nP3 : 4 - 4(도착시간) = 0 (도착과 동시에 바로 수행되어 끝나기 때문에 대기 0)\nP4 : 7 - 5(도착시간) - 0(이미 수행한 시간) = 2</p>\n<p>평균 대기 시간 (9 + 1 + 0 + 2) / 4 = 3</p>\n<h3>2.2.2 비선점형 SJF</h3>\n<p>선점형 SJF의 예시는 다음과 같다.</p>\n<p><img src=\"/static/nonpreemptive_sjf-b5ec2656.png\" alt=\"nonpre_sjf\"></p>\n<p>P1이 수행되는 동안 실행 시간이 더 짧은 P2, P3이 도착하지만 비선점형이라 CPU를 빼앗지 못하는 것을 볼 수 있다. 그리고 각 프로세스의 대기 시간 계산 시 도착 시간을 빼주어야 하는 것을 기억하자. 대기시간은 레디 큐에 들어가서부터 계산해야 하기 때문이다.</p>\n<p>평균 대기 시간 (0 + 6 + 3 + 7) / 4 = 4\n평균 turnaround time (7 + 10 + 4 + 11) / 4 = 8</p>\n<p>SJF의 문제는 긴 CPU 버스트 시간을 갖는 프로세스가 있고 그 뒤로 계속 짧은 버스트 프로세스가 도착하면 긴 버스트를 갖는 프로세스는 starvation에 시달릴 수 있다는 것이다.</p>\n<h2>2.3 Priority Scheduling</h2>\n<p>각 프로세스는 우선순위를 가지며 우선순위가 높은 프로세스가 먼저 CPU를 할당받는다. 우선순위가 같은 프로세스가 동시에 도착하면 FCFS로 처리한다.</p>\n<p>우선순위 값이 큰 것이 더 빨리 실행되어야 하는지, 혹은 우선순위 값이 작은 것이 더 빨리 실행되어야 하는지는 운영체제마다 다르다. 그저 정해진 우선순위 순서대로 실행되는 것만이 중요하다.</p>\n<p>이 알고리즘의 문제 역시 starvation이다. 우선순위가 높은(즉 먼저 실행되어야 하는) 프로세스가 계속해서 도착하면 우선순위가 낮은 프로세스는 starvation에 시달릴 수 있다.</p>\n<p>일반적으로 이렇게 starvation이 계속되면 시스템의 부하가 적어진 시점에 그 프로세스가 실행되거나 컴퓨터 시스템이 결국 크래시되어 아직 끝나지 않고 starvation에 시달리던 프로세스를 모두 잃어버린다.</p>\n<p>해결책 하나는 aging이다. 시간에 따라 레디 큐에서 대기 중인 프로세스의 우선순위를 점차 높여주는 것이다.</p>\n<p>Priority Scheduling은 비선점형, 선점형 2가지 방식이 모두 가능한데 비선점형의 예시는 다음과 같다.</p>\n<p><img src=\"/static/priority-3adbc13f.png\" alt=\"priority\"></p>\n<p>평균 대기 시간 (6+0+16+18+1)/5=8.2</p>\n<h2>2.4 RR(Round Robin)</h2>\n<p>각 프로세스는 일정 시간(time quantum)만큼 CPU time을 할당받고 그 시간이 지나면 다시 레디 큐의 끝에 가서 대기한다. 이런 방식으로 CPU를 할당받는다. <strong>당연히 선점 스케줄링 방식이다</strong></p>\n<p>프로세스가 N개 있고 time quantum이 Q라고 하면 모든 프로세스는 (N-1)Q 이상은 기다리지 않는다. 일반적으로 SJF에 비해 더 긴 평균 대기 시간을 가진다. 하지만 모든 프로세스가 일정 시간 이상은 기다리지 않고 한 번씩 CPU를 할당받으므로 반응성이 좋다.</p>\n<p>이때 time quantum을 정하는 것이 중요하다. time quantum이 너무 크면 모든 프로세스가 time quantum이 다 지나기 전에 종료되어 버려서 FCFS와 같아진다. 반면 너무 작으면 context switching이 너무 많아져 overhead가 커진다.</p>\n<p>만일 time quantum이 너무 작다면 각 프로세스는 1/N(N은 프로세스 개수)성능의 프로세서를 가진 것과 비슷해지게 된다.</p>\n<p>일반적으로 80%의 CPU버스트가 time quantum보다 작을 정도로 time quantum을 설정해야 좋다고 한다.</p>\n<h2>2.5 Multilevel Queue</h2>\n<p>레디 큐를 여러 개로 나누어서 우선순위를 다르게 준다. 예를 들어 레디 큐를 3개로 나누고 우선순위가 높은 큐부터 차례대로 CPU를 할당한다. 이렇게 하면 우선순위가 높은 프로세스가 더 많은 CPU time을 할당받을 수 있다.</p>\n<p>예를 들어서 대화형 작업을 우선순위가 높은 큐에 할당하고 계산 위주의 batch job을 우선순위가 낮은 큐에 할당하는 식이다. 이렇게 하면 대화형 작업이 더 많은 CPU time을 할당받을 수 있다.</p>\n<p>그리고 각 큐는 다른 스케줄링 알고리즘을 사용할 수 있다. 예를 들어 우선순위가 높은 큐는 SJF, 우선순위가 낮은 큐는 FCFS를 사용할 수 있다.</p>\n<p>또한 큐들 사이의 스케줄링도 필요하다. 각 큐들 간의 우선순위를 미리 정해두는 fixed priority 방식을 사용할 수 있고 이 경우 starvation문제가 발생할 수 있다. 반면 각 큐에 CPU time의 일정 부분을 할당하는 time slice 방식을 사용할 수 있다. 80%의 CPU time을 우선순위가 높은 큐에 할당하고 20%의 CPU time을 우선순위가 낮은 큐에 할당하는 식이다.</p>\n<h2>2.6 Multilevel Feedback Queue</h2>\n<p>Multilevel Queue의 문제점을 해결하기 위해 나온 방식이다. Multilevel Feedback Queue에서는 큐 사이에서 프로세스가 이동하는 것을 허용한다. 예를 들어 너무 오래 걸리는 프로세스는 우선순위가 낮은 큐로 이동한다든지 하는 식이다.</p>\n<p>Multilevel Feedback Queue 스케줄러는 다음과 같은 매개 변수에 의해 정의된다.</p>\n<ul>\n<li>큐 개수</li>\n<li>각 큐의 스케줄링 알고리즘</li>\n<li>프로세스를 상위 큐로 승격시키는 기준</li>\n<li>프로세스를 하위 큐로 강등시키는 기준</li>\n<li>프로세스가 도착할 시 어떤 기준으로 어떤 큐에 넣을지를 결정하는 기준</li>\n</ul>\n<h2>2.7 스케줄링 알고리즘의 평가</h2>\n<p>스케줄링 알고리즘을 평가하는 방법들은 다음과 같은 게 있다.</p>\n<ul>\n<li>결정론적 모델링</li>\n</ul>\n<p>기존에 정의된 특정 프로세스 워크로드들을 정하고 각 알고리즘들이 그 워크로드들을 처리하는 시간을 측정하여 그 시간으로 알고리즘들을 비교한다.</p>\n<ul>\n<li>Queueing Model</li>\n</ul>\n<p>Little's formula를 사용하여 각 알고리즘들의 평균 대기 시간을 계산한다.</p>\n<ul>\n<li>시뮬레이션</li>\n</ul>\n<p>실제 시스템 모델을 실행하고 각 이벤트들을 기록하여 각 알고리즘들의 평균 대기 시간을 계산한다. 이때 시스템을 모니터링하여 이벤트들의 순서를 기록하는 것을 trace tape라고 한다.</p>\n<ul>\n<li>Implementation</li>\n</ul>\n<p>스케줄링 알고리즘 평가에 가장 정확한 방법이다. 실제 운영체제에 각 스케줄링 알고리즘을 넣고 실행해 봄으로써 비교하는 것이다. 하지만 이 방법은 시스템을 구현하는 것이기 때문에 시간이 오래 걸린다.</p>\n<h1>참고</h1>\n<p>박성범 님의 블로그, 공룡책으로 정리하는 운영체제 Ch.5 <a href=\"https://parksb.github.io/article/9.html\">https://parksb.github.io/article/9.html</a></p>",
    "excerpt": "운영체제 5단원, CPU 스케줄링 부분을 정리한다.\n1. 기본 개념들\n1.1 CPU 스케줄링이란\n우리는 하나의 프로세서(CPU)에 여러 개의 프로세스를 올려서 멀티프로그래밍을 한다. 이것의 가장 큰 목적은 프로세서가 항상 실행 중인 프로세스를 가지게 해서 CPU 이용률을 최대화하는 것이다. 따라서 어떤 프로세스가 입출력 작업 등으로 인해 대기해야 할 경우 운영체제는 프로세서를 다른 프로세스에 양도한다. 이런 것이 바로 스케줄링이다.\n사실 최신 운영체제에서는 프로",
    "headingTree": [
      {
        "title": "1. 기본 개념들",
        "url": "#1-기본-개념들",
        "items": [
          {
            "title": "1.1 CPU 스케줄링이란",
            "url": "#11-cpu-스케줄링이란",
            "items": []
          },
          {
            "title": "1.2 CPU 스케줄러",
            "url": "#12-cpu-스케줄러",
            "items": []
          },
          {
            "title": "1.3 디스패처",
            "url": "#13-디스패처",
            "items": []
          },
          {
            "title": "1.4 스케줄링 평가 기준",
            "url": "#14-스케줄링-평가-기준",
            "items": []
          }
        ]
      },
      {
        "title": "2. 스케줄링 알고리즘",
        "url": "#2-스케줄링-알고리즘",
        "items": [
          {
            "title": "2.1 FCFS",
            "url": "#21-fcfs",
            "items": []
          },
          {
            "title": "2.2 SJF",
            "url": "#22-sjf",
            "items": [
              {
                "title": "2.2.1 선점형 SJF",
                "url": "#221-선점형-sjf",
                "items": []
              },
              {
                "title": "2.2.2 비선점형 SJF",
                "url": "#222-비선점형-sjf",
                "items": []
              }
            ]
          },
          {
            "title": "2.3 Priority Scheduling",
            "url": "#23-priority-scheduling",
            "items": []
          },
          {
            "title": "2.4 RR(Round Robin)",
            "url": "#24-rrround-robin",
            "items": []
          },
          {
            "title": "2.5 Multilevel Queue",
            "url": "#25-multilevel-queue",
            "items": []
          },
          {
            "title": "2.6 Multilevel Feedback Queue",
            "url": "#26-multilevel-feedback-queue",
            "items": []
          },
          {
            "title": "2.7 스케줄링 알고리즘의 평가",
            "url": "#27-스케줄링-알고리즘의-평가",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 233
    },
    "url": "/posts/os-4",
    "thumbnail": {
      "local": "/static/preemptive_sjf-7815d2a4.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-preemptive_sjf-7815d2a4-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAFCAIAAAD38zoCAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAiElEQVR4nAF9AIL/AP///z8/PkpJSUs7OnpubUVGRSopKfX19QD///2qqqrCw8S0qqrOyMjo6em6urnr6+oAzs7OhoaGl5eZzcfJ1M/R29rbyMfI9fX1AJqbmxIVBCMpGImQfZOZhoySgJKYg8jLvwD19fWnq56fpZSOlISdoZKXnY2gppavsagq3UuFg8p2YAAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "os-5",
    "title": "운영체제 공룡책 6단원 정리",
    "date": "2022-12-05T00:00:00Z",
    "description": "운영체제 6단원 정리",
    "tags": [
      "study",
      "CS"
    ],
    "html": "<p>운영체제 6단원, 동기화 도구에 관해 정리한다.</p>\n<h1>1. 동기화 도구의 배경</h1>\n<p>앞서 프로세스끼리 영향을 주고받는 방법에는 공유 데이터와 메시지 전달이 있다고 했다. 그런데 공유 데이터를 사용할 때는 동기화 문제가 발생할 수 있다. 예를 들어 A 프로세스가 공유 데이터에 쓰고 있는데 B 데이터도 공유 데이터에 접근해서 쓰기를 시도한다면 어떤 데이터가 공유 데이터에 쓰여질지 알 수 없다.</p>\n<p>이렇게 여러 프로세스가 동일한 데이터에 접근하여 조작하고 실행 결과가 접근의 특정 순서와 어떤 프로세스가 먼저 종료되는지에 따라 달라지는 상황을 race condition이라 한다. 이런 문제를 해결하기 위해 동기화가 필요하다.</p>\n<p>동기화에 요구되는 것은 원자적인 연산인데 원자적 연산이란 연산이 실행되는 동안에는 다른 프로세스가 해당 연산을 실행할 수 없는 연산을 말한다. 예를 들어 공유 데이터에 쓰기를 하는 연산이 원자적이라면 하나의 프로세스가 공유 데이터에 write를 하는 동안 다른 프로세스가 공유 데이터에 쓰기를 시도할 수 없다.</p>\n<p>또한 다중 스레드 환경이 일반적이 되어감에 따라 동기화 문제가 발생할 수 있는 상황이 더 많아졌다. 그래서 동기화 도구의 필요성은 더 증가하고 있다.</p>\n<h1>2. 임계 구역 문제</h1>\n<p>임계 구역(critical section)은 둘 이상의 프로세스가 동시에 접근해서는 안 되는 공유 데이터 영역에 접근하는 코드를 이야기한다. 즉 하나의 프로세스가 임계 구역을 수행하는 동안에는 다른 프로세스들이 그 프로세스의 임계 구역에 접근할 수 없다.</p>\n<p>그리고 임계구역 문제(critical section problem)은 프로세스들이 각자의 활동을 동기화할 때 사용할 수 있는 프로토콜을 설계하고 임계 구역에서 하나의 프로세스만 실행되도록 하는 문제를 말한다.</p>\n<h2>2.1 문제 해결의 조건</h2>\n<p>임계 구역 문제를 해결하는 방법은 여러 가지가 있다. 그러나 어떤 방법이든 다음 조건을 충족해야 한다.</p>\n<ol>\n<li>상호 배제(mutual exclusion) : 임계 구역에는 하나의 프로세스만 접근할 수 있다.</li>\n<li>진행(progress) : 자신의 임계구역에서 실행되고 있는 프로세스가 없고 각자의 임계구역에 진입하고자 하는 프로세스들이 있다면 그 임계구역에 진입하고자 하는 프로세스의 선택은 무기한 연기될 수 없다. 이 말은 임계 구역에서 작업중인 프로세스가 없고 거기에 진입하고자 하는 프로세스가 있다면 그 프로세스는 무기한 연기되지 않고 임계 구역에 진입할 수 있어야 한다는 것이다.</li>\n<li>한정된 대기(bounded waiting) : 특정 프로세스가 자신의 임계 구역에 진입하고자 하는 요청을 한 이후 그 요청의 허용까지, 다른 프로세스들이 각자의 임계 구역에 진입하도록 하는 횟수에 제한이 있어야 한다. 즉 임계구역에 진입하고자 하는 프로세스를 무한정 기다리게 해선 안된다.</li>\n</ol>\n<h2>2.2 용어 정리</h2>\n<p>critical section과 관련된 용어들을 정리한다.</p>\n<ul>\n<li>entry section : 각 프로세스는 자신의 임계구역으로 진입하기 위해 진입 허가를 요청한다. 임계 구역에 진입하기 위한 이런 요청을 보내는 부분을 entry section이라고 한다.</li>\n<li>exit section : 임계 구역에서 실행을 마치고 나가기 위해 임계 구역을 떠나는 부분을 exit section이라고 한다.</li>\n<li>remainder section : entry section, critical section, exit section을 제외한 나머지 부분을 remainder section이라고 한다.</li>\n</ul>\n<p>일반적인 프로세스의 구조는 다음과 같다.</p>\n<pre><code class=\"language-c\">while(true){\n  entry section;\n  critical section;\n  exit section;\n  remainder section;\n}\n</code></pre>\n<h2>2.3 생각할 수 있는 해결책</h2>\n<p>Peterson's Algorithm이라는 해결책이 있지만 먼저 단순하게 생각할 수 있는 해결책을 생각해보자.</p>\n<p>프로세스는 P0, P1 2가지밖에 없다고 생각하자. 그럼 먼저 다음과 같은 해결책을 생각할 수 있다.</p>\n<h3>2.3.1 첫번째 시도</h3>\n<p>turn이라는 변수를 두어서, 초기에는 turn=0이고 만약 turn==i이면 Pi, 즉 i번 프로세스가 임계 구역에 진입할 수 있다고 가정하자. 그럼 다음과 같은 코드를 i번 프로세스에서 실행하는 해결책을 생각할 수 있다.</p>\n<pre><code class=\"language-c\">do{\n  while(turn != i);\n  // critical section\n  turn = j;\n  // remainder section\n}while(1);\n</code></pre>\n<p>프로세스 0이 시작하고 임계 구역에서 작업하고, 그게 끝나고 나면 다른 프로세스(여기서는 넘길 프로세스가 1뿐)에 임계 구역을 넘기고 하면서 잘 작동할 것처럼 보인다.</p>\n<p>하지만 이는 progress 조건을 위배한다. turn==0이고 P1이 준비 상태가 되어 임계 구역에 진입하려고 하면 turn!=1이기 때문에 P1은 계속해서 while문을 돌게 된다. 그러면 P1은 계속해서 임계 구역에 진입할 수 없게 된다.</p>\n<h3>2.3.2 두번째 시도</h3>\n<p>프로세스 개수만큼의 원소를 갖는 boolean flag[N]를 선언한다. 여기서는 프로세스가 2개이므로 flag[2] 이다. 초기값은 모두 false로 한다. 그리고 flag[i]가 true이면 i번 프로세스가 준비된 것이라고 가정하자. 그럼 다음과 같은 코드를 i번 프로세스에서 실행하는 해결책을 생각할 수 있다.</p>\n<pre><code class=\"language-c\">do{\n  flag[i] = true;\n  while(flag[j]);\n  // critical section\n  flag[i] = false;\n  // remainder section\n}while(1);\n</code></pre>\n<p>이 코드는 상호 배제를 만족하지만 역시 progress에서 안된다. P0에서 flag[0]이 true가 되고 P0이 critical section에 진입하기 전에 P1에서 flag[1]을 true로 만들게 되면(flag[0], flag[1] 모두 true) 아직 임계 구역에는 아무 프로세스도 진입하지 않았는데 P0, P1 모두 무한히 대기하게 된다.</p>\n<p><img src=\"/static/algo2-a36c0ad1.png\" alt=\"algo2\"></p>\n<h3>2.3.3 세번째 시도(Peterson's Algorithm)</h3>\n<p>turn, flag 모두 사용한다. turn==i이면 i번째 프로세스가 임계 구역에 진입할 수 있다고 가정하자. 그리고 flag[i]가 true이면 i번 프로세스가 준비된 것이라고 가정하자. 그럼 다음과 같은 코드를 i번 프로세스에서 실행하는 해결책을 생각할 수 있다.</p>\n<pre><code class=\"language-c\">do{\n  flag[i] = true;\n  turn = j;\n  while(flag[j] &#x26;&#x26; turn == j);\n  // critical section\n  flag[i] = false;\n  // remainder section\n}while(1);\n</code></pre>\n<p>i번 프로세스는 임계 구역으로 진입하기 위해 먼저 flag[i]를 true로 만들고 turn을 j로 지정한다. 만약 j번 프로세스가 준비가 된다면 프로세스에 진입할 수 있도록 하기 위해서이다.</p>\n<p>두 프로세스가 동시에 진입을 원한다고 해도 결국 turn이 어떤 값이 되는지에 따라서 임계 구역에 진입하는 프로세스가 결정될 것이다.</p>\n<p>이 방식은 앞의 3가지 조건을 모두 만족한다. 하지만 최신 컴퓨터 아키텍처에서는 컴파일러가 종속성 없는 읽기/쓰기 작업의 순서를 변경할 가능성이 있기 때문에 Peterson's Algorithm은 최신 컴퓨터 아키텍처에서의 동작을 보장할 수 없다.</p>\n<p>또다른 상호 배제 알고리즘으로 Dekker's Algorithm이 있다. 여기 관심 있다면 다음 링크를 참고한다. <a href=\"https://cs.stackexchange.com/questions/12621/contrasting-peterson-s-and-dekker-s-algorithms\">Peterson's Algorithm, Dekker's Algorithm difference</a>, <a href=\"https://www.crocus.co.kr/1370\">crocus 블로그의 Dekker's Algorithm</a></p>\n<p>하지만 앞서 살펴본 알고리즘들은 모두 최신 컴퓨터 아키텍처에서의 동작을 보장할 수 없다. 따라서 우리는 앞으로 설명할 적절한 동기화 도구를 사용해야 한다. 이 동기화 도구는 하드웨어적인 지원부터 고수준 API까지 다양하다. 하나씩 보자.</p>\n<h1>3. 동기화를 위한 하드웨어 지원</h1>\n<h2>3.1 Memory Barrier</h2>\n<p>앞서 보았던 Peterson's Algorithm의 문제는 시스템이 명령어 순서를 재정렬할 수 있다는 점에서 온다. 즉 한 프로세스의 메모리 변경 사항이 다른 프로세스에게 즉시 반영되지 않을 수 있다는 것이다. 이러한 문제를 해결하기 위해 하드웨어적으로 지원하는 동기화 기능이 바로 Memory Barrier이다.</p>\n<p>Memory Barrier 명령어는 시스템에서 후속으로 오는 load, store 연산이 실행되기 전에 현재 프로세스에서 진행되고 있는 저장 작업이 메모리에서 완료되도록 한다. 그래서 그 후의 load, store 연산이 메모리에 반영된 최신 값을 읽거나 쓸 수 있도록 한다.</p>\n<p>즉 한 프로세서의 메모리 변경 결과가 다른 프로세서들에게 모두 보이도록 하여 메모리를 동기화하는 것이다.</p>\n<h2>3.2 하드웨어 명령어</h2>\n<p>현대의 시스템들은 인터럽트되지 않고 원자적으로 연산을 해주는 특별한 하드웨어 명령어를 제공한다. 이런 명령어를 사용하면 임계 구역 문제들을 간단하게 해결할 수 있다. 이 명령어들을 이용해서 lock을 조작해 주는 방식이다. 대표적으로 TestAndSet, Swap 명령어를 들 수 있다.</p>\n<p>이런 명령은 예를 들어서 C++의 atomic 헤더에서 제공된다. 이 헤더는 원자적 변수나 플래그 타입도 제공하는데 이 변수, 타입들을 조작하는 것이다. 예를 들어 <code>atomic_flag_test_and_set</code>과 같은 함수들이 제공된다. <a href=\"http://fienestar.tistory.com/\">이를 알려준 사람</a></p>\n<h3>3.2.1 Test and Set</h3>\n<p>TestAndSet 명령은 한 워드의 내용을 검사하고 변경한다.</p>\n<pre><code class=\"language-c\">// 다음 연산은 원자적으로 진행된다.\nint TestAndSet(int *target) {\n    int rv = *target;\n    *target = TRUE;\n    return rv;\n}\n</code></pre>\n<p>중요한 건 이 명령이 atomic하게 실행된다는 것이다. 따라서 TestAndSet 명령을 이용해서 lock을 구현하면 상호 배제를 쉽게 구현할 수 있다.</p>\n<pre><code class=\"language-c\">do{\n  while(TestAndSet(&#x26;lock));\n  // critical section\n  lock = FALSE;\n  // remainder section\n} while(TRUE);\n</code></pre>\n<p>임계 구역 접근이 끝나고 나면 lock 변수를 FALSE로 바꾸어 다른 프로세스가 접근할 수 있도록 한다. 단 이 코드는 lock 변수가 TRUE일 경우 프로세스가 준비되어도 계속해서 대기하게 된다. 즉 bounded waiting은 만족하지 못한다.</p>\n<h3>3.2.2 Swap</h3>\n<p>Swap 명령은 두 워드의 내용을 교환한다.</p>\n<pre><code class=\"language-c\">void Swap(bool *x, bool *y) {\n    bool tmp = *x;\n    *x = *y;\n    *y = tmp;\n}\n</code></pre>\n<p>Swap 명령을 이용해서 lock을 조작해 상호 배제를 구현하면 다음과 같다.</p>\n<pre><code class=\"language-c\">//lock은 초기에 false로 설정되어 있다.\ndo{\n  key=TRUE;\n  while(key==TRUE){\n    Swap(&#x26;key, &#x26;lock);\n  }\n  // critical section\n  lock=FALSE;\n  // remainder section\n} while(TRUE);\n</code></pre>\n<p>이 역시 lock 변수가 TRUE일 경우 프로세스가 준비되어도 계속해서 대기하게 된다. 즉 bounded waiting은 만족하지 못한다. bounded waiting까지 만족하는 코드는 waiting 배열까지 사용하여 다음과 같이 작성할 수 있다.</p>\n<p>waiting 배열의 초기값과 lock 변수의 초기값은 모두 FALSE로 설정한다. 다음 코드는 i번 프로세스에서 실행되는 코드이다.</p>\n<pre><code class=\"language-c\">do{\n  waiting[i]=TRUE; key=TRUE;\n  while(waiting[i]==TRUE &#x26;&#x26; key==TRUE){\n    Swap(&#x26;key, &#x26;lock);\n  }\n  waiting[i]=FALSE;\n  // critical section\n  j=(i+1)%n;\n  while(j!=i &#x26;&#x26; waiting[j]==FALSE) j=(j+1)%n;\n  if(j==i) lock=FALSE;\n  else waiting[j]=FALSE;\n  // remainder section\n} while(TRUE);\n</code></pre>\n<p>이 프로세스가 임계구역에 진입하는 건 waiting[i]==FALSE거나 key==FALSE일 때이다. 그리고 key는 Swap 명령어를 통해서만 FALSE가 될 수 있다. 그리고 waiting[i]가 FALSE가 되는 것은 다른 프로세스가 임계구역을 떠날 때뿐이다. 즉 딱 하나의 프로세스의 waiting[i]만이 FALSE일 수 있다. 따라서 상호 배제가 보장된다.</p>\n<p>그리고 다음 코드를 보자.</p>\n<pre><code class=\"language-c\">while(j!=i &#x26;&#x26; waiting[j]==FALSE) j=(j+1)%n;\n</code></pre>\n<p>이 코드는 하나의 프로세스가 임계 구역을 떠날 때 실행되는데 이 코드는 waiting 배열을 순회하며 waiting이 TRUE인 첫 프로세스를 찾는다. 그리고 그 프로세스의 waiting을 FALSE로 바꾸어 다음 프로세스가 임계 구역에 진입할 수 있도록 한다.</p>\n<p>따라서 임계구역에 들어가고자 하는 프로세스는 n회 내에 언젠가는 임계구역에 진입할 수 있다. bounded waiting이 보장된다.</p>\n<h2>3.3 Atomic Variable</h2>\n<p>어떤 시스템에서는 원자적 연산을 제공하는 변수인 원자적 변수(Atomic Variable)를 제공한다. 이 변수에 대한 연산은 원자적으로 수행된다.</p>\n<p>하지만 보통 임계 구역 문제를 해결하는 데에 쓰이기보다는 공유 데이터 한 개의 원자적 갱신을 보장하는 데에 많이 쓰인다.</p>\n<h1>4. 소프트웨어 도구들</h1>\n<h2>4.1 Mutex lock</h2>\n<p>임계 구역 문제를 해결하기 위한 좀 더 추상화된 소프트웨어 도구들이 있다. 가장 간단한 도구가 바로 mutex lock이다. 이 mutex 는 mutual exclusion의 약자로 상호 배제를 의미한다.</p>\n<p>프로세스가 임계 구역에 진입하고자 할 때 lock을 획득하고, 임계 구역을 떠날 때 lock을 반환한다. 이 때 lock을 획득하고 반환하는 동작은 원자적으로 수행되어야 한다.</p>\n<p>lock을 얻는 acquire, 반환하는 release 함수가 있다고 하자. 이 함수들은 다음과 같이 구현할 수 있다.</p>\n<pre><code class=\"language-c\">acquire(){\n  while(available==FALSE); // busy waiting\n  available=FALSE;\n}\n\nrelease(){\n  available=TRUE;\n}\n</code></pre>\n<p>다른 프로세스가 임계구역을 점유하고 있으면 임계 구역에 들어가려고 하는 다른 프로세스들은 계속 acquire를 호출하면서 기다린다. 이를 busy waiting이라고 한다.</p>\n<p>이러한 busy waiting을 하는 락 유형을 스핀 락이라고도 한다. 락을 사용할 수 있을 때까지 프로세스가 돌고(spin)있기 때문이다. 이 방식은 다른 프로세스가 생산적으로 사용할 수 있는 연산 능력을 낭비할 가능성이 있다. 그러나 프로세스가 임계 구역에 진입할 수 있게 되면 컨텍스트 스위칭 없이 바로 임계 구역에 진입할 수 있다는 장점이 있다.</p>\n<p>따라서 잠깐 동안 락을 유지해야 하는 경우(락이 잠깐만 걸릴 거라고 기대될 때) 스핀 락을 사용하는 경우가 많다. 그리고 멀티프로세서 시스템에서 자주 사용된다.</p>\n<h2>4.2 Semaphore</h2>\n<p>세마포어는 뮤텍스와 비슷하지만 busy waiting이 필요없는 도구이다.</p>\n<p>세마포어 S는 wait, signal 2개의 원자적 연산으로만 접근 가능한 정수 변수이다.</p>\n<pre><code class=\"language-c\">wait(S){\n  while(S&#x3C;=0); // busy waiting\n  S--;\n}\n\nsignal(S){\n  S++;\n}\n</code></pre>\n<p>세마포어는 네덜란드 사람인 Edsger Dijkstra가 고안했다. 따라서 wait은 검사를 의미하는 네덜란드어 Proberen에서 따서 P(S), signal은 증가를 의미하는 네덜란드어 Verhogen에서 따서 V(S)라고도 한다.</p>\n<h3>4.2.1 세마포어 종류</h3>\n<p>카운팅 세마포어(counting semaphore)는 세마포어가 가질 수 있는 값에 제한이 없다. 이 세마포어는 임계 구역에 들어갈 수 있는 프로세스의 수를 제한하는 데 쓰일 수 있다.</p>\n<p>이진 세마포어(binary semaphore)는 세마포어가 가질 수 있는 값이 0, 1뿐이다. 카운팅 세마포어보다 구현이 간단하며 mutex lock과 유사하다.</p>\n<h3>4.2.2 세마포어의 활용</h3>\n<p>먼저 N개의 프로세스가 임계 구역을 놓고 경쟁한다고 생각하자. 그러면 초기값 1을 가지는 mutex semaphore를 사용하면 된다.</p>\n<pre><code class=\"language-c\">do{\n  wait(mutex); // mutex&#x3C;=0 이면 대기\n  // 임계 구역\n  signal(mutex); //mutex++\n  // 나머지 구역\n} while(1);\n</code></pre>\n<p>좀더 일반적인 동기화 문제에도 사용 가능하다. 만약 i번 프로세스의 A 작업이 반드시 끝난 후에 j번 프로세스의 B 작업을 진행하고 싶다고 하자. 그러면 초기값이 0인 flag semaphore를 사용하면 된다.</p>\n<pre><code class=\"language-c\">Pi{\n  ...\n  A작업\n  signal(flag); //A작업이 끝나고 나서야 flag를 사용 가능 상태로 만든다.\n}\n\nPj{\n  ...\n  wait(flag); //flag가 1이 될때까지 기다리고 나서 B 작업을 시작한다\n  B작업\n}\n</code></pre>\n<p>세마포어의 좀더 구체적인 구현은 다음 블로그에 있다. <a href=\"https://rebro.kr/176?category=504670\">Rebro님 블로그</a></p>\n<h1>5. 모니터</h1>\n<p>세마포어나 뮤텍스 락을 이용해서 임계 구역 문제를 해결할 때, 프로그래머의 잘못으로 인해 오류가 쉽게 발생할 수 있다. 이를 방지하기 위해 모니터라는 도구를 사용한다. 모니터는 동시 수행 중인 프로세스들 간 추상 데이터의 안전한 공유를 보장한다. 모니터 안에 항상 하나의 프로세스만 활성화되는 것을 보장하기 때문이다.</p>\n<p><img src=\"/static/monitor-1cab74fd.png\" alt=\"monitor\"></p>\n<p>모니터 내부에서 어떤 프로세스의 동기화를 제공하기 위해서는 condition 구조체가 제공된다. condition x, y; 와 같이 선언될 수 있다.</p>\n<p>이 condition 변수에는 오직 wait, signal 함수만이 제공된다. 예를 들어 x.wait()을 호출한 프로세스는 다른 프로세스가 x.signal()을 호출할 때까지 일시 중지되는 식으로 사용할 수 있다.</p>\n<p>그리고 x.signal()의 호출은 딱 하나의 일시 중지된 프로세스를 재개한다. 만약 일시 중지된 프로세스가 없다면, x.signal()은 아무런 일도 하지 않는다. x,y는 모니터 내부의 세마포어 같은 역할을 하는 것이다. 단 세마포어의 signal 연산과는 달리 아무 일도 하지 않을 가능성이 있다는 점이 차이이다.</p>\n<h2>5.1 모니터에서의 Signal 관련 문제</h2>\n<p>모니터 내의 프로세스 P에서 x.signal() 이 호출되었다고 하자. 그리로 x.wait()에 의해 중지되었던 모니터 내의 다른 프로세스 Q가 있다. x에 의해 중지된 프로세스는 Q 하나라고 하자. 그러면 P는 기존에 실행 중이었는데 x.signal()에 의해 Q 또한 재개되어야 한다. 하지만 모니터 내에서는 단 하나의 프로세스 활성화만 허용한다.</p>\n<p>2가지 방법이 있다.</p>\n<ul>\n<li>Signal and Wait : P는 Q가 모니터를 떠날 때까지 기다린다. 그러면 Q가 모니터를 떠나면 P가 다시 활성화된다.</li>\n<li>Signal and Continue : Q는 P가 모니터를 떠날 때까지 기다린다.</li>\n</ul>\n<p>P가 이미 모니터 내에서 실행되고 있었기 때문에 signal and continue 방법이 더 합리적인 것 같다. 따라서 이게 pthread 등에서 널리 사용되는 방법이다.</p>\n<p>하지만 signal and continue에선 P에서 Q가 기다리고 있는 어떤 논리적인 조건을 바꿔 버릴 수도 있기 때문에 signal and wait도 나름의 장점이 있다.</p>\n<h1>6. Liveness Problem</h1>\n<p>Liveness는 프로세스가 무한정 기다리지 않고, 언젠가는 무언가를 하게 되는 것을 의미한다. 예를 들어 무한루프로 인해 프로세스가 영원히 실행되지 못하는 것은 liveness failure이다. 다음과 같은 예시들이 있다.</p>\n<h2>6.1 Deadlock</h2>\n<p>2개 이상인 프로세스들이 대기 중이며 대기 중인 프로세스들 중 하나에 의해서만 발생할 수 있는 이벤트가 발생할 때 까지 무한정 기다리는 것이다.</p>\n<p>2개의 프로세스 P0, P1이 있고 1로 초기화된 세마포어 S,Q에 접근한다고 하자.</p>\n<pre><code class=\"language-c\">P0\nwait(S);\nwait(Q);\n...\nsignal(S);\nsignal(Q);\n\nP1\nwait(Q);\nwait(S);\n...\nsignal(Q);\nsignal(S);\n</code></pre>\n<p>P0이 wait(S)를 실행하고 P1이 wait(Q)를 실행한다. 각자 다음 wait으로 넘어가기 위해서는 다른 프로세스에서 signal을 호출해 줘야 한다. 이런 게 deadlock(교착)이다.</p>\n<h2>6.2 Starvation</h2>\n<p>프로세스가 무한히 block되는 것이다. 중단된 상태로 영원히 세마포어의 웨이팅 리스트에서 제거되지 못하는 것을 말한다. 예를 들어 락을 다시 획득할 때 락을 기다리고 있던 프로세스들 중에서 우선순위가 가장 높은 프로세스가 락을 획득한다고 하자.</p>\n<p>그리고 락의 웨이팅 리스트에는 계속 새로운 프로세스가 추가되고 있다고 하자. 그러면 락의 웨이팅 리스트에 있는 프로세스 중 우선순위가 낮은 프로세스는 무한에 가깝게 기다리게 될 수 있다. 이런 게 starvation이다.</p>\n<h2>6.3 Priority Inversion</h2>\n<p>우선순위가 높은 프로세스가 우선순위가 낮은 프로세스들에 의해 접근되고 있는 커널 데이터(락이 걸려 있음)를 접근해야 할 때 스케줄링에 발생하는 어려움이다.</p>\n<p>예를 들어서 프로세스 A, B, C가 있고 우선순위는 <code>A&#x3C;B&#x3C;C</code>라고 하자. 그리고 C는 A에서 접근하고 있는 커널 데이터에 접근해야 한다. 그러면 커널 데이터엔 락이 걸려 있으므로 C는 A의 데이터 접근이 끝날 때까지 기다리게 된다.</p>\n<p>하지만 B가 나타나서 A를 선점해 버렸다고 하자. 그러면 C는 B보다 우선순위가 높음에도 불구하고 B가 끝날 때까지 기다려야 한다. 이런 게 priority inversion이다.</p>\n<p>A가 데이터 접근중 -> C는 A를 기다림 -> B가 A를 선점 -> C는 A가 끝나기를 기다리기 위해 우선순위가 더 낮은 B를 기다림</p>\n<h1>참고</h1>\n<p>박성범 님의 블로그, 공룡책으로 정리하는 운영체제 Ch6 <a href=\"https://parksb.github.io/article/10.html\">https://parksb.github.io/article/10.html</a></p>\n<p>C++ atomic 헤더 레퍼런스 페이지 <a href=\"https://en.cppreference.com/w/cpp/header/atomic\">https://en.cppreference.com/w/cpp/header/atomic</a></p>",
    "excerpt": "운영체제 6단원, 동기화 도구에 관해 정리한다.\n1. 동기화 도구의 배경\n앞서 프로세스끼리 영향을 주고받는 방법에는 공유 데이터와 메시지 전달이 있다고 했다. 그런데 공유 데이터를 사용할 때는 동기화 문제가 발생할 수 있다. 예를 들어 A 프로세스가 공유 데이터에 쓰고 있는데 B 데이터도 공유 데이터에 접근해서 쓰기를 시도한다면 어떤 데이터가 공유 데이터에 쓰여질지 알 수 없다.\n이렇게 여러 프로세스가 동일한 데이터에 접근하여 조작하고 실행 결과가 접근의 특정 ",
    "headingTree": [
      {
        "title": "1. 동기화 도구의 배경",
        "url": "#1-동기화-도구의-배경",
        "items": []
      },
      {
        "title": "2. 임계 구역 문제",
        "url": "#2-임계-구역-문제",
        "items": [
          {
            "title": "2.1 문제 해결의 조건",
            "url": "#21-문제-해결의-조건",
            "items": []
          },
          {
            "title": "2.2 용어 정리",
            "url": "#22-용어-정리",
            "items": []
          },
          {
            "title": "2.3 생각할 수 있는 해결책",
            "url": "#23-생각할-수-있는-해결책",
            "items": [
              {
                "title": "2.3.1 첫번째 시도",
                "url": "#231-첫번째-시도",
                "items": []
              },
              {
                "title": "2.3.2 두번째 시도",
                "url": "#232-두번째-시도",
                "items": []
              },
              {
                "title": "2.3.3 세번째 시도(Peterson's Algorithm)",
                "url": "#233-세번째-시도petersons-algorithm",
                "items": []
              }
            ]
          }
        ]
      },
      {
        "title": "3. 동기화를 위한 하드웨어 지원",
        "url": "#3-동기화를-위한-하드웨어-지원",
        "items": [
          {
            "title": "3.1 Memory Barrier",
            "url": "#31-memory-barrier",
            "items": []
          },
          {
            "title": "3.2 하드웨어 명령어",
            "url": "#32-하드웨어-명령어",
            "items": [
              {
                "title": "3.2.1 Test and Set",
                "url": "#321-test-and-set",
                "items": []
              },
              {
                "title": "3.2.2 Swap",
                "url": "#322-swap",
                "items": []
              }
            ]
          },
          {
            "title": "3.3 Atomic Variable",
            "url": "#33-atomic-variable",
            "items": []
          }
        ]
      },
      {
        "title": "4. 소프트웨어 도구들",
        "url": "#4-소프트웨어-도구들",
        "items": [
          {
            "title": "4.1 Mutex lock",
            "url": "#41-mutex-lock",
            "items": []
          },
          {
            "title": "4.2 Semaphore",
            "url": "#42-semaphore",
            "items": [
              {
                "title": "4.2.1 세마포어 종류",
                "url": "#421-세마포어-종류",
                "items": []
              },
              {
                "title": "4.2.2 세마포어의 활용",
                "url": "#422-세마포어의-활용",
                "items": []
              }
            ]
          }
        ]
      },
      {
        "title": "5. 모니터",
        "url": "#5-모니터",
        "items": [
          {
            "title": "5.1 모니터에서의 Signal 관련 문제",
            "url": "#51-모니터에서의-signal-관련-문제",
            "items": []
          }
        ]
      },
      {
        "title": "6. Liveness Problem",
        "url": "#6-liveness-problem",
        "items": [
          {
            "title": "6.1 Deadlock",
            "url": "#61-deadlock",
            "items": []
          },
          {
            "title": "6.2 Starvation",
            "url": "#62-starvation",
            "items": []
          },
          {
            "title": "6.3 Priority Inversion",
            "url": "#63-priority-inversion",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 2,
      "wordCount": 583
    },
    "url": "/posts/os-5",
    "thumbnail": {
      "local": "/static/algo2-a36c0ad1.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-algo2-a36c0ad1-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAFCAIAAAD38zoCAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAiElEQVR4nAF9AIL/AKyyufTz8/Lv793e39fY3O/u7vTz8////wCwuL6+wsfy8vLEvr60rav9/v7EvLzp5OQAcn6Koqqy09ba1dTUxLu00svHJQMBbVVVAMLHzerr7MLEx+Pk5ujm5NrV0Pn5+vb09AD////u8PHHzNHN0NXT1trIzdLW2tz///+3fGFuHxRpHQAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "os-6",
    "title": "운영체제 공룡책 7단원 정리",
    "date": "2022-12-07T00:00:00Z",
    "description": "운영체제 7단원 정리",
    "tags": [
      "study",
      "CS"
    ],
    "html": "<p>운영체제 7단원, 동기화 관련 예제를 정리한다. 학교 강의에서 그렇게 심도있게 다룬 내용이 아니므로 동기화에 관련된 고전적인 문제들과 해결만 적당히 정리하고 넘어갈 예정이다. 대부분 세마포어가 해결책 중 하나로 사용된다.</p>\n<h1>1. 유한 버퍼 문제</h1>\n<p>유한 버퍼 문제는 생산자-소비자 문제의 일종이다. 생산자 프로세스는 정보를 생산하고 소비자는 정보를 소비한다. 이를 어떻게 구현할 것인가?</p>\n<p>3장에서 공유 메모리를 사용한다는 해결책을 보았다. 생산자는 정보를 버퍼에 채워넣고 소비자는 버퍼에서 정보를 소모한다. 그런데 생산자와 소비자가 함께 버퍼에 접근할 때가 문제이다. 아직 생산되지도 않은 항목을 소비하려고 하면 문제가 생길 것이다. 따라서 동기화가 필요하다.</p>\n<p>다음과 같이 할 수 있다. 먼저 다음과 같은 변수를 선언한다. 이 변수들은 생산자, 소비자가 공유한다. n개의 버퍼로 구성된 pool이 있고 각 버퍼는 항목 하나를 저장할 수 있다고 하자.</p>\n<pre><code class=\"language-c\">int n; // 버퍼 수\nsemaphore mutex = 1; // 버퍼 풀에 접근 가능한 프로세스 수\nsemaphore empty = n; // 비어 있는 버퍼 수\nsemaphore full = 0; // 꽉 찬 버퍼 수\n</code></pre>\n<p>그러면 생산자는 다음과 같이 구현한다. 버퍼가 꽉 차 있다면(즉 비어 있는 버퍼가 없다면)기다린다는 것에 주의해서 보자.</p>\n<pre><code class=\"language-c\">do{\n  ...\n  /* produce an item in next_produced */\n  ...\n  wait(empty); // 비어 있는 버퍼가 있을 때까지 대기\n  wait(mutex); // 버퍼 풀에 접근 가능한 프로세스 수를 1 감소\n  /* add next_produced to the buffer pool */\n  ...\n  signal(mutex); // 버퍼 풀에 접근하는 프로세스 수를 1 증가\n  signal(full); // 꽉 찬 버퍼 수를 1 증가\n}while(1);\n</code></pre>\n<p>소비자는 다음과 같이 구현한다. 버퍼가 비어 있으면 즉 꽉 찬 버퍼가 없으면(full&#x3C;=0) 기다린다는 것에 주의해서 보자.</p>\n<pre><code class=\"language-c\">do{\n  wait(full); // 정보가 들어 있는 버퍼가 있을 때까지 대기\n  wait(mutex); // 버퍼 풀에 접근가능한 프로세스 수를 1 감소\n  ...\n  /* remove an item from buffer pool to next_consumed */\n  ...\n  signal(mutex); // 버퍼 풀에 접근가능한 프로세스 수를 1 증가\n  signal(empty); // 정보를 소모했으므로 비어 있는 버퍼 수 1 증가\n  ...\n  /* consume the item in next_consumed */\n  ...\n}while(1);\n</code></pre>\n<p>소비자에서는 정보를 소모함에 따라 empty를 증가시켜 주고 생산자에서는 empty가 0보다 클 때까지 기다린다. 그리고 생산자는 정보를 생산함에 따라 full을 증가시키고 소비자는 full이 0보다 클 때까지 기다린다.</p>\n<h1>2. Reader-Writer Problem</h1>\n<p>여러 프로세스가 공유하는 데이터에 대하여, 데이터를 읽기만 하는 프로세스와 데이터를 쓰는(갱신하는)프로세스가 분리될 수 있다. 이때 여러 프로세스가 동시에 데이터를 읽는 것은 문제가 없다. 그러나 여러 프로세스가 동시에 데이터를 쓰거나, 하나의 프로세스가 데이터를 쓰는 도중에 다른 프로세스가 데이터를 읽는 건 문제가 될 수 있다.</p>\n<p>이러한 문제를 해결하기 위해 우리는 writer 프로세스는 쓰기 작업 동안 데이터에 대해 독점적인 접근을 갖도록 하고, reader 프로세스는 쓰기 작업이 끝날 때까지 기다리도록 한다.</p>\n<p>reader, writer가 공유하는 데이터로 다음과 같은 변수를 선언한다.</p>\n<pre><code class=\"language-c\">int readcount = 0; // 현재 읽기 작업을 수행하는 프로세스 수\nsemaphore mutex = 1; // readcount에 대한 상호 배제를 위함\nsemaphore wrt = 1; // writer의 상호 배제\n</code></pre>\n<p>writer 프로세스는 다음과 같이 구현한다.</p>\n<pre><code class=\"language-c\">do{\n  // 데이터를 수정할 때 다른 프로세스가 데이터를 읽지 못하도록 한다.\n  wait(wrt); // writer의 상호 배제\n  ...\n  /* write to the shared data */\n  ...\n  signal(wrt); // writer의 상호 배제 해제\n  ...\n  /* do other things */\n  ...\n}while(1);\n</code></pre>\n<p>reader 프로세스는 다음과 같이 구현한다. 누군가 자료를 읽고 있을 때는 wrt 세마포어를 이용해서 writer가 접근하지 못하도록 한다. 또한 이 방식대로라면 한번에 여러 reader도 프로세스에 접근할 수 있다.</p>\n<pre><code class=\"language-c\">do{\n  wait(mutex); // readcount에 대한 상호 배제\n  readcount++;\n  if(readcount == 1) // 지금 이 프로세스가 임계 구역에 진입하는 첫 프로세스라면\n    wait(wrt); // writer의 상호 배제\n  signal(mutex); // readcount에 대한 상호 배제 해제\n  ...\n  /* read from the shared data */\n  ...\n  wait(mutex); // readcount에 대한 상호 배제\n  readcount--;\n  // 지금 읽기를 종료하는 프로세스가 공유 데이터를 읽고 있던 마지막 프로세스라면\n  if(readcount == 0)\n    signal(wrt); // writer의 상호 배제 해제\n  signal(mutex); // readcount에 대한 상호 배제 해제\n  ...\n  /* do other things */\n  ...\n}while(1);\n</code></pre>\n<p>이 방법의 문제는 reader 프로세스가 계속 생성될 경우 writer 프로세스가 starvation에 시달릴 수 있다는 것이다.</p>\n<h1>3. 식사하는 철학자들</h1>\n<p><img src=\"/static/dining-91a7533f.png\" alt=\"dining\"></p>\n<p>유명한 문제다. 하지만 시간 부족으로 일단 시험에서 더 중요한 다음 부분부터 정리한다..</p>",
    "excerpt": "운영체제 7단원, 동기화 관련 예제를 정리한다. 학교 강의에서 그렇게 심도있게 다룬 내용이 아니므로 동기화에 관련된 고전적인 문제들과 해결만 적당히 정리하고 넘어갈 예정이다. 대부분 세마포어가 해결책 중 하나로 사용된다.\n1. 유한 버퍼 문제\n유한 버퍼 문제는 생산자-소비자 문제의 일종이다. 생산자 프로세스는 정보를 생산하고 소비자는 정보를 소비한다. 이를 어떻게 구현할 것인가?\n3장에서 공유 메모리를 사용한다는 해결책을 보았다. 생산자는 정보를 버퍼에 채워넣고",
    "headingTree": [
      {
        "title": "1. 유한 버퍼 문제",
        "url": "#1-유한-버퍼-문제",
        "items": []
      },
      {
        "title": "2. Reader-Writer Problem",
        "url": "#2-reader-writer-problem",
        "items": []
      },
      {
        "title": "3. 식사하는 철학자들",
        "url": "#3-식사하는-철학자들",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 137
    },
    "url": "/posts/os-6",
    "thumbnail": {
      "local": "/static/dining-91a7533f.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-dining-91a7533f-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAIAAABLbSncAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAy0lEQVR4nGP48+fP9+/f////X1CYExoW8P///z9/fv/69Zvh////v379+v//f1VxdmyYN1jiz////xnWrFlz4sSpCcUxya6ipaEa5eHWHz68X7dmFQO/oIithWGGl4QuA4MeA4OPAUNPXS4/CwPDq7cfNy2aYiLI4CLO4CzKYMDGMLsx98XL1yA7Pr19keOn5qTMYC3JkOImeefSaZAd////X75ydZC/V09BWG2ie5Sf9ZaNa6ESEZGRDAwgxv///yV4GAqzEv7//w8A89tt2ezl80gAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "os-8",
    "title": "운영체제 공룡책 10단원 정리",
    "date": "2022-12-19T00:00:00Z",
    "description": "운영체제 10단원 정리",
    "tags": [
      "CS",
      "study"
    ],
    "html": "<p>운영체제 공룡책, 10단원을 정리한다.</p>\n<h1>1. 가상 메모리</h1>\n<p>가상 메모리를 사용하면 프로그램이 메모리에 전부 올라와 있지 않아도 프로그램을 실행할 수 있도록 해준다. 그리고 프로그래머에게 실제 메모리보다 훨씬 큰 메모리를 사용할 수 있도록 해준다. 그로 인해 프로그래머가 물리 메모리의 크기를 걱정할 필요 없도록 해준다.</p>\n<h2>1.1 가상 주소 공간</h2>\n<p>가상 주소 공간(virtual address space)는 프로세스가 메모리에 논리적으로 어떻게 저장되는지를 의미한다. 흔히 우리가 보는 스택, 힙, 데이터, 코드 영역으로 구성된 공간이 바로 가상 주소 공간이다.</p>\n<p><img src=\"/static/space-8cc878b7.png\" alt=\"space\"></p>\n<p>물론 이 공간들은 페이징으로 관리되므로 실제 물리 메모리에 연속적으로 저장되어 있지는 않다. 또한 스택과 힙 사이의 빈 공간도 실제로는 메모리를 차지하고 있지 않다. 스택이나 힙이 확장될 때 실제 물리적인 메모리를 요구하게 될 것이다. 이는 가상 주소 공간의 새 범위를 할당받는 방식으로 이루어진다.</p>\n<p>가상 메모리를 사용하면 2개 이상의 프로세스들이 파일이나 메모리를 공유하는 것도 가능하다.</p>\n<h1>2. 요구 페이징</h1>\n<p>해당 페이지가 필요해질 때만 메모리에 적재하는 것이다. 즉 프로세스가 실행되는 동안 어떤 페이지는 메모리에, 어떤 페이지는 보조 저장 장치(디스크)에 있게 된다. 당연히 메모리를 더 효율적으로 사용할 수 있다.</p>\n<h2>2.1. valid/invalid bit</h2>\n<p>페이지 테이블의 각 엔트리에 valid/invalid bit를 추가한다. 단 앞에서 쓰인 것과 달리 이 비트는 페이지가 메모리에 있는지를 나타낸다. 이 비트가 0이면 해당 페이지가 유효하지 않거나 유효하지만 디스크에 있다는 것을 의미한다. 초기에 어떤 페이지도 적재되어 있지 않다면 모든 엔트리의 비트가 0으로 설정되어 있다.</p>\n<h2>2.2. 페이지 폴트</h2>\n<p>페이지 폴트(page fault)는 프로세스가 메모리에 없는 페이지를 참조할 때 발생한다. 접근하려는 페이지의 유효 비트가 0으로 설정되어 있으면 하드웨어가 페이지 폴트 트랩을 발생시키는 것이다.</p>\n<p>이 트랩은 이렇게 처리한다.</p>\n<ol>\n<li>내부 테이블(일반적으로 Process Control Block에 있다)을 검사해서 그 참조가 유효한지 조사한다. 만약 무효한 참조라면 프로세스를 중단시킨다. 유효한 참조라면 그 페이지를 디스크에서 가져오는 동작을 취한다.</li>\n<li>디스크에서 페이지를 가져오기 위해 먼저 빈 프레임을 찾는다. 그리고 디스크에서 해당 프레임으로 페이지를 읽어 들인 후 페이지 테이블의 엔트리를 갱신한다.</li>\n<li>아까 중단되었던 명령어를 재시작한다. <strong>당연히 페이지 폴트 처리 후 명령어의 처리를 다시 시작할 수 있어야 한다.</strong></li>\n</ol>\n<p>메모리에 페이지가 단 하나도 안 올라와 있는 상태라도 프로세스를 실행시킬 수 있는데 이렇게 되면 프로세스가 사용되는 모든 페이지가 메모리에 올라올 때까지 계속 페이지 폴트가 발생하게 된다. 이렇게 어떤 페이지가 필요해지기 전엔 절대 메모리로 적재하지 않는 걸 pure demand paging이라고 한다.</p>\n<p>또한 위의 페이지 폴트 처리 과정에서 빈 프레임을 찾는 부분이 있다. 대부분의 운영체제는 이런 요청의 해결을 위해 가용 프레임들의 풀인 가용 프레임 리스트를 유지하고 있다. 시스템이 시작되면 모든 가용 메모리가 이 가용 프레임 리스트에 들어가게 된다.</p>\n<h2>2.3. 어려움</h2>\n<p>페이지 폴트를 처리하고 나면 명령어를 다시 시작해야 한다. 그런데 명령어가 특정 메모리 조각을 다른 장소로 이동하는 명령이라고 하자. 이때 src, dest가 겹칠 수도 있다. 이 경우 명령어를 단순히 재시작하면 오류가 발생할 것이다.</p>\n<p>해결책은 두 가지다. 두 블록이 겹치는지 미리 확인 후 겹치면 페이지 폴트가 발생하도록 하는 방법이 있다. 또 하나는 이동에 의해 이전 내용이 지워질 부분을 임시 레지스터에 저장해 둔 후 나중에 복구시키는 방식이다.</p>\n<h2>2.4. 성능</h2>\n<p>페이지 폴트의 발생률은 당연히 0과 1 사이일 것이다. 그러면 페이지 폴트 발생률이 $p$라 할 때 Effective Access Time은 다음과 같다.</p>\n<p>$$EAT = (1-p) \\times Memory \\ Access \\ Time + p \\times Page \\ Fault \\ Time$$</p>\n<p>이때 페이지 폴트 시간은 다음과 같은 요소들로 이루어진다.</p>\n<ul>\n<li>페이지 폴트 인터럽트를 처리하는 오버헤드</li>\n<li>페이지의 swap in 시간</li>\n<li>기존 페이지가 수정되었을 시 저장하는 데 걸리는 시간</li>\n<li>명령어의 재시작(페이지 폴트 이후의 메모리 액세스 시간 포함)</li>\n</ul>\n<p>이런 부분 때문에 페이지 폴트가 발생할 경우 성능이 크게 저하된다. 교과서의 예시에서는 그냥 메모리 접근 시간이 200ns($200 \\times 10^{-9}s$), 페이지 폴트 발생시 평균 소요시간이 8ms($8 \\times 10^{-3}s$)라고 가정한다. 엄청난 차이다. 하지만 요구 페이징을 할 경우 페이지 폴트가 아예 발생하지 않을 순 없다. 요구 페이징의 성능 저하를 줄이기 위해서는 페이지 폴트를 줄여야 한다.</p>\n<h2>2.5. Copy-on-Write</h2>\n<p>fork 명령은 부모 프로세스의 복사본인 자식 프로세스를 생성한다. 하지만 만약 fork 다음에 바로 exec 명령이 실행된다면 부모 프로세스를 복사한 페이지들은 다 쓸모없어진다. Copy on Write는 자식 프로세스가 fork로 시작될 때 부모의 페이지를 당분간 함께 사용하도록 하는 방식이다.</p>\n<p>그리고 부모나 자식 프로세스가 이렇게 공유되고 있는 페이지들 중 하나를 수정하면 딱 그 수정된 페이지만 복사되는 것이다. 수정되지 않은 페이지들은 여전히 부모와 자식 프로세스 간에 공유되는 것이다.</p>\n<p>수정된 페이지만이 복사되므로 프로세스 생성 시 더 효율적인 동작이 가능해진다.</p>\n<h1>3. 페이지 교체</h1>\n<p>프로세스가 실행되는 중에 페이지 폴트가 발생했다. 그런데 가용 프레임이 없다. 이럴 때 어떻게 해야 할까? 이런 상황을 해결하기 위해 페이지 교체라는 개념이 등장한다.</p>\n<p>물론 어떤 페이지를 교체할지 고르는 것도 중요하지만 일단 페이지 교체 알고리즘은 좀 이따 보고 기본적인 페이지 교체가 어떻게 돌아가는지 살펴보자.</p>\n<h2>3.1. 페이지 교체의 구조</h2>",
    "excerpt": "운영체제 공룡책, 10단원을 정리한다.\n1. 가상 메모리\n가상 메모리를 사용하면 프로그램이 메모리에 전부 올라와 있지 않아도 프로그램을 실행할 수 있도록 해준다. 그리고 프로그래머에게 실제 메모리보다 훨씬 큰 메모리를 사용할 수 있도록 해준다. 그로 인해 프로그래머가 물리 메모리의 크기를 걱정할 필요 없도록 해준다.\n1.1 가상 주소 공간\n가상 주소 공간(virtual address space)는 프로세스가 메모리에 논리적으로 어떻게 저장되는지를 의미한다. 흔히",
    "headingTree": [
      {
        "title": "1. 가상 메모리",
        "url": "#1-가상-메모리",
        "items": [
          {
            "title": "1.1 가상 주소 공간",
            "url": "#11-가상-주소-공간",
            "items": []
          }
        ]
      },
      {
        "title": "2. 요구 페이징",
        "url": "#2-요구-페이징",
        "items": [
          {
            "title": "2.1. valid/invalid bit",
            "url": "#21-validinvalid-bit",
            "items": []
          },
          {
            "title": "2.2. 페이지 폴트",
            "url": "#22-페이지-폴트",
            "items": []
          },
          {
            "title": "2.3. 어려움",
            "url": "#23-어려움",
            "items": []
          },
          {
            "title": "2.4. 성능",
            "url": "#24-성능",
            "items": []
          },
          {
            "title": "2.5. Copy-on-Write",
            "url": "#25-copy-on-write",
            "items": []
          }
        ]
      },
      {
        "title": "3. 페이지 교체",
        "url": "#3-페이지-교체",
        "items": [
          {
            "title": "3.1. 페이지 교체의 구조",
            "url": "#31-페이지-교체의-구조",
            "items": []
          }
        ]
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 52
    },
    "url": "/posts/os-8",
    "thumbnail": {
      "local": "/static/space-8cc878b7.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-space-8cc878b7-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAICAIAAABVpBlvAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAo0lEQVR4nAGYAGf/AP///s/HwoV9eGBbVWNdWWtiWQD08/H08OuGio8wQEU0RUtNU1EA9vb29PDri5SfJzA9MjlIUF1mALafnOXc13Z0fhACFBkPHDk2PQCrkpDg1dCNlJk7TVNBVVxTWloA9vb09fDug39/JCQiKCooRD44APHv7vXw7oKBgyUoKDE2OEJAPAD7+/rl29SCd3JQS0VaVVBfVUysekkXxfTEsgAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "os-7",
    "title": "운영체제 공룡책 9단원 정리",
    "date": "2022-12-07T01:00:00Z",
    "description": "운영체제 9단원 정리",
    "tags": [
      "study",
      "CS"
    ],
    "html": "<p>운영체제 9단원, 메인 메모리에 관하여 정리한다. 주로 메모리를 관리하는 다양한 방법에 대해 설명한다.</p>\n<h1>1. 배경</h1>\n<p>프로그램은 기본적으로 메모리에 올라간 코드이다. 그리고 다음과 같은 과정을 거쳐서 실행된다.</p>\n<p>메모리에서 명령어 하나를 가져온다(fetch)\n명령어를 해독한다(decode)\n필요한 경우 메모리에서 피연산자를 가져온다(operation fetch)\n피연산자를 이용하여 연산을 수행한다(execute)\n연산 결과를 메모리에 저장한다(store)</p>\n<p>이때 메모리는 주소에 의해서 접근되는데, 이런 메모리는 어떻게 관리되는가?</p>\n<h2>1.1. 기본 하드웨어</h2>\n<p>CPU는 레지스터와 메인 메모리에 직접 접근할 수 있다. 디스크에는 직접 접근할 수 없다. 따라서 모든 명령어와 사용되는 데이터는 메모리에 올라와 있어야 한다.</p>\n<p>하지만 레지스터의 접근은 1사이클만에 가능한 데 반해 메인 메모리에 접근하는 것은 훨씬 더 많은 사이클이 소요된다. 따라서 메인 메모리를 사용하는 명령의 경우 필요한 데이터가 아직 메인 메모리에서 로드되지 않아서 명령어의 실행이 지연되는 현상이 나타난다. 이를 stall이라 한다.</p>\n<p>이를 해결하는 방법으로는 CPU와 메인 메모리 사이에 캐시 메모리를 추가하는 방법이 있다.</p>\n<h2>1.2. 메모리 보호</h2>\n<p>시스템의 올바른 동작을 위해서는 메모리에 있는 프로그램이 다른 프로그램의 메모리에 접근하지 못하도록 해야 한다. 이를 위해서 각 프로세스가 독립된 공간을 가지도록 한다.</p>\n<p>이 독립된 공간은 다음과 같이 base와 limit를 통해서 정의된다. 특정 프로세스에 대해 legal한 메모리라 함은 base에서 base+limit까지이다.</p>\n<p><img src=\"/static/vm-2bc56369.png\" alt=\"vm\"></p>\n<p>이 base, limit는 커널 모드에서 정해지며 사용자 프로그램은 이를 변경할 수 없다. 또한 다른 프로세스의 메모리에 접근하게 되면 운영체제는 이를 오류로 감지하고 트랩(소프트웨어 인터럽트)을 발생시킨다. 이렇게 해서 현재 실행중인 프로그램이 운영체제나 다른 사용자 프로그램에 접근하는 것을 막을 수 있다.</p>\n<h2>1.3. 주소 바인딩</h2>\n<p>프로세스는 메모리의 어느 위치에 올라가게 되는가? 원시 프로그램에서 주소는 실제 메모리 주소가 아니라 심볼 형태로 표현된다. 컴파일러가 이를 relocatable address로 바인딩하고 링커가 이를 absolute address로 바인딩한다. 이렇게 하나의 주소 공간을 다른 주소 공간으로 매핑하는 걸 주소 바인딩이라 한다.</p>\n<p>이때 명령어와 데이터의 바인딩이 어느 시점에 이루어지는지에 따라 다음과 같이 나눠진다.</p>\n<ul>\n<li>compile time : 컴파일 시점에 물리 주소가 정해진다. 프로세스가 메모리 내에서 들어갈 위치를 컴파일 시간에 미리 알 수 있다. 따라서 absolute code를 생성할 수 있다. 그러나 주소를 완전히 고정해 버리기 때문에 비효율 혹은 충돌이 발생할 수 있다.</li>\n<li>load time : 컴파일 타임에 메모리 위치를 알 수 없다면 이진 코드는 재배치 가능한 코드로 만들어진다. 그리고 이 코드는 프로그램이 메인 메모리로 적재되는 시점에 메모리에 올라가는 위치에 따라서 주소가 바인딩된다.</li>\n<li>Execution time : 주소 바인딩이 런타임까지 미루어지고, MMU(Memory Management Unit)가 실행 시간에 논리 주소를 물리 주소로 변환해 준다.</li>\n</ul>\n<p>어떻게 바인딩이 이루어지든 사용자 프로그램은 언제나 논리 주소(logical address, virtual address)만 다룬다. 사용자 프로그램은 절대 물리 주소에 직접 접근하지 않는다.</p>\n<h2>1.4. 동적 라이브러리, 정적 라이브러리</h2>\n<p>라이브러리는 정적 라이브러리, 동적 라이브러리가 있다.</p>\n<h3>1.4.1. 정적 라이브러리</h3>\n<p>프로그램이 실행되기 전 컴파일 타임에 링커가 정적 라이브러리 내용을 실행 파일에 포함시킨다. 그러나 프로그램이 실행되는 동안에는 라이브러리의 내용을 변경할 수 없다. 그리고 실행 파일 크기가 커질 수 있다.</p>\n<h3>1.4.2. 동적 라이브러리</h3>\n<p>사용자 프로그램이 실행되는 시점(런타임)에 프로그램에 연결되는 라이브러리이다. 프로그램이 동적 라이브러리에 있는 코드를 참조하는 시점에 로더가 DLL파일을 찾아서 필요한 경우 메모리에 올린다.</p>\n<p>당연히 라이브러리가 있는 주소로 계속 점프하기 때문에 성능 저하가 발생한다. 하지만 메모리가 적게 들고 실행 파일 크기가 작아지며 라이브러리 갱신이 쉽다. 동적으로 링킹되기 때문에 DLL파일 하나만 수정하면 그 파일을 사용하는 모든 실행 파일에서 수정된 DLL을 사용할 수 있다. 또한 동적 라이브러리는 여러 프로그램에서 공유할 수 있으므로 DLL 인스턴스가 메인 메모리에 하나만 있을 수 있다.</p>\n<h2>1.5. Dynamic Loading, Dynamic Linking</h2>\n<h3>1.5.1. Dynamic Loading</h3>\n<p>동적 적재는 loading, linking을 실행 시점까지 미룬다. 그리고 특정 루틴이 필요해지면 그 루틴이 메모리에 있는지를 먼저 검사한다. 만약 그 루틴이 메모리에 적제되지 않은 상태라면 relocatable linking loader가 그 루틴을 메모리에 적재한다. 그리고 그 루틴을 호출한다. 이렇게 하면 프로세스 전체가 미리 메모리에 올라와 있지 않아도 되므로 메모리 사용량이 줄어든다.</p>\n<p>POSIX의 dlopen(), window의 LoadLibrary()가 이를 지원하는 API이다.</p>\n<h3>1.5.2. Dynamic Linking</h3>\n<p>동적 링킹은 실행시에 linking을 하는 것이다. 실행 파일은 메모리에서 적절한 라이브러리 루틴으로 이동하는 코드를 가지고 있고 OS가 이를 실행시에 해석한다. 실행 파일에 들어 있지 않은 루틴과 동적 라이브러리 루틴을 운영체제가 연결한다.</p>\n<h2>1.6. Swapping</h2>\n<p>실제 물리 메모리보다 크기가 큰 프로세스를 실행하는 등의 이유로 메모리가 부족하면 메모리에 있는 프로세스 중 일부를 디스크로 내보내는 것을 swapping이라고 한다. 예를 들어서 <a href=\"https://yuni.vercel.app/external-sorting/\">메인 메모리보다 큰 파일을 정렬하는 경우</a>와 같은 일을 할 수 있다.</p>\n<p>표준 스와핑은 메인 메모리와 디스크 간에 전체 프로세스를 이동시킨다. 디스크 크기는 당연히 저장 및 다시 불러와야 하는 프로세스 크기에 상관없이 모두 수용할 수 있을 만큼 커야 한다. 프로세스와 관련된 자료구조, 그리고 다중 스레드 프로세스의 경우 모든 스레드의 데이터구조도 디스크에 저장되어야 한다. 디스크에 저장된 프로세스의 메타데이터는 운영체제에 의해 유지된다.</p>\n<p>Swap에 걸리는 시간 대부분은 디스크로 전송하는 시간이라고 한다. 또한 우선순위가 낮은 프로세스를 밀어내고 우선순위가 높은 프로세스를 메모리에 올리는 Swap을 roll out, roll in이라고도 한다.</p>\n<h1>2. 연속 메모리 할당</h1>\n<p>메모리는 일반적으로 운영체제를 위한 것과 사용자 프로세스를 위한 것으로 나누어진다. 여기선 운영체제가 인터럽트 벡터와 함께 low memory에 배치되고 사용자 프로세스가 high memory에 배치된다고 하겠다.</p>\n<p>메모리를 여러 고정 크기 파티션으로 나누고 각 프로세스별로 파티션을 하나씩 할당하는 방식도 있다. 이를 multiple partition allcation이라 하는데 요즘은 거의 쓰이지 않는 방식이다.</p>\n<p>아무튼, 각 프로세스들에 메모리를 어떻게 할당할 것인가? 먼저 프로세스를 메모리의 가변 크기 파티션에 할당하는 것이다. 가용 메모리 블록을 hole로 생각하고 프로세스가 도착하면 그 프로세스를 수용 가능한 hole에 배치하는 것이다. 그 프로세스가 끝나면 공간은 반납된다. 다음과 같은 방식이다.</p>\n<p><img src=\"/static/hole-e5a68535.png\" alt=\"hole\"></p>\n<p>만약 여기서 프로세스 5가 끝나서 그 공간이 비게 되면 hole이 2개가 된다. 이런 식으로 진행되면 hole들은 메모리의 여러 부분에 흩어져 있는 상태가 된다. 여기서 생기는 2가지 문제가 있다. dynamic storage allocation problem과 fragmentation problem이다.</p>\n<h2>2.1. Dynamic Storage Allocation Problem</h2>\n<p>n바이트 공간이 요구될 때 어떤 가용 공간을 할당해서 이를 만족시킬 것인가의 문제이다.</p>\n<p>First-fit : 탐색하면서 만나는 hole 중 n바이트보다 큰 첫번째 hole을 할당한다.\nBest-fit : n바이트보다 큰 hole 중 가장 크기가 작은 것을 할당한다. 만약 hole이 크기순으로 정렬되어 있지 않다면 모든 리스트를 탐색해야 한다.\nWorst-fit : n바이트보다 큰 hole 중 가장 크기가 큰 것을 할당한다. 역시 hole이 크기순으로 정렬되어 있지 않다면 모든 리스트를 탐색해야 한다.</p>\n<p>first-fit, best-fit이 시간과 메모리 이용 측면에서 worst-fit보다 낫다고 알려져 있다. 그리고 first-fit이 일반적으로 best-fit보다 속도 면에서 더 빠르다고 알려져 있다.</p>\n<p>만약 요구되는 공간을 충족할 만큼의 메모리가 없다면? 프로세스를 거부하고 적절한 오류를 띄우거나 프로세스를 대기 큐에 넣는 방식이 있다. 메모리가 나중에 해제되면 운영체제가 대기 큐를 검사해서 메모리가 충분해지면 프로세스를 실행시키는 방식이다.</p>\n<h2>2.2. Fragmentation Problem</h2>\n<h3>2.2.1. External Fragmentation</h3>\n<p>hole들은 메모리의 여러 부분에 흩어져서 존재한다. 따라서 모든 hole들을 합치면 요구되는 공간을 만들 수 있지만 hole들이 흩어져 있어서 적절한 공간을 찾기 어려운 경우가 생길 수 있다. 이를 external fragmentation이라고 한다.</p>\n<p>일반적으로 N개 블록이 할당시 0.5N개 블록이 단편화 때문에 손실될 수 있다는 50% rule이 있다.</p>\n<h3>2.2.2. Internal Fragmentation</h3>\n<p>메모리 할당을 할 때 특정 size 단위로 할당하게 된다. 그런데 프로세스가 그 size보다 작은 메모리를 요구할 수도 있다. 이 때 할당된 메모리의 일부가 낭비되는데 이를 internal fragmentation이라고 한다.</p>\n<p>예를 들어서 4바이트 단위로 메모리가 할당되는 상황에서 프로세스가 3바이트를 요구하면 1바이트가 낭비된다.</p>\n<h2>2.3. Compaction</h2>\n<p>외부 단편화의 해법 중 하나로 메모리의 모든 프로세스를 한 군데로 모으는 방법이다. 이렇게 하면 모든 hole들이 한쪽으로 모여서 메모리를 효율적으로 사용할 수 있다.</p>\n<p>그러나 비용이 매우 많이 들고 프로세스 재배치가 실행 시간에 이루어지는 경우에만 가능하다.</p>\n<h1>3. 비연속 메모리 할당</h1>\n<p>프로세스의 물리 주소 공간이 연속되지 않아도 되는 기법이다. 이 방식으로 외부 단편화를 해결할 수 있다.</p>\n<h2>3.1. Paging</h2>\n<p>논리 메모리를 고정된 사이즈의 페이지들로 나눈다. 그리고 물리 메모리도 페이지와 같은 크기를 갖는 프레임들로 나눈다. 이때 페이지와 프레임의 크기는 보통 2의 제곱수 중 하나로 하드웨어적으로 지원된다.</p>\n<p>그리고 페이지 테이블을 이용해서 논리 주소와 물리 주소를 매핑한다. 페이징을 하면 외부 단편화는 발생하지 않지만 내부 단편화는 발생할 수 있다. 늘 프레임 크기의 정수배만큼 메모리가 할당되기 때문이다.</p>\n<h3>3.1.1. Address Translation</h3>\n<p>CPU의 모든 주소는 page number, page offset으로 이루어진다. page number는 페이지 테이블의 인덱스로 사용되고 page offset은 참조되는 프레임 내의 주소로 사용된다. 주소가 다음과 같이 나뉘는 것이다.</p>\n<p><img src=\"/static/address-7641f437.png\" alt=\"address\"></p>\n<p>page offset이 n비트라면 페이지 크기는 $2^n$이고 페이지 테이블의 크기는 $2^{m-n}$이다. m-n비트로 표현할 수 있는 경우의 수만큼의 페이지 개수를 가질 수 있기 때문이다.</p>\n<p><img src=\"/static/Translation-a0cf5ce7.png\" alt=\"Translation\"></p>\n<p>페이지 테이블을 통해 page number와 매핑된 frame에 접근한 후 offset을 더해서 물리 주소를 만든 것이 해당 페이지 주소에 해당하는 물리 주소이다.</p>\n<h3>3.1.2. Fragmentation in Paging</h3>\n<p>페이징을 하면 외부 단편화는 발생하지 않지만 내부 단편화는 발생할 수 있다. 늘 프레임 크기의 정수배만큼 메모리가 할당되기 때문이다. 그렇다면 페이지 하나를 작게 만들면 내부 단편화를 줄일 수 있지 않을까? 그렇다.</p>\n<p>하지만 페이지 하나를 작게 만들면 페이지 테이블의 크기가 커지고 페이지 테이블을 찾는 시간이 길어진다는 단점이 있다.</p>\n<h3>3.1.3. Memory Loading</h3>\n<p>프로세스가 실행되기 위해 도착하면 그 프로세스 크기에 몇 개의 페이지가 필요한지를 조사해야 한다. 그리고 필요한 프레임들을 할당해야 한다.</p>\n<p>그러기 위해서는 모든 가용 프레임들을 추적하고 있어야 한다. 그렇게 프레임들이 프로세스에 할당되고 나면 프로세스의 페이지가 할당된 프레임 중 하나에 적재된 후 페이지 테이블을 업데이트하는 것이 반복된다.</p>\n<h3>3.1.4. 운영체제의 관리</h3>\n<p>사용자는 메모리가 하나의 연속적인 공간인 것처럼 프로그램을 올려 사용하지만 사실 프로그램은 여러 곳에 프레임 단위로 분산되어 있다. 프로그램을 사용자가 사용할 때는 그 부분의 주소가 MMU에 의해 물리 주소로 변환되어 사용된다.</p>\n<p>운영체제는 이런 부분의 구현을 위해 물리 메모리의 정보를 파악하고 있다. 이는 프레임 테이블이라는 시스템에 하나뿐인 자료구조로 관리하고, 여기에는 각 프레임이 비어있는지, 어느 프로세스의 어느 페이지에 할당되었는지에 대한 정보가 모두 들어 있다.</p>\n<p>또한 운영체제는 모든 프로세스의 주소를 실제 주소로 사상하기 위해 각 프로세스의 페이지 테이블 사본을 유지한다.</p>\n<h3>3.1.5. 페이지 테이블 관리</h3>\n<p>페이지 테이블은 프로세스마다 하나씩 있어야 한다. 그러나 실행 중인 프로세스의 페이지 테이블만이 레지스터에 올라와 있어야 한다. 이를 어떻게 구현할 것인가?</p>\n<p>페이지 테이블 전체를 레지스터에 올리는 방법을 생각할 수 있고 이 방법은 매우 빠른 페이지 주소 변환을 제공한다. 하지만 페이지 테이블이 커지면 레지스터에 올릴 수 있는 공간이 부족해지고 컨텍스트 스위칭 시간도 늘어난다.</p>\n<p>따라서 Page Table Base Register(PTBR)와 Page Table Length Register(PTLR)를 사용해서 페이지 테이블을 관리한다. 컨텍스트 스위칭 시 이 레지스터만 변화시키면 된다.</p>\n<h3>3.1.6. TLB</h3>\n<p>위와 같은 방식으로 페이지 테이블을 관리한다고 하자. 그러면 데이터 액세스마다 2번의 메모리 접근이 필요하다. 한번은 PTBR을 사용해서 페이지 테이블을 찾고, 다른 한번은 페이지 테이블을 사용해서 실제 주소를 찾는 것이다. 이는 매우 비효율적이다.</p>\n<p>이를 해결하기 위해 TLB(Translation Lookaside Buffer)를 사용한다. TLB는 페이지 테이블의 일부분만을 저장하는 캐시와 같다. 또한 TLB 내의 key-value 검색은 동시에 이루어지고 성능에 손해를 미치지 않는다.</p>\n<p>어떤 논리 주소에 접근하게 되면 먼저 TLB를 검색한다. TLB에 해당 페이지 주소가 있으면(TLB hit) 즉시 해당 프레임 주소에 접근한다. 그렇지 않으면(TLB miss) 페이지 테이블을 검색하고 TLB에 새로운 key-value 쌍을 추가한다.</p>\n<p>Effect Access Time(EAT)은 다음과 같이 나타난다.</p>\n<p>$$EAT = (1+\\epsilon)\\alpha + (2+\\epsilon)(1-\\alpha)$$</p>\n<p>$\\epsilon$은 TLB에서 탐색하는 데 걸리는 시간이고 $\\alpha$는 TLB hit rate이다. TLB hit시 TLB 탐색시간 + 메모리에 1번 접근 만큼 시간이 걸리고 miss시 TLB 탐색시간 + 메모리에 2번 접근 만큼 시간이 걸리는 것을 나타낸 것이다.</p>\n<h3>3.1.7. 메모리 보호</h3>\n<p>메모리 보호를 위해서 각 페이지에는 보호 비트가 붙어 있다. 이 비트는 페이지가 읽기, 쓰기, 실행 가능한지를 나타낸다. 보호 비트는 페이지 테이블에 저장되어 있다.</p>\n<p>페이지 테이블 엔트리에는 valid bit도 있다. 이 비트는 해당 페이지가 프로세스의 논리 주소 공간에 매핑되어 있는지를 나타낸다. 즉 이 비트가 invalid이면 페이지 테이블의 해당 엔트리가 프로세스의 논리 주소 공간에 없다는 뜻이다.</p>\n<p><img src=\"/static/valid_bit-a02acb8e.png\" alt=\"valid\"></p>\n<p>혹은 앞에서 본 것과 같이 Page Table Length Register를 사용해서 메모리를 보호하는 방법도 있다. 프로세스가 제시한 주소가 유효 범위 안에 있는지 판단하기 위해 PTLR과 비교하는 것이다.</p>\n<h3>3.1.8. 공유 페이지</h3>\n<p>실행중에 변경되지 않는 읽기 전용 코드와 같은 경우 다른 프로세스들 간에 공유될 수 있다. 각 프로세스의 페이지 테이블에서 같은 물리적 주소(프레임)를 가리키게 하면 된다.</p>\n<h1>4. 페이지 테이블 구조</h1>\n<h2>4.1 Hierarchical Paging</h2>\n<p>주소 공간이 너무 커지면 페이지 테이블도 너무 커질 수 있다. 이를 해결하기 위해 페이지 테이블을 계층적으로 구성하는 게 Hierarchical Paging이다.</p>\n<p>예를 들어서 2단계 페이징을 한다고 생각하자. 페이지 테이블들을 페이징시키는 것이다.</p>\n<p>32비트 주소는 20비트 page number, 12비트 offset으로 구성되어 있다. 그리고 20비트를 10비트씩 나누어서 2단계 페이징을 한다고 하면 10비트는 outer page table의 인덱스, 10비트는 inner page table에서의 offset이다.</p>\n<p><img src=\"/static/two_level-d33c66eb.png\" alt=\"twoLevel\"></p>\n<p>단 64비트 주소공간을 사용하는 경우 비트가 너무 많기 때문에 3단계 이상의 페이징을 사용해야 하고 그 경우 너무 많은 메모리 접근이 필요하다. 따라서 64비트 주소 공간에선 계층적 페이징은 적절하지 못하다.</p>\n<h2>4.2 Hashed Page Table</h2>\n<p>32비트 이상의 주소 공간에서 많이 사용한다.</p>\n<p>페이지 테이블을 해시 테이블로 구성한다. 페이지 번호를 해싱해서 나온 해시값 인덱스에 해당하는 페이지 테이블 엔트리에 페이지를 저장한다. 그리고 충돌은 chaining으로 관리한다. 그 번호로 해시되는 페이지들이 모두 같은 페이지 테이블 엔트리에 연결 리스트로 연결되는 것이다.</p>\n<p><img src=\"/static/hashed-5f9d8f66.png\" alt=\"hashed\"></p>\n<p>페이지 번호가 오면 해시 함수에 넣는다. 그리고 그 해시값에 해당하는 페이지 테이블 엔트리를 찾는다. 그리고 그 페이지 테이블 엔트리에 연결된 페이지들을 순회하면서 페이지 번호가 같은 페이지를 찾는다. 그리고 그 페이지의 물리적 주소를 찾아서 리턴한다.</p>\n<p>비슷하게 클러스터 페이지 테이블이란 것도 있는데 이는 해시 페이지 테이블의 각 엔트리가 여러 프레임에 매핑되는 것이다.</p>\n<h2>4.3 Inverted Page Table</h2>\n<p>물리적인 페이지, 즉 메모리 프레임마다 하나의 항목을 할당한다. 각 항목은 그 프레임에 올라와 있는 페이지 주소와 페이지를 소유한 프로세스의 pid를 저장한다. 그러면 시스템에는 하나의 페이지 테이블만이 존재하게 된다.</p>\n<p><img src=\"/static/inverted-bded9fbd.png\" alt=\"inverted\"></p>\n<p>어떤 페이지를 찾을 땐 pid, 페이지 번호 쌍을 역 페이지 테이블에서 검색한다. 그리고 일치하는 것이 i번째 엔트리에서 발견되면 i번째 프레임의 주소를 탐색한다.</p>\n<p>역 페이지 테이블의 문제 하나는 역 페이지 테이블이 물리 주소 기준으로 정렬되어 있는데 탐색은 가상 메모리 주소를 탐색하므로 탐색 시간이 오래 걸린다는 것이다. 따라서 보통 해시 테이블을 사용한다.</p>\n<p>또한 물리 프레임에 페이지 하나가 매핑되는 방식이기에 하나의 물리 페이지가 2개 이상의 가상 주소에 매핑될 수 없다. 따라서 공유 페이징을 사용할 수 없다.</p>\n<h1>5. 세그멘테이션</h1>\n<p>고정되지 않은 크기의 메모리 블록을 사용하는 방식이다. 논리 주소 공간을 가변 크기의 세그먼트로 나누고 각 세그먼트를 물리 메모리의 연속된 블록에 매핑한다.</p>\n<p>주소의 변환은 세그먼트 테이블에 의해서 이루어지는데, 이 테이블은 각 세그먼트의 base address와 limit을 저장한다. 그리고 논리 주소는 세그먼트 번호와 offset으로 이루어진다. 세그먼트 번호는 세그먼트 테이블의 인덱스가 되고 offset은 세그먼트 내에서의 주소가 된다.</p>\n<p>그리고 세그먼트 테이블의 정보를 나타내는 레지스터도 있다. Segment Table Base Register(STBR), Segment Table Limit Register(STLR)다. 각각 세그먼트 테이블의 시작 위치와 길이를 저장한다.</p>\n<h1>참고</h1>\n<p><a href=\"https://parksb.github.io/article/12.html\">박성범 님의 블로그, 공룡책으로 정리하는 운영체제 Ch8</a></p>",
    "excerpt": "운영체제 9단원, 메인 메모리에 관하여 정리한다. 주로 메모리를 관리하는 다양한 방법에 대해 설명한다.\n1. 배경\n프로그램은 기본적으로 메모리에 올라간 코드이다. 그리고 다음과 같은 과정을 거쳐서 실행된다.\n메모리에서 명령어 하나를 가져온다(fetch)\n명령어를 해독한다(decode)\n필요한 경우 메모리에서 피연산자를 가져온다(operation fetch)\n피연산자를 이용하여 연산을 수행한다(execute)\n연산 결과를 메모리에 저장한다(store)\n이때 메모리",
    "headingTree": [
      {
        "title": "1. 배경",
        "url": "#1-배경",
        "items": [
          {
            "title": "1.1. 기본 하드웨어",
            "url": "#11-기본-하드웨어",
            "items": []
          },
          {
            "title": "1.2. 메모리 보호",
            "url": "#12-메모리-보호",
            "items": []
          },
          {
            "title": "1.3. 주소 바인딩",
            "url": "#13-주소-바인딩",
            "items": []
          },
          {
            "title": "1.4. 동적 라이브러리, 정적 라이브러리",
            "url": "#14-동적-라이브러리-정적-라이브러리",
            "items": [
              {
                "title": "1.4.1. 정적 라이브러리",
                "url": "#141-정적-라이브러리",
                "items": []
              },
              {
                "title": "1.4.2. 동적 라이브러리",
                "url": "#142-동적-라이브러리",
                "items": []
              }
            ]
          },
          {
            "title": "1.5. Dynamic Loading, Dynamic Linking",
            "url": "#15-dynamic-loading-dynamic-linking",
            "items": [
              {
                "title": "1.5.1. Dynamic Loading",
                "url": "#151-dynamic-loading",
                "items": []
              },
              {
                "title": "1.5.2. Dynamic Linking",
                "url": "#152-dynamic-linking",
                "items": []
              }
            ]
          },
          {
            "title": "1.6. Swapping",
            "url": "#16-swapping",
            "items": []
          }
        ]
      },
      {
        "title": "2. 연속 메모리 할당",
        "url": "#2-연속-메모리-할당",
        "items": [
          {
            "title": "2.1. Dynamic Storage Allocation Problem",
            "url": "#21-dynamic-storage-allocation-problem",
            "items": []
          },
          {
            "title": "2.2. Fragmentation Problem",
            "url": "#22-fragmentation-problem",
            "items": [
              {
                "title": "2.2.1. External Fragmentation",
                "url": "#221-external-fragmentation",
                "items": []
              },
              {
                "title": "2.2.2. Internal Fragmentation",
                "url": "#222-internal-fragmentation",
                "items": []
              }
            ]
          },
          {
            "title": "2.3. Compaction",
            "url": "#23-compaction",
            "items": []
          }
        ]
      },
      {
        "title": "3. 비연속 메모리 할당",
        "url": "#3-비연속-메모리-할당",
        "items": [
          {
            "title": "3.1. Paging",
            "url": "#31-paging",
            "items": [
              {
                "title": "3.1.1. Address Translation",
                "url": "#311-address-translation",
                "items": []
              },
              {
                "title": "3.1.2. Fragmentation in Paging",
                "url": "#312-fragmentation-in-paging",
                "items": []
              },
              {
                "title": "3.1.3. Memory Loading",
                "url": "#313-memory-loading",
                "items": []
              },
              {
                "title": "3.1.4. 운영체제의 관리",
                "url": "#314-운영체제의-관리",
                "items": []
              },
              {
                "title": "3.1.5. 페이지 테이블 관리",
                "url": "#315-페이지-테이블-관리",
                "items": []
              },
              {
                "title": "3.1.6. TLB",
                "url": "#316-tlb",
                "items": []
              },
              {
                "title": "3.1.7. 메모리 보호",
                "url": "#317-메모리-보호",
                "items": []
              },
              {
                "title": "3.1.8. 공유 페이지",
                "url": "#318-공유-페이지",
                "items": []
              }
            ]
          }
        ]
      },
      {
        "title": "4. 페이지 테이블 구조",
        "url": "#4-페이지-테이블-구조",
        "items": [
          {
            "title": "4.1 Hierarchical Paging",
            "url": "#41-hierarchical-paging",
            "items": []
          },
          {
            "title": "4.2 Hashed Page Table",
            "url": "#42-hashed-page-table",
            "items": []
          },
          {
            "title": "4.3 Inverted Page Table",
            "url": "#43-inverted-page-table",
            "items": []
          }
        ]
      },
      {
        "title": "5. 세그멘테이션",
        "url": "#5-세그멘테이션",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 264
    },
    "url": "/posts/os-7",
    "thumbnail": {
      "local": "/static/vm-2bc56369.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-vm-2bc56369-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAIAAABLbSncAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA00lEQVR4nAHIADf/ANXJwK+rpyckHwMAAGJeWebf29/a1dTLxgC4sqybnZ8vMTILDxBnaWr////////l3toAvbavztDQ29vbzs/O29vb39/esbKysq2oALixqsXFx9vb28vLy9DQz8bGxjU2N3hybgCzrafAwMLLy8u7u7vKysrGxsZHSUp6dnIAycK83t/f3tzb0c7N4uDf4uDgfH19oZyYALOtpqeusoSapHyTnpKiqv///v///+Pd2ACQh36AgIBcb3ZWaXF1gYTm39vf2tbUy8ZcM4GRTGupQwAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "passport-encrypt",
    "title": "Express - passport로 로그인과 회원가입 구현하기 - 암호화해서 정보 저장하기",
    "date": "2021-08-20T00:00:00Z",
    "description": "Passport 사용하기, 그 삽질의 기록3",
    "tags": [
      "web"
    ],
    "html": "<h1>1. 사용자 정보 암호화</h1>\n<p>전 글에서는 DB에 사용자 정보를 평문으로 저장하였다. 그러나 이는 매우 위험한 행위이다. 어떤 이유로든 사용자 정보를 담은 DB가 유출되었을 경우에 해커가 사용자들의 정보를 그대로 알 수 있기 때문이다. 따라서 해커들이 DB를 털더라도 사용자 정보를 알아낼 수 없게 하기 위해 수많은 알고리즘이 개발되었다.</p>\n<p>물론 해킹 기술도 발전하므로 SHA1 과 같은, 폐기된 알고리즘들도 있다. 하지만 여전히 뚫기 힘든 암호화 알고리즘들이 존재한다. 그러나 그런 알고리즘들을 하나하나 공부하려는 목적의 글은 아니므로 우리는 crypto 모듈을 사용하기로 한다. 그중에서도 scrypt를 사용한다.</p>\n<p>먼저 crypto 모듈을 설치해주자.</p>\n<pre><code>yarn add crypto\n</code></pre>\n<p>crypto는 다양한 방식의 암호화를 지원한다. 먼저 salt를 뿌려주고 반복해서 hashing을 하는 간단한 방식의 pbkdf2 함수를 사용해 본다.</p>\n<p>일반적으로 이런 반복 해싱은 몇만 번 정도는 해 주는 게 보통이다. Django같은 경우 암호화를 위해 기본적으로 해싱을 36000번 해준다고 한다. 물론 이렇게 해도 GPU를 이용한 병렬 연산을 통해 공격하면 위험성이 있다. 그러나 이 정도로도 평문 저장과는 비교도 할 수 없이 안전하게 유저 정보를 저장할 수 있을 것이다.</p>\n<p>pdkdf2의 사용법은 다음과 같다.</p>\n<pre><code>crypto.pbkdf2(암호화할 문자열, salt, 해싱의 반복 횟수, 생성될 암호 키의 길이, 해싱 방식, 콜백 함수)\n</code></pre>\n<p>이때 생성될 암호 키는 64를 많이 쓰는 듯 하다. 그리고 해싱 방식을 null로 할 경우 기본적으로 SHA1 방식으로 해싱된다. 이 방식은 이미 보안상의 위험성이 밝혀진 방식이므로 명시적으로 해싱 방식을 인수로 넣어 주도록 하자. crypto 공식 문서에서는 <code>SHA512</code> 를 사용했다.</p>\n<p>그리고 콜백 같은 경우 <code>(err, derivedKey)</code>를 인수로 사용한다. 매우 직관적인 이름이다. 사용 예시는 다음과 같다.</p>\n<pre><code class=\"language-javascript\">import {pbkdf2} from \"crypto\";\n\npbkdf2(\"witch-work\", \"salt\", 65536, 32, \"sha512\", (err, derivedKey) => {\n    if (err) {\n        throw err;\n    }\n    //에러 발생시 핸들링\n    console.log(derivedKey.toString(\"hex\"));\n});\n</code></pre>\n<p>이때 <code>derivedKey</code> 는 <buffer> 로 넘어오기 때문에 보기 편하라고 toString으로 출력해 준 것이다.</buffer></p>\n<p>그리고 salt는 원래 저런 단순한 문자열로 하면 안 된다. salt를 사용할지라도 <code>salt</code> 같은 누구라도 생각할 만한 단순한 문자열을 사용한다면 레인보우 테이블을 이용한 공격에 취약할 수 있다. 이 부분은 나중에 고쳐 주도록 하겠다. 보안은 단단할수록 좋겠지만, 우리는 이미 평문 저장에서 큰 걸음을 하나 내디뎠기 때문이다.</p>\n<p>그리고 패스워드를 저장하는 함수를 먼저 만들고 나서 암호화하는 방식을 강화한다고 해도 큰 문제는 없다. 그저 순서가 조금 달라질 뿐이다.</p>\n<h1>2. 사용자 정보 암호화해 저장하기 - pbkdf2</h1>\n<p>먼저 우리가 이전 글에서 만들었던, 새로운 유저 정보를 저장하는 함수를 다시 보도록 하자.</p>\n<pre><code class=\"language-javascript\">const userInfoInsert = async (username, password) => {\n    const userInsertQuery = \"insert into users(username, password) values(?,?)\";\n    await connection.query(userInsertQuery, [username, password]);\n};\n</code></pre>\n<p>DB 커넥션에 row 삽입 쿼리를 날리는 간단한 방식이다. 여기서, 인수로 받은 username과 password를 암호화하여 저장하도록 바꾸면 된다.</p>\n<p>그런데 이때 <code>pbkdf2</code>를 그냥 사용하면 콜백 함수 내에서만 derivedKey를 확인할 수 있어 모듈을 작성하고 Promise 객체를 사용하는 등 귀찮은 점이 있다. 따라서 pbkdf2 로 암호화한 <buffer> 를 그대로 리턴해 주는 <code>pbkdf2Sync</code> 함수를 사용한다. 사용 방법은 crpyto 공식 문서를 참고하였다.</buffer></p>\n<pre><code class=\"language-js\">const userInfoInsert = async (username, password) => {\n    const userInsertQuery = \"insert into users(username, password) values(?,?)\";\n    const cryptedPassword =\n        pbkdf2Sync(password, \"salt\", 65536, 32, \"sha512\").toString(\"hex\");\n    console.log(cryptedPassword);\n    await connection.query(userInsertQuery, [username, cryptedPassword]);\n};\n</code></pre>\n<p>이때 주의할 점이 있다. 우리는 keylen을 32로 하여 <code>pbkdf2 </code> 함수를 통해 길이 64의, 패스워드를 암호화한 코드를 생성한다. 그런데 만약 유저 정보를 저장하는 DB가 password 길이를 <code>nvarchar(20)</code> 과 같은 길이로 저장해 놓았다면 유저 정보를 삽입하는 과정에서 에러가 발생한다. 따라서 미리 DB를 잘 모델링해놓아야 할 것이다. 나는 password를 넉넉하게 <code>nvarchar(200)</code> 으로 다시 만들었다.</p>\n<p>이때, 일반적인 웹사이트에는 아이디와 비밀번호에 길이 제한이 있다. 가령 아이디는 20자 미만이라든지, 비밀번호는 알파벳 소문자와 숫자와 특수문자를 조합한 8자 이상 20자 미만의 문자열이라든지 하는 식이다. 하지만 이런 부분은 암호화를 거치고 나면 모두 길이 64의 문자열이 되어버린다. 따라서 이런 부분은 클라이언트에서 유저에게 입력을 받는 창에서라든지, 아니면 DB에 삽입하기 전 <code>username</code> 과 <code>password</code> 를 DB 삽입 함수에 인수로 받을 때 검사해 줘야 한다. 아무튼 암호화하기 전에만 검사하면 된다. 이는 추후에 추가 예정이다.</p>\n<p>그리고 아예 DB 삽입 함수에 인수로 전달하기 전에, 클라이언트에서 <code>password</code> 를 전달할 때 미리 암호화해야 더 안전하지 않겠냐고 생각할 수 있다. 그러나 이는 클라이언트에서 서버로 데이터를 전송할 때 <code>https</code>가 알아서 암호화를 해주므로 걱정할 필요가 없다.</p>\n<h2>2.1 salt의 랜덤 생성</h2>\n<p>우리는 방금 해시에 솔트를 추가할 때 <code>salt</code> 라는 아주 단순한 문자열을 사용하였다. 이렇게 해도 평문으로 저장하는 것보다는 훨씬 낫겠지만 여전히 개선할 수 있는 부분은 많다. 더 좋은 암호화 방식을 쓰는 방법도 있지만 그건 다음 문단에 다루기로 하고, 일단 새로운 유저 정보가 저장될 때마다 새로운 솔트를 랜덤으로 생성해서 그걸 이용해 암호화하고, 유저 정보와 각각의 솔트를 함께 저장하는 방법을 생각할 수 있다.</p>\n<p>이를 위해 <code>crypto</code> 모듈에 있는 <code>randomBytes</code> 함수를 사용하자. 이는 암호학적으로 강력한 랜덤 데이터를 생성해 준다. 간단한 예시 코드는 다음과 같다.</p>\n<pre><code class=\"language-js\">import {randomBytes} from \"crypto\";\n\nconst buf = randomBytes(64).toString(\"hex\");\nconsole.log(buf.length, buf);\n</code></pre>\n<p>이렇게 하면 길이 128의, 무작위로 생성된 문자열을 얻을 수 있다. 이때 <code>randomBytes</code>의 인수를 조정함으로써 다른 길이의 문자열도 얻을 수 있다. 우리는 추후에 길이 64의 salt 문자열을 사용할 예정이다.</p>\n<p>그럼 새로운 비밀번호를 생성할 때마다 랜덤 문자열을 생성해서 salt로 쓴다고 하는데, 이를 어떻게 비밀번호와 같이 저장해 줄까? 비밀번호 필드에 같이 저장해 주면 된다. 비밀번호를 암호화한 문자열과 salt에는 알파벳 소문자와 숫자만이 쓰이므로 거기에 들어가지 않는 문자를 구분자로 사용해서 구분해 주면 된다. 나는 <code>$</code>를 사용해 주기로 하였다.</p>\n<p>그걸 이용해 저장하는 함수를 고쳐 주면 이렇게 된다.</p>\n<pre><code class=\"language-js\">const userInfoInsert = async (username, password) => {\n    const userInsertQuery = \"insert into users(username, password) values(?,?)\";\n    const randomSalt=randomBytes(32).toString(\"hex\");\n    const cryptedPassword =\n      pbkdf2Sync(password, randomSalt, 65536, 64, \"sha512\").toString(\"hex\");\n    const passwordWithSalt=cryptedPassword+\"$\"+randomSalt;\n    await connection.query(userInsertQuery, [username, passwordWithSalt]);\n};\n</code></pre>\n<p>이 코드를 이용해 <code>testpw</code> 라는 문자열을 암호화하면 다음과 같은 결과가 나온다.</p>\n<pre><code>1803148bc1c4ee7e914365d49009a62b4a89c7cfa85b41d6aa7e6fe890108e5aa7c74936c1d71ff79177add2a147064b9e085a4ddda0e68cc8dca880ab0ae01a$51fffaa2c8c55d76969e7ab927a47a82aa5dfd278fd3e01bd0d6a31b18be8326\n</code></pre>\n<p>이때 이는 랜덤 salt를 이용해서 암호화한 것이므로 다시 암호화하면 또 결과가 달라진다. 잘 찾아보면 위 문자열의 중간에 <code>$</code>가 있는데, <code>$</code> 뒤에 나오는 문자열이 salt이다. 나중에 입력된 암호와 대조할 때 이 salt를 이용할 것이다.</p>\n<h1>3. 암호화된 문자열 대조</h1>\n<pre><code class=\"language-js\">const userPasswordVerify = async (givenPassword, encryptedPasswordAndSalt) => {\n  const [encrypted, salt] = encryptedPasswordAndSalt.split(\"$\");\n  const givenEncrypted = pbkdf2Sync(givenPassword, salt, 65536, 64, \"sha512\").toString(\"hex\");\n  if (givenEncrypted === encrypted) {\n    return 1;\n  }\n  else {\n    return 0;\n  }\n}\n</code></pre>\n<p><code>givenPassword</code> 가 평문으로 주어지고, <code>encryptedPasswordAndSalt</code> 가 암호화된 상태로 주어진다. 그러면 아까 비밀번호를 저장할 때 비밀번호와 salt가 <code>$</code> 를 경계로 더해져 있으므로 먼저 <code>$</code>를 기준으로 split해서 비구조화 할당을 해준다. 그리고 평문으로 주어진 <code>givenPassword</code> 를 그 salt를 이용해 암호화한다. <code>pbkdf2Sync</code> 를 사용한다.</p>\n<p>그리고 <code>givenPassword</code> 를 암호화한 문자열과 아까 비구조화 할당한, <code>encrypted</code>를 비교하면 유저가 입력한 비밀번호와 암호화되어 저장된 비밀번호를 비교할 수 있다. 그렇게 비교해준 뒤 유저가 입력한 비밀번호가 저장된 것과 일치하면 1, 불일치하면 0을 반환해 준다.</p>\n<p>이를 <code>passport</code>에 인증하는 부분에 사용할 것이다.</p>\n<pre><code class=\"language-js\">//passport에서 LocalStrategy 를 지정하는 부분\npassport.use(\n    new LocalStrategy(\n        async (username, password, done) => {\n            const result = await userInfoFilteredByID(username);\n\n            if (result.length > 0) {\n                const user = result[0];\n                if (await userPasswordVerify(password, user.password)===1) {\n                    return done(null, user);\n                } else {\n                    return done(null, false, {message: \"틀린 비밀번호입니다\"});\n                }\n            } else {\n                return done(null, false, {message: \"존재하지 않는 유저입니다\"});\n            }\n        }\n    )\n);\n</code></pre>\n<p>이걸 <code>bcrypt</code> 나 <code>scrpyt</code>를 활용해서 암호화하면 더 안전하게 암호화할 수 있다. 물론 DB 자체가 털리면 어쩔 수 없지만 그렇다 해도 비밀번호 해독에 걸리는 시간을 벌 수 있으므로 로그를 보고 DB가 털린 걸 알면 거기에 대한 대처를 할 수 있는 시간이 있다.</p>\n<p>그리고 더 안전한 암호화 방식을 쓰면 암호화할 때 CPU 연산이 더 들어가므로 그 부분이 디도스 공격에 대한 취약점이 될 수 있는 것이다. 따라서 어느 정도 trade-off가 존재하는 것이다. 하지만 안전하긴 하므로 다음에 할 프로젝트에서는 <code>scrypt</code>를 쓸 것이다.</p>\n<p>참고</p>\n<p>zerocho 블로그 암호화 관련 포스트 <a href=\"https://www.zerocho.com/category/NodeJS/post/593a487c2ed1da0018cff95d\">https://www.zerocho.com/category/NodeJS/post/593a487c2ed1da0018cff95d</a></p>\n<p>crypto 모듈 관련 블로그 포스트 <a href=\"https://lwndnjs93.tistory.com/101\">https://lwndnjs93.tistory.com/101</a></p>\n<p>GeeksforGeeks의 scrypt 메서드 관련 글 <a href=\"https://www.geeksforgeeks.org/node-js-crypto-scrypt-method/\">https://www.geeksforgeeks.org/node-js-crypto-scrypt-method/</a></p>\n<p>scrypt로 패스워드 암호화하기 <a href=\"https://elvanov.com/2420\">https://elvanov.com/2420</a></p>\n<p>crypto 공식 문서 <a href=\"https://nodejs.org/api/crypto.html#crypto_crypto_scrypt_password_salt_keylen_options_callback\">https://nodejs.org/api/crypto.html#crypto_crypto_scrypt_password_salt_keylen_options_callback</a></p>\n<p>Node.js 단방향 암호화 <a href=\"https://velog.io/@neity16/NodeJS-crypto%EB%8B%A8%EB%B0%A9%ED%96%A5-%EC%95%94%ED%98%B8%ED%99%94\">https://velog.io/@neity16/NodeJS-crypto%EB%8B%A8%EB%B0%A9%ED%96%A5-%EC%95%94%ED%98%B8%ED%99%94</a></p>\n<p>https의 암호화 <a href=\"https://eun-jeong.tistory.com/27\">https://eun-jeong.tistory.com/27</a></p>\n<div style=\"color:white\"> \n    내가 누구? 데브시스터즈 프론트 리드 xo.dev\n</div>",
    "excerpt": "1. 사용자 정보 암호화\n전 글에서는 DB에 사용자 정보를 평문으로 저장하였다. 그러나 이는 매우 위험한 행위이다. 어떤 이유로든 사용자 정보를 담은 DB가 유출되었을 경우에 해커가 사용자들의 정보를 그대로 알 수 있기 때문이다. 따라서 해커들이 DB를 털더라도 사용자 정보를 알아낼 수 없게 하기 위해 수많은 알고리즘이 개발되었다.\n물론 해킹 기술도 발전하므로 SHA1 과 같은, 폐기된 알고리즘들도 있다. 하지만 여전히 뚫기 힘든 암호화 알고리즘들이 존재한다. ",
    "headingTree": [
      {
        "title": "1. 사용자 정보 암호화",
        "url": "#1-사용자-정보-암호화",
        "items": []
      },
      {
        "title": "2. 사용자 정보 암호화해 저장하기 - pbkdf2",
        "url": "#2-사용자-정보-암호화해-저장하기---pbkdf2",
        "items": [
          {
            "title": "2.1 salt의 랜덤 생성",
            "url": "#21-salt의-랜덤-생성",
            "items": []
          }
        ]
      },
      {
        "title": "3. 암호화된 문자열 대조",
        "url": "#3-암호화된-문자열-대조",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 2,
      "wordCount": 405
    },
    "url": "/posts/passport-encrypt",
    "thumbnail": {
      "local": "/thumbnails/passport-encrypt-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-passport-encrypt-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAkklEQVR4nGNYvnx5WlpaUVHR3r17/////wcM/v//z9DT06OlpW1qahocHFxaWlpbW5ucnJyTk8OQk5MjJCRkYGCQkJCgBgYNDQ3Pnj1jyM3JkZOTY2dnd3Jy0tXVtbW1DQgIUFZWZti5c9eSJUtWrVp1BgwuXbp04cKFzZs3M6zftHXDhk179+69c+cOxPL/YAAATdhPoRpDWMEAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "passport-login-basic",
    "title": "Express - passport로 로그인과 회원가입 구현하기 - 시작",
    "date": "2021-08-17T00:00:00Z",
    "description": "Passport 사용하기, 그 삽질의 기록",
    "tags": [
      "web"
    ],
    "html": "<h1>1. Passport 는</h1>\n<p>Express를 이용해서 백엔드 클론코딩을 하고 있는데, 회원가입과 로그인을 구현하는 데 있어 passport라는 미들웨어를 사용하기로 하였다. 굉장히 골치아팠던 끝에 이뤄낸 코드와 이해였기에 부족하지만 이곳에 흔적을 남긴다. 주로 passport 공식 문서를 기반으로 내가 이해한 내용이다.</p>\n<p>유저로부터 입력을 받아서 이 유저가 DB에 존재하는 유저인지 확인하고 아이디와 패스워드를 대조해서 로그인 성공 혹은 실패를 알려주고 싶다고 하자.</p>\n<p>이는 우리가 흔히 사용하는 사이트에 당연히 있는 기능이다. 어딘가에 내 정보가 저장되어 있고 내가 아이디와 비밀번호를 입력하면 맞는 입력일 때 또는 틀린 입력임에 따라 특정 동작을 해 주는 것이다.(보통 로그인 성공시에는 보고 있던 원래 페이지에서 로그인만 성공한 상태로 리다이렉트된다)</p>\n<p>그러면 이것을 실제로 구현하려면 어떻게 할까.</p>\n<p>가장 단순한 방식은, post 메서드를 이용하여 사용자가 클라이언트에서 보낸 요청(req)에 들어 있는 아이디와 비밀번호를 유저 DB에서 조회하는 방식을 생각할 수 있다.(<code>SELECT * FROM USER WHERE ID=req.body.id and PASSWORD=req.body.password </code>)</p>\n<p>DB에 유저 정보가 암호화된 상태로 저장되어 있다면 <code>req.body</code> 의 정보를 salting+hashing 해준 후에 조회해주어야 하겠지만 기본 로직은 같을 것이다.</p>\n<p>그러나 이런 방식은 그다지 좋지 않다.</p>\n<p>가령 다음과 같은 코드를 작성한다고 하자.</p>\n<pre><code class=\"language-javascript\">app.post(\"/login\", (req, res)=>{\n    /* 유저가 입력한 정보를 DB에 쿼리를 날려 검증하고\n     로그인 성공/실패시에 해줄 동작을 작성해 준다 */\n})\n</code></pre>\n<p>그러면 유저 입력에 대응되는 쿼리를 DB에 날리고 성공/실패에 따라 특정 동작을 해주는 것이 하나의 콜백 함수 안에서 모두 이루어진다. 이는 난잡하고 좋지 않다. 따라서 나온 것이 Passport이다. 페이지에서 온 요청에 대한 인증과 그 결과에 따라 실행되는 콜백을 분리해 주는 것이다.</p>\n<p>즉, Passport는 Node.js에서 인증을 위해 쓰이는 미들웨어이다(<a href=\"http://www.passportjs.org/docs/\">http://www.passportjs.org/docs/</a> 공식 문서에서 발췌) . 다음 코드와 같이 사용된다.</p>\n<pre><code class=\"language-javascript\">app.post('/login',\n  passport.authenticate('local'),\n  //'local' 인수가 무슨 뜻인지는 글 뒤쪽에 다룬다\n  function(req, res) {\n    // 인증이 성공했을 시에 이 콜백이 호출된다\n  });\n</code></pre>\n<p>위 코드의 주석에 써 있다시피 authenticate 가 성공하면 다음 라우트 핸들러(콜백함수)가 호출된다. 그럼 만약 실패하면? 401에러(자격 증명 없음)가 응답되고 라우트 핸들러는 실행되지 않는다. 포스트 메서드는 401에러로 끝나버린다.</p>\n<p>이렇게 바로 post 요청을 처리하기 전에, 인증을 거쳐주는 미들웨어가 passport인 것이다. 정확히는 인증을 해주는 strategy(아이디/비밀번호로 인증하는 방식, 구글/페이스북 따위로 인증하는 방식 등이 있다. 페이지에 온 요청에 대해 어떻게 인증할 것인지를 결정해 준다고 생각하면 된다)에 연결시켜 준 후 그 결과를 받아오는 것이다.</p>\n<h1>2. 인증 결과 다루기</h1>\n<p>passport는 post메서드로 온 요청을 authenticate strategy로 연결해 주고 그 결과를 받아오는데, 그 결과를 다루는 몇 가지 방법들도 제공하고 있다.</p>\n<h2>2.1 리다이렉션</h2>\n<p>가령 로그인 인증이 성공하면 홈 페이지로, 실패하면 다시 로그인 페이지로 돌아가게 하는 리다이렉션을 생각해 볼 수 있다.</p>\n<pre><code class=\"language-javascript\">app.post('/login',\n  passport.authenticate('local', { successRedirect: '/',\n                                   failureRedirect: '/login' }));\n</code></pre>\n<p>그건 위와 같이 처리할 수 있다. 직관적이지 않은가? 인증이 성공하면 successRedirect의 페이지로, 실패하면 failureRedirect의 페이지로 이동하는 것이다.</p>\n<h2>2.2 플래시 메시지</h2>\n<p>성공 혹은 실패했을 시에 한번 뜨고 사라지는 플래시 메시지를 띄워 주는 것도 가능하다.</p>\n<p>로그인할 때 오타 따위로 정보를 잘못 입력해서 <code>아이디 혹은 비밀번호가 틀렸습니다</code> 따위의 경고창이 뜨는 걸 누구나 한번쯤 겪어 봤을 것이다. 혹은 로그인이 성공했을 때 <code>환영해요!</code> 같은 메시지를 띄워 주는 것 등 말이다. 바로 그런 창을 띄워 주는 기능이다.</p>\n<p>이는 <code>authenciate</code> 함수의 두번째 인자로 주는 객체에 <code>successFlash</code>, <code>failureFlash</code> 옵션을 주는 것으로 가능하다.</p>\n<pre><code class=\"language-javascript\">app.post('/login',\n  passport.authenticate('local', { successRedirect: '/',\n                                   failureRedirect: '/login',\n                                   successFlash: '환영합니다!',\n                                   failureFlash: true })\n);\n</code></pre>\n<p><code>successFlash</code> 에는 <code>환영합니다!</code> 라는 커스텀 메시지를, <code>failureFlash</code>에는 단순한 true 옵션을 주었다. 이렇게 <code>failureFlash</code>에 true옵션만 주면 passport에서 인증을 위해 연결한 strategy의 인증 콜백에서 나온 에러 메시지를 출력해 주는 코드가 된다.</p>\n<p>각 strategy에서 사용하는 인증 콜백에서 나온 에러 메시지가 가장 정확하므로 이런 식으로 Flash 옵션에 true만 주는 것이 제일 무난한 방식이다.</p>\n<p>단 최신 익스프레스에서는 플래시 메시지를 띄워 주는 기능이 분리되었으므로 <code>connect-flash</code> 미들웨어를 설치해야 사용할 수 있다.</p>\n<p>passport에서 제공해 주는 이런 빌트인 리다이렉션 기능들을 사용하면, 성공시에 라우트 핸들러로 넘어가는 동작은 실행되지 않는다.</p>\n<h2>2.3 세션 사용하지 않기</h2>\n<p>보통 한번 로그인하면 로그인한 정보는 세션에 저장된다. 그러나 어떤 정보는 매우 민감하여 거기에 접근할 때마다 인증을 거쳐야 한다든지 하는 경우 이렇게 세션에 로그인 정보를 저장해 놓는 것은 불필요하다. 그럴 땐 <code>authentiacate</code> 함수에 세션을 사용하지 않는 옵션을 줄 수 있다.</p>\n<pre><code class=\"language-javascript\">passport.authenticate('basic', { session: false })\n//세션을 사용하지 않는다\n</code></pre>\n<h2>2.4 인증 결과를 커스텀 콜백으로 다루기</h2>\n<p>passport에서 기본적으로 제공하는 이런 옵션들이 마음에 들지 않을 경우, 인증 결과(성공/실패)에 따라 특정 동작을 하게 하는 커스텀 콜백함수를 직접 짤 수도 있다.</p>\n<pre><code class=\"language-javascript\">app.get('/login', (req, res, next) => {\n  passport.authenticate('local', (err, user, info) => {\n    if (err) { return next(err); }\n      //만약 어떤 예외가 발생할 시 err에 특정 값이 들어갈 것이다. 예외가 없을 시 null\n    if (!user) { return res.redirect('/login'); }\n      //인증 실패시에 user는 false로 설정될 것이다.\n    req.logIn(user, (err) => {\n      if (err) { return next(err); }\n      return res.redirect('/users/' + user.username);\n    });\n  })(req, res, next);\n});\n</code></pre>\n<p>이때 <code>authenticate</code> 함수는 라우트 미들웨어로 들어간 게 아니라 라우트 핸들러에 들어 있다. 이는 <code>authenticate</code> 함수 내에서 호출하는 콜백에서 <code>req</code>와 <code>res</code>에 접근할 수 있게 해 준다.</p>\n<p>그리고 커스텀 콜백을 사용하게 되면 위의 코드에서 <code>req.logIn</code> 을 사용하는 것과 같이, 세션을 다루는 것을 따로 코드로 작성해줘야 한다.</p>\n<h1>3. Passport를 쓰기 위한 설정하기</h1>\n<p>Passport를 어떤 인증을 위해 사용하려면 3가지가 필요하다.</p>\n<ol>\n<li>인증 strategy(Provider)</li>\n<li>어플리케이션 미들웨어</li>\n<li>세션(필수는 아님)</li>\n</ol>\n<p>하나하나 살펴보자.</p>\n<h2>3.1 Strategy</h2>\n<p>passport는 사실 그 자체만으로는 특별한 기능이 없다. 다른 무언가-인증을 제공하는 provider-로 중개해 주는 역할을 할 뿐인 미들웨어이기 때문이다. 이때 passport가 중개해서 인증을 받아오는 provider를 strategy라고 부른다. 이런 strategy는 우리가 흔히 사용하는 것과 같은 아이디와 비밀번호를 입력해 인증하는 local strategy(<code>passport-local</code>), 구글/페이스북/카카오 등을 통해 로그인하는 strategy(<code>passport-facebook</code> 등)등이 있다.</p>\n<p>정말 너무 많은 strategy가 있기 때문에 다 댈 수는 없고 관심이 있는 사람은 이곳에서 보도록 하자. (<a href=\"http://www.passportjs.org/packages/\">http://www.passportjs.org/packages/</a>)</p>\n<p>따라서 우리는 passport를 통해 인증을 처리해 주기 전에, passport에서 어떤 strategy를 이용해서 인증을 처리할 것인지 지정해 줘야 한다.</p>\n<p>strategy 설정은 <code>passport.use()</code>함수를 통해 할 수 있다. 예를 들어 내가 <code>passport-local</code>, 즉 username과 password를 이용해서 인증하는 strategy를 사용하기 위해 작성한 코드는 다음과 같다. 공식 문서에 있는 코드를 약간 변경하였다.</p>\n<pre><code class=\"language-javascript\">import passport from \"passport\";\nimport passportLocal from \"passport-local\";\nimport userList from \"./userList.js\";\n\nconst LocalStrategy=passportLocal.Strategy;\n\npassport.use(\n    new LocalStrategy(\n        //verify callback\n        (username, password, done)=>{\n            const result=userList.filter((user)=>user.username===username);\n\n            if(result.length>0){\n                const user=result[0];\n                if(user.password===password){\n                    return done(null, user);\n                }\n                else{\n                    return done(null, false, {message:\"틀린 비밀번호입니다\"});\n                }\n            }\n            else{\n                return done(null, false, {message:\"존재하지 않는 유저입니다\"});\n            }\n        }\n    )\n);\n</code></pre>\n<pre><code class=\"language-javascript\">app.post('/login', \n  passport.authenticate('local', { failureRedirect: '/login' }),\n  (req, res) => {\n    //인증이 성공시에 이 콜백으로 온다\n    res.redirect('/');\n  }\n);\n</code></pre>\n<p>조금은 허술한 코드이다. 하지만 DB 연결 등을 하기 전에도 작동하게 만들기 위한 일이다. 대략적인 로직은 다음과 같다.</p>\n<p>먼저 <code>passport-local</code>의 strategy를 import한 후에 strategy에 인증을 위한 콜백(verify callback이라 한다)을 넣어 준다. 이 콜백의 목적은 자격을 갖춘 사용자(혹은 요청)인지 검증하는 것이다. 즉 passport에서 받아서 어플리케이션에 전달해 줘야 하는 '인증'을 주는 역할이라는 것이다. 비밀번호가 맞는지 틀린지, 적절한 요청인지, 요청을 처리할 때 에러는 없는지, 그런 것들 말이다.</p>\n<p>그럼 이 인증 콜백이 어떻게 작동하는지 보자.</p>\n<p>passport는 요청에 대한 검증을 할 때, 요청에 포함되어 있는 자격들을 가져온다. 일반적인 express 라우트 핸들러에서 <code>req.body </code>의 내용을 가져오는 것과 비슷하다. 여기서는 username과 password를 가져왔다.</p>\n<p>그러면 우리는 이 값들을 가지고 이 username과 password가 정말 존재하는 사용자의 것인지 검증해야 한다. 지금은 일단 단순한 배열을 사용하였다. <code>userList.js</code>에 현재 존재하는 자격있는 사용자들의 username, password가 든 객체들을 담은 배열이 있다.</p>\n<pre><code class=\"language-javascript\">//userList.js\nconst userList=[\n    {\n        username:\"test\",\n        password:\"testpw\"\n    },\n    {\n        username:\"test1\",\n        password:\"testpw1\"\n    },\n    {\n        username:\"test2\",\n        password:\"testpw2\"\n    },\n];\n\nexport default userList;\n</code></pre>\n<p>다시 인증 콜백으로 돌아가면, javascript filter함수를 사용하여, post를 통해 받은 요청에 있는 username과 같은 username을 가진 자격있는 사용자가 있는지 검증한다. 그리고 만약 그런 사용자가 있을 경우 패스워드에 대해서도 검사하는 것이다. 그리고 이런 검사들이 실패하거나 성공함에 따라 적절한 <code>done</code>을 적용한다.</p>\n<h3>3.1.1 done에 대하여</h3>\n<p>이 문단 참고 자료 : zerocho님 블로그 포스트 <a href=\"https://www.zerocho.com/category/NodeJS/post/57b7101ecfbef617003bf457\">https://www.zerocho.com/category/NodeJS/post/57b7101ecfbef617003bf457</a></p>\n<p>그럼 <code>done</code>은 무엇인가? 무슨 역할을 하는가? 만약 요청이 유효하면 인증 콜백은 <code>done</code> 콜백을 호출해서 passport에 인증한 결과를 전달한다. 이때의 유효한 요청이란 꼭 자격있음이 검증되었다는 의미가 아니라 서버 에러나 인증 콜백 실행에 에러가 없었고 자격 검증의 성공이든 실패든 결과가 정상적으로 나올 수 있었던 요청이라는 의미이다.</p>\n<p>그리고 done이 호출되면 done을 호출한 strategy 콜백은 종료되고 다시 <code>authenticate</code> 단으로 돌아가서 <code>done</code> 콜백이 전달한 결과에 따라 다르게 동작한다.</p>\n<p>정리하면 이렇다.</p>\n<hr>\n<p><code>app.post</code>의 도메인에서 요청을 전달받음 -> <code>passport.authenticate</code>함수를 호출하고 그 인자에 따라 다른 strategy 콜백을 호출함. 위의 코드에서는 <code>LocalStrategy</code>의 콜백을 호출한다 -> <code>LocalStrategy</code>의 콜백 함수 속에서 인증이 진행되고 어떤 조건에 의해 <code>done</code> 이 호출됨 -> <code>done</code> 은 인증을 시도한 결과에 대한 정보를 리턴하고 이 정보는 <code>LocalStrategy</code> 에서 인증을 시도한 결과로서 <code>authenciate</code>의 리턴값이 됨 -> 이 리턴값에 따라 <code>app.post</code>에서는 특정 동작을 취해 주거나 다른 콜백을 호출함</p>\n<hr>\n<p>그럼 <code>done</code> 이 받는 3개의 인자는 무슨 뜻일까?</p>\n<p>먼저 첫번째 인자는 위의 코드에서는 언제나 null인데, 서버 에러를 넣는 곳이다. 현재는 JS배열에 유저 정보들을 저장하고 있는데 만약 DB를 사용한다면 DB를 연결하다가 에러가 발생할 수 있다. 그런 에러들을 넣는 곳이다. 따라서 위의 경우에는 언제나 null이라고 할 수 있다.</p>\n<p>그러나 DB 연결 실패 등의 서버 에러가 만약 발생했을 시에는 done은 다음과 같이 호출된다.</p>\n<pre><code class=\"language-javascript\">return done(err);\n//express에서 DB에 연결할 때 쓰는 콜백에는 보통 err가 인수 중 하나로 들어간다\n</code></pre>\n<p>두번째 인자는 인증이 성공했을 시에 passport에 전달해줄, 인증된 값에 대한 정보이다. 인증이 성공했을 시에는 인증이 성공한 user의 정보를 담고 있는 객체를 passport에 전달한다.</p>\n<p>그런데 만약 비밀번호가 틀리거나 존재하지 않는 아이디라는 등의 이유로 인증이 실패하면 <code>done</code>의 두번째 인자는 false로 주어져야 한다. 인증이 실패했다는 것을 알리기 위해서이다.</p>\n<p>세번째 인자는 실패 이유에 대한 것을 나타낼 수 있는 에러 메시지를 전달해 주는 데에 쓰인다. 이는 인증이 실패했을 시에 플래시 메시지 등을 띄워주고자 할 시에 유용하다. 가령 <code>존재하지 않는 회원입니다</code> 와 <code>비밀번호가 틀렸습니다</code> 는 둘 다 인증 실패이지만, 다른 메시지를 사용자에게 보여주고자 할 수 있다. 그런 경우에 <code>done</code>의 세번째 인자를 통해 추가적인 정보를 전달할 수 있다.</p>\n<p>이런 방식을 통해 얻는 것이 무엇이냐면, passport는 실제 인증에 쓰이는 strategy와 무관하게 작동할 수 있다는 것이다. passport단에서는 어떻게 유저 정보가 저장되고 인증이 진행되는지 전혀 알 수 없다. 그저 들어온 요청을 passport에 연결된 어떤 strategy로 보내줄 뿐이다. 이는 반대로 말하면 passport단에서는 인증의 진행에 대해 어떤 제한을 걸 수 없고, 따라서 인증을 진행하는 단계는 매우 자유롭게 진행될 수 있다는 것이다.</p>\n<h2>3.2 어플리케이션 미들웨어</h2>\n<p>express에서 passport를 사용하려고 하면 미들웨어를 사용해 줘야 한다. 일단 passport를 시작하기 위해 <code>passport.initialize()</code> 를 사용해야 하고, 로그인 유지를 위해 세션을 사용한다면 <code>passport.session()</code> 도 사용해야 한다.</p>\n<p>이때 미들웨어란 post등의 방법을 통해 도메인에 요청이 들어왔을 때 실제 <code>post</code> 혹은 <code>get</code> 등에 도달하기 전까지 거치게 되는 콜백들을 뜻한다. 물론 공식 문서를 보면 직접 미들웨어를 만들어서 사용할 수도 있다. 다만 <code>(req, res)</code> 외에도 <code>next</code> 인수를 꼭 넣어 주어서 다음 미들웨어로 넘어갈 수 있도록 하는 것에 주의해야 한다. 미들웨어에 관해서는 나중에 따로 정리할 예정이다. 지금은 어플리케이션에 도달하는 요청(<code>req</code>)이 거쳐가게 되는 콜백 함수 정도로 생각하면 된다.</p>\n<p>나는 <code>/login</code> 이라는 도메인의 라우터에서 로그인을 진행했기에 라우터에 미들웨어를 달아 줬는데, passport 를 사용하기 위해 달아준 미들웨어는 다음과 같다.</p>\n<pre><code class=\"language-javascript\">router.use(session({\n    resave:false,\n    saveUninitialized:false,\n    secret:process.env.SESSION_SECRET\n    //.env를 이용해서 session의 비밀 키 관리(dotenv 사용)\n}));\n\nrouter.use(express.urlencoded({extended:false}));\nrouter.use(passport.initialize());\nrouter.use(passport.session());\n</code></pre>\n<p>만약 인증을 원하는 사용자로부터의 요청이 온다면 위에서 <code>router.use()</code> 로 달아준 미들웨어들을 모두 거치고 난 후에 다음 코드에 도달하여 인증을 거칠 것이다.</p>\n<pre><code class=\"language-javascript\">app.post('/', \n  //여기 도달한 req는 모두 위의 미들웨어를 거친 후에 오는 것이다\n  passport.authenticate('local', { failureRedirect: '/login' }),\n  (req, res) => {\n    //인증이 성공시에 이 콜백으로 온다\n    res.redirect('/');\n  }\n);\n</code></pre>\n<h2>3.3 세션</h2>\n<p>보통의 웹사이트에서는 한 번 로그인을 하면 그 브라우저를 닫을 때까지 로그인이 유지된다. 어떤 사이트에 로그인해서 글을 하나 보려고 다음 페이지로 넘어가는 순간 다시 로그인을 해야 한다면 얼마나 귀찮겠는가?</p>\n<p>따라서 거의 모든 웹사이트에서는 브라우저에서 접속할 때 한 번만 자격 증명(즉, 로그인)을 요구한다. 그리고 만약 로그인이 성공하면 세션이 만들어진다. 이 세션은 브라우저를 통해 유지되면서 브라우저를 닫을 때까지 로그인을 지속시켜준다.</p>\n<p>정확히는 클라이언트로부터 온 유효한 로그인 요청을 서버에서 받았을 때, 로그인 요청이 성공 시 그 아이디를 세션에 저장하고 응답헤더에 <code>set-cookie: sessionid</code>를 넣어서 응답하는 것이다. 그렇게 하면 클라이언트는 이후 서버로 보내는 요청(가령 다른 페이지로 이동한다든지)을 할 때 쿠키를 통해 <code>sessionid</code>를 자동으로 넣어서 요청하게 된다. 그럼 그 요청을 받은 서버에서는 요청에 들어 있는 <code>sessionid</code> 값을 유효한지 확인 후 요청을 처리한다.</p>\n<p>인증에 이런 로그인 세션을 쓸 수 있게 하기 위해 passport에서는 <code>serializeUser</code> 와 <code>deserializeUser</code> 를 제공한다.</p>\n<pre><code class=\"language-javascript\">passport.serializeUser((user, done)=>{\n    done(null, user);\n});\n\npassport.deserializeUser((user, done)=>{\n    //id는 req.session.passport.user 에 저장된 값\n    done(null, user);\n});\n</code></pre>\n<p><code>serializeUser</code> 는 로그인 성공 시 실행되는 <code>done(null, user)</code> 에서 <code>user</code>를 전달받아서 세션에 저장한다. 그리고 <code>deserializeUser</code>는 서버로 요청이 들어올 때마다 세션에 들어 있는 정보를 실제의 데이터와 비교한다. 이때 <code>deserializeUser</code>의 <code>done</code>에서 받는 <code>user</code>는 <code>serializeUser</code> 에서 <code>done</code>으로 넘겨준 <code>user</code> 와 타입이 같아야 한다.</p>\n<p>왜냐 하면 <code>serializeUser</code>에서 <code>user</code> 를 세션에 저장하는데 <code>deserializeUser</code> 에서 받은 <code>user</code>는 세션에 들어 있는 것과 대조되어서 확인을 받기 때문이다. 만약 둘의 타입이 다르면, 가령 <code>serializeUser</code>는 <code>user.id</code> 만 저장했는데 <code>deserializeUser</code>는 <code>user</code> 전체가 세션에 있는지 확인한다면 무조건 인증은 실패할 것이다. 저장한 정보의 양과 인증 상태를 알기 위해 확인하라고 지시된 정보의 양이 다르기 때문이다.</p>\n<p>세션을 다루는 이 두 메서드는 꼭 있어야 passport가 작동한다.</p>\n<h1>4. Passport-local로 로그인 구현하기</h1>\n<p>우리가 흔히 사용하는, 아이디와 비밀번호 입력을 통해 구현하는 로그인 strategy가 바로 <code>passport-local</code> 이다. 이를 사용하기 위해서는 <code>passport-local</code> 모듈이 필요하다.</p>\n<pre><code>yarn add passport-local\n</code></pre>\n<p>터미널에서 설치해 주자.</p>\n<p>그리고 로그인 인증을 위한 코드를 짜 주기 전에 먼저 간단한 로그인 폼을 구현해 준다. 물론 postman 등으로 시험해 보아도 상관없지만 시각적인 효과가 있는 편이 좋다.</p>\n<pre><code class=\"language-html\">&#x3C;!-- loginView/index.html -->\n&#x3C;!DOCTYPE html>\n&#x3C;html lang=\"en\">\n&#x3C;head>\n    &#x3C;meta charset=\"UTF-8\">\n    &#x3C;title>Login Form&#x3C;/title>\n&#x3C;/head>\n&#x3C;body>\n&#x3C;form action=\"/login\" method=\"post\">\n    &#x3C;div>\n        &#x3C;label>Username : &#x3C;/label>\n        &#x3C;input type=\"text\" name=\"username\"/>&#x3C;br/>\n    &#x3C;/div>\n    &#x3C;div>\n        &#x3C;label>Password : &#x3C;/label>\n        &#x3C;input type=\"password\" name=\"password\"/>&#x3C;br/>\n    &#x3C;/div>\n    &#x3C;input type=\"submit\" value=\"submit\"/>\n&#x3C;/form>\n&#x3C;/body>\n&#x3C;/html>\n</code></pre>\n<p>이렇게 하고 브라우저로 열어 보면 초라하지만 흔히 볼 수 있는 것과 뼈대는 같은 로그인 창이 만들어진다.</p>\n<p><img src=\"/static/loginForm-99f41f0d.png\" alt=\"loginForm.png\"></p>\n<p>이곳에 아이디와 패스워드를 입력하고 제출하면 그것을 담은 요청이 <code>/login</code> 으로 전달될 것이다.</p>\n<p>그럼 이제 이걸 처리해주기 위한 passport 설정을 해주자.</p>\n<p>먼저 passport를 사용하기 위해 필요한 미들웨어들을 설정해 준다. 그리고 로그인 성공시에 보여줄 간단한 페이지를 만들어 주겠다.</p>\n<pre><code class=\"language-javascript\">router.use(session({\n    resave:false,\n    saveUninitialized:false,\n    secret:process.env.SESSION_SECRET\n    //.env를 사용한 세션 비밀 키\n}));\n\nrouter.use(express.urlencoded({extended:false}));\nrouter.use(passport.initialize());\nrouter.use(passport.session());\n\nrouter.use(\"/\", express.static(__dirname+\"/server/loginView/index.html\"));\nrouter.use(\"/success\", express.static(__dirname+\"/server/loginView/success.html\"));\n\n</code></pre>\n<pre><code class=\"language-html\">&#x3C;!-- loginView/success.html -->\n&#x3C;!DOCTYPE html>\n&#x3C;html lang=\"en\">\n&#x3C;head>\n    &#x3C;meta charset=\"UTF-8\">\n    &#x3C;title>Title&#x3C;/title>\n&#x3C;/head>\n&#x3C;body>\n    &#x3C;h1>LOGIN SUCCESS&#x3C;/h1>\n&#x3C;/body>\n&#x3C;/html>\n</code></pre>\n<p>이때 흔히 사용하는 <code>app.use</code> 가 아니라 <code>router.use</code> 인 까닭은 express router를 사용하여 홈 페이지가 아니라 따로 사용되는 로그인 페이지에서 로그인을 하도록 만들고자 했기 때문이다. 만약 홈 페이지에서 로그인을 해도 된다면 위의 <code>router.use</code> 를 <code>app.use</code> 로 바꾸면 된다.(사실 router인지 app인지 변수명이 중요하다기보다는 <code>express()</code> 와 <code>express.Router()</code> 의 차이이다)</p>\n<p>그럼 이제 passport에 strategy를 넣어주자.</p>\n<p>단 필요한 라이브러리와 검증에 사용되는 정보(추후에 DB를 연결하여 검증하도록 할 계획이지만 현재는 <code>userList.js</code> 에 저장된 배열)를 먼저 import해줘야 한다.</p>\n<pre><code class=\"language-javascript\">import passport from \"passport\";\nimport passportLocal from \"passport-local\";\nimport userList from \"./userList.js\";\n\nconst LocalStrategy=passportLocal.Strategy;\n</code></pre>\n<p>그 다음에 strategy와 <code>serializeUser</code>, <code>deserializeUser</code>를 넣어준다.</p>\n<pre><code class=\"language-javascript\">passport.use(\n    new LocalStrategy(\n        (username, password, done)=>{\n            const result=userList.filter((user)=>user.username===username);\n\n            if(result.length>0){\n                const user=result[0];\n                if(user.password===password){\n                    return done(null, user);\n                }\n                else{\n                    return done(null, false, {message:\"틀린 비밀번호입니다\"});\n                }\n            }\n            else{\n                return done(null, false, {message:\"존재하지 않는 유저입니다\"});\n            }\n        }\n    )\n);\n\npassport.serializeUser((user, done)=>{\n    done(null, user.username);\n});\n\npassport.deserializeUser((username, done)=>{\n    //id는 req.session.passport.user 에 저장된 값\n    done(null, username);\n});\n</code></pre>\n<p>마지막으로, 우리가 아까 HTML로 만들었던 로그인 폼은 <code>post</code> 메서드를 통해서 지정한 도메인에 전달되므로 그 요청을 받아 주도록 하자.</p>\n<pre><code class=\"language-javascript\">router.post(\"/\", passport.authenticate(\"local\",\n    { successRedirect: \"/login/success\",\n    failureRedirect: \"/login\",\n    failureFlash: \"로그인 실패\" })\n);\n</code></pre>\n<p>첫번째 인수로 준 도메인(\"/\")에서 요청을 받으면 이 요청의 body는 <code>passport.authenticate</code> 콜백으로 넘어간 후 <code>LocalStrategy</code> 로 위임되어 거기서 처리하게 된다. 그리고 <code>LocalStrategy</code> 에서 요청을 검사한 결과는 성공 혹은 실패로써 다시 <code>passport.authenticate</code> 단계로 전달된다. 이는 <code>passport.authenticate</code> 의 두번째 인수로 들어와 있는 처리 방법으로 연결된다. 가령 성공시에는 <code>/login/success</code> 로 리다이렉트된다.</p>\n<h2>4.1 LocalStrategy에서 다른 이름의 자격 사용하기</h2>\n<p><code>LocalStrategy</code> 는 기본적으로 <code>username</code> 과 <code>password</code> 라는 이름의 자격을 사용하여 인증하도록 되어 있다.  그런데 여기서 다른 이름의 자격을 사용하고 싶을 수도 있다. 예를 들어 유저의 아이디가 아니라 이메일을 이용해 로그인하도록 되어 있는 경우도 많다. 이럴 경우 유저의 이름 입력란에 <code>username</code> 보다는 <code>email</code> 을 넣는 게 더 적절한 선택일 것이다. 그럴 경우 <code>LocalStrategy</code> 에 다음과 같은 설정을 주는 것으로 가능하다.</p>\n<pre><code class=\"language-javascript\">passport.use(new LocalStrategy({\n    usernameField: 'email',\n    passwordField: 'password'\n  },\n  //LocalStrategy의 첫번째 인수를 통해서 바꿀 자격증명 이름을 설정\n  (username, password, done) => {\n    // ...\n  }\n));\n</code></pre>\n<p>다음 글에서는 사용자들의 정보를 담고 있는 DB에 연결해서 사용자를 인증하는 로직을 짜 보고, 간단하게 회원가입을 하는 부분을 만들어 보도록 하겠다.</p>\n<p>참고</p>\n<p>공식 문서 <a href=\"http://www.passportjs.org/docs/\">http://www.passportjs.org/docs/</a></p>\n<p>passport-local <a href=\"http://www.passportjs.org/packages/passport-local/\">http://www.passportjs.org/packages/passport-local/</a></p>\n<p>zerocho님 블로그 포스트 <a href=\"https://www.zerocho.com/category/NodeJS/post/57b7101ecfbef617003bf457\">https://www.zerocho.com/category/NodeJS/post/57b7101ecfbef617003bf457</a></p>\n<p>2G Dev 블로그 포스트 <a href=\"https://dev-dain.tistory.com/73?category=858558\">https://dev-dain.tistory.com/73?category=858558</a></p>\n<p><a href=\"https://stackoverflow.com/questions/26164837/difference-between-done-and-next-in-node-js-callbacks\">https://stackoverflow.com/questions/26164837/difference-between-done-and-next-in-node-js-callbacks</a></p>\n<p>express 미들웨어 공식 문서 <a href=\"https://expressjs.com/ko/guide/writing-middleware.html\">https://expressjs.com/ko/guide/writing-middleware.html</a></p>\n<p>jennyLee.log 블로그 <a href=\"https://velog.io/@wjddnjswjd12/node.js-express-%EB%AF%B8%EB%93%A4%EC%9B%A8%EC%96%B4%EB%9E%80\">https://velog.io/@wjddnjswjd12/node.js-express-%EB%AF%B8%EB%93%A4%EC%9B%A8%EC%96%B4%EB%9E%80</a></p>\n<p>serialize와 deserialize <a href=\"https://velog.io/@mollang/20.01.17-backend-serializeUser-%EC%99%80-deserializeUser\">https://velog.io/@mollang/20.01.17-backend-serializeUser-%EC%99%80-deserializeUser</a></p>\n<p>웹의 쿠키와 세션 <a href=\"https://chrisjune-13837.medium.com/web-%EC%BF%A0%ED%82%A4-%EC%84%B8%EC%85%98%EC%9D%B4%EB%9E%80-aa6bcb327582\">https://chrisjune-13837.medium.com/web-%EC%BF%A0%ED%82%A4-%EC%84%B8%EC%85%98%EC%9D%B4%EB%9E%80-aa6bcb327582</a></p>\n<p>패스포트 동작 원리와 인증 구현 <a href=\"https://jeonghwan-kim.github.io/dev/2020/06/20/passport.html\">https://jeonghwan-kim.github.io/dev/2020/06/20/passport.html</a></p>",
    "excerpt": "1. Passport 는\nExpress를 이용해서 백엔드 클론코딩을 하고 있는데, 회원가입과 로그인을 구현하는 데 있어 passport라는 미들웨어를 사용하기로 하였다. 굉장히 골치아팠던 끝에 이뤄낸 코드와 이해였기에 부족하지만 이곳에 흔적을 남긴다. 주로 passport 공식 문서를 기반으로 내가 이해한 내용이다.\n유저로부터 입력을 받아서 이 유저가 DB에 존재하는 유저인지 확인하고 아이디와 패스워드를 대조해서 로그인 성공 혹은 실패를 알려주고 싶다고 하자.\n",
    "headingTree": [
      {
        "title": "1. Passport 는",
        "url": "#1-passport-는",
        "items": []
      },
      {
        "title": "2. 인증 결과 다루기",
        "url": "#2-인증-결과-다루기",
        "items": [
          {
            "title": "2.1 리다이렉션",
            "url": "#21-리다이렉션",
            "items": []
          },
          {
            "title": "2.2 플래시 메시지",
            "url": "#22-플래시-메시지",
            "items": []
          },
          {
            "title": "2.3 세션 사용하지 않기",
            "url": "#23-세션-사용하지-않기",
            "items": []
          },
          {
            "title": "2.4 인증 결과를 커스텀 콜백으로 다루기",
            "url": "#24-인증-결과를-커스텀-콜백으로-다루기",
            "items": []
          }
        ]
      },
      {
        "title": "3. Passport를 쓰기 위한 설정하기",
        "url": "#3-passport를-쓰기-위한-설정하기",
        "items": [
          {
            "title": "3.1 Strategy",
            "url": "#31-strategy",
            "items": [
              {
                "title": "3.1.1 done에 대하여",
                "url": "#311-done에-대하여",
                "items": []
              }
            ]
          },
          {
            "title": "3.2 어플리케이션 미들웨어",
            "url": "#32-어플리케이션-미들웨어",
            "items": []
          },
          {
            "title": "3.3 세션",
            "url": "#33-세션",
            "items": []
          }
        ]
      },
      {
        "title": "4. Passport-local로 로그인 구현하기",
        "url": "#4-passport-local로-로그인-구현하기",
        "items": [
          {
            "title": "4.1 LocalStrategy에서 다른 이름의 자격 사용하기",
            "url": "#41-localstrategy에서-다른-이름의-자격-사용하기",
            "items": []
          }
        ]
      }
    ],
    "metadata": {
      "readingTime": 3,
      "wordCount": 876
    },
    "url": "/posts/passport-login-basic",
    "thumbnail": {
      "local": "/static/loginForm-99f41f0d.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-loginForm-99f41f0d-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAADCAIAAAAhqtkfAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAQElEQVR4nGMoLS0NCg6ZP3/+qVMnDoPB7t27b968ycDNzc3AwLRly5Yrly9fAoNTp069ePGCYdmy5YcPH/6PAQDIKTTFrQy+8wAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "passport-login-db",
    "title": "Express - passport로 로그인과 회원가입 구현하기 - DB 연결하기",
    "date": "2021-08-18T00:00:00Z",
    "description": "Passport 사용하기, 그 삽질의 기록2",
    "tags": [
      "web"
    ],
    "html": "<h1>1. 사용자 정보 DB 만들기</h1>\n<h2>1.1 DB 모델링</h2>\n<p>아까 passport를 이용해서 사용자 정보를 검증할 때에는 유저들의 정보를 단순한 객체 배열에 저장하였다. 그러나 이런 정보를 저장하기에 최적화된 DB를 따로 사용하는 게 합리적인 선택일 것이다. 나는 MySQL을 사용하기로 했다.</p>\n<p>나는 Express를 사용하고 있으므로 먼저 DB를 Express에 연결해 줘야 한다. 따라서 먼저 MySQL과의 연결을 구성해 줄 것이다.</p>\n<pre><code class=\"language-javascript\">// mysql/mysql_connection.js\nimport mysql from \"mysql2/promise\";\nimport dotenv from \"dotenv\";\n\ndotenv.config();\n//.env 파일을 사용해서 DB 접속 정보를 숨겼다\nconst connection=mysql.createPool({\n    host:process.env.DB_HOST,\n    user:process.env.DB_USER,\n    password:process.env.DB_PASSWORD,\n    database:process.env.DB_DATABASE\n});\n\nexport default connection;\n</code></pre>\n<p>그럼 DB에 사용자를 저장할 때는 어떤 정보를 어떻게 저장해야 할까? 나는 간단하게 유저의 고유 ID와 아이디, 패스워드만을 저장하기로 했다. 다음 쿼리문을 MySQL에 날려서 유저 테이블을 생성해 주었다.</p>\n<pre><code class=\"language-mysql\">create table users(\n    id int not null primary key auto_increment,\n    username nvarchar(20) not null unique,\n    password nvarchar(20) not null\n);\n</code></pre>\n<p>DB 연결이 성공적으로 수행되고 나면 <code>connection.query(쿼리문)</code> 으로 쿼리를 날려 줄 수 있는데 나는 그것을 통해 테이블을 만들어 주었다. 터미널에서 MySQL 커맨드라인으로 하는 게 편한 사람이라면 그렇게 해주어도 된다. 하지만 어차피 로그인과 회원가입 관련 api를 만들면서 <code>query</code> 함수를 통해서 SQL 쿼리를 날릴 일이 많이 생길 것이므로 그것을 사용하는 걸 추천한다.</p>\n<p>아무튼 저렇게 유저 정보 테이블을 구성하고 나면, 어플리케이션에서 온 요청을 검증해야 할 때 테이블에 쿼리를 날려서 검증할 수 있을 것이다. 그런데 테이블에 정보가 있어야 검증에 사용할 수 있을 것이다.</p>\n<h2>1.2 테이블에 정보 추가</h2>\n<p>따라서 insert 문을 이용해서 테이블에 정보를 추가해 주자.</p>\n<p>이때 나중에 회원가입을 만들면서 새로운 유저를 삽입하는 동작을 만들어야 한다고 생각해서, 지금 미리 뼈대라도 잡아 놓기로 했다. <code>username</code> 과 <code>password</code> 를 전달받아서 <code>users</code> 테이블에 삽입해 주는 함수는 다음과 같다.</p>\n<pre><code class=\"language-javascript\">const userInfoInsert = async (username, password) => {\n    const userInsertQuery = \"insert into users(username, password) values(?,?)\";\n    await connection.query(userInsertQuery, [username, password]);\n    console.log(\"새로운 유저 정보 삽입 완료\");\n};\n</code></pre>\n<p>그리고 임시로 <code>/user-insert</code> 경로를 만들어서 그곳에서 유저 정보 삽입을 할 수 있도록 하자. 이러면 postman을 통해서 쉽게 새로운 정보를 삽입하게 해줄 수 있다.</p>\n<pre><code class=\"language-javascript\">app.post(\"/user-insert\", async(req, res)=>{\n    const {username, password}=req.body;\n\n    try{\n        //간단한 에러 핸들링. username이 중복된 요청이 들어온다든가 하는 경우 에러가 발생함\n        const result=await userInfoInsert(username, password);\n        res.send(\"유저 정보 삽입 성공\");\n    }\n    catch(err){\n        res.send(\"에러 발생\");\n    }\n});\n</code></pre>\n<p>몇 개의 데이터를 삽입하였다. <code>SELECT * FROM USERS</code> 쿼리를 날려주면 다음과 같이 내가 삽입한 유저 정보를 확인할 수 있었다. 이제 이걸 이용해서 유저 정보를 검증하도록 만들어 주자.</p>\n<pre><code>+----+----------+----------+\n| id | username | password |\n+----+----------+----------+\n|  1 | test     | testpw   |\n|  2 | test1    | testpw1  |\n|  5 | test2    | testpw2  |\n|  7 | test3    | testpw3  |\n+----+----------+----------+\n</code></pre>\n<h1>2. DB를 이용해 로그인 요청 검증하기</h1>\n<p>바로 이전 글에서 passport에서 LocalStrategy를 이용해서 인증하던 것을 기억해 보자. 어떤 방식으로 했었나? userList라는 배열에서 filter함수를 이용해 요청에 있는 username을 가진 사용자가 존재하는지를 먼저 검사했다. 그리고 요청에 들어 있는 username과 같은 username을 가진 사용자가 없을 경우 로그인 실패였다.</p>\n<p>그리고 만약 같은 username을 가진 사용자는 있는데, 등록된 password와 요청에 들어있는 password가 다를 경우에도 로그인 실패였다. username과 password가 모두 같은 경우에만 로그인 성공으로 인정해 주었다.</p>\n<p>이를 DB를 이용하는 인증으로 바꿔 주자. 먼저 DB에 저장된 username들은 unique constraint가 걸려 있다. 일반적으로 회원 시스템은 중복 아이디를 허용하지 않으므로 이는 꽤 합리적인 모델링이다. 이는 무엇을 뜻하냐면, DB에 username으로 필터링하는 SELECT 쿼리를 날려서 결과를 받아오면 결과는 하나뿐이라는 것이다. 하나의 유저 정보 객체가 담긴 배열일 것이다.</p>\n<p>먼저 DB에서 username으로 필터링한 결과물을 리턴해 주는 함수를 만들자. 그 함수는 다음과 같을 것이다.</p>\n<pre><code class=\"language-javascript\">const userInfoFilteredByID = async (username) => {\n    const userFilterQuery = \"select * from users where username=?\";\n    const result = await connection.query(userFilterQuery, [username]);\n    return result[0];\n    /* result는 db에서 오는 엄청나게 다양한 정보를 담고 있고 index 0에 있는 것이 우리가 원하는 필터링을 한 유저 정보의 배열이다. 단 async 함수이므로 리턴값은 promise 객체에 감싸인 배열이고 이를 받아 줄 때는 await으로 받아 줘야 한다. */\n};\n</code></pre>\n<p>그러면 이제 이걸 이용해서 LocalStrategy의 인증 로직을 짜 줄 수 있다.</p>\n<p>위의 함수가 async 함수이므로 await으로 받아 준 데에 주의하라.</p>\n<pre><code class=\"language-javascript\">passport.use(\n    new LocalStrategy(\n        async (username, password, done) => {\n            const result = await userInfoFilteredByID(username);\n\t\t\t//result는 username으로 유저 DB를 필터링한 정보들을 담고 있는 배열이다\n            \n            if (result.length > 0) {\n                const user = result[0];\n                if (user.password === password) {\n                    return done(null, user);\n                } else {\n                    return done(null, false, {message: \"틀린 비밀번호입니다\"});\n                }\n            } else {\n                return done(null, false, {message: \"존재하지 않는 유저입니다\"});\n            }\n        }\n    )\n);\n</code></pre>\n<p>이제 우리는 DB에 담긴 유저 정보를 이용해서 사용자로부터 온 로그인 요청을 검사할 수 있다. 전체적인 구조는 앞에서 작성한, 배열을 이용한 것과 같다. 다만 로그인 요청에 담긴 정보가 실제로 존재하는 사용자에 대한 정보인지를 검증할 때 javascript 배열을 사용하는지 혹은 SQL 쿼리의 결과를 사용하는지의 차이가 있을 뿐이다.</p>\n<p>하지만 지금 우리가 짠 코드에는 아주 큰 문제가 있다. 사용자의 정보가 평문으로 저장되어 있다는 것이다. 지금은 <code>test</code> 나 <code>testpw</code> 따위의, 아무 의미도 없는 아이디와 패스워드만이 DB에 담겨 있다.</p>\n<p>하지만 실제로 사용자들이 사용하는 아이디와 패스워드가 평문으로 저장되어 있다면 보안상 매우 위험한 일이다. DB가 유출될 것을 대비하여 암호화를 해서 저장해야 한다. 당연히 이를 위해서도 많은 방법이 있고 그 중에 하나를 택해서 암호화하는 방법을 다음 글에서 알아보도록 하자.</p>\n<p>참고</p>\n<p>async/await으로 mysql 작성하기 <a href=\"https://holywater-jeong.github.io/2018/06/08/node-mysql-async-await\">https://holywater-jeong.github.io/2018/06/08/node-mysql-async-await</a></p>",
    "excerpt": "1. 사용자 정보 DB 만들기\n1.1 DB 모델링\n아까 passport를 이용해서 사용자 정보를 검증할 때에는 유저들의 정보를 단순한 객체 배열에 저장하였다. 그러나 이런 정보를 저장하기에 최적화된 DB를 따로 사용하는 게 합리적인 선택일 것이다. 나는 MySQL을 사용하기로 했다.\n나는 Express를 사용하고 있으므로 먼저 DB를 Express에 연결해 줘야 한다. 따라서 먼저 MySQL과의 연결을 구성해 줄 것이다.\n// mysql/mysql_connect",
    "headingTree": [
      {
        "title": "1. 사용자 정보 DB 만들기",
        "url": "#1-사용자-정보-db-만들기",
        "items": [
          {
            "title": "1.1 DB 모델링",
            "url": "#11-db-모델링",
            "items": []
          },
          {
            "title": "1.2 테이블에 정보 추가",
            "url": "#12-테이블에-정보-추가",
            "items": []
          }
        ]
      },
      {
        "title": "2. DB를 이용해 로그인 요청 검증하기",
        "url": "#2-db를-이용해-로그인-요청-검증하기",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 264
    },
    "url": "/posts/passport-login-db",
    "thumbnail": {
      "local": "/thumbnails/passport-login-db-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-passport-login-db-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAiklEQVR4nGNYtWpVVlZWWVnZvn37/v///wcM/v//z9Df329oaGhtbR0eHl5TU9PS0pKVldXY2MiQm5snKSlpaGgcGxsrDwZ1dXWurq4MdXW1bGxsenp6q1atunv37vXr19+/f3/69GmGA4eOzl+wYOfOnS9evkSxY8OmbVu2bt2zZ8+tW7cgEhASAJhNWtjRQ2AQAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "pintos-4",
    "title": "서강대학교 핀토스 - project 3",
    "date": "2022-11-16T00:00:00Z",
    "description": "핀토스 프로젝트 3 - Threads",
    "tags": [
      "CS"
    ],
    "html": "<h1>1. 프로젝트 시작</h1>\n<p>또 새로운 프로젝트가 나왔다. 그저 시작할 뿐이다..무엇을 해야 하는지부터 알아보자.</p>\n<p>핀토스는 현재 라운드 로빈 스케줄러를 사용하고 있다. 그리고 각 프로세스, 스레드의 우선순위를 전혀 고려하지 않는다. 따라서 이번 프로젝트에서는 alarm, 우선순위 스케줄링, BSD스케줄러를 구현해야 한다.</p>\n<p>주어진 것부터 검토하자.</p>\n<h2>1.1. 현재의 스케줄러</h2>\n<p>현재 라운드 로빈 방식으로 짜인 스케줄러는 어떻게 작동하는가?</p>\n<pre><code class=\"language-c\">// src/threads/thread.c\nvoid\nthread_yield (void)\n{\n  struct thread *cur = thread_current ();\n  enum intr_level old_level;\n\n  ASSERT (!intr_context ());\n  // 인터럽트를 비활성화하고 이전 인터럽트 상태 반환\n  old_level = intr_disable ();\n  if (cur != idle_thread)\n    list_push_back (&#x26;ready_list, &#x26;cur->elem);\n  // 스레드를 READY 상태로 변경\n  cur->status = THREAD_READY;\n  // 컨텍스트 스위칭\n  schedule ();\n  // 인자로 전달된 이전 인터럽트 상태로 인터럽트 활성화\n  intr_set_level (old_level);\n}\n</code></pre>\n<p>현재 작동하고 있는 스레드를 ready_list의 맨 뒤에 넣고 schedule()을 호출한다. schedule()은 ready_list의 맨 앞에 있는 스레드를 실행시킨다. 이때 쓰이는 함수가 next_thread_to_run, switch_threads이다. 이런 방식으로 ready_list에 있는 스레드를 순서대로 실행시키는 것을 반복한다.</p>\n<h2>1.2. 현재의 알람</h2>\n<p>timer_sleep은 현재 시간을 기준으로 ticks만큼 대기하도록 하는 함수이다.</p>\n<pre><code class=\"language-c\">void\ntimer_sleep (int64_t ticks)\n{\n  int64_t start = timer_ticks ();\n\n  ASSERT (intr_get_level () == INTR_ON);\n  while (timer_elapsed (start) &#x3C; ticks)\n    thread_yield ();\n}\n</code></pre>\n<p>timer_ticks는 운영체제가 켜진 이후의 틱 수를 반환하는 함수이다. 그리고 timer_elapsed 함수는 start 부터의 지난 틱 수를 반환한다. 즉 위 함수는 start로부터 ticks만큼의 시간이 지날 때까지 thread_yield를 실행한다. 스레드가 running 상태가 되면 다시 ready 상태로 되돌리는 것이다.</p>\n<p>그리고 주어진 ticks만큼의 시간이 지나면 더 이상 thread_yield를 실행하지 않고 함수를 종료한다. 이 말은 스레드를 다시 실행 재개한다는 것이다.</p>\n<p>위에서 본 thread_yield의 작동 방식을 볼 때, 이 함수는 ticks의 시간 동안 현재 스레드를 ready_list의 맨 뒤에 넣고 다른 스레드를 실행시키는 것을 반복한다. 따라서 스레드들은 RUNNING 상태와 READY 상태를 계속 왕복하게 된다. 이는 비효율적이다. 따라서 이번 프로젝트의 목표 중 하나는 이 비효율을 개선하는 것이다.</p>\n<h1>2. alarm clock 개선</h1>\n<p>이를 어떻게 개선할 수 있을까? 먼저 sleep 중인 스레드들을 관리하는 자료구조 sleep_list를 만든다. 이 sleep_list는 스레드가 timer_sleep을 호출할 때 그 스레드를 저장하고 또한 스레드가 다시 실행을 시작해야 하는 시점인 wakeup_tick을 저장한다. wakeup_tick으로 설정한 시점이 되면 그 스레드는 다시 실행되어야 한다.</p>\n<p>이를 위해서는 매 틱마다 호출되는 timer_interrupt 함수를 이용한다. 현재 시간을 기준으로 sleep_list에 있는 스레드들 중 wakeup_tick이 된 스레드들을 다시 ready_list에 넣어준다. 그리고 sleep_list에서 그 스레드를 제거한다.</p>\n<p>이를 구현하기 위해 먼저 스레드 자료구조에 <code>wakeup_tick</code>을 추가한다.</p>\n<pre><code class=\"language-c\">struct thread\n  {\n    /* Owned by thread.c. */\n    tid_t tid;                          /* Thread identifier. */\n    enum thread_status status;          /* Thread state. */\n    char name[16];                      /* Name (for debugging purposes). */\n    uint8_t *stack;                     /* Saved stack pointer. */\n    int priority;                       /* Priority. */\n    struct list_elem allelem;           /* List element for all threads list. */\n\n    /* Shared between thread.c and synch.c. */\n    struct list_elem elem;              /* List element. */\n\n#ifdef USERPROG\n    /* Owned by userprog/process.c. */\n    uint32_t *pagedir;                  /* Page directory. */\n    // parent process descriptor\n    struct thread* parent_thread;\n\n    /* each structure\n   that is a potential list element must embed a struct list_elem\n   member. */\n    /* child list element */\n    struct list_elem child_thread_elem;\n    /* child list */\n    struct list child_threads;\n    /* 프로세스의 프로그램 메모리 적재 여부 */\n    bool load_flag;\n    /* 프로세스 종료 유무 확인 */\n    bool exit_flag;\n    /* exit semaphore, 자식 프로세스 종료 대기를 위한 세마포어 */\n    struct semaphore exit_sema;\n    /* load semaphore, 자식 프로세스 생성 대기 */\n    struct semaphore load_sema;\n    /* 삭제될 때 부모의 자식 리스트에서 삭제하기 위해 메모리를 남겨두는 세마포어 */\n    struct semaphore remove_sema;\n    /* exit 호출 시 종료 상태 */\n    int exit_status;\n    /* file descriptor table */\n    struct file* fd_table[FDTABLE_SIZE];\n    /* 현재 실행중인 파일 */\n    struct file* exec_file;\n#endif\n  // new!\n    int64_t wakeup_tick;\n    /* Owned by thread.c. */\n    unsigned magic;                     /* Detects stack overflow. */\n  };\n</code></pre>\n<p>그 다음 block된 스레드들을 저장하는 sleep_list를 만든다.</p>\n<pre><code class=\"language-c\">//src/threads/thread.c\n// THREAD_BLOCKED 상태의 스레드를 관리\nstatic struct list sleep_list;\n</code></pre>\n<p>왜 static 변수로 선언하냐 하면 static 변수는 스레드의 데이터 영역에 저장되어 스레드 실행시 생성되고 스레드가 끝날 때 파괴되기 때문이다. 즉 스레드와 운명을 함께한다?는 것이다...</p>\n<p>다음으로 thread_init 함수에서 sleep_list를 초기화한다.</p>\n<pre><code class=\"language-c\">//src/threads/thread.c\nvoid\nthread_init (void)\n{\n  ASSERT (intr_get_level () == INTR_OFF);\n\n  lock_init (&#x26;tid_lock);\n  list_init (&#x26;ready_list);\n  list_init (&#x26;all_list);\n  // new!\n  list_init(&#x26;(sleep_list));\n\n  /* Set up a thread structure for the running thread. */\n  initial_thread = running_thread ();\n  init_thread (initial_thread, \"main\", PRI_DEFAULT);\n  initial_thread->status = THREAD_RUNNING;\n  initial_thread->tid = allocate_tid ();\n}\n</code></pre>\n<p>그리고 다음과 같은 함수들을 <code>src/threads/thread.h</code>에 선언하자.</p>\n<pre><code class=\"language-c\">/* for project 3 Threads, alarm clock */\nvoid thread_sleep(int64_t ticks);\nvoid thread_awake(int64_t ticks);\n</code></pre>\n<p>다 피가 되고 살이 되는 함수들일 테니 하나하나 구현해 보자.</p>\n<h2>2.1 thread_sleep</h2>\n<p>thread_sleep 함수는 실행 중인 스레드를 sleep 상태로 만들어 주는 함수이다. 그리고 몇 tick 이후에 깨어나야 할지를 인자로 받는다.</p>\n<p>인터럽트 비활성화 -> 현재 스레드가 깨어나야 할 tick을 저장 -> sleep_list에 삽입 -> 현재 스레드 상태를 BLOCKED로 바꾸고 스케줄링 -> 인터럽트 활성화 순으로 진행된다. 이때 중간 과정은 현재 스레드가 idle 상태가 아닐 때 이루어진다.</p>\n<pre><code class=\"language-c\">//src/threads/thread.c\n// ticks 이후 깨어남\nvoid thread_sleep(int64_t ticks){\n  struct thread* cur=thread_current();\n  enum intr_level old_level;\n  // 인터럽트 비활성화\n  old_level=intr_disable();\n  if(cur!=idle_thread){\n    cur->status=THREAD_BLOCKED;\n    // 현재 이후 ticks 지나면 깨어나도록\n    cur->wakeup_tick=ticks;\n    list_push_back(&#x26;sleep_list, &#x26;(cur->elem));\n    schedule();\n  }\n  // 인터럽트 활성화\n  intr_set_level(old_level);\n}\n</code></pre>\n<h2>2.2 thread_awake</h2>\n<p>thread_awake 함수는 sleep_list에서 깨어나야 할 스레드들을 깨워주는 함수이다. wakeup_tick 값이 인자로 받은 ticks보다 작은 스레드들을 깨운다. 이때 sleep_list를 순회하면서 삭제하는 동작이 이루어지므로 여기 주의한다. 만약 삭제를 할 경우 리스트 요소들의 순서가 하나씩 당겨지므로 굳이 list_next로 넘어갈 필요가 없다.</p>\n<pre><code class=\"language-c\">void thread_awake(int64_t ticks){\n  struct list_elem* elem;\n  struct thread* t;\n  for(elem=list_begin(&#x26;(sleep_list));elem!=list_end(&#x26;(sleep_list));){\n    t=list_entry(elem, struct thread, elem);\n    if(t->wakeup_tick&#x3C;=ticks){\n      elem=list_remove(elem);\n      thread_unblock(t);\n    }\n    else{\n      elem=list_next(elem);\n    }\n  }\n}\n</code></pre>\n<h2>2.3 적용</h2>\n<p>timer_sleep에 기존 busy waiting 방식을 쓰던 코드를 지우고 thread_sleep 함수를 적용한다.</p>\n<pre><code class=\"language-c\">void\ntimer_sleep (int64_t ticks)\n{\n  int64_t start = timer_ticks ();\n\n  ASSERT (intr_get_level () == INTR_ON);\n  thread_sleep(start+ticks);\n}\n</code></pre>\n<p>그리고 wakeup_ticks에 도달한 스레드는 깨워 줘야 하므로 매 틱마다 실행되는 timer_interrupt 함수에 thread_awake 함수를 추가한다.</p>\n<pre><code class=\"language-c\">/* Timer interrupt handler. */\nstatic void\ntimer_interrupt (struct intr_frame *args UNUSED)\n{\n  ticks++;\n  thread_awake(ticks);\n  thread_tick ();\n}\n</code></pre>\n<p>이 상태로 src/threads에서 make를 해보면? 에러가 뜬다. 뭐가 문제일까? user program에서 스레드에 추가했던 <code>exit_sema</code>, <code>remove_sema</code>를 사용하는 thread_exit 코드에서 에러가 뜬다. 이를 #ifdef USERPROG #endif로 감싸주면 된다.</p>\n<pre><code class=\"language-c\">// src/threads/thread.c\nvoid\nthread_exit (void)\n{\n  ASSERT (!intr_context ());\n\n#ifdef USERPROG\n  process_exit ();\n  sema_up(&#x26;(thread_current()->exit_sema));\n  sema_down(&#x26;(thread_current()->remove_sema));\n#endif\n\n  /* Remove thread from all threads list, set our status to dying,\n     and schedule another process.  That process will destroy us\n     when it calls thread_schedule_tail(). */\n  intr_disable ();\n  list_remove (&#x26;thread_current()->allelem);\n\n  thread_current ()->status = THREAD_DYING;\n  schedule ();\n  NOT_REACHED ();\n}\n</code></pre>\n<p>이제 make check도 통과하고, <code>pintos -v -- -q run alarm-multiple</code>을 해보면 idle tick이 생긴 것을 볼 수 있다. 원래는 sleep 상태에서도 스레드가 cpu를 점유하므로 idle tick이 0이었다.</p>\n<h1>3. priority scheduling</h1>\n<p>현재의 라운드 로빈 스케줄러를 스레드의 우선순위를 고려하는 스케줄러로 바꿔야 한다. 만약 새로운 스레드가 현재 스레드보다 우선순위가 높다면 현재 스레드는 스레드를 바로 빼앗겨야 한다. 또한 여러 스레드가 락을 갖기 위해 경쟁하고 있을 경우 우선순위가 더 높은 스레드가 락을 가져가야 한다. 이는 세마포어에 대해서도 똑같이 적용된다.</p>\n<p>이 우선순위는 0부터 63까지 있으며 숫자가 높을수록 더 높은 우선순위를 가진다. 우선순위가 높은 스레드가 먼저 실행된다. thread.h에는 다음과 같은 매크로도 정의되어 있다.</p>\n<pre><code class=\"language-c\">/* Thread priorities. */\n#define PRI_MIN 0                       /* Lowest priority. */\n#define PRI_DEFAULT 31                  /* Default priority. */\n#define PRI_MAX 63                      /* Highest priority. */\n</code></pre>\n<p>그리고 현재 스레드의 우선순위를 얻어오는 함수와 우선순위를 변경하는 함수도 이미 만들어져 있다.</p>\n<pre><code class=\"language-c\">// src/threads/thread.c\n/* Sets the current thread's priority to NEW_PRIORITY. */\nvoid\nthread_set_priority (int new_priority)\n{\n  thread_current ()->priority = new_priority;\n}\n\n/* Returns the current thread's priority. */\nint\nthread_get_priority (void)\n{\n  return thread_current ()->priority;\n}\n</code></pre>\n<p>이것과 한양대에서 제공하는 갓-ppt를 기반으로 차근차근 우선순위 스케줄링을 구현해보자. 우리가 해야 할 것은 다음과 같다.</p>\n<p><img src=\"/static/solution-0d30d24e.png\" alt=\"sol\"></p>\n<h2>3.1 thread_create</h2>\n<p>현재 스레드의 우선순위와 thread_create에서 새로 만드는 스레드의 우선순위를 비교해서 만약 새로 만드는 스레드 우선순위가 더 높으면 현재 스레드를 yield시키는 코드를 추가한다.</p>\n<pre><code class=\"language-c\">tid_t\nthread_create (const char *name, int priority,\n               thread_func *function, void *aux)\n{\n  struct thread *t;\n  struct kernel_thread_frame *kf;\n  struct switch_entry_frame *ef;\n  struct switch_threads_frame *sf;\n  tid_t tid;\n\n  ASSERT (function != NULL);\n\n  /* Allocate thread. */\n  t = palloc_get_page (PAL_ZERO);\n  if (t == NULL)\n    return TID_ERROR;\n\n  /* Initialize thread. */\n  init_thread (t, name, priority);\n  tid = t->tid = allocate_tid ();\n\n  /* Stack frame for kernel_thread(). */\n  kf = alloc_frame (t, sizeof *kf);\n  kf->eip = NULL;\n  kf->function = function;\n  kf->aux = aux;\n\n  /* Stack frame for switch_entry(). */\n  ef = alloc_frame (t, sizeof *ef);\n  ef->eip = (void (*) (void)) kernel_thread;\n\n  /* Stack frame for switch_threads(). */\n  sf = alloc_frame (t, sizeof *sf);\n  sf->eip = switch_entry;\n  sf->ebp = 0;\n\n  /* Add to run queue. */\n  thread_unblock (t);\n  /* 실행중인 스레드와 우선순위 비교 */\n  if(thread_get_priority() &#x3C; priority){\n    thread_yield();\n  }\n\n  return tid;\n}\n</code></pre>\n<h2>3.2 thread_unblock</h2>\n<p>스레드가 unblock될 때 우선순위 순으로 정렬되어 삽입되도록 한다. 이때 우선순위가 높은 스레드가 앞에 오도록 해야 하는데 이를 위해 list_insert_ordered를 사용한다. 그리고 거기 쓰이는 비교함수인 <code>cmp_priority</code>를 구현해야 한다.</p>\n<pre><code class=\"language-c\">// 우선순위 기준으로 비교한다\nbool cmp_priority(const struct list_elem *a, const struct list_elem *b, void *aux UNUSED){\n  struct thread *at, *bt;\n  at=list_entry(a, struct thread, elem);\n  bt=list_entry(b, struct thread, elem);\n  return (at->priority) > (bt->priority);\n}\n</code></pre>\n<p>그리고 thread_unblock에서는 이 비교함수를 사용해서 삽입한다.</p>\n<pre><code class=\"language-c\">void\nthread_unblock (struct thread *t)\n{\n  enum intr_level old_level;\n\n  ASSERT (is_thread (t));\n\n  old_level = intr_disable ();\n  ASSERT (t->status == THREAD_BLOCKED);\n  // 수정\n  list_insert_ordered(&#x26;ready_list, &#x26;(t->elem), cmp_priority, NULL);\n  //list_push_back (&#x26;ready_list, &#x26;t->elem);\n  t->status = THREAD_READY;\n  intr_set_level (old_level);\n}\n</code></pre>\n<h2>3.3 thread_yield</h2>\n<p>thread_yield에서 현재 스레드가 cpu를 양보할 때 우선순위 순서로 삽입되도록 수정하자. 이 역시 list_insert_ordered를 사용하고, 비교함수는 <code>cmp_priority</code>를 사용한다.</p>\n<pre><code class=\"language-c\">void\nthread_yield (void)\n{\n  struct thread *cur = thread_current ();\n  enum intr_level old_level;\n\n  ASSERT (!intr_context ());\n\n  old_level = intr_disable ();\n  if (cur != idle_thread) {\n    //list_push_back (&#x26;ready_list, &#x26;cur->elem);\n    list_insert_ordered(&#x26;ready_list, &#x26;cur->elem, cmp_priority, NULL);\n  }\n  cur->status = THREAD_READY;\n  schedule ();\n  intr_set_level (old_level);\n}\n</code></pre>\n<h2>3.4 thread_set_priority</h2>\n<p>그리고 우선순위를 변경할 때도 선점이 발생하도록 해야 한다. 만약 새로 우선순위가 설정된 스레드가 현재 실행되고 있는 스레드보다 우선순위가 높다면 당장 지금 실행중인 스레드를 선점해야 한다.</p>\n<p>이를 위해 thread_set_priority를 수정한다.</p>\n<pre><code class=\"language-c\">void\nthread_set_priority (int new_priority)\n{\n  int p=thread_current ()->priority;\n  thread_current ()->priority = new_priority;\n  // 현재 스레드의 우선순위가 작아졌다면 다시 스케줄링\n  if(p > new_priority){\n    thread_yield();\n  }\n}\n</code></pre>\n<p>이제 make check을 해보면 alarm-priority, priority-fifo, priority-preempt가 통과하는 것을 확인할 수 있다.</p>\n<h1>4. Priority Scheduling and Synchronization</h1>\n<p>아직 구현해야 할 게 있다. 앞서 #3 의 첫 시작에서 말했던 것 중 다음과 같은 이야기가 있었다.</p>\n<pre><code>여러 스레드가 락을 갖기 위해 경쟁하고 있을 경우 우선순위가 더 높은 스레드가 락을 가져가야 한다. 이는 세마포어에 대해서도 똑같이 적용된다.\n</code></pre>\n<p>현재 핀토스는 세마포어가 그 세마포어를 대기하고 있는 스레드들의 리스트 waiters를 가지도록 하고 있다. 하지만 현재 이 waiters 리스트 내부의 스레드는 우선순위에 상관없이 단순한 FIFO 방식으로 관리되고 있다. 이를 우선순위가 높은 스레드가 먼저 우선순위를 가져가도록 수정해 보자. thread.c, synch.c를 수정하면 된다.</p>\n<h2>4.1 sema_down</h2>\n<p>기존에는 sema_down 함수에서 waiters 리스트에 스레드를 삽입하고, 스레드를 block 시켰다. 이를 우선순위에 따라 삽입하도록 수정한다.</p>\n<pre><code class=\"language-c\">void\nsema_down (struct semaphore *sema)\n{\n  enum intr_level old_level;\n\n  ASSERT (sema != NULL);\n  ASSERT (!intr_context ());\n\n  old_level = intr_disable ();\n  while (sema->value == 0)\n    {\n      //list_push_back (&#x26;sema->waiters, &#x26;thread_current ()->elem);\n      /* 우선순위에 따라 삽입하도록 수정 */\n      list_insert_ordered(&#x26;sema->waiters, &#x26;thread_current ()->elem, cmp_priority, NULL);\n      thread_block ();\n    }\n  sema->value--;\n  intr_set_level (old_level);\n}\n</code></pre>\n<h2>4.2 sema_up</h2>\n<p>스레드가 waiters 리스트에 있는 동안 우선순위가 변경되었을 가능성에 대비하여 리스트를 정렬해 준다.</p>\n<pre><code class=\"language-c\">void\nsema_up (struct semaphore *sema)\n{\n  enum intr_level old_level;\n\n  ASSERT (sema != NULL);\n\n  old_level = intr_disable ();\n  if (!list_empty (&#x26;sema->waiters)) {\n    list_sort(&#x26;sema->waiters, cmp_priority, NULL);\n    thread_unblock (list_entry (list_pop_front (&#x26;sema->waiters),\n                                struct thread, elem));\n  }\n\n  sema->value++;\n  intr_set_level (old_level);\n}\n</code></pre>\n<p>그런데 한양대 ppt를 보면 priority preemption 코드를 넣어야 한다고 한다. 이게 뭐냐 하면 우선순위가 높은 스레드가 선점하는 로직을 짜라는 뜻이다. thread.c에 이를 위한 함수 test_max_priority를 작성하자. 이 함수의 원형을 thread.h에 추가하는 것도 잊지 말자.</p>\n<pre><code class=\"language-c\">void test_max_priority (void)\n{\n  /* ready_list에서 우선순위가 가장 높은 스레드와 현재 스레드의\n  우선순위를 비교하여 스케줄링 한다. 즉 preemption (ready_list 가 비어있지 않은지 확인) */\n  if(list_empty(&#x26;ready_list)){return;}\n  // ready_list에서 우선순위가 가장 높은 스레드\n  struct list_elem* e=list_front(&#x26;ready_list);\n  struct thread *t=list_entry(e, struct thread, elem);\n  // ready list의 최고 우선순위 스레드가 더 우선순위 높다면 선점\n  if(thread_get_priority() &#x3C; t->priority){\n    thread_yield();\n  }\n}\n</code></pre>\n<p>그리고 이를 sema_up에 추가한다.</p>\n<pre><code class=\"language-c\">void\nsema_up (struct semaphore *sema)\n{\n  enum intr_level old_level;\n\n  ASSERT (sema != NULL);\n\n  old_level = intr_disable ();\n  if (!list_empty (&#x26;sema->waiters)) {\n    list_sort(&#x26;sema->waiters, cmp_priority, NULL);\n    thread_unblock (list_entry (list_pop_front (&#x26;sema->waiters),\n                                struct thread, elem));\n  }\n\n  sema->value++;\n  // new!\n  test_max_priority();\n  intr_set_level (old_level);\n}\n</code></pre>\n<p>여기까지 하면 priority_sema가 pass되는 것을 볼 수 있다. 이제 priority_condvar을 진행해보자. priority_condvar는 서강대의 채점 기준에는 없다. 하지만 이걸 해야 추후에 all pass를 볼 수 있다. 따라서 한번 해보자.</p>\n<h2>4.3 cmp_sem_priority</h2>\n<p>특정 condition variable 을 기다리는 세마포어 리스트를 가장 높은 우선순위를 가지는 스레드의 우선순위 순으로 정렬해야 한다. 이때 쓰는 비교 함수를 정의한다. 먼저 함수 원형을 threads/synch.h에 추가한다.</p>\n<pre><code class=\"language-c\">// src/threads/synch.h\nbool cmp_sem_priority (const struct list_elem *a,\nconst struct list_elem *b,\nvoid *aux);\n</code></pre>\n<p>구현은 다음과 같다.</p>\n<pre><code class=\"language-c\">// src/threads/synch.c\n/* 두 세마포어를 기다리는 대기자들 중 우선순위가 가장 높은 스레드를 기준으로\n어떤 게 더 우선순위가 높은지를 반환한다 */\nbool cmp_sem_priority (const struct list_elem *a, const struct list_elem *b, void *aux){\n  struct semaphore_elem *sa = list_entry(a, struct semaphore_elem, elem);\n  struct semaphore_elem *sb = list_entry(b, struct semaphore_elem, elem);\n  struct list_elem *la=list_front(&#x26;(sa->semaphore.waiters));\n  struct list_elem *lb=list_front(&#x26;(sb->semaphore.waiters));\n  // 각 세마포어의 대기자들 중 우선순위가 가장 높은 스레드\n  struct thread *ta=list_entry(la, struct thread, elem);\n  struct thread *tb=list_entry(lb, struct thread, elem);\n  return ta->priority > tb->priority;\n}\n</code></pre>\n<h2>4.4 cond_wait</h2>\n<p>한양대 ppt에서 시키는 대로 하자. condition variable의 waiters list에 우선순위 순서로 삽입되도록 수정한다.</p>\n<p>list_push_back으로 구현된 부분을 list_insert_ordered로 바꾼다.</p>\n<pre><code class=\"language-c\">void\ncond_wait (struct condition *cond, struct lock *lock)\n{\n  struct semaphore_elem waiter;\n\n  ASSERT (cond != NULL);\n  ASSERT (lock != NULL);\n  ASSERT (!intr_context ());\n  ASSERT (lock_held_by_current_thread (lock));\n\n  sema_init (&#x26;waiter.semaphore, 0);\n  //list_push_back (&#x26;cond->waiters, &#x26;waiter.elem);\n  list_insert_ordered(&#x26;cond->waiters, &#x26;waiter.elem, cmp_sem_priority, NULL);\n  lock_release (lock);\n  sema_down (&#x26;waiter.semaphore);\n  lock_acquire (lock);\n}\n</code></pre>\n<h2>4.5 cond_signal</h2>\n<p>역시 갓-한양대가 시키는 대로 하자. 대기 중 우선순위가 변경되었을 가능성이 있으니 condition variable의 waiters list를 우선순위로 재 정렬한다.</p>\n<pre><code class=\"language-c\">void\ncond_signal (struct condition *cond, struct lock *lock UNUSED)\n{\n  ASSERT (cond != NULL);\n  ASSERT (lock != NULL);\n  ASSERT (!intr_context ());\n  ASSERT (lock_held_by_current_thread (lock));\n\n  if (!list_empty (&#x26;cond->waiters)) {\n    // new!\n    list_sort(&#x26;cond->waiters, cmp_sem_priority, NULL);\n    sema_up (&#x26;list_entry (list_pop_front (&#x26;cond->waiters),\n                          struct semaphore_elem, elem)->semaphore);\n  }\n}\n</code></pre>\n<h2>4.6 디버깅</h2>\n<p>아..그런데 priority_condvar에서 커널 패닉이 뜬다. list_empty(list) 에 대한 assertion에서 무언가 실패했다고 한다. 이때 생각나는 것이 있는데..priority preemption에서 ready list가 비어 있을 때를 고려하지 않은 부분이 있다는 것. test_max_priority 함수를 이용한 preemption에서는 그런 경우가 없었는데, preemption 을 하는 코드를 싹 다 test_max_priority를 사용하도록 바꿔 버리자.</p>\n<p>먼저 thread_created에서 test_max_priority를 사용하도록 바꾼다.</p>\n<pre><code class=\"language-c\">tid_t\nthread_create (const char *name, int priority,\n               thread_func *function, void *aux)\n{\n  struct thread *t;\n  struct kernel_thread_frame *kf;\n  struct switch_entry_frame *ef;\n  struct switch_threads_frame *sf;\n  tid_t tid;\n\n  ASSERT (function != NULL);\n\n  /* Allocate thread. */\n  t = palloc_get_page (PAL_ZERO);\n  if (t == NULL)\n    return TID_ERROR;\n\n  /* Initialize thread. */\n  init_thread (t, name, priority);\n  tid = t->tid = allocate_tid ();\n\n  /* Stack frame for kernel_thread(). */\n  kf = alloc_frame (t, sizeof *kf);\n  kf->eip = NULL;\n  kf->function = function;\n  kf->aux = aux;\n\n  /* Stack frame for switch_entry(). */\n  ef = alloc_frame (t, sizeof *ef);\n  ef->eip = (void (*) (void)) kernel_thread;\n\n  /* Stack frame for switch_threads(). */\n  sf = alloc_frame (t, sizeof *sf);\n  sf->eip = switch_entry;\n  sf->ebp = 0;\n\n  /* Add to run queue. */\n  thread_unblock (t);\n  /* 수정 */\n  test_max_priority();\n\n  return tid;\n}\n</code></pre>\n<p>그리고 thread_set_priority에서도 test_max_priority를 사용하도록 바꾼다.</p>\n<pre><code class=\"language-c\">void\nthread_set_priority (int new_priority)\n{\n  thread_current ()->priority = new_priority;\n  // 현재 스레드의 우선순위가 작아졌다면 다시 스케줄링\n  test_max_priority();\n}\n</code></pre>\n<p>그리고 cmp_sem_priority에서 list_front 대신 list_begin을 사용하도록 바꾼다. 이러면 리스트가 비어 있을 때에도 tail이 반환되어서 문제가 없다. 반면 list_front를 사용하면 리스트가 비어 있으면 에러를 발생시키기 때문에 priority_condvar를 통과하지 못한다.</p>\n<pre><code class=\"language-c\">src/threads/synch.c\nbool cmp_sem_priority (const struct list_elem *a, const struct list_elem *b, void *aux){\n  struct semaphore_elem *sa = list_entry(a, struct semaphore_elem, elem);\n  struct semaphore_elem *sb = list_entry(b, struct semaphore_elem, elem);\n  // 수정\n  struct list_elem *la=list_begin(&#x26;(sa->semaphore.waiters));\n  struct list_elem *lb=list_begin(&#x26;(sb->semaphore.waiters));\n  // 각 세마포어의 대기자들 중 우선순위가 가장 높은 스레드\n  struct thread *ta=list_entry(la, struct thread, elem);\n  struct thread *tb=list_entry(lb, struct thread, elem);\n  return ta->priority > tb->priority;\n}\n</code></pre>\n<p>이제 make check을 돌려보면 priority_condvar를 통과한다.</p>\n<h1>5. priority aging</h1>\n<p>기본적인 우선순위 스케줄링은 낮은 우선순위를 가진 프로세스들이 starvation에 걸릴 가능성이 있다. 이를 해결하기 위한 방법 중 하나는 aging이다. 자세한 설명은 운영체제 수업에서 듣고... 이번에는 aging을 구현해보자.</p>\n<p>먼저 수정하라고 하는 코드들을 수정하자. src/threads/thread.h에 다음을 추가한다.</p>\n<pre><code class=\"language-c\">/* Project #3. */\n#ifndef USERPROG\nextern bool thread_prior_aging;\n#endif\n</code></pre>\n<p>그리고 src/threads/thread.c에 다음을 추가한다.</p>\n<pre><code class=\"language-c\">/* Project #3. */\n#ifndef USERPROG\nbool thread_prior_aging;\n#endif\n</code></pre>\n<p>thread_tick 함수는 다음과 같이 수정.</p>\n<pre><code class=\"language-c\">void\nthread_tick (void)\n{\n  struct thread *t = thread_current ();\n\n  /* Update statistics. */\n  if (t == idle_thread)\n    idle_ticks++;\n#ifdef USERPROG\n  else if (t->pagedir != NULL)\n    user_ticks++;\n#endif\n  else\n    kernel_ticks++;\n\n  /* Enforce preemption. */\n  if (++thread_ticks >= TIME_SLICE)\n    intr_yield_on_return ();\n\n#ifndef USERPROG\n  if(thread_prior_aging==true){\n    thread_aging();\n  }\n#endif\n}\n</code></pre>\n<p>src/threads/init.c 의 parse_options 함수의 중간엔 다음 내용을 추가한다.</p>\n<pre><code class=\"language-c\">#ifndef USERPROG\n  else if (!strcmp (name, \"-aging\"))\n    thread_prior_aging=true;\n#endif\n</code></pre>\n<p>그리고 과제와 함께 주어진 thread_tests.tar의 압축을 푼 후 src/tests/threads를 그 내용으로 교체한다. 파일질라로 간단히 해결했다.</p>\n<p>우리는 thread_tick()함수에 thread_aging이라는 함수를 호출하도록 했다. 그럼 이 thread_tick함수는 어디서 쓰일까? 아까 수정했던 timer_interrupt() 함수에서 thread_tick이 호출되는 것을 알 수 있다. 즉 매 틱마다 thread_tick 함수가 호출되는 것이다.</p>\n<p>그러면 thread_aging 함수를 구현해보자. 매 틱마다 모든 스레드의 우선순위를 1씩 높여 주면 되는 간단한 함수이다. 이 함수 원형을 src/threads/thread.h에 추가하는 것도 잊지 말자.</p>\n<pre><code class=\"language-c\">// src/threads/thread.c\nvoid thread_aging(void){\n  struct thread *t;\n  struct list_elem* elem;\n\n  for(elem=list_begin(&#x26;all_list); elem!=list_end(&#x26;all_list);elem=list_next(elem)){\n    t=list_entry(elem, struct thread, allelem);\n    t->priority++;\n  }\n  if(t->priority > PRI_MAX){t->priority = PRI_MAX;}\n  if(t->priority &#x3C; PRI_MIN){t->priority = PRI_MIN;}\n}\n</code></pre>\n<p>이 함수는 thread_tick()에 의해 매 틱마다 호출되므로 priority aging을 잘 구현한다고 할 수 있다. 이 함수를 구현하고 나서 make check을 실행하면 priority-aging 테스트를 통과할 수 있다.</p>\n<p><img src=\"/static/aging-pass-ccdc05c4.png\" alt=\"aging-pass\"></p>\n<h1>6. BSD scheduler</h1>\n<p>BSD 스케줄러의 구현을 하면 이번 프로젝트에서 보너스 점수를 받을 수 있다. BSD 스케줄러를 구현하기 위해서는 멀티 레벨 피드백 큐를 사용할 수 있다. 각 우선순위가 각각의 레디 큐를 가지고 있고 스케줄링할 때마다 우선순위가 높은 큐부터 스케줄링을 하는 것이다. 각 우선순위의 레디 큐는 라운드 로빈 방식으로 스케줄링을 한다.</p>\n<p>이때 우선순위는 스레드 생성시 초기화되고 매 4틱마다 다시 계산되도록 한다. 그 계산식은 다음과 같다.</p>\n<p>$priority = PRI_MAX - (recent_cpu / 4) - (nice * 2)$</p>\n<p>여기에 뭔가 익숙하지 않은 변수들이 꽤 있다. PRI_MAX는 우선순위의 최대값인데 나머지는?</p>\n<p>먼저 nice은 스레드의 nice값이다. -20부터 20까지 있고 nice가 양수면 우선순위 감소, 음수면 우선순위 증가의 효과를 가진다. 실질적으로 무슨 의미인지는 핀토스 매뉴얼에도 딱히 나와 있지 않은데, 이런 말이 있긴 하다.</p>\n<pre><code>Pintos Appendix B.1 Niceness\nA positive nice, to the maximum of 20, decreases the priority of a thread and causes it to give up some CPU time it would otherwise receive.\n</code></pre>\n<p>즉 nice 값이 높으면 다른 스레드에게 더 CPU를 양보하게 되니까 성격좋은 스레드라서 nice하다...? 정도로 이해하면 될 것 같다. 아무튼 우선순위에 영향을 미친다는 것이다. 스레드가 처음 생성되면 nice값은 0이다. 만약 스레드가 부모가 있다면 부모의 nice값을 물려받는다.</p>\n<p>recent_cpu는 스레드의 최근 cpu사용량이다. 이 변수들은 스레드 구조체에 정의되어 있다. 최근에 CPU 사용량이 높은 스레드는 우선순위를 낮춰 주는 역할을 한다. 이 값은 처음 생기는 스레드에 대해 0이고 부모가 있는 스레드는 부모의 recent_cpu값을 물려받는다.</p>\n<p>그리고 recent_cpu는 다음 계산식에 따라서 매 interrupt마다 다시 계산된다.</p>\n<p>$recent_cpu = (2 * load_avg) / (2 * load_avg + 1) * recent_cpu + nice$</p>\n<p>여기서 load_avg는 시스템에서 최근 1분 동안 수행 가능한 프로세스의 평균값이다. 매 1틱마다 다음과 같이 계산된다.</p>\n<p>$load_avg = (59/60) * load_avg + (1/60) * ready_threads$</p>\n<p>여기서 ready_threads는 현재 ready 혹은 running 상태에 있는 스레드의 수이다. (즉 실행 중인 스레드 개수 + ready_list에 있는 스레드 개수)이다.</p>\n<p>어..그런데 문제가 있다. priority, nice, ready_threads값은 정수, recent_cpu, load_avg값은 실수이다. 문제는 pintos가 커널에서 부동 소수점 연산을 지원하지 않는다는 것이다. 따라서 우리는 이 값을 정수로 표현해야 한다.</p>\n<p>이를 위해 정수를 실수 연산을 위해 사용한다. 우리는 17.14 fixed point를 사용한다. 이는 32비트 정수형에서 1비트는 부호 비트, 17비트는 정수부, 14비트는 소수부를 나타내게 해서 실수를 표현하는 것이다.</p>\n<h2>6.1 실수 연산 구현</h2>\n<p>이를 위해 src/thread/fixed-point.h 파일을 만들고 다음과 같이 내용을 작성한다.</p>\n<pre><code class=\"language-c\">#define F (1 &#x3C;&#x3C; 14) //fixed point 1\n#define INT_MAX ((1 &#x3C;&#x3C; 31) - 1)\n#define INT_MIN (-(1 &#x3C;&#x3C; 31))\n// x and y denote fixed_point numbers in 17.14 format\n// n is an integer\n\nint int_to_fp(int n); /* integer를 fixed point로 전환 */\nint fp_to_int_round(int x); /* FP를 int로 전환(반올림) */\nint fp_to_int(int x); /* FP를 int로 전환(버림) */\nint add_fp(int x, int y); /* FP의 덧셈 */\nint add_mixed(int x, int n); /* FP와 int의 덧셈 */\nint sub_fp(int x, int y); /* FP의 뺄셈(x-y) */\nint sub_mixed(int x, int n); /* FP와 int의 뺄셈(x-n) */\nint mult_fp(int x, int y); /* FP의 곱셈 */\nint mult_mixed(int x, int y); /* FP와 int의 곱셈 */\nint div_fp(int x, int y); /* FP의 나눗셈(x/y) */\nint div_mixed(int x, int n); /* FP와 int 나눗셈(x/n) */\n</code></pre>\n<p>이 함수들을 모두 구현하자. 다행히 한양대 ppt에서 모든 것을 알려주므로 그대로 하면 된다.</p>\n<pre><code class=\"language-c\">int int_to_fp(int n){\n  int temp= n * F;\n  return temp;\n}\n\n/* FP를 int로 전환(반올림) */\nint fp_to_int_round(int x){\n  if(x>=0){\n    return (x + F / 2 ) / F;\n  }\n  else{\n    return (x - F / 2 ) / F;\n  }\n}\n\n/* FP를 int로 전환(버림) */\nint fp_to_int(int x){\n  return x/F;\n}\n\nint add_fp(int x, int y){\n  return x+y;\n}\n\n/* FP와 int의 덧셈 */\nint add_mixed(int x, int n){\n  return x+int_to_fp(n);\n}\n\n/* FP의 뺄셈(x-y) */\nint sub_fp(int x, int y){\n  return x-y;\n}\n\n/* FP와 int의 뺄셈(x-n) */\nint sub_mixed(int x, int n){\n  return x-int_to_fp(n);\n}\n\nint mult_fp(int x, int y){\n  // F가 2번 곱해진 상태가 되어버려서 F로 한번 나눠줘야함\n  return (((int64_t)x) * y / F);\n}\n\nint mult_mixed(int x, int n){\n  return x*n;\n}\n\nint div_fp(int x, int y){\n  return ((int64_t) x) * F / y;\n}\n\n/* FP와 int 나눗셈(x/n) */\nint div_mixed(int x, int n){\n  return x/n;\n}\n</code></pre>\n<h2>6.2 스케줄러 구현</h2>\n<p>먼저 스케줄러를 위한 정보를 thread 구조체에 추가한다. nice, recent_cpu를 추가한다.</p>\n<pre><code class=\"language-c\">struct thread\n  {\n    /* Owned by thread.c. */\n    tid_t tid;                          /* Thread identifier. */\n    enum thread_status status;          /* Thread state. */\n    char name[16];                      /* Name (for debugging purposes). */\n    uint8_t *stack;                     /* Saved stack pointer. */\n    int priority;                       /* Priority. */\n    struct list_elem allelem;           /* List element for all threads list. */\n\n    /* Shared between thread.c and synch.c. */\n    struct list_elem elem;              /* List element. */\n\n#ifdef USERPROG\n    /* Owned by userprog/process.c. */\n    uint32_t *pagedir;                  /* Page directory. */\n    // parent process descriptor\n    struct thread* parent_thread;\n\n    /* each structure\n   that is a potential list element must embed a struct list_elem\n   member. */\n    /* child list element */\n    struct list_elem child_thread_elem;\n    /* child list */\n    struct list child_threads;\n    /* 프로세스의 프로그램 메모리 적재 여부 */\n    bool load_flag;\n    /* 프로세스 종료 유무 확인 */\n    bool exit_flag;\n    /* exit semaphore, 자식 프로세스 종료 대기를 위한 세마포어 */\n    struct semaphore exit_sema;\n    /* load semaphore, 자식 프로세스 생성 대기 */\n    struct semaphore load_sema;\n    /* 삭제될 때 부모의 자식 리스트에서 삭제하기 위해 메모리를 남겨두는 세마포어 */\n    struct semaphore remove_sema;\n    /* exit 호출 시 종료 상태 */\n    int exit_status;\n    /* file descriptor table */\n    struct file* fd_table[FDTABLE_SIZE];\n    /* 현재 실행중인 파일 */\n    struct file* exec_file;\n#endif\n    int64_t wakeup_tick;\n    // new!\n    int nice;\n    int recent_cpu;\n    /* Owned by thread.c. */\n    unsigned magic;                     /* Detects stack overflow. */\n  };\n</code></pre>\n<p>그리고 thread.c 파일에 다음과 같은 내용을 추가한다.</p>\n<pre><code class=\"language-c\">#include \"threads/fixed_point.h\"\n\n#define NICE_DEFAULT 0\n#define RECENT_CPU_DEFAULT 0\n#define LOAD_AVG_DEFAULT 0\n\nint load_avg;\n</code></pre>\n<p>또한 이 매크로들을 이용해서 스레드의 초기화 시 값을 설정한다. nice, recent_cpu는 맨 처음 생기는 스레드에 대해서 0이고 나머지 스레드들은 부모의 값을 알아서 물려받는다. 따라서 맨 처음 생기는 스레드인 initial_thread에 대해서만 초기화를 진행해 주면 된다. 따라서 thread_init 함수에서 초기화를 진행한다.</p>\n<pre><code class=\"language-c\">// src/threads/thread.c\nvoid\nthread_init (void)\n{\n  ASSERT (intr_get_level () == INTR_OFF);\n\n  lock_init (&#x26;tid_lock);\n  list_init (&#x26;ready_list);\n  list_init (&#x26;all_list);\n\n  list_init(&#x26;(sleep_list));\n\n  /* Set up a thread structure for the running thread. */\n  initial_thread = running_thread ();\n  init_thread (initial_thread, \"main\", PRI_DEFAULT);\n  initial_thread->status = THREAD_RUNNING;\n  initial_thread->tid = allocate_tid ();\n  // new!\n  initial_thread->nice=NICE_DEFAULT;\n  initial_thread->recent_cpu=RECENT_CPU_DEFAULT;\n}\n</code></pre>\n<p>그리고 thread_start 함수에서 load_avg 값을 초기화한다.</p>\n<pre><code class=\"language-c\">void\nthread_start (void)\n{\n  /* Create the idle thread. */\n  struct semaphore idle_started;\n  sema_init (&#x26;idle_started, 0);\n  thread_create (\"idle\", PRI_MIN, idle, &#x26;idle_started);\n\n  // new! 초기화하는 부분 추가.\n  load_avg=LOAD_AVG_DEFAULT;\n  /* Start preemptive thread scheduling. */\n  intr_enable ();\n\n  /* Wait for the idle thread to initialize idle_thread. */\n  sema_down (&#x26;idle_started);\n}\n</code></pre>\n<h2>6.2 BSD 스케줄링 구현</h2>\n<p>필요한 변수들을 다 정의했다. 우리가 BSD 스케줄링에서 해야 할 것은 다음과 같다.</p>\n<p>이걸 정리하기까지 수많은 블로그와 ppt를 보고 지옥같은 디버깅을 했다. 예를 들어 각 블로그나 github 코드들에서는 getter나 setter에 접근할 때 인터럽트를 비활성화시켜 준다든가, priority를 변경할 때 mlfqs면 우선순위 변경을 막는다든가 하는 동작을 한다. 하지만 그런 건 굳이 할 필요가 없다. 중요한 것은 ppt에 나와 있는 것이 다이다. 그리고 스레드의 우선순위를 바꿀 때는 선점에 대해 고려해야 한다-정도만 생각하면 된다.</p>\n<p>서강대학교 ppt는 무척 불친절한 것 같지만 의외로 도움되는 정보를 줄 때가 있다. 즉, 딱 다음과 같은 일만 하면 된다.</p>\n<ol>\n<li>매 초마다 load_avg를 업데이트해준다. 이때 1초는 TIMER_FREQ를 통해서 정의되어 있다.</li>\n<li>매 초마다 recent_cpu를 업데이트해준다.</li>\n<li>4틱(TIME_SLICE)마다 우선순위를 업데이트해준다.</li>\n<li>우선순위 업데이트에 따라서 스레드 선점을 발생시킨다.</li>\n</ol>\n<p>이것들을 하나하나 구현해 보자. 각 업데이트의 구현을 할 때 어떤 게 실수이고 어떤 게 정수인지 주의한다. priority, nice, ready_threads는 정수이고 recent_cpu, load_avg는 실수이다.</p>\n<p><span style=\"color:red\">어떤 게 정수이고, 어떤 게 실수인지 구분하는 건 정말 중요하다! 계산식을 구현할 때 이걸 디버깅하는 데 몇 시간을 썼는지 모르겠다. 나같은 경우 위 함수 선언에서 x, y는 실수, n은 정수형 인수로 구분하였으며 리턴형은 모두 실수인 것으로 생각했다.</span></p>\n<h3>6.2.1 load_avg 업데이트</h3>\n<p>먼저 load_avg를 업데이트하는 함수를 구현하자. 정의되어 있는 load_avg를 업데이트하는 식은 다음과 같다.</p>\n<p>$load_avg = \\frac{59}{60} \\times load_avg + \\frac{1}{60} \\times ready_threads$</p>\n<p>이를 그대로 구현해 주면 된다.</p>\n<pre><code class=\"language-c\">void mlfqs_load_avg (void){\n  int left, right;\n  int ready_threads=list_size(&#x26;ready_list);\n  if(thread_current() != idle_thread){ready_threads++;}\n  left = div_fp(int_to_fp(59), int_to_fp(60));\n  left= mult_fp(left, load_avg);\n  right= div_fp(int_to_fp(1), int_to_fp(60));\n  // ready_threads 는 정수\n  right=mult_mixed(right, ready_threads);\n  load_avg = add_fp(left, right);\n}\n</code></pre>\n<h3>6.2.2 recent_cpu 업데이트</h3>\n<p>다음으로 recent_cpu를 업데이트하는 함수를 구현하자. recent_cpu는 다음과 같은 동작을 해야 한다.</p>\n<ol>\n<li>running thread에 대해서 recent_cpu가 1 증가한다.</li>\n<li>다음 식에 의해 업데이트된다.</li>\n</ol>\n<p>$recent_cpu = \\frac{2 \\times load_avg}{2 \\times load_avg + 1} \\times recent_cpu + nice$</p>\n<p>먼저 running thread에 대해서 recent_cpu가 1 증가하는 부분을 구현해보자. idle thread는 recent_cpu를 업데이트하지 않는다는 점만 반영한다.</p>\n<pre><code class=\"language-c\">// 현재 스레드의 Recent_cpu 값 1 증가\nvoid mlfqs_increment (void){\n  struct thread* cur=thread_current();\n  if(cur==idle_thread){return;}\n  cur->recent_cpu=add_mixed(cur->recent_cpu, 1);\n}\n</code></pre>\n<p>그리고 인자로 받은 스레드에 대해서 recent_cpu를 업데이트하는 함수를 구현해보자. 계산식을 그대로 구현하면 된다.</p>\n<pre><code class=\"language-c\">// src/threads/thread.c\n/* 해당 스레드 recent_cpu 값 계산 */\nvoid mlfqs_recent_cpu (struct thread *t){\n  if(t==idle_thread){return;}\n  int temp_mult= mult_mixed(load_avg, 2);\n  int temp=div_fp(temp_mult, add_mixed(temp_mult, 1));\n  temp=mult_fp(temp, t->recent_cpu);\n  // nice는 정수\n  temp=add_mixed(temp, t->nice);\n  t->recent_cpu=temp;\n}\n</code></pre>\n<p>그리고 모든 스레드에 대해서 recent_cpu를 업데이트하는 함수를 구현한다.</p>\n<pre><code class=\"language-c\">void mlfqs_recalc_recent_cpu(void){\n  struct list_elem* e;\n  struct thread* t;\n  for(e=list_begin(&#x26;all_list); e!=list_end(&#x26;all_list); e=list_next(e)){\n    t=list_entry(e, struct thread, allelem);\n    mlfqs_recent_cpu(t);\n  }\n}\n</code></pre>\n<h3>6.2.3 priority 업데이트</h3>\n<p>마지막으로 priority를 업데이트하는 함수를 구현하자. priority는 다음 식에 따라 업데이트하면 된다.</p>\n<p>$priority = PRI_MAX - \\left( \\frac{recent_cpu}{4} \\right) - \\left( {nice} \\times {2} \\right)$</p>\n<p>인자로 받은 스레드에 대해서 priority를 업데이트하는 함수를 다음과 같이 그대로 구현한다.</p>\n<pre><code class=\"language-c\">// 해당 스레드 우선순위 재계산\nvoid mlfqs_priority (struct thread *t){\n  if(t==idle_thread){return;}\n  int temp=add_fp(int_to_fp(PRI_MAX), div_mixed(t->recent_cpu, -4));\n  temp=add_fp(temp, int_to_fp(-2 * t->nice));\n  t->priority=fp_to_int(temp);\n  if (t->priority > PRI_MAX) {\n    t->priority = PRI_MAX;\n  }\n  if (t->priority &#x3C; PRI_MIN) {\n    t->priority = PRI_MIN;\n  }\n}\n</code></pre>\n<p>모든 스레드에 대해서 priority를 업데이트하는 함수를 구현한다.</p>\n<p>여기서는 각 스레드의 우선순위가 업데이트되면서 선점해야 하는 상황이 생길 수 있으므로 선점이 필요할 경우 <code>intr_yield_on_return</code>을 호출한다.</p>\n<p>인터럽트 도중에 yield하는 것이므로 thread_yield()를 호출하는 대신 <code>intr_yield_on_return</code>을 호출해야 하는 것에 주의한다. 이걸 알려준 #참고 의 네이버 블로그에 감사한다.</p>\n<pre><code class=\"language-c\">void mlfqs_recalc_priority(void){\n  struct list_elem* e;\n  struct thread* t;\n  for(e=list_begin(&#x26;all_list); e!=list_end(&#x26;all_list); e=list_next(e)){\n    t=list_entry(e, struct thread, allelem);\n    mlfqs_priority(t);\n  }\n\n  if(list_empty(&#x26;ready_list)){return;}\n  // ready_list에서 우선순위가 가장 높은 스레드\n  e=list_front(&#x26;ready_list);\n  t=list_entry(e, struct thread, elem);\n  // ready list의 최고 우선순위 스레드가 더 우선순위 높다면 선점\n  if(thread_get_priority() &#x3C; t->priority){\n    //thread_yield();\n    intr_yield_on_return();\n  }\n}\n</code></pre>\n<h3>6.2.4 매 틱마다 업데이트</h3>\n<p>마지막으로 매 틱마다 업데이트하는 함수를 구현한다. 1초에 1번 load_avg와 recent_cpu를 업데이트하고 4번째 틱마다 priority를 업데이트한다. 그리고 매 틱마다 현재 running중인 스레드의 recent_cpu를 1 증가시킨다.</p>\n<pre><code class=\"language-c\">// src/threads/thread.c\nvoid thread_mlfqs_tick(void){\n  int64_t ticks=timer_ticks();\n\n  mlfqs_increment();\n  if(ticks % TIMER_FREQ==0){\n    mlfqs_load_avg();\n    mlfqs_recalc_recent_cpu();\n  }\n  if(ticks%TIME_SLICE==0){\n    mlfqs_recalc_priority();\n  }\n}\n</code></pre>\n<p>이를 thread_tick에서 호출하면 된다. mlfqs 모드일 때만 호출하도록 한다.</p>\n<pre><code class=\"language-c\">// src/threads/thread.c\nvoid\nthread_tick (void)\n{\n  struct thread *t = thread_current ();\n\n  /* Update statistics. */\n  if (t == idle_thread)\n    idle_ticks++;\n#ifdef USERPROG\n  else if (t->pagedir != NULL)\n    user_ticks++;\n#endif\n  else\n    kernel_ticks++;\n\n  /* Enforce preemption. */\n  if (++thread_ticks >= TIME_SLICE)\n    intr_yield_on_return ();\n\n  if(thread_prior_aging==true){\n    thread_aging();\n  }\n  // new!\n  if(thread_mlfqs==true){\n    thread_mlfqs_tick();\n  }\n}\n</code></pre>\n<h3>6.2.5 그 외 요구되는 함수들</h3>\n<p>그 외에 ppt에서는 다음과 같은 함수들을 요구하고 있다.</p>\n<pre><code class=\"language-c\">int thread_get_nice (void);\nvoid thread_set_nice (int);\nint thread_get_recent_cpu (void);\nint thread_get_load_avg (void);\n</code></pre>\n<p>이 함수들의 원형을 <code>src/threads/thread.h</code>에 추가하고, <code>src/threads/thread.c</code>에 구현하면 된다. 한양대 ppt에서는 이 함수들에서 인터럽트를 막아야 한다고 하는데 그런 거 안 해도 잘 통과한다.</p>\n<p>thread_get_nice는 단순한 getter 함수이다.</p>\n<pre><code class=\"language-c\">/* Returns the current thread's nice value. */\nint\nthread_get_nice (void)\n{\n  return thread_current()->nice;\n}\n</code></pre>\n<p>thread_set_nice는 현재 스레드의 nice 값을 변경하고, 우선순위를 재계산한다.</p>\n<pre><code class=\"language-c\">/* Sets the current thread's nice value to NICE. */\nvoid\nthread_set_nice (int nice UNUSED)\n{\n  /* 프로젝트 3에서 구현 */\n  thread_current()->nice=nice;\n  // 우선순위 재계산\n  mlfqs_priority(thread_current());\n  // 선점 처리\n  test_max_priority();\n}\n</code></pre>\n<p>thread_get_recent_cpu는 단순한 getter 함수이다. 주석에 써있는 대로 100을 곱해 반환하면 된다.</p>\n<pre><code class=\"language-c\">/* Returns 100 times the current thread's recent_cpu value. */\nint\nthread_get_recent_cpu (void)\n{\n  int temp_recent_cpu = fp_to_int_round(mult_mixed(thread_current()->recent_cpu, 100));\n  return temp_recent_cpu;\n}\n</code></pre>\n<p>thread_get_load_avg도 주석에 써있는 대로 100을 곱해 반환하면 된다.</p>\n<pre><code class=\"language-c\">/* Returns 100 times the system load average. */\nint\nthread_get_load_avg (void)\n{\n  int temp_load_avg;\n  temp_load_avg = fp_to_int_round(mult_mixed(load_avg, 100));\n  return temp_load_avg;\n}\n</code></pre>\n<p>이제 끝난 것 같다..한번 make check을 해볼까? mlfqs가 붙은 테스트 시리즈는 테스트가 매우 오래 걸린다. 테스트를 돌려 놓고 커피 한잔 하고 오자. 커피를 한잔 하고 와도 안 끝날지도 모른다. 디버깅을 하다 보면, 이번 테스트의 관건은 인내심을 가지고 테스트를 기다리는 것이라는 걸 깨달을지도? 뭔가 비효율적으로 코드를 짜서 그런 것 같기도 한데, 잘은 모르겠다.</p>\n<p>만약 여기까지 왔는데 mlfqs 테스트에서 일부는 pass고 일부는 fail인 분이 계시다면, 혹시 계산식을 구현하는 과정에서 정수와 실수를 헷갈리지 않았는지 꼼꼼히 체크해보자. 나같은 경우 예를 들어서 nice도 실수이고 -2도 실수인데 우선순위 계산을 구현하는 과정에서 <code>mult_mixed(t->nice, -2)</code>와 같이 실수와 정수를 곱하는 연산을 사용하는 실수를 저질렀다.</p>\n<p>자, 아무튼 이렇게 해서 mlfqs 테스트도 모두 통과했다. 서강대에서 요구하는 모든 조건을 만족했다!</p>\n<p><img src=\"/static/proj3-pass-183e97c2.png\" alt=\"mlfqs-pass\"></p>\n<p>다음으로는 한양대학교 ppt를 보고 priority scheduling에서 통과하지 못한 테스트들, 이를테면 priority-donate 시리즈들을 통과시켜 볼 것이다. 또 그 다음에는 VM을 구현해 볼 예정이다.</p>\n<h1>참고</h1>\n<p>어떤 선배님의 네이버 블로그 <a href=\"https://m.blog.naver.com/adobeillustrator/220546339744\">https://m.blog.naver.com/adobeillustrator/220546339744</a></p>\n<p>한양대학교 핀토스 ppt <a href=\"https://oslab.kaist.ac.kr/wp-content/uploads/esos_files/courseware/undergraduate/PINTOS/Pintos_all.pdf\">https://oslab.kaist.ac.kr/wp-content/uploads/esos_files/courseware/undergraduate/PINTOS/Pintos_all.pdf</a></p>\n<p>cmp_sem_priority 함수 구현 <a href=\"https://renelemon.tistory.com/99\">https://renelemon.tistory.com/99</a></p>\n<p>BSD scheduler 구현에 참고 <a href=\"https://for-development.tistory.com/21\">https://for-development.tistory.com/21</a></p>\n<p>핀토스 매뉴얼 <a href=\"https://web.stanford.edu/class/cs140/projects/pintos/pintos.pdf\">https://web.stanford.edu/class/cs140/projects/pintos/pintos.pdf</a></p>",
    "excerpt": "1. 프로젝트 시작\n또 새로운 프로젝트가 나왔다. 그저 시작할 뿐이다..무엇을 해야 하는지부터 알아보자.\n핀토스는 현재 라운드 로빈 스케줄러를 사용하고 있다. 그리고 각 프로세스, 스레드의 우선순위를 전혀 고려하지 않는다. 따라서 이번 프로젝트에서는 alarm, 우선순위 스케줄링, BSD스케줄러를 구현해야 한다.\n주어진 것부터 검토하자.\n1.1. 현재의 스케줄러\n현재 라운드 로빈 방식으로 짜인 스케줄러는 어떻게 작동하는가?\n// src/threads/thread",
    "headingTree": [
      {
        "title": "1. 프로젝트 시작",
        "url": "#1-프로젝트-시작",
        "items": [
          {
            "title": "1.1. 현재의 스케줄러",
            "url": "#11-현재의-스케줄러",
            "items": []
          },
          {
            "title": "1.2. 현재의 알람",
            "url": "#12-현재의-알람",
            "items": []
          }
        ]
      },
      {
        "title": "2. alarm clock 개선",
        "url": "#2-alarm-clock-개선",
        "items": [
          {
            "title": "2.1 thread_sleep",
            "url": "#21-thread_sleep",
            "items": []
          },
          {
            "title": "2.2 thread_awake",
            "url": "#22-thread_awake",
            "items": []
          },
          {
            "title": "2.3 적용",
            "url": "#23-적용",
            "items": []
          }
        ]
      },
      {
        "title": "3. priority scheduling",
        "url": "#3-priority-scheduling",
        "items": [
          {
            "title": "3.1 thread_create",
            "url": "#31-thread_create",
            "items": []
          },
          {
            "title": "3.2 thread_unblock",
            "url": "#32-thread_unblock",
            "items": []
          },
          {
            "title": "3.3 thread_yield",
            "url": "#33-thread_yield",
            "items": []
          },
          {
            "title": "3.4 thread_set_priority",
            "url": "#34-thread_set_priority",
            "items": []
          }
        ]
      },
      {
        "title": "4. Priority Scheduling and Synchronization",
        "url": "#4-priority-scheduling-and-synchronization",
        "items": [
          {
            "title": "4.1 sema_down",
            "url": "#41-sema_down",
            "items": []
          },
          {
            "title": "4.2 sema_up",
            "url": "#42-sema_up",
            "items": []
          },
          {
            "title": "4.3 cmp_sem_priority",
            "url": "#43-cmp_sem_priority",
            "items": []
          },
          {
            "title": "4.4 cond_wait",
            "url": "#44-cond_wait",
            "items": []
          },
          {
            "title": "4.5 cond_signal",
            "url": "#45-cond_signal",
            "items": []
          },
          {
            "title": "4.6 디버깅",
            "url": "#46-디버깅",
            "items": []
          }
        ]
      },
      {
        "title": "5. priority aging",
        "url": "#5-priority-aging",
        "items": []
      },
      {
        "title": "6. BSD scheduler",
        "url": "#6-bsd-scheduler",
        "items": [
          {
            "title": "6.1 실수 연산 구현",
            "url": "#61-실수-연산-구현",
            "items": []
          },
          {
            "title": "6.2 스케줄러 구현",
            "url": "#62-스케줄러-구현",
            "items": []
          },
          {
            "title": "6.2 BSD 스케줄링 구현",
            "url": "#62-bsd-스케줄링-구현",
            "items": [
              {
                "title": "6.2.1 load_avg 업데이트",
                "url": "#621-load_avg-업데이트",
                "items": []
              },
              {
                "title": "6.2.2 recent_cpu 업데이트",
                "url": "#622-recent_cpu-업데이트",
                "items": []
              },
              {
                "title": "6.2.3 priority 업데이트",
                "url": "#623-priority-업데이트",
                "items": []
              },
              {
                "title": "6.2.4 매 틱마다 업데이트",
                "url": "#624-매-틱마다-업데이트",
                "items": []
              },
              {
                "title": "6.2.5 그 외 요구되는 함수들",
                "url": "#625-그-외-요구되는-함수들",
                "items": []
              }
            ]
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 13,
      "wordCount": 3443
    },
    "url": "/posts/pintos-4",
    "thumbnail": {
      "local": "/static/solution-0d30d24e.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-solution-0d30d24e-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAjUlEQVR4nAXBSw6CMBAA0LmCS1E3+Iluvf8piIkmKsYwiNCW/mBKO5L4HsBxD7slnNZw3kK+gkUGmwNkOXhPzVe1nRHSqt7FmJh5nmdQvUasH8+yKC4VopBKG+uHEYRU19u9QqwQu07Un6Z8vYkCxJi0sSNRmCaioI21zjH/QEipjScKznk/jIk5MRPFPze1cfW0EHseAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "pintos-2",
    "title": "서강대학교 핀토스 - project 1",
    "date": "2022-11-11T01:00:00Z",
    "description": "핀토스 프로젝트 1 - User Program 1",
    "tags": [
      "CS"
    ],
    "html": "<h1>1. 본격적인 프로젝트 시작</h1>\n<p>이번 과제는 시스템 콜 핸들러와 시스템 콜 일부가 작동하도록 하는 것이다.</p>\n<p>먼저 pintos 폴더의 src/userprog 와 src/examples 디렉토리에서 make를 실행한 후 src/userprog 디렉토리에서 다음 커맨드를 실행해 본다.</p>\n<pre><code>pintos --filesys-size=2 -p ../examples/echo -a echo -- -f -q run 'echo x'\n</code></pre>\n<p>원래는 <code>echo x</code>를 실행하면 <code>x</code>가 출력되어야 하지만, 현재는 아무것도 출력되지 않는다. 커맨드를 운영체제에 전달하는 부분이 모두 빠져 있기 때문이다.</p>\n<p>핀토스에서 커맨드가 실행되는 방식은 다음과 같다. <code>echo x</code>라는 명령이 전달되면 <code>echo</code>, <code>x</code> 가 유저 스택에 쌓이고, 이 인자들이 커널에 전달되고 커널은 그 인자를 받아 시스템 콜 핸들러를 실행한다. 시스템 콜 핸들러는 적절한 시스템 콜을 실행해 준다.</p>\n<p>하지만 아직 핀토스에는 유저 스택, 스택의 인자를 커널에 전달하는 로직, 시스템 콜 핸들러가 구현되어 있지 않기 때문에 <code>echo x</code>를 실행하면 아무것도 출력되지 않는다. 즉 유저와 커널이 연결되어 있지 않다.(커널에는 적절한 시스템 콜들이 이미 구현되어 있다) 이번 프로젝트1에서는 이 연결 부분 일부를 구현해야 한다.</p>\n<h1>2. argument passing</h1>\n<h2>2.1 분석</h2>\n<p>유저 스택은 커널이 아닌 유저 프로그램이 사용하는 스택이다. 유저 프로그램이 커널에게 시스템 콜을 요청할 때, 인자를 유저 스택에 쌓아두고, 커널에게 전달한다. 커널은 유저 스택에 있는 인자를 꺼내서 시스템 콜을 실행한다. 이렇게 사용자가 전달한 인자를 커널에 전달하는 것을 argument passing이라 한다.</p>\n<p>이 유저 스택에 인자를 쌓아서 커널에 전달하는 것을 80x86 호출 규약에 따라서 구현해야 한다. 그럼 이걸 어디서 구현해야 하는가?</p>\n<p>먼저 핀토스에서 프로그램을 실행하는 과정을 파헤쳐 본다. <code>threads/init.c</code>의 메인 함수가 실행되면서 <code>run_actions</code> 함수를 호출한다. 이때 <code>run</code> 옵션이 주어져 있으면 <code>run_task</code>함수가 호출되고 <code>run_task</code>에서는 <code>process_execute</code>함수를 이용하여 유저 프로세스를 생성한다. 또한 이 생성된 프로세스는 <code>process_wait</code> 내에 들어가서 핀토스가 유저 프로세스 종료까지 기다리게 한다(<code>process_wait</code> 부분은 아직 구현되어 있지 않긴 하다. 원래는 그렇다는 것).</p>\n<p>그러면 이 프로세스 생성은 어떻게 되는가? <code>process_execute</code>함수에서는 <code>thread_create</code> 함수를 이용해서 새로운 스레드를 생성한다. 그리고 이 스레드는 <code>thread_create</code>를 통해 만들어지면서 <code>start_process</code> 함수를 실행하고 run queue에 올라간다.</p>\n<p><code>start_process</code> 함수는 <code>load</code> 함수를 호출하여 유저 프로그램을 메모리에 올린다(만약 메모리에 로드가 실패할 시 스레드 종료). 그리고 <code>setup_stack</code> 함수를 호출하여 유저 스택을 초기화한다. 그럼 우리는 <code>load</code>함수에서 유저 스택에 인자를 쌓는 것을 구현하면 된다. 그러면 그 스택이 메모리에 로드되어 있는 유저 프로그램에 전달될 것이다.</p>\n<p><img src=\"/static/pintos_exec-5ddbaeb8.png\" alt=\"exec\"></p>\n<h2>2.2 실행 파일 이름 수정</h2>\n<p>하지만 그 전에 할 일이 있다. 앞에서 본 방법대로 echo x를 실행하면 load failed가 뜬다(아니라면 process_wait에 timer_msleep을 넣고 해보자. load failed가 뜰 것이다.). 에러 메시지를 읽어보면 'echo x'라는 이름의 파일을 열기를 실패했다고 한다...echo 명령어에 대한 동작이 담긴 파일 이름은 상식적으로 echo일 텐데 애초에 실행할 파일 이름을 잘못 전달하고 있다. 이것부터 고치자.</p>\n<p>먼저 load 함수의 file_name이 무엇인지 체크하자. 이 file_name을 통해서 load에 <code>printf</code>로 file_name을 출력하는 코드를 추가한다. 단 아직 <code>process_wait</code>이 구현되어 있지 않으므로 <code>printf</code>의 결과가 출력되기 전에 핀토스가 종료될 수 있다. 그래서 <code>process_wait</code>을 일단 2초 정도 대기하는 것으로 대체했다. 여기는 <code>src/devices/timer.h</code>의 <code>timer_msleep</code>을 사용하였다.</p>\n<pre><code class=\"language-c\">int process_wait (tid_t child_tid UNUSED) {\n  // timer_msleep는 milisecond 단위로 대기한다.\n  timer_msleep(2000);\n  return -1;\n}\n</code></pre>\n<p>그리고 아까의 커맨드인 <code>pintos --filesys-size=2 -p ../examples/echo -a echo -- -f -q run 'echo x'</code>를 실행하면 <code>echo x</code>가 출력되는 것을 확인할 수 있다. 이게 load의 인자로 주어진 file_name이다.</p>\n<p>여기서는 file_name은 <code>filesys_open</code>함수에 인자로 넘어간다. 따라서 <code>file_name</code>의 내용을 제목으로 갖는 파일을 열게 되는 것이다. 하지만 현재 <code>file_name</code>은 명령줄 전체를 가리키고 있다. 명령이 <code>echo x</code>라면 echo만 파일 이름이 되어야 하는데 명령 전체가 파일명으로 인식되는 것이다. 따라서 <code>file_name</code>을 수정해야 한다.</p>\n<p>이는 file_name을 공백을 통해 구분하여 첫 번째 단어를 파일명으로 인식되게 하면 된다. 따라서 <code>load</code> 함수의 첫 부분을 다음과 같이 수정한다. <code>file_name_first_word</code>에 file_name의 첫 단어를 넣고 이를 filesys_open에 넘겨주는 것이다. 또한 malloc을 했으면 free를 해주는 걸 잊으면 안 된다.</p>\n<pre><code class=\"language-c\">/* Allocate and activate page directory. */\n  t->pagedir = pagedir_create ();\n  if (t->pagedir == NULL)\n    goto done;\n  process_activate ();\n\n  /* parse the first word of file_name */\n  file_name_copy=malloc(sizeof(char)*(strlen(file_name)+1));\n  strlcpy(file_name_copy, file_name, (strlen(file_name)));\n  file_name_copy[strlen(file_name)]='\\0';\n  file_name_first_word=strtok_r(file_name_copy, \" \", &#x26;save_ptr);\n  printf(\"\\n\\n%s\\n\\n\", file_name_first_word);\n  /* Open executable file. */\n  file = filesys_open (file_name_first_word);\n  if (file == NULL)\n    {\n      printf (\"load: %s: open failed\\n\", file_name_first_word);\n      free(file_name_copy);\n      goto done;\n    }\n    free(file_name_copy);\n</code></pre>\n<p>다시 <code>src/userprog</code>에서 make를 하고 <code>pintos --filesys-size=2 -p ../examples/echo -a echo -- -f -q run 'echo x'</code>를 실행하면 <code>file_name_first_word</code>의 값으로 <code>echo</code>가 출력되는 것을 확인할 수 있다. 물론 페이지 폴트가 뜨지만 이건 유저 스택을 구성하면 해결된다.</p>\n<h2>2.3 유저 스택을 호출 규약에 맞게 구성</h2>\n<p>이제 80x86 호출 규약에 따라서 유저 스택을 구성해 주자. 이 내용은 <a href=\"https://web.stanford.edu/class/cs140/projects/pintos/pintos.pdf\">pintos 공식 매뉴얼</a>의 35-38쪽에 자세히 나와 있다.</p>\n<p>만약 다음과 같은 커맨드가 들어왔다고 하자.</p>\n<pre><code class=\"language-bash\">/bin/ls -l foo bar\n</code></pre>\n<p>호출 규약에 따르면 다음과 같이 스택에 쌓여야 한다. 이 작업을 시작하자.</p>\n<p><img src=\"/static/calling_convention-f6fc9430.png\" alt=\"calling convention\"></p>\n<h3>2.3.1 스택에 인자 넣기</h3>\n<p>이 작업은 전달받은 커맨드 라인과 스택 포인터를 통해서 이루어진다. 커맨드 라인의 인자들과 주소 등을 유저 스택에 쌓으면서 스택 포인터(esp)를 이동시켜 주는 것이다. 따라서 그 둘을 받는 함수 <code>construct_stack</code>을 <code>src/userprog/process.c</code>에 추가하고 프로토타입도 <code>src/userprog/process.h</code>에 추가한다.</p>\n<p>먼저 인자들을 문자열 형태로 스택에 쌓아 줘야 한다. 단 거꾸로 쌓아줘야 하므로 이 동작을 위해서는 전체 인자의 개수를 알아야 한다. 따라서 먼저 인자의 개수를 세어 주자. 먼저 문자열을 공백으로 구분하기 위해 &#x3C;string.h>의 <code>strtok_r</code>함수를 사용할 것인데 이 함수는 인자로 들어오는 문자열을 훼손시키므로 먼저 복사본을 만들어 주자.</p>\n<pre><code class=\"language-c\">void construct_stack(const char* file_name, void** esp){\n  int argc, idx;\n  char** argv;\n  int total_arg_len, cur_arg_len;\n  char file_name_copy[1000];\n  char* file_name_token, *save_ptr;\n\n  strlcpy(file_name_copy, file_name, strlen(file_name)+1);\n}\n</code></pre>\n<p>그리고 하나하나 파싱해 가며 인자 개수를 센다. 중간중간 주석에 있는 출력 코드는 디버깅을 위한 것인데 저런 식으로 복사된 것이나 토크나이징된 결과를 출력하면서 코드를 짰다.</p>\n<pre><code class=\"language-c\">  argc=0;\n  // count arg\n  // function name parse\n  file_name_token=strtok_r(file_name_copy, \" \", &#x26;save_ptr);\n  //printf(\"tokenized file name : %s\\n\", file_name_token);\n  // count argument number\n  while(file_name_token!=NULL){\n    file_name_token=strtok_r(NULL, \" \", &#x26;save_ptr);\n    //printf(\"tokenized file name : %s\\n\", file_name_token);\n    argc++;\n  }\n  //printf(\"arg count : %d\\n\\n\",argc);\n</code></pre>\n<p>그 다음으로는 인자들(문자열)을 넣어 줘야 한다. 하지만 호출 규약에 맞추려면 인자가 주어진 순서와 반대로 스택에 넣어야 한다. 따라서 먼저 인자들을 저장할 공간을 할당해 주자. 그리고 다시 토크나이징을 해서 인자들을 저장해 준다. 이때 추후를 위해서 인자들이 들어간 전체 공간의 길이도 <code>total_arg_len</code>으로 저장한다.</p>\n<pre><code class=\"language-c\">  argv=malloc(sizeof(char)*(argc+1));\n  strlcpy(file_name_copy, file_name, strlen(file_name)+1);\n  idx=0;\n  total_arg_len=0;\n  for(file_name_token=strtok_r(file_name_copy, \" \", &#x26;save_ptr);file_name_token!=NULL;file_name_token=strtok_r(NULL, \" \", &#x26;save_ptr)){\n    total_arg_len+=strlen(file_name_token)+1;\n    argv[idx]=file_name_token;\n    idx++;\n  }\n</code></pre>\n<p>이제 드디어 인자들을 스택에 넣을 차례다. 인자들의 주소를 저장한 배열 argv를 역순으로 순회하면서 인자들을 문자열 형태로 스택에 담아 준다. 그러면서 이후 스택에 인자들의 주소도 담을 것을 대비해서 argv배열에는 각 인자들의 시작 주소를 저장해 둔다.</p>\n<pre><code class=\"language-c\">  for(idx=argc-1;idx>=0;idx--){\n    cur_arg_len=strlen(argv[idx]);\n    *esp-=cur_arg_len+1; // include null character\n    strlcpy(*esp, argv[idx], cur_arg_len+1);\n    // 각 인자들의 시작 주소 저장\n    argv[idx]=*esp;\n    //printf(\"file name token %s\\n\", *esp);\n  }\n</code></pre>\n<p>그 다음으로는 word alignment, NULL, 인자들의 시작 주소, argv주소, argc, return address를 차례로 넣어 준 후 동적 할당한 메모리를 해제해 준다. 이렇게 해서 구성된 <code>construct_stack</code> 함수는 다음과 같다.</p>\n<pre><code class=\"language-c\">void construct_stack(const char* file_name, void** esp){\n  int argc, idx;\n  char** argv;\n  int total_arg_len, cur_arg_len;\n  char file_name_copy[1000];\n  char* file_name_token, *save_ptr;\n\n  strlcpy(file_name_copy, file_name, strlen(file_name)+1);\n  argc=0;\n  // count arg\n  // function name parse\n  file_name_token=strtok_r(file_name_copy, \" \", &#x26;save_ptr);\n  //printf(\"tokenized file name : %s\\n\", file_name_token);\n  // count argument number\n  while(file_name_token!=NULL){\n    file_name_token=strtok_r(NULL, \" \", &#x26;save_ptr);\n    //printf(\"tokenized file name : %s\\n\", file_name_token);\n    argc++;\n  }\n  //printf(\"arg count : %d\\n\\n\",argc);\n\n  argv=malloc(sizeof(char)*(argc+1));\n  strlcpy(file_name_copy, file_name, strlen(file_name)+1);\n  idx=0;\n  total_arg_len=0;\n  for(file_name_token=strtok_r(file_name_copy, \" \", &#x26;save_ptr);file_name_token!=NULL;file_name_token=strtok_r(NULL, \" \", &#x26;save_ptr)){\n    total_arg_len+=strlen(file_name_token)+1;\n    argv[idx]=file_name_token;\n    idx++;\n  }\n\n  for(idx=argc-1;idx>=0;idx--){\n    cur_arg_len=strlen(argv[idx]);\n    *esp-=cur_arg_len+1; // include null character\n    strlcpy(*esp, argv[idx], cur_arg_len+1);\n    argv[idx]=*esp;\n    //printf(\"file name token %s\\n\", *esp);\n  }\n\n  /* word alignment */\n  if(total_arg_len%4){\n    *esp-=4-(total_arg_len%4);\n  }\n  /* NULL pointer seltinel ensures that argv[argc] is NULL\n  (required by C standard) */\n  *esp-=4;\n  **((uint32_t**)esp)=0;\n\n  for(idx=argc-1;idx>=0;idx--){\n    *esp-=4;\n    **((uint32_t**)esp)=argv[idx];\n  }\n\n  //argv\n  *esp-=4;\n  **((uint32_t**)esp)=*esp+4;\n\n  //argc\n  *esp-=4;\n  **((uint32_t**)esp)=argc;\n\n  //return address\n  *esp-=4;\n  **((uint32_t**)esp)=0;\n\n  free(argv);\n}\n</code></pre>\n<p>이때 스택에 인자들이 잘 담겼는지 디버깅을 위해서는 <code>hex_dump</code>함수를 이용할 수 있다. <code>construct_stack</code>함수의 끝에 다음과 같은 코드를 추가해 보자.</p>\n<pre><code class=\"language-c\">printf(\"hex dump in construct_stack start\\n\\n\");\nhex_dump(*esp, *esp, 100, true);\n</code></pre>\n<p>그 상태에서 <code>src/userprog</code>에서 make를 하고 이를 실행하면 다음과 같이 메모리가 hex형태로 출력되어 나온다. 이게 호출 규약에 맞게 잘 구성된 메모리인지를 직접 계산해서 확인할 수 있다.</p>\n<pre><code>pintos --filesys-size=2 -p ../examples/echo -a echo -- -f -q run 'echo x'\n</code></pre>\n<p><img src=\"/static/hex_dump-bec45dc0.png\" alt=\"hex_dump\"></p>\n<h1>3. 시스템 콜 핸들러</h1>\n<p>이제 시스템 콜을 구현하러 가보자. 이 시스템 콜은 어디서 구현해야 할까? 위에 hex_dump를 캡처한 사진을 보면 hex_dump의 결과 출력 다음 <code>system call!</code> 이라는 문구가 있는 것을 확인할 수 있다. 이 문구가 어디서 출력되는지 찾아보자. 찾아보면 <code>src/userprog/syscall.c</code>에 있다. 거기의 <code>syscall_handler</code>함수가 호출되면서 system call! 이 출력되는 것이다. 그럼 이 함수는 무엇을 하는가?</p>\n<p>글 맨 아래의 참고 사이트들을 참고하면 다음과 같다. init.c의 메인 함수에서 write를 호출한다. 그러면 src/lib/user/syscall.c에 있는 syscall 어셈블리 함수에서 유저 스택에 시스템 콜 넘버와 시스템 콜 인자들을 담아서 syscall_handler를 호출한다.</p>\n<p>이때 유저 스택은 다음과 같은 구조로 쌓여 있다.</p>\n<p><img src=\"/static/syscall_stack-a4fab6e9.PNG\" alt=\"syscall_stack\"></p>\n<p>즉 syscall number가 esp 위치에 있고 시스템 콜 인자들이 그 위 즉 esp+4, esp+8, esp+12...의 위치에 들어가는 것이다. 이 스택 포인터 esp는 syscall_handler 함수가 인자로 받는 intr_frame 구조체의 esp에 있다. 이 intr_frame은 인터럽트의 각종 레지스터 정보를 담고 있다. 추후 시스템 콜의 리턴값을 담을 때 여기의 eax 레지스터에 담을 것이다.</p>\n<p>따라서 우리는 이 esp의 시스템 콜 넘버를 이용해서 알맞은 시스템 콜을 호출하는 부분을 짜야 한다. 시스템 콜 넘버마다 어떤 함수를 호출해야 하는지는 src/lib/syscall-nr.h를 참고했다. 친절하게 <code>/* Projects 2 and later. */</code> 라고 주석도 달아서, 어떤 시스템 콜 넘버를 사용해야 하는지도 알려준다. 따라서 먼저 시스템 콜 핸들러에 시스템 콜 넘버를 추가해 주자. 이때 switch문을 사용하는데, 주의할 점은 intr_frame의 esp는 void*타입으로 선언되어 있기 때문에 역참조할 때 포인터 변환을 해줘야 한다는 것이다.</p>\n<pre><code class=\"language-c\">static void\nsyscall_handler (struct intr_frame *f UNUSED)\n{\n  switch(*(int32_t*)(f->esp)){\n    case SYS_HALT:                   /* Halt the operating system. */\n    break;\n    case SYS_EXIT:                   /* Terminate this process. */\n    break;\n    case SYS_EXEC:                   /* Start another process. */\n    break;\n    case SYS_WAIT:                   /* Wait for a child process to die. */\n    break;\n    case SYS_CREATE:                 /* Create a file. */\n    break;\n    case SYS_REMOVE:                 /* Delete a file. */\n    break;\n    case SYS_OPEN:                   /* Open a file. */\n    break;\n    case SYS_FILESIZE:               /* Obtain a file's size. */\n    break;\n    case SYS_READ:                   /* Read from a file. */\n    break;\n    case SYS_WRITE:                  /* Write to a file. */\n    break;\n    case SYS_SEEK:                   /* Change position in a file. */\n    break;\n    case SYS_TELL:                   /* Report current position in a file. */\n    break;\n    case SYS_CLOSE:                  /* Close a file. */\n    break;\n  }\n  printf (\"system call! %d\\n\", *(int32_t*)(f->esp));\n  thread_exit ();\n}\n</code></pre>\n<p>이때 system call handler에서 f->esp를 출력해 보는 방식으로 <code>echo x</code>에서 호출하는 시스템 콜이 무엇인지 볼 수 있다. echo는 system call 9번, write system call을 호출한다. 우리는 이렇게 주어지는 시스템 콜 번호에 따라서 알맞은 시스템 콜을 호출하도록 구현해야 한다.</p>\n<h2>3.1 주소 유효성 검사</h2>\n<p>이때 시스템 콜을 구현하고 호출하기 전에 고려해야 할 게 있다. 시스템 콜 핸들러에 넘어온 주소가 문제가 있는 주소가 아닌지 확인하는 것이다. 그럼 문제가 있는 주소란 무엇인가? 학교에서 제공한 proj1 ppt에 보면 친절하게 설명되어 있다.</p>\n<p><img src=\"/static/validate_ppt-8967e4ac.PNG\" alt=\"validate\"></p>\n<p>따라서 먼저 특정 주소가 유효한지 판별하는 <code>check_address</code> 함수를 구현하자. 여기에 어떤 함수를 써야 하는지도 다 나와 있다. userprog/pagedir.c의 pagedir_get_page 함수와 threads/vaddr.h의 is_user_vaddr 함수를 쓴다. 그런데 pagedir_get_page 함수에는 특정 pagedir도 함께 인수로 넘겨줘야 하는데, 이는 현재 실행중인 스레드의 pagedir로 한다.</p>\n<p>종합해서 <code>check_address</code> 함수를 구현하면 다음과 같다.</p>\n<pre><code class=\"language-c\">void check_address(void* vaddr){\n  if(vaddr==NULL){exit(-1);}\n  if(!is_user_vaddr(vaddr)){exit(-1);}\n  if(!pagedir_get_page(thread_current()->pagedir, vaddr)==NULL){exit(-1);}\n}\n</code></pre>\n<p>이 함수를 이용해서 시스템 콜 함수가 받는 인자의 주소, esp+4, esp+8..등에 대한 검증을 진행하면 된다.</p>\n<h2>3.2 시스템 콜 구현</h2>\n<p>이제 각 시스템 콜 함수들을 구현해 보자. 이는 핀토스 공식 매뉴얼과 프로젝트 ppt를 참고했다. 먼저 userprog/syscall.h에 시스템 콜들의 프로토타입을 선언해 주자. bool타입을 리턴해 주는 함수들이 있으므로 <code>stdbool.h</code>도 인클루드해 준다.</p>\n<pre><code class=\"language-c\">// src/userprog/syscall.h\n#ifndef USERPROG_SYSCALL_H\n#define USERPROG_SYSCALL_H\n\n#include &#x3C;stdbool.h>\n\ntypedef int pid_t;\n\nvoid syscall_init (void);\nvoid check_address(void* vaddr);\nvoid halt(void);\nvoid exit(int status);\npid_t exec(const char *cmd_line);\nint wait(pid_t pid);\nbool create(const char* file, unsigned int initial_size);\nbool remove(const char* file);\nint open(const char* file);\nint filesize(int fd);\nint read(int fd, void *buffer, unsigned int size);\nint write(int fd, const void* buffer, unsigned int size);\nvoid seek(int fd, unsigned int position);\nunsigned int tell(int fd);\nvoid close(int fd);\nint fibonacci(int n);\nint max_of_four_int(int a, int b, int c, int d);\n\n#endif /* userprog/syscall.h */\n</code></pre>\n<p>그리고 프로젝트 1에서는 이 중 halt, exit, exec, wait을 구현하고 read는 stdin에 대해, write는 stdout에 대해서 작동하도록 구현해야 한다. 추가적인 시스템 콜인 fibonacci와 max_of_four_int도 구현해야 하지만 일단 핀토스 공식 매뉴얼에 있는 건 저게 전부다.</p>\n<p>나머지 시스템 콜은 프로젝트 2에서 구현하게 될 것이다. 그러므로 이 중에서 구현해야 할 함수들을 syscall.c에 구현해 주자. 구현 방법은 학교에서 제공한 ppt를 참고했다.</p>\n<h3>3.2.1 halt</h3>\n<p>halt는 <code>src/devices/shutdown.c</code>에 있는 <code>shutdown_power_off()</code> 함수를 호출하면 된다. 이 함수는 핀토스를 종료시키는 함수이다.</p>\n<pre><code class=\"language-c\">// src/userprog/syscall.c\nvoid halt(void){\n  shutdown_power_off();\n}\n</code></pre>\n<h3>3.2.2 exit</h3>\n<p>exit는 현재 실행 중인 프로세스를 종료시키는 함수이다. 이 함수는 프로세스의 종료 상태를 인자로 받는다. 프로세스의 종료 상태는 부모 프로세스가 <code>wait()</code> 함수를 호출했을 때 리턴되는 값이다.</p>\n<p>이렇게 exit함수가 인자로 받은 프로세스의 종료 상태는 <code>thread_current()->exit_status</code>에 저장해야 한다. 따라서 이 값을 인자로 받은 종료 상태로 바꿔주고, 종료 메시지를 출력하고 현재 프로세스를 종료시키면 된다. 이는 <code>thread_exit()</code> 함수를 호출하면 된다. 단 문제가 있다. 현재 스레드 구조체에는 스레드의 종료 상태를 나타내는 요소가 없다는 것이다.</p>\n<p>따라서 src/threads/thread.h의 thread 구조체에 다음과 같이 exit_status라는 멤버 변수를 추가해 주어야 한다.</p>\n<pre><code class=\"language-c\">// src/threads/thread.h 의 thread 구조체 내용의 일부\n#ifdef USERPROG\n    /* Owned by userprog/process.c. */\n    uint32_t *pagedir;                  /* Page directory. */\n    int exit_status;\n\n#endif\n</code></pre>\n<p>이제 exit 함수를 구현해 주면 된다. 이것은 한양대 학교에서 제공한 ppt의 80쪽의 exit 구현 설명을 참고했다.</p>\n<pre><code class=\"language-c\">// src/userprog/syscall.c\nvoid exit(int status){\n  struct thread *t=thread_current();\n  printf(\"%s: exit(%d)\\n\", thread_name(), status);\n  t->exit_status=status;\n  thread_exit();\n}\n</code></pre>\n<h3>3.2.3 exec</h3>\n<p>exec는 <code>process_execute</code>함수만 호출해 주면 된다.</p>\n<pre><code class=\"language-c\">// src/userprog/syscall.c\npid_t exec(const char *cmd_line){\n  process_execute(cmd_line);\n}\n</code></pre>\n<h3>3.2.4 wait</h3>\n<p>wait는 <code>process_wait</code>함수만 호출해 주면 된다. 아직 <code>process_wait</code> 함수는 단순히 2초 대기하는 식으로 구현되어 있다. 추가적인 구현은 나중에 한다.</p>\n<pre><code class=\"language-c\">// src/userprog/syscall.c\nint wait(pid_t pid){\n  process_wait(pid);\n}\n</code></pre>\n<h3>3.2.5 read</h3>\n<p>read 함수는 <code>src/devices/input.c</code>에 있는 <code>input_getc()</code> 함수를 이용하면 된다. 이 함수는 키보드에서 입력된 문자를 리턴한다. 그리고 아직은 stdin만 지원하므로 인자로 받은 fd가 0이 아니면 -1을 리턴하면 된다.</p>\n<pre><code class=\"language-c\">// src/userprog/syscall.c\nint read(int fd, void *buffer, unsigned int size){\n  // not from STDIN\n  unsigned int cnt;\n  uint8_t temp;\n  if(fd==0){\n    cnt=0;\n    for(cnt=0;(cnt&#x3C;size) &#x26;&#x26; (temp=input_getc());cnt++){\n      *(uint8_t*)(buffer+cnt)=temp;\n    }\n    return cnt;\n  }\n  else{\n    return -1;\n  }\n}\n</code></pre>\n<h3>3.2.6 write</h3>\n<p>write 함수는 putbuf 함수를 이용하면 된다. 이는 &#x3C;stdio.h>에 있다. 또한 아직은 stdout에 대해서만 구현하면 되므로 fd가 1이 아니면 -1을 리턴하면 된다.</p>\n<pre><code class=\"language-c\">int write(int fd, const void* buffer, unsigned int size){\n  if(fd==1){\n    putbuf(buffer, size);\n    return size;\n  }\n  return -1;\n}\n</code></pre>\n<h2>3.3 시험해 보기</h2>\n<p>시스템 콜 핸들러에 지금까지 구현한 함수들을 추가하고 아까의 echo x 명령을 실행해 보자. 먼저 syscall_handler에 다음과 같이 시스템 콜 함수들의 실행을 추가해 주자. 시스템 콜 실행 전 시스템 콜 함수의 인자들의 주소가 정상적인지 체크해 주는 걸 꼭 하자.</p>\n<pre><code class=\"language-c\">// src/userprog/syscall.c\nstatic void\nsyscall_handler (struct intr_frame *f UNUSED)\n{\n  switch(*(int32_t*)(f->esp)){\n    case SYS_HALT:                   /* Halt the operating system. */\n    halt();\n    break;\n    case SYS_EXIT:                   /* Terminate this process. */\n    check_address(f->esp+4);\n    exit(*(int*)(f->esp+4));\n    break;\n    case SYS_EXEC:                   /* Start another process. */\n    check_address(f->esp+4);\n    f->eax=exec((char*)*(uint32_t*)(f->esp+4));\n    break;\n    case SYS_WAIT:                   /* Wait for a child process to die. */\n    check_address(f->esp+4);\n    f->eax = wait(*(uint32_t*)(f->esp+4));\n    break;\n    case SYS_CREATE:                 /* Create a file. */\n    break;\n    case SYS_REMOVE:                 /* Delete a file. */\n    break;\n    case SYS_OPEN:                   /* Open a file. */\n    break;\n    case SYS_FILESIZE:               /* Obtain a file's size. */\n    break;\n    case SYS_READ:                   /* Read from a file. */\n    check_address(f->esp+4);\n    check_address(f->esp+8);\n    check_address(f->esp+12);\n    f->eax = read((int)*(uint32_t*)(f->esp+4), (void*)*(uint32_t*)(f->esp+8),\n\t\t\t\t\t(unsigned)*(uint32_t*)(f->esp+12));\n    break;\n    case SYS_WRITE:                  /* Write to a file. */\n    //printf(\"write system call!\\n\");\n    check_address(f->esp+4);\n    check_address(f->esp+8);\n    check_address(f->esp+12);\n    f->eax = write((int)*(uint32_t*)(f->esp+4), (const void*)*(uint32_t*)(f->esp+8),\n\t\t\t\t\t(unsigned)*(uint32_t*)(f->esp+12));\n    break;\n    case SYS_SEEK:                   /* Change position in a file. */\n    break;\n    case SYS_TELL:                   /* Report current position in a file. */\n    break;\n    case SYS_CLOSE:                  /* Close a file. */\n    break;\n  }\n  //printf (\"system call! %d\\n\", *(int32_t*)(f->esp));\n  thread_exit ();\n}\n</code></pre>\n<p>이 상태에서 make를 하고 echo x 명령을 실행해 보자. 제대로 되지 않는다.. 문제는 syscall_handler 의 마지막 줄에서 thread_exit()를 해버린다는 것이다. 여기서 핸들러 함수가 다른 곳으로 넘어가지 않도록 해야 한다. 이를 위해 thread_exit()를 호출하는 부분을 주석처리하자.</p>\n<p>그러면 echo x를 했을 때 제대로 실행되는 것처럼 보인다.</p>\n<p><img src=\"/static/check1-a8c71497.png\" alt=\"check-1\"></p>\n<p>그러면 이제 make check을 한번 해보자. args-single부터 실패한다. <code>src/userprog/build/tests/userprog</code>에 가서 args-single에 관련된 파일들을 열어 보면 실패한 이유를 알 수 있다. 파일명 파싱에 관련된 문제였다.</p>\n<p>예를 들어서 <code>args-many a b c</code>라는 명령이 전달되면 args-many 명령에 따르는 파일이 실행되어야 하는데 <code>args-many a b c</code> 전체가 파일명으로 인식된다.</p>\n<p>이 오류는 '참고'에 있는 네이버 블로그에서 쉽게 해결 가능했다. userprog/process.c의 process-create 함수에서 thread-create함수를 호출할 때, 파일명을 넘겨주는 부분을 수정하면 된다. 주어진 파일명의 첫 번째 단어만 넘겨주도록 하자. process_execute 함수를 다음과 같이 수정한다.</p>\n<pre><code class=\"language-c\">tid_t\nprocess_execute (const char *file_name)\n{\n  char *fn_copy;\n  tid_t tid;\n  char file_name_copy[1000];\n  char* parsed_file_name;\n  char* save_ptr;\n\n  /* Make a copy of FILE_NAME.\n     Otherwise there's a race between the caller and load(). */\n  fn_copy = palloc_get_page (0);\n  if (fn_copy == NULL)\n    return TID_ERROR;\n  strlcpy (fn_copy, file_name, PGSIZE);\n\n  // 첫 단어만 파싱\n  strlcpy(file_name_copy, file_name, strlen(file_name)+1);\n  parsed_file_name=strtok_r(file_name_copy, \" \", &#x26;save_ptr);\n\n  /* Create a new thread to execute FILE_NAME. */\n  tid = thread_create (file_name, PRI_DEFAULT, start_process, fn_copy);\n  if (tid == TID_ERROR)\n    palloc_free_page (fn_copy);\n  return tid;\n}\n</code></pre>\n<p>이제 make check을 돌려보면 그럭저럭 통과한다. args-multiple은 실패하는데 이걸 한번 고쳐보자.</p>\n<h2>3.4 페이지 폴트 디버깅</h2>\n<p>가장 먼저 실패하는 것은 args-multiple. 페이지 폴트가 뜬다. 페이지 폴트는 src/userprog/exception.c를 수정해서 고칠 수 있다. page_fault 함수에서, 커널 모드일 땐 커널 주소만 읽게 하고 유저 모드일 땐 유저 주소만 읽게 하는 것이다.</p>\n<pre><code class=\"language-c\">static void\npage_fault (struct intr_frame *f)\n{\n  bool not_present;  /* True: not-present page, false: writing r/o page. */\n  bool write;        /* True: access was write, false: access was read. */\n  bool user;         /* True: access by user, false: access by kernel. */\n  void *fault_addr;  /* Fault address. */\n\n  /* Obtain faulting address, the virtual address that was\n     accessed to cause the fault.  It may point to code or to\n     data.  It is not necessarily the address of the instruction\n     that caused the fault (that's f->eip).\n     See [IA32-v2a] \"MOV--Move to/from Control Registers\" and\n     [IA32-v3a] 5.15 \"Interrupt 14--Page Fault Exception\n     (#PF)\". */\n  asm (\"movl %%cr2, %0\" : \"=r\" (fault_addr));\n\n  /* Turn interrupts back on (they were only off so that we could\n     be assured of reading CR2 before it changed). */\n  intr_enable ();\n\n  /* Count page faults. */\n  page_fault_cnt++;\n\n  /* Determine cause. */\n  not_present = (f->error_code &#x26; PF_P) == 0;\n  write = (f->error_code &#x26; PF_W) != 0;\n  user = (f->error_code &#x26; PF_U) != 0;\n\n  /* new! 커널 모드일 땐 커널 주소만, 유저 모드일 땐 유저 주소만 읽도록.\n  그렇지 않으면 exit 시스템 콜. 덤으로 not_present 도 처리 */\n  if(not_present){exit(-1);}\n  if(!user &#x26;&#x26; !is_kernel_vaddr(fault_addr)){\n    exit(-1);\n  }\n  if(user &#x26;&#x26; !is_user_vaddr(fault_addr)){\n    exit(-1);\n  }\n\n  /* To implement virtual memory, delete the rest of the function\n     body, and replace it with code that brings in the page to\n     which fault_addr refers. */\n  printf (\"Page fault at %p: %s error %s page in %s context.\\n\",\n          fault_addr,\n          not_present ? \"not present\" : \"rights violation\",\n          write ? \"writing\" : \"reading\",\n          user ? \"user\" : \"kernel\");\n  kill (f);\n}\n</code></pre>\n<p>이렇게 하면 args-multiple에서 페이지 폴트는 더 이상 뜨지 않는다. 하지만 인자가 제대로 출력되지 않는 문제가 발생한다. 뭔가 스택 구성에 문제가 있는 건가? 스택을 구성할 때를 아무리 살펴봐도 딱히 문제가 보이지 않는다. 또 꽤 많은 테스트가 통과하므로 일단 아직 구현하지 않은 어디선가 발생한 문제로 생각하고 다음 과정으로 넘어가 보자.</p>\n<p>다음은 프로젝트 계층 구조를 구현하고 그것을 통해 process_wait을 구현하는 것이다.</p>\n<h1>4. Wait 구현하기</h1>\n<h2>4.1 프로젝트 계층 구조 구현</h2>\n<p>wait은 부모 프로세스가 자식 프로세스 종료까지 기다리는 기능이다. 단 지금 스레드 구조체에는 어떤 프로세스가 부모이고 어떤 프로세스가 자식인지 나타내는 부분이 없다. 따라서 스레드 구조체에 이 부분을 추가하고 계층 구조를 편하게 사용하기 위한 함수들을 추가하자.</p>\n<p>한양대학교 ppt를 참고하면 일단 다음과 같은 정보들을 스레드 구조체에 추가해야 한다고 한다.</p>\n<p><img src=\"/static/thread-55f87efd.png\" alt=\"thread\"></p>\n<p>따라서 스레드 구조체에 다음과 같은 부분을 추가한다. 아까 exit_status를 추가한 부분과 같은 곳이다.</p>\n<pre><code class=\"language-c\">#ifdef USERPROG\n    /* Owned by userprog/process.c. */\n    uint32_t *pagedir;                  /* Page directory. */\n    // parent process descriptor\n    struct thread* parent_thread;\n\n    /* each structure\n   that is a potential list element must embed a struct list_elem\n   member. */\n    /* child list element */\n    struct list_elem child_thread_elem;\n    /* child list */\n    struct list child_threads;\n    /* 프로세스의 프로그램 메모리 적재 여부 */\n    bool load_flag;\n    /* 프로세스 종료 유무 확인 */\n    bool exit_flag;\n    /* exit semaphore, 자식 프로세스 종료 대기를 위한 세마포어 */\n    struct semaphore exit_sema;\n    /* load semaphore, 자식 프로세스 생성 대기 */\n    struct semaphore load_sema;\n    /* exit 호출 시 종료 상태 */\n    int exit_status;\n\n#endif\n</code></pre>\n<p>그리고 src/threads/thread.c의 <code>init_thread</code>함수에 새로 추가한 스레드 구조체의 원소들을 초기화하는 부분을 넣는다.</p>\n<pre><code class=\"language-c\">  #ifdef USERPROG\n  /* 자식 리스트 초기화 */\n  list_init(&#x26;(t->child_threads));\n  // push to the child list of the running thread\n  list_push_back(&#x26;(running_thread()->child_threads), &#x26;(t->child_thread_elem));\n  // 부모 프로세스 저장\n  t->parent_thread=running_thread();\n  sema_init(&#x26;(t->exit_sema), 0);\n  sema_init(&#x26;(t->load_sema), 0);\n  #endif\n</code></pre>\n<p>자식 리스트 중 특정 pid를 갖는 스레드를 검색하여 리턴하는 함수도 구현한다.</p>\n<pre><code class=\"language-c\">struct thread* get_child_process(pid_t pid){\n  struct thread* child_thread;\n  struct list_elem* elem;\n\n  for(elem=list_begin(&#x26;(thread_current()->child_threads)); elem!=list_end(&#x26;(thread_current()->child_threads)); elem=list_next(elem)){\n    child_thread=list_entry(elem, struct thread, child_thread_elem);\n    if(pid==child_thread->tid){\n      return child_thread;\n    }\n  }\n  // 리스트에 존재하지 않으면 NULL 리턴\n  return NULL;\n}\n</code></pre>\n<h2>4.2 process_wait 구현</h2>\n<p>그럼 process_wait에서는 뭘 해야 하는가? 인자로 주어진 tid 프로세스가 끝날 때까지 기다리면 된다. 이는 세마포어를 사용해서 구현한다. 자식 프로세스가 실행될 때 sema_down을 이용해서 부모 프로세스를 대기시키고 자식 프로세스가 종료될 때 sema_up을 이용해서 부모 프로세스를 재개시킨다.</p>\n<pre><code class=\"language-c\">// src/userprog/process.c\nint\nprocess_wait (tid_t child_tid UNUSED)\n{\n  struct thread* child_thread;\n  struct list_elem* elem;\n  int exit_status;\n\n  child_thread=get_child_process(child_tid);\n  // child thread not found\n  if(child_thread==NULL){\n    return -1;\n  }\n  // 자식 프로세스 종료까지 대기\n  sema_down(&#x26;(child_thread->exit_sema));\n  exit_status=child_thread->exit_status;\n  list_remove(&#x26;(child_thread->child_thread_elem));\n  return exit_status;\n}\n</code></pre>\n<p>그리고 thread_exit 함수에서는 자식 스레드가 종료될 때 세마포어를 풀어준다.</p>\n<pre><code class=\"language-c\">// src/threads/thread.c\nvoid\nthread_exit (void)\n{\n  ASSERT (!intr_context ());\n\n#ifdef USERPROG\n  process_exit ();\n#endif\n\n  /* Remove thread from all threads list, set our status to dying,\n     and schedule another process.  That process will destroy us\n     when it calls thread_schedule_tail(). */\n  intr_disable ();\n  list_remove (&#x26;thread_current()->allelem);\n  // 부모 프로세스의 대기 상태를 이탈시킨다.\n  sema_up(&#x26;(thread_current()->exit_sema));\n  thread_current ()->status = THREAD_DYING;\n  schedule ();\n  NOT_REACHED ();\n}\n</code></pre>\n<p>그런데 문제가 있다. 부모 프로세스는 자식 프로세스를 기다린다. 자식 프로세스는 종료되면서 sema_up을 하고 따라서 부모 프로세스는 재개된다. 부모 프로세스는 list_remove를 수행하고 자식 스레드의 종료 상태를 저장한다. 하지만 그때 자식 프로세스의 메모리가 남아 있을까? 없기에 문제가 생긴다. 프로세스가 끝나질 않는다.</p>\n<p>자식 프로세스가 종료된 후 종료 상태를 저장해 주고 자식 리스트에서 삭제하는 동작을 수행해 줘야 한다. 하지만 자식 프로세스가 종료됨과 동시에 sema_up을 하면서 자식 프로세스의 프로세스 디스크립터 메모리가 사라져 버린다. 그래서 자식 프로세스를 삭제하면서 수행해야 하는 동작을 못하게 된다. 따라서 부모 프로세스도 종료되지 못해서 아예 프로세스 전체가 종료가 안되는 듯하다.</p>\n<p>따라서 프로세스 디스크립터 메모리를 삭제하지 않도록 <code>src/userprog/thread.c</code>의 <code>thread_schedule_tail </code>함수를 수정한다.</p>\n<pre><code class=\"language-c\">void\nthread_schedule_tail (struct thread *prev)\n{\n  struct thread *cur = running_thread ();\n\n  ASSERT (intr_get_level () == INTR_OFF);\n\n  /* Mark us as running. */\n  cur->status = THREAD_RUNNING;\n\n  /* Start new time slice. */\n  thread_ticks = 0;\n\n#ifdef USERPROG\n  /* Activate the new address space. */\n  process_activate ();\n#endif\n\n  /* If the thread we switched from is dying, destroy its struct\n     thread.  This must happen late so that thread_exit() doesn't\n     pull out the rug under itself.  (We don't free\n     initial_thread because its memory was not obtained via\n     palloc().) */\n  if (prev != NULL &#x26;&#x26; prev->status == THREAD_DYING &#x26;&#x26; prev != initial_thread)\n    {\n      ASSERT (prev != cur);\n      /* 이 부분을 주석처리해서 프로세스 디스크립터 삭제를 막는다. */\n      //palloc_free_page (prev);\n    }\n}\n</code></pre>\n<p>이러면 많은 것이 해결된다. 이제 <code>make check</code>을 해보면 80개 중 46개가 통과되고, 프로젝트 1에서 요구되는 21개의 테스트는 모두 통과된다.</p>\n<pre><code>pass tests/userprog/args-none\npass tests/userprog/args-single\npass tests/userprog/args-multiple\npass tests/userprog/args-many\npass tests/userprog/args-dbl-space\npass tests/userprog/sc-bad-sp\npass tests/userprog/sc-bad-arg\npass tests/userprog/sc-boundary\npass tests/userprog/sc-boundary-2\npass tests/userprog/sc-boundary-3\npass tests/userprog/halt\npass tests/userprog/exit\npass tests/userprog/create-normal\nFAIL tests/userprog/create-empty\nFAIL tests/userprog/create-null\nFAIL tests/userprog/create-bad-ptr\nFAIL tests/userprog/create-long\nFAIL tests/userprog/create-exists\npass tests/userprog/create-bound\npass tests/userprog/open-normal\nFAIL tests/userprog/open-missing\npass tests/userprog/open-boundary\nFAIL tests/userprog/open-empty\npass tests/userprog/open-null\nFAIL tests/userprog/open-bad-ptr\npass tests/userprog/open-twice\npass tests/userprog/close-normal\npass tests/userprog/close-twice\npass tests/userprog/close-stdin\npass tests/userprog/close-stdout\npass tests/userprog/close-bad-fd\nFAIL tests/userprog/read-normal\nFAIL tests/userprog/read-bad-ptr\nFAIL tests/userprog/read-boundary\nFAIL tests/userprog/read-zero\npass tests/userprog/read-stdout\npass tests/userprog/read-bad-fd\nFAIL tests/userprog/write-normal\nFAIL tests/userprog/write-bad-ptr\nFAIL tests/userprog/write-boundary\nFAIL tests/userprog/write-zero\npass tests/userprog/write-stdin\npass tests/userprog/write-bad-fd\npass tests/userprog/exec-once\npass tests/userprog/exec-arg\npass tests/userprog/exec-bound\npass tests/userprog/exec-bound-2\npass tests/userprog/exec-bound-3\npass tests/userprog/exec-multiple\npass tests/userprog/exec-missing\npass tests/userprog/exec-bad-ptr\npass tests/userprog/wait-simple\npass tests/userprog/wait-twice\npass tests/userprog/wait-killed\npass tests/userprog/wait-bad-pid\npass tests/userprog/multi-recurse\nFAIL tests/userprog/multi-child-fd\nFAIL tests/userprog/rox-simple\nFAIL tests/userprog/rox-child\nFAIL tests/userprog/rox-multichild\npass tests/userprog/bad-read\npass tests/userprog/bad-write\npass tests/userprog/bad-read2\npass tests/userprog/bad-write2\npass tests/userprog/bad-jump\npass tests/userprog/bad-jump2\nFAIL tests/userprog/no-vm/multi-oom\nFAIL tests/filesys/base/lg-create\nFAIL tests/filesys/base/lg-full\nFAIL tests/filesys/base/lg-random\nFAIL tests/filesys/base/lg-seq-block\nFAIL tests/filesys/base/lg-seq-random\nFAIL tests/filesys/base/sm-create\nFAIL tests/filesys/base/sm-full\nFAIL tests/filesys/base/sm-random\nFAIL tests/filesys/base/sm-seq-block\nFAIL tests/filesys/base/sm-seq-random\nFAIL tests/filesys/base/syn-read\nFAIL tests/filesys/base/syn-remove\nFAIL tests/filesys/base/syn-write\n34 of 80 tests failed.\n</code></pre>\n<h1>참고</h1>\n<p>핀토스 공식 매뉴얼 <a href=\"https://web.stanford.edu/class/cs140/projects/pintos/pintos.pdf\">https://web.stanford.edu/class/cs140/projects/pintos/pintos.pdf</a></p>\n<p>한양대학교 핀토스 ppt <a href=\"https://oslab.kaist.ac.kr/wp-content/uploads/esos_files/courseware/undergraduate/PINTOS/Pintos_all.pdf\">https://oslab.kaist.ac.kr/wp-content/uploads/esos_files/courseware/undergraduate/PINTOS/Pintos_all.pdf</a></p>\n<p>어떤 선배님의 네이버 블로그\n<a href=\"https://m.blog.naver.com/adobeillustrator/220843740425\">https://m.blog.naver.com/adobeillustrator/220843740425</a></p>",
    "excerpt": "1. 본격적인 프로젝트 시작\n이번 과제는 시스템 콜 핸들러와 시스템 콜 일부가 작동하도록 하는 것이다.\n먼저 pintos 폴더의 src/userprog 와 src/examples 디렉토리에서 make를 실행한 후 src/userprog 디렉토리에서 다음 커맨드를 실행해 본다.\npintos --filesys-size=2 -p ../examples/echo -a echo -- -f -q run 'echo x'\n\n원래는 echo x를 실행하면 x가 출력되어야 하지만,",
    "headingTree": [
      {
        "title": "1. 본격적인 프로젝트 시작",
        "url": "#1-본격적인-프로젝트-시작",
        "items": []
      },
      {
        "title": "2. argument passing",
        "url": "#2-argument-passing",
        "items": [
          {
            "title": "2.1 분석",
            "url": "#21-분석",
            "items": []
          },
          {
            "title": "2.2 실행 파일 이름 수정",
            "url": "#22-실행-파일-이름-수정",
            "items": []
          },
          {
            "title": "2.3 유저 스택을 호출 규약에 맞게 구성",
            "url": "#23-유저-스택을-호출-규약에-맞게-구성",
            "items": [
              {
                "title": "2.3.1 스택에 인자 넣기",
                "url": "#231-스택에-인자-넣기",
                "items": []
              }
            ]
          }
        ]
      },
      {
        "title": "3. 시스템 콜 핸들러",
        "url": "#3-시스템-콜-핸들러",
        "items": [
          {
            "title": "3.1 주소 유효성 검사",
            "url": "#31-주소-유효성-검사",
            "items": []
          },
          {
            "title": "3.2 시스템 콜 구현",
            "url": "#32-시스템-콜-구현",
            "items": [
              {
                "title": "3.2.1 halt",
                "url": "#321-halt",
                "items": []
              },
              {
                "title": "3.2.2 exit",
                "url": "#322-exit",
                "items": []
              },
              {
                "title": "3.2.3 exec",
                "url": "#323-exec",
                "items": []
              },
              {
                "title": "3.2.4 wait",
                "url": "#324-wait",
                "items": []
              },
              {
                "title": "3.2.5 read",
                "url": "#325-read",
                "items": []
              },
              {
                "title": "3.2.6 write",
                "url": "#326-write",
                "items": []
              }
            ]
          },
          {
            "title": "3.3 시험해 보기",
            "url": "#33-시험해-보기",
            "items": []
          },
          {
            "title": "3.4 페이지 폴트 디버깅",
            "url": "#34-페이지-폴트-디버깅",
            "items": []
          }
        ]
      },
      {
        "title": "4. Wait 구현하기",
        "url": "#4-wait-구현하기",
        "items": [
          {
            "title": "4.1 프로젝트 계층 구조 구현",
            "url": "#41-프로젝트-계층-구조-구현",
            "items": []
          },
          {
            "title": "4.2 process_wait 구현",
            "url": "#42-process_wait-구현",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 11,
      "wordCount": 2915
    },
    "url": "/posts/pintos-2",
    "thumbnail": {
      "local": "/static/pintos_exec-5ddbaeb8.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-pintos_exec-5ddbaeb8-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAIAAAA8r+mnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAb0lEQVR4nAFkAJv/AC4eHFNGRTEjIi8iIk9CPx4CAFlHRv///wCXjo1PPDtcSklzY2JJNzWPgH91Y2LAubYAi39/KxoZTjs7ZldWPy0saVxYGQgIXE5PANjU1PHz8/Hw8NDLy/r6+tTQzra9wOLn6ssuLLdIycMsAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "pintos-1",
    "title": "서강대학교 핀토스 - project 0",
    "date": "2022-11-11T00:00:00Z",
    "description": "핀토스를 실행해 보자",
    "tags": [
      "CS"
    ],
    "html": "<h1>1. 핀토스 시작</h1>\n<p>운영체제 과제로 핀토스가 나왔다. 프로젝트 0은 핀토스를 설치하고 간단한 커맨드를 실행시켜 보는 것이다. 제공된 ppt에서 시키는 대로 하면 된다.</p>\n<p>핀토스 실행에 필요한 QEMU등은 cspro에서 제공하므로 따로 설치할 필요가 없다. 따라서 제공된 pintos_modified.tar.gz 파일을 받아서 압축을 해제하는 것부터 시작한다.</p>\n<pre><code>tar -xvzf pintos_modified.tar.gz\n</code></pre>\n<p>그리고 <code>.bashrc</code>파일을 이용해서 환경 변수를 추가해 줘야 한다. <code>.bashrc</code>파일은 <code>~/</code>디렉토리에 존재하므로 <code>vi ~/.bashrc</code>로 열어서 다음과 같이 추가해 준다.</p>\n<pre><code>export PATH=/sogang/under/cseXXXXXXXX/pintos/src/utils:$PATH\n</code></pre>\n<p>여기서 <code>cseXXXXXXXX</code>는 자신의 학번이다. 그리고 <code>pintos/src/utils</code>는 핀토스를 실행하기 위한 스크립트가 있는 디렉토리이다. 이렇게 추가하고 나면 <code>source ~/.bashrc</code>를 실행해서 적용시켜 준다.</p>\n<p>그리고 <code>cd ~/pintos/src/threads</code>로 디렉토리를 이동한 후 <code>make</code>를 실행하면 핀토스의 스레드 부분이 컴파일된다.</p>\n<p>그 다음 <code>src/threads</code>로 이동하여 다음 커맨드를 실행한다.</p>\n<pre><code>pintos -v -- -q run alarm-multiple\n</code></pre>\n<p>핀토스가 실행되고 <code>alarm-multiple</code> 명령이 실행된다.</p>\n<p>이때 핀토스를 실행시키는 시뮬레이터에 몇 가지 옵션을 줄 수 있고 이는 핀토스 커널에 전달되는 명령과 구분되어야 한다. 이 분리를 <code>--</code> 가 담당한다. 따라서 핀토스 명령의 형태는 다음과 같아진다. <code>pintos 핀토스 시뮬레이터 옵션 -- 핀토스 커널 argunemt ...</code> 이때 어떤 옵션이 가능한지는 <code>pintos</code> 명령으로 볼 수 있다. 예를 들어 -v는 VGA 디스플레이를 끄는 옵션이다.</p>\n<p>그리고 위 명령 중 -q는 <code>--</code> 뒤에 있으므로 핀토스 커널에 전달하는 argument인데 출력이 끝나면 핀토스를 종료하라는 옵션이다.</p>",
    "excerpt": "1. 핀토스 시작\n운영체제 과제로 핀토스가 나왔다. 프로젝트 0은 핀토스를 설치하고 간단한 커맨드를 실행시켜 보는 것이다. 제공된 ppt에서 시키는 대로 하면 된다.\n핀토스 실행에 필요한 QEMU등은 cspro에서 제공하므로 따로 설치할 필요가 없다. 따라서 제공된 pintos_modified.tar.gz 파일을 받아서 압축을 해제하는 것부터 시작한다.\ntar -xvzf pintos_modified.tar.gz\n\n그리고 .bashrc파일을 이용해서 환경 변수를 ",
    "headingTree": [
      {
        "title": "1. 핀토스 시작",
        "url": "#1-핀토스-시작",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 54
    },
    "url": "/posts/pintos-1",
    "thumbnail": {
      "local": "/thumbnails/pintos-1-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-pintos-1-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAeElEQVR4nGNYunSpubm5srJyRESEm5ubhobGtm3b/v//z9DW1sbJyWlv7+Dj43MQDJ4+fQqSWLRoUUxMTG9v74ULF/4jAYYvX768fPny7du3v2EAKnH77t1bt27du3fvw4cPKDpmzl0wbfqMpUuXXr58+f///3AdAG53bIy+a5eTAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "pintos-3",
    "title": "서강대학교 핀토스 - project 2",
    "date": "2022-11-14T00:00:00Z",
    "description": "핀토스 프로젝트 2 - User Program 2",
    "tags": [
      "CS"
    ],
    "html": "<h1>1. 프로젝트 개요</h1>\n<p>이번 프로젝트에서는 파일 시스템과 관련된 시스템 콜을 구현한다. create, remove, open, close, filesize, read, write, seek, tell을 구현하면 된다. 이 대부분은 이미 구현되어 있는 함수들을 이용할 수 있다.</p>\n<p>하지만 이를 구현하기 위해서는 파일 디스크립터를 구현해야 한다.</p>\n<h1>2. 파일 디스크립터 구현</h1>\n<p>운영체제는 파일 디스크립터를 통해서 파일에 접근한다. 이때 파일이란 디스크에서의 입출력이나 모니터, 키보드 등 어떤 외부 디바이스일 수 있다. 그리고 파일 디스크립터란 이 파일들을 정수로 표현한 것이다. 파일 디스크립터는 0부터 시작해서 2까지는 표준 입출력을 위한 것이고, 3부터는 사용자가 open을 통해서 열 수 있는 파일들이다.</p>\n<p>그리고 파일에 접근할 때는 파일 디스크립터 테이블을 이용한다. 예를 들어 3이라는 파일 디스크립터를 가진 파일이 있다면, 파일 디스크립터 테이블에는 3과 해당하는 파일에 대한 매칭이 저장되어 있다. 우리는 이 파일 디스크립터 테이블을 스레드 구조체에 추가해야 한다.</p>\n<h2>2.1 파일 디스크립터와 관련 기본 함수</h2>\n<p>핀토스 매뉴얼에 보면 파일 디스크립터는 최대 128까지만 있으면 된다고 하므로 크기 130의 배열을 만들어서 사용하면 된다. 먼저 편의를 위해 이를 매크로로 정의한다.</p>\n<pre><code class=\"language-c\">#define FDTABLE_SIZE 130\n</code></pre>\n<p>그리고 파일 디스크립터 테이블을 스레드 구조체에 추가한다.</p>\n<pre><code class=\"language-c\">// src/threads/thread.h 의 thread 구조체\n#ifdef USERPROG\n    /* Owned by userprog/process.c. */\n    uint32_t *pagedir;                  /* Page directory. */\n    // parent process descriptor\n    struct thread* parent_thread;\n\n    /* each structure\n   that is a potential list element must embed a struct list_elem\n   member. */\n    /* child list element */\n    struct list_elem child_thread_elem;\n    /* child list */\n    struct list child_threads;\n    /* 프로세스의 프로그램 메모리 적재 여부 */\n    bool load_flag;\n    /* 프로세스 종료 유무 확인 */\n    bool exit_flag;\n    /* exit semaphore, 자식 프로세스 종료 대기를 위한 세마포어 */\n    struct semaphore exit_sema;\n    /* load semaphore, 자식 프로세스 생성 대기 */\n    struct semaphore load_sema;\n    /* exit 호출 시 종료 상태 */\n    int exit_status;\n    /* file descriptor table */\n    struct file* fd_table[FDTABLE_SIZE];\n\n#endif\n</code></pre>\n<p>이제 파일 디스크립터 테이블을 초기화하는 함수를 만들어야 한다. 이 함수는 스레드가 생성될 때 호출되어야 한다. 그래서 스레드 초기화 함수인 init_thread를 다음과 같이 수정한다.</p>\n<pre><code class=\"language-c\">// src/threads/thread.c 의 init_thread 함수\nstatic void\ninit_thread (struct thread *t, const char *name, int priority)\n{\n  enum intr_level old_level;\n\n  ASSERT (t != NULL);\n  ASSERT (PRI_MIN &#x3C;= priority &#x26;&#x26; priority &#x3C;= PRI_MAX);\n  ASSERT (name != NULL);\n\n  memset (t, 0, sizeof *t);\n  t->status = THREAD_BLOCKED;\n  strlcpy (t->name, name, sizeof t->name);\n  t->stack = (uint8_t *) t + PGSIZE;\n  t->priority = priority;\n  t->magic = THREAD_MAGIC;\n\n  old_level = intr_disable ();\n  list_push_back (&#x26;all_list, &#x26;t->allelem);\n  intr_set_level (old_level);\n\n  #ifdef USERPROG\n  /* 자식 리스트 초기화 */\n  list_init(&#x26;(t->child_threads));\n  // push to the child list of the running thread\n  list_push_back(&#x26;(running_thread()->child_threads), &#x26;(t->child_thread_elem));\n  // 부모 프로세스 저장\n  t->parent_thread=running_thread();\n  sema_init(&#x26;(t->exit_sema), 0);\n  sema_init(&#x26;(t->load_sema), 0);\n  for(i=0;i&#x3C;FDTABLE_SIZE;i++){\n    t->fd_table[i]=NULL;\n  }\n  #endif\n}\n</code></pre>\n<p>그리고 한양대학교 핀토스 ppt에서 시키는 함수들을 구현한다. 먼저 파일 디스크립터를 생성하는 함수를 구현한다. 이 함수는 파일 객체를 파일 디스크립터 테이블에 추가하고 파일 디스크립터를 리턴한다.</p>\n<pre><code class=\"language-c\">// src/userprog/process.c 의 process_add_file 함수\nint process_add_file(struct file* f){\n  struct thread* t = thread_current();\n  int i;\n  for(i=3;i&#x3C;FDTABLE_SIZE;i++){\n    if(t->fd_table[i]==NULL){\n      t->fd_table[i]=f;\n      return i;\n    }\n  }\n  return -1;\n}\n</code></pre>\n<p>그리고 파일 디스크립터 값에 해당하는 파일 객체를 리턴하는 함수를 구현한다.</p>\n<pre><code class=\"language-c\">// src/userprog/process.c 의 process_get_file 함수\n// 파일 디스크립터에 대한 객체 주소 반환\nstruct file* process_get_file(int fd){\n  struct thread* t = thread_current();\n  if(fd&#x3C;3 || fd>=FDTABLE_SIZE){\n    return NULL;\n  }\n  return t->fd_table[fd];\n}\n</code></pre>\n<p>그리고 파일 디스크립터에 해당하는 파일 객체를 닫는 함수를 구현한다.</p>\n<pre><code class=\"language-c\">// src/userprog/process.c 의 process_close_file 함수\nvoid process_close_file(int fd){\n  struct thread* t = thread_current();\n  if(fd&#x3C;3 || fd>=FDTABLE_SIZE){\n    return;\n  }\n  // NULL인 파일을 닫을 수는 없다.\n  if(t->fd_table[fd]!=NULL){\n    file_close(t->fd_table[fd]);\n    t->fd_table[fd]=NULL;\n  }\n}\n</code></pre>\n<p>그리고 프로세스가 종료될 때는 프로세스에 열린 모든 파일을 닫도록 한다. 따라서 process_exit 함수를 다음과 같이 수정한다.</p>\n<pre><code class=\"language-c\">/* Free the current process's resources. */\nvoid\nprocess_exit (void)\n{\n  struct thread *cur = thread_current ();\n  uint32_t *pd;\n  int i;\n\n  /* new! */\n  for(i=3;i&#x3C;FDTABLE_SIZE;i++){\n    process_close_file(i);\n  }\n\n  /* Destroy the current process's page directory and switch back\n     to the kernel-only page directory. */\n  pd = cur->pagedir;\n  if (pd != NULL)\n    {\n      /* Correct ordering here is crucial.  We must set\n         cur->pagedir to NULL before switching page directories,\n         so that a timer interrupt can't switch back to the\n         process page directory.  We must activate the base page\n         directory before destroying the process's page\n         directory, or our active page directory will be one\n         that's been freed (and cleared). */\n      cur->pagedir = NULL;\n      pagedir_activate (NULL);\n      pagedir_destroy (pd);\n    }\n}\n</code></pre>\n<h2>2.2 파일 시스템 콜 구현</h2>\n<p>이제 파일 시스템 콜을 구현해 보자. 핀토스에서는 파일을 다루기 위한 함수들을 이미 몇 가지 제공하고 있다. 한양대 ppt에 자세히 설명되어 있는데 그것을 옮겨온다.</p>\n<p><img src=\"/static/file_api1-7c055b12.png\" alt=\"file_api1\">\n<img src=\"/static/file_api2-cdfe75a1.png\" alt=\"file_api2\"></p>\n<p>이제 이 함수들을 사용하여 파일 시스템 콜을 구현해 보자.</p>\n<h3>2.2.0 구현하기 전에</h3>\n<p>파일에 관한 시스템 콜을 구현하기 전에 고려해야 할 사항이 있다. 바로 파일에 대한 동시 접근을 막아야 한다는 점이다. 예를 들어서 A 파일을 내가 읽고 있는데 A 파일을 다른 프로세스에서 쓰기를 시도한다면 A 파일의 내용을 읽는 중에 내용이 바뀔 수 있다. 더 심한 것은 A 파일을 2개 이상의 프로세스가 동시에 쓰기를 시도할 경우 내용이 꼬일 수 있다.</p>\n<p>따라서 파일에 대한 동시 접근을 막을 lock을 사용해야 한다. reader-writer problem처럼 읽는 건 동시에 여러 프로세스에서 할 수 있고 쓰기는 하나의 프로세스에서만 가능하게 하는 방법도 있겠지만 여기서는 가장 단순하게 읽기든 쓰기든 한 번에 하나의 프로세스만 파일에 접근할 수 있도록 구현한다.</p>\n<p>핀토스에서는 이런 목적으로 <code>src/threads/synch.h</code>에 lock 구조체를 선언해 놓았다. 이를 사용하면 된다.</p>\n<p>먼저 <code>src/userprog/syscall.h</code>에 전역 변수로 <code>struct lock filesys_lock;</code>을 추가한다.</p>\n<p>그리고 <code>src/userprog/syscall.c</code>의 <code>syscall_init()</code>에서 <code>lock_init(&#x26;filesys_lock);</code>을 추가한다.</p>\n<pre><code class=\"language-c\">void\nsyscall_init (void)\n{\n  lock_init(&#x26;filesys_lock);\n  intr_register_int (0x30, 3, INTR_ON, syscall_handler, \"syscall\");\n}\n</code></pre>\n<p>앞으로 시스템 콜을 구현할 때 이 락을 이용한다. open, read, write 시스템 콜에서 사용될 것이다.</p>\n<h3>2.2.1 파일 열기</h3>\n<p>open 시스템 콜은 파일을 열고 그 파일의 디스크립터를 반환한다. 파일을 열 때 락을 거는 열고 나서 락을 푸는 것, 파일이 NULL일 때의 처리를 해야 한다. 파일의 디스크립터를 부여할 때는 아까 구현한 <code>process_add_file()</code>을 사용한다.</p>\n<pre><code class=\"language-c\">int open(const char* file){\n  int fd;\n  struct file* f;\n  if(file==NULL){exit(-1);}\n  lock_acquire(&#x26;filesys_lock);\n  f=filesys_open(file);\n  if(f==NULL){\n    lock_release(&#x26;filesys_lock);\n    return -1;\n  }\n  fd=process_add_file(f);\n  lock_release(&#x26;filesys_lock);\n  return fd;\n}\n</code></pre>\n<h3>2.2.2 파일 읽기</h3>\n<p>프로젝트 1에서는 read 시스템 콜을 stdin에 대해서만 구현하였다. 이번에는 파일에 대해서도 구현한다. 먼저 인자로 들어오는 fd가 음수일 때, stdout(==1)일 때 혹은 파일 디스크립터 테이블의 크기보다 클 때는 exit 시스템 콜을 호출해 준다. 그리고 락을 얻는다.</p>\n<p>그 후 fd가 stdin이면 프로젝트 1에서 했던 키보드 입력을 읽는 동작을 한다. 아니라면 fd를 파일 디스크립터로 갖는 파일의 내용을 읽는다. 이러한 동작이 끝나고 나면 락을 풀어 줘야 한다.</p>\n<pre><code class=\"language-c\">int read(int fd, void *buffer, unsigned int size){\n  int result;\n  uint8_t temp;\n  if(fd&#x3C;0 || fd==1 || fd>=FDTABLE_SIZE){exit(-1);}\n  lock_acquire(&#x26;filesys_lock);\n  if(fd==0){\n    for(result=0;(result&#x3C;size) &#x26;&#x26; (temp=input_getc());result++){\n      *(uint8_t*)(buffer+result)=temp;\n    }\n  }\n  else{\n    struct file* f=process_get_file(fd);\n    if(f==NULL){\n      lock_release(&#x26;filesys_lock);\n      exit(-1);\n    }\n    result=file_read(f, buffer, size);\n  }\n  lock_release(&#x26;filesys_lock);\n  return result;\n}\n</code></pre>\n<h3>2.2.3 파일 쓰기</h3>\n<p>write 시스템 콜은 파일에 쓰는 동작을 한다. 구현은 앞의 read 시스템 콜과 비슷하다. 인자로 들어오는 fd가 음수일 때, stdin(==0)일 때 혹은 파일 디스크립터 테이블의 크기보다 클 때는 exit 시스템 콜을 호출해 준다. 그리고 락을 얻는다.</p>\n<p>그 후 fd가 stdout이면 프로젝트 1에서 했던 화면 출력을 하는 동작을 한다. 아니라면 fd를 파일 디스크립터로 갖는 파일에 쓴다. 이러한 동작이 끝나고 나면 락을 풀어 줘야 한다.</p>\n<pre><code class=\"language-c\">int write(int fd, const void* buffer, unsigned int size){\n  int file_write_result;\n  struct file* f;\n  if(fd&#x3C;=0 || fd>=FDTABLE_SIZE){exit(-1);}\n  lock_acquire(&#x26;filesys_lock);\n  if(fd==1){\n    putbuf(buffer, size);\n    lock_release(&#x26;filesys_lock);\n    return size;\n  }\n  else{\n    f=process_get_file(fd);\n    if(f==NULL){\n      lock_release(&#x26;filesys_lock);\n      exit(-1);\n    }\n    file_write_result=file_write(f, buffer, size);\n    lock_release(&#x26;filesys_lock);\n    return file_write_result;\n  }\n}\n</code></pre>\n<h3>2.2.4 파일 생성</h3>\n<p>파일 생성은 다음과 같이 구현한다. filesys_create 함수를 그대로 사용하기만 하면 된다.</p>\n<pre><code class=\"language-c\">bool create(const char *file, unsigned initial_size){\n  // NULL 파일은 열 수 없다.\n  if(file==NULL){\n    exit(-1);\n  }\n  return filesys_create(file, initial_size);\n}\n</code></pre>\n<h3>2.2.5 파일 삭제</h3>\n<p>파일 삭제는 다음과 같이 구현한다. filesys_remove 함수를 그대로 사용하기만 하면 된다.</p>\n<pre><code class=\"language-c\">bool remove(const char *file){\n  // NULL 파일은 열 수 없다.\n  if(file==NULL){\n    exit(-1);\n  }\n  return filesys_remove(file);\n}\n</code></pre>\n<h3>2.2.6 파일 닫기</h3>\n<p>파일 닫기는 process_close_file 함수를 그대로 사용하기만 하면 된다.</p>\n<pre><code class=\"language-c\">void close(int fd){\n  process_close_file(fd);\n}\n</code></pre>\n<h3>2.2.7 파일 크기</h3>\n<p>파일 크기는 file_length 함수를 그대로 사용한다.</p>\n<pre><code class=\"language-c\">int filesize(int fd){\n  struct file* f=process_get_file(fd);\n  if(f==NULL){exit(-1);}\n  return file_length(f);\n}\n</code></pre>\n<h3>2.2.8 파일의 읽기/쓰기 위치 변경</h3>\n<p>파일의 편집 위치 변경은 file_seek 함수를 그대로 사용한다.</p>\n<pre><code class=\"language-c\">void seek(int fd, unsigned int position){\n  struct file* f=process_get_file(fd);\n  if(f==NULL){exit(-1);}\n  file_seek(f, position);\n}\n</code></pre>\n<h3>2.2.9 파일 위치 반환</h3>\n<p>파일 위치 반환은 file_tell 함수를 그대로 사용한다.</p>\n<pre><code class=\"language-c\">unsigned int tell(int fd){\n  struct file* f=process_get_file(fd);\n  if(f==NULL){exit(-1);}\n  return file_tell(f);\n}\n</code></pre>\n<h3>2.2.10 테스트</h3>\n<p>이제 이렇게 열심히 구현한 시스템 콜들을 시스템 콜 핸들러에 추가한다.</p>\n<pre><code class=\"language-c\">static void\nsyscall_handler (struct intr_frame *f UNUSED)\n{\n  switch(*(int32_t*)(f->esp)){\n    case SYS_HALT:                   /* Halt the operating system. */\n    halt();\n    break;\n    case SYS_EXIT:                   /* Terminate this process. */\n    check_address(f->esp+4);\n    exit(*(int*)(f->esp+4));\n    break;\n    case SYS_EXEC:                   /* Start another process. */\n    check_address(f->esp+4);\n    f->eax=exec((char*)*(uint32_t*)(f->esp+4));\n    break;\n    case SYS_WAIT:                   /* Wait for a child process to die. */\n    check_address(f->esp+4);\n    f->eax = wait(*(uint32_t*)(f->esp+4));\n    break;\n    case SYS_CREATE:                 /* Create a file. */\n    check_address(f->esp+4);\n    check_address(f->esp+8);\n    f->eax = create((char*)*(uint32_t*)(f->esp+4), *(uint32_t*)(f->esp+8));\n    break;\n    case SYS_REMOVE:                 /* Delete a file. */\n    check_address(f->esp+4);\n    f->eax = remove((char*)*(uint32_t*)(f->esp+4));\n    break;\n    case SYS_OPEN:                   /* Open a file. */\n    check_address(f->esp+4);\n    f->eax = open((char*)*(uint32_t*)(f->esp+4));\n    break;\n    case SYS_FILESIZE:               /* Obtain a file's size. */\n    check_address(f->esp+4);\n    f->eax = filesize(*(uint32_t*)(f->esp+4));\n    break;\n    case SYS_READ:                   /* Read from a file. */\n    check_address(f->esp+4);\n    check_address(f->esp+8);\n    check_address(f->esp+12);\n    f->eax = read((int)*(uint32_t*)(f->esp+4), (void*)*(uint32_t*)(f->esp+8),\n\t\t\t\t\t(unsigned)*(uint32_t*)(f->esp+12));\n    break;\n    case SYS_WRITE:                  /* Write to a file. */\n    //printf(\"write system call!\\n\");\n    check_address(f->esp+4);\n    check_address(f->esp+8);\n    check_address(f->esp+12);\n    f->eax = write((int)*(uint32_t*)(f->esp+4), (const void*)*(uint32_t*)(f->esp+8),\n\t\t\t\t\t(unsigned)*(uint32_t*)(f->esp+12));\n    break;\n    case SYS_SEEK:                   /* Change position in a file. */\n    check_address(f->esp+4);\n    check_address(f->esp+8);\n    seek((int)*(uint32_t*)(f->esp+4), (unsigned)*(uint32_t*)(f->esp+8));\n    break;\n    case SYS_TELL:                   /* Report current position in a file. */\n    check_address(f->esp+4);\n    f->eax = tell((int)*(uint32_t*)(f->esp+4));\n    break;\n    case SYS_CLOSE:                  /* Close a file. */\n    check_address(f->esp+4);\n    close(*(uint32_t*)(f->esp+4));\n    break;\n  }\n  //printf (\"system call! %d\\n\", *(int32_t*)(f->esp));\n  //thread_exit ();\n}\n</code></pre>\n<p>이제 대망의 make check을 해보면?? 안 된다..아예 프로세스가 끝나지 않는다.</p>\n<p>왜 안되나 열심히 찾아보았더니 프로젝트 1에서 <code>thread_schedule_tail</code> 함수의 <code>palloc_free_page</code>를 주석처리하여 프로세스 디스크립터 삭제를 막는 부분이 있었는데 그 부분을 처리한 게 다시 원래대로 돌아가 있었다. 따라서 이 부분을 주석처리하고 다시 make check을 한다.</p>\n<pre><code class=\"language-c\">// 수정된 thread_schedule_tail\nvoid\nthread_schedule_tail (struct thread *prev)\n{\n  struct thread *cur = running_thread ();\n\n  ASSERT (intr_get_level () == INTR_OFF);\n\n  /* Mark us as running. */\n  cur->status = THREAD_RUNNING;\n\n  /* Start new time slice. */\n  thread_ticks = 0;\n\n#ifdef USERPROG\n  /* Activate the new address space. */\n  process_activate ();\n#endif\n\n  /* If the thread we switched from is dying, destroy its struct\n     thread.  This must happen late so that thread_exit() doesn't\n     pull out the rug under itself.  (We don't free\n     initial_thread because its memory was not obtained via\n     palloc().) */\n  if (prev != NULL &#x26;&#x26; prev->status == THREAD_DYING &#x26;&#x26; prev != initial_thread)\n    {\n      ASSERT (prev != cur);\n      /* 이 부분을 주석처리해서 프로세스 디스크립터 삭제를 막는다. */\n      //palloc_free_page (prev);\n    }\n}\n</code></pre>\n<p>이제는 7개 빼고 모두 통과하는 것을 확인할 수 있다.</p>\n<pre><code>run: wait for child 2 of 10 returned 0 (expected 1): FAILED\npass tests/userprog/args-none\npass tests/userprog/args-single\npass tests/userprog/args-multiple\npass tests/userprog/args-many\npass tests/userprog/args-dbl-space\npass tests/userprog/sc-bad-sp\npass tests/userprog/sc-bad-arg\npass tests/userprog/sc-boundary\npass tests/userprog/sc-boundary-2\npass tests/userprog/sc-boundary-3\npass tests/userprog/halt\npass tests/userprog/exit\npass tests/userprog/create-normal\npass tests/userprog/create-empty\npass tests/userprog/create-null\npass tests/userprog/create-bad-ptr\npass tests/userprog/create-long\npass tests/userprog/create-exists\npass tests/userprog/create-bound\npass tests/userprog/open-normal\npass tests/userprog/open-missing\npass tests/userprog/open-boundary\npass tests/userprog/open-empty\npass tests/userprog/open-null\npass tests/userprog/open-bad-ptr\npass tests/userprog/open-twice\npass tests/userprog/close-normal\npass tests/userprog/close-twice\npass tests/userprog/close-stdin\npass tests/userprog/close-stdout\npass tests/userprog/close-bad-fd\npass tests/userprog/read-normal\nFAIL tests/userprog/read-bad-ptr\npass tests/userprog/read-boundary\npass tests/userprog/read-zero\npass tests/userprog/read-stdout\npass tests/userprog/read-bad-fd\npass tests/userprog/write-normal\npass tests/userprog/write-bad-ptr\npass tests/userprog/write-boundary\npass tests/userprog/write-zero\npass tests/userprog/write-stdin\npass tests/userprog/write-bad-fd\npass tests/userprog/exec-once\npass tests/userprog/exec-arg\npass tests/userprog/exec-bound\npass tests/userprog/exec-bound-2\npass tests/userprog/exec-bound-3\npass tests/userprog/exec-multiple\npass tests/userprog/exec-missing\npass tests/userprog/exec-bad-ptr\npass tests/userprog/wait-simple\npass tests/userprog/wait-twice\npass tests/userprog/wait-killed\npass tests/userprog/wait-bad-pid\npass tests/userprog/multi-recurse\npass tests/userprog/multi-child-fd\nFAIL tests/userprog/rox-simple\nFAIL tests/userprog/rox-child\nFAIL tests/userprog/rox-multichild\npass tests/userprog/bad-read\npass tests/userprog/bad-write\npass tests/userprog/bad-read2\npass tests/userprog/bad-write2\npass tests/userprog/bad-jump\npass tests/userprog/bad-jump2\nFAIL tests/userprog/no-vm/multi-oom\npass tests/filesys/base/lg-create\npass tests/filesys/base/lg-full\npass tests/filesys/base/lg-random\npass tests/filesys/base/lg-seq-block\npass tests/filesys/base/lg-seq-random\npass tests/filesys/base/sm-create\npass tests/filesys/base/sm-full\npass tests/filesys/base/sm-random\npass tests/filesys/base/sm-seq-block\npass tests/filesys/base/sm-seq-random\nFAIL tests/filesys/base/syn-read\npass tests/filesys/base/syn-remove\nFAIL tests/filesys/base/syn-write\n7 of 80 tests failed.\n</code></pre>\n<p>실패한 테스트들을 하나하나 까볼 수도 있겠다. 하지만 그전에 할 수 있는 게 남았다. 한양대 ppt를 보면 <code>denying write to executable</code>이라는 챕터가 다음에 있다. 또한 학교 ppt에도 실행중인 파일에 데이터 쓰기를 막아야 한다는 내용이 있다. 이를 먼저 진행하자.</p>\n<h1>3. Denying Write to Executable</h1>\n<p>실행 중인 사용자 프로그램에 데이터를 쓰는 걸 방지해야 한다는 것은 당연하다. 프로그램이 실행 중일 땐 데이터 변경을 막아야 하며 프로그램이 종료된 상태일 때만 변경 가능하도록 해야 한다. 핀토스에 이미 구현되어 있는, 데이터 변경을 막는 함수들을 이용해서 이를 구현하자.</p>\n<p>먼저 현재 프로세스에서 실행 중인 파일을 저장하는 <code>struct file *exec_file</code>을 스레드에 추가한다.</p>\n<pre><code class=\"language-c\">// thread.h 의 thread 구조체 일부\n#ifdef USERPROG\n    /* Owned by userprog/process.c. */\n    uint32_t *pagedir;                  /* Page directory. */\n    // parent process descriptor\n    struct thread* parent_thread;\n\n    /* each structure\n   that is a potential list element must embed a struct list_elem\n   member. */\n    /* child list element */\n    struct list_elem child_thread_elem;\n    /* child list */\n    struct list child_threads;\n    /* 프로세스의 프로그램 메모리 적재 여부 */\n    bool load_flag;\n    /* 프로세스 종료 유무 확인 */\n    bool exit_flag;\n    /* exit semaphore, 자식 프로세스 종료 대기를 위한 세마포어 */\n    struct semaphore exit_sema;\n    /* load semaphore, 자식 프로세스 생성 대기 */\n    struct semaphore load_sema;\n    /* exit 호출 시 종료 상태 */\n    int exit_status;\n    /* file descriptor table */\n    struct file* fd_table[FDTABLE_SIZE];\n    /* new! 현재 실행중인 파일 */\n    struct file* exec_file;\n#endif\n</code></pre>\n<p>이제 <code>file_deny_write()</code>와 <code>file_allow_write</code>를 어떻게 사용할지는 한양대학교 ppt에 아주 친절하게 나와 있다. 그대로 하면 된다.</p>\n<p>먼저 load 함수에서 실행할 파일을 열 때 실행중인 파일을 설정하고 <code>file_deny_write()</code>를 호출한다.</p>\n<pre><code class=\"language-c\">bool\nload (const char *file_name, void (**eip) (void), void **esp)\n{\n  struct thread *t = thread_current ();\n  struct Elf32_Ehdr ehdr;\n  struct file *file = NULL;\n  off_t file_ofs;\n  bool success = false;\n  int i;\n  char command[200];\n  char* command_ptr;\n  char* command_file_name;\n\n  /* Allocate and activate page directory. */\n  t->pagedir = pagedir_create ();\n  if (t->pagedir == NULL)\n    goto done;\n  process_activate ();\n\n  // parse file name\n  strlcpy(command, file_name, 129);\n  command_file_name=strtok_r(command, \" \", &#x26;command_ptr);\n  /* Open executable file. */\n  file = filesys_open (command_file_name);\n  if (file == NULL)\n    {\n      printf (\"load: %s: open failed\\n\", command_file_name);\n      goto done;\n    }\n\n    /* 데이터 변경 예방 */\n    t->exec_file=file;\n    file_deny_write(file);\n\n  /* Read and verify executable header. */\n  if (file_read (file, &#x26;ehdr, sizeof ehdr) != sizeof ehdr\n      || memcmp (ehdr.e_ident, \"\\177ELF\\1\\1\\1\", 7)\n      || ehdr.e_type != 2\n      || ehdr.e_machine != 3\n      || ehdr.e_version != 1\n      || ehdr.e_phentsize != sizeof (struct Elf32_Phdr)\n      || ehdr.e_phnum > 1024)\n    {\n      printf (\"load: %s: error loading executable\\n\", file_name);\n      goto done;\n    }\n\n  /* Read program headers. */\n  file_ofs = ehdr.e_phoff;\n  for (i = 0; i &#x3C; ehdr.e_phnum; i++)\n    {\n      struct Elf32_Phdr phdr;\n\n      if (file_ofs &#x3C; 0 || file_ofs > file_length (file))\n        goto done;\n      file_seek (file, file_ofs);\n\n      if (file_read (file, &#x26;phdr, sizeof phdr) != sizeof phdr)\n        goto done;\n      file_ofs += sizeof phdr;\n      switch (phdr.p_type)\n        {\n        case PT_NULL:\n        case PT_NOTE:\n        case PT_PHDR:\n        case PT_STACK:\n        default:\n          /* Ignore this segment. */\n          break;\n        case PT_DYNAMIC:\n        case PT_INTERP:\n        case PT_SHLIB:\n          goto done;\n        case PT_LOAD:\n          if (validate_segment (&#x26;phdr, file))\n            {\n              bool writable = (phdr.p_flags &#x26; PF_W) != 0;\n              uint32_t file_page = phdr.p_offset &#x26; ~PGMASK;\n              uint32_t mem_page = phdr.p_vaddr &#x26; ~PGMASK;\n              uint32_t page_offset = phdr.p_vaddr &#x26; PGMASK;\n              uint32_t read_bytes, zero_bytes;\n              if (phdr.p_filesz > 0)\n                {\n                  /* Normal segment.\n                     Read initial part from disk and zero the rest. */\n                  read_bytes = page_offset + phdr.p_filesz;\n                  zero_bytes = (ROUND_UP (page_offset + phdr.p_memsz, PGSIZE)\n                                - read_bytes);\n                }\n              else\n                {\n                  /* Entirely zero.\n                     Don't read anything from disk. */\n                  read_bytes = 0;\n                  zero_bytes = ROUND_UP (page_offset + phdr.p_memsz, PGSIZE);\n                }\n              if (!load_segment (file, file_page, (void *) mem_page,\n                                 read_bytes, zero_bytes, writable))\n                goto done;\n            }\n          else\n            goto done;\n          break;\n        }\n    }\n\n  /* Set up stack. */\n  if (!setup_stack (esp))\n    goto done;\n\n  //printf(\"stack pointer before construct stack %p\\n\", *esp);\n  // construct stack\n  construct_stack(file_name, esp);\n  //printf(\"stack pointer %p\\n\", *esp);\n  /* Start address. */\n  *eip = (void (*) (void)) ehdr.e_entry;\n\n  success = true;\n\n done:\n  /* We arrive here whether the load is successful or not. */\n  file_close (file);\n  return success;\n}\n</code></pre>\n<p>그 다음 <code>process_exit()</code>에서 <code>file_allow_write()</code>를 호출해야 하는데, 이는 file_close 함수에서 호출된다. 이는 process_exit 함수에서 실행 중인 모든 파일에 대해 file_close를 호출하는 코드가 이미 있으니 괜찮다고 생각했다. 그래서 load만 저렇게 바꾸고 실행하면? 똑같이 80개 중 7개가 실패한다. 뭐가 문제일까?</p>\n<h2>3.1 디버깅</h2>\n<p>load 함수를 잘 보자. 맨 아래의 done: 은 파일 열기가 성공하든 실패하든 도달하는 지점이다. 그런데 여기서 file_close를 호출해 버리고 있다. 이러면 file_close에서 해당 파일에 file_allow_write를 하게 되므로 기껏 파일에 대해 file_deny_write를 한 의미가 없어진다. 따라서 load 함수에서는 file_close를 호출하지 않도록 바꿔야 한다. 따라서 done: 아래의 file_close를 주석처리한다.</p>\n<pre><code class=\"language-c\"> done:\n  /* We arrive here whether the load is successful or not. */\n  //file_close (file);\n  return success;\n</code></pre>\n<p>그리고 어쩐지 process_exit 함수에서 실행중인 모든 파일을 닫고 file_allow_write를 해주는 과정이 필요할 것 같아서 process_exit 함수도 다음과 같이 수정한다.</p>\n<pre><code class=\"language-c\">/* Free the current process's resources. */\nvoid\nprocess_exit (void)\n{\n  struct thread *cur = thread_current ();\n  uint32_t *pd;\n  int i;\n\n  // 실행중인 파일 닫기 (file_allow_write도 이루어짐)\n  file_close(cur->exec_file);\n  for(i=3;i&#x3C;FDTABLE_SIZE;i++){\n    process_close_file(i);\n  }\n  /* Destroy the current process's page directory and switch back\n     to the kernel-only page directory. */\n  pd = cur->pagedir;\n  if (pd != NULL)\n    {\n      /* Correct ordering here is crucial.  We must set\n         cur->pagedir to NULL before switching page directories,\n         so that a timer interrupt can't switch back to the\n         process page directory.  We must activate the base page\n         directory before destroying the process's page\n         directory, or our active page directory will be one\n         that's been freed (and cleared). */\n      cur->pagedir = NULL;\n      pagedir_activate (NULL);\n      pagedir_destroy (pd);\n    }\n  //printf(\"process exit\\n\");\n\n}\n</code></pre>\n<p>이렇게 하고 make check을 해본다. 와! 실패가 80개중 4개로 줄었다!</p>\n<h1>4. 남은 테스트 디버깅</h1>\n<h2>4.1 read-bad-ptr</h2>\n<p>현재 80개의 테스트 중 read-bad-ptr, multi-oom, syn-read, syn-write 4개가 실패한다. 가장 만만한 건 read-bad-ptr이므로 이것부터 해결해 보자. 왜 실패하는지는 <code>src/userprog/build/tests/userprog/read-bad-ptr.result</code> 파일을 보면 알 수 있다. 커널 패닉이 뜬다. 뭔가 안 좋은 포인터를 읽고 있는 것 같다.</p>\n<p>read 시스템 콜이 받는 buffer 인수에 check_address를 진행해 주면 해결된다. read 시스템 콜을 다음과 같이 수정한다.</p>\n<pre><code class=\"language-c\">int read(int fd, void *buffer, unsigned int size){\n  int result;\n  uint8_t temp;\n  if(fd&#x3C;0 || fd==1 || fd>=FDTABLE_SIZE){exit(-1);}\n  /* new! */\n  check_address(buffer);\n  lock_acquire(&#x26;filesys_lock);\n  if(fd==0){\n    for(result=0;(result&#x3C;size) &#x26;&#x26; (temp=input_getc());result++){\n      *(uint8_t*)(buffer+result)=temp;\n    }\n  }\n  else{\n    struct file* f=process_get_file(fd);\n    if(f==NULL){\n      lock_release(&#x26;filesys_lock);\n      exit(-1);\n    }\n    result=file_read(f, buffer, size);\n  }\n  lock_release(&#x26;filesys_lock);\n  return result;\n}\n</code></pre>\n<p>비슷한 주소 체크를 write 시스템 콜의 buffer 인수에도 해주었다.</p>\n<pre><code class=\"language-c\">int write(int fd, const void* buffer, unsigned int size){\n  int file_write_result;\n  struct file* f;\n  if(fd&#x3C;=0 || fd>=FDTABLE_SIZE){exit(-1);}\n  check_address(buffer);\n  lock_acquire(&#x26;filesys_lock);\n  if(fd==1){\n    putbuf(buffer, size);\n    lock_release(&#x26;filesys_lock);\n    return size;\n  }\n  else{\n    f=process_get_file(fd);\n    if(f==NULL){\n      lock_release(&#x26;filesys_lock);\n      exit(-1);\n    }\n    file_write_result=file_write(f, buffer, size);\n    lock_release(&#x26;filesys_lock);\n    return file_write_result;\n  }\n}\n</code></pre>\n<p>해결 완료. make check에서 syn-read, syn-write, multi-oom 3개 실패 상태가 되었다.</p>\n<h2>4.2 syn-read, syn-write</h2>\n<p>이번에는 syn-read 테스트가 실패한다. <code>src/userprog/build/tests/filesys/base/syn-read.result</code> 파일을 보면 뭔가 많이 로드하고 있는데 많이 실패하는 것 같다.</p>\n<p>지금까지 내가 뭘 안했는지 찾아보자. 한양대학교 ppt 97쪽에 보면 '부모 프로세스는 생성된 자식 프로세스의 프로그램이 메모리에 적재 될 때까지 대기'해야 한다고 나와 있다.</p>\n<p>생각해 보면 당연하다. 자식 프로세스가 아직 적재되고 있는데 부모 프로세스가 종료되어 버리면 안 된다. 이 문제 때문에 syn-read, syn-write 테스트 에서 load가 실패하는 게 아닌가 싶다. 이를 세마포어를 이용해 구현하자.</p>\n<p>예전에 프로젝트 1을 할 때 로드에 관한 세마포어를 스레드 구조체에 추가했었다. load_sema라는 이름으로. 따라서 이를 이용한다. 어떻게 해야 하는지는 한양대 ppt에 상세하게 나와 있다.</p>\n<p>먼저 exec 시스템 콜을 고치자.</p>\n<p><img src=\"/static/exec_syscall-cef50609.png\" alt=\"Exec\"></p>\n<pre><code class=\"language-c\">pid_t exec(const char *cmd_line){\n  tid_t tid;\n  // 자식 프로세스 생성\n  tid=process_execute(cmd_line);\n  /* 자식 프로세스가 문제없이 생성되었으면 그 자식 프로세스가 메모리에 적재될 때까지 대기한다 */\n  if(tid!=-1){\n    sema_down(&#x26;(get_child_process(tid)->load_sema));\n  }\n  return tid;\n}\n</code></pre>\n<p>그리고 메모리가 다 적재되면 load_sema를 up 시키는 부분을 추가한다. 이는 start_process 함수에 있다. 그 외에 한양대 ppt에서 요구하고 있는 load_flag의 값도 변경해준다. 이를 수행한 start_process 함수는 다음과 같다.</p>\n<pre><code class=\"language-c\">static void\nstart_process (void *file_name_)\n{\n  char *file_name = file_name_;\n  struct intr_frame if_;\n  bool success;\n\n  /* Initialize interrupt frame and load executable. */\n  memset (&#x26;if_, 0, sizeof if_);\n  if_.gs = if_.fs = if_.es = if_.ds = if_.ss = SEL_UDSEG;\n  if_.cs = SEL_UCSEG;\n  if_.eflags = FLAG_IF | FLAG_MBS;\n  // 프로그램 메모리 적재 성공 여부\n  success = load (file_name, &#x26;if_.eip, &#x26;if_.esp);\n  /* 메모리 적재 완료 시 부모 프로세스 다시 진행 (세마포어 이용) */\n  sema_up(&#x26;(thread_current()->load_sema));\n  /* If load failed, quit. */\n  palloc_free_page (file_name);\n  if (!success) {\n    /* 메모리 적재 실패 시 프로세스 디스크립터에 메모리 적재 실패 */\n    thread_current()->load_flag=false;\n    thread_exit ();\n  }\n  /* 메모리 적재 성공 시 프로세스 디스크립터에 메모리 적재 성공 */\n  thread_current()->load_flag=true;\n\n  /* Start the user process by simulating a return from an\n     interrupt, implemented by intr_exit (in\n     threads/intr-stubs.S).  Because intr_exit takes all of its\n     arguments on the stack in the form of a `struct intr_frame',\n     we just point the stack pointer (%esp) to our stack frame\n     and jump to it. */\n  asm volatile (\"movl %0, %%esp; jmp intr_exit\" : : \"g\" (&#x26;if_) : \"memory\");\n  NOT_REACHED ();\n}\n</code></pre>\n<p>이 작업을 수행해 주면 syn-write, syn-read가 모두 정상 동작한다. 이제 multi-oom 하나 남았다.</p>\n<h2>4.3 multi-oom</h2>\n<p>이제 테스트 단 하나 남았다. 먼저 multi-oom 테스트의 결과를 보자.</p>\n<pre><code>FAIL\nrun: crashed child should return -1.: FAILED\n</code></pre>\n<p>음..무슨 말인지 모르겠다. 뭔가 자식 프로세스가 충돌할 때 -1을 리턴해야 하는데 그게 안되는 것 같다. 참고에 있는 네이버 블로그에서 한 짓들을 먼저 해보자.</p>\n<p>강제 종료된 child list가 있는지 검사하여 process_wait으로 실패한 프로세스를 회수한다. 이는 앞에서 처리한 load_flag를 이용한다. load가 되지 못하고 종료되어 버린 프로세스를 기다려 주는 것이다.</p>\n<p>이때 주의할 점은 init_thread에서 스레드의 요소들을 초기화할 때 load_flag가 true로 초기화되어 있는지 확인해야 한다는 것이다. 이 기본값을 설정 안 해 놓아서 몇 시간 동안 디버깅을 했다.</p>\n<p>process_execute를 다음과 같이 수정한다.</p>\n<pre><code class=\"language-c\">tid_t\nprocess_execute (const char *file_name)\n{\n  char *fn_copy;\n  tid_t tid;\n\n  char file_name_copy[1000];\n  char* parsed_file_name;\n  char* save_ptr;\n  struct list_elem* elem;\n  struct thread* t;\n\n  /* Make a copy of FILE_NAME.\n     Otherwise there's a race between the caller and load(). */\n  fn_copy = palloc_get_page (0);\n  if (fn_copy == NULL)\n    return TID_ERROR;\n  strlcpy (fn_copy, file_name, PGSIZE);\n\n  // 첫 단어만 파싱\n  strlcpy(file_name_copy, file_name, strlen(file_name)+1);\n  parsed_file_name=strtok_r(file_name_copy, \" \", &#x26;save_ptr);\n\n  if(filesys_open(parsed_file_name)==NULL){return -1;}\n  /* Create a new thread to execute FILE_NAME. */\n  tid = thread_create (parsed_file_name, PRI_DEFAULT, start_process, fn_copy);\n  if (tid == TID_ERROR)\n    palloc_free_page (fn_copy);\n\n  for(elem=list_begin(&#x26;thread_current()->child_threads);elem!=list_end(&#x26;thread_current()->child_threads);elem=list_next(elem)){\n    t = list_entry(elem, struct thread, child_thread_elem);\n    if(t->load_flag==false){\n      return process_wait(tid);\n    }\n  }\n  return tid;\n}\n</code></pre>\n<p>또한 start_process에서 load에 실패했을 때 thread_exit() 대신 exit(-1)을 해줘야 한다. exit() 시스템 콜을 사용해서 프로세스를 종료함으로써 exit status를 저장해 놓아야 부모 프로세스가 자식 프로세스의 exit status를 확인할 수 있기 때문이다.(thread_exit()만 하면 종료 상태가 저장되지 않는다.)</p>\n<pre><code class=\"language-c\">// start_process 함수 일부 내용\n// 프로그램 메모리 적재 성공 여부\n  success = load (file_name, &#x26;if_.eip, &#x26;if_.esp);\n  /* 메모리 적재 완료 시 부모 프로세스 다시 진행 (세마포어 이용) */\n  sema_up(&#x26;(thread_current()->load_sema));\n  /* If load failed, quit. */\n  palloc_free_page (file_name);\n  if (!success) {\n    /* 메모리 적재 실패 시 프로세스 디스크립터에 메모리 적재 실패 */\n    thread_current()->load_flag=false;\n    exit(-1);\n  }\n  /* 메모리 적재 성공 시 프로세스 디스크립터에 메모리 적재 성공 */\n  thread_current()->load_flag=true;\n</code></pre>\n<p>이렇게 하면 오류 메시지가 바뀐다.</p>\n<pre><code>FAIL\nrun: wait returned -1.: FAILED\n</code></pre>\n<p>wait이 -1을 리턴했다고 한다. 자식 프로세스가 제대로 종료되지 않는다는 것이다. 그럼 multi-oom의 목적을 생각해 보자. 메모리 누수를 체크하는 것이다. 메모리 누수가 어디에서 나는 거지? free를 어디서 했던가?</p>\n<p>잘 생각해 보니 누수가 날 곳이 있다. 아까 thread_schedule_tail 함수에서 프로세스 디스크립터를 palloc_free_page로 삭제하는 것을 막지 않았던가? 이 부분에서 누수가 일어나는 것 같다. 따라서 free를 하면서도 자식 프로세스의 디스크립터를 삭제하지 않도록 수정해 줘야 한다. 이 또한 세마포어로 할 수 있다.</p>\n<p>이 작업은 다음과 같다. 먼저 스레드 구조체에 remove_sema를 추가한다.</p>\n<pre><code class=\"language-c\">/* 삭제될 때 부모의 자식 리스트에서 삭제하기 위해 메모리를 남겨두는 세마포어 */\nstruct semaphore remove_sema;\n</code></pre>\n<p>그리고 init_thread 함수에서 remove_sema를 0으로 초기화시켜 준다. thread_exit 함수에서 remove_sema를 down 시키고 process_wait 함수에서 자식 리스트에서 해당 프로세스가 삭제되면 다시 remove_sema를 up시킨다. 이렇게 고친 함수들은 다음과 같다.</p>\n<pre><code class=\"language-c\">void\nthread_exit (void)\n{\n  ASSERT (!intr_context ());\n\n#ifdef USERPROG\n  process_exit ();\n#endif\n\n  /* Remove thread from all threads list, set our status to dying,\n     and schedule another process.  That process will destroy us\n     when it calls thread_schedule_tail(). */\n  intr_disable ();\n  list_remove (&#x26;thread_current()->allelem);\n  sema_up(&#x26;(thread_current()->exit_sema));\n  // new!\n  sema_down(&#x26;(thread_current()->remove_sema));\n  thread_current ()->status = THREAD_DYING;\n  schedule ();\n  NOT_REACHED ();\n}\n</code></pre>\n<pre><code class=\"language-c\">int\nprocess_wait (tid_t child_tid UNUSED)\n{\n  struct thread* child_thread;\n  struct list_elem* elem;\n  int exit_status;\n\n  child_thread=get_child_process(child_tid);\n  // child thread not found\n  if(child_thread==NULL){\n    return -1;\n  }\n  // 자식 프로세스 종료까지 대기\n  sema_down(&#x26;(child_thread->exit_sema));\n  exit_status=child_thread->exit_status;\n  list_remove(&#x26;(child_thread->child_thread_elem));\n  // new!\n  sema_up(&#x26;(child_thread->remove_sema));\n  return exit_status;\n}\n</code></pre>\n<p>그리고 thread_schedule_tail의 palloc_free_page도 원래대로 복구한다.</p>\n<pre><code class=\"language-c\">void\nthread_schedule_tail (struct thread *prev)\n{\n  struct thread *cur = running_thread ();\n\n  ASSERT (intr_get_level () == INTR_OFF);\n\n  /* Mark us as running. */\n  cur->status = THREAD_RUNNING;\n\n  /* Start new time slice. */\n  thread_ticks = 0;\n\n#ifdef USERPROG\n  /* Activate the new address space. */\n  process_activate ();\n#endif\n\n  /* If the thread we switched from is dying, destroy its struct\n     thread.  This must happen late so that thread_exit() doesn't\n     pull out the rug under itself.  (We don't free\n     initial_thread because its memory was not obtained via\n     palloc().) */\n  if (prev != NULL &#x26;&#x26; prev->status == THREAD_DYING &#x26;&#x26; prev != initial_thread)\n    {\n      ASSERT (prev != cur);\n      /* 이 부분을 주석처리해서 프로세스 디스크립터 삭제를 막는다. */\n      palloc_free_page (prev);\n    }\n}\n</code></pre>\n<p>하지만 이렇게 해도 multi-oom은 전혀 잘될 기미가 보이지 않는다. 똑같은 에러 메시지가 뜬다. 일단 process_exit() 함수를 고친다. 참고에 쓰인 블로그에 보면, 부모 프로세스가 절대 자식 프로세스보다 먼저 죽으면 안된다고 한다. 따라서 process_exit() 함수에서 자식 프로세스가 존재하면 부모 프로세스를 죽이지 않고 대기하도록 한다.</p>\n<p>process_exit() 함수를 다음과 같이 수정한다.</p>\n<pre><code class=\"language-c\">/* Free the current process's resources. */\nvoid\nprocess_exit (void)\n{\n  struct thread *cur = thread_current ();\n  uint32_t *pd;\n  int i;\n  struct thread* child_thread;\n  struct list_elem* elem;\n\n  /* Destroy the current process's page directory and switch back\n     to the kernel-only page directory. */\n  pd = cur->pagedir;\n  if (pd != NULL)\n    {\n      /* Correct ordering here is crucial.  We must set\n         cur->pagedir to NULL before switching page directories,\n         so that a timer interrupt can't switch back to the\n         process page directory.  We must activate the base page\n         directory before destroying the process's page\n         directory, or our active page directory will be one\n         that's been freed (and cleared). */\n      cur->pagedir = NULL;\n      pagedir_activate (NULL);\n      pagedir_destroy (pd);\n    }\n\n  //printf(\"process exit\\n\");\n  for(elem=list_begin(&#x26;(thread_current()->child_threads)); elem!=list_end(&#x26;(thread_current()->child_threads)); elem=list_next(elem)){\n    child_thread=list_entry(elem, struct thread, child_thread_elem);\n    process_wait(child_thread->tid);\n  }\n  file_close(cur->exec_file);\n\n  for(i=3;i&#x3C;FDTABLE_SIZE;i++){\n    process_close_file(i);\n  }\n}\n</code></pre>\n<p>하지만 여전히 multi-oom은 되지 않는다. 한양대 ppt를 찬찬히 다시 뜯어보자.</p>\n<p>이전에 보았던 <code>exec</code>시스템 콜에 관한 ppt에서 뭔가 이상한 점을 발견했다.</p>\n<p><img src=\"/static/exec_syscall-cef50609.png\" alt=\"Exec_syscall\"></p>\n<p>자식 프로세스의 프로그램이 적재될 때까지 대기하는 건 이미 <code>load_sema</code>를 통해서 하고 있다. 그런데 프로그램 적재 실패 시 -1을 리턴하고 성공 시 자식 프로세스의 pid를 리턴해야 한다고 한다.</p>\n<p>원래는 그저 <code>get_child_process</code>의 결과가 널인지 체크해야 한다는 정도로 생각했다.</p>\n<p>하지만 잘 생각해 보니 그게 아니었다. 현재 start_process에서 load가 실패할 경우 exit(-1)을 한다. 하지만 이렇게 메모리에 적재 중인 자식 프로세스가 적재에 실패해서 종료될 경우 부모 프로세스에서는 자식 프로세스의 적재 실패를 알 수 없다. 위의 '적재 실패 시 -1을 리턴해 줘야 한다'는 것은 이를 처리해 줘야 한다는 말이었다.</p>\n<p>위에서 load_flag의 값에 대한 처리는 start_process 함수에서 해 주었으므로 우리는 그것을 사용해 주기만 하면 된다. exec() 시스템 콜을 다음과 같이 수정한다.</p>\n<pre><code class=\"language-c\">pid_t exec(const char *cmd_line){\n  tid_t tid;\n  struct thread* t;\n  // 자식 프로세스 생성\n  tid=process_execute(cmd_line);\n  t=get_child_process(tid);\n  // 생성에 성공 시 생성된 프로세스 pid 반환\n  if(t!=NULL){\n    // 자식 프로세스가 메모리에 적재될 때까지 대기\n    sema_down(&#x26;(t->load_sema));\n    //프로그램 적재 실패 시 -1 리턴\n    if(t->load_flag==false){\n      return -1;\n    }\n    // 적재 성공 시 자식 프로세스 pid 리턴\n    else{\n      return tid;\n    }\n  }\n  else{\n    return -1;\n  }\n}\n</code></pre>\n<p>이제 multi-oom도 잘 돌아간다. 모든 테스트가 통과된다.</p>\n<pre><code>- make check의 결과\npass tests/userprog/args-none\npass tests/userprog/args-single\npass tests/userprog/args-multiple\npass tests/userprog/args-many\npass tests/userprog/args-dbl-space\npass tests/userprog/sc-bad-sp\npass tests/userprog/sc-bad-arg\npass tests/userprog/sc-boundary\npass tests/userprog/sc-boundary-2\npass tests/userprog/sc-boundary-3\npass tests/userprog/halt\npass tests/userprog/exit\npass tests/userprog/create-normal\npass tests/userprog/create-empty\npass tests/userprog/create-null\npass tests/userprog/create-bad-ptr\npass tests/userprog/create-long\npass tests/userprog/create-exists\npass tests/userprog/create-bound\npass tests/userprog/open-normal\npass tests/userprog/open-missing\npass tests/userprog/open-boundary\npass tests/userprog/open-empty\npass tests/userprog/open-null\npass tests/userprog/open-bad-ptr\npass tests/userprog/open-twice\npass tests/userprog/close-normal\npass tests/userprog/close-twice\npass tests/userprog/close-stdin\npass tests/userprog/close-stdout\npass tests/userprog/close-bad-fd\npass tests/userprog/read-normal\npass tests/userprog/read-bad-ptr\npass tests/userprog/read-boundary\npass tests/userprog/read-zero\npass tests/userprog/read-stdout\npass tests/userprog/read-bad-fd\npass tests/userprog/write-normal\npass tests/userprog/write-bad-ptr\npass tests/userprog/write-boundary\npass tests/userprog/write-zero\npass tests/userprog/write-stdin\npass tests/userprog/write-bad-fd\npass tests/userprog/exec-once\npass tests/userprog/exec-arg\npass tests/userprog/exec-bound\npass tests/userprog/exec-bound-2\npass tests/userprog/exec-bound-3\npass tests/userprog/exec-multiple\npass tests/userprog/exec-missing\npass tests/userprog/exec-bad-ptr\npass tests/userprog/wait-simple\npass tests/userprog/wait-twice\npass tests/userprog/wait-killed\npass tests/userprog/wait-bad-pid\npass tests/userprog/multi-recurse\npass tests/userprog/multi-child-fd\npass tests/userprog/rox-simple\npass tests/userprog/rox-child\npass tests/userprog/rox-multichild\npass tests/userprog/bad-read\npass tests/userprog/bad-write\npass tests/userprog/bad-read2\npass tests/userprog/bad-write2\npass tests/userprog/bad-jump\npass tests/userprog/bad-jump2\npass tests/userprog/no-vm/multi-oom\npass tests/filesys/base/lg-create\npass tests/filesys/base/lg-full\npass tests/filesys/base/lg-random\npass tests/filesys/base/lg-seq-block\npass tests/filesys/base/lg-seq-random\npass tests/filesys/base/sm-create\npass tests/filesys/base/sm-full\npass tests/filesys/base/sm-random\npass tests/filesys/base/sm-seq-block\npass tests/filesys/base/sm-seq-random\npass tests/filesys/base/syn-read\npass tests/filesys/base/syn-remove\npass tests/filesys/base/syn-write\nAll 80 tests passed.\n</code></pre>\n<pre><code>make grade 결과\nSUMMARY BY TEST SET\n\nTest Set                                      Pts Max  % Ttl  % Max\n--------------------------------------------- --- --- ------ ------\ntests/userprog/Rubric.functionality           108/108  35.0%/ 35.0%\ntests/userprog/Rubric.robustness               88/ 88  25.0%/ 25.0%\ntests/userprog/no-vm/Rubric                     1/  1  10.0%/ 10.0%\ntests/filesys/base/Rubric                      30/ 30  30.0%/ 30.0%\n--------------------------------------------- --- --- ------ ------\nTotal                                                 100.0%/100.0%\n</code></pre>\n<p>아..매우 기분이 좋다....하지만 이제 곧 프로젝트 3이 나올 것이다..</p>\n<h1>참고</h1>\n<p>핀토스 공식 매뉴얼 <a href=\"https://web.stanford.edu/class/cs140/projects/pintos/pintos.pdf\">https://web.stanford.edu/class/cs140/projects/pintos/pintos.pdf</a></p>\n<p>한양대학교 핀토스 ppt <a href=\"https://oslab.kaist.ac.kr/wp-content/uploads/esos_files/courseware/undergraduate/PINTOS/Pintos_all.pdf\">https://oslab.kaist.ac.kr/wp-content/uploads/esos_files/courseware/undergraduate/PINTOS/Pintos_all.pdf</a></p>\n<p>multi-oom 오류를 해결할 때 부모 프로세스가 자식 프로세스보다 먼저 죽으면 안된다는 것을 알려준 블로그 <a href=\"https://for-development.tistory.com/20\">https://for-development.tistory.com/20</a></p>\n<p>서강대 핀토스를 한다면 모두가 보았을 네이버 블로그 글 <a href=\"https://m.blog.naver.com/adobeillustrator/220857007737\">https://m.blog.naver.com/adobeillustrator/220857007737</a></p>",
    "excerpt": "1. 프로젝트 개요\n이번 프로젝트에서는 파일 시스템과 관련된 시스템 콜을 구현한다. create, remove, open, close, filesize, read, write, seek, tell을 구현하면 된다. 이 대부분은 이미 구현되어 있는 함수들을 이용할 수 있다.\n하지만 이를 구현하기 위해서는 파일 디스크립터를 구현해야 한다.\n2. 파일 디스크립터 구현\n운영체제는 파일 디스크립터를 통해서 파일에 접근한다. 이때 파일이란 디스크에서의 입출력이나 모니터, ",
    "headingTree": [
      {
        "title": "1. 프로젝트 개요",
        "url": "#1-프로젝트-개요",
        "items": []
      },
      {
        "title": "2. 파일 디스크립터 구현",
        "url": "#2-파일-디스크립터-구현",
        "items": [
          {
            "title": "2.1 파일 디스크립터와 관련 기본 함수",
            "url": "#21-파일-디스크립터와-관련-기본-함수",
            "items": []
          },
          {
            "title": "2.2 파일 시스템 콜 구현",
            "url": "#22-파일-시스템-콜-구현",
            "items": [
              {
                "title": "2.2.0 구현하기 전에",
                "url": "#220-구현하기-전에",
                "items": []
              },
              {
                "title": "2.2.1 파일 열기",
                "url": "#221-파일-열기",
                "items": []
              },
              {
                "title": "2.2.2 파일 읽기",
                "url": "#222-파일-읽기",
                "items": []
              },
              {
                "title": "2.2.3 파일 쓰기",
                "url": "#223-파일-쓰기",
                "items": []
              },
              {
                "title": "2.2.4 파일 생성",
                "url": "#224-파일-생성",
                "items": []
              },
              {
                "title": "2.2.5 파일 삭제",
                "url": "#225-파일-삭제",
                "items": []
              },
              {
                "title": "2.2.6 파일 닫기",
                "url": "#226-파일-닫기",
                "items": []
              },
              {
                "title": "2.2.7 파일 크기",
                "url": "#227-파일-크기",
                "items": []
              },
              {
                "title": "2.2.8 파일의 읽기/쓰기 위치 변경",
                "url": "#228-파일의-읽기쓰기-위치-변경",
                "items": []
              },
              {
                "title": "2.2.9 파일 위치 반환",
                "url": "#229-파일-위치-반환",
                "items": []
              },
              {
                "title": "2.2.10 테스트",
                "url": "#2210-테스트",
                "items": []
              }
            ]
          }
        ]
      },
      {
        "title": "3. Denying Write to Executable",
        "url": "#3-denying-write-to-executable",
        "items": [
          {
            "title": "3.1 디버깅",
            "url": "#31-디버깅",
            "items": []
          }
        ]
      },
      {
        "title": "4. 남은 테스트 디버깅",
        "url": "#4-남은-테스트-디버깅",
        "items": [
          {
            "title": "4.1 read-bad-ptr",
            "url": "#41-read-bad-ptr",
            "items": []
          },
          {
            "title": "4.2 syn-read, syn-write",
            "url": "#42-syn-read-syn-write",
            "items": []
          },
          {
            "title": "4.3 multi-oom",
            "url": "#43-multi-oom",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 15,
      "wordCount": 4067
    },
    "url": "/posts/pintos-3",
    "thumbnail": {
      "local": "/static/file_api1-7c055b12.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-file_api1-7c055b12-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAj0lEQVR4nB3MSw6CMBQF0LsCo4lGgyTq/ldh4sSZ0chAwAECFeTztNJCpa2Bs4ADbB1spnCnmLuYrTBZwNlhuQZvBHsW0SOrqspaa7SxIwgpUsbiJGVZLqRs21aNUBPdwntevD6c//peD4zWBo0Uvh+EUcSbr1Sd6KRSaqgunrc/HE/nqx+EcZKURCVRTe8/eJxxmyjBhBIAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "react-docs",
    "title": "React 공식 문서를 읽으면서",
    "date": "2023-10-11T00:00:00Z",
    "description": "개편된 React 공식 문서를 읽어보았다",
    "tags": [
      "front",
      "react"
    ],
    "html": "<p>나는 지금은 레거시로 분류되어 있는 <a href=\"https://ko.legacy.reactjs.org/\">react 이전 공식문서</a>를 보면서 리액트를 처음 시작했었다. 아마 거기 있던 틱택토를 만들어 보는 문서부터 시작해서 조금 보다가 <a href=\"https://react.vlpt.us/\">벨로퍼트의 모던 리액트</a>로 넘어가서 투두리스트를 만들며 개발로 넘어왔던 걸로 기억한다.</p>\n<p>하지만 꽤 오래전 이야기이고 <a href=\"https://react.dev/\">지금은 리액트 공식문서가 개편되었다.</a> 그래서 거기의 문서들을 한번 읽어 보면서 몰랐던 부분들만 간략히 정리해본다.</p>\n<h1>1. JSX</h1>\n<p>HTML을 JSX로 많이 바꿔야 한다면 <a href=\"https://transform.tools/html-to-jsx\">온라인 컨버터를 쓸 수 있다.</a></p>\n<p>jsx는 HTML보다 엄격하다. <code>&#x3C;br /></code>같이 무조건 태그를 닫아야 하고 여러 JSX 태그를 리턴할 수 없다. 이는 JSX가 사실 JS이기 때문으로 JS 함수가 여러 값을 리턴할 수 없는 것과 같다.</p>\n<h1>2. 리액트 훅</h1>\n<p><code>use</code>로 시작하는 함수들은 리액트에서 훅이라고 불리는데 이 훅들은 컴포넌트 코드 혹은 다른 훅(아마도 커스텀 훅)의 최상위에서만 호출되어야 한다. 즉 훅을 조건문이나 반복문 내에서 바로 사용하는 건 불가능하다. 그럴 경우 새로운 컴포넌트를 만들어서 해야 한다.</p>\n<p>리액트에서 제공하는 <code>useState</code>같은 훅들도 있는데 사용자는 이들을 조합해서 새로운 훅을 만들 수 있다. 이런 훅들을 커스텀 훅이라고 부른다.</p>\n<h1>3. lifting state</h1>\n<p>여러 개의 자식 컴포넌트에서 같은 상태를 관리한다면 부모 컴포넌트에 state를 두고 props로 자식 컴포넌트에 상태를 내려 주는 게 공식 문서에서도 권장되고 있다. 이를 lifting state라고 부른다. 이렇게 하면 자식 컴포넌트들이 동기화된 상태를 쉽게 유지할 수 있다.</p>\n<h1>4. 리액트로 설계하기</h1>\n<p>리액트로 UI를 짠다면 먼저 UI를 컴포넌트 단위로 쪼갠 다음 각 컴포넌트에서 보여주어야 할 상태들을 생각할 것이다. 그리고 컴포넌트들 간에 어떤 데이터가 어떻게, 어디서 어디까지 흐를지를 설계하게 된다.</p>\n<h2>4.1. 컴포넌트 나누기</h2>\n<p>컴포넌트를 나눌 때는 단일 책임 원칙을 따라서 한 역할을 하는 부분을 컴포넌트로 빼거나, CSS를 기반으로 클래스 셀렉터를 잘 쓸 수 있도록 컴포넌트를 나눌 수 있다.</p>\n<p>디자인 구성을 생각해서 나누는 것도 좋다. 그러나 UI와 데이터 모델은 보통 같이 가기 때문에 데이터가 잘 짜여 있다면 컴포넌트를 그에 따라 나누는 것은 어렵지 않다.</p>\n<h2>4.2. 상태 관리하기</h2>\n<p>사이트의 구조 설계가 끝났다면 컴포넌트의 정적 구조는 다 잡혀 있을 것이다. 그러면 앱이 가져야 할 상태를 최소한으로 설계해야 한다. 최소한으로.</p>\n<p>예를 들어서 배열이 state로 저장되어 있다면 배열의 길이는 state로부터 계산될 수 있으므로 상태로 존재하면 안된다. 혹은 불변의 값도 상태로 존재하면 안된다. state는 사용자와의 상호작용을 위해 존재하는 것이다.</p>\n<p>이렇게 최소한의 상태를 구상하고 나면 해당 상태들이 어떤 컴포넌트에 state로 저장되어야 하는지도 생각해야 한다.</p>\n<h1>3. key props</h1>\n<p>JS의 배열 메서드인 <code>.map(item, index)</code>를 써서 배열에 들어 있는 요소들을 컴포넌트로 렌더링할 때 <code>key</code>라는 각 컴포넌트별로 고유한 값을 넣어줘야 한다. 이는 리액트가 각 컴포넌트를 보고 무엇이 바뀌었는지를 감지하고 어떤 것을 리렌더링할지 결정할 수 있게 하는, 컴포넌트의 고유한 아이디 같은 것이다.</p>\n<pre><code class=\"language-jsx\">const listItems = numbers.map((number) =>\n  &#x3C;li key={number}>\n    {number}\n  &#x3C;/li>\n);\n</code></pre>\n<p>리스트가 리렌더링되면 리액트는 이전의 리스트와 업데이트된 리스트의 key값을 가지고 원소들을 비교한다.</p>\n<p>그래서 업데이트된 리스트가 이전에 없었던 key를 가지고 있다면 해당 key를 위한 컴포넌트를 만든다. 그리고 이전에 있었던 key가 업데이트된 리스트에 없다면 해당 key를 가진 컴포넌트를 제거한다. 만약 key가 이전 리스트에도, 업데이트된 리스트에도 있다면 해당 key에 대응되는 컴포넌트를 업데이트하거나 이동시킨다.</p>\n<p>즉 key는 리액트가 각 컴포넌트의 고유값을 알려주고 리렌더링될 때 어떤 컴포넌트가 추가되고, 제거되고, 업데이트되는지를 알려주는 역할을 한다.</p>\n<p>key는 그냥 props처럼 보이지만 특별하고 reserved된 속성이며 리액트는 내부적으로 key 속성을 사용해서 어떤 컴포넌트를 업데이트할지 결정한다.</p>\n<p>따라서 동적인 리스트를 렌더링할 때 적당한 key를 할당하는 것은 매우 중요하다. 예를 들어서 배열의 인덱스를 key로 쓰는 것은 좋지 않다.(만약 key를 따로 지정하지 않으면 리액트는 에러를 발생시키며 자동적으로 배열의 인덱스를 key로 사용한다.)</p>\n<p>key가 바뀌면 리액트가 컴포넌트를 제거하고 새로 만드는데 배열의 인덱스는 배열 편집에 따라 너무 쉽게 바뀌는 값이기 때문이다. 반면 배열 원소마다 가지고 있는 어떤 고유한 값을 key로 쓴다면 배열에서 편집된 원소에 대응되는 컴포넌트만 업데이트할 수 있다.</p>\n<p>그리고 key는 당연히 전역적으로 유일할 필요는 없고 컴포넌트와 그 형제(sibling)들 사이에서만 유일하면 된다.</p>\n<h1>4. 리액트 프레임워크</h1>\n<p>create-react-app이나 vite를 통한 생성처럼 리액트 프로젝트를 간단히 시작하게 해주는 보일러플레이트도 많다. 하지만 리액트 프로젝트를 하다 보면 흔히 필요해지는 라우팅이나 데이터 페칭, HTML 생성같은 기능들을 포함한 여러 프레임워크들도 있다.</p>\n<p>대표적으로는 이 블로그를 만든 NextJS가 있다. 그리고 비슷한 풀스택 리액트 프레임워크인 <a href=\"https://remix.run/\">Remix</a>, 정적 사이트 생성기로 유명한 <a href=\"https://www.gatsbyjs.com/\">Gatsby</a>, 리액트 네이티브를 지원하는 <a href=\"https://expo.dev/\">Expo</a> 등이 있다. NextJS는 Vercel, Gatsby는 Netlify에 의해서 관리된다.</p>\n<h2>4.1. 리액트에서 프레임워크 사용을 권장하는 이유</h2>\n<p>프레임워크 없이 리액트를 사용하는 것도 가능하다. 리액트는 원래 <code>render</code>등을 통한 점진적인 마이그레이션이 가능하다는 것이 장점인 라이브러리였다. 하지만 만약 페이지 전부를 리액트로 구축하려 한다면 프레임워크를 쓰는 것이 좋다.</p>\n<p>개발을 하다 보면 라우팅이나 데이터 페칭, 프리로딩 등을 구현하거나 라이브러리를 통해서 환경을 구성해야 할 때가 많다. 정적 HTML 빌드 등을 원할 수도 있다. 이런 것들을 직접 구현하려면 많은 시간과 노력이 들어가고 라이브러리를 쓰려면 라이브러리를 쓰는 방법을 익혀야 한다. 또한 그렇게 스스로 환경을 구성했다 해도 다른 사람의 도움을 받기 쉽지 않다. 사람마다 구성해 본 환경이 다르기 때문이다.</p>\n<p>하지만 프레임워크를 쓰면 이런 것들을 이미 구성해 놓았기 때문에 빠르게 개발을 시작할 수 있다. 또한 오류가 생겨도 프레임워크의 커뮤니티를 통해서 도움을 받을 수 있다.</p>\n<h2>4.2. 프레임워크와 리액트</h2>\n<p>리액트 팀은 몇몇 유명한 리액트 프레임워크 개발자들과 협력하고 있다. 예를 들어 <a href=\"https://react.dev/blog/2023/03/22/react-labs-what-we-have-been-working-on-march-2023#react-server-components\">리액트 서버 컴포넌트</a>와 같은 리액트 피쳐들에 대해서 Nextjs와 같은 리액트 프레임워크 개발자들과 의견을 나누고 있다.</p>\n<p><a href=\"https://nextjs.org/docs\">nextJS 앱 라우터 공식문서</a>에서 이런 서버 컴포넌트를 미리 사용해볼 수 있다. 서버 컴포넌트와 Suspense 같은 것들은 리액트 피쳐지만 리액트에 바로 적용하기에는 무리가 있기 때문에 Nextjs에서 먼저 구현되었다.</p>\n<h2>4.3. 에디터 설정</h2>\n<p><a href=\"https://react.dev/learn/editor-setup\">VSCode 설정시 도움될 만한 공식문서 일부</a></p>\n<h1>5. 기존 프로젝트에 리액트 더하기</h1>\n<p>지금은 CRA 등의 리액트 보일러플레이트의 등장으로 모든 프로젝트를 처음부터 리액트로 짜는 것이 당연하게 여겨진다. 하지만 리액트는 원래 점진적인 마이그레이션이 가능하다는 것이 강점이었다. 당연히 기존 프로젝트에 리액트를 조금씩 더해 가는 것도 가능하다.</p>\n<p>일부 페이지를 리액트로 구성하는 것, 그리고 개별 페이지의 일부를 리액트 컴포넌트로 렌더링하는 것 2가지 방법이 있다.</p>\n<h2>5.1. 리액트 페이지를 더하기</h2>\n<p>루비 온 레일즈 같은, 다른 서버 기술로 만들어진 페이지가 있다고 하자. <code>witch.com</code>이라고 하자. 여기에 특정 라우트는 리액트로 만들고 싶다면 어떻게 해야 할까? 예를 들어 <code>/witch</code>로 시작하는 모든 라우트를 리액트로 만들고 싶다고 하자.</p>\n<p>그럼 먼저 해당 페이지를 리액트로 구성한다. nextjs같은 프레임워크를 쓸 수도 있다. 그리고 프레임워크의 설정 파일에서 base path로 해당 경로를 설정한다. 만약 <code>/witch</code>라는 경로를 리액트 페이지의 루트로 설정하고 싶다면 다음과 같이 설정한다.</p>\n<p><a href=\"https://nextjs.org/docs/app/api-reference/next-config-js/basePath\">NextJS라고 한다면 <code>next.config.js</code>를 편집해준다.</a> 다음과 같이 하면 <code>기존사이트URL/witch</code>가 리액트 페이지의 루트가 된다.</p>\n<pre><code class=\"language-js\">module.exports = {\n  basePath: '/witch',\n}\n</code></pre>\n<p>그리고 서버에서 <code>/witch</code>로 가는 모든 요청을 리액트 페이지로 보내도록 프록시 설정을 하면 된다.</p>\n<h2>5.2. 기존 페이지에 리액트 컴포넌트 더하기</h2>\n<p>기존 페이지의 일부 컴포넌트만 리액트로 쓸 수도 있다. 이는 Meta에서 꽤 오랫동안 리액트를 사용했던 방식이기도 하다.</p>\n<p>먼저 npm을 통해서 JSX 문법, 리액트 라이브러리 등을 설치한다. 그리고 원하는 곳에 리액트 컴포넌트를 만들어서 렌더링하면 된다.</p>\n<p>그리고 JS 모듈을 컴파일하는 설정도 해야 하는데 이는 Vite를 통해서 간단하게 할 수 있다. <a href=\"https://github.com/vitejs/awesome-vite#integrations-with-backends\">Vite를 여러 백엔드 프레임워크와 통합하는 코드를 모은 레포지토리도 있다.</a></p>\n<p>아무튼 먼저 리액트부터 설치한다.</p>\n<pre><code class=\"language-bash\">npm install react react-dom\n</code></pre>\n<p>그리고 다음과 같이 DOM 엘리먼트 내부에 <code>createRoot</code>와 <code>render</code>를 통해서 리액트 컴포넌트를 렌더링한다.</p>\n<pre><code class=\"language-js\">import {createRoot} from 'react-dom/client';\n\nconst root = document.getElementById('root');\n\ncreateRoot(root).render(&#x3C;App />);\n</code></pre>\n<p>이런 방식은 Vite의 Typescript 템플릿으로 처음 프로젝트를 생성했을 때 <code>main.tsx</code>의 구조에서도 비슷하게 볼 수 있다. <code>root</code>라는 id를 가진 태그를 찾고 그 내부에 <code>createRoot</code>를 통해서 리액트 컴포넌트를 렌더링하는 것이다.</p>\n<pre><code class=\"language-tsx\">ReactDOM.createRoot(document.getElementById('root') as HTMLElement).render(\n  &#x3C;React.StrictMode>\n    &#x3C;App />\n  &#x3C;/React.StrictMode>\n);\n</code></pre>\n<p>물론 이런 동작은 기존 앱의 어떤 태그에도 할 수 있다. 유일한 id를 주고 <code>getElementById</code>를 통해서 해당 태그를 찾고 <code>createRoot</code>, <code>render</code>를 통해서 리액트 컴포넌트를 렌더링하면 된다.</p>\n<p>예를 들어서 원래 헤더 역할을 하던 페이지가 있다면 그 페이지의 헤더 태그에 리액트 컴포넌트를 렌더링할 수 있다.</p>\n<pre><code class=\"language-html\">&#x3C;!-- ...생략... -->\n&#x3C;header>\n  &#x3C;div id=\"header\">&#x3C;/div>\n&#x3C;/header>\n&#x3C;!-- ...생략... -->\n</code></pre>\n<p>다음과 같이 id가 <code>header</code>인 태그를 찾고 그 내부에 리액트 컴포넌트를 렌더링한다.</p>\n<pre><code class=\"language-js\">import { createRoot } from 'react-dom/client';\n// 헤더 내부에 들어갈 컴포넌트는 이미 만들어져 있다고 하자\nimport Header from './Header';\n\nconst header = document.getElementById('header');\nconst root = createRoot(header);\nroot.render(&#x3C;Header />);\n</code></pre>\n<p>그런 식으로 페이지의 요소 하나하나를 리액트로 바꿔가며 마이그레이션할 수 있다.</p>\n<h1>6. 리액트의 타입들</h1>\n<p>리액트 사용자를 위해 리액트 요소들의 타입을 제공해 주는 <code>@types/react</code>와 <code>@types/react-dom</code> 패키지의 몇 가지 타입을 소개하는 섹션이 있다. 훅에 관련된 타입도 있고 몇 가지 유용한 타입들이 더 있다.</p>\n<p>리액트 타입의 설치는 당연히 <code>npm install @types/react @types/react-dom</code>으로 할 수 있다. 그리고 <code>.tsx</code> 파일 형식을 사용해야 JSX에 ts를 사용할 수 있다.</p>\n<h2>6.1. useState</h2>\n<p><code>useState</code>는 리액트의 가장 기본적인 훅이다. 이 훅은 전달된 초기 상태를 기반으로 상태의 타입을 추론한다.</p>\n<pre><code class=\"language-tsx\">// count의 타입은 number로 추론된다.\n// setCount의 타입은 number 혹은 number를 리턴하는 함수를 받는 함수 타입으로 추론된다.\nconst [count, setCount] = useState(0);\n</code></pre>\n<p>제네릭을 이용해서 <code>useState</code>의 상태 타입을 직접 제공할 수도 있다. 이는 유니언 타입 상태를 정의할 때 등에 유용하다.</p>\n<pre><code class=\"language-tsx\">type Theme = 'light' | 'dark';\n\nconst [theme, setTheme] = useState&#x3C;Theme>('light');\n</code></pre>\n<h2>6.2. useReducer</h2>\n<p><code>useReducer</code>는 <code>useState</code>와 비슷하지만 리듀서를 통해서 상태를 업데이트한다. 역시 리듀서 함수의 타입도 초기 상태를 통해서 추론된다. 물론 제네릭을 통해서 직접 타입을 제공할 수도 있지만 초기 상태를 통해 추론되도록 하는 게 보통 더 좋다.</p>\n<pre><code class=\"language-tsx\">type Action = { type: 'increment' } | { type: 'decrement' };\n\nfunction reducer(state: number, action: Action): number {\n  switch (action.type) {\n    case 'increment':\n      return state + 1;\n    case 'decrement':\n      return state - 1;\n  }\n}\n\n// 이후 사용될 때\nconst [count, dispatch] = useReducer(reducer, 0);\n</code></pre>\n<h2>6.3. useContext</h2>\n<p><code>useContext</code>훅은 props를 통호지 않고 컴포넌트 트리에 데이터를 내려줄 때 사용한다. 흔히 자식 컴포넌트에 값을 전달하는 커스텀 훅을 만들어서 사용한다.</p>\n<p>context에서 제공되는 값의 타입은 <code>createContext</code> 함수에 전달되는 값을 통해서 추론된다. 제네릭으로 따로 제공도 가능하다.</p>\n<pre><code class=\"language-tsx\">type Theme = 'light' | 'dark';\n\nconst ThemeContext = React.createContext&#x3C;Theme>('light');\n</code></pre>\n<p>만약 초기 값이 없는 경우가 있다면 제네릭에 제공하는 타입을 <code>Theme | null</code>로 설정한 후 <code>useContext</code>를 사용할 때 <code>null</code> 체크를 해줘서 타입을 좁히도록 하자.</p>\n<h2>6.4. useMemo, useCallback</h2>\n<p><code>useMemo</code>와 <code>useCallback</code>은 첫번째 인수로 전달받는 함수의 리턴 타입으로 훅의 결과를 추론한다. 훅에 타입 제네릭을 제공할 수도 있다.</p>\n<pre><code class=\"language-tsx\">// computeExpensiveValue의 리턴 타입으로 memoizedValue 타입이 추론된다\nconst memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);\n</code></pre>\n<p><code>useCallback</code>은 콜백 함수의 파라미터 타입과 리턴 타입을 통해서 훅의 결과를 추론한다.</p>\n<pre><code class=\"language-tsx\">// onClick의 타입은 (e: React.MouseEvent&#x3C;HTMLButtonElement>) => void로 추론된다.\nconst onClick = useCallback((e: React.MouseEvent&#x3C;HTMLButtonElement>) => {\n  console.log('button clicked');\n}, []);\n</code></pre>\n<p>취향에 따라서 리액트 타입에서 제공하는 <code>EventHandler</code>라는 타입을 사용할 수도 있다.</p>\n<pre><code class=\"language-tsx\">const handleClick=useCallback&#x3C;React.ClickEventHandler&#x3C;HTMLButtonElement>>((e) => {\n  console.log('button clicked');\n}, []);\n</code></pre>\n<h2>6.5. DOM 이벤트</h2>\n<p>리액트는 DOM 이벤트를 래핑해서 제공한다. 이벤트 타입은 이벤트 핸들러로부터 추론될 수 있을 때가 많지만 이벤트 핸들러에 전달될 함수를 따로 제작하고 싶을 경우 이벤트 타입을 직접 제공할 수 있다.</p>\n<pre><code class=\"language-tsx\">function handleClick(e: React.MouseEvent&#x3C;HTMLButtonElement>) {\n  console.log('button clicked');\n}\n\nfunction handleChange(e: React.ChangeEvent&#x3C;HTMLInputElement>) {\n  console.log('input changed');\n}\n</code></pre>\n<p>이벤트의 종류는 <a href=\"https://developer.mozilla.org/en-US/docs/Web/Events\">mdn 이벤트 레퍼런스</a>에서 볼 수 있다.</p>\n<p>그리고 모든 이벤트 타입의 base type은 <code>React.SynthenticEvent</code>이다.</p>\n<h2>6.6. children</h2>\n<p>자식 컴포넌트를 표현할 수 있는 방법은 널리 쓰이는 2가지가 있다. 하나는 JSX의 자식으로 전달될 수 있는 모든 타입들의 유니온인 <code>React.ReactNode</code>이다.</p>\n<p>두번째는 <code>React.ReactElement</code>인데 이는 JSX 요소만을 나타내며 문자열이나 숫자 같은 JS 원시값들은 포함하지 않는다.</p>\n<p>그리고 특정 타입의 JSX 요소만을 자식으로 받는 children 타입은 불가능하다. 예를 들어서 <code>&#x3C;section></code>태그만 자식으로 받는 등의 동작은 불가능하다는 말이다.</p>\n<h2>6.7. style props</h2>\n<p>리액트에서 인라인 스타일을 적용할 때 <code>React.CSSProperties</code>를 사용한다. 이는 모든 가능한 CSS 프로퍼티의 유니언 타입이라서 유효한 CSS 프로퍼티를 넘기는지를 이 타입을 이용해 검사할 수 있다.</p>\n<pre><code class=\"language-tsx\">interface Props {\n  style: React.CSSProperties;\n}\n</code></pre>",
    "excerpt": "나는 지금은 레거시로 분류되어 있는 react 이전 공식문서를 보면서 리액트를 처음 시작했었다. 아마 거기 있던 틱택토를 만들어 보는 문서부터 시작해서 조금 보다가 벨로퍼트의 모던 리액트로 넘어가서 투두리스트를 만들며 개발로 넘어왔던 걸로 기억한다.\n하지만 꽤 오래전 이야기이고 지금은 리액트 공식문서가 개편되었다. 그래서 거기의 문서들을 한번 읽어 보면서 몰랐던 부분들만 간략히 정리해본다.\n1. JSX\nHTML을 JSX로 많이 바꿔야 한다면 온라인 컨버터를 쓸 ",
    "headingTree": [
      {
        "title": "1. JSX",
        "url": "#1-jsx",
        "items": []
      },
      {
        "title": "2. 리액트 훅",
        "url": "#2-리액트-훅",
        "items": []
      },
      {
        "title": "3. lifting state",
        "url": "#3-lifting-state",
        "items": []
      },
      {
        "title": "4. 리액트로 설계하기",
        "url": "#4-리액트로-설계하기",
        "items": [
          {
            "title": "4.1. 컴포넌트 나누기",
            "url": "#41-컴포넌트-나누기",
            "items": []
          },
          {
            "title": "4.2. 상태 관리하기",
            "url": "#42-상태-관리하기",
            "items": []
          }
        ]
      },
      {
        "title": "3. key props",
        "url": "#3-key-props",
        "items": []
      },
      {
        "title": "4. 리액트 프레임워크",
        "url": "#4-리액트-프레임워크",
        "items": [
          {
            "title": "4.1. 리액트에서 프레임워크 사용을 권장하는 이유",
            "url": "#41-리액트에서-프레임워크-사용을-권장하는-이유",
            "items": []
          },
          {
            "title": "4.2. 프레임워크와 리액트",
            "url": "#42-프레임워크와-리액트",
            "items": []
          },
          {
            "title": "4.3. 에디터 설정",
            "url": "#43-에디터-설정",
            "items": []
          }
        ]
      },
      {
        "title": "5. 기존 프로젝트에 리액트 더하기",
        "url": "#5-기존-프로젝트에-리액트-더하기",
        "items": [
          {
            "title": "5.1. 리액트 페이지를 더하기",
            "url": "#51-리액트-페이지를-더하기",
            "items": []
          },
          {
            "title": "5.2. 기존 페이지에 리액트 컴포넌트 더하기",
            "url": "#52-기존-페이지에-리액트-컴포넌트-더하기",
            "items": []
          }
        ]
      },
      {
        "title": "6. 리액트의 타입들",
        "url": "#6-리액트의-타입들",
        "items": [
          {
            "title": "6.1. useState",
            "url": "#61-usestate",
            "items": []
          },
          {
            "title": "6.2. useReducer",
            "url": "#62-usereducer",
            "items": []
          },
          {
            "title": "6.3. useContext",
            "url": "#63-usecontext",
            "items": []
          },
          {
            "title": "6.4. useMemo, useCallback",
            "url": "#64-usememo-usecallback",
            "items": []
          },
          {
            "title": "6.5. DOM 이벤트",
            "url": "#65-dom-이벤트",
            "items": []
          },
          {
            "title": "6.6. children",
            "url": "#66-children",
            "items": []
          },
          {
            "title": "6.7. style props",
            "url": "#67-style-props",
            "items": []
          }
        ]
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 367
    },
    "url": "/posts/react-docs",
    "thumbnail": {
      "local": "/thumbnails/react-docs-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-react-docs-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAfklEQVR4nGNoam4ODAwsLy/38PBITEw0MTF1cnL+//8/Q3p6urS0NDMzc3t7+507dw4cOHD8+HGQxNKlS6uqqk6dOvXx48f/SIDh+PGjEydOvH///v///3/DAEjizr379+7du3Pnztu3b1F0zJm/eNbs2atXr7569SpEE0QCAFdWbBE+PzvjAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "react-test-1",
    "title": "React Testing - Jest 1",
    "date": "2023-02-04T03:00:00Z",
    "description": "프론트에 테스트 도입을 위한 공부, 기초",
    "tags": [
      "javascript"
    ],
    "html": "<p>테스트를 위해 공부한 내용을 간략히 정리하는 목적이다.</p>\n<h1>1. React Testing Library</h1>\n<p>CRA로 프로젝트를 생성하면 기본적으로 RTL이 설치되어 있다. 이는 DOM Testing Library를 기반으로 리액트를 위한 API를 붙여서 만들어졌다.</p>\n<p>리액트 컴포넌트를 테스트하는 목적으로, 행위 주도 테스트 방법론을 사용한다. 즉 값의 교환에 초점을 맞추는 것이 아니라 어떤 행위로 인해 화면이 변경되는 부분에 초점을 맞춘다.</p>\n<h1>2. 웹페이지 빌드 과정</h1>\n<p>브라우저는 HTML 문서를 읽고 스타일(CSS)을 입히고 뷰포트에 표시한다. 이때 HTML을 DOM으로, CSS를 CSSOM으로 변환한 후 브라우저가 둘을 합쳐 렌더 트리를 만든다. 이는 추후 다른 글에서 더 자세히 다룰 것이다.</p>\n<p>이때 DOM 트리는 HTML 파일을 파싱하고 HTML 표준에 맞게 토큰을 만든 후 트리 구조로 구축한다. 이렇게 브라우저가 HTML 파일을 구조화해서 표현한 것을 DOM이라고 한다.</p>\n<p>React 테스트를 할 때는 이런 DOM의 노드를 잡아서 테스트하게 된다.</p>\n<h1>3. 테스트 시작하기</h1>\n<p>CRA를 사용해서 프로젝트를 생성하자. 앱 이름은 적당히 지었다.</p>\n<pre><code>npx create-react-app react-test-app --template typescript\n</code></pre>\n<h2>3.1. Jest</h2>\n<p>React Testing Library를 통해서 DOM을 렌더링하고 그 DOM을 Jest를 이용해 테스트하게 될 것이다.</p>\n<p>CRA로 앱을 만들면 Jest도 미리 설치되어 있다. 이 jest는 <code>[파일이름].test.js</code>나 <code>[파일이름].spec.js</code>로 끝나는 파일을 찾아서 테스트를 실행한다. 또한 tests라는 이름의 폴더 안에 있는 파일들도 테스트 파일로 인식한다.</p>\n<p>이 Jest의 구조는 describe와 it으로 구성된다. describe는 테스트를 그룹화하고, it은 각 테스트의 내용을 정의한다. it는 test로 쓸 수도 있다.</p>\n<pre><code class=\"language-js\">// describe(name, function) 형식\ndescribe('테스트 그룹 이름', () => {\n  // it(name, function, [timeout]) 형식\n  it('테스트 이름', () => {\n    // 테스트 내용\n  });\n});\n</code></pre>\n<p>테스트는 기본적으로 expect, matcher로 이루어진다. expect는 테스트 대상을 정의하고, matcher는 테스트 대상의 상태를 검증한다.</p>\n<p>예를 들어서 <code>expect(sum(1,3)).toBe(2)</code>는 sum(1,3)이 2가 되는지를 검사한다. <code>expect(somthing).not.toBe(a)</code>처럼 not을 붙여 쓸 수도 있다.</p>\n<h2>3.2. React Testing Library</h2>\n<p>이제 드디어 RTL을 써보자. CRA로 앱을 만들었을 경우 <code>npm test</code>로 테스트를 실행시킬 수 있다. 이때 <code>App.test.tsx</code> 파일이 실행된다.</p>\n<p>이 파일은 다음과 같은 구조이다.</p>\n<pre><code class=\"language-js\">test('renders learn react link', () => {\n  render(&#x3C;App />);\n  // learn react라는 텍스트를 가진 링크 요소를 가져온다\n  const linkElement = screen.getByText(/learn react/i);\n  // 가져온 링크 요소가 DOM에 존재하는지 확인하는 toBeInTheDocument() matcher를 사용\n  expect(linkElement).toBeInTheDocument();\n});\n</code></pre>\n<p>render는 인자로 받은 컴포넌트를 DOM에 렌더링해주는 함수다. 위의 경우 App 컴포넌트를 렌더링할 것이다. 그리고 RTL에서 제공하는 쿼리 함수(getByText 등)을 담고 있는 객체를 리턴한다. 물론 위와 같이 screen이라는 객체를 사용할 수도 있고 이쪽이 더 권장된다.</p>\n<h3>3.2.1. RTL 쿼리 함수</h3>\n<p>쿼리 함수는 테스트 라이브러리가 페이지에서 특정 요소를 찾는 데에 사용된다. getByX(), queryByX(), findByX() 등이 있다.</p>\n<ul>\n<li>\n<p>getByX() : 요소를 찾으면 찾은 요소를 리턴하고, 없으면 에러를 발생시킨다. 둘 이상의 요소가 발견되어도 에러다. 만약 여러 요소가 예상될 경우 getAllByX를 쓰자.</p>\n</li>\n<li>\n<p>findByX() : 요소를 찾으면 resolve되는 Promise를 리턴하고, 해당 요소가 없거나 기본 제한시간(1초) 후에 해당 요소가 2개 이상이면 reject Promise를 리턴한다.</p>\n</li>\n<li>\n<p>queryByX() : 요소를 찾으면 찾은 요소를 리턴하고, 없으면 null을 리턴한다. getBy처럼 둘 이상의 요소가 발견되어도 에러다.</p>\n</li>\n</ul>\n<p>waitFor을 쓰면 일정 시간 동안 테스트 통과를 기다릴 수도 있다.</p>\n<h1>4. ESlint 설치</h1>\n<p>코드 작성할 때 문법 오류를 잡고 스타일을 맞추기 위해 eslint, prettier를 설치하자.</p>\n<p>먼저 CRA로 앱을 만들 때 자동으로 설정된 eslint config가 package.json에 있다. 이를 삭제하자.</p>\n<pre><code class=\"language-json\">// 이 부분 삭제\n\"eslintConfig\": {\n  \"extends\": [\n    \"react-app\",\n    \"react-app/jest\"\n  ]\n},\n</code></pre>\n<p>그리고 루트에 <code>.eslintrc.json</code> 파일을 만들고 testing플러그인 설치</p>\n<pre><code>npm install eslint-plugin-testing-library eslint-plugin-jest-dom --save-dev\n</code></pre>\n<p>플러그인 깔아 준 것에 맞게 eslintrc 변경</p>\n<pre><code class=\"language-json\">{\n  \"plugins\": [\"testing-library\", \"jest-dom\"],\n  \"extends\": [\n    \"react-app\",\n    \"react-app/jest\",\n    \"plugin:testing-library/react\",\n    \"plugin:jest-dom/recommended\"\n  ]\n}\n</code></pre>\n<h1>참고</h1>\n<p><a href=\"https://www.daleseo.com/react-testing-library/\">https://www.daleseo.com/react-testing-library/</a></p>\n<p><a href=\"https://leehyungi0622.github.io/2021/05/05/202105/210505-React-unit-test-questions/\">https://leehyungi0622.github.io/2021/05/05/202105/210505-React-unit-test-questions/</a></p>\n<p><a href=\"https://testing-library.com/docs/queries/about\">https://testing-library.com/docs/queries/about</a></p>",
    "excerpt": "테스트를 위해 공부한 내용을 간략히 정리하는 목적이다.\n1. React Testing Library\nCRA로 프로젝트를 생성하면 기본적으로 RTL이 설치되어 있다. 이는 DOM Testing Library를 기반으로 리액트를 위한 API를 붙여서 만들어졌다.\n리액트 컴포넌트를 테스트하는 목적으로, 행위 주도 테스트 방법론을 사용한다. 즉 값의 교환에 초점을 맞추는 것이 아니라 어떤 행위로 인해 화면이 변경되는 부분에 초점을 맞춘다.\n2. 웹페이지 빌드 과정\n브라",
    "headingTree": [
      {
        "title": "1. React Testing Library",
        "url": "#1-react-testing-library",
        "items": []
      },
      {
        "title": "2. 웹페이지 빌드 과정",
        "url": "#2-웹페이지-빌드-과정",
        "items": []
      },
      {
        "title": "3. 테스트 시작하기",
        "url": "#3-테스트-시작하기",
        "items": [
          {
            "title": "3.1. Jest",
            "url": "#31-jest",
            "items": []
          },
          {
            "title": "3.2. React Testing Library",
            "url": "#32-react-testing-library",
            "items": [
              {
                "title": "3.2.1. RTL 쿼리 함수",
                "url": "#321-rtl-쿼리-함수",
                "items": []
              }
            ]
          }
        ]
      },
      {
        "title": "4. ESlint 설치",
        "url": "#4-eslint-설치",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 202
    },
    "url": "/posts/react-test-1",
    "thumbnail": {
      "local": "/thumbnails/react-test-1-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-react-test-1-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAgUlEQVR4nGMoLCy0sbEpLCx0cnLS0NAICAj4DwYMzc3NLCwszc3Np06d2rdv3+zZs6ES8+bNc3Nzq6iomD179qFDh37//g2VWL9+fVpaWk1NTWZm5qFDh759+waVuH7z1p27dx89evT582eIEFSid+KUtvb22bNnnzp16v///3CjAJEXZxqCxoDOAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "react-target-vs-currenttarget",
    "title": "e.target과 e.currentTarget에 대한 연구",
    "date": "2023-11-26T01:00:00Z",
    "description": "target과 currentTarget을 다루기",
    "tags": [
      "react",
      "typescript"
    ],
    "html": "<h1>1. event.target vs event.currentTarget</h1>\n<h2>1.1. event.target</h2>\n<p>리액트에서 이벤트의 <code>target</code> 속성을 사용하는 일은 매우 흔하다. 이벤트가 발생한 객체에 대한 참조가 <code>event.target</code>에 담겨 있기 때문이다. 다음 코드의 경우 화면의 <code>hi</code>를 클릭 시 클릭이 발생한 객체의 <code>innerText</code> 즉 <code>hi</code>를 가져와서 로그를 찍는다.</p>\n<pre><code class=\"language-jsx\">export function App(props) {\n  const handleClick=(e)=>{console.log(e.target.innerText)}\n\n  return (\n    &#x3C;div className='App'>\n      &#x3C;div onClick={handleClick}>hi&#x3C;/div>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h2>1.2. vs event.currentTarget</h2>\n<p>여기서 위의 <code>handleClick</code> 함수를 다음과 같이 바꾸면 어떨까?</p>\n<pre><code class=\"language-jsx\">const handleClick=(e)=>{console.log(e.currentTarget.innerText)}\n</code></pre>\n<p>여전히 똑같은 동작을 한다. hi를 클릭하면 hi가 콘솔에 찍힌다. 그럼 이 둘의 차이는 무엇일까?</p>\n<p><code>event.target</code>은 이벤트가 발생한 객체를 가리킨다. 그리고 <code>event.currentTarget</code>은 이벤트 핸들러가 부착된 객체를 가리킨다. 이 둘은 다를 수도 있고 같을 수도 있다. 위의 예제에서는 같았지만 다음과 같은 예제를 보면 다르다는 것을 알 수 있다.</p>\n<pre><code class=\"language-jsx\">export function App(props) {\n  const handleClick=(e)=>{\n    console.log(\"target 텍스트\", e.target.innerText);\n    console.log(\"currentTarget 텍스트\", e.currentTarget.innerText);\n  }\n  return (\n    &#x3C;div onClick={handleClick}>\n      부모 요소\n      &#x3C;div>자식 요소&#x3C;/div>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<p>위 예제를 실행하고 조작해 보면 다음과 같은 결과가 나온다.</p>\n<pre><code>자식 요소 클릭 시\n> target 텍스트 자식 요소\n> currentTarget 텍스트 부모 요소 자식 요소\n\n부모 요소 클릭 시\n> target 텍스트 부모 요소 자식 요소\n> currentTarget 텍스트 부모 요소 자식 요소\n</code></pre>\n<p><code>target</code>은 정확히 클릭한 요소를 가리킨다. 자식 요소를 클릭 시 딱 자식 요소를 가리켜 거기의 <code>innerText</code>를 가져왔고 부모 요소를 클릭시 부모 요소를 가리켜서 부모 요소의 <code>innerText</code>를 가져왔다.</p>\n<p>반면 <code>currentTarget</code>은 이벤트 핸들러가 부착된 요소를 가리켰다. 자식 요소를 클릭하든 부모 요소를 클릭하든 해당 이벤트를 제어하는 이벤트 핸들러가 부착된 바로 그 요소, 여기서는 부모 요소를 가리켰고 해당 요소의 <code>innerText</code>를 가져왔다.</p>\n<h1>2. 타입스크립트와 함께</h1>\n<p>그런데 여기에 타입스크립트가 끼면 문제가 더 복잡해진다. 예를 들어 맨 앞에서 보았던 간단한 예제를 타입스크립트로 재현해 보자. 다음과 같이 해볼 수 있다. <code>handleClick</code>을 <code>MouseEventHandler</code>로 타이핑할 수도 있지만 결과는 똑같다.</p>\n<pre><code class=\"language-tsx\">export function App(props) {\n  const handleClick = (e: React.MouseEvent&#x3C;HTMLDivElement>) => {\n    // 에러 : Property 'innerText' does not exist on type 'EventTarget'.\n    console.log(e.target.innerText); \n  };\n\n  return (\n    &#x3C;div className='App'>\n      &#x3C;div onClick={handleClick}>hi&#x3C;/div>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<p>하지만 이렇게 하면 위의 주석에도 적어놓았듯이 에러가 발생한다! <code>EventTarget</code>에는 <code>innerText</code>같은 프로퍼티가 없다고 한다. 이는 결론부터 이야기하면 여기서는 <code>e.target</code>이 <code>EventTarget</code> 타입으로 정의되어 있기 때문이다. 왜 이런 문제가 발생할까? 그리고 어떻게 해야 할까?</p>\n<h2>2.1. 문제의 원인</h2>\n<p><code>React.MouseEvent&#x3C;T></code>의 정의를 따라가 보면 타입이 다음과 같은 위계를 가지고 있다.</p>\n<p><img src=\"/static/event-type-structure-3821f37d.png\" alt=\"이벤트 타입의 구조\"></p>\n<p>그리고 제일 기본 타입인 <code>BaseSyntheticEvent</code>를 보면 이렇게 정의되어 있다.</p>\n<pre><code class=\"language-ts\">interface BaseSyntheticEvent&#x3C;E = object, C = any, T = any> {\n    nativeEvent: E;\n    currentTarget: C;\n    target: T;\n    bubbles: boolean;\n    cancelable: boolean;\n    defaultPrevented: boolean;\n    eventPhase: number;\n    isTrusted: boolean;\n    preventDefault(): void;\n    isDefaultPrevented(): boolean;\n    stopPropagation(): void;\n    isPropagationStopped(): boolean;\n    persist(): void;\n    timeStamp: number;\n    type: string;\n}\n</code></pre>\n<p>많은 이벤트의 기본 타입인 <code>BaseSyntheticEvent</code>의 target은 <code>T</code> 제네릭 타입으로 정의되어 있다. 그리고 이를 래핑하는 <code>SyntheticEvent</code>타입에서는 <code>BaseSyntheticEvent</code>의 <code>T</code>를 <code>EventTarget</code>으로 제한한다. 리액트에서 모든 이벤트 타입은 <code>SyntheticEvent</code>를 상속하고 있으므로 리액트의 이벤트 타입들은 <code>target</code>이 <code>EventTarget</code> 타입으로 제한되어 있다.</p>\n<pre><code class=\"language-ts\">interface SyntheticEvent&#x3C;T = Element, E = Event> extends BaseSyntheticEvent&#x3C;E, EventTarget &#x26; T, EventTarget> {}\n</code></pre>\n<p>반면 <code>currentTarget</code>은 <code>C</code> 제네릭 타입으로 정의되어 있는데 이는 <code>SyntheticEvent</code>를 보면 <code>EventTarget &#x26; T</code>로 정의되어 있어서 참조하고 있는 요소의 프로퍼티도 사용할 수 있게 되어 있다.</p>\n<h2>2.2. 왜 이렇게 되었을까?</h2>\n<p>원인은 <code>SyntheticEvent</code>타입 정의의 주석에 있는 링크를 보면 알 수 있다. 주석과 타입 정의를 옮기면 다음과 같다.</p>\n<pre><code class=\"language-ts\">/**\n * currentTarget - a reference to the element on which the event listener is registered.\n *\n * target - a reference to the element from which the event was originally dispatched.\n * This might be a child element to the element on which the event listener is registered.\n * If you thought this should be `EventTarget &#x26; T`, see https://github.com/DefinitelyTyped/DefinitelyTyped/issues/11508#issuecomment-256045682\n */\ninterface SyntheticEvent&#x3C;T = Element, E = Event> extends BaseSyntheticEvent&#x3C;E, EventTarget &#x26; T, EventTarget> {}\n</code></pre>\n<p>그리고 주석에 링크를 타고 들어가면 다음과 같은 설명이 있다.</p>\n<pre><code>You cannot always tell target's type at compile time. Making it generic is of little value.\ntarget is the origin of the event (which no one really cares about, it might be a span inside a link, for example)\ncurrentTarget is the element that has the event handler attached to, which you should very much care about and type accordingly if you attached a dataset or other attributes to it, and intend to access at runtime.\n\nRelying on target instead of currentTarget is a beginner's mistake that will bite them sooner than latter.\n</code></pre>\n<p>요약하면 <code>target</code>은 우리가 위에서 본 것과 같이 이벤트가 일어난 바로 그 요소에 대한 참조인데 해당 요소에 대한 타입은 컴파일 타임에 정확히 확정할 수 없다는 얘기다.</p>\n<p>이벤트 핸들러는 부모 요소에 부착되어 있는데 이벤트가 일어난 정확한 요소는 자식 요소일 수도 있지 않은가? 이런 상황에서 이벤트 핸들러 입장에서는 <code>target</code>의 타입을 확정할 수 없다.</p>\n<p>예시를 들어 보자. 약간은 억지스런 코드일 수도 있지만 폼을 클릭하면 유효성 검사를 진행하도록 하고 싶다고 하자. 그러면 다음과 같은 코드를 작성할 수 있다.</p>\n<pre><code class=\"language-tsx\">function App() {\n  const handleClick = (e: React.MouseEvent&#x3C;HTMLFormElement>) => {\n    if (e.currentTarget.checkValidity()) {\n      console.log(\"유효성 검사 통과\");\n    } else {\n      console.log(\"유효성 검사 실패\");\n    }\n  };\n\n  return (\n    &#x3C;div className='App'>\n      &#x3C;form onClick={handleClick}>\n        &#x3C;h1>간단한 설문조사&#x3C;/h1>\n        &#x3C;input type='text' required />\n        &#x3C;button type='submit'>제출&#x3C;/button>\n      &#x3C;/form>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<p>이벤트 핸들러가 부착된 요소는 form 요소이므로 언제나 <code>e.currentTarget</code>은 form 요소이다. 그렇기 때문에 <code>currentTarget</code> 타입에 <code>checkValidity</code> 메서드를 사용해 클릭 시마다 유효성 검사를 할 수 있다.</p>\n<p>하지만 <code>e.target</code>의 경우에는 어떨까? 런타임에 유저가 어디를 클릭해서 이벤트를 발생시킬지는 TS 컴파일러 입장에서 알 수 없다. 제목인 <code>&#x3C;h1></code>태그를 클릭할 수도 있고 제출 버튼을 클릭할 수도 있다. 그러면 <code>e.target</code>은 <code>HTMLHeadingElement</code>나 <code>HTMLButtonElement</code>가 된다. 이런 여러 가능성들이 있기 때문에 <code>e.target</code>의 타입은 컴파일 타임에 확정할 수 없다.</p>\n<p>따라서 TS에서는 컴파일 타임에 타입을 확정할 수 있는 '이벤트 핸들러가 부착된 요소에 대한 참조'인 <code>currentTarget</code>을 통해서만 요소를 제어할 수 있도록 타입을 정의한 것이다.</p>\n<h2>2.3. 해결 방법</h2>\n<p>사실 해결 방법은 간단하다. 일단 당연히 위에서 말했듯이 컴파일 타임에 타입을 확정할 수 있는, 이벤트 핸들러가 부착된 바로 그 요소인 <code>currentTarget</code>을 사용하면 된다. 해당 PR 코멘트에서도 이를 권장하고 있고 타입 정의를 볼 때 이게 더 안전하기도 하다.</p>\n<p>하지만 만약 어떤 이유로 이벤트가 발생한 바로 그 요소에 접근하고 싶어서 <code>target</code>을 사용하고 싶다면 <code>as</code>를 사용해서 타입을 강제로 지정해 주면 된다. 물론 <code>EventTarget</code>에 정의되어 있는 <code>addEventListener</code> 등을 사용하고 싶은 거라면 <code>as</code>를 안 써도 된다.</p>\n<pre><code class=\"language-tsx\">export function App(props) {\n  const handleClick = (e: React.MouseEvent&#x3C;HTMLDivElement>) => {\n    console.log((e.target as HTMLDivElement).innerText);\n  };\n\n  return (\n    &#x3C;div className='App'>\n      &#x3C;div onClick={handleClick}>hi&#x3C;/div>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h1>3. 예외와 이유</h1>\n<p><code>e.target</code>은 <code>EventTarget</code>타입으로 정의되어 이벤트가 발생한 요소의 속성을 제대로 사용할 수 없다고 했었다. 그런데 다음과 같은 코드는 잘 동작한다. <code>target</code>에 접근해서 분명 <code>EventTarget</code>타입에는 존재하지 않는 <code>value</code>라는 속성을 사용하고 있다!</p>\n<pre><code class=\"language-tsx\">function App() {\n  const [value, setValue] = useState(\"\");\n\n  const handleChange = (e: React.ChangeEvent&#x3C;HTMLInputElement>) => {\n    setValue(e.target.value);\n  };\n\n  return (\n    &#x3C;div className='App'>\n      &#x3C;input value={value} onChange={handleChange} />\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<p>이는 몇몇 이벤트 타입에서 <code>target</code>의 타입을 재정의해주고 있기 때문이다. 예를 들어 <code>ChangeEvent</code>의 경우 이렇게 정의되어 있다.</p>\n<pre><code class=\"language-ts\">interface ChangeEvent&#x3C;T = Element> extends SyntheticEvent&#x3C;T> {\n    target: EventTarget &#x26; T;\n}\n</code></pre>\n<p>그리고 해당 이벤트를 받는 이벤트 핸들러가 <code>ChangeEventHandler</code>로 따로 정의되어 있으며 이는 <code>&#x3C;input></code>, <code>&#x3C;select></code>, <code>&#x3C;textarea></code>의 onChange 속성의 타입에 사용된다.</p>\n<p>따라서 <code>event</code>가 <code>ChangeEvent</code> 타입이라고 할 때 <code>event.target</code>은 이벤트가 발생한 바로 그 요소의 타입을 포함하게 된다. 그래서 위의 예제에서는 <code>event.target</code>이 <code>EventTarget &#x26; HTMLInputElement</code> 타입이 되어 <code>value</code> 속성을 사용할 수 있게 된 것이다.</p>\n<p>이외에도 <code>FocusEvent</code>이벤트 등이 <code>e.target</code>의 타입을 재정의해주고 있고 이런 이벤트 타입들에서는 <code>e.target</code>을 사용해서 이벤트 타깃에 접근해도 타입 에러가 발생하지 않는다. 이벤트가 발생한 정확한 그 객체 타입을 확정할 수 있는 객체를 어떤 기준으로든 분류해서 이렇게 해놓은 듯 하다.</p>\n<h1>4. 결론</h1>\n<p>특별한 이유가 없다면 이벤트 핸들러는 해당 이벤트에 대해 대응하고 싶은 바로 그 요소에 부착하게 된다. A 요소의 클릭 이벤트에 대응하고 싶은데 굳이 A 요소의 부모 요소에 이벤트 핸들러를 붙일 이유는 없기 때문이다.</p>\n<p>따라서 이왕이면 <code>currentTarget</code>을 사용하자.</p>\n<h1>참고</h1>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Event/target\">https://developer.mozilla.org/en-US/docs/Web/API/Event/target</a></p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Event/currentTarget\">https://developer.mozilla.org/en-US/docs/Web/API/Event/currentTarget</a></p>\n<p><a href=\"https://velog.io/@edie_ko/JavaScript-event-target%EA%B3%BC-currentTarget%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90\">https://velog.io/@edie_ko/JavaScript-event-target%EA%B3%BC-currentTarget%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90</a></p>\n<p><a href=\"https://handhand.tistory.com/287\">https://handhand.tistory.com/287</a></p>\n<p><a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped/issues/11508\">https://github.com/DefinitelyTyped/DefinitelyTyped/issues/11508</a></p>",
    "excerpt": "1. event.target vs event.currentTarget\n1.1. event.target\n리액트에서 이벤트의 target 속성을 사용하는 일은 매우 흔하다. 이벤트가 발생한 객체에 대한 참조가 event.target에 담겨 있기 때문이다. 다음 코드의 경우 화면의 hi를 클릭 시 클릭이 발생한 객체의 innerText 즉 hi를 가져와서 로그를 찍는다.\nexport function App(props) {\n  const handleClick=(e)=>",
    "headingTree": [
      {
        "title": "1. event.target vs event.currentTarget",
        "url": "#1-eventtarget-vs-eventcurrenttarget",
        "items": [
          {
            "title": "1.1. event.target",
            "url": "#11-eventtarget",
            "items": []
          },
          {
            "title": "1.2. vs event.currentTarget",
            "url": "#12-vs-eventcurrenttarget",
            "items": []
          }
        ]
      },
      {
        "title": "2. 타입스크립트와 함께",
        "url": "#2-타입스크립트와-함께",
        "items": [
          {
            "title": "2.1. 문제의 원인",
            "url": "#21-문제의-원인",
            "items": []
          },
          {
            "title": "2.2. 왜 이렇게 되었을까?",
            "url": "#22-왜-이렇게-되었을까",
            "items": []
          },
          {
            "title": "2.3. 해결 방법",
            "url": "#23-해결-방법",
            "items": []
          }
        ]
      },
      {
        "title": "3. 예외와 이유",
        "url": "#3-예외와-이유",
        "items": []
      },
      {
        "title": "4. 결론",
        "url": "#4-결론",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 2,
      "wordCount": 571
    },
    "url": "/posts/react-target-vs-currenttarget",
    "thumbnail": {
      "local": "/static/event-type-structure-3821f37d.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-event-type-structure-3821f37d-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAICAIAAABVpBlvAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAdklEQVR4nCWMERZAIRBFW0YUtYk2Eg6Gg+FgGKazlnQwTUfTtH/6XXh07zPWWu99jJGIAICZzZxTVXvvqrr3VlXjnAshIGL+uZaIjDFE5OlzTlNKqbW+ba1dK8YIAPiTUiIis9Y654wxVPWcc+9zzohIRK9l5g/Zo1cTBSNuugAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "react-test-2",
    "title": "React Testing - Jest 2",
    "date": "2023-02-19T03:00:00Z",
    "description": "프론트에 테스트 도입을 위한 공부, Testing Library 기본",
    "tags": [
      "javascript"
    ],
    "html": "<p>TDD로 개발할 때는 먼저 테스트를 만들고 테스트를 통과하는 코드를 작성하는 방식으로 제작해야 한다. 물론 반대 순서도 선택할 수 있지만 이름답게 테스트가 중심이 되어야 하는 건 마찬가지다.</p>\n<p>먼저 Testing Lib 공식 문서에서 기본적인 내용을 알아본 후 다음 글에서 TDD로 카운터를 만들어 볼 것이다.</p>\n<h1>1. 기본</h1>\n<p>기초적인 테스트를 만들어 보자. CRA로 프로젝트를 생성하면 기본적으로 <code>App.test.tsx</code>파일이 있다. 여기에 다음과 같은 테스트를 만들자. 이는 App 컴포넌트에 있는 title 엘리먼트가 Document에 있는지 확인하는 테스트다.</p>\n<pre><code class=\"language-js\">test(\"Title is in Document\", () => {\n  render(&#x3C;App />);\n  const titleElement = screen.getByTestId(\"title\");\n  expect(titleElement).toBeInTheDocument();\n});\n</code></pre>\n<p>먼저 App 컴포넌트를 렌더링한 후, 그 내부에서 \"title\"이라는 testId를 가진 엘리먼트를 찾는다. 그리고 해당 엘리먼트가 Document에 있는지 확인한다.</p>\n<p>다음과 같이 App 컴포넌트를 짜면 테스트가 통과된다. title testid를 가진 엘리먼트가 Document에 있기 때문이다.</p>\n<pre><code class=\"language-js\">function App() {\n  return (\n    &#x3C;div className=\"App\" data-testid=\"title\">\n      안녕하세요\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h1>2. 쿼리 함수들의 동작에 따른 분류</h1>\n<p>위에서 자연스럽게 <code>screen.getByTestId</code>함수를 사용하여 엘리먼트에 접근했다. 다른 쿼리 함수들은 뭐가 있을까?</p>\n<p>먼저 쿼리 함수들은 앞서 보았듯이 페이지 엘리먼트를 찾는 데 사용된다. 크게 분류하면 get, find, query 함수들이 있는데 이 함수들은 엘리먼트를 찾지 못했을 때의 동작이 다르다.</p>\n<p>이렇게 엘리먼트를 찾고 나면 Event API나 user-event로 이벤트를 발생시킬 수 있다.</p>\n<pre><code class=\"language-js\">test(테스트 제목, ()=>{\n  render(컴포넌트)\n  // 특정 엘리먼트를 찾는 쿼리 함수\n  const element=screen.쿼리함수(/이름/);\n})\n</code></pre>\n<p>그럼 이제 쿼리 함수들이 엘리먼트 찾기를 실패했을 때의 동작에 따른 분류를 알아보자. 또한 하나의 엘리먼트를 찾는 쿼리 함수와 여러 개의 엘리먼트를 찾는 쿼리 함수로 나눌 수도 있다. 여러 개의 엘리먼트를 찾을 경우 By 대신 AllBy가 붙는다. 이렇게 총 6가지의 분류가 생긴다.</p>\n<h3>2.1.1. getBy</h3>\n<p><code>getBy...</code> 쿼리 함수는 조건에 맞는 엘리먼트를 찾으면 해당 엘리먼트를 반환한다. 만약 찾지 못하면 에러를 발생시킨다. 조건에 맞는 엘리먼트가 2개 이상 있어도 에러를 발생시킨다.</p>\n<h3>2.1.2. queryBy</h3>\n<p><code>queryBy...</code> 쿼리 함수는 조건에 맞는 엘리먼트를 찾으면 해당 엘리먼트를 반환한다. 만약 찾지 못하면 null을 반환한다. 조건에 맞는 엘리먼트가 2개 이상 있으면 에러를 발생시킨다.</p>\n<h3>2.1.3. findBy</h3>\n<p><code>findBy...</code> 쿼리 함수는 Promise를 반환한다. 이때 해당 쿼리에 맞는 엘리먼트를 찾으면 Promise는 resolve된다. 만약 못 찾으면 Promise는 reject된다.</p>\n<p>그리고 기본 타임아웃 1000ms(1초)이후에 조건에 맞는 하나 이상의 엘리먼트가 발견되면 Promise는 reject된다.</p>\n<h3>2.1.4. getAllBy</h3>\n<p><code>getAllBy...</code> 쿼리 함수는 조건에 맞는 엘리먼트들을 담은 배열을 반환한다. 만약 찾지 못하면 에러를 발생시킨다.</p>\n<h3>2.1.5. queryAllBy</h3>\n<p><code>queryAllBy...</code> 쿼리 함수는 조건에 맞는 엘리먼트들을 담은 배열을 반환한다. 만약 찾지 못하면 빈 배열 <code>[]</code>을 반환한다.</p>\n<h3>2.1.6. findAllBy</h3>\n<p><code>findAllBy...</code> 쿼리 함수는 Promise를 반환한다. 해당 쿼리에 맞는 엘리먼트를 찾으면 Promise는 해당 엘리먼트들이 담긴 배열로 resolve된다. 만약 기본 타임아웃인 1000ms후에 그런 엘리먼트를 못 찾으면 Promise는 reject된다.</p>\n<p>findBy 쿼리 함수들은 getBy와 waitFor의 조합과 같다. 이 함수들은 마지막 optional argument로 wailFor의 옵션을 받는다.</p>\n<h1>3. 쿼리 함수의 우선순위</h1>\n<p>위에서 분류한 분류 각각이 수많은 쿼리 함수들을 가지고 있다. 이중에 위에서는 getByTestId를 사용했다. 그런데 screen.getByTestId를 사용해서 엘리먼트에 접근하는 건 권장되는 방식이 아니다. 그럼 어떤 쿼리를 사용해야 할까?</p>\n<p>기본적인 원칙은 유저가 내 페이지와 상호작용하는 방식을 닮아야 한다. 그리고 모두가 접근할 수 있는 쿼리 함수들을 우선적으로 사용해야 한다.</p>\n<p>따라서 getByRole, getByLabelText, getByText, getByDisplayValue 등을 사용하는 것이 좋다. 이 쿼리 함수들은 마우스나 시각을 사용하는 사람뿐 아니라 스크린 리더를 사용하는 등 다양한 상황에서도 잘 동작한다.</p>\n<p>그 다음이 getByAltText, getByTitle 등의 시맨틱 쿼리다. 그 다음이 우리가 썼던 getByTestId인데, 이게 우선순위가 가장 낮다. 이는 TestId가 개발자에게만 의미가 있고, 사용자에게는 의미가 없기 때문이다.</p>\n<p>그럼 먼저 Testing Library에 들어가서 제공되는 쿼리 함수들을 알아보았다.</p>\n<h1>3.1. Accessible to Everyone</h1>\n<p>마우스를 사용하는 사람뿐 아니라 스크린 리더를 사용하는 사람의 경험도 포함하는 쿼리들이다. 편의상 getBy로 설명하지만 같은 의미로 queryBy, findBy, getAllBy, queryAllBy, findAllBy도 있다.</p>\n<h3>3.1.3. getByRole</h3>\n<p>접근성 트리(DOM 트리를 기반으로 하며 접근성 관련 정보들을 포함한다)에 나와 있는 모든 요소에 사용 가능하다. 그리고 name으로 필터링도 할 수 있다. 이걸 사용하는 게 가장 권장된다. 그리고 문서에 의하면 대부분의 테스트를 이걸로 할 수 있을 거라고 한다. name 옵션과 함께 쓰일 때가 많다.</p>\n<pre><code class=\"language-js\">screen.getByRole('button', {name: /submit/i})\n</code></pre>\n<h3>3.1.2. getByLabelText</h3>\n<p>LabelText를 통해서 엘리먼트를 찾는다. form에 사용하기 좋다. 사용자는 form을 채우는 과정에서 label을 보게 되는데, 이 label을 통해서 엘리먼트를 찾는 것이다. 이 또한 가장 권장된다.</p>\n<h3>3.1.3. getByPlaceholderText</h3>\n<p>placeholder를 통해서 요소를 찾는다. 그러나 <a href=\"https://www.nngroup.com/articles/form-design-placeholders/\">placeholder 자체가 권장되지 않는다.</a> 다른 옵션이 있다면 다른 걸 쓰는 게 낫다.</p>\n<h3>3.1.4. getByText</h3>\n<p>사용자는 텍스트를 통해 요소를 찾기도 한다. 사용자와 상호작용하지 않는 요소들, div, span, p tag 등에 사용한다.</p>\n<h3>3.1.5. getByDisplayValue</h3>\n<p>input, textarea, select 등에서 현재 보여지고 있는 value를 통해서 요소를 찾는다.</p>\n<h2>3.2. 시맨틱 쿼리 함수</h2>\n<h3>3.2.1. getByAltText</h3>\n<p>alt text를 지원하는 img, area, input과 같은 태그로 이루어진 요소라면 이 함수를 통해 요소를 불러올 수 있다.</p>\n<h3>3.2.2. getByTitle</h3>\n<p>title 속성으로 요소를 불러오지만 이는 스크린 리더에 잘 읽히지도 않고 기본적으로는 보이지 않는다는 단점이 있다.</p>\n<h2>3.3. getByTestId</h2>\n<p>testid 속성으로 요소를 불러온다. 그러나 이는 사용자에게 보이지 않는 속성이기 때문에 role이나 text로 요소를 매칭시킬 수 없을 때 사용한다. text가 동적으로 변한다든지 하는 상황.</p>\n<h1>4. 쿼리함수 사용하기</h1>\n<p>Testing Library의 쿼리 함수는 첫 번째 인수로 container를 전달해야 한다. 그런데 React Testing Library를 포함한 대부분의 Testing Library에서 document.body는 워낙 많이 컨테이너로 전달되어, screen 객체를 통해서 쿼리 함수를 사용할 경우 자동으로 document.body를 컨테이너로 전달해준다.</p>\n<p>쿼리가 요소를 찾을 때 쓰이는 인수는 문자열, 정규 표현식 혹은 함수가 될 수 있다. 그러면 이제 쿼리 함수에 문자열을 전달해서 요소를 찾은 다음 테스트해보자.</p>\n<p>간단한 리액트 컴포넌트를 만든다.</p>\n<pre><code class=\"language-js\">function App() {\n  return &#x3C;h1>안녕하세요&#x3C;/h1>;\n}\n</code></pre>\n<p>그리고 테스트 코드를 작성한다. <a href=\"https://www.w3.org/TR/html-aria/#docconformance\">여기</a>를 보면 각 HTML 요소들의 기본 role을 볼 수 있는데, h1~h6 태그의 role은 heading이다. 그래서 getByRole을 사용한다.</p>\n<pre><code class=\"language-js\">test(\"Element is in Document\", () => {\n  render(&#x3C;App />);\n  const titleElement = screen.getByRole(\"heading\");\n  expect(titleElement).toBeInTheDocument();\n});\n\ntest(\"Text check\", () => {\n  render(&#x3C;App />);\n  const titleElement = screen.getByRole(\"heading\");\n  expect(titleElement).toHaveTextContent(\"안녕하세요\");\n});\n</code></pre>\n<p>이 상태에서 npm test를 실행해 보면 테스트를 통과하는 것을 확인할 수 있다.</p>\n<h2>4.1. TextMatch</h2>\n<p>여러 쿼리 함수들이 TextMatch를 인수로 받는다. 그리고 이는 문자열, 정규 표현식, 함수가 될 수 있다. 이때 함수의 형태는 다음과 같다.</p>\n<pre><code class=\"language-js\">(content?: string, element?: Element | null) => boolean\n</code></pre>\n<p>다음과 같이 쓰일 수 있는 것이다.</p>\n<pre><code class=\"language-js\">screen.getByText('Hello World') // 문자열을 써서 탐색\nscreen.getByText(/World/) // 정규표현식으로 탐색\nscreen.getByText((content, element) => content.startsWith('Hello')) //함수를 이용해서 탐색\n</code></pre>\n<p>보통 정규 표현식을 써서 찾는 게 더 광범위하고 복잡한 탐색을 가능하게 한다.</p>\n<h3>4.1.1. TextMatch Options</h3>\n<p>TextMatch를 받는 함수들은 마지막 인수로 option들을 담은 객체를 전달하여 문자열 매칭을 조정할 수 있다. 그 옵션들은 다음과 같다.</p>\n<ul>\n<li>exact: true일 경우 대소문자를 구분하고 정확히 일치하는 문자열만 찾는다. 기본값은 true이다. false일 경우 대소문자 구분을 안하고 부분 문자열도 매칭한다.(문자열 인수인 경우에만 영향)</li>\n<li>normalizer : 문자열을 정규화하는 함수를 전달할 수 있다.</li>\n</ul>\n<h3>4.1.2. 정규화</h3>\n<p>DOM의 텍스트 매칭 작업을 할 때 Testing Lib은 기본적으로 텍스틀 정규화한다. 기본 정규화의 경우 앞뒤 공백을 제거하고 공백을 하나로 합치고, 줄바꿈을 공백으로 바꾼다. 이는 사용자가 보는 텍스트와 일치시키기 위함이다.</p>\n<p>만약 따로 정규화 함수를 만들고 싶다면 TextMatch Option들을 담은 객체의 normalizer에 정규화 함수를 전달하면 된다.</p>\n<p>혹은 getDefaultNormalizer에 옵션을 전달해서 기본 정규화 함수를 약간 편집해서 사용할 수도 있다. 앞뒤 공백을 제거하는 옵션인 trim, 공백을 하나로 합치는 옵션인 collapseWhitespace를 조정할 수 있다.</p>\n<pre><code class=\"language-js\">screen.getByText('text', {\n  normalizer: getDefaultNormalizer({trim: false}),\n})\n</code></pre>\n<p>위 코드는 'text'가 포함된 요소를 가져오는데 텍스트 정규화 함수가 trim을 하지 않도록 설정한 것이다.</p>\n<h2>4.2. 수동 쿼리</h2>\n<p>요소들을 가져오기 위해서 Testing Lib의 쿼리 함수들을 사용하는 대신 그냥 querySelector API 등을 사용할 수도 있다. 이렇게 하면 class나 id를 통해서 요소를 가져올 수 있다.</p>\n<pre><code class=\"language-js\">const {container}= render(&#x3C;App />);\nconst titleElement = container.querySelector(\"h1\");\n</code></pre>\n<p>하지만 이런 부분은 사용자에게 보이는 것이 아니기 때문에 '사용자의 경험과 같은 방식으로 테스트한다'는 원칙에 어긋난다. 따라서 권장되지 않는다. 만약 굳이 시맨틱하지 않은 쿼리를 사용해야 한다면 testid를 사용하자.</p>\n<h1>5. 개별 함수들</h1>\n<p>앞서 쿼리 함수들의 우선순위에서 어떻게 요소를 찾는지에 따라 달라지는 쿼리 함수들을 간단히 알아보았다. 각 함수들을 공식 문서를 토대로 좀더 자세히 알아보았다. 다만 모든 선택 인수까지 다루기에는 시간이 없어서, 적당히 많이 쓰일 것 같은 기능만 일단 정리하였다.</p>\n<h2>5.1. ByRole</h2>\n<p>요소의 role을 기반으로 요소를 가져온다. 예를 들어서 button 태그의 role은 button, a 태그의 role은 link이다. role을 기반으로 요소를 가져오기 때문에 시맨틱한 HTML 요소를 사용하는 것이 중요하다.</p>\n<p>각 요소의 기본 role은 <a href=\"https://www.w3.org/TR/html-aria/#docconformance\">여기</a>서 볼 수 있다.</p>\n<p>이렇게 기본 설정된 role이나 aria-* 속성을 편집하는 것은 불필요하고 권장되지 않는다. 기본 role과 충돌할 수도 있고.</p>\n<p>그리고 accessible name을 기반으로 요소를 가져오는 것도 가능하다. 가령 form 요소의 label, button 요소의 textContent, aria-label의 값 등으로 가져오는 것이다.</p>\n<p>같은 역할을 하는 컴포넌트가 여러 개 있을 때 accessible name을 통해서 구분지을 수 있다. 예를 들어서 버튼이 여러 개 있을 때 이 요소들의 role은 모두 button으로 같겠지만 버튼의 accessible name이 다르다면 이를 통해서 구분할 수 있다. <code>getByRole('button', {name: 'Submit'})</code> 이런 식으로 말이다.</p>\n<p>accessible name은 <a href=\"https://www.tpgi.com/what-is-an-accessible-name/\">이 글</a>에 더 자세히 설명되어 있다.</p>\n<h2>5.2. ByLabelText</h2>\n<p>이 쿼리 함수는 TextMatch를 받는다. 그리고 거기 맞는 label을 찾고 그 label에 엮여 있는 요소를 찾는다.</p>\n<p>다음과 같은 컴포넌트를 테스트한다.</p>\n<pre><code class=\"language-js\">function App() {\n  return (\n    &#x3C;div>\n      &#x3C;label htmlFor=\"id-input\">아이디&#x3C;/label>\n      &#x3C;input id=\"id-input\" />\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<p>간단하게 input이 document 안에 있는지만 테스트한다. input 요소를 가져올 수 있는지만 체크하면 되기 때문에.</p>\n<pre><code class=\"language-js\">test(\"Element is in Document\", () => {\n  render(&#x3C;App />);\n  const titleElement = screen.getByLabelText(\"아이디\");\n  expect(titleElement).toBeInTheDocument();\n});\n</code></pre>\n<p>단 만약 라벨 텍스트와 input의 id가 다르다면 getByLabelText는 요소를 찾지 못한다. 이런 경우에는 getByRole을 사용하면 된다. aria-label 같은 걸 사용하는 것보다 이편이 더 권장된다.</p>\n<pre><code class=\"language-js\">getByRole('textbox', {name: '아이디'})\n</code></pre>\n<h2>5.3. 나머지 쿼리 함수들</h2>\n<p>나머지들은 거의 위에서 설명한 것 이상의 의미가 없었다. 그냥 TextMatch 인수만 잘 넣어주면 알아서 찾는다.</p>\n<h1>6. 이벤트 발생시키기</h1>\n<p>fireEvent 대신 userEvent를 사용하는 게 권장된다. userEvent도 fireEvent를 사용하지만 엘리먼트 타입에 따라서 더 적절한 반응을 보여준다. 클릭한 버튼이 focus되는 등이다. 따라서 userEvent를 사용하는 법을 간단히 보았다.</p>\n<p>먼저 컴포넌트 렌더링 이전에 userEvent.setup()을 실행하고 거기서 리턴된 객체를 이용해 이벤트를 발생시키는 것이 권장된다. <code>userEvent.click(element)</code>와 같이 즉시 실행하는 것도 가능하지만 이는 v13에서 v14로의 마이그레이션을 수월하게 하기 위해서일 뿐이다.</p>\n<p>그리고 userEvent.setup()에서 리턴된 객체들은 하나의 상태를 공유하므로 테스트를 계속 이어갈 수 있다. 예를 들어서 첫 번째 테스트에서 버튼을 클릭하고 두 번째 테스트에서 버튼이 클릭되었는지 확인할 수 있다.</p>\n<pre><code class=\"language-js\">test(\"Button click\", () => {\n  const user=userEvent.setup();\n  render(&#x3C;App />);\n  // Click me라고 쓰인 버튼을 가져온다\n  const button = screen.getByRole(\"button\",{name:\"Click me\"});\n  user.click(button);\n});\n</code></pre>\n<p>다음과 같은 App 컴포넌트를 작성하면 테스트가 통과된다.</p>\n<pre><code class=\"language-js\">function App() {\n  return (\n    &#x3C;div>\n      &#x3C;button>Click me&#x3C;/button>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h2>6.1. userEvent api</h2>\n<p>pointer, keyboard, clipboard, click/dblClick/tripleClick 등 많은 사용자 이벤트가 있지만 좀 써보고 정리 예정</p>\n<h1>참고</h1>\n<p><a href=\"https://testing-library.com/docs/queries/about\">https://testing-library.com/docs/queries/about</a></p>",
    "excerpt": "TDD로 개발할 때는 먼저 테스트를 만들고 테스트를 통과하는 코드를 작성하는 방식으로 제작해야 한다. 물론 반대 순서도 선택할 수 있지만 이름답게 테스트가 중심이 되어야 하는 건 마찬가지다.\n먼저 Testing Lib 공식 문서에서 기본적인 내용을 알아본 후 다음 글에서 TDD로 카운터를 만들어 볼 것이다.\n1. 기본\n기초적인 테스트를 만들어 보자. CRA로 프로젝트를 생성하면 기본적으로 App.test.tsx파일이 있다. 여기에 다음과 같은 테스트를 만들자. ",
    "headingTree": [
      {
        "title": "1. 기본",
        "url": "#1-기본",
        "items": []
      },
      {
        "title": "2. 쿼리 함수들의 동작에 따른 분류",
        "url": "#2-쿼리-함수들의-동작에-따른-분류",
        "items": []
      },
      {
        "title": "3. 쿼리 함수의 우선순위",
        "url": "#3-쿼리-함수의-우선순위",
        "items": []
      },
      {
        "title": "3.1. Accessible to Everyone",
        "url": "#31-accessible-to-everyone",
        "items": [
          {
            "title": "3.2. 시맨틱 쿼리 함수",
            "url": "#32-시맨틱-쿼리-함수",
            "items": [
              {
                "title": "3.2.1. getByAltText",
                "url": "#321-getbyalttext",
                "items": []
              },
              {
                "title": "3.2.2. getByTitle",
                "url": "#322-getbytitle",
                "items": []
              }
            ]
          },
          {
            "title": "3.3. getByTestId",
            "url": "#33-getbytestid",
            "items": []
          }
        ]
      },
      {
        "title": "4. 쿼리함수 사용하기",
        "url": "#4-쿼리함수-사용하기",
        "items": [
          {
            "title": "4.1. TextMatch",
            "url": "#41-textmatch",
            "items": [
              {
                "title": "4.1.1. TextMatch Options",
                "url": "#411-textmatch-options",
                "items": []
              },
              {
                "title": "4.1.2. 정규화",
                "url": "#412-정규화",
                "items": []
              }
            ]
          },
          {
            "title": "4.2. 수동 쿼리",
            "url": "#42-수동-쿼리",
            "items": []
          }
        ]
      },
      {
        "title": "5. 개별 함수들",
        "url": "#5-개별-함수들",
        "items": [
          {
            "title": "5.1. ByRole",
            "url": "#51-byrole",
            "items": []
          },
          {
            "title": "5.2. ByLabelText",
            "url": "#52-bylabeltext",
            "items": []
          },
          {
            "title": "5.3. 나머지 쿼리 함수들",
            "url": "#53-나머지-쿼리-함수들",
            "items": []
          }
        ]
      },
      {
        "title": "6. 이벤트 발생시키기",
        "url": "#6-이벤트-발생시키기",
        "items": [
          {
            "title": "6.1. userEvent api",
            "url": "#61-userevent-api",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 2,
      "wordCount": 418
    },
    "url": "/posts/react-test-2",
    "thumbnail": {
      "local": "/thumbnails/react-test-2-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-react-test-2-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAgElEQVR4nC3JoQ2DIRBA4T8sxAhoFmACZrgZTpC2KWlSfXucRzAAKRKJQCBJcw2kT77vAgBjDABYa7XWzjk5XYiolAKAlBIzE9EfiMh7n1JqrfXexxhrrQ3MjIhEFEKIMYYQeu8byqeWUmqtc04RWacNz9f7dn8QUc5ZRL7nisgPheFpU85T6IcAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "react-usereducer-basic",
    "title": "React 탐구생활 - useReducer 문법",
    "date": "2022-09-12T00:00:00Z",
    "description": "React useReducer의 기본적인 내용",
    "tags": [
      "web",
      "study",
      "front",
      "react"
    ],
    "html": "<p>(2023-11-13 업데이트)</p>\n<h1>1. 시작</h1>\n<p>리액트를 가르치는 많은 문서에서 useReducer라는 상태 관리 기법을 소개하고 있다. 하지만 어렴풋이 이런 게 있다는 것만 알 뿐 딱히 사용해본 적은 없었다. 그래서 이번에 useReducer의 기능, 장점과 사용처를 알아보겠다. 마침 새로 업데이트된 리액트 공식 문서에도 이 부분이 있었다.</p>\n<h1>2. useReducer의 기본형태</h1>\n<p>React에서는 useState라는 상태 관리 기법을 제공한다. 그리고 리액트를 쓰는 사람이라면 useState정도는 분명 써보았을 것이다. 이 함수는 상태와 그 상태를 특정한 상태로 업데이트시킬 수 있는 <code>setState</code> 함수를 제공한다.</p>\n<p>그러면 useReducer는 이와 무엇이 다른가? useReducer는 어떤 상태와 그 상태를 특정한 다른 상태로 변경하는 action을 보낼 수 있는 dispatch 함수를 제공한다. 이 action은 상태를 직접 설정하는 대신 '무엇을 할지'에 대한 정보를 리듀서에 전달하는 역할을 한다.</p>\n<p>예시를 들어 보자. 다음과 같은 useState를 사용한 코드가 있다고 하자.</p>\n<pre><code class=\"language-jsx\">const [number, setNumber] = useState(0);\n</code></pre>\n<p>여기서 useState는 상태를 저장하는 변수 number와 그 number를 특정한 다른 숫자로 바꿔주는 함수 setNumber를 제공한다. 따라서 카운터를 만든다면 다음과 같이 증가와 감소를 구현할 수 있다.</p>\n<pre><code class=\"language-jsx\">const onIncrease = () => {\n  setNumber(number + 1);\n};\n\nconst onDecrease = () => {\n  setNumber(number - 1);\n};\n</code></pre>\n<p>반면 useReducer는 상태를 저장하는 변수와 그 상태를 특정 함수(reducer)를 통과한 상태로 만들어주는 함수(dispatch)를 제공한다.</p>\n<p>기본형은 이렇다. useReducer 훅은 상태의 업데이트를 담당하는 Reducer 함수와 초기 상태를 인자로 받는다.</p>\n<pre><code class=\"language-jsx\">const [state, dispatch] = useReducer(reducer, initialState);\n</code></pre>\n<p>useReducer의 3번째 인자로 lazy initialization에 해당하는 함수를 넣어줄 수도 있지만 이는 잘 쓰이지 않으므로 사실상 위의 형태가 기본형이다. 즉 위의 number와 setNumber를 대체하는, useReducer의 형태는 다음과 같다.</p>\n<pre><code class=\"language-jsx\">const [number, dispatch] = useReducer(reducer, 0);\n</code></pre>\n<p>앞서 보았던 증가와 감소 함수는 이런 식으로 구현된다. dispatch 함수에 action 객체를 전달해 주는 식이다. 이렇게 하면 <code>useReducer</code>가 리턴했던 <code>number</code> state가 업데이트된다.</p>\n<pre><code class=\"language-jsx\">const onIncrease = () => {\n  dispatch({ type: \"INCREMENTED\" });\n};\n\nconst onDecrease = () => {\n  dispatch({ type: \"DECREMENTED\" });\n};\n</code></pre>\n<p>이때 사실 action 객체는 어떤 형태든 상관없지만 일반적으로 <code>type</code> 속성에 들어간 문자열을 이용해 어떤 업데이트를 할지 명시한다. 이렇게 하면 리듀서에서 <code>switch</code>문을 통해 어떤 업데이트를 할지를 구분할 수 있다.</p>\n<p>그러면 이 type속성의 문자열은 어떤 방식으로 작성해야 할까? 원래 일반적으로는 상태가 어떤 방식으로 바뀔지를 작성했었다. 가령 <code>ADD</code>나 <code>DELETE</code>처럼 작성한 것이다.</p>\n<p>다만 리액트 공식 문서에서는 이렇게 상태를 어떻게 바꿀지를 작성하는 것보다 사용자가 어떤 동작을 취했는지를 작성하는 것을 권장하고 있다. 예를 들어 <code>INCREMENTED</code>나 <code>CHANGED</code>처럼 말이다. 물론 <code>changed</code>같이 소문자로 써도 상관없다.</p>\n<p>업데이트에 필요한 데이터는 각 속성으로 전달하거나 <code>payload</code>라는 이름의 속성 객체로 전달하기도 한다. 위의 경우 특별히 업데이트에 필요한 상태가 없으므로 <code>type</code>속성만 전달하였다.</p>\n<p>number는 <code>useState</code>를 썼을 때와 똑같이 상태를 저장하고 있고, dispatch는 action 객체를 리듀서에 전달해서 상태를 업데이트한다. 그럼 리듀서는 무엇인가?</p>\n<h1>3. reducer 함수에 대하여</h1>\n<p>리듀서는 <code>setState</code>와 비슷하게 state의 업데이트를 담당하는 함수이다. 현재 상태와 action 객체를 받아서 새로운 상태를 리턴한다.</p>\n<pre><code class=\"language-tsx\">// state: 현재 상태\n// action: 업데이트에 필요한 정보를 가진 객체\nfunction reducer(state, action){\n  // 다음 state를 리턴한다\n}\n</code></pre>\n<p>이때 action은 useReducer를 사용하는 측에서 dispatch 함수를 통해 전달되는 객체이다. 앞서 말했듯 action은 상태 업데이트 종류를 나타내는 type과 필요한 정보로 이루어지는 게 일반적이다. 그렇기 때문에 일반적으로 <code>action.type</code>에 대한 switch문을 작성한다.</p>\n<pre><code class=\"language-tsx\">function reducer(state, action) {\n  switch (action.type) {\n    case \"ADDED\":\n      return state + 1;\n    case \"SUBTRACTED\":\n      return state - 1;\n  }\n}\n</code></pre>\n<p>만약 state가 객체 형태라면 여기서도 <code>setState</code>를 사용할 때와 같이 불변성을 지켜 주어야 한다. 여기서는 업데이트에 필요한 정보를 action.payload로 전달했는데 리덕스에서 사용하는 이름을 그대로 따른 것이다.</p>\n<pre><code class=\"language-tsx\">function reducer(state, action) {\n  switch (action.type) {\n    case 'APPENDED':\n      return [...state, action.payload];\n    case 'CHANGED':\n      return state.map((item) => {\n        if (item.id === action.payload.id) {\n          return action.payload;\n        }\n        return item;\n      });\n    case 'DELETED':\n      return state.filter((item) => item.id !== action.payload.id);\n  }\n}\n</code></pre>\n<p>이 리듀서는 useState의 업데이트 로직과 같은 작업 큐에 들어가서 실행된다. 따라서 불변성과 순수성을 지켜 주어야 한다. 네트워크 요청이나 사이드 이펙트를 가지고 있으면 안된다.</p>\n<p>또한 하나의 action은 하나의 사용자 상호작용을 나타내야 한다. 그것이 여러 데이터를 한번에 변경하더라도 말이다. form을 초기화하는 action이 있다면 5개의 데이터를 초기화하겠지만 이는 <code>reset_form</code>같은 하나의 action으로 표현되어야 한다.</p>\n<h2>3.1. reducer의 유래</h2>\n<p>이 reducer라는 이름은 어디서 온 걸까? 이는 배열의 <code>reduce</code>메서드에서 가져온 것이다. 배열의 reduce 메서드는 배열의 모든 원소를 모아서 만든 어떤 하나의 값을 리턴해준다. 그런데 이때 reduce가 받는 콜백을 바로 reducer라 한다. 이 콜백은 다음과 같은 형태를 가진다.</p>\n<pre><code class=\"language-tsx\">function reducer(accumulator, currentValue, currentIndex, array) {\n  // ...\n}\n// 그런데 일반적으론 2번째 인자까지만 쓰인다\nfunction reducer(accumulator, currentValue) {\n  // ...\n}\n</code></pre>\n<p>이 콜백은 배열의 모든 원소를 순회하면서 호출되는데, accumulator는 이전 원소까지 순회하면서 나온 결과이고 currentValue는 현재 순회하고 있는 원소이다. 이 둘을 받아서 어떤 값을 리턴하면 그 값이 다음 순회에서 accumulator로 전달된다. 이런 식으로 모든 원소를 순회하면서 하나의 값으로 축약하는 것이다.</p>\n<p>리액트의 reducer도 현재 상태와 action을 받아서 다음 상태를 리턴하는 함수이므로 이를 reducer라고 부른다. 상태를 지금까지의 모든 action이 reduce된 결과물이라고 생각하면 생각을 연결시켜 볼 수 있겠다.</p>\n<h1>4. dispatch 함수의 사용</h1>\n<p>앞서 본 useReducer의 기본형은 다음과 같다. reducer 함수와 초기상태를 useReducer에 전달하여 상태를 저장하는 변수 state와 action을 전달하여 상태를 업데이트하는 데 쓰이는 dispatch 함수를 받는다.</p>\n<p>dispatch를 통해 action을 받아서 상태 변경에 대한 구체적인 로직을 실행하는 reducer는 컴포넌트 외부에, 혹은 다른 파일에 있어도 되기 때문에 상태 변경 로직을 분리할 수 있다는 게 useReducer의 장점이다.</p>\n<pre><code class=\"language-jsx\">const [state, dispatch] = useReducer(reducer, initialState);\n</code></pre>\n<p>dispatch는 받은 인자를 reducer의 2번째 인자로 전달한다. 그리고 현재 상태와 dispatch에서 전달한 action을 통해 리턴된 값을 새로운 상태로 만든다. 만약 다음과 같은 dispatch 함수가 있다고 하자.</p>\n<pre><code class=\"language-jsx\">dispatch({ type: \"reset\" });\n</code></pre>\n<p>그러면 reducer는 <code>reducer(현재 상태, {type:\"reset\"})</code>형태로 호출되고 여기서 리턴된 값이 새로운 state가 된다.</p>\n<p>이런 동작을 그림으로 간단히 나타내볼 수 있다.</p>\n<p><img src=\"/static/reducer-structure-6e742cb7.png\" alt=\"reducer의 동작\"></p>\n<p>이때 이 dispatch 함수는 컴포넌트가 새로 렌더링된다고 새로 생성되지 않는다. 이는 useState의 setState도 마찬가지다.</p>\n<p>참고로 <code>immer</code>라이브러리도 비슷한 기능을 제공한다. <code>useImmerReducer</code>를 사용하면 된다.</p>\n<h1>5. useReducer의 사용법 - Counter 예제</h1>\n<p>그럼 이제 useReducer를 사용하는 형태도 알았고 리듀서도 dispatch도 어떻게 쓰이는지 알았다. 그럼 어떻게 사용할까? 리액트를 처음 시작할 때 한번씩은 다들 만드는 카운터 예제를 만들어보자. 먼저 useState를 이용하는 형태로 만들어보자.</p>\n<pre><code class=\"language-jsx\">function Counter() {\n  const [number, setNumber] = useState(0);\n\n  const onIncrease = () => {\n    setNumber((prev) => prev + 1);\n  };\n\n  const onDecrease = () => {\n    setNumber(number - 1);\n  };\n\n  return (\n    &#x3C;section>\n      &#x3C;h1>{number}&#x3C;/h1>\n      &#x3C;button onClick={onIncrease}>+1&#x3C;/button>\n      &#x3C;button onClick={onDecrease}>-1&#x3C;/button>\n    &#x3C;/section>\n  );\n}\n</code></pre>\n<p>useReducer를 이용하면 다음과 같아진다.</p>\n<pre><code class=\"language-tsx\">const initialState = { count: 0 };\n\nfunction reducer(state: { count: number }, action: { type: string }) {\n  switch (action.type) {\n    case \"increment\":\n      return { count: state.count + 1 };\n    case \"decrement\":\n      return { count: state.count - 1 };\n    default:\n      throw new Error();\n  }\n}\n\nfunction Counter() {\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  const onIncrease = () => {\n    dispatch({ type: \"increment\" });\n  };\n\n  const onDecrease = () => {\n    dispatch({ type: \"decrement\" });\n  };\n\n  return (\n    &#x3C;section>\n      &#x3C;h1>{state.count}&#x3C;/h1>\n      &#x3C;button onClick={onIncrease}>+1&#x3C;/button>\n      &#x3C;button onClick={onDecrease}>-1&#x3C;/button>\n    &#x3C;/section>\n  );\n}\n</code></pre>\n<p>그런데 어쩐지 코드는 더 길어진 것 같고 딱히 해결된 문제는 없는 것 같다.. 대체 useReducer는 왜 쓰는 걸까? 이는 다음 글에서 알아보도록 하자.</p>\n<h1>6. useReducer의 동작을 개념적으로 이해해 보기</h1>\n<p>이 문단은 참고문헌에 있는 <a href=\"https://devtrium.com/posts/how-to-use-react-usereducer-hook#usereducer-a-backend-mental-model\">리액트 프로처럼 쓰기</a>글의 <code>useReducer: A Backend Mental Model</code>문단과 <a href=\"https://xo.dev/\">이창희</a>님과의 대화를 참고하여 작성되었다.</p>\n<p>useReducer를 사용해서 좋은 점에 대해서 알아보기 전에 먼저 useReducer가 어떤 식으로 작동하는지 직관적으로 이해해 보도록 하자. useReducer는 백엔드를 다루는 것과 비슷하게 생각할 수 있다.</p>\n<p>state를 데이터베이스로 생각하고 dispatch는 DB의 api로 생각하는 것이다. 이 dispatch에 주는 인자인 action으로 우리는 마치 다양한 api로 데이터베이스를 관리하듯이 state를 관리할 수 있다. action.type으로 어떤 종류의 api인지를 선택할 수 있고, action.payload로 api에 전달할 데이터를 넣을 수 있다. POST 메서드 같은 경우 request body에 데이터를 함께 전달하는데 그것과 비슷하다.</p>\n<p>그리고 reducer는 api의 내부 로직과 대응시켜 생각할 수 있다. 실제 백엔드 api의 경우 내부 로직과는 별개로 데이터베이스에 접근하는 방법을 제공한다. 예를 들어서 <code>AddUser</code> 라는 api가 있다면 이 api는 실제로는 어떤 DB 쿼리(혹은 ORM을 통한 DB 요청)를 날리는 것에 해당하는 동작을 할 것이다.</p>\n<p>하지만 이 api를 사용하는 사람은 그렇게 내부에서 무슨 일이 일어나는지를 알 필요가 없다. 그냥 <code>AddUser</code>라는 api를 호출하면 된다. 이와 비슷하게 useReducer를 사용하는 사람은 reducer의 내부 로직을 알 필요가 없다. dispatch에 action을 넣어서 호출하면 된다. 그러면 reducer 함수에서 알아서 모든 걸 처리해 준다.</p>\n<p>이런 상태 관리 로직의 분리는 실제로 useReducer의 장점이다. 그리고 이런 점이 useState와의 차별점을 만든다.</p>\n<h2>6.1. 비슷하게 구현</h2>\n<p>리액트 공식 문서에선 useReducer를 비슷하게 구현해 보는 예제도 제공한다. 매우 짧은 코드로 action을 받아서 reducer를 호출하고 그 결과를 state로 만드는 코드를 구현할 수 있다.</p>\n<pre><code class=\"language-tsx\">function useReducer(reducer, initialState){\n  const [state, setState] = useState(initialState);\n\n  function dispatch(action){\n    setState(prev=>reducer(prev, action));\n  }\n\n  return [state, dispatch];\n}\n</code></pre>\n<h1>참고</h1>\n<p>벨로퍼트의 모던 리액트 useReducer 항목 <a href=\"https://react.vlpt.us/basic/20-useReducer.html\">20. useReducer 를 사용하여 상태 업데이트 로직 분리하기 · GitBook</a></p>\n<p>React 공식 문서의 useReducer <a href=\"https://ko.reactjs.org/docs/hooks-reference.html#usereducer\">https://ko.reactjs.org/docs/hooks-reference.html#usereducer</a></p>\n<p>새로운 React 공식 문서의 useReducer 튜토리얼 <a href=\"https://react.dev/learn/extracting-state-logic-into-a-reducer\">https://react.dev/learn/extracting-state-logic-into-a-reducer</a></p>\n<p>useReducer의 사용에 관한 구체적인 글 <a href=\"https://devtrium.com/posts/how-to-use-react-usereducer-hook\">https://devtrium.com/posts/how-to-use-react-usereducer-hook</a></p>\n<p>useReducer가 최적화에 도움이 될 때 <a href=\"https://stackoverflow.com/questions/54646553/usestate-vs-usereducer\">https://stackoverflow.com/questions/54646553/usestate-vs-usereducer</a></p>\n<p>useReducer를 언제 써야 하는지와 써야하는 이유에 관한 짧은 글 <a href=\"https://dev.to/spukas/3-reasons-to-usereducer-over-usestate-43ad#:%7E:text=useReducer()%20is%20an%20alternative,understand%20for%20you%20and%20colleagues\">https://dev.to/spukas/3-reasons-to-usereducer-over-usestate-43ad#:%7E:text=useReducer()%20is%20an%20alternative,understand%20for%20you%20and%20colleagues</a></p>",
    "excerpt": "(2023-11-13 업데이트)\n1. 시작\n리액트를 가르치는 많은 문서에서 useReducer라는 상태 관리 기법을 소개하고 있다. 하지만 어렴풋이 이런 게 있다는 것만 알 뿐 딱히 사용해본 적은 없었다. 그래서 이번에 useReducer의 기능, 장점과 사용처를 알아보겠다. 마침 새로 업데이트된 리액트 공식 문서에도 이 부분이 있었다.\n2. useReducer의 기본형태\nReact에서는 useState라는 상태 관리 기법을 제공한다. 그리고 리액트를 쓰는 사람",
    "headingTree": [
      {
        "title": "1. 시작",
        "url": "#1-시작",
        "items": []
      },
      {
        "title": "2. useReducer의 기본형태",
        "url": "#2-usereducer의-기본형태",
        "items": []
      },
      {
        "title": "3. reducer 함수에 대하여",
        "url": "#3-reducer-함수에-대하여",
        "items": [
          {
            "title": "3.1. reducer의 유래",
            "url": "#31-reducer의-유래",
            "items": []
          }
        ]
      },
      {
        "title": "4. dispatch 함수의 사용",
        "url": "#4-dispatch-함수의-사용",
        "items": []
      },
      {
        "title": "5. useReducer의 사용법 - Counter 예제",
        "url": "#5-usereducer의-사용법---counter-예제",
        "items": []
      },
      {
        "title": "6. useReducer의 동작을 개념적으로 이해해 보기",
        "url": "#6-usereducer의-동작을-개념적으로-이해해-보기",
        "items": [
          {
            "title": "6.1. 비슷하게 구현",
            "url": "#61-비슷하게-구현",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 2,
      "wordCount": 461
    },
    "url": "/posts/react-usereducer-basic",
    "thumbnail": {
      "local": "/static/reducer-structure-6e742cb7.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-reducer-structure-6e742cb7-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAICAIAAACzjdIrAAAACXBIWXMAAAsTAAALEwEAmpwYAAAATklEQVR4nBXKIRVAMQgF0FcBuSSLQBXsKrwMpJlFY9Fo9AL886++MDNVJYmIIFlVqCqSM4PM3HtnJtx9reXumBlVfe/975zT3bj3ikhEfKpsK28JC+cPAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "react-test-3",
    "title": "React Testing - Jest 3",
    "date": "2023-03-01T03:00:00Z",
    "description": "프론트에 테스트 도입을 위한 공부, 카운터 만들기",
    "tags": [
      "javascript"
    ],
    "html": "<h1>1. 카운터 제작</h1>\n<p>간단하게 +, - 버튼이 있고 누르면 숫자가 증가하고 감소하는 카운터를 만든다고 해보자. 핵심 기능은 무엇일까? 당연히 숫자가 증가하고 감소하는 것이다. 그럼 이 기능을 테스트 해보자.</p>\n<p>물론 버튼이 제대로 렌더링되어 있는지, 숫자 컴포넌트가 제대로 렌더링되어 있는지 등도 테스트할 수 있을 것이다. 하지만 그런 건 리액트를 믿기로 한다. 우리가 해야 할 건 사용자가 버튼을 누르는 동작을 했을 때 그 의도가 제대로 작동하는지이다.</p>\n<h1>2. 테스트 작성</h1>\n<p>간단하게, section 요소 내부에 숫자를 보여주는 h1 요소, +, - 버튼을 보여주는 button 요소가 있다고 할 것이다. 그리고 그냥 cra로 만든 프로젝트에 기본으로 있는 App 컴포넌트에 이를 구현할 것이다.</p>\n<p>그럼 +버튼을 눌렀을 때 1 증가하는 테스트는 다음과 같이 작성할 수 있다. 카운터 초기값은 0이라고 생각하자.</p>\n<pre><code class=\"language-js\">test(\"when plus button is clicked then counter increases\", () => {\n  const user = userEvent.setup();\n  render(&#x3C;App />);\n  const plusButton = screen.getByRole(\"button\", { name: \"+\" });\n  user.click(plusButton);\n  const counterElement = screen.getByRole(\"heading\");\n  expect(counterElement).toHaveTextContent(\"1\");\n});\n</code></pre>\n<p>아니면 좀 더 세련되게 이렇게 작성할 수도 있겠다. 초기값이 0이라는 보장은 없으니까, 초기값을 가져와서 1을 더해주는 방식이다.</p>\n<pre><code class=\"language-js\">test(\"when plus button is clicked then counter increases\", () => {\n  const user = userEvent.setup();\n  render(&#x3C;App />);\n  const counterElement = screen.getByRole(\"heading\");\n  const counterValue = parseInt(counterElement.textContent || \"0\");\n  const plusButton = screen.getByRole(\"button\", { name: \"+\" });\n  user.click(plusButton);\n  expect(counterElement).toHaveTextContent((counterValue + 1).toString());\n});\n</code></pre>\n<p><code>npm test</code>를 해보면 당연히 테스트는 실패한다. 하지만 먼저 <code>-</code>버튼 테스트도 작성해 보자. 비슷하게 작성하면 된다.</p>\n<pre><code class=\"language-js\">test(\"when minus button is clicked then counter decreases\", () => {\n  const user = userEvent.setup();\n  render(&#x3C;App />);\n  const counterElement = screen.getByRole(\"heading\");\n  const counterValue = parseInt(counterElement.textContent || \"0\");\n  const minusButton = screen.getByRole(\"button\", { name: \"-\" });\n  user.click(minusButton);\n  expect(counterElement).toHaveTextContent((counterValue - 1).toString());\n});\n</code></pre>\n<h1>3. 컴포넌트 구현</h1>\n<p>이제 한번 카운터를 직접 구현해 보자. 간단한 것이니 금방 할 수 있다.</p>\n<pre><code class=\"language-js\">function App() {\n  const [count, setCount] = useState(0);\n\n  return (\n    &#x3C;section title=\"counter\">\n      &#x3C;h1>{count}&#x3C;/h1>\n      &#x3C;button\n        onClick={() => {\n          setCount((prev) => prev + 1);\n        }}\n      >\n        +\n      &#x3C;/button>\n      &#x3C;button\n        onClick={() => {\n          setCount((prev) => prev - 1);\n        }}\n      >\n        -\n      &#x3C;/button>\n    &#x3C;/section>\n  );\n}\n</code></pre>\n<h1>4. 테스트 고치기</h1>\n<p>음..하지만 이렇게 하면 테스트가 실패한다. 그런데 어플리케이션은 잘 동작한다. 왜 그럴까?</p>\n<p>위 테스트 코드의 다음 부분을 본다.</p>\n<pre><code class=\"language-js\">user.click(plusButton);\nexpect(counterElement).toHaveTextContent((counterValue + 1).toString());\n</code></pre>\n<p>plusButton을 클릭한 후 counterValue를 가져와서 1을 더한 값을 텍스트로 가지고 있는지 확인하는 것이다. 그런데 이 테스트는 비동기적으로 동작한다. 일단 user.click부터가 Promise로 동작하니까. (그리고 Testing Lib 문서에서도 userEvent들에 await을 붙이고 있었다)</p>\n<p>따라서 await을 붙여서 click이벤트가 끝난 후 요소에 접근하도록 하자. 다음과 같이 테스트를 수정한다.</p>\n<pre><code class=\"language-js\">test(\"when plus button is clicked then counter increases\", async () => {\n  const user = userEvent.setup();\n  render(&#x3C;App />);\n  const counterElement = screen.getByRole(\"heading\");\n  const counterValue = parseInt(counterElement.textContent || \"0\");\n  const plusButton = screen.getByRole(\"button\", { name: \"+\" });\n  await user.click(plusButton);\n  expect(counterElement).toHaveTextContent((counterValue + 1).toString());\n});\n\ntest(\"when minus button is clicked then counter decreases\", async () => {\n  const user = userEvent.setup();\n  render(&#x3C;App />);\n  const counterElement = screen.getByRole(\"heading\");\n  const counterValue = parseInt(counterElement.textContent || \"0\");\n  const minusButton = screen.getByRole(\"button\", { name: \"-\" });\n  await user.click(minusButton);\n  expect(counterElement).toHaveTextContent((counterValue - 1).toString());\n});\n</code></pre>\n<p>이제 <code>npm test</code>를 해보면 테스트가 성공한다.</p>\n<h1>5. 테스트 추가</h1>\n<p>위의 테스트는 1번만 버튼을 눌러본다. 하지만 여러번 눌러도 제대로 동작하는지 테스트해야 한다. 그럼 다음과 같이 테스트를 추가해 보자.</p>\n<pre><code class=\"language-js\">test(\"plus button 100 times\", async () => {\n  const user = userEvent.setup();\n  render(&#x3C;App />);\n\n  const plusButton = screen.getByRole(\"button\", { name: \"+\" });\n  for (let i = 0; i &#x3C; 100; i++) {\n    await user.click(plusButton);\n  }\n  const counterElement = screen.getByRole(\"heading\");\n  expect(counterElement).toHaveTextContent(\"100\");\n});\n</code></pre>\n<p>npm test로 확인해 보면 카운터가 반복적인 클릭에도 잘 작동함을 확인할 수 있다. 카운터 감소 버튼에도 비슷하게 테스트를 작성할 수 있을 것이다.</p>\n<p>CSS같은 건 설정하지 않아서 볼품없지만 일단은 테스트와 함께 카운터를 작성해 보았다.</p>\n<h1>참고</h1>\n<p><a href=\"https://jbee.io/react/testing-2-react-testing/\">https://jbee.io/react/testing-2-react-testing/</a></p>",
    "excerpt": "1. 카운터 제작\n간단하게 +, - 버튼이 있고 누르면 숫자가 증가하고 감소하는 카운터를 만든다고 해보자. 핵심 기능은 무엇일까? 당연히 숫자가 증가하고 감소하는 것이다. 그럼 이 기능을 테스트 해보자.\n물론 버튼이 제대로 렌더링되어 있는지, 숫자 컴포넌트가 제대로 렌더링되어 있는지 등도 테스트할 수 있을 것이다. 하지만 그런 건 리액트를 믿기로 한다. 우리가 해야 할 건 사용자가 버튼을 누르는 동작을 했을 때 그 의도가 제대로 작동하는지이다.\n2. 테스트 작성",
    "headingTree": [
      {
        "title": "1. 카운터 제작",
        "url": "#1-카운터-제작",
        "items": []
      },
      {
        "title": "2. 테스트 작성",
        "url": "#2-테스트-작성",
        "items": []
      },
      {
        "title": "3. 컴포넌트 구현",
        "url": "#3-컴포넌트-구현",
        "items": []
      },
      {
        "title": "4. 테스트 고치기",
        "url": "#4-테스트-고치기",
        "items": []
      },
      {
        "title": "5. 테스트 추가",
        "url": "#5-테스트-추가",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 290
    },
    "url": "/posts/react-test-3",
    "thumbnail": {
      "local": "/thumbnails/react-test-3-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-react-test-3-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAdUlEQVR4nGMoKyuzt7cvKiry9PQ0NjYOCwv7DwYMbe3tvLy8lZWVR44c2bJly7x586ASy5Ytt7GxaWlpgfDhgOHAgQO1tbWLFi36/v37bzCASty4devOnbsPHzx4/fo1io5JU2f29ffPmzfvwoUL////h+sAAEVMbN/ELmoeAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "react-usereducer-usage",
    "title": "React 탐구생활 - useReducer 활용",
    "date": "2022-09-18T00:00:00Z",
    "description": "React useReducer를 사용하는 이유에 대한 탐구",
    "tags": [
      "web",
      "study",
      "front",
      "react"
    ],
    "html": "<p>(2023-11-13 업데이트)</p>\n<h1>1. 시작</h1>\n<p>이번 글에서는 useReducer를 왜 사용하는지에 대해 알아보고자 한다.</p>\n<h1>2. useReducer의 활용</h1>\n<p>그럼 이제 useReducer가 어떤 문법으로 작동하는지도 알았고 백엔드와 같이 특정 데이터를 api를 통해 관리하는 모델처럼 볼 수 있다는 점도 알았다. 이제 useReducer를 어떻게 활용할 수 있는지 알아보자.</p>\n<p>여러 시행착오를 겪고 또 많은 사람들(<a href=\"https://xo.dev/\">이창희</a>와 <a href=\"https://github.com/CreeJee\">유동근</a>님 등등)과 논의한 결과, useReducer를 사용할 때 얻을 수 있는 이점은 다음과 같다.</p>\n<ol>\n<li>상태 관리 로직을 분리함으로써 상태 업데이트의 내부 로직을 알지 않아도 상태를 사용할 수 있게 되고 복잡한 상태 관리가 편해진다는 점. 즉 상태 업데이트 로직을 은닉할 수 있다는 점</li>\n<li>상태 업데이트 시 새로운 상태를 검증하는 등, 어떤 동작을 같이 해 줘야 할 경우 새로운 함수를 만들지 않고도 reducer에 로직을 추가하는 식으로 작성할 수 있다는 점</li>\n<li>상태 업데이트를 담당하는 dispatch가 순수 함수이므로 테스팅에 이점이 있다는 점. 아예 리듀서 함수만 별개로 테스트하여 상태 업데이트 로직을 테스트할 수도 있다.</li>\n<li>useState를 사용하는 것에 비해 리렌더링 최적화가 쉬울 수 있는 점</li>\n<li>하나의 함수에서 상태 업데이트 로직을 모두 담당하고 있으므로 디버깅 등을 할 때 어디서 버그가 발생했는지 알아내기 쉬울 수 있다는 점</li>\n</ol>\n<p>반면 단점도 있다. useReducer를 사용하면 리듀서 함수와 dispatch에 전달할 action까지 작성해야 해서 코드가 더 길어진다. 그리고 간단한 업데이트 로직의 경우 오히려 useState를 쓰는 것보다 코드 구조를 복잡하게 만든다.</p>\n<p>이 각각의 경우를 하나씩 알아보도록 하자.</p>\n<h1>3. 복잡한 state를 관리하는 경우</h1>\n<h2>3.1 useState를 사용</h2>\n<p>useReducer를 사용하면 상태 로직을 컴포넌트에서 분리하여 여러 개의 state와 그 상태들이 얽힌 동작을 편리하게 관리할 수 있다는 장점이 있다. 예를 들어서 회원가입 컴포넌트를 만든다고 하자. 이 컴포넌트는 이름, 아이디, 이메일, 비밀번호, 비밀번호 확인 등의 정보를 입력받아야 한다. 일단 이 5개의 요소만 받아서 회원가입을 시켜준다고 해보자. 이렇게 여러 개의 state를 관리해야 하는 경우에는 useState를 사용하면 다음과 같이 폼 관리 로직을 작성할 수 있다.</p>\n<pre><code class=\"language-tsx\">interface SignUpFormType {\n  \"User Name\": string;\n  \"User ID\": string;\n  \"User Email\": string;\n  \"User Password\": string;\n  \"User Confirm Password\": string;\n}\n\nconst initialSignUpForm: SignUpFormType = {\n  \"User Name\": \"\",\n  \"User ID\": \"\",\n  \"User Email\": \"\",\n  \"User Password\": \"\",\n  \"User Confirm Password\": \"\",\n};\n\nfunction SignUpForm() {\n  const [userSignUpForm, setUserSignUpForm] = useState(initialSignUpForm);\n\n  const handleChange = (e: React.ChangeEvent&#x3C;HTMLInputElement>) => {\n    setUserSignUpForm({\n      ...userSignUpForm,\n      [e.target.name]: e.target.value,\n    });\n  };\n\n  return (\n    &#x3C;section>\n      &#x3C;h1>Sign Up&#x3C;/h1>\n      &#x3C;form\n        style={{ display: \"flex\", flexDirection: \"column\", width: \"180px\" }}\n      >\n        {Object.keys(userSignUpForm).map((key) => (\n          &#x3C;label key={key}>\n            {key}\n            &#x3C;input\n              type=\"text\"\n              id={key}\n              name={key}\n              value={userSignUpForm[key]}\n              onChange={handleChange}\n            />\n          &#x3C;/label>\n        ))}\n        &#x3C;button type=\"submit\">Sign Up&#x3C;/button>\n      &#x3C;/form>\n    &#x3C;/section>\n  );\n}\n</code></pre>\n<p>스타일링을 하지 않아서 별로 볼품은 없지만 다음과 같은 간단한 회원가입 폼이 완성되었다.</p>\n<p><img src=\"/static/signupform-4ae2b9e0.png\" alt=\"signupform\"></p>\n<h2>3.2 useReducer를 이용한 경우</h2>\n<p>같은 타입과 <code>initialSignUpForm</code>을 사용하고 useReducer를 이용하여 같은 동작의 코드를 다음과 같이 작성할 수도 있다.</p>\n<pre><code class=\"language-tsx\">const signUpReducer = (\n  state: SignUpFormType,\n  action: { type: string; payload: { key: string; value: string } }\n) => {\n  switch (action.type) {\n    case \"UPDATE\":\n      return {\n        ...state,\n        [action.payload.key]: action.payload.value,\n      };\n    default:\n      throw new Error(`Unknown action type: ${action.type}`);\n  }\n};\n\nconst ReducerSignUpForm = () => {\n  const [state, dispatch] = useReducer(signUpReducer, initialSignUpForm);\n\n  const handleChange = (e: React.ChangeEvent&#x3C;HTMLInputElement>) => {\n    dispatch({\n      type: \"UPDATE\",\n      payload: {\n        key: e.target.name,\n        value: e.target.value,\n      },\n    });\n  };\n\n  return (\n    &#x3C;section>\n      &#x3C;h1>Sign Up&#x3C;/h1>\n      &#x3C;form\n        style={{ display: \"flex\", flexDirection: \"column\", width: \"180px\" }}\n        onSubmit={handleSubmit}\n      >\n        {Object.keys(state).map((key) => (\n          &#x3C;label key={key}>\n            {key}\n            &#x3C;input\n              type=\"text\"\n              id={key}\n              name={key}\n              value={userSignUpForm[key]}\n              onChange={handleChange}\n            />\n          &#x3C;/label>\n        ))}\n        &#x3C;button type=\"submit\">Sign Up&#x3C;/button>\n      &#x3C;/form>\n    &#x3C;/section>\n  );\n};\n</code></pre>\n<h2>3.3 useState, useReducer의 비교</h2>\n<p>useReducer를 사용하는 코드를 보자. 업데이트 함수를 사용하는 측에서는 Action만 잘 만들어서 dispatch 함수로 전달하면 reducer함수가 알아서 상태를 변경해 준다. 상태 업데이트 내부 로직을 신경쓰지 않아도 코드를 짤 수 있게 된 것이다.</p>\n<p><code>ReducerSignUpForm</code> 컴포넌트에서는 다른 사람이 작성했을 수도 있을 dispatch 함수 내에서 어떻게 업데이트를 하는지 신경쓰지 않고도 상태를 업데이트할 수 있는 것이다! 반면 useState를 사용할 경우 상태 업데이트 로직은 <code>SignUpForm</code>내에 존재해야 한다.</p>\n<p>이는 생각보다 편리한 기능이다. 예를 들어서 어떤 이유로 회원가입 폼을 리셋하는 기능을 만들어야 한다면 useState를 사용하는 경우 다음과 같은 함수를 회원가입 폼 컴포넌트 내에 새로 만들어 줘야 한다. 이 함수는 <code>SignUpForm</code>내에 작성해야 한다.</p>\n<pre><code class=\"language-tsx\">const signUpFormReset = () => {\n  setUserSignUpForm(initialSignUpForm);\n};\n</code></pre>\n<p>그러나 reducer 함수를 사용한다면 reducer 함수에 적당한 리셋 로직을 추가해주면 된다. 이는 reducer 함수를 작성하는 사람이 알아서 해주면 되는 일이다. 그리고 사용하는 측에서는 그저 다음과 같이 쓰면 된다.</p>\n<pre><code class=\"language-tsx\">const signUpFormReset = () => {\n  dispatch({\n    type: \"RESET\",\n  });\n};\n</code></pre>\n<p>이 회원가입 폼은 작은 컴포넌트이므로 모든 로직을 한 곳에 모아두는 것이 좋다고 생각할 수 있다. 하지만 컴포넌트가 커지고 복잡해지면 이런 방식은 유지보수하기가 어려워진다.</p>\n<p>그럴 때는 useReducer를 사용하여 관리 로직을 다른 곳에 분리하는 것이 좋다. state업데이트 함수와 그 활용을 하나의 컴포넌트에 몰아넣는 것보다는 신뢰할 수 있는 reducer함수를 작성한 후 거기에 상태 관리를 맡기는 것이 더 유지보수하기 편해진다.</p>\n<p>또한 useReducer와 useContext 훅을 함께 사용하는 테크닉도 있다. dispatch 함수를 ContextProvider를 이용해서 하위 컴포넌트로 내려보내면 하위 컴포넌트에서는 dispatch만을 이용해서 상태를 업데이트할 수 있다.</p>\n<h1>4. state를 설정할 때 특정 작업을 함께하는 경우</h1>\n<p>어떤 작업을 실행하기 전에 특정 작업을 함께 실행해야 하는 경우가 있다. 예를 들어서 회원가입 폼을 업데이트하기 전에 유효성 검사를 해야 하는 경우가 그렇다. 이런 경우에는 <code>useReducer</code>를 사용하면 편리하다.</p>\n<p>회원가입 폼에 아이디를 작성할 때 10글자 이상은 타이핑할 수 없도록 한다고 해보자. 그러면 다음과 같이 handleChange 함수 자체를 바꿀 수도 있다.</p>\n<pre><code class=\"language-tsx\">const handleChange = (e: React.ChangeEvent&#x3C;HTMLInputElement>) => {\n  if (userSignUpForm[\"User ID\"].length &#x3C;= 10) {\n    setUserSignUpForm({\n      ...userSignUpForm,\n      [e.target.name]: e.target.value,\n    });\n  }\n};\n</code></pre>\n<p><code>handleUserIDChange</code>와 같은 새로운 함수를 작성해서 할 수도 있다. 하지만 useState가 제공해 주는 <code>state</code>, <code>setState</code>는 게터와 세터의 역할을 한다고도 할 수 있다. 그런데 이를 사용하는 쪽에서 세터에 전달하는 값을 따로 검증해야 한다는 건 뭔가 이상하다. 세터에서 자체적으로 값을 검증하면 더 좋을 것 같다.</p>\n<p>이런 방식의 코드를 useReducer에서 작성할 수 있다. 상태의 업데이트 자체를 담당하는 reducer 함수가 따로 있기에 가능하다. 다음과 같이 리듀서 함수를 작성해 주면 된다. 이렇게 하면 회원가입 폼 컴포넌트 코드는 단 한 글자도 바꾸지 않고도 회원가입 폼 입력시 검증이 가능해진다.</p>\n<pre><code class=\"language-tsx\">const signUpReducer = (\n  state: SignUpFormType,\n  action: { type: string; payload: { key: string; value: string } }\n) => {\n  switch (action.type) {\n    case \"UPDATE\":\n      if (state[\"User ID\"].length &#x3C;= 10) {\n        return {\n          ...state,\n          [action.payload.key]: action.payload.value,\n        };\n      } else {\n        return state;\n      }\n    default:\n      throw new Error(`Unknown action type: ${action.type}`);\n  }\n};\n</code></pre>\n<p>물론 이 코드를 그대로 쓸 수는 없다. 사용자가 작성한 아이디가 어떤 이유로 10글자를 넘었을 경우 아예 다른 칸의 변경을 막아버리기 때문이다. 위의 코드는 <code>useReducer</code>를 사용할 경우 상태 업데이트 함수가 세터의 역할을 더 잘 수행할 수 있다는 것을 보여주기 위한 예시 코드이다.</p>\n<h1>5. 리렌더링 최적화를 할 경우</h1>\n<p>리액트는 상태가 변경되면 컴포넌트를 리렌더링한다. 그런데 컴포넌트가 리렌더링되는 것은 비용이 큰 작업이다. 그래서 리렌더링을 최소화하는 것이 중요하다.</p>\n<p>그리고 리렌더링이 일어나는 조건 중 하나는 컴포넌트가 가지고 있는 state가 변경되는 것이다. 그런데 어떤 경우 하나의 함수에서 여러 개의 state를 업데이트해줘야 하는 경우가 있을 수 있다. 예를 들어서 3개의 색깔 칸을 표시하는 다음과 같은 코드를 보자.</p>\n<pre><code class=\"language-tsx\">function Colors() {\n  const [firstColor, setFirstColor] = useState(\"red\");\n  const [secondColor, setSecondColor] = useState(\"blue\");\n  const [thirdColor, setThirdColor] = useState(\"green\");\n\n  const setColorSet = () => {\n    setFirstColor(secondColor);\n    setSecondColor(thirdColor);\n    setThirdColor(firstColor);\n  };\n\n  return (\n    &#x3C;div style={{ display: \"flex\", flexDirection: \"row\" }}>\n      &#x3C;button onClick={setColorSet}>Red&#x3C;/button>\n      &#x3C;div\n        style={{ backgroundColor: firstColor, width: \"100px\", height: \"100px\" }}\n      >&#x3C;/div>\n      &#x3C;div\n        style={{\n          backgroundColor: secondColor,\n          width: \"100px\",\n          height: \"100px\",\n        }}\n      >&#x3C;/div>\n      &#x3C;div\n        style={{ backgroundColor: thirdColor, width: \"100px\", height: \"100px\" }}\n      >&#x3C;/div>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<p>이렇게 코드를 작성할 시 3번 리렌더링되게 된다.(React 17까지 그렇다.) 하지만 이를 useReducer로 작성하면 1번만 리렌더링되게 된다. reducer를 활용하면 상태가 1번만 변경되기 때문이다.</p>\n<h1>6. 테스트를 작성할 경우</h1>\n<p>동일한 인자를 주었을 때 늘 동일한 인자를 반환하며 부수 효과가 없는 순수 함수는 테스트하기 쉽다. 시간이나 여러 가지 이유로 e2e 테스트를 작성하지 못하더라도 프로그램에 쓰이는 순수 함수의 경우 아예 따로 테스트를 작성할 수도 있다.</p>\n<p>useReducer에 전달하는 reducer 함수 역시 순수 함수이므로 같은 이점을 가져간다.</p>\n<h1>참고</h1>\n<p>벨로퍼트의 모던 리액트 useReducer 항목 <a href=\"https://react.vlpt.us/basic/20-useReducer.html\">20. useReducer 를 사용하여 상태 업데이트 로직 분리하기 · GitBook</a></p>\n<p>React 공식 문서의 useReducer <a href=\"https://ko.reactjs.org/docs/hooks-reference.html#usereducer\">https://ko.reactjs.org/docs/hooks-reference.html#usereducer</a></p>\n<p>useReducer의 사용에 관한 구체적인 글 <a href=\"https://devtrium.com/posts/how-to-use-react-usereducer-hook\">https://devtrium.com/posts/how-to-use-react-usereducer-hook</a></p>\n<p>useReducer가 최적화에 도움이 될 때 <a href=\"https://stackoverflow.com/questions/54646553/usestate-vs-usereducer\">https://stackoverflow.com/questions/54646553/usestate-vs-usereducer</a></p>\n<p>useReducer를 언제 써야 하는지와 써야하는 이유에 관한 짧은 글 <a href=\"https://dev.to/spukas/3-reasons-to-usereducer-over-usestate-43ad#:%7E:text=useReducer()%20is%20an%20alternative,understand%20for%20you%20and%20colleagues\">https://dev.to/spukas/3-reasons-to-usereducer-over-usestate-43ad#:%7E:text=useReducer()%20is%20an%20alternative,understand%20for%20you%20and%20colleagues</a></p>\n<p>순수 함수에 관하여 <a href=\"https://www.learnhowtoprogram.com/react/functional-programming-with-javascript/pure-functions\">https://www.learnhowtoprogram.com/react/functional-programming-with-javascript/pure-functions</a></p>",
    "excerpt": "(2023-11-13 업데이트)\n1. 시작\n이번 글에서는 useReducer를 왜 사용하는지에 대해 알아보고자 한다.\n2. useReducer의 활용\n그럼 이제 useReducer가 어떤 문법으로 작동하는지도 알았고 백엔드와 같이 특정 데이터를 api를 통해 관리하는 모델처럼 볼 수 있다는 점도 알았다. 이제 useReducer를 어떻게 활용할 수 있는지 알아보자.\n여러 시행착오를 겪고 또 많은 사람들(이창희와 유동근님 등등)과 논의한 결과, useReducer",
    "headingTree": [
      {
        "title": "1. 시작",
        "url": "#1-시작",
        "items": []
      },
      {
        "title": "2. useReducer의 활용",
        "url": "#2-usereducer의-활용",
        "items": []
      },
      {
        "title": "3. 복잡한 state를 관리하는 경우",
        "url": "#3-복잡한-state를-관리하는-경우",
        "items": [
          {
            "title": "3.1 useState를 사용",
            "url": "#31-usestate를-사용",
            "items": []
          },
          {
            "title": "3.2 useReducer를 이용한 경우",
            "url": "#32-usereducer를-이용한-경우",
            "items": []
          },
          {
            "title": "3.3 useState, useReducer의 비교",
            "url": "#33-usestate-usereducer의-비교",
            "items": []
          }
        ]
      },
      {
        "title": "4. state를 설정할 때 특정 작업을 함께하는 경우",
        "url": "#4-state를-설정할-때-특정-작업을-함께하는-경우",
        "items": []
      },
      {
        "title": "5. 리렌더링 최적화를 할 경우",
        "url": "#5-리렌더링-최적화를-할-경우",
        "items": []
      },
      {
        "title": "6. 테스트를 작성할 경우",
        "url": "#6-테스트를-작성할-경우",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 2,
      "wordCount": 468
    },
    "url": "/posts/react-usereducer-usage",
    "thumbnail": {
      "local": "/static/signupform-4ae2b9e0.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-signupform-4ae2b9e0-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAICAIAAABVpBlvAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAe0lEQVR4nDXMIRZFERCA4bsHS5EtwhIUXZokS5MmSYokSZYhSZNswAIk97jnvT9+4X+klEIIADj/nlKKc661ds7Ze1/KOdda55zMvNa6FEIAgN77+rqUUgIARBxj/CjG6L9KKWOMS0TkvTfGaK0Rce9994iolLLWEhEzv48MY1iNpVSsAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "sinchon-attendance-page",
    "title": "신촌연합 알고리즘 캠프 출석 페이지 만들기 - 개발",
    "date": "2024-02-27T10:00:00Z",
    "description": "개발 환경을 세팅해 보자",
    "tags": [
      "typescript",
      "javascript",
      "web"
    ],
    "html": "<h1>1. 디자인 구현</h1>",
    "excerpt": "1. 디자인 구현",
    "headingTree": [
      {
        "title": "1. 디자인 구현",
        "url": "#1-디자인-구현",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 0
    },
    "url": "/posts/sinchon-attendance-page",
    "thumbnail": {
      "local": "/thumbnails/sinchon-attendance-page-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-sinchon-attendance-page-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAkUlEQVR4nD3IMQrDIBQAUDdvkNW7uLhkDk4u4gU8gqfICRxaSqkUpFlSMuUQGUITpwz9IDgJv1PzxkdijFJKIYTW2lrbdZ3WmnNOjDGMsbZtm6ZRSjnnKKXeezLPc9/3IYRxfKeUAGCappwzKaUcxwEAtVb8q7WS9bNt+55S+gKci4jk/nherrdheC3Lci4i/gCyvGarbTbVmAAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "sinchon-attendance-project",
    "title": "신촌연합 알고리즘 캠프 출석 페이지 만들기 - 개발 환경 세팅",
    "date": "2024-03-10T00:00:00Z",
    "description": "개발 환경을 세팅해 보자",
    "tags": [
      "typescript",
      "javascript",
      "web"
    ],
    "html": "<h1>1. 시작</h1>\n<p><a href=\"https://icpc-sinchon.io/\">ICPC Sinchon(이하 신촌연합)</a>에서 프로그램 관리팀을 맡게 되었다. 이왕 하게 된 프로젝트 잘 해보자 싶기도 하고, 새롭게 해보는 것도 많아서 이곳에 기록을 남기기 시작한다.</p>\n<p>이 글에서는 신촌연합의 알고리즘 캠프 출석 페이지를 개선하는 과정 중 개발 환경 세팅에 관한 부분을 다룬다. 기본적인 구상과 패키지 매니저, 기본적인 웹팩 설정이 될 것이다.</p>\n<h2>1.1. 배경</h2>\n<p>나는 오래 전부터 <a href=\"https://icpc-sinchon.io/\">ICPC Sinchon(이하 신촌연합)</a>에서 활동해왔다. <a href=\"https://witch.work/posts/sinchon-camp-2021-summer\">그곳에서 강의를 듣기도 했고</a> 시간이 지나 실력이 조금 붙자 <a href=\"https://github.com/witch-factory/2022-winter-sinchon-lecture\">거기서 강사 활동을 하기도 했다.</a></p>\n<p>그리고 <a href=\"https://github.com/Goldchae\">신촌연합의 캠프장을 맡은 분</a>과 식사를 하다가 그곳의 갖가지 일을 돕게 되었다. 그 중 첫번째가 바로 알고리즘 강의의 출석 페이지를 개선하는 거였다. <a href=\"https://noguen.tistory.com/\">다른 운영진</a>분께서 디자인도 간단히 해주셨다.</p>\n<p>그곳의 개발을 시작하면서 했던 설정들을 정리하는 글이다.</p>\n<h2>1.2. 기존 구성</h2>\n<p>기존의 페이지에도 필요한 요소들은 있었고 디자인도 괜찮았다. 애초에 여러 컴포넌트들이 그냥 피그마로 만든 이미지를 삽입한 거라서 깔끔한 편이었다.</p>\n<p><img src=\"/static/attendance-page-e4b9dbe7.png\" alt=\"출석 페이지\"></p>\n<p>하지만 개발 환경이나 로직 설계에 있어서는 그렇게 잘 되어 있지 못했다. HTML, CSS, 바닐라 JS로만 짜여 있었고 CSS로 해결할 수 있는 부분도 이미지를 삽입해서 만들고 있었다. 라이브러리는 <code>&#x3C;script></code>태그의 CDN을 통해서 사용하고 있었고 번들 용량에서 낭비되는 부분도 많았다. 내비게이션 바 하나를 위해서 <code>bootstrap</code> 전체를 사용하고 있는 등이었다.</p>\n<p>개발 서버 세팅 등도 되어 있지 않았다. 또한 사용자를 위한 페이지는 firebase로, 관리자를 위한 페이지는 repl.it에서 호스팅되고 있는 등 배포도 흩어져 있었다.</p>\n<p>이를 좀더 나은 구조로 리팩토링하고, React와 TypeScript를 도입하고, 패키지 매니저를 사용하고, 빌드를 통해서 배포할 수 있게 만들어보는 작업을 진행하고자 한다. 이후에는 테스트도 도입하고자 한다.</p>\n<p>다만 모든 지식을 완벽히 알고 있는 상태에서 시작하는 것이 아니라서 미흡할 수 있다. 그래도 해나가는 과정을 여기 기록한다.</p>\n<p><code>create-vite</code>와 같은 프로젝트 템플릿을 사용해서 아예 갈아엎을 수도 있다. 하지만 기존에 이 코드를 작성하던 사람이 있고 이미 배포되어서 사용되고 있기 때문에, 최대한 원래의 선택과 기존의 구조를 보존하면서 시작하고자 한다.</p>\n<p>따라서 웹팩 등 프로젝트 설정을 거의 밑바닥부터 진행하고 리팩토링을 하겠다. 이 글에서는 프로젝트 설정에 관해서 다룬다.</p>\n<h2>1.3. 구상</h2>\n<p>해야 할 일은 다음과 같다.</p>\n<ul>\n<li>개발 환경 세팅</li>\n<li>사이트 구조 개편</li>\n<li>새로운 사이트 구조 설계</li>\n<li>국민 스택(?) React, TypeScript 도입</li>\n<li>배포를 firebase 기반으로 통일</li>\n<li>기존 코드 리팩토링</li>\n<li>향후 관리에 용이하도록 DB 구성 변경</li>\n<li>CI/CD 도입</li>\n<li>테스트 도입</li>\n</ul>\n<p>이 글에서는 개발 환경 세팅에 대해서 일단 다룬다.</p>\n<h1>2. 기본적인 세팅</h1>\n<p>먼저 각 프로젝트에는 다음과 같은 설정을 해주었다.</p>\n<h2>2.1. 패키지 매니저 설정</h2>\n<p>프로젝트 폴더에서 <code>npm init</code>으로 프로젝트 설정을 시작하자. 기본적인 <code>package.json</code>이 생성된다.</p>\n<pre><code class=\"language-json\">{\n  \"name\": \"sinchonattendance\",\n  \"version\": \"1.0.0\",\n  \"description\": \"### ...\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" &#x26;&#x26; exit 1\"\n  },\n  \"author\": \"\",\n  \"license\": \"ISC\"\n}\n</code></pre>\n<h2>2.2. eslint 설치</h2>\n<p>그리고 코드를 정적 분석해 문제를 찾아주는 툴인 <code>eslint</code>를 설치하자. <code>npm init @eslint/config</code>을 이용해서 빠르게 시작할 수 있다. 해당 커맨드를 입력하면 몇 가지 질문을 하고, 그에 따라 <code>.eslintrc.json</code> 파일이 생성된다. 나는 Typescript를 쓸 것이고 브라우저에서 코드를 돌릴 거라서 다음과 같이 선택했다.</p>\n<pre><code class=\"language-bash\">npm init @eslint/config\n✔ How would you like to use ESLint? · problems\n✔ What type of modules does your project use? · esm\n✔ Which framework does your project use? · none\n✔ Does your project use TypeScript? · No / Yes\n✔ Where does your code run? · browser\n✔ What format do you want your config file to be in? · JSON\n</code></pre>\n<p>또한 이후 나오는 패키지 매니저 질문에는 <code>yarn</code>을 쓰는 걸로 했다.</p>\n<h1>3. 웹팩 기본 설정</h1>\n<h2>3.1. 웹팩 설치와 기본 설정</h2>\n<p>이제 번들러를 설치하자. 나는 고전인 웹팩을 쓸 것이다. 최신 프레임워크인 nextjs에서조차도 아직 웹팩을 쓰고 있으니 아주 한물간 기술은 아니라고 생각한다.</p>\n<p><code>webpack</code>은 <code>webpack-cli</code>와 함께 설치해야 한다.</p>\n<pre><code class=\"language-bash\">yarn add webpack webpack-cli --dev\n</code></pre>\n<p>그리고 소스 파일을 만들자. 먼저 시험적으로 프로젝트 루트 경로에 <code>dist/index.html</code>을 만들고 <code>src/index.js</code>를 생성한다.</p>\n<p><code>dist/index.html</code>은 이후 빌드 결과물에 포함될 것이다.</p>\n<p>그리고 <code>package.json</code>에서 엔트리 포인트를 삭제하고 private를 true로 설정하자. 실수로 publish해버리는 것을 방지하는 옵션이라고 한다.</p>\n<pre><code class=\"language-json\">{\n  \"name\": \"sinchonattendance\",\n  \"version\": \"1.0.0\",\n  \"description\": \"### ...\",\n  \"main\": \"index.js\", // 삭제\n  \"private\": true, // 추가\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" &#x26;&#x26; exit 1\"\n  },\n  // ...\n}\n</code></pre>\n<p>그리고 기본적으로는 웹팩 번들링 결과물은 <code>main.js</code>이다. <code>dist/index.html</code>에서 이를 불러오도록 하자.</p>\n<pre><code class=\"language-html\">&#x3C;!DOCTYPE html>\n&#x3C;html>\n  &#x3C;head>\n    &#x3C;meta charset=\"utf-8\" />\n    &#x3C;title>Getting Started&#x3C;/title>\n  &#x3C;/head>\n  &#x3C;body>\n    &#x3C;script src=\"main.js\">&#x3C;/script>\n  &#x3C;/body>\n&#x3C;/html>\n</code></pre>\n<p><code>npx webpack</code>을 실행하면 <code>dist/main.js</code>가 생성된다. 이를 <code>dist/index.html</code>에서 불러오는 것이다.</p>\n<h2>3.2. 설정 파일 만들기</h2>\n<p>이제 설정 파일을 만들어보자 <code>npx webpack</code>을 실행할 때 이 설정 파일을 읽어서 빌드를 진행하도록 한다. 프로젝트 루트 경로에 <code>webpack.config.js</code>를 생성하자.</p>\n<p>물론 파일명이 <code>webpack.config.js</code>가 아니어도 된다. 웹팩 커맨드에서 <code>webpack --config 파일이름</code>과 같이 <code>--config</code> 옵션을 통해서 사용할 설정 파일의 이름을 지정할 수도 있다. 하지만 <code>webpack.config.js</code>가 기본 설정 파일명으로 지정되어 있고 굳이 바꿀 것도 없으니 이걸 사용하자.</p>\n<p>웹팩 공식 문서의 예시에 <code>mode</code>만 추가해서 다음과 같이 설정했다.</p>\n<pre><code class=\"language-js\">// webpack.config.js\nconst path = require(\"path\");\n\nmodule.exports = {\n  mode: \"development\",\n  entry: \"./src/index.js\",\n  output: {\n    filename: \"main.js\",\n    path: path.resolve(__dirname, \"dist\"),\n  },\n};\n</code></pre>\n<p><code>entry</code>는 웹팩이 파일을 번들링할 때 진입하는 지점이고 <code>output</code>은 번들링 결과물에 대한 설정이다. 즉 이는 개발 모드로 빌드하고, <code>src/index.js</code>를 번들링해서 <code>dist/main.js</code>에 저장하라는 의미이다.</p>\n<p><code>package.json</code>에 빌드 명령어도 추가하자.</p>\n<pre><code class=\"language-json\">{\n  // ...\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" &#x26;&#x26; exit 1\",\n    \"build\": \"webpack\"\n  },\n  // ...\n}\n</code></pre>\n<p>이렇게 하면 <code>yarn build</code>를 실행하면 <code>dist/main.js</code>가 생성된다.</p>\n<h1>4. 타입스크립트 설정</h1>\n<p>그다음엔 ts를 설치하자. 그리고 <code>tsx --init</code>으로 <code>tsconfig.json</code>을 생성했다.</p>\n<pre><code class=\"language-bash\">yarn add typescript --dev\nnpx tsc --init\n</code></pre>\n<p>그 다음 생성된 <code>tsconfig.json</code>을 다음과 같이 설정한다. <a href=\"https://stackblitz.com/edit/vitejs-vite-6uynas?file=tsconfig.json&#x26;terminal=dev\">vite의 react-ts 설정을 따와서 약간 수정했다.</a></p>\n<pre><code class=\"language-json\">{\n  \"compilerOptions\": {\n    \"target\": \"ES2020\",\n    \"useDefineForClassFields\": true,\n    \"lib\": [\"ES2020\", \"DOM\", \"DOM.Iterable\"],\n    \"module\": \"ES6\",\n    \"skipLibCheck\": true,\n\n    /* Bundler mode */\n    \"moduleResolution\": \"Node\",\n    \"allowImportingTsExtensions\": true,\n    \"resolveJsonModule\": true,\n    \"isolatedModules\": true,\n    \"noEmit\": true,\n    \"jsx\": \"react-jsx\",\n\n    \"esModuleInterop\": true,\n    \"forceConsistentCasingInFileNames\": true /* Ensure that casing is correct in imports. */,\n    /* Linting */\n    \"strict\": true,\n    \"noUnusedLocals\": true,\n    \"noUnusedParameters\": true,\n    \"noFallthroughCasesInSwitch\": true,\n\n    \"typeRoots\": [\"src/types\"],\n    \"outDir\": \"./dist/\"\n  },\n  \"include\": [\"src\"]\n}\n</code></pre>\n<h1>5. 리액트 설정</h1>\n<h2>5.1. 라이브러리 설치</h2>\n<p>리액트 사용을 위해 다음과 같이 라이브러리를 설치하자.</p>\n<pre><code class=\"language-bash\">yarn add react react-dom\nyarn add -D webpack-dev-server html-webpack-plugin\nyarn add -D @types/react @types/react-dom\nyarn add -D ts-loader\n</code></pre>\n<h2>5.2. 웹팩 설정 수정</h2>\n<p>그리고 <code>webpack.config.js</code>를 다음과 같이 수정하자. 기본적인 로더들과 플러그인을 추가했다.</p>\n<p>ts를 처리하도록 웹팩 설정을 바꾸자. <code>module.rules</code>에 <code>.ts</code>와 <code>.tsx</code>를 <code>ts-loader</code>로 처리하도록 추가하자. 그리고 <code>resolve.extensions</code>에 <code>.ts</code>와 <code>.tsx</code>를 추가하자. <code>./src/index.ts</code>를 통해 진입하고 빌드된 파일은 <code>./dist/bundle.js</code>에 저장하도록 설정했다.</p>\n<pre><code class=\"language-js\">const path = require(\"path\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\n\nmodule.exports = {\n  mode: \"development\",\n  entry: \"./src/index.tsx\",\n  output: {\n    filename: \"bundle.js\",\n    path: path.resolve(__dirname, \"dist\"),\n    clean: true,\n  },\n  resolve: {\n    modules: [path.resolve(__dirname, \"src\"), \"node_modules\"],\n    extensions: [\".tsx\", \".ts\", \".js\", \".jsx\", \".json\", \".css\"],\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(ts|tsx)$/,\n        use: \"ts-loader\",\n        exclude: /node_modules/,\n      },\n    ],\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      title: \"Sinchon Attendance Development\",\n      template: \"./src/index.html\",\n    }),\n  ]\n};\n</code></pre>\n<h2>5.3. 애셋 가져오기</h2>\n<p>웹팩에서 css, 이미지도 가져오도록 설정하자. <code>style-loader</code>와 <code>css-loader</code>를 설치하자.</p>\n<pre><code class=\"language-bash\">yarn add style-loader css-loader --dev\n</code></pre>\n<p>그리고 <a href=\"https://webpack.kr/guides/asset-management/\">Asset Management 공식 문서</a>를 참고하여 <code>webpack.config.js</code>의 <code>module</code>속성의 rules를 다음과 같이 수정하자.</p>\n<pre><code class=\"language-js\">const path = require(\"path\");\n\nmodule.exports = {\n  // ...\n  module: {\n    rules: [\n      {\n        test: /\\.tsx?$/,\n        use: \"ts-loader\",\n        exclude: /node_modules/,\n      },\n      {\n        test: /\\.css$/i,\n        use: [\"style-loader\", \"css-loader\"],\n      },\n      {\n        test: /\\.(png|svg|jpg|jpeg|gif)$/i,\n        type: \"asset/resource\",\n      },\n    ],\n  },\n  // ...\n};\n</code></pre>\n<h2>5.4. 개발 서버 설정</h2>\n<p>잘 되는지 확인하기 위해 기본적인 리액트 코드를 작성해보자.</p>\n<pre><code class=\"language-tsx\">// index.tsx\nimport \"./style.css\";\nimport App from \"./App\";\n\nimport React from \"react\";\nimport ReactDOM from \"react-dom/client\";\n\n// App은 따로 정의해준다\n\nReactDOM.createRoot(document.getElementById(\"root\")!).render(\n  &#x3C;React.StrictMode>\n    &#x3C;App />\n  &#x3C;/React.StrictMode>\n);\n</code></pre>\n<p>그리고 index.html은 이렇게.</p>\n<pre><code class=\"language-html\">&#x3C;!DOCTYPE html>\n&#x3C;html>\n  &#x3C;head>\n    &#x3C;meta charset=\"UTF-8\" />\n    &#x3C;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    &#x3C;meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1.0, user-scalable=no\"\n    />\n    &#x3C;meta property=\"og:image\" content=\"./image/240.png\" />\n    &#x3C;title>알고리즘캠프 출석체크&#x3C;/title>\n  &#x3C;/head>\n  &#x3C;body>\n    &#x3C;div id=\"root\">&#x3C;/div>\n  &#x3C;/body>\n&#x3C;/html>\n</code></pre>\n<p>이다음 개발 서버를 실행시켜서 화면이 잘 뜨는지 확인해 보자. 아까 <code>webpack-dev-server</code>를 설치했으니 이를 이용하면 된다. <code>package.json</code>에 다음 커맨드를 추가한다.</p>\n<pre><code class=\"language-json\">{\n  // ...\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" &#x26;&#x26; exit 1\",\n    \"dev\": \"webpack serve --mode development --open --hot\",\n    \"build\": \"webpack --mode production\"\n  },\n  // ...\n}\n</code></pre>\n<p>그리고 <code>webpack.config.js</code>에 다음과 같이 <code>devServer</code> 속성을 추가한다.</p>\n<pre><code class=\"language-js\">{\n  // ...\n  devServer: {\n    static: {\n      directory: path.join(__dirname, \"dist\"),\n    },\n    compress: true,\n    port: 9000,\n  },\n}\n</code></pre>\n<p>이제 <code>yarn dev</code> 명령어로 개발 서버를 실행하면 <code>localhost:9000</code>에서 개발 서버가 실행된다.</p>\n<p>만약 엔트리 포인트가 하나 이상이라면 <code>optimization</code>의 <code>runtimeChunk</code>를 <code>single</code>로 설정하자.</p>\n<pre><code class=\"language-js\">module.exports = {\n  // ...\n  optimization: {\n    runtimeChunk: \"single\",\n  },\n  // ...\n};\n</code></pre>\n<p>다만 여기서는 하나의 엔트리 포인트만 있기 때문에 이 옵션을 설정하지 않아도 된다.</p>\n<p>참고로 <code>webpack-dev-server</code>는 <code>output.path</code>에 정의된 디렉토리의 번들된 파일을 제공한다. 예를 들어 특정 파일은 다음 주소로 접근 가능하다.</p>\n<pre><code>http://[devServer.host]:[devServer.port]/[output.publicPath]/[output.filename]\n</code></pre>\n<h1>6. 개발 서버의 hot module replacement 설정</h1>\n<p>개발 서버 환경에 Hot Module Replacement (HMR)를 추가하는 것은 개발 과정을 더욱 효율적으로 만들어준다. HMR을 사용하면 애플리케이션을 개발 중에 변경사항을 저장할 때마다 전체 페이지를 새로고침하지 않고도 해당 변경사항을 반영할 수 있기 때문이다.</p>\n<h2>6.1. HMR 기본 설정</h2>\n<p>이를 위해서는 원래 <code>react-hot-loader</code>가 주로 쓰였다. 하지만 React의 fast refresh가 더 범용적이고 좋다고 한다. 따라서 <code>react-refresh</code>를 사용하자.</p>\n<pre><code class=\"language-bash\">yarn add -D @pmmmwh/react-refresh-webpack-plugin react-refresh\n</code></pre>\n<p>나는 <code>ts-loader</code>를 사용중이다. 그러니 <a href=\"https://github.com/pmmmwh/react-refresh-webpack-plugin\">react-refresh 공식 문서</a>를 참고하여 <code>react-refresh-typescript</code>를 설치해준다.</p>\n<pre><code class=\"language-bash\">yarn add -D react-refresh-typescript\n</code></pre>\n<p>그리고 <code>webpack.config.js</code>를 다음과 같이 수정하자. 공식 문서의 예시를 약간 변경한 정도이다.</p>\n<pre><code class=\"language-js\">const ReactRefreshWebpackPlugin = require('@pmmmwh/react-refresh-webpack-plugin');\nconst ReactRefreshTypeScript = require('react-refresh-typescript');\n\nconst isDevelopment = process.env.NODE_ENV !== 'production';\n\nmodule.exports = {\n  mode: isDevelopment ? 'development' : 'production',\n  module: {\n  rules: [\n    {\n        test: /\\.(ts|tsx)$/,\n        use: [\n          {\n            loader: require.resolve(\"ts-loader\"),\n            options: {\n              getCustomTransformers: () => ({\n                before: [isDevelopment &#x26;&#x26; ReactRefreshTypeScript()].filter(\n                  Boolean\n                ),\n              }),\n              transpileOnly: isDevelopment,\n            },\n          },\n        ],\n        exclude: /node_modules/,\n      },\n      // 기타 플러그인 설정들...\n    ],\n  },\n  plugins: [isDevelopment &#x26;&#x26; new ReactRefreshWebpackPlugin()].filter(Boolean),\n};\n</code></pre>\n<p>그런데 이렇게 하면 <code>ts-loader</code>가 개발 모드에서는 <code>transpileOnly</code>를 사용하게 되어서 타입 체크가 이루어지지 않는다. 타입 체크를 병렬로 진행해 주는 플러그인 <code>fork-ts-checker-webpack-plugin</code>을 사용하자.</p>\n<pre><code class=\"language-bash\">yarn add --dev fork-ts-checker-webpack-plugin\n</code></pre>\n<p>그다음 웹팩 설정 파일에 다음과 같이 플러그인을 추가한다.</p>\n<pre><code class=\"language-js\">module.exports = {\n  plugins: [\n    new HtmlWebpackPlugin({\n      title: \"Sinchon Attendance Development\",\n      template: \"./src/index.html\",\n    }),\n    isDevelopment &#x26;&#x26; new ReactRefreshWebpackPlugin(),\n    new ForkTsCheckerWebpackPlugin(),\n  ].filter(Boolean),\n  watchOptions: {\n    ignored: /node_modules/,\n  },\n};\n</code></pre>\n<p>이렇게 한 후 <code>yarn dev</code>를 실행하면 HMR이 적용된 개발 서버가 실행된다. minification 등 더 할 수 있는 설정들도 있지만 이후 적용할 수도 있기 때문에 개발을 좀 진행한 후 최적화는 다음에 진행하기로 한다.</p>\n<h1>7. 기타 설정</h1>\n<h2>7.1. 이미지 로딩</h2>\n<p>현재 설정에서는 웹팩에서 이미지 경로를 제대로 찾지 못할 수 있다. 이를 해결하기 위해 타입을 설정해 주자. <code>src/types</code>에 <code>custom.d.ts</code>를 만들고 다음과 같이 작성하자.</p>\n<pre><code class=\"language-ts\">declare module \"*.png\";\ndeclare module \"*.jpg\";\ndeclare module \"*.jpeg\";\n</code></pre>\n<p>그리고 <code>tsconfig.json</code>에 다음과 같이 <code>typeRoots</code>를 설정하자.</p>\n<pre><code class=\"language-json\">{\n  \"compilerOptions\": {\n    \"typeRoots\": [\"src/types\"],\n    // ...\n  },\n  // ...\n}\n</code></pre>\n<h2>7.2. CSS 플러그인 설정</h2>\n<p>CSS 압축과 모듈화를 위한 플러그인을 설정해주자.</p>\n<pre><code class=\"language-bash\">yarn add -D mini-css-extract-plugin css-minimizer-webpack-plugin\n</code></pre>\n<p>그리고 다음과 같이 웹팩 설정 파일을 수정하자. <code>mini-css-extract-plugin</code>는 <code>style-loader</code>와 같이 쓸 수 없으므로 개발 모드에서는 <code>style-loader</code>를, 프로덕션 모드에서는 <code>mini-css-extract-plugin</code>을 사용하도록 설정했다.</p>\n<p>webpack 설정을 다음과 같이 설정한다.</p>\n<pre><code class=\"language-js\">const MiniCssExtractPlugin = require(\"mini-css-extract-plugin\");\nconst CssMinimizerPlugin = require(\"css-minimizer-webpack-plugin\");\n\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n          isDevelopment ? \"style-loader\" : MiniCssExtractPlugin.loader,\n          \"css-loader\",\n        ],\n      },\n    ],\n  },\n  optimization: {\n    minimizer: [\n      new CssMinimizerPlugin(),\n    ],\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      title: \"Sinchon Attendance Development\",\n      template: \"./src/index.html\",\n    }),\n    isDevelopment &#x26;&#x26; new ReactRefreshWebpackPlugin(),\n    new ForkTsCheckerWebpackPlugin(),\n    !isDevelopment &#x26;&#x26; new MiniCssExtractPlugin(),\n  ].filter(Boolean),\n};\n</code></pre>\n<h1>참고</h1>\n<p>바닐라 TypeScript 시작하기 - 프로젝트 환경설정</p>\n<p><a href=\"https://velog.io/@hopsprings2/TypeScript-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%ED%99%98%EA%B2%BD%EC%84%A4%EC%A0%95\">https://velog.io/@hopsprings2/TypeScript-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%ED%99%98%EA%B2%BD%EC%84%A4%EC%A0%95</a></p>\n<p>ESLint 설치하기, 설정 방법</p>\n<p><a href=\"https://lakelouise.tistory.com/199\">https://lakelouise.tistory.com/199</a></p>\n<p>웹팩 getting started</p>\n<p><a href=\"https://webpack.kr/guides/getting-started\">https://webpack.kr/guides/getting-started</a></p>\n<p>웹팩 typescript</p>\n<p><a href=\"https://webpack.kr/guides/typescript/\">https://webpack.kr/guides/typescript/</a></p>\n<p>웹팩 Asset Management</p>\n<p><a href=\"https://webpack.kr/guides/asset-management/\">https://webpack.kr/guides/asset-management/</a></p>\n<p>웹팩 Output Management</p>\n<p><a href=\"https://webpack.kr/guides/output-management/\">https://webpack.kr/guides/output-management/</a></p>\n<p>웹팩 html-loader</p>\n<p><a href=\"https://webpack.js.org/loaders/html-loader/\">https://webpack.js.org/loaders/html-loader/</a></p>\n<p>웹팩 DevServer</p>\n<p><a href=\"https://webpack.kr/configuration/dev-server/\">https://webpack.kr/configuration/dev-server/</a></p>\n<p>제로초 웹팩5(Webpack) 설정하기</p>\n<p><a href=\"https://www.zerocho.com/category/Webpack/post/58aa916d745ca90018e5301d\">https://www.zerocho.com/category/Webpack/post/58aa916d745ca90018e5301d</a></p>\n<p>모두 알지만 모두 모르는 package.json(package.json scripts)</p>\n<p><a href=\"https://programmingsummaries.tistory.com/385\">https://programmingsummaries.tistory.com/385</a></p>\n<p>TypeScript 사용할 때 'Cannot find module ...' 에러</p>\n<p><a href=\"https://chiabi.github.io/2018/08/30/typescript/\">https://chiabi.github.io/2018/08/30/typescript/</a></p>\n<p>웹팩 입문: 1. HTML, CSS 사용하기</p>\n<p><a href=\"https://medium.com/@shlee1353/%EC%9B%B9%ED%8C%A9-%EC%9E%85%EB%AC%B8-%EA%B0%80%EC%9D%B4%EB%93%9C%ED%8E%B8-html-css-%EC%82%AC%EC%9A%A9%EA%B8%B0-75d9fb6062e6\">https://medium.com/@shlee1353/%EC%9B%B9%ED%8C%A9-%EC%9E%85%EB%AC%B8-%EA%B0%80%EC%9D%B4%EB%93%9C%ED%8E%B8-html-css-%EC%82%AC%EC%9A%A9%EA%B8%B0-75d9fb6062e6</a></p>\n<p>React Typescript에서 firebase 연동하기</p>\n<p><a href=\"https://velog.io/@parkyw1206/React-Typescript%EC%97%90%EC%84%9C-firebase-%EC%97%B0%EB%8F%99%ED%95%98%EA%B8%B0\">https://velog.io/@parkyw1206/React-Typescript%EC%97%90%EC%84%9C-firebase-%EC%97%B0%EB%8F%99%ED%95%98%EA%B8%B0</a></p>\n<p>React Refresh Webpack Plugin</p>\n<p><a href=\"https://github.com/pmmmwh/react-refresh-webpack-plugin/\">https://github.com/pmmmwh/react-refresh-webpack-plugin/</a></p>\n<p>Typescript TS2307: Cannot find module '.png' or its corresponding type declarations</p>\n<p><a href=\"https://egas.tistory.com/125\">https://egas.tistory.com/125</a></p>\n<p>플러그인 공식 문서들</p>\n<p><a href=\"https://www.npmjs.com/package/css-minimizer-webpack-plugin\">https://www.npmjs.com/package/css-minimizer-webpack-plugin</a></p>\n<p><a href=\"https://www.npmjs.com/package/mini-css-extract-plugin\">https://www.npmjs.com/package/mini-css-extract-plugin</a></p>\n<p>웹팩 (Webpack + TypeScript + React)</p>\n<p><a href=\"https://1-blue.github.io/posts/Webpack/\">https://1-blue.github.io/posts/Webpack/</a></p>",
    "excerpt": "1. 시작\nICPC Sinchon(이하 신촌연합)에서 프로그램 관리팀을 맡게 되었다. 이왕 하게 된 프로젝트 잘 해보자 싶기도 하고, 새롭게 해보는 것도 많아서 이곳에 기록을 남기기 시작한다.\n이 글에서는 신촌연합의 알고리즘 캠프 출석 페이지를 개선하는 과정 중 개발 환경 세팅에 관한 부분을 다룬다. 기본적인 구상과 패키지 매니저, 기본적인 웹팩 설정이 될 것이다.\n1.1. 배경\n나는 오래 전부터 ICPC Sinchon(이하 신촌연합)에서 활동해왔다. 그곳에서 ",
    "headingTree": [
      {
        "title": "1. 시작",
        "url": "#1-시작",
        "items": [
          {
            "title": "1.1. 배경",
            "url": "#11-배경",
            "items": []
          },
          {
            "title": "1.2. 기존 구성",
            "url": "#12-기존-구성",
            "items": []
          },
          {
            "title": "1.3. 구상",
            "url": "#13-구상",
            "items": []
          }
        ]
      },
      {
        "title": "2. 기본적인 세팅",
        "url": "#2-기본적인-세팅",
        "items": [
          {
            "title": "2.1. 패키지 매니저 설정",
            "url": "#21-패키지-매니저-설정",
            "items": []
          },
          {
            "title": "2.2. eslint 설치",
            "url": "#22-eslint-설치",
            "items": []
          }
        ]
      },
      {
        "title": "3. 웹팩 기본 설정",
        "url": "#3-웹팩-기본-설정",
        "items": [
          {
            "title": "3.1. 웹팩 설치와 기본 설정",
            "url": "#31-웹팩-설치와-기본-설정",
            "items": []
          },
          {
            "title": "3.2. 설정 파일 만들기",
            "url": "#32-설정-파일-만들기",
            "items": []
          }
        ]
      },
      {
        "title": "4. 타입스크립트 설정",
        "url": "#4-타입스크립트-설정",
        "items": []
      },
      {
        "title": "5. 리액트 설정",
        "url": "#5-리액트-설정",
        "items": [
          {
            "title": "5.1. 라이브러리 설치",
            "url": "#51-라이브러리-설치",
            "items": []
          },
          {
            "title": "5.2. 웹팩 설정 수정",
            "url": "#52-웹팩-설정-수정",
            "items": []
          },
          {
            "title": "5.3. 애셋 가져오기",
            "url": "#53-애셋-가져오기",
            "items": []
          },
          {
            "title": "5.4. 개발 서버 설정",
            "url": "#54-개발-서버-설정",
            "items": []
          }
        ]
      },
      {
        "title": "6. 개발 서버의 hot module replacement 설정",
        "url": "#6-개발-서버의-hot-module-replacement-설정",
        "items": [
          {
            "title": "6.1. HMR 기본 설정",
            "url": "#61-hmr-기본-설정",
            "items": []
          }
        ]
      },
      {
        "title": "7. 기타 설정",
        "url": "#7-기타-설정",
        "items": [
          {
            "title": "7.1. 이미지 로딩",
            "url": "#71-이미지-로딩",
            "items": []
          },
          {
            "title": "7.2. CSS 플러그인 설정",
            "url": "#72-css-플러그인-설정",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 4,
      "wordCount": 1100
    },
    "url": "/posts/sinchon-attendance-project",
    "thumbnail": {
      "local": "/static/attendance-page-e4b9dbe7.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-attendance-page-e4b9dbe7-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAFCAIAAAD38zoCAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAiElEQVR4nAF9AIL/AC8qOi0hODEiPEYzSUEzRR8gIxsdHSkqLAApDzVhPWxnTn0sKVQUEioTCBkQCBIAAAAAajt3cXSMKTg1SFZaTUxYKBomRSxGGRwcAJRfn5mNu2dff3dfg1k6YtD//nKNhic8MgCSYqCsd7iRZqJ0V4Q3LUaX3cBfjHVMbVxbpyZtxZ6NIwAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "react-usestate-init-function",
    "title": "React의 상태 관리 훅의 지연 초기화",
    "date": "2024-03-09T00:00:00Z",
    "description": "React useState initialize function",
    "tags": [
      "react"
    ],
    "html": "<h1>초기화 함수 전달하기</h1>\n<p>리액트의 상태 관리를 위한 훅인 <code>useState</code>와 <code>useReducer</code>는 첫 번째 렌더링에서만 평가되는 초기화 함수를 받을 수 있다. 예를 들어서 비용이 아주 큰 연산을 하는 함수를 이용해서 초기화 값을 만들어야 한다고 하자. 간단하게 이렇게 해볼 수 있다.</p>\n<pre><code class=\"language-tsx\">const veryExpensiveInitFunction = () => {\n  // 비용이 아주 큰 연산을 이용해 초기화 값을 만든다.\n  return veryExpensiveValue;\n};\n\nfunction MyComponent() {\n  const [state, setState] = useState(veryExpensiveInitFunction());\n  const [state, dispatch] = useReducer(reducer, veryExpensiveInitFunction());\n  // ...\n  update(current, initialArg, init){\n    realUpdate(current, **hook,);\n  }\n  update(current, veryExpensiveInitFunction(), ...){\n\n  }\n}\n</code></pre>\n<p>하지만 이렇게 하면 <code>veryExpensiveInitFunction()</code>의 결과는 초기 렌더링에만 사용됨에도 불구하고 매 렌더링마다 호출된다.</p>\n<p>이를 개선하기 위해 <code>useState</code>와 <code>useReducer</code>에 초기화 함수를 전달할 수 있다. 이 함수는 훅이 호출되기 전까지 호출되지 않으며 컴포넌트가 마운트될 때 한 번만 호출된다. <code>useReducer</code>같은 경우 2번째 인자 <code>initialArg</code>를 3번째 인자인 <code>init</code> 함수를 통해 초기화한 값을 state 초기값으로 사용한다.</p>\n<pre><code class=\"language-tsx\">const [state, setState] = useState(veryExpensiveInitFunction);\nconst [state, dispatch] = useReducer(reducer, 0, veryExpensiveInitFunction);\n</code></pre>\n<h1>내부</h1>\n<p>그럼 내부가 어떻게 되어 있길래 이렇게 동작할 수 있는 걸까? <a href=\"https://github.com/facebook/react\">react 소스코드 github</a></p>\n<p><code>useState</code>와 <code>useReducer</code>는 <code>packages/react/src/ReactHooks.js</code>에 있다.</p>\n<pre><code class=\"language-js\">export function useState&#x3C;S>(\n  initialState: (() => S) | S,\n): [S, Dispatch&#x3C;BasicStateAction&#x3C;S>>] {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useState(initialState);\n}\n\nexport function useReducer&#x3C;S, I, A>(\n  reducer: (S, A) => S,\n  initialArg: I,\n  init?: I => S,\n): [S, Dispatch&#x3C;A>] {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useReducer(reducer, initialArg, init);\n}\n</code></pre>\n<p>그럼 핵심인 <code>resolveDispatcher</code>는 어디에 있을까? <code>packages/react/src/ReactHooks.js</code>에 같이 있다.</p>\n<pre><code class=\"language-js\">function resolveDispatcher() {\n  const dispatcher = ReactCurrentDispatcher.current;\n\n  // ... 중간 코드 생략 ...\n  return ((dispatcher: any): Dispatcher);\n}\n</code></pre>\n<p><code>src/ReactCurrentDispatcher.js</code>에 <code>ReactCurrentDispatcher</code>가 있다.</p>\n<pre><code class=\"language-js\">/**\n * Keeps track of the current dispatcher.\n */\nconst ReactCurrentDispatcher = {\n  current: (null: null | Dispatcher),\n};\n</code></pre>\n<p>찾아보니 다른 곳에서 <code>ReactCurrentDispatcher.current</code>를 주입해 준다고 한다. 이는 <code>ReactFiberHooks.js</code>에서 이루어진다.</p>\n<pre><code class=\"language-js\">// packages/react-reconciler/src/ReactFiberHooks.js\nexport function renderWithHooks&#x3C;Props, SecondArg>(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  Component: (p: Props, arg: SecondArg) => any,\n  props: Props,\n  secondArg: SecondArg,\n  nextRenderLanes: Lanes,\n): any {\n  // ... 중간 코드 생략 ...\n  if (__DEV__) {\n    // 개발 모드의 코드들 생략\n  } else {\n    ReactCurrentDispatcher.current =\n      current === null || current.memoizedState === null\n        ? HooksDispatcherOnMount\n        : HooksDispatcherOnUpdate;\n  }\n  // 이하 생략...\n}\n</code></pre>\n<p>대략 현재 상태도 메모이제이션된 상태도 없으면 <code>HooksDispatcherOnMount</code>를 사용하고, 그렇지 않으면 <code>HooksDispatcherOnUpdate</code>를 사용한다는 걸 알 수 있다.</p>\n<p>우리는 '초기화 함수'에 대한 동작이 궁금하니까 <code>HooksDispatcherOnMount</code>를 살펴보자.</p>\n<pre><code class=\"language-js\">// packages/react-reconciler/src/ReactFiberHooks.js\nconst HooksDispatcherOnMount = {\n  useState: mountState,\n  useReducer: mountReducer,\n  /*...*/\n};\n</code></pre>\n<p><code>mountState</code>는 <code>mountStateImpl</code>을 호출하는데 거기 보면 이렇게 되어 있다. <code>typeof</code>로 <code>initialState</code>가 함수인지 판단하고 함수면 호출해서 초기값을 만들어낸다.</p>\n<p>이후 state update 함수를 보면 거기에도 사용되지는 않지만 <code>initialArg</code>가 인수로 들어가게 된다. 이때 만약 이렇게 초기화 함수로 전달된 인수가 있다면 update할 때는 초기화 함수를 마운트 시에 딱 1번 호출해서 만들어낸 값이 들어가지만 그렇지 않으면 <code>initialArg</code>가 들어가게 되는데 이때 만약 <code>initialArg</code>가 함수 전달이 아닌 함수 호출(<code>veryExpensiveInitFunction()</code>)이라면 이 큰 비용의 함수가 매 렌더링마다 호출되게 된다.</p>\n<pre><code class=\"language-tsx\">function mountStateImpl&#x3C;S>(initialState: (() => S) | S): Hook {\n  const hook = mountWorkInProgressHook();\n  if (typeof initialState === 'function') {\n    const initialStateInitializer = initialState;\n    // $FlowFixMe[incompatible-use]: Flow doesn't like mixed types\n    initialState = initialStateInitializer();\n    if (shouldDoubleInvokeUserFnsInHooksDEV) {\n      setIsStrictModeForDevtools(true);\n      // $FlowFixMe[incompatible-use]: Flow doesn't like mixed types\n      initialStateInitializer();\n      setIsStrictModeForDevtools(false);\n    }\n  }\n  hook.memoizedState = hook.baseState = initialState;\n  const queue: UpdateQueue&#x3C;S, BasicStateAction&#x3C;S>> = {\n    pending: null,\n    lanes: NoLanes,\n    dispatch: null,\n    lastRenderedReducer: basicStateReducer,\n    lastRenderedState: (initialState: any),\n  };\n  hook.queue = queue;\n  return hook;\n}\n</code></pre>\n<p><code>mountReducer</code>는 이렇게. <code>init</code> 인수가 있는지 없는지에 따라서 초기값을 만들어낸다.</p>\n<pre><code class=\"language-tsx\">function mountReducer&#x3C;S, I, A>(\n  reducer: (S, A) => S,\n  initialArg: I,\n  init?: I => S,\n): [S, Dispatch&#x3C;A>] {\n  const hook = mountWorkInProgressHook();\n  let initialState;\n  if (init !== undefined) {\n    initialState = init(initialArg);\n    if (shouldDoubleInvokeUserFnsInHooksDEV) {\n      setIsStrictModeForDevtools(true);\n      init(initialArg);\n      setIsStrictModeForDevtools(false);\n    }\n  } else {\n    initialState = ((initialArg: any): S);\n  }\n  hook.memoizedState = hook.baseState = initialState;\n  const queue: UpdateQueue&#x3C;S, A> = {\n    pending: null,\n    lanes: NoLanes,\n    dispatch: null,\n    lastRenderedReducer: reducer,\n    lastRenderedState: (initialState: any),\n  };\n  hook.queue = queue;\n  const dispatch: Dispatch&#x3C;A> = (queue.dispatch = (dispatchReducerAction.bind(\n    null,\n    currentlyRenderingFiber,\n    queue,\n  ): any));\n  return [hook.memoizedState, dispatch];\n}\n</code></pre>\n<h1>참고</h1>\n<p><a href=\"https://ko.react.dev/reference/react/useState#avoiding-recreating-the-initial-state\">https://ko.react.dev/reference/react/useState#avoiding-recreating-the-initial-state</a></p>",
    "excerpt": "초기화 함수 전달하기\n리액트의 상태 관리를 위한 훅인 useState와 useReducer는 첫 번째 렌더링에서만 평가되는 초기화 함수를 받을 수 있다. 예를 들어서 비용이 아주 큰 연산을 하는 함수를 이용해서 초기화 값을 만들어야 한다고 하자. 간단하게 이렇게 해볼 수 있다.\nconst veryExpensiveInitFunction = () => {\n  // 비용이 아주 큰 연산을 이용해 초기화 값을 만든다.\n  return veryExpensiveValue;",
    "headingTree": [
      {
        "title": "초기화 함수 전달하기",
        "url": "#초기화-함수-전달하기",
        "items": []
      },
      {
        "title": "내부",
        "url": "#내부",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 368
    },
    "url": "/posts/react-usestate-init-function",
    "thumbnail": {
      "local": "/thumbnails/react-usestate-init-function-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-react-usestate-init-function-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAgklEQVR4nGOora0NDQ0NDAyMjo5xcHCwtbX18PDQ1tZmKC8vZ2ZmDg0N5eDgaGlpuQgGV69eZVi9enVKSkp7e3tLS8vHjx//wwDDtm3bjhw58vbt2/v37/////83DDDcu//gzp27jx8//vLlC1w5SMec+YtnzZ69evXqixcvQnRAJABPJ2UxUrLKHwAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "security-of-link-tag",
    "title": "a태그와 보안",
    "date": "2023-06-28T00:00:00Z",
    "description": "HTML의 하이퍼링크 태그가 내포한 보안 문제",
    "tags": [
      "study"
    ],
    "html": "<h1>1. 시작</h1>\n<p>HTML 태그들을 조사하다가 <a href=\"https://developer.mozilla.org/ko/docs/Web/HTML/Element/a\">a 태그 문서</a>에서 흥미로운 부분이 있었다. a 태그를 잘못 사용하면 보안과 개인정보 문제가 발생할 수 있다고 한다.</p>\n<p><code>target=\"_blank\"</code> 속성을 <code>rel=\"noreferrer\"</code>와 <code>rel=\"noopener\"</code> 없이 사용하면 웹사이트가 <code>window.opener</code> API 악용 공격에 취약해진다는 것이다. 그러나 이게 무슨 말인지 이것만 봐서는 모르겠다. 이제부터 알아보자.</p>\n<h1>2. 개요</h1>\n<p>a태그에서 <code>target=\"_blank\"</code> 속성을 넣으면 링크가 새로운 브라우저 맥락에서 열린다.</p>\n<pre><code class=\"language-html\">&#x3C;a href=\"https://www.google.com\" target=\"_blank\">구글&#x3C;/a>\n</code></pre>\n<p>그런데 이렇게 하면 다음과 같은 문제가 있다.</p>\n<ol>\n<li>다른 페이지가 해당 페이지와 동일한 프로세스에서 실행될 수 있다. 기본적으로는 브라우저가 페이지별로 다른 프로세스를 사용한다. 다른 페이지에서 많은 JavaScript를 실행하는 경우 페이지의 성능이 저하될 수 있다.</li>\n<li>다른 페이지가 window.opener 속성을 사용하여 window 객체에 액세스할 수 있다. 그러면 다른 페이지에서 해당 페이지를 악성 URL로 리디렉션할 수 있다.</li>\n</ol>\n<p>이 문제를 피하기 위해서는 <code>target=\"_blank\"</code> 속성을 사용할 때는 <code>rel=\"noreferrer\"</code>혹은 <code>rel=\"noopener\"</code> 속성을 함께 사용해야 한다고 한다.</p>\n<pre><code class=\"language-html\">&#x3C;a href=\"https://www.google.com\" target=\"_blank\" rel=\"noreferrer\">구글&#x3C;/a>\n</code></pre>\n<p>그런데 이 문제들은 대체 왜 일어나는 걸까? 하나는 성능 면의 문제고, 하나는 보안 문제다. 하나씩 알아보자.</p>\n<ul>\n<li>최신 브라우저들에서는 이런 문제가 기본적으로 발생하지 않도록 되어 있다고 한다</li>\n</ul>\n<h1>3. 성능 문제</h1>\n<p>a 태그가 <code>target=\"_blank\"</code> 속성으로 쓰였고 위의 문제 해결법을 사용하지 않은 상태라고 하자.</p>\n<p>a 태그를 통해서 새롭게 열린 페이지는 보조 브라우징 맥락이다. 따라서 자신을 생성한 원본 브라우징 맥락을 오프너 브라우징 맥락으로 참조하고 있다.</p>\n<p>따라서 새롭게 열린 페이지가 원본 페이지의 오프너 브라우징 맥락과 동일한 프로세스 상에서 실행될 수 있다. 만약 새롭게 열린 페이지에서 많은 JS를 실행하는 경우 원본 페이지의 성능이 저하될 수 있다.</p>\n<h1>4. 보안 문제</h1>\n<p>위와 똑같은 가정을 하면 새롭게 열린 페이지에서 JS를 통해 원본 페이지 접근이 가능해진다. 이는 <code>window.opener</code> API를 통해 가능한데 이를 이용하는 보안 취약점이 있다.</p>\n<p>이를 이용한 공격을 tab nabbing이라고 한다.</p>\n<p>먼저 사용자를 유도할 사이트를 만든다. 예시에서는 적당히 <code>https://www.fishing-site.com</code>라고 하였다.</p>\n<pre><code class=\"language-html\">&#x3C;a href=\"https://www.fishing-site.com\" target=\"_blank\" >클릭을 유도하는 문구&#x3C;/a>\n</code></pre>\n<p>그리고 해당 사이트에서는 다음과 같은 JS를 실행한다.</p>\n<pre><code class=\"language-js\">window.opener.location = 'https://www.malicious-site.com';\n</code></pre>\n<p>사용자가 원래 사이트에서 <code>https://www.fishing-site.com</code>에 갔다가 원래 탭으로 돌아오면 <code>window.opener.location</code>이 변경되었으므로 <code>https://www.malicious-site.com</code>에 있다.</p>\n<p>이제 사용자는 <code>https://www.malicious-site.com</code>에 있다고 생각하고 로그인을 하거나 뭔가를 하게 될 것이다. 그러면 사용자의 정보가 노출될 수 있다.</p>\n<p>이렇게 노출된 사용자의 정보가 탈취되고 나면(가령 사용자가 로그인을 했다던가) 원래 사이트로 리디렉션된다. 사용자는 아무것도 모르고 로그인이 풀린 줄 알고 <code>https://www.malicious-site.com</code>에서 로그인을 했고, 원래 사이트로 돌아왔으니까 아무것도 모르고 있다.</p>\n<p><img src=\"/static/tab-nabbing-ca41467c.png\" alt=\"tab-nabbing\"></p>\n<p>일정 시간이 지나면 로그인을 다시 하도록 하는 사이트도 꽤 있기 때문에 사용자는 의심하기 어렵다. 그리고 사용자가 악의적인 사이트에서 로그인 시 이미 로그인되어 있는 원래 사이트로 리다이렉션하기 때문에 사용자는 로그인 성공으로만 인식한다.</p>\n<p>도메인 이름이 달라졌거나 조직 정보가 표시되지 않는 것 등을 이용해서 알아차릴 수도 있지만 악의적인 사이트에서도 원래 사이트와 비슷한 이름을 사용하기 때문에 쉽지 않다(예를 들어 <code>youtube.com</code>에 있는 댓글에서 파생된 링크라면 <code>voutube.com</code>을 쓰는 식이다)</p>\n<h1>5. 보안 문제 해결방법</h1>\n<p><code>rel=\"noopener\"</code> 혹은 <code>rel=\"noreferrer\"</code> 속성을 사용하면 된다.</p>\n<h2>5.1. rel=\"noopener\"</h2>\n<pre><code class=\"language-html\">&#x3C;a href=\"https://www.google.com\" target=\"_blank\" rel=\"noopener\">구글&#x3C;/a>\n</code></pre>\n<p>이를 적용하면 a, area, form요소에서 새롭게 생성된 브라우징 맥락에서 해당 맥락을 생성한 문서에 대한 접근을 하는 것을 막을 수 있다. 즉 새로 열린 브라우징 맥락의 <code>window.opener</code>가 null로 설정된다.</p>\n<p>단 <code>Referer</code> HTTP 헤더는 그대로 유지된다.</p>\n<p>그리고 a 태그에서 <code>target=\"_blank\"</code>속성을 설정하면 현재 대부분의 최신 브라우저에선 <code>rel=\"noopener\"</code>를 지정하는 것이 기본 동작이다.</p>\n<p>만약 굳이 새 탭에서 <code>window.opener</code>를 써야 한다면 <code>rel=\"opener\"</code>를 지정하면 된다.</p>\n<h2>5.2. rel=\"noreferrer\"</h2>\n<p>해당 속성을 지정하면 <code>rel=\"noopener\"</code>의 동작이 일어날 뿐 아니라 추가적으로 <code>Referer</code> HTTP 헤더도 제거된다.</p>\n<p>링크를 타고 들어왔을 때 HTTP 헤더에 포함되는 원래 사이트의 주소가 없어지는 것이다. 따라서 유입 분석에서도 해당 사이트가 어디서 유입되었는지 알 수 없기에 직접 유입으로 표시되게 된다.</p>\n<p>하지만 일부 구형 브라우저에서는 <code>rel=\"noreferrer\"</code>만 지원하는 경우가 있기 때문에 <code>rel=\"noopener noreferrer\"</code>처럼 함께 사용하는 것이 좋다.</p>\n<h2>5.3. 리퍼러 헤더</h2>\n<p><code>rel=\"noreferrer\"</code>속성을 지정하는 게 잠재적인 보안 위협을 막아 줄 수도 있다. 물론 리퍼러 헤더는 유입 분석 등 좋은 쓰임새도 많지만 보안에 취약한 경우도 있기 때문이다.</p>\n<p>예를 들어서 사용자의 비밀번호 초기화 페이지가 있고 해당 페이지의 푸터에 다른 사이트 링크가 있는 경우를 생각해 보자.</p>\n<p>그러면 사용자가 비밀번호를 초기화하다가 그 링크 사이트에 접속하게 되었을 경우 링크된 사이트는 사용자의 비밀번호 초기화 페이지에 대한 정보를 알 수 있게 된다. 이는 사용자 보안의 잠재적인 위협이 될 수 있다.</p>\n<p>비슷하게 서드파티 사잍에서 온 이미지가 페이지에 임베딩되어 있다면, 민감한 정보가 해당 서드파티에 전송되는 리퍼러를 통해 유출되고 있을 수 있다. 물론 민감한 정보가 아닐 수도 있지만 민감하지는 않더라도 어쨌든 사용자가 공유하길 원치 않는 정보일 수도 있고.</p>\n<h3>5.3.1. 리퍼러 헤더의 문제 해결</h3>\n<p>이 문제를 해결하기 위해서는 <code>rel=\"noreferrer\"</code>속성을 사용하면 된다. 이렇게 하면 리퍼러 헤더 자체가 전송되지 않는다.</p>\n<p>그리고 정보를 유출할 가능성이 있는 HTML 요소의 <code>referrerpolicy</code> 속성을 <code>no-referrer</code>로 설정하는 것도 비슷한 방법이다.</p>\n<pre><code class=\"language-html\">&#x3C;a href=\"https://www.google.com\" target=\"_blank\" referrerpolicy=\"no-referrer\">구글&#x3C;/a>\n</code></pre>\n<p><code>meta</code> 태그의 <code>referrer</code> 속성을 <code>no-referrer</code>로 설정하는 것도 강력한 방법이다(문서 전체에서 리퍼러 헤더를 비활성화시킨다).</p>\n<pre><code class=\"language-html\">&#x3C;meta name=\"referrer\" content=\"no-referrer\">\n</code></pre>\n<p>하지만 어플리케이션을 주의깊게 디자인하는 것만으로도 이런 문제를 대부분 피할 수 있다.</p>\n<p>URL을 통해서 민감한 정보가 전달되는 걸 막기 위해 get대신 post 요청을 사용하고, HTTPS가 아닌 사이트로 리퍼러를 보내지 않는 HTTPS 사이트를 사용하며 민감한 정보를 URL에 포함시키지 않는 등의 방법이 있다.</p>\n<p>또한 iframe등으로 삽입된 서드파티 컨텐츠를 민감한 정보가 담긴 페이지에 넣지 않음으로써 정보 유출을 막아야 한다.</p>\n<h1>6. window.open</h1>\n<p>새 창을 여는 함수인 <code>window.open</code>을 사용할 때도 같은 취약점이 있다. 따라서 이 함수를 사용할 때에도 opener를 리셋해 주자.</p>\n<pre><code class=\"language-js\">var ret = window.open(url, \"_blank\", specs, replace);\nret.opener=null;\n</code></pre>\n<h1>참고</h1>\n<p>리퍼러 헤더 : 개인정보와 보안 고려사항 <a href=\"https://developer.mozilla.org/en-US/docs/Web/Security/Referer_header:_privacy_and_security_concerns\">https://developer.mozilla.org/en-US/docs/Web/Security/Referer_header:_privacy_and_security_concerns</a></p>\n<p>교차 출처 대상에 대한 링크는 안전하지 않습니다 <a href=\"https://developer.chrome.com/ko/docs/lighthouse/best-practices/external-anchors-use-rel-noopener/\">https://developer.chrome.com/ko/docs/lighthouse/best-practices/external-anchors-use-rel-noopener/</a></p>\n<p>하이퍼링크를 신뢰할 수 없다면? <a href=\"https://yozm.wishket.com/magazine/detail/1586/\">https://yozm.wishket.com/magazine/detail/1586/</a></p>\n<p><a href=\"https://blog.jxck.io/entries/2016-06-12/noopener.html\">https://blog.jxck.io/entries/2016-06-12/noopener.html</a></p>\n<p>rel=noopener <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel/noopener\">https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel/noopener</a></p>\n<p><a href=\"https://www.jitbit.com/alexblog/256-targetblank---the-most-underestimated-vulnerability-ever/\">https://www.jitbit.com/alexblog/256-targetblank---the-most-underestimated-vulnerability-ever/</a></p>\n<p><a href=\"https://security.stackexchange.com/questions/216135/xss-with-a-tag-with-target-blank\">https://security.stackexchange.com/questions/216135/xss-with-a-tag-with-target-blank</a></p>\n<p><a href=\"https://offbyone.tistory.com/312\">https://offbyone.tistory.com/312</a></p>",
    "excerpt": "1. 시작\nHTML 태그들을 조사하다가 a 태그 문서에서 흥미로운 부분이 있었다. a 태그를 잘못 사용하면 보안과 개인정보 문제가 발생할 수 있다고 한다.\ntarget=\"_blank\" 속성을 rel=\"noreferrer\"와 rel=\"noopener\" 없이 사용하면 웹사이트가 window.opener API 악용 공격에 취약해진다는 것이다. 그러나 이게 무슨 말인지 이것만 봐서는 모르겠다. 이제부터 알아보자.\n2. 개요\na태그에서 target=\"_blank\" 속성",
    "headingTree": [
      {
        "title": "1. 시작",
        "url": "#1-시작",
        "items": []
      },
      {
        "title": "2. 개요",
        "url": "#2-개요",
        "items": []
      },
      {
        "title": "3. 성능 문제",
        "url": "#3-성능-문제",
        "items": []
      },
      {
        "title": "4. 보안 문제",
        "url": "#4-보안-문제",
        "items": []
      },
      {
        "title": "5. 보안 문제 해결방법",
        "url": "#5-보안-문제-해결방법",
        "items": [
          {
            "title": "5.1. rel=\"noopener\"",
            "url": "#51-relnoopener",
            "items": []
          },
          {
            "title": "5.2. rel=\"noreferrer\"",
            "url": "#52-relnoreferrer",
            "items": []
          },
          {
            "title": "5.3. 리퍼러 헤더",
            "url": "#53-리퍼러-헤더",
            "items": [
              {
                "title": "5.3.1. 리퍼러 헤더의 문제 해결",
                "url": "#531-리퍼러-헤더의-문제-해결",
                "items": []
              }
            ]
          }
        ]
      },
      {
        "title": "6. window.open",
        "url": "#6-windowopen",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 290
    },
    "url": "/posts/security-of-link-tag",
    "thumbnail": {
      "local": "/static/tab-nabbing-ca41467c.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-tab-nabbing-ca41467c-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAIAAAA8r+mnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAZ0lEQVR4nB3JoQ3AIBAAQAZggzIDFtP6twgqEDWkCSOgOgWy5JdAswD2l8DjvylnTxBRa80YE0Jg5jGG1hoAhPdeSnnH+JZCRIgIAIgomLn3Hq/rSWlTylqbc661/jHnPPb9dG4uvHxHuTk4GfOotwAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "sinchon-camp-2021-summer",
    "title": "ICPC 신촌 여름 알고리즘 캠프 후기",
    "date": "2021-08-23T00:00:00Z",
    "description": "여름방학 신촌 알고리즘 캠프의 후기",
    "tags": [
      "algorithm"
    ],
    "html": "<h1>신촌연합 알고리즘 캠프 후기</h1>\n<h1>1. 캠프 콘테스트 3등</h1>\n<p><img src=\"/static/scoreboard-f28f7b93.png\" alt=\"scoreboard\"></p>\n<p>신촌연합 알고리즘 캠프 초급반 콘테스트에서 3등을 했다. 꽤 괜찮은 성적이라고 생각한다. 사실 내가 내 스스로의 힘으로, 내가 그럭저럭 만족할 만한 어떤 결과를 낸 것이 처음이기에 조금은 홀가분한 마음으로 TMI 투성이인 후기를 쓴다. 게다가 후기를 쓰면 추첨을 통해 경품을 주는 이벤트도 진행 중이라 안 쓸 수가 없었다.</p>\n<h1>2. 나에 대하여</h1>\n<p><img src=\"/static/myprofile-076e0e8f.png\" alt=\"profile\"></p>\n<p>방학 시작할 때의 프로필이 없어서 올리는 현재의 내 프로필</p>\n<hr>\n<p>나는 꽤 알고리즘을 오래 해왔다. 이번 방학이 시작할 때 내 티어는 이미 <a href=\"https://solved.ac/\">https://solved.ac/</a> 기준 플래티넘 4였고, 푼 문제는 800문제를 넘어갔던 것 같다. 단순히 시작한 날짜로 따지면 2년 정도가 되었으니 이상한 일은 아니다.</p>\n<p>그러면서 YunGoon, dlstj0923, snowflake, gs11008 등 많은 알고리즘 고수들을 만났고 같은 학교의 고수들인 raararaara, shiftpsh, wbcho0504, djs100201, seastar105 등과도 알게 되었다. 직접 알게 된 사람들 외에도 한두 번 이야기를 나눠본 고수들은 셀 수도 없다. 그리고 그런 사람들처럼 빛나는 사람이 되고 싶어 컴퓨터공학 복수전공을 시작하기도 했다. 또 나보다 훨씬 잘하는 그런 사람들을 모아서 스터디를 이끌어보는 영광을 안기도 했다. 그러면서 내 실력이 꽤 괜찮다고 사람들이 인식하게 된 듯 하다. 나는 내가 어울리는 사람들보다 실력은 많이 못한 게 사실인데 말이다.</p>\n<p>그래서 나는 늘 내 실력이 거품이라고 생각해왔다. 지금도 그렇게 생각한다. 내가 완전히 뉴비급으로 못하는 건 아니라는 걸 알지만 그렇다고 플래티넘이라는 티어에 걸맞는 사람이라고 생각하지도 않는다. 이 플래티넘 티어는 한때 쓸데없이 마음만 급해져서 고급 알고리즘에 손끝만 대어 본 덕분일 뿐이다. 가령 내가 푼 문제에는 네트워크 플로우라든지 무슨 고급 테크닉 문제들이 몇 개 있지만 지금에 와서 그런 것들은 하나도 기억나지 않는다. 원리는 전혀 이해하지 못한 채로 거의 코드만 베껴와서 적어넣는 수준이었으니 말이다.</p>\n<p>그래서 늘 처음부터 다시 시작하는 것을 생각해 왔다. 그러나 계속 시간이 없어서, 또는 내 쓸데없는 자만심이 그걸 막아서 못해왔었다. 이번 방학에서야 신촌연합 알고리즘 캠프 초급반을 듣는 것으로 겨우 그것을 실현하게 되었다.</p>\n<h1>3. 신촌연합 알고리즘 캠프</h1>\n<pre><code>안녕하세요 신촌지역 대학교 프로그래밍 동아리 연합입니다. 서강대학교, 숙명여자대학교, 연세대학교, 이화여자대학교, 홍익대학교 프로그래밍 동아리의 연합 동아리로, 각 학교 컴퓨터공학과 전공생 180명으로 구성되어 있습니다. 2020년 겨울부터 활동을 시작하여 매 시즌 정기적인 활동을 이어 나가고 있습니다.\n</code></pre>\n<p><a href=\"https://icpc-sinchon.io/\">https://icpc-sinchon.io/</a> 에서 발췌</p>\n<hr>\n<p>알고리즘 학회에 들어가서 가만히 있었는데 갑자기 신촌지역 대학들이 모여서 연합이란 걸 만들고 양질의 강의를 제공하기 시작했다. 원래 서강대 학회에서도 고수 분들이 좋은 강의를 해주었지만 아무래도 멘토라든지, 시험 등의 시스템이 부족했다. 그런 것들을 할 수 있을 만큼 서강대 학회의 인원이 충분하지도 않았을 것이다.</p>\n<p>하지만 신촌연합이 만들어지고 인원이 충분해지면서 여러가지 시스템이 만들어졌고 열심히 할 마음만 있다면 훨씬 더 괜찮은 환경에서 알고리즘을 배울 수 있게 되었다. 강의 보증금 시스템이라든지 멘토라든지 하는, 알고리즘을 배우고 싶어하는 사람들을 도울 수 있는 여러가지 시스템들이 갖춰졌다.</p>\n<p>그 와중에 나는 거의 연합이 생길 때부터 있었지만 제대로 참여해 본 적은 별로 없는 것 같다. 늘 강의는 듣는둥 마는둥 연습문제도 푸는둥 마는둥 했다. 다른 할 게 있다는 핑계로 딱히 제대로 참여하지 않았다. 게다가 중급반을 참여했기에, 실력의 기반이 부족한 내가 이해하기에는 어려운 알고리즘들이 많아서 잘 머리에 들어오지도 않았다.(신촌연합 중급반에서는 중급이라고 하기 힘들 정도로 어려운 알고리즘을 다뤘었다)</p>\n<p>하지만 이번에는 마음을 잡고 초급반을 신청했다. 커리큘럼의 대부분이 한번쯤 들어 보고 문제도 몇 개는 풀어 보았던 알고리즘들이라 다시 복습하면서 기반을 탄탄하게 잡는다는 마음이었다. 그리고 제대로 된 지식 기반 없이 어려운 알고리즘을 배우는 것이 재미가 있긴 하지만 기본적인 실력 향상에는 그렇게 도움이 되지 않는다는 것을 1년 반이나 지나서 이제야 깨달아 버렸기 때문이다.</p>\n<p>참고 : <a href=\"https://blog.naver.com/pasdfq/222217957003\">어려운 알고리즘 권하는 사회 - Green55님</a></p>\n<p><img src=\"/static/practice-1ef1113a.png\" alt=\"practice\"></p>\n<p>아쉽게도 모든 출석문제를 풀지는 못했다.</p>\n<hr>\n<p>그래서 이번에는 최대한 모든 문제를 내 손으로 풀어 보고자 했다. 정 안 되면 풀이를 볼 수도 있지만, 무턱대고 남의 코드를 보고 대충 이해한 후에 거의 비슷한 코드를 제출하는 일은 없게 하기로 했다.(그렇게 남의 코드를 따라 치기만 하는 게 실력 향상에 전혀 도움이 안 된다는 걸 나도 안다. 하지만 부끄럽게도 나는 그런 짓을 꽤 많이 해왔다) 풀이를 보더라도 이해한 후의 구현은 내가 직접 내 손으로 하기로 결심했다.</p>\n<p>캠프가 끝나고 돌아보건대, 모든 문제를 다 오로지 나만의 발상으로 푼 것은 아니지만 적어도 내 손으로 푼 것은 맞다고 생각한다. 티어만 따진다면 내가 지금까지 고급 알고리즘을 조금씩만 배우면서 풀어온 문제보다 훨씬 낮은 티어의 문제들을 풀었다. 하지만 내가 푼 어떤 고급 문제들보다 자랑스럽다고 감히 생각한다.</p>\n<h2>3.1 캠프의 진행</h2>\n<p><img src=\"/static/curriculm-897c2902.png\" alt=\"curriculm\"></p>\n<p>신촌연합 알고리즘 캠프 초급반에서 다루는 자료구조와 알고리즘은 매우 기본적인, 그러나 잘 다루기는 굉장히 어려운 주제들을 다룬다. (가령 유니언 파인드와 BFS는 각각 solved.ad기준 골드 하위, 실버 상위 티어의 알고리즘이지만 그걸 섞으면 <a href=\"https://www.acmicpc.net/problem/14868\">BOJ 14868 문명</a> 과 같은 흉악한 문제가 나온다. 그 외에도 스택을 이용한 라인 스위핑이라든지 하는 수많은 고급 알고리즘들이 이 기본적인 알고리즘들에서 파생된다)</p>\n<p>따라서 이런 기본적인 알고리즘들은 사람들이 대충 이해하고 훌쩍 넘어가는 데에 반해서 매우 중요하고 잘 이끌어 줄 사람도 필요하다고 본다. 신촌연합에서는 이런 부분들을 잘 제공해 주었다고 생각한다. 강사는 최소 코드포스 오렌지급이었고 멘토들도 꽤 짱짱했으니 말이다.</p>\n<p>아무튼 이런 주제들로 초급반은 진행되었고, 각 주제들에 관한 강사들의 강의 이후 일정 개수 이상의 출석 문제(+연습 문제)를 풀면 출석이 되는 방식으로 캠프가 진행되었다. 또한 동기부여를 위해서인지 캠프가 처음 시작할 때 일정 금액의 보증금을 걷고 나서 캠프 진행 동안 특정 기준을 만족한 사람에게만 보증금을 환급해 주는 제도를 도입하였다.</p>\n<p>누가 생각한지 몰라도 정말 좋은 생각이었다고 생각한다. 몇만원의 보증금이 걸려 있다고 생각하니 열심히 참여하게 되더라.</p>\n<h2>3.2 캠프 이야기 - 출석 문제</h2>\n<p><img src=\"/static/greedy-f24beb1c.png\" alt=\"greedy\"></p>\n<p>그리디 주제의 출석 문제들. 4문제 이상 풀면 되긴 하지만 대부분이 골드 이상의 그리디 문제이다.</p>\n<hr>\n<p>그래도 참가자로서 조금 평을 하자면, 일단 캠프의 참여자들을 볼 때, 몇몇 주제에 대한 출석 문제 선택은 그렇게 좋지 않았다고 생각한다. 이런 기본적인 알고리즘들만으로도 충분히 엿볼 수 있는 신비한 알고리즘의 세계를 맛보게 해 주려는 운영진들의 노력인지는 잘 모르겠으나 완전히 처음 시작하는 사람들에게 골드 상위의 문제들을 출석 문제로 던져주는 것은 글쎄, 나한테는 매우 좋았지만 조금은 무리한 선택이 아니었나 싶다.</p>\n<p>(물론 최소 스패닝 트리와 같이 최소 골드 4 이상의 티어가 책정되는 주제에 대해서는 크게 할 말 없다. 다만 알고리즘 난이도로 골드 4를 받은 MST기본 문제보다는 백트래킹 골드4 티어 문제가 훨씬 까다롭다고 생각한다. MST 출석 문제에 골드 3이 있는 것과 백트래킹 출석 문제에 골드 3이 있는 것은 다르게 평가해야 한다고 나는 본다)</p>\n<p>알고리즘 대회 판에 한번 몸을 던져 보고 싶은 사람이라면 이 정도도 안 푸는 것은 말도 안 된다-라는 견해에도 나름 동의한다. 솔직히 나 같아도, 어려운-하지만 상당히 도전해 볼 만한-문제를 던지고 싶은 욕심이 마구 들 것 같다. 그러나 초급반 수강생은 150명을 넘어간다. 그런 사람들이 모두 알고리즘을 끝까지 한 번 해 보겠다는 마음을 먹었다는 것은 말이 안 된다. 개인적으로는 많아야 10%인 15명 정도가 그런 알고리즘 전사들이 아닐까 생각한다.</p>\n<p>그런 사람들만을 위해서 캠프가 운영되는 것은 아니니까, 다음에는 좀 더 쉬운 문제들을 필수문제로 하고 나머지는 연습문제로 던지는 게 좋지 않을까 생각하지만...뭐, 내가 캠프의 운영진도 아니고 나에게는(또 내가 아는 몇몇 알고리즘 전사들에게도) 매우 마음에 들었던 문제 선정이었으니 딱히 더 할 말은 없다. 그리고 다음에도 이런 멋진 문제 선정이라면 나 개인적으로는 아마 다음에도 초급반에 참여하지 않을까? 적어도 멘토로 참여해서라도 문제는 받아서 풀어보지 않을까 싶다.</p>\n<h2>3.3 캠프 이야기 - 강의와 연습문제</h2>\n<p>나는 내용을 거의 다 아는 상태인데도 강의는 꽤 괜찮았다. 어떤 고급 테크닉을 더 가르쳐 주는 건 아니었지만 내용이 제법 탄탄해서 정리한다는 마음으로 들으니 왠지 머릿속의 지식 기반이 더 튼튼해지는 느낌이었다. 역시 코드포스 오렌지 강사들은 다르구나 싶었다.</p>\n<p>출석 문제들 또한, 처음 하는 사람들에게는 그다지 적절하지 못하다고 생각하긴 하지만 말했듯이 내게는 정말 좋은 문제 선정이었다. 스택이 뭔지, 다이나믹 프로그래밍이 뭔지는 알지만 제대로 활용하지 못하는 나같은 사람에게 강제로 응용을 시켜주는 문제들이었다고 생각한다. 또한 알고리즘을 거의 처음 시작하는 사람이라도 배우고자 하는 욕심만 있다면 도전해 볼 만한 문제였다고 본다. 실제로 이번 캠프로 인해 실력이 엄청나게 상승한 사람을 몇 명 보았기도 하고 말이다.</p>\n<p>물론 내게는 여전히 백트래킹은 어렵고 DP는 발상이 너무나 힘들며 완전탐색 구현은 빡세다. 그래도 그런 주제들의 응용 문제를 스스로의 힘으로 풀어 보면서 조금은 더 익숙해졌다고 생각한다. 예전에는 거들떠보지도 않거나 조금 끄적거리다가 답을 찾아보고 있었을 텐데 말이다.</p>\n<h2>3.4 캠프 이야기 - 캠프의 효용에 대하여</h2>\n<p>알고리즘 실력을 기르고 싶다면 캠프를 듣는 게 좋은가? 무조건 맞다고 할 수는 없을 것이다. 하지만 알고리즘을 시작하면서 보통 겪게 되는 많은 관문들을 조금 낮춰 주는 것은 사실이다.</p>\n<p>사실 캠프에서 배우게 되는 내용에 대해서는 큰 효과가 없다고 생각한다. 물론 캠프에서 양질의 강의를 제공한다고 했던 말은 사실이다. 그러나 그런 정보쯤은 마음만 있다면 인터넷에서 쉽게 찾아볼 수 있다. kks227님의 블로그나 바킹독님의 블로그 등에 이미 잘 정리된 자료들이 있고, 유튜브에 가보면 IOI Korea 등의 채널에서 알고리즘 판의 네임드들이 나와서 강의하는 자료도 있다. 캠프에서만 배울 수 있는 내용 같은 건 아무것도 없다.</p>\n<p>그러나 이곳에선 확실한 커리큘럼을 제공한다. 이 기간 안에 이 주제를 습득하고 이 문제를 스스로의 힘으로 풀면 일정 수준에 올라설 수 있다는 어떤 보장 같은 것. 그리고 이해가 안 되는 무언가나 내 힘으로 풀 수 없는 문제가 나오면 편하게 질문할 수 있는 멘토진의 존재. 이런 것들 또한 온라인에서 찾을 수 있는 것은 맞지만 알고리즘을 처음 시작하는 입장에서는 정말 쉽지 않다.</p>\n<p><img src=\"/static/score2-fc04a8a5.png\" alt=\"score2\"></p>\n<p>출석 문제 스코어보드. 경쟁심리를 자극한다.</p>\n<hr>\n<p>또한 얼굴 한 번 본 적 없더라도 내 조금 앞에서 달려가는 어떤 사람들의 존재. 알고리즘을 조금이라도 제대로 해볼 마음이 있는 사람이라면 저렇게, 나보다 스코어보드상의 순위가 높은 사람을 보면 문제를 풀고 싶은 마음이 들게 된다.</p>\n<p>오픈채팅방이나 알고리즘 커뮤니티에 있는 사람들은 보통 너무 잘하기 때문에 좋은 조언자는 될 수 있어도 좋은 경쟁자가 될 수는 없다. 알고리즘을 이제야 처음 시작했다면 어떻게 코드포스 퍼플, 오렌지급들이랑 경쟁하겠는가? 어느 정도의 승부욕을 자극하는 그런 경쟁자들의 존재를 신촌연합 캠프에서는 제공해 준다. 나 또한 저런 스코어보드를 보면 한 문제를 더 풀지 않고는 못 배기곤 했다.</p>\n<p>다만 대면 스터디나 세미나의 경우 우연한 만남을 통해 얻을 수 있는 인연이 상당히 많다고 생각하는데(나의 우상 <code>raararaara</code> 님도 이런 기회를 통해 만났었다) 코로나 때문에 대면으로 만날 수 있는 기회가 없었어서 아쉬운 부분이었다. 먼 훗날(이날이 오긴 올까?) 소규모라도 모임을 할 수 있게 된다면 캠프에서 대면으로 진행되는 무언가도 진행해 봐도 좋지 않을까 하는 생각을 한다. 아니면 대면이 아니라도 따로 스터디를 만든다든가. 그러고 보니 스터디는 지금도 만들 수 있었는데 아무도 하지 않은 것이구나.</p>\n<p>요약하자면, 오직 이 캠프에서만 얻을 수 있는 것은 없다. 그러나 혼자 얻기가 쉽지만은 않은 것들을 이 캠프에서는 꽤나 많이 제공해 줬다고 생각한다.</p>\n<h1>4. 캠프 콘테스트</h1>\n<p>그래도 3등씩이나 했는데 콘테스트에 대한 후기를 아예 안 쓸 수는 없다. 간단하게나마 서술하도록 하겠다.</p>\n<p><img src=\"/static/suggest-a82fff25.png\" alt=\"suggest\"></p>\n<p>잘 알지 못하는 사람들에게 :god: 이모지를 받는 경험은 신선하다</p>\n<hr>\n<p>캠프 콘테스트 날 학교 랩실을 사용하지 못한다고 하여 스터디룸을 빌리려고 했다. 그런데 14400원으로 꽤 가격이 나가기에 조금이라도 분담할 사람을 찾고자 했다. 바로 연락을 준 <code>p_jun</code> 과 함께 가기로 했다.</p>\n<p><code>p_jun</code> 과 함께 간 스터디룸은 의자가 조금 기울어져 있긴 했지만 꽤 괜찮았다. 14400원이 적은 돈은 아니지만 스터디룸 대여비치고는 싼 편인데, 그 가격에 빌릴 수 있는 스터디룸치고는 괜찮았다. 커피를 맘대로 뽑아 마실 수 있는 게 특별히 맘에 들었다.</p>\n<p>아무튼 그렇게 스터디룸에서 아무 말 없이 각자 문제를 풀었다. 문제별 후기는 다음과 같다. 문제 순서는 내가 푼 순서대로이다.</p>\n<h2><a href=\"https://www.acmicpc.net/problem/22950\">A. 이진수 나눗셈</a></h2>\n<p>이진수의 특성을 잘 생각해서 풀면 되는 문제다. 브론즈1 티어의 문제치고는 삐끗해서 틀리기 좋은 문제라고 생각한다. 이진수의 뒷자리부터 0의 개수를 센 후 그게 K보다 크거나 같으면 M이 $ 2^{k} $ 로 나누어떨어진다고 할 수 있다. 이때 조심할 점은 주어진 M의 자릿수가 모두 0이면 무엇으로 나눠도 나누어떨어진다는 점이다. 이 부분을 생각하지 못해서 나도 1번 틀렸다.</p>\n<pre><code class=\"language-cpp\">#include &#x3C;iostream>\n#include &#x3C;vector>\n#include &#x3C;list>\n#include &#x3C;cstring>\n#include &#x3C;algorithm>\n#include &#x3C;string>\n#include &#x3C;map>\n#include &#x3C;set>\n#include &#x3C;cmath>\n#include &#x3C;queue>\n#include &#x3C;iomanip>\n\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    int n, k, len, cnt = 0;\n    string bin;\n    cin >> n;\n    cin >> bin;\n    cin >> k;\n    len = bin.length();\n    for (int idx = len - 1; idx >= 0; idx--) {\n        if (bin[idx] == '1') {\n            break;\n        }\n        else {\n            cnt++;\n        }\n    }\n    if (cnt >= k || cnt == len) {\n        cout &#x3C;&#x3C; \"YES\\n\";\n    }\n    else {\n        cout &#x3C;&#x3C; \"NO\\n\";\n    }\n\n    return 0;\n}\n</code></pre>\n<h2><a href=\"https://www.acmicpc.net/problem/22952\">C. permutation making</a></h2>\n<p>1~N으로 순열을 만들 때, 1부터 i인덱스까지의 구간합을 N으로 나눈 나머지 중 서로 다른 값이 $ \\frac {N}{2} +1 $ 개가 되게 하는 순열을 아무거나 구해서 출력하는 문제이다.</p>\n<p>나는 N이 홀수일 경우<code>1, N-1, 2, N-2, ... (N/2-1), (N/2+1)</code> 을 출력하면 문제의 조건을 만족하고, 짝수일 경우 <code>1, N-1, 2, N-2, ... (N/2-1), N/2</code> 를 출력하면 문제의 조건을 만족한다는 것을 몇 개의 경우를 직접 해보고 나서 깨달았다. 그대로 구현하니까 맞았다.</p>\n<pre><code class=\"language-cpp\">#include &#x3C;iostream>\n#include &#x3C;vector>\n#include &#x3C;list>\n#include &#x3C;cstring>\n#include &#x3C;algorithm>\n#include &#x3C;string>\n#include &#x3C;map>\n#include &#x3C;set>\n#include &#x3C;cmath>\n#include &#x3C;queue>\n#include &#x3C;iomanip>\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    int n;\n    cin >> n;\n    if (n % 2 == 1) {\n        for (int i = 1; i &#x3C;= n / 2; i++) {\n            cout &#x3C;&#x3C; i &#x3C;&#x3C; \" \" &#x3C;&#x3C; n - i &#x3C;&#x3C; \" \";\n        }\n        cout &#x3C;&#x3C; n &#x3C;&#x3C; \"\\n\";\n    }\n    else {\n        for (int i = 1; i &#x3C; n / 2; i++) {\n            cout &#x3C;&#x3C; i &#x3C;&#x3C; \" \" &#x3C;&#x3C; n - i &#x3C;&#x3C; \" \";\n        }\n        cout &#x3C;&#x3C; n / 2 &#x3C;&#x3C; \" \" &#x3C;&#x3C; n &#x3C;&#x3C; \"\\n\";\n    }\n\n\n    return 0;\n}\n</code></pre>\n<h2><a href=\"https://www.acmicpc.net/problem/22951\">B. 송이의 카드 게임</a></h2>\n<p><a href=\"https://www.acmicpc.net/problem/1158\">요세푸스 문제</a>의 변형이다. 처음 봤을 때는 감을 못 잡고 C번으로 가서 C번을 먼저 풀었으나, C번을 풀고 돌아와서 다시 보니까 요세푸스 문제의 변형인 것을 쉽게 알 수 있었다. 그 문제에 내가 제출했던 코드를 좀 찾아보고 나서 이 문제를 풀었다. 다만 인덱스가 좀 헷갈려서 1번 틀렸다.</p>\n<pre><code class=\"language-cpp\">#include &#x3C;iostream>\n#include &#x3C;vector>\n#include &#x3C;list>\n#include &#x3C;cstring>\n#include &#x3C;algorithm>\n#include &#x3C;string>\n#include &#x3C;map>\n#include &#x3C;set>\n#include &#x3C;cmath>\n#include &#x3C;queue>\n#include &#x3C;iomanip>\nusing namespace std;\ntypedef long long ll;\n\ntypedef struct card {\n    int person, num;\n    //누가 가지고 있는지와 카드에 적힌 숫자\n} card;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    int n, k;\n    cin >> n >> k;\n    vector&#x3C;card> people;\n    for (int i = 1; i &#x3C;= n; i++) {\n        for (int j = 0; j &#x3C; k; j++) {\n            int t;\n            cin >> t;\n            people.push_back({i, t});\n        }\n    }\n    int pos = 0;\n    while (people.size() > 1) {\n        int prev = people[pos].num;\n        people.erase(people.begin() + pos);\n        pos = (pos + prev - 1) % people.size();\n    }\n    cout &#x3C;&#x3C; people[0].person &#x3C;&#x3C; \" \" &#x3C;&#x3C; people[0].num &#x3C;&#x3C; \"\\n\";\n    return 0;\n}\n</code></pre>\n<h2><a href=\"https://www.acmicpc.net/problem/22954\">E. 그래프 트리 분할</a></h2>\n<p>주어진 그래프가 만약 연결 요소라면 그냥 최소 스패닝 트리를 적당히 구축해 준 후 마지막에 트리에 합류한 정점 하나만 뚝 떼어서 2번째 트리로 만들어 주면 된다. 정점 하나뿐인 그래프 또한 트리의 조건을 만족하므로 말이다.</p>\n<p>그러나 문제는 주어진 그래프가 연결 요소라는 보장이 없다는 것이다. 따라서 먼저 BFS나 DFS를 통해서 연결 요소의 개수를 세어 준다. 그리고 연결 요소가 2개보다 많으면 주어진 그래프를 2개의 트리로 분할할 수 없으므로 <code>-1</code>을 출력해 준다. 또한 주어진 정점 개수가 1개이거나 2개일 때도, 어떻게 하더라도 그래프가 서로 다른 크기의 트리 2개로 분할될 수 없으므로 역시 <code>-1</code> 을 출력해 준다.</p>\n<p>그 다음에는 연결 요소가 2개일 때를 처리해 준다. 이때 크루스칼로 처리하면 2개의 연결 요소에 들어가 있는 간선들을 분류하는 처리를 해줘야 하므로 나는 프림을 사용했다. 2개의 연결 요소에서 아무 정점이나 하나씩 잡고 프림 알고리즘을 돌리면서 트리를 구성하게 되는 정점과 간선들을 벡터에 각각 담아 주었다.</p>\n<p>그런데 만약 이렇게 만든 2개의 트리의 크기가 같다면 문제의 조건을 만족하지 못한다. 그런데 연결 요소는 처음부터 2개가 주어졌으므로 달리 어떻게 분할해도 2개의 트리의 크기는 같을 수밖에 없다. 따라서 이 경우 <code>-1</code>을 출력해 준다. 그게 아닌 경우에는 아까 만든 벡터의 원소들을 형식에 맞게 출력해 주면 된다.</p>\n<p>그리고 마지막으로 연결 요소가 1개일 때이다. 이때도 아무 정점이나 하나 잡고(나는 1 정점을 잡아 주었다)거기서 프림을 돌리면서 붙는 정점과 간선들을 모두 벡터에 담아 주었다. 그리고 트리의 정점들을 담는 벡터 사이즈가 <code>n-1</code> 이 되는 순간 프림 알고리즘을 종료한다. n번째 붙는 정점은 혼자서 2번째 트리가 되어야 하기 때문이다.</p>\n<p>그렇게 만든 벡터와 마지막 정점을 형식에 맞게 출력해 주면 된다. 이 경우 2번째 트리에 속하는 간선은 없다. 트리를 이루는 정점은 1개뿐이기 때문이다.</p>\n<p>이 문제를 3번 틀렸는데 딱히 구현 실수 같은 게 있었던 것이 아니라, 처음에 두 트리의 크기를 출력해 줘야 하는데 이 부분을 출력해 주지 않아서였다. 이 부분만 잘 처리해 줬어도 3번 틀리지 않았을 테고 내가 콘테스트 2등이었을지도 모르는데 아쉽다. 2등과 나의 차이는 페널티 10분뿐이었기 때문이다...</p>\n<p>아무튼 내 개인적으로는 상당히 구현이 까다로운 문제였다.</p>\n<pre><code class=\"language-cpp\">#include &#x3C;iostream>\n#include &#x3C;vector>\n#include &#x3C;list>\n#include &#x3C;cstring>\n#include &#x3C;algorithm>\n#include &#x3C;string>\n#include &#x3C;map>\n#include &#x3C;set>\n#include &#x3C;cmath>\n#include &#x3C;queue>\n#include &#x3C;iomanip>\n\nusing namespace std;\ntypedef long long ll;\n\nint n, m;\nvector&#x3C;pair&#x3C;int, int>> adj[200005];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    cin >> n >> m;\n    for (int i = 1; i &#x3C;= m; i++) {\n        int s, e;\n        cin >> s >> e;\n        adj[s].push_back({e, i});\n        adj[e].push_back({s, i});\n    }\n    int visited[200005] = {0};\n    vector&#x3C;int> com_start;\n    //연결 요소를 대표하는 하나의 정점들\n    int component = 0;\n    //연결 요소 개수부터 세자\n    for (int i = 1; i &#x3C;= n; i++) {\n        if (visited[i] == 0) {\n            component++;\n            com_start.push_back(i);\n            list&#x3C;int> q;\n            q.push_front(i);\n            visited[i] = 1;\n            while (!q.empty()) {\n                int cur = q.back();\n                q.pop_back();\n                for (pair&#x3C;int, int> u:adj[cur]) {\n                    int next = u.first;\n                    if (visited[next]) { continue; }\n                    visited[next] = 1;\n                    q.push_front(next);\n                }\n            }\n        }\n    }\n    if (component > 2 || n == 1 || n == 2) {\n        //연결 요소 2개 이상이면 애초에 안됨\n        cout &#x3C;&#x3C; -1 &#x3C;&#x3C; \"\\n\";\n    } else if (component == 2) {\n        fill(visited, visited + 200005, 0);\n        int start1 = com_start[0], start2 = com_start[1];\n        //시작 정점들\n        vector&#x3C;int> tree_v1, tree_v2;\n        vector&#x3C;int> tree_e1, tree_e2;\n        //두 트리의 정점과 간선들 저장\n        priority_queue&#x3C;pair&#x3C;int, int>> pq;\n        for (pair&#x3C;int, int> p:adj[start1]) {\n            pq.push(p);\n        }\n        visited[start1] = 1;\n        tree_v1.push_back(start1);\n        while (!pq.empty()) {\n            pair&#x3C;int, int> cur = pq.top();\n            pq.pop();\n            //cur.first는 정점 번호, cur.second는 간선 번호\n            if (visited[cur.first]) { continue; }\n            visited[cur.first] = 1;\n            tree_v1.push_back(cur.first);\n            tree_e1.push_back(cur.second);\n            for (pair&#x3C;int, int> p:adj[cur.first]) {\n                pq.push(p);\n            }\n        }\n\n        fill(visited, visited + 200005, 0);\n        for (pair&#x3C;int, int> p:adj[start2]) {\n            pq.push(p);\n        }\n        visited[start2] = 1;\n        tree_v2.push_back(start2);\n        while (!pq.empty()) {\n            pair&#x3C;int, int> cur = pq.top();\n            pq.pop();\n            //cur.first는 정점 번호, cur.second는 간선 번호\n            if (visited[cur.first]) { continue; }\n            visited[cur.first] = 1;\n            tree_v2.push_back(cur.first);\n            tree_e2.push_back(cur.second);\n            for (pair&#x3C;int, int> p:adj[cur.first]) {\n                pq.push(p);\n            }\n        }\n        if (tree_v1.size() == tree_v2.size()) {\n            cout &#x3C;&#x3C; -1 &#x3C;&#x3C; \"\\n\";\n        } else {\n            cout &#x3C;&#x3C; tree_v1.size() &#x3C;&#x3C; \" \" &#x3C;&#x3C; tree_v2.size() &#x3C;&#x3C; \"\\n\";\n            for (int v:tree_v1) {\n                cout &#x3C;&#x3C; v &#x3C;&#x3C; \" \";\n            }\n            cout &#x3C;&#x3C; \"\\n\";\n            for (int e:tree_e1) {\n                cout &#x3C;&#x3C; e &#x3C;&#x3C; \" \";\n            }\n            cout &#x3C;&#x3C; \"\\n\";\n            for (int v:tree_v2) {\n                cout &#x3C;&#x3C; v &#x3C;&#x3C; \" \";\n            }\n            cout &#x3C;&#x3C; \"\\n\";\n            for (int e:tree_e2) {\n                cout &#x3C;&#x3C; e &#x3C;&#x3C; \" \";\n            }\n            cout &#x3C;&#x3C; \"\\n\";\n        }\n    } else {\n        //컴포넌트는 1개뿐. 이때는 미니멈 스패닝 트리 만든후 마지막 하나의 정점이\n        //나머지 하나의 트리이다\n        fill(visited, visited + 200005, 0);\n        int start = 1;\n        vector&#x3C;int> tree_v, tree_e;\n\n        priority_queue&#x3C;pair&#x3C;int, int>> pq;\n        for (pair&#x3C;int, int> p:adj[start]) {\n            pq.push(p);\n        }\n        visited[start] = 1;\n        tree_v.push_back(start);\n        while (!pq.empty() &#x26;&#x26; tree_v.size() &#x3C; n - 1) {\n            pair&#x3C;int, int> cur = pq.top();\n            pq.pop();\n            //cur.first는 정점 번호, cur.second는 간선 번호\n            if (visited[cur.first]) { continue; }\n            visited[cur.first] = 1;\n            tree_v.push_back(cur.first);\n            tree_e.push_back(cur.second);\n            for (pair&#x3C;int, int> p:adj[cur.first]) {\n                pq.push(p);\n            }\n        }\n        cout &#x3C;&#x3C; tree_v.size() &#x3C;&#x3C; \" \" &#x3C;&#x3C; 1 &#x3C;&#x3C; \"\\n\";\n        for (int v:tree_v) {\n            cout &#x3C;&#x3C; v &#x3C;&#x3C; \" \";\n        }\n        cout &#x3C;&#x3C; \"\\n\";\n        for (int e:tree_e) {\n            cout &#x3C;&#x3C; e &#x3C;&#x3C; \" \";\n        }\n        cout &#x3C;&#x3C; \"\\n\";\n        for (int i = 1; i &#x3C;= n; i++) {\n            if (visited[i] == 0) {\n                cout &#x3C;&#x3C; i &#x3C;&#x3C; \"\\n\";\n            }\n        }\n    }\n\n\n    return 0;\n}\n</code></pre>\n<p>이외에 D번도, 처음에 이분탐색까지는 잘 생각했는데 백트래킹을 생각하지 못했다. 그래서 그리디+이분탐색으로 짜다가 틀리고는 바로 E번으로 넘어가 구현에 힘을 쏟았다. 내가 백트래킹을 잘 못하는 편이긴 하지만 D번을 조금만 더 잘 봤으면 정말로 2등을 할 수 있었을지도 모르는데 아쉬운 점이다.</p>\n<p>하지만 실전은 실전이고 아쉬워만 하면 아무것도 할 수 없다. 3등에 매우 만족한다.</p>\n<h1>5. 마지막</h1>\n<p>실적만 본다면, 나는 점점 퇴보해왔다. 그 증거로, 신촌연합 명예의 전당에는 내 이름이 이미 2개나 박혀 있다.</p>\n<p><img src=\"/static/suapc-4a8b3bba.png\" alt=\"suapc\"></p>\n<p>SUAPC 2020 summer 수상내역. 5등 팀에 내 이름이 있다. 그리고 팀명을 저렇게 지은 것은 아직도 후회하고 있다. 이 후회는 당시의 팀원 모두가 공유하고 있는 듯 하다.</p>\n<hr>\n<p><img src=\"/static/mento-2f73474f.png\" alt=\"mento\"></p>\n<p>2021 겨울 신촌연합 알고리즘 캠프 멘토 목록. 내가 들어가 있다.</p>\n<hr>\n<p>처음에는 SUAPC 수상자, 그 다음에는 초급반 멘토, 그리고는 초급반 수강생이 되었다. 만약 이러한 실적이, 또 어떤 위치에 있는지가 실력을 증명하는 것이라고 한다면 나는 점점 실력이 떨어졌다고 할 수 있을 것이다. 그러나  실제로 그렇지는 않다. 아무런 직위나 위치가 없는데도 말도 안 되는 실력을 가진 사람들을 나는 많이 보았다.</p>\n<p>게다가 나는 계속 알고리즘을 조금씩이나마 해왔는데 실력이 퇴보했다는 것은 말이 안 되는 일이다. 아주 성실하지는 않았지만 퇴보가 당연할 정도로 살지도 않았다. 나는 그래서, 내 자리를 찾아온 것 뿐이라고 생각한다. 원래부터 기초 기반을 쌓아올려야 하는 사람이었는데 잠시 거품이 꼈다가 이제야 기초를 쌓아나가는 내 자리로 돌아왔다는 생각이다. 그리고 초급반 콘테스트에서 3등을 함으로써, 기초를 조금은 닦았다는 증명을 했다고 생각한다.</p>\n<p>물론 아직 나는 한참 멀었다. 나는 알고리즘을 조금씩이라도 계속할 것이고 어떤 확고한 목표를 향해 달려가는 건 아니더라도 이 알고리즘 판에서 얻을 수 있는 게 있다면 더 얻고 싶다. solved 다이아 티어도 찍고 싶고 코드포스 블루도 찍고 싶으며 골드 문제 랜덤 디펜스가 가능할 정도의 탄탄한 실력을 쌓고 싶다. 고급 알고리즘 따위로 거품 낀 실력이 아니라 제대로 된 어떤 실력 기반을 쌓아 나가고 싶다. 또한 기존 팀원들이 ICPC도 나가볼 생각이 있다고 하여 한번쯤은 넘봐볼까 생각하고 있다.</p>\n<p>졸업까지 약 1년 반 정도가 남았는데, 그동안 그런 목표들을 이룰 수 있었으면 좋겠다. 그리고 그런 다음 목표들에 가까이 다가갈 수 있는 기반을, 이번 캠프를 통해서 조금 더 빠르게 쌓을 수 있었다고 생각한다. 이런 기회를 제공해준 신촌연합에 감사하며, 나중에 멘토 같은 자리에서 캠프를 도울 수 있는 기회가 있다면 한번쯤은 내가 도움이 되었으면 싶다.</p>",
    "excerpt": "신촌연합 알고리즘 캠프 후기\n1. 캠프 콘테스트 3등\n\n신촌연합 알고리즘 캠프 초급반 콘테스트에서 3등을 했다. 꽤 괜찮은 성적이라고 생각한다. 사실 내가 내 스스로의 힘으로, 내가 그럭저럭 만족할 만한 어떤 결과를 낸 것이 처음이기에 조금은 홀가분한 마음으로 TMI 투성이인 후기를 쓴다. 게다가 후기를 쓰면 추첨을 통해 경품을 주는 이벤트도 진행 중이라 안 쓸 수가 없었다.\n2. 나에 대하여\n\n방학 시작할 때의 프로필이 없어서 올리는 현재의 내 프로필\n\n나는 ",
    "headingTree": [
      {
        "title": "신촌연합 알고리즘 캠프 후기",
        "url": "#신촌연합-알고리즘-캠프-후기",
        "items": []
      },
      {
        "title": "1. 캠프 콘테스트 3등",
        "url": "#1-캠프-콘테스트-3등",
        "items": []
      },
      {
        "title": "2. 나에 대하여",
        "url": "#2-나에-대하여",
        "items": []
      },
      {
        "title": "3. 신촌연합 알고리즘 캠프",
        "url": "#3-신촌연합-알고리즘-캠프",
        "items": [
          {
            "title": "3.1 캠프의 진행",
            "url": "#31-캠프의-진행",
            "items": []
          },
          {
            "title": "3.2 캠프 이야기 - 출석 문제",
            "url": "#32-캠프-이야기---출석-문제",
            "items": []
          },
          {
            "title": "3.3 캠프 이야기 - 강의와 연습문제",
            "url": "#33-캠프-이야기---강의와-연습문제",
            "items": []
          },
          {
            "title": "3.4 캠프 이야기 - 캠프의 효용에 대하여",
            "url": "#34-캠프-이야기---캠프의-효용에-대하여",
            "items": []
          }
        ]
      },
      {
        "title": "4. 캠프 콘테스트",
        "url": "#4-캠프-콘테스트",
        "items": [
          {
            "title": "A. 이진수 나눗셈",
            "url": "#a-이진수-나눗셈",
            "items": []
          },
          {
            "title": "C. permutation making",
            "url": "#c-permutation-making",
            "items": []
          },
          {
            "title": "B. 송이의 카드 게임",
            "url": "#b-송이의-카드-게임",
            "items": []
          },
          {
            "title": "E. 그래프 트리 분할",
            "url": "#e-그래프-트리-분할",
            "items": []
          }
        ]
      },
      {
        "title": "5. 마지막",
        "url": "#5-마지막",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 3,
      "wordCount": 820
    },
    "url": "/posts/sinchon-camp-2021-summer",
    "thumbnail": {
      "local": "/static/scoreboard-f28f7b93.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-scoreboard-f28f7b93-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAADCAIAAAAhqtkfAAAACXBIWXMAAAsTAAALEwEAmpwYAAAASklEQVR4nGPo7Gn8/v3Hmzevv3379v///48f3zLo8/bN7Geor8n/////HzD4////i1dPGUQYThw5wNBcV4gs8fzFY0lT8dsXLwEAJUE3LDZsDFgAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "swr-global-state",
    "title": "SWR로 전역 상태 관리해보기",
    "date": "2023-03-21T02:00:00Z",
    "description": "SWR로 전역 상태 관리도 가능하다고?",
    "tags": [
      "web",
      "study",
      "front"
    ],
    "html": "<h1>1. SWR로도 전역 상태 관리가 가능하다?</h1>\n<p>SWR은 React에서 사용하는 라이브러리로, 데이터를 가져오는 것을 도와주는 라이브러리이다. 클라이언트와 서버의 관심사를 분리해야 한다는 철학에서 나왔다. 따라서 서버 데이터를 fetching하는 것을 도와준다.</p>\n<p>이는 recoil, jotai 등의 전역 상태 관리 라이브러리와는 분명 다른 목적에 쓰라고 만들어졌다. 하지만 SWR을 사용하면 전역 상태 관리도 가능하다고 한다. 따라서 그 방법을 알아보았다.</p>\n<p>SWR은 설치되어 있다고 가정하겠다.</p>\n<h1>2. 전역 상태 관리하기, context API로</h1>\n<p>전역 상태 관리를 위해서는 두 다른 컴포넌트가 같은 데이터를 공유하도록 하면 된다. 예를 들어서 다음과 같은 상황에서 A, B 컴포넌트에 같은 데이터를 공유하도록 하면 된다. 물론 MyPage에서 관리하는 데이터를 props를 통해서 A, B에 전달하는 것이 아니라, A에서 필요한 데이터를 A에서 즉시 불러와서 사용할 수 있도록 하는 것이다.</p>\n<p>만약 React에서 기본적으로 제공하는 context API를 사용해서 전역 상태 관리를 구현하면 다음과 같이 될 것이다.</p>\n<pre><code class=\"language-jsx\">export const MyContext = React.createContext(\"default value\");\n\nfunction MyPage() {\n  const contextData = \"못의 날개는 세기의 명곡이다\";\n\n  return (\n    &#x3C;MyContext.Provider value={contextData}>\n      &#x3C;section>\n        &#x3C;A />\n        &#x3C;B />\n      &#x3C;/section>\n    &#x3C;/MyContext.Provider>\n  );\n}\n</code></pre>\n<p>Provider에 감싸인 컴포넌트에서는 컨텍스트 값을 가져와서 사용할 수 있다.</p>\n<pre><code class=\"language-jsx\">function A() {\n  const context = React.useContext(MyContext);\n  return &#x3C;div>{context}&#x3C;/div>;\n}\n\nfunction B() {\n  const context = React.useContext(MyContext);\n  return &#x3C;div>{context}&#x3C;/div>;\n}\n</code></pre>\n<p>이걸 SWR을 사용해서 똑같이 해보자.</p>\n<h1>3. SWR로 전역 상태 관리하기</h1>\n<p>SWR은 fetch한 데이터를 로컬 어딘가에 캐싱해 놓는다. 그리고 이를 fetch에 쓰인 key와 연동한다. 그리고 갱신 요청이 없다면 그 캐시를 사용한다.</p>\n<p>예를 들어서 <code>/data</code>라는 URL에 어떤 데이터가 저장되어 있다. 그리고 <code>/data</code>에 저장된 데이터가 필요한데 그게 없다면 새로 fetch한다. 하지만 만약 그 데이터가 이미 fetch된 상태이며 갱신될 필요가 없다면 SWR은 그것을 가져와서 주는 것이다. 이렇게 SWR은 데이터를 캐싱해 놓는다.</p>\n<p>즉 클라이언트 어딘가에 데이터를 캐싱해 놓는다는 뜻이다! 이걸 보면 간단한 전역 상태 관리를 할 수 있다고 생각할 수 있다.</p>\n<h2>3.1. 상태 만들기</h2>\n<p>SWR로 전역 상태를 관리하는 것은 SWR이 useSWR에 주어진 key에 데이터를 연동하는 것을 이용해서 구현한다. 다음과 같이 쓰는 것이다. 일단 SWR로 상태를 하나 만들자.</p>\n<pre><code class=\"language-jsx\">const { data, mutate } = useSWR(\"global\", {\n  fallbackData: \"뭐든 할 수 있을 것만 같던 매일 밤 차오르는 마음은\",\n});\n</code></pre>\n<p>이렇게 짜면 \"global\"이라는 키와 연동된 클라이언트 캐시가 없으므로 SWR은 <code>http://localhost:3000/global</code>에 fetcher로 요청을 보내게 된다. 그런데 우리는 fetcher 인수를 전달하지 않았다. 따라서 default fetcher로 요청을 보내게 된다. 그 fetcher는 다음과 같다.</p>\n<pre><code class=\"language-jsx\">fetcher = window.fetch(url).then(res => res.json())\n</code></pre>\n<p><code>http://localhost:3000/global</code>에는 아무것도 없다. 당연히 fetcher에선 에러가 발생한다. 하지만 이를 catch하는 코드가 없으므로 그냥 넘어간다. 그러나 fetch의 실패는 인식되므로 클라이언트 캐시에 fallbackData가 사용되고 이는 우리가 전달한 key인 \"global\"과 엮인다.</p>\n<p>즉 현재 클라이언트 캐시에는 \"global\"이라는 키와 \"뭐든 할 수 있을 것만 같던 매일 밤 차오르는 마음은\"라는 데이터가 연동되어 있다. 그리고 이를 data인수로 조회할 수 있다.</p>\n<pre><code class=\"language-jsx\">function A() {\n  const { data, mutate } = useSWR(\"global\", {\n    fallbackData: \"뭐든 할 수 있을 것만 같던 매일 밤 차오르는 마음은\",\n  });\n  if (!data) {\n    return &#x3C;div>로딩중&#x3C;/div>;\n  }\n  return &#x3C;div>{data}&#x3C;/div>;\n}\n</code></pre>\n<h2>3.2. 상태 변경하기</h2>\n<p>그럼 이렇게 저장한 전역 상태를 어떻게 변경할 수 있을까? mutate를 사용하면 된다. SWR의 mutate는 클라이언트 캐시를 변경하게 해준다. 이 API에 관한 자세한 내용은 <a href=\"https://swr.vercel.app/ko/docs/mutation\">공식 문서</a>를 참고하자.</p>\n<p>mutate에 비동기 함수를 전달하여 서버에서 데이터를 변경하는 작업을 할 수도 있지만, 우리는 클라이언트 캐싱을 이용하여 전역 상태 관리를 할 뿐이므로 단순히 캐시 업데이트만 해주자.</p>\n<p>위의 전역 상태 데이터는 노래 가사인데, 버튼을 누르면 다음 가사 한 소절을 표시해 주는 것을 구현해보자.</p>\n<pre><code class=\"language-jsx\">function A() {\n  const { data, mutate } = useSWR(\"global\", {\n    fallbackData: \"뭐든 할 수 있을 것만 같던 매일 밤 차오르는 마음은\",\n  });\n  if (!data) {\n    return &#x3C;div>로딩중&#x3C;/div>;\n  }\n  return (\n    &#x3C;div>\n      {data}\n      &#x3C;button\n        onClick={() => {\n          mutate(\"아물지 못하는 어제를 끌어안고 썩어버린 채 말이 없네\");\n        }}\n      >\n        다음 소절\n      &#x3C;/button>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<p>위 코드의 mutate는 useSWR의 리턴값을 사용했으므로 key는 기본적으로 바인딩되어 있다. 따라서 클라이언트 캐시를 어떤 값으로 업데이트할지만 전달해 주면 된다. 즉 위 코드에서 버튼을 누르면 \"global\"에 바인딩된 클라이언트 캐시가 변경되는 것이다.</p>\n<p>그리고 mutate로 클라이언트 캐시를 최신화하고 나면 자동으로 useSWR의 리턴값인 data가 서버 데이터 fetch를 통해 최신화된다. 하지만 우리가 짠 코드에선 어차피 서버 데이터를 fetch할 수 없기 때문에(정확히는 에러 발생) 우리가 mutate로 업데이트한 클라이언트 캐시가 계속 사용된다.</p>\n<p>우리는 클라이언트 캐시를 마치 전역 상태처럼 사용함으로써 SWR의 상태 관리를 하는 것이다.</p>\n<h2>3.3. fetch 최소화</h2>\n<p>데이터 fetch 요청은 많을수록 좋지 않다. 그럼 우리의 코드는 지금 얼마나 많은 fetch 요청을 보내고 있을까?</p>\n<p>fetch를 할 때마다 콘솔 메시지를 출력하도록 해서 얼마나 많은 요청이 가고 있을지를 알아보자. 다음과 같이 fetcher 함수를 작성한다. 기본 fetcher에 콘솔을 찍는 기능을 추가한 것 뿐이다.</p>\n<pre><code class=\"language-jsx\">const fetcher = (url: string) => {\n  console.log(\"fetch 요청\");\n  return fetch(url).then((res) => res.json());\n};\n</code></pre>\n<p>그리고 이를 아까 코드의 useSWR 인수에 추가한다.</p>\n<pre><code class=\"language-tsx\">function A() {\n  const { data, mutate } = useSWR(\"global\", fetcher, {\n    fallbackData: \"뭐든 할 수 있을 것만 같던 매일 밤 차오르는 마음은\",\n  });\n  if (!data) {\n    return &#x3C;div>로딩중&#x3C;/div>;\n  }\n  return (\n    &#x3C;div>\n      {data}\n      &#x3C;button\n        onClick={() => {\n          mutate(\"아물지 못하는 어제를 끌어안고 썩어버린 채 말이 없네\");\n        }}\n      >\n        다음 소절\n      &#x3C;/button>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<p>이 상태에서 A 컴포넌트를 렌더링하면 콘솔에 fetch 요청이 반복되어 출력되는 것을 볼 수 있다. 나는 한번도 클라이언트 캐시를 갱신하지 않았는데도. 그리고 mutate를 하고 나면 더 자주 fetch된다.</p>\n<p>우리의 최적 목표는 클라이언트 캐시를 최신화할 때만 fetch를 하고, 그 외에는 fetch를 하지 않는 것이다. 그럼 이를 어떻게 구현할 수 있을까? 필요없는 fetch를 생각해서 없애 보자.</p>\n<p>먼저 fetcher에서 에러가 발생했을 때 재시도하는 게 있다. 하지만 우리는 클라이언트 캐시만 이용하므로 이 옵션은 사실상 필요가 없다. 이는 useSWR 옵션에서 shouldRetryOnError를 false로 설정하면 재시도를 막을 수 있다.</p>\n<pre><code class=\"language-tsx\">const { data, mutate } = useSWR(\"global\", fetcher, {\n  fallbackData: \"뭐든 할 수 있을 것만 같던 매일 밤 차오르는 마음은\",\n  shouldRetryOnError: false,\n});\n</code></pre>\n<p>그리고 SWR에서는 자동 갱신 옵션들이 있다. revalidateIfStale, revalidateOnFocus, revalidateOnReconnect가 자동으로 켜져 있는데, 이로 인해서 갱신이 많이 되는 것이다. 물론 focusThrottleInterval이 기본적으로 5초로 설정되어 있기 때문에 너무 자주 갱신되지는 않도록 조절되고 있지만 굳이 필요없는 요청을 보낸다는 것은 변함이 없다.</p>\n<p>이런 모든 종류들의 자동 갱신을 비활성화하는 useSWRImmutable을 쓰자.</p>\n<pre><code class=\"language-tsx\">const { data, mutate } = useSWRImmutable(\"global\", fetcher, {\n  fallbackData: \"뭐든 할 수 있을 것만 같던 매일 밤 차오르는 마음은\",\n  shouldRetryOnError: false,\n});\n</code></pre>\n<p>이렇게 쓰고 나면 상태를 갱신할 때만 fetch가 일어나는 것을 볼 수 있다.</p>\n<h1>4. 커스텀 훅 만들기</h1>\n<p>이를 커스텀 훅으로 만들면 비로소 전역 상태 관리와 같이 쓸 수 있어진다.</p>\n<h2>4.1. 첫번째 커스텀 훅</h2>\n<p>우리는 앞서 노래 가사를 전역 상태로 관리했으므로, useSong이라는 전역 store hook을 만들어 보자.</p>\n<pre><code class=\"language-tsx\">function useSong() {\n  const { data: song, mutate: setSong } = useSWRImmutable(\"song\", fetcher, {\n    fallbackData: \"뭐든 할 수 있을 것만 같던 매일 밤 차오르는 마음은\",\n    shouldRetryOnError: false,\n  });\n  return [song, setSong];\n}\n</code></pre>\n<p>이는 useState와 비슷하게 쓸 수 있다.</p>\n<pre><code class=\"language-tsx\">function A() {\n  const [song, setSong] = useSong();\n  return (\n    &#x3C;div>\n      {song}\n      &#x3C;button\n        onClick={() => {\n          setSong(\"아물지 못하는 어제를 끌어안고 썩어버린 채 말이 없네\");\n        }}\n      >\n        다음 소절\n      &#x3C;/button>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<p>다른 컴포넌트에서도 useSong을 사용할 수 있고, 상태도 공유되는 것을 알 수 있다.</p>\n<h2>4.2. 개선된 커스텀 훅</h2>\n<p>아예 useSWRStore라는 훅을 만들어서 key와 초기값을 설정하여 쓸 수 있도록 하자. key가 같으면 같은 상태를 공유하도록 하자.</p>\n<pre><code class=\"language-tsx\">function useSWRStore(key: string, initialData: any) {\n  const { data, mutate } = useSWRImmutable(key, fetcher, {\n    fallbackData: initialData,\n    shouldRetryOnError: false,\n  });\n  return [data, mutate];\n}\n</code></pre>\n<p>이러면 useSong이 쓰였던 위 컴포넌트를 다음과 같이 바꿀 수 있다.</p>\n<pre><code class=\"language-tsx\">function A() {\n  const [song, setSong] = useSWRStore(\n    \"song\",\n    \"뭐든 할 수 있을 것만 같던 매일 밤 차오르는 마음은\"\n  );\n  return (\n    &#x3C;div>\n      {song}\n      &#x3C;button\n        onClick={() => {\n          setSong(\"아물지 못하는 어제를 끌어안고 썩어버린 채 말이 없네\");\n        }}\n      >\n        다음 소절\n      &#x3C;/button>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<p>그런데 문제가 있다. initialData를 모든 전역 상태 훅에 인수로 전달함으로 인해서 여러 가지 상태가 공존할 수 있게 된다.</p>\n<p>이는 useSWRStore 훅에서 initialData 인수를 제거한 후 상위 SWRConfig에서 fallback을 설정하는 식으로 해결할 수 있을 것으로 생각된다.</p>\n<p>예를 들어서 다음처럼 하는 것이다. song이라는 key에 대해서는 \"초기값\"이라는 값을 fallback으로 설정하는 것이다. 그러면 A, B 컴포넌트에서 <code>useSWRStore(\"song\");</code>을 쓸 때 자동으로 초기값이 \"초기값\"으로 설정된다. 그리고 편집은 똑같이 하면 된다.</p>\n<pre><code class=\"language-tsx\">&#x3C;SWRConfig\n  value={{\n    fallback: {\n      song: \"초기값\",\n    },\n  }}\n>\n  &#x3C;section>\n    &#x3C;A />\n    &#x3C;B />\n  &#x3C;/section>\n&#x3C;/SWRConfig>\n</code></pre>\n<p>A 컴포넌트에서 useSWRStore를 쓰는 예시</p>\n<pre><code class=\"language-tsx\">function A() {\n  const [song, setSong] = useSWRStore(\"song\");\n  return (\n    &#x3C;div>\n      {song}\n      &#x3C;button\n        onClick={() => {\n          setSong(\"아물지 못하는 어제를 끌어안고 썩어버린 채 말이 없네12\");\n        }}\n      >\n        다음 소절\n      &#x3C;/button>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<p>점점 복잡해지는 느낌이 들지만 어쨌든 SWR의 클라이언트 캐싱을 이용해서 전역 상태를 관리하는 게 가능하다는 것이다. 하지만 복잡한 전역 상태가 생긴다면 zustand나 Recoil등 전역 상태관리를 위한 라이브러리를 따로 쓰는 게 더 낫겠다.</p>\n<h1>5. 번외</h1>\n<p>위에서 본 기본 fetcher는 fetch가 실패했을 때 Promise를 catch하는 부분이 없다. 그래서 이상했는데, 핸들링하지 못하는 에러라면 catch를 하지 않는 것이 더 낫다고 한다.</p>\n<p>Promise의 catch를 하는 이유는 에러가 발생할 수 있는 부분에서 실제로 에러가 발생했을 때 어떤 대처를 하고 다른 동작을 하기 위함이다. try-catch를 쓰는 이유와 같다.</p>\n<p>하지만 만약 catch에서 어떤 에러 핸들링을 하지 않고 그저 <code>console.log(err)</code>따위만 한다면 에러 핸들링이 아니다.</p>\n<p>그리고 요즘 JS는 unhandled promise rejection을 따로 처리해줄 수 있는 방법도 있기 때문에 굳이 catch를 쓰지 않아도 된다.</p>\n<p><a href=\"https://stackoverflow.com/questions/54892213/creating-reusable-promises-without-catch\">참고1</a></p>\n<p><a href=\"https://stackoverflow.com/questions/50896442/why-is-catcherr-console-errorerr-discouraged\">참고2</a></p>\n<h1>참고</h1>\n<p><a href=\"https://velog.io/@e_juhee/Global-state\">https://velog.io/@e_juhee/Global-state</a></p>\n<p><a href=\"https://paco.me/writing/shared-hook-state-with-swr\">https://paco.me/writing/shared-hook-state-with-swr</a></p>\n<p>SWR의 디폴트 fetcher <a href=\"https://github.com/vercel/swr/discussions/910\">https://github.com/vercel/swr/discussions/910</a></p>\n<p>fetch <a href=\"https://www.daleseo.com/js-window-fetch/\">https://www.daleseo.com/js-window-fetch/</a></p>\n<p><a href=\"https://ko.javascript.info/promise-error-handling\">https://ko.javascript.info/promise-error-handling</a></p>\n<p><a href=\"https://velog.io/@code-bebop/SWR-%EC%8B%AC%EC%B8%B5%ED%83%90%EA%B5%AC\">https://velog.io/@code-bebop/SWR-%EC%8B%AC%EC%B8%B5%ED%83%90%EA%B5%AC</a></p>",
    "excerpt": "1. SWR로도 전역 상태 관리가 가능하다?\nSWR은 React에서 사용하는 라이브러리로, 데이터를 가져오는 것을 도와주는 라이브러리이다. 클라이언트와 서버의 관심사를 분리해야 한다는 철학에서 나왔다. 따라서 서버 데이터를 fetching하는 것을 도와준다.\n이는 recoil, jotai 등의 전역 상태 관리 라이브러리와는 분명 다른 목적에 쓰라고 만들어졌다. 하지만 SWR을 사용하면 전역 상태 관리도 가능하다고 한다. 따라서 그 방법을 알아보았다.\nSWR은 설",
    "headingTree": [
      {
        "title": "1. SWR로도 전역 상태 관리가 가능하다?",
        "url": "#1-swr로도-전역-상태-관리가-가능하다",
        "items": []
      },
      {
        "title": "2. 전역 상태 관리하기, context API로",
        "url": "#2-전역-상태-관리하기-context-api로",
        "items": []
      },
      {
        "title": "3. SWR로 전역 상태 관리하기",
        "url": "#3-swr로-전역-상태-관리하기",
        "items": [
          {
            "title": "3.1. 상태 만들기",
            "url": "#31-상태-만들기",
            "items": []
          },
          {
            "title": "3.2. 상태 변경하기",
            "url": "#32-상태-변경하기",
            "items": []
          },
          {
            "title": "3.3. fetch 최소화",
            "url": "#33-fetch-최소화",
            "items": []
          }
        ]
      },
      {
        "title": "4. 커스텀 훅 만들기",
        "url": "#4-커스텀-훅-만들기",
        "items": [
          {
            "title": "4.1. 첫번째 커스텀 훅",
            "url": "#41-첫번째-커스텀-훅",
            "items": []
          },
          {
            "title": "4.2. 개선된 커스텀 훅",
            "url": "#42-개선된-커스텀-훅",
            "items": []
          }
        ]
      },
      {
        "title": "5. 번외",
        "url": "#5-번외",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 2,
      "wordCount": 439
    },
    "url": "/posts/swr-global-state",
    "thumbnail": {
      "local": "/thumbnails/swr-global-state-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-swr-global-state-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAkUlEQVR4nE3JIQrDMBQA0FT3CpG9TVTtVCE3yBkCFYGoibKK8ZmYiIvNBSoD0aOwiuiIQMYXf6xqzz5mreWcCyEup2EYQghExJRSXdf1fT+OYwghxlhK+YVzbpomKaVSCgC89wDQWmPbtmmtl2W5nuZ5NsYgInvt+/s4cs61VvrD7o/nbV2dcyklImrtg4hE9AXJQl/1M55d/AAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "swr",
    "title": "데이터 fetch library SWR 익히기",
    "date": "2023-03-09T02:00:00Z",
    "description": "SWR 라이브러리 학습기록",
    "tags": [
      "web",
      "study",
      "front"
    ],
    "html": "<h1>1. 배경설명</h1>\n<p>프론트에서는 서버에 저장되어 있는 데이터를 다룰 때가 많다. 예를 들어서 사용자 프로필 정보를 받아와서 관리하는 등이다.</p>\n<p>이를 관리할 때 원래는 useEffect를 사용하여 페이지의 로드 시 서버에서 정보를 받아오고, 프론트단에 저장하는 게 보통이었다. 그리고 서버 정보 업데이트가 있을 시 프론트에서 계속 그 부분에 대한 처리를 해주어야 했다.</p>\n<p>React 18부터는 Suspense가 나와서 페이지 로드 시 비동기 처리를 간편하게 해주기는 했지만 서버에서 받아온 데이터를 프론트에 저장해 둔다는 건 마찬가지였다.</p>\n<p>이런 상황에 SWR, React query와 같은 라이브러리는 서버 데이터를 프론트에 저장하지 않고 관심사를 분리해야 한다는 철학을 가지고 등장했다.</p>\n<p>그 중에 SWR이라는 라이브러리를 사용해 보았다. state-while-revalidate라는 전략의 약자를 따왔다고 한다. 먼저 캐시에서 데이터를 반환한 후 fetch로 재검증하고 최신화 데이터를 가져오는 전략이다. SWR이 요즘은 React-query에 밀리고 있는 것 같지만 원조를 한번 써보기로 했다.</p>\n<h2>1.1. stale-while-revalidate</h2>\n<p>(2023.07.04 추가)</p>\n<p><code>stale-while-revalidate</code>는 HTTP의 캐시 컨트롤 확장이며 swr은 해당 사항을 구현+확장한 라이브러리이다.</p>\n<p>그럼 이 <code>stale-while-revalidate</code>라는 건 뭘까?</p>\n<p>이는 캐시된 콘텐츠를 즉시 로드하는 즉시성과 업데이트된 캐시 콘텐츠가 향후에 쓰이도록 보장하는 최신성 간의 균형을 유지하는 데에 도움을 준다. 어떻게? 캐시된 데이터를 먼저 보여주고, 그 데이터를 백그라운드에서 업데이트하는 방식을 통해서.</p>\n<p><code>stale-while-revalidate</code>를 포함하는 HTTP Cache-Control 헤더는 max-age 또한 포함해야 한다. 이 max-age는 캐시된 응답이 오래된 것인지를 판단하도록 해준다. 우리는 이 2가지를 이용해서 로컬 캐시 응답에 대한 판단을 내리고 후속 행동을 취할 수 있다.</p>\n<p>예시로 알아보자. 0초 시점에 캐시된 응답이 있다고 하자. 그리고 해당 응답의 Cache-Control 헤더는 다음과 같다.</p>\n<pre><code>Cache-Control: max-age=60, stale-while-revalidate=120\n</code></pre>\n<p>그러면 해당 요청이 60초 이내에 반복되는 경우 max-age에 아직 도달하지 않았으므로 캐시 값은 최신이다. 따라서 캐시된 응답을 재검증 없이 반환한다.</p>\n<p>만약 요청이 60초에서 120초 사이에 반복되면 캐시된 값은 오래된 값이지만 <code>stale-while-revalidate</code>에 의해 캐시된 응답을 반환한다. 그리고 백그라운드에서 새로운 응답을 가져온다. 새로운 응답이 오면 캐시를 업데이트한다.</p>\n<p>120초 이상 지난 후에 요청이 오면 오래된 캐시 컨텐츠는 사용할 수 없다. 따라서 새로운 응답을 서버에서 가져와서 요청에 응답하고 캐시를 업데이트한다.</p>\n<p>SWR 라이브러리에서는 이 전략을 차용하여 낡은 캐시에서 빠르게 컨텐츠를 반환하고, 백그라운드에서는 캐싱 컨텐츠 재검증을 진행하여 최신화된 캐시 데이터를 보장하도록 한다.</p>\n<p><img src=\"/static/swr-001e65a2.svg\" alt=\"swr 로직\"></p>\n<h1>2. vs React-query</h1>\n<p>차후에 기회가 되면 직접 React-query도 써보고 비교해 보려고 한다. 그런데 <a href=\"https://tech.madup.com/react-query-vs-swr/\">매드업 기술블로그의 글</a>에 잘 비교된 글이 있어 한번 읽어 보았다.</p>\n<p>React-query에서는 Mutation을 통해 서버 데이터를 변형하는 것을 지원하고, devTool을 기본적으로 제공하며 무한 스크롤과 같은 UI를 사용할 때 기본 제공하는 프로퍼티를 이용하여 이전 페이지 데이터를 간편하게 불러올 수 있다고 한다.</p>\n<p>그리고 React-query는 다음 데이터를 불러오기 전까지 현재 캐싱된 데이터를 자동으로 반환한다. 이런 것들이 SWR에서도 가능은 하지만 부가적인 코드 작성이 필요하다.</p>\n<p>그리고 React-query는 selector라는 것을 이용하여 쿼리 결과 부분을 추출할 수도 있다. 쿼리가 업데이트될 때만 컴포넌트를 업데이트하고, 여러 컴포넌트가 같은 쿼리를 사용할 시 묶어서 업데이트해주는 등 렌더링 퍼포먼스 최적화도 잘 되어 있다.</p>\n<p>지정된 시간 동안 쿼리가 사용되지 않을 경우 가비지 컬렉션하는 기능도 React-query에서만 지원한다.</p>\n<p>더 자세한 기능은 <a href=\"https://tanstack.com/query/latest/docs/react/comparison?from=reactQueryV3&#x26;original=https%3A%2F%2Ftanstack.com%2Fquery%2Fv3%2Fdocs%2Fcomparison\">React-query 공식문서에서의 비교</a>에서 더 볼 수 있다. 이런 React-query의 우위가 있긴 하지만 <a href=\"https://fe-developers.kakaoent.com/2022/220224-data-fetching-libs/\">카카오 기술블로그</a>에 의하면 SWR도 function이름 정도만 대체하면 쉽게 React-query로 넘어갈 수 있다고 하고, SWR이 더 먼저 나왔다고 하여 한번 사용해 보려고 한다.</p>\n<p>간단한 todoList 정도를 만들까 한다.</p>\n<p>먼저 CRA로 생성한 어플리케이션에 SWR을 깔자. 여기서는 typescript를 사용했다.</p>\n<pre><code class=\"language-bash\">npm i swr\n</code></pre>\n<h1>3. 서버 모킹</h1>\n<p>그리고 간단하게 서버를 모킹하기 위해서 json-server를 사용하였다. msw를 이용할 수도 있겠지만 이는 json-server보다 러닝커브가 좀 더 높다고 생각되어 나중에 테스트를 공부하면서 해볼 예정이다.</p>\n<p>먼저 폴더를 생성한 후 json-server를 설치하자.</p>\n<pre><code class=\"language-bash\">mkdir json-server-test &#x26;&#x26; cd json-server-test\nnpm init -y\nnpm install json-server\n</code></pre>\n<p>그리고 프로젝트 루트에 db.json 파일을 생성하자. 내용은 다음과 같이 간단한 todo리스트 파일을 작성하였다.</p>\n<pre><code class=\"language-json\">{\n  \"todos\": [\n    {\n      \"id\": 1,\n      \"content\": \"Learn React\",\n      \"done\": false\n    },\n    {\n      \"id\": 2,\n      \"content\": \"Learn Redux\",\n      \"done\": false\n    },\n    {\n      \"id\": 3,\n      \"content\": \"Learn React Native\",\n      \"done\": false\n    }\n  ]\n}\n</code></pre>\n<p>그리고 json-server-test폴더의 package.json의 스크립트에 다음과 같은 내용을 추가하자. json-server를 포트 5000으로 실행하도록 하는 것이다.</p>\n<pre><code class=\"language-json\">\"scripts\": {\n  \"start\": \"json-server --watch db.json --port 5000\",\n  \"test\": \"echo \\\"Error: no test specified\\\" &#x26;&#x26; exit 1\"\n},\n</code></pre>\n<p><code>npm start</code>명령으로 실행하면 다음과 같이 서버가 열린다.</p>\n<p><img src=\"/static/json-server-open-4dd63e40.png\" alt=\"json-server-open\"></p>\n<h1>4. 기초적인 SWR 사용</h1>\n<p>서버에 요청을 보낼 때는 axios를 사용할 것이다. 따라서 todolist 폴더로 돌아와서 이를 설치하자.</p>\n<pre><code class=\"language-bash\">npm i axios\n</code></pre>\n<p>URL에서 데이터를 가져오는 fetcher 함수를 만들어 보자.</p>\n<pre><code class=\"language-jsx\">import axios from 'axios';\nconst fetcher = (url: string) => axios.get(url).then((res) => res.data);\n</code></pre>\n<p>그리고 TodoList의 todo 항목들을 나타낼 요소를 간단하게 만든다. 완료 표시와 같은 것들도 만들어야 하겠지만 일단 리스트 요소만 표시하였다.</p>\n<pre><code class=\"language-tsx\">interface Todo {\n  id: number;\n  content: string;\n  done: boolean;\n}\n\nfunction TodoListItem({ todo }: { todo: Todo }) {\n  return (\n    &#x3C;li>\n      &#x3C;span>{todo.content}&#x3C;/span>\n    &#x3C;/li>\n  );\n}\n</code></pre>\n<p>그리고 useSWR 함수를 사용한다. 이따가 더 자세히 알아보겠지만 가장 간단하게 fetch할 주소와 fetcher 함수를 가져오는 방식으로 사용하겠다.</p>\n<pre><code class=\"language-tsx\">function TodoListPage() {\n  const { data, error } = useSWR(\"http://localhost:5000/todos\", fetcher);\n\n  useEffect(() => {\n    console.log(data);\n  }, [data]);\n\n  return (\n    &#x3C;ul>\n      {data\n        ? data.map((todo: Todo) => &#x3C;TodoListItem key={todo.id} todo={todo} />)\n        : null}\n    &#x3C;/ul>\n  );\n}\n</code></pre>\n<p>이러면 데이터를 잘 가져오는 것을 확인할 수 있다.</p>\n<p><img src=\"/static/useswr-res-8b856639.png\" alt=\"useswr\"></p>\n<p>아니면 isLoading을 사용하여 다음과 같이 짤 수도 있다.</p>\n<pre><code class=\"language-tsx\">function TodoListPage() {\n  const { data, error, isLoading } = useSWR(\n    \"http://localhost:5000/todos\",\n    fetcher\n  );\n\n  if (error) {\n    return &#x3C;div>failed to load!&#x3C;/div>;\n  }\n  if (isLoading) {\n    return &#x3C;div>loading TodoList...&#x3C;/div>;\n  }\n\n  return (\n    &#x3C;ul>\n      {data\n        ? data.map((todo: Todo) => &#x3C;TodoListItem key={todo.id} todo={todo} />)\n        : null}\n    &#x3C;/ul>\n  );\n}\n</code></pre>\n<h1>5. useSWR</h1>\n<p>useSWR은 다음과 같이 사용한다. 이때 key 외에는 모두 선택 인자라서 없어도 된다. 그런데 fetcher가 없어도 된다고?</p>\n<p>알고 보니 fetcher를 전역으로 제공할 수 있는 방법이 있고 이럴 경우에 생략이 가능하다는 것이었다. 이렇게 전역 설정을 하는 법은 조금 뒤에 정리할 것이다.</p>\n<pre><code class=\"language-tsx\">const { data, error, isLoading, isValidating, mutate } = useSWR(key, fetcher, options)\n</code></pre>\n<p>위에서 보았듯이 key는 요청할 URL이다. 함수, 배열, null도 전달할 수 있다. fetcher는 데이터를 가져오기 위한 함수를 반환하는 Promise이고 options는 옵션들을 담은 객체이다.</p>\n<h2>5.1. 반환값</h2>\n<p>useSWR은 다음과 같은 값을 반환한다.</p>\n<ul>\n<li>data: 데이터, fetcher 함수가 주어진 key에 대해 fetch한 데이터. 아직 로드되지 않은 상태에는 undefined이다.</li>\n<li>error : fetcher 함수가 주어진 key에 대해 fetch하는 도중 에러가 발생하면 에러 객체를 반환한다. 에러가 없으면 undefined</li>\n<li>isLoading : 진행 중인 요청이 있고 로드된 데이터가 없으면 true, 아니면 false</li>\n<li>isValidating : 데이터 요청이나 갱신 중이면 true, 아니면 false</li>\n<li>mutate(data?, options) : 캐싱된 데이터를 변형한다.</li>\n</ul>\n<p>이때 mutate를 사용하는 방법은 후에 더 자세히 다룰 것이다.</p>\n<h2>5.2. 옵션 객체</h2>\n<p>옵션 객체는 다음과 같은 속성들을 가질 수 있다.</p>\n<h3>5.2.1. Suspense</h3>\n<p>React 18부터 제공되는 suspense를 사용할 수 있다. options 객체에 suspense를 true로 설정하면 된다. 단 리액트에서는 데이터 fetching 프레임워크에 suspense를 쓰는 걸 권장하지는 않는다.</p>\n<p>Suspense를 사용하여 TodoListPage를 다음과 같이 바꿔볼 수 있다. 일반적으로 suspense를 활성화하면 렌더링 시점에는 data가 항상 준비된 상태이다.</p>\n<pre><code class=\"language-tsx\">function TodoListPage() {\n  const { data } = useSWR(\"http://localhost:5000/todos\", fetcher, {\n    suspense: true,\n  });\n\n  return (\n    &#x3C;Suspense fallback={&#x3C;div>Loading...&#x3C;/div>}>\n      &#x3C;ul>\n        {data\n          ? data.map((todo: Todo) => &#x3C;TodoListItem key={todo.id} todo={todo} />)\n          : null}\n      &#x3C;/ul>\n    &#x3C;/Suspense>\n  );\n}\n</code></pre>\n<h3>5.2.2. 자동 갱신 옵션</h3>\n<p>SWR은 몇몇 시점에 자동으로 데이터를 갱신한다. 이를 위해 refreshInterval, refreshWhenHidden, refreshWhenOffline, revalidateOnFocus, revalidateOnReconnect, revalidateOnMount 옵션을 제공한다.</p>\n<p>revalidateOnFocus는 페이지에 다시 포커스하거나 탭을 전환할 때 자동으로 데이터를 갱신하는 옵션이다. 이 옵션은 기본적으로 true이다.</p>\n<p>refreshInterval은 데이터를 갱신하는 주기를 설정한다. 이 옵션을 지정한 useSWR 훅과 관련된 컴포넌트가 화면상에 있을 때만 갱신된다. 기본적으로는 0이고 ms단위로 설정할 수 있으며 함수가 들어갈 경우 함수가 최신 데이터를 인수로 받고 갱신 주기를 반환하는 형식이 된다.</p>\n<pre><code class=\"language-tsx\">// 숫자를 전달할 경우\nconst { data } = useSWR(key, fetcher, {\n  refreshInterval: 1000\n})\n\n// 함수를 전달할 경우\nconst { data } = useSWR(key, fetcher, {\n  refreshInterval: (data) => data.interval\n})\n</code></pre>\n<p>revalidateOnReconnect는 네트워크 연결이 끊어졌다가 다시 연결되었을 때 자동으로 데이터를 갱신하는 옵션이다. 네트워크가 회복될 때 자동으로 갱신하는 게 일반적이므로 기본적으로 true이다.</p>\n<p>revalidateOnMount는 컴포넌트가 마운트될 때 자동으로 데이터를 갱신하는 옵션이다.</p>\n<p>revalidateIfStale는 컴포넌트 마운트 시 데이터가 오래되었을 때 자동으로 데이터를 갱신하는 옵션이다. 이 옵션은 기본적으로 true이다.</p>\n<p>refreshWhenHidden, refreshWhenOffline은 각각 브라우저 탭이 숨겨졌을 때, 브라우저가 오프라인일 때 자동으로 데이터를 갱신하는 옵션이다. 이 옵션은 기본적으로 false라서 SWR은 페이지가 화면상에 없거나 네트워크 연결이 오프라인이면 데이터를 갱신하지 않는다.</p>\n<p>만약 서버 리소스가 한번 받아오고 나서는 불변하는 경우가 있다고 하자. 이런 경우 모든 자동 갱신을 비활성화하여 불필요한 요청을 줄일 수 있다.</p>\n<pre><code class=\"language-tsx\">const { data } = useSWR(key, fetcher, {\n  revalidateIfStale: false,\n  revalidateOnFocus: false,\n  revalidateOnReconnect: false\n});\n</code></pre>\n<p>SWR 1.0부터는 이렇게 불변하는 자원을 가져오는 기능을 위해서 useSWRImmutable이라는 훅을 제공한다. 이 훅은 자동 갱신을 비활성화하고 데이터를 불변하게 만든다.</p>\n<pre><code class=\"language-tsx\">const { data } = useSWRImmutable(key, fetcher);\n</code></pre>\n<p>위의 두 훅은 완전히 똑같은 기능을 한다.</p>\n<h3>5.2.3. 에러 관련 옵션</h3>\n<p>shouldRetryOnError는 에러가 발생했을 때 재시도를 할지 여부를 설정하는 옵션이다. 이 옵션은 기본적으로 true이다.</p>\n<p>errorRetryInterval은 에러가 발생했을 때 재시도 간격을 설정하는 옵션이다. 기본적으로 5초이다. ms 단위로 설정 가능하며, 느린 네트워크 환경에서는 재시도 간격이 기본적으로 10초로 설정된다.</p>\n<p>errorRetryCount는 에러가 발생했을 때 재시도 횟수를 설정하는 옵션이다.</p>\n<h3>5.2.4. 갱신 간격 옵션</h3>\n<p>dedupingInterval은 같은 키를 가진 요청이 동시에 들어왔을 때 중복된 요청을 방지하는 간격을 설정하는 옵션이다. ms단위로 설정되며 기본적으로 2초이다.</p>\n<p>focusThrottleInterval은 focus 이벤트가 발생했을 때 갱신을 방지하는 간격을 설정하는 옵션이다. ms단위로 설정되며 기본적으로 5초이다.</p>\n<p>loadingTimeout은 데이터를 가져오는데 시간이 오래 걸릴 때 로딩 상태를 보여주는 시간을 설정하는 옵션이다. ms단위로 설정되며 기본적으로 3초이다. 데이터를 가져오는 데 이 이상 시간이 걸리면 onLoadingSlow 콜백이 호출된다.</p>\n<h3>5.2.5. 이외의 콜백 함수</h3>\n<p>onSuccess(data, key, config)는 데이터를 성공적으로 가져왔을 때 호출되는 콜백 함수이다.</p>\n<p>onError(err, key, config)는 데이터를 가져오는 도중 에러가 발생했을 때 호출되는 콜백 함수이다.</p>\n<p>onErrorRetry(err, key, config, revalidate, revalidateOps)는 onError 콜백 함수가 호출된 후 재시도를 할 때 호출되는 콜백 함수이다.</p>\n<p>onDiscarded(key)는 race condition으로 인해 이 key에 대한 요청이 무시될 경우 실행되는 콜백 함수이다.</p>\n<p>나머지 compare, isPaused, use 등도 있지만 정말로 쓸 일이 없을 것 같다. 그냥 눈에만 익혀 둬야겠다.</p>\n<h1>6. 전역 설정</h1>\n<p>SWR은 전역 설정을 지원한다. SWRConfig 컴포넌트를 사용하면 이 컴포넌트 내부의 모든 컴포넌트에서 쓰이는 SWR 훅의 options 설정을 한 번에 할 수 있다.</p>\n<pre><code class=\"language-tsx\">import { SWRConfig } from 'swr'\n\nfunction App() {\n  return (\n    &#x3C;SWRConfig\n      value={options}\n    >\n      &#x3C;Component />\n    &#x3C;/SWRConfig>\n  )\n}\n</code></pre>\n<p>위 코드의 options 객체에 들어갈 수 있는 값은 useSWR의 옵션과 동일하다. 위에서는 다루지 않았는데 이 options 인수에는 fetcher 함수도 들어갈 수 있다.</p>\n<p>이를 이용하면 특정 SWRConfig 내부에서 공통적으로 사용하는 fetcher 함수를 설정할 수 있다. 이 경우 useSWR 훅에 따로 fetcher 함수를 넣어주지 않아도 된다. 물론 따로 fetcher를 넣어 줄 경우 오버라이드는 가능하다.</p>\n<p>SWRConfig를 중첩해서 쓰면 상위 컨텍스트의 설정이 오버라이드된다.</p>\n<p>그리고 SWRConfig의 value 객체에는 함숫값들도 넣을 수 있는데 이렇게 함숫값을 넣게 되면 함수는 상위 config 설정을 인수로 받고 새로운 설정을 반환한다.</p>\n<p>useSWRConfig 훅을 사용하면 현재 SWRConfig의 설정을 가져올 수 있다.</p>\n<pre><code class=\"language-tsx\">import { useSWRConfig } from 'swr'\n\nfunction Component() {\n  // 만약 상위 컴포넌트에 SWRConfig가 없다면 기본값 반환\n  const { cache, mutate, ...restConfig } = useSWRConfig()\n  // ...\n}\n</code></pre>\n<h1>7. 에러 처리</h1>\n<p>useSWR 훅에 제공한 fetcher 함수의 동작에서 에러가 발생할 시 error로 반환된다. 즉 throw될 경우 error가 반환되는 것이다.</p>\n<pre><code class=\"language-tsx\">const {data, error}=useSWR(key, fetcher);\n</code></pre>\n<p>fetcher가 실패할 시 error 객체를 반환할 때 더 많은 정보를 반환하도록 할 수 있다. 이는 <a href=\"https://swr.vercel.app/ko/docs/error-handling#%EC%83%81%ED%83%9C-%EC%BD%94%EB%93%9C%EC%99%80-%EC%97%90%EB%9F%AC-%EA%B0%9D%EC%B2%B4\">여기</a>를 참고.</p>\n<p>그리고 SWR은 에러 발생시 요청을 재시도하는데, onErrorRetry 옵션 콜백을 이용하면 에러가 발생했을 때 재시도를 하는 함수를 오버라이드할 수도 있다. 이를 SWRConfig 전역 설정을 이용해 제공할 경우 많은 컴포넌트들 내부의 훅에 공통적으로 에러 재시도 로직을 제공할 수 있다.</p>\n<p>또한 만약 에러 발생 시 어떤 로직을 실행하길 원할 경우 onError 콜백을 사용할 수도 있다. 에러를 토스트 등으로 보여주길 원할 때이다.</p>\n<h1>8. 조건부 fetch</h1>\n<p>useSWR에서 key 인수가 null이거나, key 인수에 전달한 함수가 falsy값을 반환할 경우 SWR은 fetch를 하지 않는다. 이를 이용하면 조건부 fetch를 할 수 있다.</p>\n<pre><code class=\"language-tsx\">const { data, error } = useSWR(\n  isLogin ? '/api/user' : null,\n  fetcher\n)\n</code></pre>\n<p>위와 같이 쓸 경우 isLogin이 false일 경우 fetch를 하지 않는다.</p>\n<p>이를 이용하면 다른 데이터에 의존하는 데이터를 가져올 수도 있다.</p>\n<pre><code class=\"language-tsx\">const {data:user}=useSWR('/api/user', fetcher);\nconst {data:posts}=useSWR(user ? `/api/posts?userId=${user.id}` : null, fetcher);\n</code></pre>\n<p>위와 같이 쓸 경우 user가 null일 경우 posts를 가져오는 훅은 작동하지 않는다. 이를 이용하면 user가 존재할 때만 posts를 가져오도록 할 수 있다.</p>\n<h1>9. fetcher 함수 인자</h1>\n<p>useSWR의 key 인수는 기본적으로 fetcher인자로 받은 함수의 인자로 전달된다. 일반적으로 이 key 인수는 fetch해올 URL이 된다.</p>\n<p>그런데 이 fetcher 함수에 다른 인자, 예를 들어서 로그인한 유저의 jwt 토큰을 함께 붙여서 fetch를 하고 싶을 수도 있다.</p>\n<p>이 경우 useSWR의 key 인자에 배열을 넣어 줄 수 있다.</p>\n<pre><code class=\"language-tsx\">const { data, error } = useSWR(\n  ['/api/user', token],\n  (url, token) => fetcher(url, token)\n)\n</code></pre>\n<p>이렇게 하면 fetcher 함수의 인자로 url과 token이 전달된다.</p>\n<h1>10. mutation</h1>\n<p>SWR은 데이터를 fetch하는 것 뿐만 아니라 데이터를 변경하는 기능도 mutate를 통해 제공한다.</p>\n<p>이를 사용하는 방법은 모든 키에 대해 데이터를 변경할 수 있는 전역 mutate API와 특정 hook에 대한 mutate API가 있다.</p>\n<h2>10.1. 전역 mutate API</h2>\n<p>전역 mutate API는 useSWRConfig 훅을 이용해 가져올 수 있다.</p>\n<pre><code class=\"language-tsx\">import { useSWRConfig } from 'swr'\n\nfunction Component() {\n  const { mutate } = useSWRConfig()\n  // ...\n}\n</code></pre>\n<p>전역으로 가져올 수도 있다.</p>\n<pre><code class=\"language-tsx\">import { mutate } from 'swr'\n</code></pre>\n<p>그리고 이 mutate 함수는 다음과 같이 사용할 수 있다.</p>\n<pre><code class=\"language-tsx\">mutate(key, data, options)\n</code></pre>\n<h2>10.2. 특정 hook에 대한 mutate API</h2>\n<p>특정 hook에 대한 mutate API는 useSWR 훅을 이용해 가져올 수 있다. 이미 위에서 useSWR훅의 반환값으로 mutate 함수도 존재함을 배웠다.</p>\n<p>이렇게 bound mutate를 사용하는 경우 해당 훅의 key에 대해서만 데이터를 변경할 수 있으며 mutate 함수에 대해 따로 key를 제공할 필요가 없다.</p>\n<pre><code class=\"language-tsx\">const { data, mutate } = useSWR('/api/user', fetcher)\nmutate(data, options)\n</code></pre>\n<h2>10.3. mutate API 형식</h2>\n<p>mutate API는 다음과 같은 형식을 가진다.</p>\n<pre><code class=\"language-tsx\">mutate(key, data, options)\n</code></pre>\n<h3>10.3.1. key 인수</h3>\n<p>key는 mutate할 데이터의 key이다. 즉 해당 key에 대한 데이터를 mutate한다는 의미이다. useSWR의 key 인수와 비슷하다.</p>\n<p>그런데 useSWR의 key 인수와 약간 다른 점이 있다. key 인수가 함수로 주어질 때이다. 이 경우 key 인수로 주어진 콜백 함수는 필터 함수처럼 작용하는데, 이 말은 key를 인자로 받아서 true를 반환할 경우 해당 key에 관한 데이터를 refetch한다는 의미이다.</p>\n<p>이것은 data인수 없이 mutate를 호출하는 것과도 같은 동작인데, data 인수 없이 mutate를 호출하면 해당 key에 대한 데이터를 refetch한다. 정확히는 해당 key에 대한 데이터를 만료된 것으로 표시하여 refetch하도록 하는 것이다.</p>\n<pre><code class=\"language-tsx\">mutate('/api/user');\n</code></pre>\n<p>위와 같은 함수는 <code>/api/user</code>라는 키를 가진 데이터를 모두 만료 표시하고 refetch한다.</p>\n<p>앞서 말한 듯이 key를 filter 함수처럼 사용하는 예시는 다음과 같다.</p>\n<pre><code class=\"language-tsx\">mutate((key) => key.startsWith('/api/user'))\n\n// 혹은 data를 undefined로 전달하여 refetch\n\nmutate((key) => key.startsWith('/api/user'), undefined, { revalidate: true })\n</code></pre>\n<p>이러면 <code>/api/user</code>로 시작하는 모든 키에 대한 데이터를 만료 표시하고 refetch한다.</p>\n<p>필터 기능은 기존에 있는 모든 캐시된 key에 적용되므로 key 형태가 다양할 경우를 염두에 두고 작성해야 한다.</p>\n<p>그리고 이 기능을 사용할 시 모든 캐시 데이터를 지우는 함수도 쉽게 작성할 수 있다.</p>\n<pre><code class=\"language-tsx\">// 모든 key의 캐시 데이터를 지우고 캐시 유효성 검사도 다시 안 한다\nmutate(() => true, undefined, { revalidate: false })\n</code></pre>\n<h3>10.3.2. data</h3>\n<p>이 인수를 이용해서 클라이언트 캐시를 업데이트하거나 클라이언트에서 서버로 데이터를 보내서 서버의 데이터를 업데이트할 수 있다.</p>\n<p>서버에 데이터를 변경하는 작업을 시키기 위한 비동기 함수를 전달하는 것이다.</p>\n<h3>10.3.3. options</h3>\n<p>options 인수는 다음과 같은 옵션을 가진다.</p>\n<p>optimisticData, revalidate, populateCache, rollbackOnError, throwOnError</p>\n<p>revalidate는 비동기 업데이트를 완료한 후 캐시 유효성을 다시 검사할지를 결정한다. 기본은 true</p>\n<p>rollbackOnError는 mutate가 실패했을 때 캐시를 이전 상태로 되돌릴지를 결정한다. 기본은 true</p>\n<p>throwOnError는 mutate가 실패했을 때 에러를 throw할지를 결정한다. 기본은 true</p>\n<h3>10.3.4. mutate의 반환값</h3>\n<p>mutate 함수는 data 매개변수의 해결 결과를 반환한다. 해당 캐시값을 업데이트하는 데에 사용되는 업데이트된 데이터를 반환하는 것이다.</p>\n<p>에러도 try-catch로 적절히 처리 가능하다.</p>\n<pre><code class=\"language-tsx\">try {\n  // update는 비동기 함수\n  const data = await mutate('/api/user', update(newData))\n} catch (error) {\n  // ...\n}\n</code></pre>\n<h2>10.4. useSWRMutation</h2>\n<p>remote mutation을 위한 훅으로 useSWRMutation이 있다. 이는 자동으로 트리거되는 useSWR과 달리 수동으로만 트리거된다. 또한 다른 useSWRMutation과 상태를 공유하지 않는다.</p>\n<pre><code class=\"language-tsx\">const { data, error, trigger, reset, isMutating } = useSWRMutation(key, fetcher, options)\n</code></pre>\n<p>key와 fetcher, options를 제공하면 remote mutation을 제공하는 trigger 함수를 반환한다. 그리고 trigger가 호출되기 전까지 요청을 시작하지 않기 때문에, 필요할 때까지 데이터 로딩을 지연시킬 수 있다.</p>\n<h1>참고</h1>\n<p><a href=\"https://web.dev/stale-while-revalidate/\">https://web.dev/stale-while-revalidate/</a></p>\n<p>공식 문서 <a href=\"https://swr.vercel.app/ko\">https://swr.vercel.app/ko</a></p>\n<p><a href=\"https://fe-developers.kakaoent.com/2022/220224-data-fetching-libs/\">https://fe-developers.kakaoent.com/2022/220224-data-fetching-libs/</a></p>\n<p><a href=\"https://tech.madup.com/react-query-vs-swr/\">https://tech.madup.com/react-query-vs-swr/</a></p>\n<p>json-server <a href=\"https://poiemaweb.com/json-server\">https://poiemaweb.com/json-server</a></p>\n<p><a href=\"https://velog.io/@soryeongk/SWRBasic\">https://velog.io/@soryeongk/SWRBasic</a></p>\n<p><a href=\"https://youthfulhps.dev/web/stale-while-ravalidate/\">https://youthfulhps.dev/web/stale-while-ravalidate/</a></p>",
    "excerpt": "1. 배경설명\n프론트에서는 서버에 저장되어 있는 데이터를 다룰 때가 많다. 예를 들어서 사용자 프로필 정보를 받아와서 관리하는 등이다.\n이를 관리할 때 원래는 useEffect를 사용하여 페이지의 로드 시 서버에서 정보를 받아오고, 프론트단에 저장하는 게 보통이었다. 그리고 서버 정보 업데이트가 있을 시 프론트에서 계속 그 부분에 대한 처리를 해주어야 했다.\nReact 18부터는 Suspense가 나와서 페이지 로드 시 비동기 처리를 간편하게 해주기는 했지만 서",
    "headingTree": [
      {
        "title": "1. 배경설명",
        "url": "#1-배경설명",
        "items": [
          {
            "title": "1.1. stale-while-revalidate",
            "url": "#11-stale-while-revalidate",
            "items": []
          }
        ]
      },
      {
        "title": "2. vs React-query",
        "url": "#2-vs-react-query",
        "items": []
      },
      {
        "title": "3. 서버 모킹",
        "url": "#3-서버-모킹",
        "items": []
      },
      {
        "title": "4. 기초적인 SWR 사용",
        "url": "#4-기초적인-swr-사용",
        "items": []
      },
      {
        "title": "5. useSWR",
        "url": "#5-useswr",
        "items": [
          {
            "title": "5.1. 반환값",
            "url": "#51-반환값",
            "items": []
          },
          {
            "title": "5.2. 옵션 객체",
            "url": "#52-옵션-객체",
            "items": [
              {
                "title": "5.2.1. Suspense",
                "url": "#521-suspense",
                "items": []
              },
              {
                "title": "5.2.2. 자동 갱신 옵션",
                "url": "#522-자동-갱신-옵션",
                "items": []
              },
              {
                "title": "5.2.3. 에러 관련 옵션",
                "url": "#523-에러-관련-옵션",
                "items": []
              },
              {
                "title": "5.2.4. 갱신 간격 옵션",
                "url": "#524-갱신-간격-옵션",
                "items": []
              },
              {
                "title": "5.2.5. 이외의 콜백 함수",
                "url": "#525-이외의-콜백-함수",
                "items": []
              }
            ]
          }
        ]
      },
      {
        "title": "6. 전역 설정",
        "url": "#6-전역-설정",
        "items": []
      },
      {
        "title": "7. 에러 처리",
        "url": "#7-에러-처리",
        "items": []
      },
      {
        "title": "8. 조건부 fetch",
        "url": "#8-조건부-fetch",
        "items": []
      },
      {
        "title": "9. fetcher 함수 인자",
        "url": "#9-fetcher-함수-인자",
        "items": []
      },
      {
        "title": "10. mutation",
        "url": "#10-mutation",
        "items": [
          {
            "title": "10.1. 전역 mutate API",
            "url": "#101-전역-mutate-api",
            "items": []
          },
          {
            "title": "10.2. 특정 hook에 대한 mutate API",
            "url": "#102-특정-hook에-대한-mutate-api",
            "items": []
          },
          {
            "title": "10.3. mutate API 형식",
            "url": "#103-mutate-api-형식",
            "items": [
              {
                "title": "10.3.1. key 인수",
                "url": "#1031-key-인수",
                "items": []
              },
              {
                "title": "10.3.2. data",
                "url": "#1032-data",
                "items": []
              },
              {
                "title": "10.3.3. options",
                "url": "#1033-options",
                "items": []
              },
              {
                "title": "10.3.4. mutate의 반환값",
                "url": "#1034-mutate의-반환값",
                "items": []
              }
            ]
          },
          {
            "title": "10.4. useSWRMutation",
            "url": "#104-useswrmutation",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 3,
      "wordCount": 809
    },
    "url": "/posts/swr",
    "thumbnail": {
      "local": "/static/swr-001e65a2.svg",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-swr-001e65a2-svg",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAYAAACzzX7wAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAj0lEQVR4nAGEAHv/AAARDwMpJwAKbmIADtGlABDPnwsPx5IADcecAAv///8DAABLQKcARzqsCmdlo7u2sqm0tK+q2dncotbTzK3i4t6oAABYUP8AVU7/HnRs/rm1tv+7vLz/4uLi/tbW1//s7O3/AAA8M/sAMyj8C2Zg+sfCxPvExcT71tbW+dXV1fzf39/7kWhJbdnrD04AAAAASUVORK5CYII="
    }
  },
  {
    "slug": "stdin-is-not-a-tty",
    "title": "git 에러 - stdin is not a tty",
    "date": "2022-12-03T00:00:00Z",
    "description": "stdin is not a tty 해결하기",
    "tags": [
      "git"
    ],
    "html": "<h1>1. 문제의 발생</h1>\n<p>보통 자취방의 노트북에서 작업을 하다가 본가에 와서 잠깐 블로그에 글을 쓰게 되었다. 현재 내 블로그는 gatsby를 사용했고 <a href=\"https://xo.dev/\">이창희</a>님이 제작한 gatsby-starter-lavendar 테마를 사용하고 있다.</p>\n<p>그런데 글을 쓰고 git commit을 하려고 하니 다음과 같은 에러가 발생했다.</p>\n<p><img src=\"/static/bug-e864dbe5.png\" alt=\"bug\"></p>\n<h1>2. 에러 메시지 탐구</h1>\n<p>이게 무슨 소리지? 하나하나 해석해 보자. stdin은 당연히 표준 입출력일 것이다. tty는 알아보니 전신을 위한 장치를 뜻하는 Teletype 을 줄인 말이라고 하며 이게 이어져 현재 리눅스의 /dev 디렉토리에서 입출력에 관련된 파일들을 담는 폴더의 이름이 되었다고 한다.</p>\n<p>tty에 관한 더 자세한 설명은 밑의 참고 페이지에 있지만 지금 중요한 건 tty가 입출력을 담당한다는 것이다. 따라서 stdin의 상위 개념일 것이다. stdin is not a tty는 뭔가 꼬였다는 걸 알려준다. 하지만 에러 해결엔 별 도움이 되지 않는다..</p>\n<p>그러면 밑의 에러 메시지는? husky 또한 찾아보았다. git hook이라고 하여 git과 관련된 어떤 이벤트 발생 시 특정 스크립트를 실행할 수 있는 기능이 있다. 이 중 커밋, 머지, 푸시가 발생하기 전 클라이언트(즉 내 컴퓨터)에서 실행하는 클라이언트 훅을 공유하게 해 주는 npm 라이브러리가 husky이다.</p>\n<p>에러 메시지도 딱 그에 어울리는 내용이다. 커밋 전에 실행되는 git hook이 어떤 오류로 인해 종료되었다는 것이다.</p>\n<p>추측은 다음과 같다. husky의 pre-commit hook이 실행하는 쉘스크립트 파일에 echo를 이용하는 내용이 있었고 이는 tty를 이용한다. 그런데 내 노트북(맥os)에서 사용하는 tty와 본가의 윈도우 데스크탑에서 사용하는 tty가 달라서 일어나는 문제로 추측한다.</p>\n<p><code>tty</code> 명령어를 이용해서 각 컴퓨터에서 어떤 tty 폴더를 사용하나 봤더니 맥에서는 <code>dev/ttys001</code>이 뜨고 윈도우의 git bash에서는 <code>dev/pty0</code>이 떴다. 그 차이로 인해 husky의 pre-commit hook 실행에서 뭔가 에러가 발생한 게 아닐까 한다.</p>\n<h1>3. 해결</h1>\n<p>방법은 간단하다. 그냥 husky를 지우고 다시 깔면 된다. <code>.husky</code> 폴더를 지운 후 <code>yarn</code> 명령으로 husky를 재설치했다.</p>\n<p><img src=\"/static/yarn-ab0eb326.png\" alt=\"yarn\"></p>\n<p>husky의 pre-commit hook이 조금 변경되었다. 하지만 어차피 husky는 git에서 코드를 커밋하거나 푸시할 때마다 lint checking 등을 위해서 많이 사용된다. 나는 블로그에 새로운 글만 쓸 뿐 딱히 코드를 수정하지 않으므로 아무래도 좋다.</p>\n<p>게다가 블로그 코드를 고치게 된다면 아마 노트북으로 작업할 텐데 본가 데스크탑의 husky폴더는 <code>.gitignore</code>가 설정되어 있어서, 내 노트북에는 기존의 <code>.husky</code>폴더가 잘 남아 있다. 따라서 괜찮다...</p>\n<p>아무튼 이렇게 한 결과 git commit, push가 잘 이루어졌다.</p>\n<h1>참고</h1>\n<p>tty는 무엇인가? <a href=\"https://mug896.github.io/bash-shell/tty.html\">TTY | Introduction</a></p>\n<p>husky가 뭘까? <a href=\"https://library.gabia.com/contents/8492/\">husky 로 git hook 하자 | 가비아 라이브러리</a></p>",
    "excerpt": "1. 문제의 발생\n보통 자취방의 노트북에서 작업을 하다가 본가에 와서 잠깐 블로그에 글을 쓰게 되었다. 현재 내 블로그는 gatsby를 사용했고 이창희님이 제작한 gatsby-starter-lavendar 테마를 사용하고 있다.\n그런데 글을 쓰고 git commit을 하려고 하니 다음과 같은 에러가 발생했다.\n\n2. 에러 메시지 탐구\n이게 무슨 소리지? 하나하나 해석해 보자. stdin은 당연히 표준 입출력일 것이다. tty는 알아보니 전신을 위한 장치를 뜻하는",
    "headingTree": [
      {
        "title": "1. 문제의 발생",
        "url": "#1-문제의-발생",
        "items": []
      },
      {
        "title": "2. 에러 메시지 탐구",
        "url": "#2-에러-메시지-탐구",
        "items": []
      },
      {
        "title": "3. 해결",
        "url": "#3-해결",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 72
    },
    "url": "/posts/stdin-is-not-a-tty",
    "thumbnail": {
      "local": "/static/bug-e864dbe5.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-bug-e864dbe5-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAACCAIAAADq9gq6AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAO0lEQVR4nGO4/vX6+lPrF+1d5Gbprq2qFh7h4xHsLyQuzhAeEmZmYmZvay8rJysiIiIqKsbPz8/AwAAA35YNi83ytj4AAAAASUVORK5CYII="
    }
  },
  {
    "slug": "swr-practice",
    "title": "데이터 fetch library SWR 익히기 - 간단한 todoList 만들기",
    "date": "2023-03-21T00:00:00Z",
    "description": "SWR 라이브러리 학습기록 - 실제로 해보기",
    "tags": [
      "web",
      "study",
      "front"
    ],
    "html": "<p>앞선 글에서 SWR를 간단하게 배워보았다. 이어서 SWR을 간단하게나마 실제로 써보았다.</p>\n<h1>1. 사전 작업</h1>\n<p>아주 간단한 todoList를 만들 것이다. CRA typescript로 어플리케이션을 만들었다. 이전 글에서 모두 해놓은 작업이다.</p>\n<p>SWR 설치</p>\n<pre><code class=\"language-bash\">npm i swr\n</code></pre>\n<p>다른 폴더에 json-server 설치</p>\n<pre><code class=\"language-bash\">mkdir json-server-test &#x26;&#x26; cd json-server-test\nnpm init -y\nnpm install json-server\n</code></pre>\n<p>프로젝트 루트에 db.json 파일을 생성하자. 내용은 다음과 같이 간단한 todo리스트 파일을 작성하였다.</p>\n<pre><code class=\"language-json\">{\n  \"todos\": [\n    {\n      \"id\": 1,\n      \"content\": \"Learn React\",\n      \"done\": false\n    },\n    {\n      \"id\": 2,\n      \"content\": \"Learn Redux\",\n      \"done\": false\n    },\n    {\n      \"id\": 3,\n      \"content\": \"Learn React Native\",\n      \"done\": false\n    }\n  ]\n}\n</code></pre>\n<p>json-server를 설치한 폴더의 package.json의 스크립트에 다음과 같은 내용을 추가하자. json-server를 포트 5000으로 실행하도록 하는 것이다.</p>\n<pre><code class=\"language-json\">\"scripts\": {\n  \"start\": \"json-server --watch db.json --port 5000\",\n  \"test\": \"echo \\\"Error: no test specified\\\" &#x26;&#x26; exit 1\"\n},\n</code></pre>\n<p>그리고 axios를 설치한다. 서버에 요청을 보내기 위한 것이다.</p>\n<pre><code class=\"language-bash\">npm i axios\n</code></pre>\n<h1>2. TodoList 구성하기</h1>\n<p>이제 TodoList를 작성할 것이다. 먼저 CRA의 기본 파일들을 지우고 다음과 같은 내용에서 시작하자. App.tsx를 다음처럼 바꾸면 될 것이다.</p>\n<pre><code class=\"language-tsx\">function TodoListPage() {\n  return &#x3C;div>TodoList&#x3C;/div>;\n}\n\nexport default TodoListPage;\n</code></pre>\n<p>그럼 todoList엔 뭐가 필요할까? 아무래도 기본적인 CRUD면 충분할 것 같다.</p>\n<h2>2.1. 기초 컴포넌트 구현하기</h2>\n<p>TodoListPage 컴포넌트를 최상단으로 하고, todo 항목들은 이 컴포넌트에서 관리하도록 하자. 그리고 이를 편집하는 기능들은 따로 각각의 item들로 내려보내는 형식으로 컴포넌트를 구성한다.</p>\n<p>먼저 TodoListPage 컴포넌트를 다음과 같이 구성하자.</p>\n<pre><code class=\"language-tsx\">function TodoListPage() {\n  const [todos, setTodos] = useState&#x3C;Todo[]>([\n    {\n      id: 1,\n      content: \"Learn React\",\n      done: false,\n    },\n    {\n      id: 2,\n      content: \"Learn Redux\",\n      done: false,\n    },\n    {\n      id: 3,\n      content: \"Learn React Native\",\n      done: false,\n    },\n  ]);\n\n  return (\n    &#x3C;main>\n      &#x3C;h1>Todo List&#x3C;/h1>\n      &#x3C;TodoList todos={todos} setTodos={setTodos} />\n      &#x3C;TodoListForm addTodo={(todo) => setTodos([...todos, todo])} />\n    &#x3C;/main>\n  );\n}\n</code></pre>\n<p>그리고 todo 항목들을 보여주는 TodoList 컴포넌트를 다음과 같이 구현한다. 간단한 unordered list로 구성하였다.</p>\n<pre><code class=\"language-tsx\">function TodoList({\n  todos,\n  setTodos,\n}: {\n  todos: Todo[];\n  setTodos: (todos: Todo[]) => void;\n}) {\n  return (\n    &#x3C;ul>\n      {todos.map((todo) => (\n        &#x3C;TodoListItem\n          key={todo.id}\n          todo={todo}\n          setTodo={(newTodo) => {\n            setTodos(todos.map((td) => (td.id === newTodo.id ? newTodo : td)));\n          }}\n        />\n      ))}\n    &#x3C;/ul>\n  );\n}\n</code></pre>\n<p>이제 각각의 TodoListItem 컴포넌트를 구성한다. 이 컴포넌트는 todo 항목을 보여주고, done을 편집할 수 있도록 한다. list item 태그로 구성하였다.</p>\n<pre><code class=\"language-tsx\">function TodoListItem({\n  todo,\n  setTodo,\n}: {\n  todo: Todo;\n  setTodo: (todo: Todo) => void;\n}) {\n  return (\n    &#x3C;li>\n      &#x3C;input\n        type=\"checkbox\"\n        checked={todo.done}\n        onChange={() => {\n          setTodo({\n            ...todo,\n            done: !todo.done,\n          });\n        }}\n      />\n      {todo.content}\n    &#x3C;/li>\n  );\n}\n</code></pre>\n<p>그리고 TodoListForm 컴포넌트를 구성한다. 이 컴포넌트는 todo 항목을 추가할 수 있도록 한다. form 태그로 구성하였다.</p>\n<pre><code class=\"language-tsx\">function TodoListForm({ addTodo }: { addTodo: (todo: Todo) => void }) {\n  const [newTodo, setNewTodo] = useState&#x3C;Todo>({\n    id: 4,\n    content: \"\",\n    done: false,\n  });\n\n  const handleSubmit = (e: React.FormEvent&#x3C;HTMLFormElement>) => {\n    e.preventDefault();\n    addTodo(newTodo);\n    setNewTodo({\n      id: newTodo.id + 1,\n      content: \"\",\n      done: false,\n    });\n  };\n\n  return (\n    &#x3C;form onSubmit={handleSubmit}>\n      &#x3C;input\n        type=\"text\"\n        value={newTodo.content}\n        onChange={(e) => {\n          setNewTodo({ ...newTodo, content: e.target.value });\n        }}\n      />\n      &#x3C;button type=\"submit\">Add&#x3C;/button>\n    &#x3C;/form>\n  );\n}\n</code></pre>\n<p>편집 중인 내역은 이 컴포넌트에서만 가지고 있으면 된다고 생각하여, 새로 추가할 요소의 내용을 담은 newTodo는 이 컴포넌트에서만 가지고 있도록 하였다. 그리고 이를 추가하는 addTodo 함수를 props로 내려받아서 사용하였다.</p>\n<p>이제 create, read 기능을 구현하였다. 이렇게 하고 나면 다음과 같이 별로 예쁘진 않지만 todoList스러운 무언가가 완성되었다.</p>\n<p><img src=\"/static/todolist-CR-50496809.png\" alt=\"cr\"></p>\n<p>이제 update, delete 기능을 구현해보자.</p>\n<h2>2.2. update, delete 기능 구현하기</h2>\n<p>delete 기능은 TodoListItem 컴포넌트 단위에서 구현할 수 있다. 이때 TodoListItem이 받는 props를 먼저 바꾸자. 현재는 setTodo라는 이름으로 되어 있는데 이를 updateTodo로 바꾸고 deleteTodo props를 추가하자.</p>\n<pre><code class=\"language-tsx\">function TodoListItem({\n  todo,\n  updateTodo,\n  deleteTodo,\n}: {\n  todo: Todo;\n  updateTodo: (todo: Todo) => void;\n  deleteTodo: (todo: Todo) => void;\n}) {\n  return (\n    &#x3C;li>\n      &#x3C;input\n        type=\"checkbox\"\n        checked={todo.done}\n        onChange={() => {\n          updateTodo({\n            ...todo,\n            done: !todo.done,\n          });\n        }}\n      />\n      {todo.content}\n      &#x3C;button onClick={() => deleteTodo(todo)}>Delete&#x3C;/button>\n    &#x3C;/li>\n  );\n}\n</code></pre>\n<p>그리고 TodoList 컴포넌트에서는 deleteTodo를 적절히 만들어서 넘겨주도록 하자.</p>\n<pre><code class=\"language-tsx\">function TodoList({\n  todos,\n  setTodos,\n}: {\n  todos: Todo[];\n  setTodos: (todos: Todo[]) => void;\n}) {\n  return (\n    &#x3C;ul>\n      {todos.map((todo) => (\n        &#x3C;TodoListItem\n          key={todo.id}\n          todo={todo}\n          updateTodo={(newTodo) => {\n            setTodos(todos.map((td) => (td.id === newTodo.id ? newTodo : td)));\n          }}\n          deleteTodo={(todo) => {\n            setTodos(todos.filter((td) => td.id !== todo.id));\n          }}\n        />\n      ))}\n    &#x3C;/ul>\n  );\n}\n</code></pre>\n<p>이제 delete 기능을 구현하였다. 이렇게 하고 나면 다음과 같이 delete 버튼이 생겼다. 또한 잘 작동하는 것을 확인할 수 있다.</p>\n<p><img src=\"/static/todolist-delete-e9cf5356.png\" alt=\"todoList-delete\"></p>\n<p>이제 update 기능은 쉽다. TodoListItem 컴포넌트가 이미 todo를 업데이트하는 함수를 가지고 있기 때문에 이 컴포넌트만 편집해 주면 된다. 수정 상태인지를 알려주는 state를 추가한 후 이를 이용하여 input 태그를 보여주거나, span 태그를 보여주도록 하자.</p>\n<pre><code class=\"language-tsx\">function TodoListItem({\n  todo,\n  updateTodo,\n  deleteTodo,\n}: {\n  todo: Todo;\n  updateTodo: (todo: Todo) => void;\n  deleteTodo: (todo: Todo) => void;\n}) {\n  const [isEditing, setIsEditing] = useState(false);\n\n  return (\n    &#x3C;li>\n      &#x3C;input\n        type=\"checkbox\"\n        checked={todo.done}\n        onChange={() => {\n          updateTodo({\n            ...todo,\n            done: !todo.done,\n          });\n        }}\n      />\n      {isEditing ? (\n        &#x3C;input\n          type=\"text\"\n          value={todo.content}\n          onChange={(e) => {\n            updateTodo({\n              ...todo,\n              content: e.target.value,\n            });\n          }}\n        />\n      ) : (\n        &#x3C;span>{todo.content}&#x3C;/span>\n      )}\n      &#x3C;button onClick={() => setIsEditing((prev) => !prev)}>\n        {isEditing ? \"Done\" : \"Edit\"}\n      &#x3C;/button>\n      &#x3C;button onClick={() => deleteTodo(todo)}>Delete&#x3C;/button>\n    &#x3C;/li>\n  );\n}\n</code></pre>\n<p>이 코드에는 현재 문제가 있기는 하다. 보통 TodoList에서 항목 수정이 완료되는 시점은 수정 완료(여기서는 Done)버튼을 누르는 시점이어야 한다. 하지만 여기서는 수정 버튼을 누른 후 수정하는 그대로 todo항목의 내용이 바뀌어 버린다. 하지만 여기서는 수정하다가 이를 물릴 수 있는 방법이 없으므로 그냥 넘어가고, 이따 서버와 통신할 때 이를 따지기로 한다.</p>\n<h1>3. SWR과 사용하기</h1>\n<p>이제 서버와 통신을 해보자. 서버와 통신을 하기 위해서는 앞서 설치한 axios를 사용할 것이다.</p>\n<p>json-server의 데이터는 앞에서 구축했다. npm start로 서버를 실행하면 <a href=\"http://localhost:5000/todos\">http://localhost:5000/todos</a> 에 서버가 실행된다. 이제 이 서버와 통신을 해보자.</p>\n<h2>3.1. 서버에서 데이터 받아오기</h2>\n<p>간단하다. axios로 fetcher를 만들고 useSWR 훅을 사용하면 된다.</p>\n<p>axios로 정의한 fetcher 함수</p>\n<pre><code class=\"language-tsx\">const fetcher = (url: string) => axios.get(url).then((res) => res.data);\n</code></pre>\n<p>useSWR 훅을 사용해서 서버에서 데이터를 받아오는 시험을 하는 TodoListPage 코드</p>\n<pre><code class=\"language-tsx\">function TodoListPage() {\n  const [todos, setTodos] = useState&#x3C;Todo[]>([\n    {\n      id: 1,\n      content: \"Learn React\",\n      done: false,\n    },\n    {\n      id: 2,\n      content: \"Learn Redux\",\n      done: false,\n    },\n    {\n      id: 3,\n      content: \"Learn React Native\",\n      done: false,\n    },\n  ]);\n\n  const { data } = useSWR(\"http://localhost:5000/todos\", fetcher);\n\n  useEffect(() => {\n    console.log(data);\n  }, [data]);\n\n  return (\n    &#x3C;main>\n      &#x3C;h1>Todo List&#x3C;/h1>\n      &#x3C;TodoList todos={todos} setTodos={setTodos} />\n      &#x3C;TodoListForm addTodo={(todo) => setTodos([...todos, todo])} />\n    &#x3C;/main>\n  );\n}\n</code></pre>\n<p>이렇게 하면 처음에는 undefined이던 data가 서버에서 받아온 데이터로 바뀌는 것을 콘솔 출력으로 확인할 수 있다.</p>\n<h2>3.2. 서버 데이터로 TodoList 보여주기</h2>\n<p>먼저 Todo를 좀 수정하자. json-server에서 auto increment id를 처리해 주기는 쉽지 않고 여기서는 그것을 다루는 게 목적이 아니기 때문에 todo 항목 생성 시 id를 랜덤으로 생성해 주도록 하자.</p>\n<p>먼저 Todo 타입을 수정하고, Todo의 추가 시점에 id를 생성해서 넣어주도록 하자.</p>\n<pre><code class=\"language-tsx\">interface Todo {\n  id: string;\n  content: string;\n  done: boolean;\n}\n</code></pre>\n<p>그리고 랜덤 id 생성을 위한 uuid 라이브러리 설치</p>\n<pre><code class=\"language-bash\">npm i uuid\n</code></pre>\n<p>id를 랜덤으로 생성해 주게 되면 새로운 todo 항목을 추가할 때 필요한 건 content 뿐이다. TodoListForm 컴포넌트를 수정하자.</p>\n<p>그리고 원래는 todo 항목의 편집 함수들을 최상위의 TodoListPage 컴포넌트에서 관리하였는데 지금은 서버에 요청을 보내 편집하면 되기 때문에 굳이 props drilling을 할 필요 없다. 따라서 서버 데이터를 받아오는 건 TodoListPage 컴포넌트에서 관리하되 편집 함수들은 각각의 담당 컴포넌트에서 하도록 하자.</p>\n<p>따라서 TodoListPage 컴포넌트는 다음과 같이 간소해진다.</p>\n<pre><code class=\"language-tsx\">function TodoListPage() {\n  const { data, error, isLoading } = useSWR(\n    \"http://localhost:5000/todos\",\n    fetcher\n  );\n\n  if (isLoading) {\n    return &#x3C;div>Loading...&#x3C;/div>;\n  }\n  if (error) {\n    return &#x3C;div>Error&#x3C;/div>;\n  }\n\n  return (\n    &#x3C;main>\n      &#x3C;h1>Todo List&#x3C;/h1>\n      &#x3C;TodoList todos={data} />\n      &#x3C;TodoListForm />\n    &#x3C;/main>\n  );\n}\n</code></pre>\n<p>그리고 Todo 항목을 추가하는 TodoListForm 컴포넌트를 다음과 같이 수정한다. 서버에 직접 요청을 보낼 수 있으므로 addTodo 함수를 props로 받을 필요가 없다. 대신 handleSubmit 함수를 만들어서 서버에 요청을 보낸 후 mutate를 통해 데이터를 갱신해 주도록 한다.</p>\n<pre><code class=\"language-tsx\">function TodoListForm() {\n  const [newTodo, setNewTodo] = useState&#x3C;string>(\"\");\n\n  const handleSubmit = (e: React.FormEvent&#x3C;HTMLFormElement>) => {\n    e.preventDefault();\n    axios\n      .post(\"http://localhost:5000/todos\", {\n        id: uuidv4(),\n        content: newTodo,\n        done: false,\n      })\n      .then(() => {\n        setNewTodo(\"\");\n        mutate(\"http://localhost:5000/todos\");\n      });\n  };\n\n  return (\n    &#x3C;form onSubmit={handleSubmit}>\n      &#x3C;input\n        type=\"text\"\n        value={newTodo}\n        onChange={(e) => {\n          setNewTodo(e.target.value);\n        }}\n      />\n      &#x3C;button type=\"submit\">Add&#x3C;/button>\n    &#x3C;/form>\n  );\n}\n</code></pre>\n<p>그리고 TodoList 함수는 그저 todos를 받아서 TodoItem 컴포넌트를 렌더링해 주는 역할만 하도록 수정한다. setTodos가 props에서 사라진 것을 알 수 있다.</p>\n<pre><code class=\"language-tsx\">function TodoList({ todos }: { todos: Todo[] }) {\n  return (\n    &#x3C;ul>\n      {todos.map((todo) => (\n        &#x3C;TodoListItem key={todo.id} todo={todo} />\n      ))}\n    &#x3C;/ul>\n  );\n}\n</code></pre>\n<p>가장 많이 수정된 TodoListItem 컴포넌트는 다음과 같다. 이 컴포넌트에서는 todo가 수정되거나 삭제됨에 따라 서버에 요청을 보내고 mutate를 통해 데이터를 갱신해 주도록 하였다.</p>\n<pre><code class=\"language-tsx\">function TodoListItem({ todo }: { todo: Todo }) {\n  const [isEditing, setIsEditing] = useState&#x3C;boolean>(false);\n  const [editTodoContent, setEditTodoContent] = useState&#x3C;string>(\"\");\n\n  const completeTodo = () => {\n    axios\n      .patch(`http://localhost:5000/todos/${todo.id}`, {\n        done: !todo.done,\n      })\n      .then(() => {\n        mutate(\"http://localhost:5000/todos\");\n      });\n  };\n\n  const editTodo = () => {\n    setIsEditing(true);\n    setEditTodoContent(todo.content);\n  };\n\n  const saveTodo = () => {\n    axios\n      .patch(`http://localhost:5000/todos/${todo.id}`, {\n        content: editTodoContent,\n      })\n      .then(() => {\n        setIsEditing(false);\n        setEditTodoContent(\"\");\n        mutate(\"http://localhost:5000/todos\");\n      });\n  };\n\n  const deleteTodo = () => {\n    axios.delete(`http://localhost:5000/todos/${todo.id}`).then(() => {\n      mutate(\"http://localhost:5000/todos\");\n    });\n  };\n\n  return (\n    &#x3C;li>\n      &#x3C;input type=\"checkbox\" checked={todo.done} onChange={completeTodo} />\n      {isEditing ? (\n        &#x3C;input\n          type=\"text\"\n          value={editTodoContent}\n          onChange={(e) => {\n            setEditTodoContent(e.target.value);\n          }}\n        />\n      ) : (\n        &#x3C;span>{todo.content}&#x3C;/span>\n      )}\n      &#x3C;button onClick={isEditing ? saveTodo : editTodo}>\n        {isEditing ? \"Done\" : \"Edit\"}\n      &#x3C;/button>\n      &#x3C;button onClick={deleteTodo}>Delete&#x3C;/button>\n    &#x3C;/li>\n  );\n}\n</code></pre>\n<p>이제 json-server를 실행하고 todoList를 업데이트해 보면 todoList의 모든 기능이 잘 작동하는 것을 확인할 수 있다. 그리고 새로고침을 해도 데이터가 유지되며 편집한 내용이 json-server에 저장되는 것을 확인할 수 있다.</p>\n<h1>참고</h1>\n<p><a href=\"https://maliethy.github.io/posts/swr/\">https://maliethy.github.io/posts/swr/</a></p>\n<p><a href=\"https://velog.io/@soryeongk/SWRBasic\">https://velog.io/@soryeongk/SWRBasic</a></p>\n<p>json server 사용하기 <a href=\"https://redux-advanced.vlpt.us/3/01.html\">https://redux-advanced.vlpt.us/3/01.html</a></p>",
    "excerpt": "앞선 글에서 SWR를 간단하게 배워보았다. 이어서 SWR을 간단하게나마 실제로 써보았다.\n1. 사전 작업\n아주 간단한 todoList를 만들 것이다. CRA typescript로 어플리케이션을 만들었다. 이전 글에서 모두 해놓은 작업이다.\nSWR 설치\nnpm i swr\n\n다른 폴더에 json-server 설치\nmkdir json-server-test && cd json-server-test\nnpm init -y\nnpm install json-server\n\n프로젝",
    "headingTree": [
      {
        "title": "1. 사전 작업",
        "url": "#1-사전-작업",
        "items": []
      },
      {
        "title": "2. TodoList 구성하기",
        "url": "#2-todolist-구성하기",
        "items": [
          {
            "title": "2.1. 기초 컴포넌트 구현하기",
            "url": "#21-기초-컴포넌트-구현하기",
            "items": []
          },
          {
            "title": "2.2. update, delete 기능 구현하기",
            "url": "#22-update-delete-기능-구현하기",
            "items": []
          }
        ]
      },
      {
        "title": "3. SWR과 사용하기",
        "url": "#3-swr과-사용하기",
        "items": [
          {
            "title": "3.1. 서버에서 데이터 받아오기",
            "url": "#31-서버에서-데이터-받아오기",
            "items": []
          },
          {
            "title": "3.2. 서버 데이터로 TodoList 보여주기",
            "url": "#32-서버-데이터로-todolist-보여주기",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 3,
      "wordCount": 827
    },
    "url": "/posts/swr-practice",
    "thumbnail": {
      "local": "/static/todolist-CR-50496809.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-todolist-CR-50496809-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAARklEQVR4nGOQlpYSFhJas2bN////f/z48R8GGOrbJgiJiEVGRr569QouCpI4ffbC6bNnJ02adPXqVRQJCIVsCIoEJsApAQBFf3+PeCgjdwAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "tailwind-2",
    "title": "프론트 지식 익히기 tailwind - 2",
    "date": "2022-07-28T00:00:00Z",
    "description": "프로젝트 tailwind 사용기 - 태그 정리",
    "tags": [
      "web",
      "study",
      "front"
    ],
    "html": "<h1>1. 두번째 글의 목적</h1>\n<p>첫번째 글에서는 tailwind 개론과 제공하는 몇 가지 기능들을 다루었다. 이 글에서는 tailwind를 본격적으로 시작하기 전에 어떤 클래스들이 존재하는지 간단히 정리해 두는 글이다. 물론 그때그때 부딪쳐 가면서 배울 수도 있겠지만 먼저 한번 정리해 두는 것이 더 효율적이라고 느낀다. 대충 뭐가 있는지 알아야 부딪치든 말든 하니까.</p>\n<h1>2. 기본 스타일</h1>\n<p>tailwind에서는 브라우저별로 다른 기본 CSS 설정 등을 싹 밀어 주고 어느 정도 통일된 기반에서 시작하게 해주는 preflight를 자동으로 제공한다. index.css에 들어 있는 <code>@tailwind base;</code>에서 알아서 주입해 준다. 뭐가 있는지는 공식 문서의 스타일시트를 참고하면 된다. 최대한 직관적으로 짜였다는 것 정도만 알고 넘어갔다.</p>\n<p>만약 다른 Base style이 있는 프로젝트와 합병 등의 이유로 preflight를 아예 사용하지 않고 싶다면 역시 tailwind.config.js에서 설정 가능하다. corePlugins 항목에서 <code>preflight:false;</code>로 바꾸면 된다.</p>\n<h1>3. Layout 관련 스타일</h1>\n<p>필요해 보이는 것만 몇 개 정리한다.</p>\n<ul>\n<li>\n<p>Aspect ratio : 컴포넌트의 가로세로비 조절\naspect-auto, aspect-square(가로세로 비율 1:1), aspect-video(16:9)</p>\n</li>\n<li>\n<p>Columns : 요소 내부의 열 개수를 조절\ncolumns-{n}, columns-{size}\n요소 안의 열 개수를 지정하거나 특정 너비마다 열이 새로 생기게 할 수 있다.</p>\n</li>\n<li>\n<p>Box Sizing : 각 요소의 크기를 padding, margin 포함해서 측정하게 할 것인지를 결정\nbox-border : 요소의 크기에 padding, margin이 포함된다.\nbox-content : 요소의 크기에 요소 내부의 내용만 포함된다.</p>\n</li>\n<li>\n<p>Display : 요소의 디스플레이 타입을 결정한다.\nblock, inline-block, inline, flex, inline-flex, table, inline-table, table-caption등이 있다.\nblock, inline-block, inline, flex, grid, hidden 정도만 알고 넘어가자.</p>\n</li>\n<li>\n<p>Float : 한 요소가 흐름으로부터 빠져서 텍스트나 인라인 요소들이 그 주위를 감싸게 할 때 그 요소의 위치를 지정한다. 가령 이미지와 텍스트가 어우러질 때 이미지가 어느 곳에 정렬될 것인지를 결정.\nfloat-right, float-left, float-none(요소와 인라인 요소가 섞이지 않는다)</p>\n</li>\n<li>\n<p>Object Fit\n한 요소가 다른 요소 안에 포함되어 있을 때(박스 안의 이미지처럼)포함된 요소가 어떻게 크기가 조절될지를 결정한다.\nobject-contain, object-cover, object-fill, object-none, object-scale-down\n이것들은 모두 object-fit css의 하나를 지정한 것과 같다.</p>\n</li>\n<li>\n<p>Object Position\n내부 요소가 컨테이너에 어느 위치에 있는지를 결정한다.\nobject-bottom, object-left, object-left-top, object-center 등 9개의 위치 중 하나를 지정할 수 있다.</p>\n</li>\n<li>\n<p>Overflow\n내부 요소가 컨테이너에서 넘칠 때 어떻게 처리할지를 결정한다.\noverflow-{auto, hidden, clip, visible, scroll, x-auto, y-auto, x-hidden, y-hidden, x-clip, y-clip, x-visible, y-visible, x-scroll, y-scroll}</p>\n</li>\n<li>\n<p>Overscroll Behavior\n페이지에서 스크롤했을 때 스크롤 가능한 영역이 2개 이상일 때 한쪽의 스크롤이 끝난 상태에서 스크롤을 더 하면 더 큰 쪽의 스크롤도 내려가는 스크롤 체이닝 현상이 발생한다. 이를 조정하는 클래스이다. overscroll-contain 을 주면 이런 스크롤 체이닝을 막을 수 있다.(기본은 overscroll-auto)</p>\n</li>\n<li>\n<p>Position\n요소가 DOM에서 어떻게 배치되는지를 나타내는 유틸리티. static, fixed, absolute, relative, sticky가 있다. position css와 같다. <a href=\"https://developer.mozilla.org/ko/docs/Web/CSS/position\">https://developer.mozilla.org/ko/docs/Web/CSS/position</a> top-{n}, bottom-{n} 등으로 해당 위치 지정 방법에 따라 위치를 지정할 수도 있다.</p>\n</li>\n<li>\n<p>Visibility\n요소가 보이는지 안 보이는지를 조정한다. visible, invisible 2가지뿐이다.</p>\n</li>\n<li>\n<p>z-index\n말 그대로 요소의 z-index를 조정한다. 요소가 얼만큼 우선적으로 보일지 결정한다. z-0, z-10...z-50까지 있다. z-auto도 있다. z-뒤 숫자가 높을수록 더 우선적으로 보인다.</p>\n</li>\n</ul>\n<h1>4. Display(Layout) 관련 스타일</h1>\n<ul>\n<li>\n<p>Flex Direction\nflex-direction을 지정하는 것. flex-row, flex-col, flex-row-reverse, flex-col-reverse가 있다.</p>\n</li>\n<li>\n<p>Flex Wrap\nflex 컨테이너 내의 요소들이 컨테이너 영역을 벗어나더라도 강제로 한 줄에 배치되게 할 것인지 wrap(줄바꿈되더라도 컨테이너 내부에 위치)하게 할 것인지를 결정한다.\nflex-wrap, flex-nowrap, flex-wrap-reverse가 있다.</p>\n</li>\n<li>\n<p>Flex\nflex 컨테이너 내의 요소들이 grow/shrink하는 것을 결정. flex-grow(grow, grow-0으로 설정 가능), flex-shrink(shrink, shrink-0으로 설정 가능), flex-basis(basis-{n}으로 설정가능)의 shortcut이다.\nflex-initial : <code>flex:0 1 auto</code>와 같음. 요소가 내용 크기에 맞춰 줄어들긴 하지만 늘어나진 않고 initial size 유지\nflex-1 : <code>flex: 1 1 0%;</code>와 같음. 요소가 초기 사이즈를 무시하고 필요한 만큼 늘어나거나 줄어든다.\nflex-auto : <code>flex: 1 1 auto;</code>와 같음. 요소가 초기 사이즈를 어느 정도 고려해서 늘어나거나 줄어든다.\nflex-none : 요소가 늘어나거나 줄어들지 않는다.</p>\n</li>\n<li>\n<p>Grid Template Columns\ngrid display에서 열 개수를 결정한다.\ngrid-cols-{n} 이 <code>grid-template-columns: repeat(n, minmax(0, 1fr));</code>과 같다.</p>\n</li>\n<li>\n<p>Grid Column Start / End\ngrid display에서 요소가 몇 개의 열을 차지할지, 혹은 어떤 열에서 시작해서 어떤 열까지 차지할지를 결정한다.\ncol-span-n : 이 요소는 열 n개를 차지(span)한다.\ncol-start-n : 이 요소는 열 n에서 시작한다. (왼쪽 맨 끝이 1, 한 열이 더해질 때마다 1씩 늘어난다)\ncol-end-n : 이 요소는 열 n에서 끝난다.</p>\n</li>\n<li>\n<p>Grid Template Rows, Grid Row Start / End\ngrid display에서 요소의 행 개수를 결정하고 요소가 몇 개의 행을 차지하거나 몇 행에서 시작해서 몇 행에서 끝날지를 결정한다.\ncolumn의 경우와 비슷하게 grid-rows-n, row-span-n, row-start-n, row-end-n 을 쓴다.</p>\n</li>\n<li>\n<p>Grid Auto Flow\n아이템이 자동 배치되는 흐름을 결정한다. row의 경우 아이템으로 한 행을 채운 후 다음 행으로 넘어가는 식이다. grid-flow-row, grid-flow-col, grid-flow-dense, grid-flow-row-dense, grid-flow-col-dense</p>\n</li>\n<li>\n<p>Grid Auto Columns / Rows\ngrid-template의 통제를 벗어난 그리드 트랙의 크기를 지정한다. 만약 row나 column의 개수를 알 수 없는 경우 사용한다.\nauto-cols-{auto, min, max, fr}\nauto-rows-{auto, min, max, fr}</p>\n</li>\n<li>\n<p>Gap\n그리드 행, 열 혹은 flexbox item들 간의 간격을 설정한다. gap-n으로 설정할 수 있고 혹은 gap-x-n, gap-y-n으로 x,y축 방향으로도 설정할 수 있다.</p>\n</li>\n<li>\n<p>Justify Content\n컨테이너의 메인 축을 따라서 아이템들이 배열되는데 이때 가로 방향으로 어떻게 위치하는지를 결정한다. 예를 들어 justify-start 는 아이템이 컨테이너의 시작부터 메인 축을 따라 채워지게 한다. display grid의 경우, grid 아이템들의 너비를 모두 합한 값이 grid 컨테이너의 너비보다 작을 때 아이템들을 통째로 정렬하게 된다.\njustify-{start, end, center, between, around, evenly}</p>\n</li>\n<li>\n<p>Justify Items\ngrid 요소들이 컨테이너 내부에서 어떻게 배열되는지를 결정하는 컨테이너 속성이다. 즉 inline axis상에서의 위치를 결정한다. 아이템의 가로 방향 정렬이라고 생각하면 된다.\njustify-items-{start, end, center, stretch}</p>\n</li>\n<li>\n<p>Justify Self\n컨테이너가 아닌, 배치할 요소 스스로에 쓰인다. 해당 아이템을 가로로 정렬하는 데에 쓰인다.\njustify-self-{auto, start, end, center, stretch}</p>\n</li>\n<li>\n<p>Align Content\n컨테이너의 메인 축을 따라서 아이템들이 배열되는데 이때 세로 방향으로 어떻게 위치하는지를 결정한다. display grid의 경우, grid 아이템들의 높이를 모두 합한 값이 grid 컨테이너의 높이보다 작을 때 아이템들을 통째로 세로 정렬하게 된다.\ncontent-{center, start, end, between, around, evenly}</p>\n</li>\n<li>\n<p>Align Items\ninline axis에 교차되는 축 방향으로 아이템이 어떻게 배열되는지를 결정한다. grid에서는 아이템의 세로 방향 정렬이라고 생각하면 된다.\nitems-{start, end, center, baseline, stretch}</p>\n</li>\n<li>\n<p>Align Self\n컨테이너가 아닌, 배치할 요소 스스로에 쓰인다. 해당 아이템을 세로로 정렬하는 데에 쓰인다.\nself-{auto, start, end, center, stretch, baseline}</p>\n</li>\n<li>\n<p>Place Content\njustify, align content가 같은 정렬로 이루어질 때 shortcut으로 사용한다.\nplace-content-{center, start, end, between, around, evenly, stretch}</p>\n</li>\n<li>\n<p>Place Items\njustify, align items가 같은 방식 정렬로 이루어질 때 shortcut으로 사용한다.\nplace-items-{start, end, center, stretch}</p>\n</li>\n<li>\n<p>Place Self\n하나의 요소에 justify-self와 align-self가 같은 방식 정렬로 이루어질 때 사용된다.\nplace-self-{auto, start, end, center, stretch}</p>\n</li>\n</ul>\n<h1>5. Spacing styles</h1>\n<ul>\n<li>\n<p>Padding\n요소의 padding을 결정한다. 이때 padding, margin의 차이는 border의 바깥쪽의 여백인지의 차이이다. margin은 테두리 바깥의 여백이고 padding은 그 안쪽에, 요소의 자식 요소들을 배치할 때 테두리와 내부 요소간의 여백이다.\np-n(n은 1당 0.25rem, 즉 4px이다)이 있고 가로 여백과 세로 여백을 뜻하는 px-n, py-n이 있다. padding-top, bottom, left, right를 나타내는 pt, pb, pl, pr이 있다.</p>\n</li>\n<li>\n<p>Margin\n요소의 margin을 결정한다. 이 역시 m-n으로 결정되는데 n은 1당 0.25rem=4px이다. 예를 들어 m-1은 4px margin이다. padding과 마찬가지로 가로, 세로 마진을 주는 mx, my와 상하좌우 마진을 뜻하는 mt, mb, ml, mr이 있다.</p>\n</li>\n<li>\n<p>Space Between\n자식 요소간의 간격을 설정한다. space-x-n은 margin-left를 부여해서 간격을 주고 space-y-n은 margin-top으로 간격을 준다. 이것 역시 n 1당 0.25rem=4px 간격이다.</p>\n</li>\n</ul>\n<h1>6. Sizing style</h1>\n<ul>\n<li>\n<p>Width\n요소의 너비를 설정한다. w-n. n당 0.25rem=4px. 숫자별 크기는 이 페이지를 참고하자. <a href=\"https://tailwindcss.com/docs/width\">https://tailwindcss.com/docs/width</a> w-3/5 등 화면 크기의 일정 비율을 차지하는 너비도 가능하다. 100%는 w-full.</p>\n</li>\n<li>\n<p>Min-Width\n요소의 최소 너비를 설정한다.\nmin-w-0, min-w-full이 있고 min-content와 max-content의 크기에 따라서 최소 너비를 정하는 min-w-min, min-w-max가 있다. min-w-fit도 있다.</p>\n</li>\n<li>\n<p>Max-Width\n요소의 최대 너비를 설정한다. max-w-* 로 설정하는데 너무 많기 때문에 구체적인 수치는 공식 문서를 참고하면서 필요할 때마다 찾아 쓸 예정이다.</p>\n</li>\n<li>\n<p>Height\n요소의 높이를 결정한다. h-*으로 정의하며 width의 경우와 비슷하게 1당 0.25rem=4px이고 fraction height(h-3/5와 같은)도 지원한다.</p>\n</li>\n<li>\n<p>Min-Height, Max-Height\nMin/Max-Width와 비슷하다.</p>\n</li>\n</ul>\n<h1>7. Typography</h1>\n<ul>\n<li>\n<p>Font Family\n글씨체를 결정한다. sans style, serif style, mono style 글씨체들을 각각 모아서 정의하고 있다. 요소의 폰트를 적당히 브라우저가 지원하는 그 스타일의 글씨체로 만들어 준다.\nfont-sans, font-serif, font-mono</p>\n</li>\n<li>\n<p>Font Size\n당연히 폰트 크기를 결정한다. 이때 이 속성을 설정하면 한 줄의 높이를 설정하는 속성인 <code>line-height</code>도 적절하게 같이 설정된다.\ntext-{xs, sm, base, lg, xl, 2xl, ..., 9xl}\n각 속성의 크기는 공식 문서를 참고하자.</p>\n</li>\n<li>\n<p>Font Smoothing\n폰트를 더 부드럽게 표현해 주는 속성이라고 한다. 단 비표준이라고 하고 당장 필요한 기능도 아닌 것 같아서 넘어간다.</p>\n</li>\n<li>\n<p>Font style\nitalic 과 not-italic 을 지원한다. 더 설명이 필요한가?</p>\n</li>\n<li>\n<p>Font Weight\n요소의 폰트 굵기를 바꾼다. font-weight css 설정과 같다.\nfont-{thin, extralight, light, normal, medium, semibold, bold, extrabold, black} : 각각이 font-weight 100부터 900까지에 해당된다.</p>\n</li>\n<li>\n<p>Font Variant Numeric\n숫자의 스타일을 결정한다. 가령 0에 사선을 그을 것인지 말 것인지 등을 결정. 당장 크게 쓰일 일은 없을 것 같아 넘어간다.</p>\n</li>\n<li>\n<p>Letter Spacing\n자간을 설정한다.\ntracking-{tighter, tight, normal, wide, wider, widest}</p>\n</li>\n<li>\n<p>Line Height\n한 줄의 높이를 설정한다. leading-{숫자} 로 설정할 수 있다. 그러나 font size를 설정할 때 자동으로 적절히 같이 설정되기도 한다.</p>\n</li>\n<li>\n<p>List Style Type\n리스트가 bullet point를 쓸 건지 1., 2., ... 와 같은 숫자 표기를 쓸 것인지 결정한다.\nlist-{none, disc, decimal}</p>\n</li>\n<li>\n<p>List Style Position\n리스트에서 bullet point와 같은 리스트의 구분 표시가 리스트 영역의 밖에 있을지를 결정한다.</p>\n</li>\n<li>\n<p>Text Align\n말 그대로 텍스트 정렬이다. justify의 경우 한 줄 한 줄을 꽉 채우고 넘어가는 것이다.\ntext-{left, center, right, justify, start, end}</p>\n</li>\n<li>\n<p>Text Color\n요소의 텍스트 색을 나타낸다. text-{color이름} 과 같은 클래스명으로 설정할 수 있다. 이 색 팔레트는 공식 문서의 컬러 페이지에서 확인 가능하다. <a href=\"https://tailwindcss.com/docs/customizing-colors#default-color-palette\">https://tailwindcss.com/docs/customizing-colors#default-color-palette</a></p>\n</li>\n<li>\n<p>Text Decoration\n텍스트에 밑줄, 윗줄 등을 그을 수 있는 옵션이다.\nunderline, overline, line-through, no-underline 클래스가 있다.</p>\n</li>\n<li>\n<p>Text Decoration Color\n텍스트의 밑줄 등의 컬러를 설정한다. decoration-{color이름} 클래스명으로 설정할 수 있고 가능한 색은 위에 있는 색 팔레트와 같다. 물론 커스터마이징도 가능하다. <a href=\"https://tailwindcss.com/docs/customizing-colors#customizing\">https://tailwindcss.com/docs/customizing-colors#customizing</a></p>\n</li>\n<li>\n<p>Text Decoration Style\n밑줄을 두 줄로 칠 수도 있고 점선으로 칠 수도 있다. 이런 텍스트 장식 스타일을 지정한다.\ndecoration-{solid, double, dotted, dashed, wavy}</p>\n</li>\n<li>\n<p>Text Decoration Thickness\n텍스트 장식(밑줄 등)의 굵기를 지정한다. decoration-숫자 형식으로 지정하며 decoration-from-font로 폰트에 따라 알아서 스타일이 결정되도록 설정할 수도 있다.</p>\n</li>\n<li>\n<p>Text Underline Offset\n텍스트와 밑줄의 간격을 설정한다.</p>\n</li>\n<li>\n<p>Text Transform\n텍스트를 대문자, 혹은 소문자 혹은 첫 글자 대문자 등으로 바꾼다.</p>\n</li>\n<li>\n<p>Text overflow\n텍스트가 요소의 너비를 넘어갔을 때 어떻게 처리할지를 결정한다.\ntruncate, text-ellipsis, text-clip이 있다. text-clip을 제외하고는 모두 넘치는 문자를 ellipsis(...)로 처리한다.</p>\n</li>\n<li>\n<p>Text Indent\n텍스트의 들여쓰기 크기를 결정한다. indent-숫자 형식이다.</p>\n</li>\n<li>\n<p>Vertical Alignment\n텍스트의 세로 정렬을 결정한다. 실제로 vertical-align css를 설정하는 것과 같다.\nalign-{baseline, top, middle, bottom, text-top, text-bottom, align-sub, align-super}</p>\n</li>\n<li>\n<p>Whitespace\n요소가 공백 문자를 처리하는 법을 지정한다.\nwhitespace-{normal, nowrap, pre, pre-line, pre-wrap}</p>\n</li>\n<li>\n<p>Word Break\n단어를 그대로 표시하면 요소의 크기를 넘기게 될 때 어떻게 처리할지를 결정한다.\nbreak-{normal, words, all}</p>\n</li>\n</ul>\n<h1>참고</h1>\n<p>CSS grid <a href=\"https://studiomeal.com/archives/533\">https://studiomeal.com/archives/533</a></p>\n<p>padding, margin의 차이 <a href=\"https://ofcourse.kr/css-course/margin-padding-%EC%86%8D%EC%84%B1\">https://ofcourse.kr/css-course/margin-padding-%EC%86%8D%EC%84%B1</a></p>\n<p>font-smooth에 대하여 <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth\">https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth</a></p>",
    "excerpt": "1. 두번째 글의 목적\n첫번째 글에서는 tailwind 개론과 제공하는 몇 가지 기능들을 다루었다. 이 글에서는 tailwind를 본격적으로 시작하기 전에 어떤 클래스들이 존재하는지 간단히 정리해 두는 글이다. 물론 그때그때 부딪쳐 가면서 배울 수도 있겠지만 먼저 한번 정리해 두는 것이 더 효율적이라고 느낀다. 대충 뭐가 있는지 알아야 부딪치든 말든 하니까.\n2. 기본 스타일\ntailwind에서는 브라우저별로 다른 기본 CSS 설정 등을 싹 밀어 주고 어느 정도",
    "headingTree": [
      {
        "title": "1. 두번째 글의 목적",
        "url": "#1-두번째-글의-목적",
        "items": []
      },
      {
        "title": "2. 기본 스타일",
        "url": "#2-기본-스타일",
        "items": []
      },
      {
        "title": "3. Layout 관련 스타일",
        "url": "#3-layout-관련-스타일",
        "items": []
      },
      {
        "title": "4. Display(Layout) 관련 스타일",
        "url": "#4-displaylayout-관련-스타일",
        "items": []
      },
      {
        "title": "5. Spacing styles",
        "url": "#5-spacing-styles",
        "items": []
      },
      {
        "title": "6. Sizing style",
        "url": "#6-sizing-style",
        "items": []
      },
      {
        "title": "7. Typography",
        "url": "#7-typography",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 3,
      "wordCount": 778
    },
    "url": "/posts/tailwind-2",
    "thumbnail": {
      "local": "/thumbnails/tailwind-2-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-tailwind-2-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAhElEQVR4nGNoa2tTVVXNzMwMCgrKzMzU0NBobm7+//8/Q2VlJScnp7m5eUxMTFtb24ULFx49egSSWLlypY+PT3x8/OzZsx89evT79+//YMBw4sSJzs7O6dOnv337FiIElbh9996jR48fPXr04cMHFImZcxdMnjp16dKlly9f/v//P9woAN3gZ6scUuGOAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "tailwind-1",
    "title": "프론트 지식 익히기 tailwind - 1",
    "date": "2022-07-27T00:00:00Z",
    "description": "프로젝트에서 tailwind를 사용하는 기록",
    "tags": [
      "web",
      "study",
      "front"
    ],
    "html": "<h1>0. 프론트 공부 정리</h1>\n<p>프로젝트에서 프론트를 맡아 구현하면서 여러 가지를 공부하고 있다. 그러면서 알게 되는 지식들을 이곳에 일단 난잡하게나마 쌓아 두는 식으로 정리한다. 아마 tailwind와 HTML 태그들, 그리고 React 관련 토막 지식들이 들어가지 않을까 한다.</p>\n<h1>1. tailwind 사용 시작</h1>\n<p>원래 하던 프로젝트에서는 styled-component로 프론트 페이지 제작을 진행하였다. 그러나 컴포넌트 이름을 짓기가 점점 힘들어지고 커스터마이징을 어느 정도로 해야 할지 늘 고민해야 했다. 그래서 사용을 추천받은 것이 tailwind와 DaisyUI였다. 하지만 tailwind는 초반 러닝커브가 꽤 있는 라이브러리였다. 특히 tailwind에서 자체적으로 정리한 클래스명을 사용해야 했다. tailwind의 기초와 이런 클래스명들을 익히며 여기 간단히 기록을 남긴다. tailwind 공식 문서를 참고하여 공부하였다. 이 글은 tailwind 공식 문서의 Core Concepts에 있는 페이지들을 간단히 정리하였다.</p>\n<h1>2. tailwind를 쓰는 이유 - Utility-First Fundamentals</h1>\n<p>일단 가장 간편하게는 미리 정의된 클래스명인 <code>w-12</code>(특정 너비를 의미한다) 등을 사용할 수 있다. 물론 컴포넌트 하나에 클래스명이 10개도 넘게 붙어 있는 것이 보기에는 난잡한 코드로 보일 수 있다. 하지만 더 이상 클래스명을 짓기 위한 고민을 안 해도 되고 한번 tailwind 클래스명을 익혀 놓으면 생산성도 크게 좋아진다.</p>\n<p>inline style과도 비슷해 보이지만 매직 넘버를 안 써도 되고 반응형 디자인을 쉽게 구현할 수 있으며 hover, focus 등의 상태 디자인도 할 수 있다는 점에서 더 범용적이고 편리하다. 가령 컴포넌트에 마우스를 올렸을 때 특정 색이 뜨게 하고 싶다면 <code>hover:bg-my-color</code> 와 같은 className을 주면 된다.</p>\n<h1>3. tailwind에서 제공하는 상태들 - Hover, Focus, and Other States</h1>\n<p><code>hover</code>, <code>focus</code>, <code>active</code>, <code>visited</code> 등의 유사 클래스를 제공한다.</p>\n<p>그리고 컴포넌트 자신이 부모 컴포넌트의 첫번째 자식, 혹은 마지막 자식일 때 발현되는 modifier인 <code>first</code>, <code>last</code>가 있고 짝수, 홀수 번째 자식일 때 발현되는 <code>even</code> <code>odd</code>도 있다.</p>\n<p>폼의 상태를 나타내는 <code>disabled</code> <code>invalid</code> <code>required</code> <code>read-only</code>등의 유사 클래스도 있다.</p>\n<p>이외에도 엄청나게 많은 modifier를 제공한다. 몇 가지를 아래 정리한다.</p>\n<p>부모 컴포넌트의 상태에 따라서 자식 컴포넌트의 CSS를 바꿔야 할 수도 있다. 예를 들어 부모 컴포넌트에 hover하면 그 자식 컴포넌트의 텍스트 색이 흰색으로 바뀌는 것을 들 수 있다. 이런 건 부모 컴포넌트에 <code>group</code>이라는 클래스명을 준 후 부모 컴포넌트 상태에 따라 바꾸고 싶은 자식 컴포넌트에 <code>group-hover:stroke-white</code>와 같이 <code>group-*</code>으로 시작하는 상태명을 주면 된다.</p>\n<p>sibling의 상태에 따라 스타일링하는 것도 sibling에게 <code>peer</code>클래스를 부여한 후 <code>peer-*:*</code> 와 같은 클래스를 쓰는 것으로 가능하다. 단 sibling의 상태에 따라 디자인을 바꾸고 싶은 컴포넌트가 더 뒤쪽에 와야 가능하다. (<code>peer</code> 컴포넌트를 더 위쪽에 정의해야 한다.)</p>\n<p>input이나 textarea의 placeholder도 <code>placeholder:*</code> 와 같은 modifier로 스타일링할 수 있다.</p>\n<p>또한 input(file type)컴포넌트의 파일 업로드 버튼도 <code>file:*</code> modifier로 스타일링한다.</p>\n<p><code>&#x3C;li></code> 컴포넌트의 list marker도 <code>marker</code>를 이용해서 스타일링 가능하다. li 컴포넌트에 <code>marker:text-sky-400</code>과 같은 클래스명을 주면 된다. 이는 상속되기 때문에 li 컴포넌트 각각에 써도 되지만 상위 컴포넌트인 ul 컴포넌트 등에 적용해도 잘 상속되어 적용된다.</p>\n<p>highlighted text는 <code>selection:*</code>을 이용해 스타일링한다. 문단(p 태그)의 첫 줄과 첫 단어도 <code>first-line</code> <code>first-letter</code> modifier로 스타일링 가능하다.</p>\n<p><code>&#x3C;dialog></code> 태그를 사용한다면 다이얼로그 뒤에 뜨는 창 색상인 듯한 backdrop도 <code>backdrop:bg-gray-50</code>과 같은 클래스명으로 스타일링할 수 있다. dialog나 details 태그를 사용한다면 그 태그가 열렸을 때에 대한 스타일링을 하는 <code>open</code> modifier도 사용할 만 하다.</p>\n<p>반응형 디자인을 할 때는 <code>sm:*</code>, <code>md:*</code> 와 같은 클래스명을 사용하게 된다. 화면의 크기에 따라 sm~2xl까지 존재한다.</p>\n<p>만약 유저가 웹에서 최소한의 움직임만 허용하는 prefers-reduced-motion 미디어 쿼리를 요청했을 경우를 대비하여 <code>motion-reduce:*</code> modifier를 사용할 수 있다.</p>\n<p>사용자가 커스텀한 셀렉터를 modifier로 사용할 수도 있다. 이는 대괄호로 표시돤다. 예를 들어 다음과 같이 셀렉터를 이용한 modifier는 컴포넌트가 부모의 3번째 자식일 때에만 발현된다. <code>[&#x26;:nth-child(3)]:underline</code></p>\n<p>사용자 정의 셀렉터에 띄어쓰기가 필요하면 언더스코어를 사용하자. 자손 컴포넌트의 모든 p 태그를 선택하는 셀렉터의 modifier class는 다음과 같다. <code>[&#x26;_p]:*</code></p>\n<p>이런 사용자 정의 셀렉터 중 반복되는 게 있으면 <code>addVariant</code>API를 이용해서 새로 정의할 수도 있다. (<a href=\"https://tailwindcss.com/docs/hover-focus-and-other-states\">https://tailwindcss.com/docs/hover-focus-and-other-states</a> 의 <code>Creating a plugin</code>항목 참고)</p>\n<p>모든 유사 클래스 정보는 레퍼런스를 참고하자. (<a href=\"https://tailwindcss.com/docs/hover-focus-and-other-states?email=geor%40ustrial&#x26;password=Bosco#disabled\">https://tailwindcss.com/docs/hover-focus-and-other-states?email=geor%40ustrial&#x26;password=Bosco#disabled</a>)</p>\n<h1>4. 반응형 디자인 하기 - Responsive Design</h1>\n<p>tailwind에서는 모든 클래스를 화면 크기에 따라 적용할 수 있도록 해놓았다. sm, md, lg, xl, 2xl의 prefix는 화면의 크기가 얼만큼의 경계를 넘어서냐에 따라서 적용되거나 적용되지 않는다. 예를 들어 <code>w-16 md:w-32 lg:w-48</code>이라는 class가 있다면 이는 너비가 768px가 넘는 화면에선 <code>w-32</code>, 1024px가 넘는 화면에선 <code>w-48</code>로 보일 것이다.</p>\n<p>그리고 tailwind는 mobile-first이다. 따라서 스타일링의 기본은 모바일이 되어야 한다. prefix가 없는 클래스라면 모든 화면 사이즈에 적용될 것이고 sm: 과 같은 prefix를 붙인다면 그 경계선을 넘는 크기의 화면부터 그 클래스의 화면이 적용될 것이다. 따라서 모바일 화면을 위해서는 unprefixed utility를 쓰고 더 큰 화면의 대비를 위해서는 sm: 등의 화면 breakpoint를 나타내는 prefix를 써서 스타일링하는 게 맞다.</p>\n<p>또한 max-width breakpoint가 없음에 유의하라. 만약 medium 크기의 화면에만 어떤 미디어 쿼리를 적용하고 싶다면 md: 에 그걸 적용한 후 lg: 화면에서는 원래대로 되돌리면 된다.</p>\n<p>이런 미디어 쿼리 breakpoint는 tailwind.config.js에서 커스텀할 수 있다.\ntheme의 screens 항목을 만들어서 'tablet':'640px'(min-width 640px인 화면 미디어 쿼리가 만들어짐) 등의 항목을 추가하면 된다. 자세한 커스텀 내용은 <a href=\"https://tailwindcss.com/docs/screens\">https://tailwindcss.com/docs/screens</a> 참조.</p>\n<h1>5. 다크 모드</h1>\n<p>다크 모드를 지원하는 페이지가 많다. tailwind에서도 <code>dark:*</code>클래스를 이용해서 다크모드일 경우를 스타일링할 수 있게 하고 있다. 이는 미디어 쿼리 중 <code>prefers-color-scheme</code>를 이용하게 한다.</p>\n<p>그러나 다크모드를 토글할 수 있게 하는 페이지도 많다. 이는 tailwind.config.js에서 darkMode항목을 media 대신 class로 바꾸면 된다. 그러면 html 태그(정확히는 HTML트리에서 더 앞에 있는 태그 중 아무거나) class가 'dark' 클래스를 가지고 있는지에 따라 다크모드가 적용되고 안 되고가 바뀐다.</p>\n<h1>6. 스타일 재사용</h1>\n<p>프로젝트가 커질수록, 특정 스타일 유틸리티의 조합이 반복되는 경우가 많아지게 된다. 가령 똑같은 class 조합이 들어간 버튼만 수십 개가 된다거나..이런 반복되는 스타일을 잘 다루는 법도 가이드에 적혀 있다.</p>\n<p>물론 이런 반복되는 스타일을 따로 클래스로 빼는 법도 존재한다. 그러나 VScode 등에서 제공하는 multi-cursor editing(<a href=\"https://code.visualstudio.com/docs/editor/codebasics#_multiple-selections-multicursor)%EC%9C%BC%EB%A1%9C\">https://code.visualstudio.com/docs/editor/codebasics#_multiple-selections-multicursor)으로</a> 모든 반복되는 클래스를 한번에 편집하는 식으로 다루는 것도 가능하다. 반복되는 스타일이 한 파일에만 있다면 이렇게 하는 것이 새로운 추상화 클래스를 만드는 것보다 좋을 수 있다.</p>\n<p>혹은 반복되는 요소들의 내용을 배열에 담은 후 map 등을 이용해서 코드의 반복을 피하는 것도 방법이다. 그러면 실제 요소의 코드가 쓰이는 건 한 번뿐이다.</p>\n<p>React 등의 프론트엔드 프레임워크를 사용하고 있다면 반복되는 요소를 컴포넌트로 만드는 것이 가장 좋은 방법이다. 반복되는 요소에서 달라지는 부분을 파악해 <code>children</code>등의 props와 다른 props를 정의하여 컴포넌트를 제작해 반복 요소를 처리할 수 있다.</p>\n<p>이런 반복되는 요소를 따로 css class로 뺄 수도 있다. 그러나 그렇게 하면 결국 클래스명은 여러 컴포넌트에서 똑같이 반복되게 된다. 따라서 그보다는 컴포넌트를 따로 만들어서 추상화하는 게 더 좋은 방법이다.</p>\n<h1>7. 커스텀 스타일</h1>\n<p>프레임워크를 사용하면서 가장 힘든 점 하나는 프레임워크가 해주지 않는 부분을 직접 핸들링할 때이다. tailwind는 이런 것을 tailwind.config.js에서 어느 정도 확장하고 핸들링할 수 있게 제작되었다.</p>\n<p>만약 컬러 팔레트나 spacing 스타일, 글씨체 등을 바꾸고 싶다면 tailwind.config.js의 theme section을 편집하면 된다.</p>\n<p>그리고 tailwind에서 제공하는 색, 크기, 간격 등 외에 아예 다른 임의의 값을 사용하고 싶을 수도 있다. 그러면 <code>[]</code>를 이용해서 그 값을 적어넣으면 된다. 예를 들어서 <code>bg-[#bada55]</code>를 사용하면 background color가 내가 설정한 색으로 설정된다. 이는 <code>hover</code>등의 state와도 쉽게 같이 사용될 수 있다.</p>\n<p><code>[mask-type:luminance]</code> 과 같이 아예 tailwind에서 지원하지 않는 CSS 프로퍼티를 통째로 집어넣을 수도 있다. 이는 정말 인라인 스타일과 비슷하지만 역시 hover등의 state와 같이 쓰일 수 있는 게 장점이다.</p>\n<p>만약 <code>[]</code> 내에서 띄어쓰기가 필요하다면 언더스코어로 대신하면 된다. 그러면 tailwind가 알아서 빌드할 때 변환해 준다. 만약 정말 언더스코어가 필요한 경우 보통 tailwind가 알아서 변환을 안하지만 모호한 경우 백슬래시를 붙여서 언더스코어로 무조건 쓰이도록 할 수 있다.</p>\n<p>이외에도 <code>@apply</code>를 사용하는 등 많은 스타일링 방법이 있지만 그렇게 많이 사용하지는 않는다고 한다.</p>\n<h1>8. Functions &#x26; Directives</h1>\n<p>directives는 Tailwind CSS에서 특별한 기능을 만드는 데에 쓰인다. 또 몇 가지 함수들을 제공한다. 대부분 커스텀 스타일과 관련된 부분인데 나중에 필요할 때 읽으면 될 것 같다. 빠르게 tailwind를 익히는 것과는 큰 상관이 없어 보이는데, 개발하면서 만약 중요한 부분인 것 같으면 돌아와서 보강하도록 하겠다.</p>",
    "excerpt": "0. 프론트 공부 정리\n프로젝트에서 프론트를 맡아 구현하면서 여러 가지를 공부하고 있다. 그러면서 알게 되는 지식들을 이곳에 일단 난잡하게나마 쌓아 두는 식으로 정리한다. 아마 tailwind와 HTML 태그들, 그리고 React 관련 토막 지식들이 들어가지 않을까 한다.\n1. tailwind 사용 시작\n원래 하던 프로젝트에서는 styled-component로 프론트 페이지 제작을 진행하였다. 그러나 컴포넌트 이름을 짓기가 점점 힘들어지고 커스터마이징을 어느 정",
    "headingTree": [
      {
        "title": "0. 프론트 공부 정리",
        "url": "#0-프론트-공부-정리",
        "items": []
      },
      {
        "title": "1. tailwind 사용 시작",
        "url": "#1-tailwind-사용-시작",
        "items": []
      },
      {
        "title": "2. tailwind를 쓰는 이유 - Utility-First Fundamentals",
        "url": "#2-tailwind를-쓰는-이유---utility-first-fundamentals",
        "items": []
      },
      {
        "title": "3. tailwind에서 제공하는 상태들 - Hover, Focus, and Other States",
        "url": "#3-tailwind에서-제공하는-상태들---hover-focus-and-other-states",
        "items": []
      },
      {
        "title": "4. 반응형 디자인 하기 - Responsive Design",
        "url": "#4-반응형-디자인-하기---responsive-design",
        "items": []
      },
      {
        "title": "5. 다크 모드",
        "url": "#5-다크-모드",
        "items": []
      },
      {
        "title": "6. 스타일 재사용",
        "url": "#6-스타일-재사용",
        "items": []
      },
      {
        "title": "7. 커스텀 스타일",
        "url": "#7-커스텀-스타일",
        "items": []
      },
      {
        "title": "8. Functions & Directives",
        "url": "#8-functions--directives",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 272
    },
    "url": "/posts/tailwind-1",
    "thumbnail": {
      "local": "/thumbnails/tailwind-1-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-tailwind-1-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAiElEQVR4nGNoa2tTVVXNyckJCgrKzMzU0NBobm7+//8/Q2VlJQsLi7m5RUxM7JQpk8+cOfPo0SOQxOzZs2NiYlJTUzs7Ox89evT79+//YMBw4sTxpqam6WDw8uWL////Q+QYbt+9d+/evadPn3758gWiFqpj5twF06bPWL5s2YULF+DK////DwCHPmZK49VePwAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "tailwind-3",
    "title": "프론트 지식 익히기 tailwind - 3",
    "date": "2022-07-29T00:00:00Z",
    "description": "프로젝트 tailwind 사용기 - 태그 정리 2",
    "tags": [
      "web",
      "study",
      "front"
    ],
    "html": "<h1>1. 두번째 태그 정리</h1>\n<p>이전 글에 이어서 tailwind의 태그들을 간단히 정리해 올려 놓는다. 어떤 태그가 있는지 쭉 훑어보면서 알아 두고 나중에 더 제대로 쓸 때는 공식 문서를 찾아보면서 프로젝트를 진행할 예정이다.</p>\n<h1>2. Backgrounds</h1>\n<p>배경과 관련한 속성들이다.</p>\n<ul>\n<li>\n<p>Background Attachment\n배경 이미지가 뷰포트의 스크롤과 함께 움직일지를 결정하는 속성이다.\nbg-fixed : 배경을 뷰포트에 대해 고정한다. 요소에 스크롤이 존재해도 배경은 함께 스크롤되지 않는다.\nbg-local : 배경을 요소 콘텐츠에 대해 고정한다. 요소에 스크롤이 존재하면 배경은 콘텐츠와 함께 스크롤된다.\nbg-scroll : 배경을 요소 자체에 대해 고정한다. 요소에 스크롤이 존재해도 배경은 함께 스크롤되지 않는다. 즉 요소의 테두리에 배경 이미지를 부착한 것과 같은 효과를 낸다.</p>\n</li>\n<li>\n<p>Background Clip\n요소의 배경이 테두리, 안쪽 여백, 콘텐츠 박스 중 어디까지 차지할지를 결정한다.\nbg-clip-{border, padding, content, text}</p>\n</li>\n<li>\n<p>Background Color\n말 그대로 배경색을 지정한다. bg-{color이름} 클래스명을 사용하며 컬러 팔레트는 위에서 나온 공식 문서의 팔레트와 같다.</p>\n</li>\n<li>\n<p>Background Origin\n배경의 원점을 테두리 시작점, 테두리 내부, 안쪽 여백 내부 중 어느 것으로 지정할지를 결정한다.\nbg-origin-{border, padding, content}</p>\n</li>\n<li>\n<p>Background Position\n배경 이미지의 위치를 결정한다. 8방향과 중앙까지 9방향을 지원한다.\nbg-{bottom, top, ..., center}</p>\n</li>\n<li>\n<p>Background Repeat\n배경 이미지의 반복을 결정한다. 반복 여부와 어떤 축으로 반복할지, 잘리지 않도록 배경 이미지 크기를 조절하거나(round) 끝에서 끝까지 고르게 분배(space)할 수도 있다.\nbg-{repeat, no-repeat, repeat-x, repeat-y, repeat-round, repeat-space}</p>\n</li>\n<li>\n<p>Background Size\n요소 배경 이미지의 크기를 결정한다. 그대로 두거나, 늘리고 줄이거나, 공간에 맞출 수 있다. bg-{auto, cover, contain}</p>\n</li>\n<li>\n<p>Background Gradient\n배경색에 그라데이션 같은 것을 줄 수 있다.\nbg-gradient-to-r from-cyan-500 to-blue-500 은 cyan-500에서 오른쪽으로 갈수록 blue-500이 되는 그라데이션이다. 또한 bg-gradient-to-{t, tr, r, br, b, bl, l, tl} 을 이용해서 그라데이션 방향도 조절 가능하다. 로고 색 등을 입힐 때 요긴하게 사용될 것 같아 정리해 둔다.</p>\n</li>\n</ul>\n<h1>3. Borders</h1>\n<p>당연히 테두리에 관련된 속성들이다.</p>\n<ul>\n<li>\n<p>Border Radius\n모서리를 둥글게 깎아 주는 옵션이다. 매우 자주 쓰이기 때문에 모서리 4개 각각에 대해 깎는 옵션도 따로 있고 크기도 다양하다.</p>\n</li>\n<li>\n<p>Border Width\n테두리의 굵기를 정하는 옵션이다. border-숫자 형식의 클래스로 지정한다.</p>\n</li>\n<li>\n<p>Border Color\n테두리의 색깔을 지정한다. border-색깔명 클래스로 지정하며 색깔 이름은 tailwind 공식 문서의 컬러 팔레트에 있는 것과 같다.</p>\n</li>\n<li>\n<p>Border Style\n테두리 스타일은 solid한 실선이 될 수도 있지만 점선이나 이중 실선이 될 수도 있다. 이를 결정하는 옵션이다.\nborder-{solid, dashed, dotted, double, hidden, none}</p>\n</li>\n<li>\n<p>Divide Width\n요소들 간의 경계 테두리를 정하는 속성이다. divide-x-숫자, divide-y-숫자 형식으로 사용한다.</p>\n</li>\n<li>\n<p>Divide Color\n요소들 간의 경계의 색상을 결정한다. divide-색이름 과 같이 사용하며 색 이름은 참고 부분의 컬러 팔레트를 따른다.</p>\n</li>\n<li>\n<p>Divide Style\n역시 요소 경계가 점선인지 이중 실선인지 등을 결정한다.</p>\n</li>\n<li>\n<p>Outline\nOutline도 width, color, style(점선, 실선...) 스타일링이 가능하다.</p>\n</li>\n<li>\n<p>Ring\n비슷하게 Ring 이라는 것도 스타일링이 가능한 것 같다. 당장 쓸 일이 없을 듯해 넘어갔다.</p>\n</li>\n</ul>\n<h1>4. Effects</h1>\n<ul>\n<li>\n<p>Box Shadow\n요소의 그림자를 설정하는 옵션이다.\nshadow-{sm, md, lg, xl, 2xl, inner, none}과 같은 클래스로 사용할 수 있다. shadow 클래스로 기본 그림자를 줄 수도 있다.</p>\n</li>\n<li>\n<p>Box Shadow Color\n역시 요소의 그림자를 설정한다. shadow-색이름 과 같은 클래스로 사용하며 tailwind 기본 팔레트를 사용할 수 있다.</p>\n</li>\n<li>\n<p>Opacity\n요소의 불투명도를 설정한다. opacity-0 부터 opacity-100 까지 10 단위로 설정 가능하다. 이때 100이 완전히 불투명한 것이다.</p>\n</li>\n<li>\n<p>Mix Blend Mode\n요소의 콘텐츠가 자신의 배경 및 부모와 어떻게 혼합되어야 하는지 결정한다.\nmix-blend-{normal, multiply, screen, overlay, darken, lighten, color-dodge, color-burn} 비슷한 것으로 Background Blend Mode 가 있다.</p>\n</li>\n</ul>\n<hr>\n<p>이외에도 많은 속성이 있지만 당장 필요한 건 이 정도인 것 같아 추후에 더 많은 속성을 정리하도록 하겠다.</p>\n<h1>참고</h1>\n<p>background attachment from MDN <a href=\"https://developer.mozilla.org/ko/docs/Web/CSS/background-attachment\">https://developer.mozilla.org/ko/docs/Web/CSS/background-attachment</a> 외 많은 CSS 속성 MDN 문서\n<a href=\"https://developer.mozilla.org/ko/docs/Web/CSS/blend-mode\">https://developer.mozilla.org/ko/docs/Web/CSS/blend-mode</a> 등등...</p>\n<p>tailwind 컬러 팔레트 <a href=\"https://tailwindcss.com/docs/customizing-colors#default-color-palette\">https://tailwindcss.com/docs/customizing-colors#default-color-palette</a></p>",
    "excerpt": "1. 두번째 태그 정리\n이전 글에 이어서 tailwind의 태그들을 간단히 정리해 올려 놓는다. 어떤 태그가 있는지 쭉 훑어보면서 알아 두고 나중에 더 제대로 쓸 때는 공식 문서를 찾아보면서 프로젝트를 진행할 예정이다.\n2. Backgrounds\n배경과 관련한 속성들이다.\n\n\nBackground Attachment\n배경 이미지가 뷰포트의 스크롤과 함께 움직일지를 결정하는 속성이다.\nbg-fixed : 배경을 뷰포트에 대해 고정한다. 요소에 스크롤이 존재해도 배경",
    "headingTree": [
      {
        "title": "1. 두번째 태그 정리",
        "url": "#1-두번째-태그-정리",
        "items": []
      },
      {
        "title": "2. Backgrounds",
        "url": "#2-backgrounds",
        "items": []
      },
      {
        "title": "3. Borders",
        "url": "#3-borders",
        "items": []
      },
      {
        "title": "4. Effects",
        "url": "#4-effects",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 192
    },
    "url": "/posts/tailwind-3",
    "thumbnail": {
      "local": "/thumbnails/tailwind-3-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-tailwind-3-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAg0lEQVR4nE3LvQmDIRSFYQtXEZzBMaxc4YILCBaClQvkS5BAGgsHsRcsQywEe3uLG/IDySnfh0NCCIwxAJBSAgDn3HuPiMQYQykVQiilnHO11jHGC3LOUkqtdYxxzrn3xvdIKcVaG0IopSDiD+6P3nsfY6y1PukLl+vtdJxTSq21/8cTsCJm79N0uI4AAAAASUVORK5CYII="
    }
  },
  {
    "slug": "threejs-1",
    "title": "ThreeJS를 하면서 간략한 정리",
    "date": "2023-06-15T00:00:00Z",
    "description": "ThreeJS 공식 문서 훑어보기",
    "tags": [
      "javascript"
    ],
    "html": "<h1>1. 시작</h1>\n<p>기본적인 설치법은 <a href=\"https://threejs.org/docs/index.html#manual/en/introduction/Installation\">공식 문서의 설치 가이드</a>를 참고. 나는 이곳에서 Vite를 사용했다.</p>\n<p>기본 원리는 그래픽스에서 배운 것과 같다. Scene에 있는 물체를 Camera에서 보고, 카메라에 맺힌 영상을 Renderer가 화면에 렌더링한다. 만약에 이 글을 읽는 사람이 있고 내부 원리가 궁금하다면 그래픽스 과목을 들어보길 바란다. <a href=\"http://grmanet.sogang.ac.kr/publications.html#book\">서강대학교 임인성 교수님 연구실에서 좀 오래되긴 했어도 한글로 된 그래픽스 자료를 무료로 볼 수 있다.</a></p>\n<p>three.js에서는 이를 각각 Scene, Camera, Renderer로 구현한다. 공식 페이지에서는 화면에 회전하는 초록색 정육면체를 띄우는 예제를 보여준다.</p>\n<pre><code class=\"language-javascript\">// 출처 : https://threejs.org/docs/index.html#manual/en/introduction/Creating-a-scene\nimport * as THREE from 'three';\n// 물체가 들어갈 scene\nconst scene = new THREE.Scene();\n// 물체를 비출 카메라. 인수는 시야각, aspect ratio, near, far이다.\nconst camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );\n// 물체를 렌더링할 렌더러\nconst renderer = new THREE.WebGLRenderer();\nrenderer.setSize( window.innerWidth, window.innerHeight );\n// DOM tree에 렌더러를 추가해서 화면에 띄운다.\ndocument.body.appendChild( renderer.domElement );\n// 박스 만들기 + 초록색으로\nconst geometry = new THREE.BoxGeometry( 1, 1, 1 );\nconst material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );\nconst cube = new THREE.Mesh( geometry, material );\n// scene에 박스 추가\nscene.add( cube );\n\ncamera.position.z = 5;\n// 렌더링 함수\nfunction animate() {\n\trequestAnimationFrame( animate );\n\n\tcube.rotation.x += 0.01;\n\tcube.rotation.y += 0.01;\n\n\trenderer.render( scene, camera );\n}\n\nanimate();\n</code></pre>\n<p>Renderer는 Scene, Camera를 넘겨받아서 카메라가 비추고 있는 범위를 2차원으로 축소해서 제공한다. 자세한 내용은 그래픽스 과목에서 다룬다.</p>\n<p><img src=\"/static/threejs-1cube-no-light-scene-8e10298b.svg\" alt=\"threejs-cube-nolight\"></p>\n<p>만약 빛을 넣고 싶다면 AmbientLight나 DirectionalLight 등의 광원을 추가하고 Material을 MeshPhongMaterial로 바꾸면 된다. Phong은 광원을 근사적으로 모델링하는 모델 이름인데 제작자 이름을 따서 만들어졌다.</p>\n<pre><code class=\"language-javascript\">// 빛 만들기 코드의 일부\nconst geometry = new THREE.BoxGeometry( 1, 1, 1 );\n\nconst material = new THREE.MeshPhongMaterial( { color: 0x00ff00 } );\nconst cube = new THREE.Mesh( geometry, material );\nscene.add( cube );\n/* DirectionalLight 선언 */\nconst color=0xFFFFFF;\nconst intensity=1;\nconst light = new THREE.DirectionalLight(color, intensity);\nlight.position.set(-1, 2, 4);\nscene.add(light);\n\ncamera.position.z = 5;\n</code></pre>\n<h1>2. threejs 기본 구조</h1>\n<h2>2.1. BoxGeometry</h2>\n<p>너비, 높이, 깊이를 인자로 받아서 육면체를 만든다. 그리고 4,5,6번째 인수로 각 면을 이루는 세그먼트 개수에 대한 설정을 할 수 있다.</p>\n<pre><code class=\"language-js\">const geometry = new THREE.BoxGeometry(width, height, depth);\nconst geometry = new THREE.BoxGeometry(width, height, depth, widthSegments, heightSegments, depthSegments);\n</code></pre>\n<h2>2.2. CircleGeometry</h2>\n<p>반지름과 세그먼트 개수를 받아서 원을 만든다. 세그먼트는 원을 몇 개의 호로 나눌지를 결정한다. 예를 들어서 8개의 세그먼트로 원을 구현한다면 원보다는 팔각형에 가까운 모양이 렌더링된다.</p>\n<p>3,4번째 인수로는 호를 그릴 수 있는 기능을 제공하는데 호의 시작 각도와 호의 중심각을 지정할 수 있다. 라디안 단위.</p>\n<pre><code class=\"language-js\">const geometry = new THREE.CircleGeometry(radius, segments);\nconst geometry = new THREE.CircleGeometry(radius, segments, thetaStart, thetaLength);\n</code></pre>\n<h2>2.3. ConeGeometry</h2>\n<p>원뿔 그리기. 반지름, 높이, 세그먼트 개수, 원뿔의 꼭대기를 닫을지 여부, 원뿔호의 시작각도, 원뿔호의 중심각도를 인수로 받는다.</p>\n<pre><code class=\"language-js\">const geometry = new THREE.ConeGeometry( radius, height, radialSegments );\nconst geometry = new THREE.ConeGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );\n</code></pre>\n<h2>2.4. CylinderGeometry</h2>\n<p>윗/밑면 반지름, 높이, 세그먼트 개수, 끝을 닫을지 여부, 원기둥 호의 시작각도, 호의 중심각.</p>\n<pre><code class=\"language-js\">const geometry = new THREE.CylinderGeometry( radiusTop, radiusBottom, height, radialSegments );\nconst geometry = new THREE.CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );\n</code></pre>\n<h2>2.5. DodecahedronGeometry</h2>\n<p>십이면체를 그린다. 반지름과 디테일한 정도가 전부다.</p>\n<pre><code class=\"language-js\">// 반지름만 전달도 가능\nconst geometry = new THREE.DodecahedronGeometry( radius );\nconst geometry = new THREE.DodecahedronGeometry( radius, detail );\n</code></pre>\n<h2>2.6. ExtrudeGeometry</h2>\n<p>경로를 따라 생성된 입체를 렌더링한다. 입체는 threejs의 Shape 객체를 통해 만들어질 수 있다.</p>\n<pre><code class=\"language-js\">const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);\n</code></pre>\n<h2>2.7. IcosahedronGeometry</h2>\n<p>이십면체를 그린다.</p>\n<pre><code class=\"language-js\">const geometry = new THREE.IcosahedronGeometry( radius );\nconst geometry = new THREE.IcosahedronGeometry( radius, detail );\n</code></pre>\n<h2>2.8. SphereGeometry</h2>\n<p>구를 그린다. 구면 좌표계를 통한 그림도 지원한다.</p>\n<pre><code class=\"language-js\">const geometry = new THREE.SphereGeometry( radius, widthSegments, heightSegments );\nconst geometry = new THREE.SphereGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength );\n</code></pre>\n<h2>2.8. 기타 Geometry</h2>\n<ul>\n<li>LatheGeometry : 선을 회전시켜 만든 모양을 렌더링한다.</li>\n<li>OctahedronGeometry : 팔면체를 그린다.</li>\n<li>ParametricGeometry : 매개 변수를 통해서 만든 입체를 렌더링하는 듯 하다.</li>\n<li>PlaneGeometry : 평면을 그린다.</li>\n<li>PolyhedronGeometry : 다면체를 그린다.</li>\n<li>RingGeometry : 중앙이 비어 있는 CD같은 모양의 디스크를 그린다.</li>\n<li>ShapeGeometry : 2D 윤곽선을 그린다.</li>\n<li>TetrahedronGeometry : 사면체를 그린다.</li>\n<li>TextGeometry : 텍스트를 그린다. 폰트를 따로 로딩해 줘야 한다.</li>\n<li>TorusGeometry : 도넛 모양을 그린다.</li>\n<li>TorusKnotGeometry : 원환 매듭 모양을 그린다.</li>\n<li>TubeGeometry : 경로를 따라서 원통을 그린다.</li>\n<li>EdgesGeometry : 다른 geometry를 받아서 각 면 사이 각이 thresholdAngle 이상일 때만 모서리를 그린다.</li>\n<li>WireframeGeometry</li>\n</ul>\n<h1>3. Scene graph</h1>\n<p>씬 그래프는 요소의 계층 구조를 나타낸다. 각 요소의 지역 공간과 그 소속을 다루는 것이다. 예를 들어서 지구는 태양의 지역 공간에 속해서 태양을 공전한다. 그리고 달은 지구의 지역 공간에서 공전한다.</p>\n<p>태양의 입장에서 보면 달은 괴상한 모양을 그리겠지만 달은 그냥 지구의 지역 공간만 신경쓰면 된다. threejs에서 이런 움직임을 모방하려 한다면 달을 지구의 자식으로 만들어서 지구의 지역 공간에서 공전하게 만들면 될 뿐이다.</p>\n<p>기본 세팅과 같은 부분을 빼고 물체 좌표계간의 계층 구조를 만드는 코드는 다음과 같다.</p>\n<pre><code class=\"language-js\">const solarSystem = new THREE.Object3D();\nscene.add(solarSystem);\nobjects.push(solarSystem);\n\nconst sunMaterial = new THREE.MeshPhongMaterial({emissive: 0xFFFF00});\nconst sunMesh = new THREE.Mesh(sphereGeometry, sunMaterial);\nsunMesh.scale.set(5,5,5);\n\nsolarSystem.add(sunMesh);\nobjects.push(sunMesh);\n\nconst earthOrbit=new THREE.Object3D();\nearthOrbit.position.x=10;\nsolarSystem.add(earthOrbit);\nobjects.push(earthOrbit);\n\nconst earthMaterial=new THREE.MeshPhongMaterial({color: 0x2233FF, emissive: 0x112244});\nconst earthMesh=new THREE.Mesh(sphereGeometry, earthMaterial);\nearthOrbit.add(earthMesh);\nobjects.push(earthMesh);\n\nconst moonOrbit=new THREE.Object3D();\nmoonOrbit.position.x=2;\nearthOrbit.add(moonOrbit);\n\nconst moonMaterial=new THREE.MeshPhongMaterial({color: 0x888888, emissive: 0x222222});\nconst moonMesh=new THREE.Mesh(sphereGeometry, moonMaterial);\nmoonMesh.scale.set(.5,.5,.5);\nmoonOrbit.add(moonMesh);\nobjects.push(moonMesh);\n</code></pre>\n<h1>4. Material</h1>\n<p>Material은 물체가 scene에 어떻게 나타날지를 결정한다. 이 속성은 material 생성자를 호출 시 값을 넘겨서 정할 수도 있고 생성한 다음 바꿀 수도 있다.</p>\n<p>MeshBasicMaterial : 광원 영향을 받지 않음\nMeshLambertMaterial : 광원 영향을 받는데, 정점에서만 광원을 계산함\nMeshPhongMaterial : 픽셀 하나하나에서 광원을 계산한다. 이것도 근사 모델이긴 하지만 더 정확한 광원 모델링을 위해 사용한다.</p>\n<p>옵션에서는 shininess, emissive등을 설정 가능하다.</p>\n<p>만화 같은 스타일의 물체를 생성하는 MeshToonMaterial, 물리 기반 렌더링을 위한 MeshStandardMaterial, 더 고급의 물리 렌더링 특성을 제공하는 MeshPhysicalMaterial 등이 있다.</p>\n<p>특수한 경우 사용하는 재질로는 그림자를 가져오는 ShadowMaterial, 픽셀의 깊이를 렌더링하는 MeshDepthMaterial, 법선을 렌더링하는 MeshNormalMaterial 등이 있다. 재질을 커스텀할 수 있게 해주는 ShaderMaterial도 존재한다. 이들은 당장 자세히 알 필요는 없을 것 같다.</p>\n<h2>4.1. 유명한 옵션</h2>\n<p>flatShading : 물체를 각지게 표현할지 여부, 기본값은 false\nside : 어떤 면을 렌더링할지 여부, 기본값은 THREE.FrontSide이고 THREE.BackSide / THREE.DoubleSide도 있다.</p>\n<p>재질을 만드는 건 연산이 많이 필요하기에 보통 한 번 만든 재질을 바꾸지는 않지만 만약 그래야 할 일이 있다면 <code>material.needsUpdate = true</code>로 설정해야 한다.</p>\n<h1>5. 텍스처</h1>\n<p>텍스처는 <code>TextureLoader</code>를 생성한 다음 load 메서드에 이미지를 넘겨서 호출한 후 반환된 값을 Material의 map 속성에 지정하는 방식으로 사용할 수 있다.</p>\n<pre><code class=\"language-js\">const cubes=[];\nconst loader=new THREE.TextureLoader();\n\nconst material = new THREE.MeshBasicMaterial({\n  map:loader.load(\"./witch-new.png\"),\n});\nconst cube=new THREE.Mesh(geometry,material);\nscene.add(cube);\ncubes.push(cube);\n</code></pre>\n<p>이 <code>loader.load</code>는 비동기로 작동한다. 2번째 인수로는 텍스처를 전부 불러온 후에 호출될 콜백을 지정할 수 있다. 다음과 같이 하면 텍스처를 전부 불러온 다음 화면을 렌더링한다.</p>\n<pre><code class=\"language-js\">const loader=new THREE.TextureLoader();\nloader.load(\"./witch-new.png\",function(texture){\n  const material = new THREE.MeshBasicMaterial({\n    map:texture,\n  });\n  const cube=new THREE.Mesh(geometry,material);\n  scene.add(cube);\n  cubes.push(cube);\n});\n</code></pre>\n<p>다수의 텍스처를 불러올 땐 <code>LoadingManager</code> 사용. <code>TextureLoader</code>를 생성할 때 <code>LoadingManager</code>를 인수로 넘겨준다. 그리고 <code>load</code> 메서드를 호출할 때 2번째 인수로 텍스처를 전부 불러온 후에 호출될 콜백을 지정할 수 있다.</p>\n<p>LoadingManager의 onProgress에 콜백 함수 지정시 현재 진행 상태도 추적할 수 있다.</p>\n<p>단 텍스처는 메모리를 매우 많이 사용하므로 주의해서 사용하자. 보통 텍스처는 <code>width * height * 4 * 1.33</code>바이트의 메모리를 사용한다. 따라서 필요한 퀄리티를 유지하는 선에서 해상도를 낮추는 게 좋다.</p>\n<p>그런데 텍스처의 크기가 딱 원본과 맞는 경우는 잘 없다. 이 경우 GPU는 mipmap이라는, 텍스처를 반 크기로 축소해 가면서 생성한 map들을 만들어 놓고 geometry와 가장 가까운 크기의 것을 골라서 렌더링한다.</p>\n<p>사용되는 필터는 텍스처가 원본보다 클 경우 <code>texture.magFilter</code>를 사용하며 <code>THREE.nearestFilter</code>와 <code>THREE.LinearFilter</code>가 있다.</p>\n<p>텍스처가 원본보다 작을 경우 <code>texture.minFilter</code>를 사용하며 <code>THREE.NearestFilter</code>, <code>THREE.LinearFilter</code>, <code>THREE.NearestMipmapNearestFilter</code>, <code>THREE.NearestMipmapLinearFilter</code>, <code>THREE.LinearMipmapNearestFilter</code>, <code>THREE.LinearMipmapLinearFilter</code>가 있다.</p>\n<p>필요할 때마다 추가하자.</p>\n<h1>6. 조명</h1>\n<p>조명은 대표적으로 <code>AmbientLight</code>, <code>DirectionalLight</code>, <code>HemisphereLight</code> 가 있다.</p>\n<h2>6.1. AmbientLight</h2>\n<p>Ambient Light는 말 그대로 방향 같은 게 없이 scene에 전체적으로 적용되는 빛이다. 물체에 Light color를 곱해 주는 것 뿐이고 방향이나 어떤 물체에 더 비춰 준다는 개념이 없다.</p>\n<pre><code class=\"language-js\">const light = new THREE.AmbientLight(color, intensity);\n</code></pre>\n<h2>6.2. HemisphereLight</h2>\n<p>반구 형태의 광원이다. 천장과 바닥의 색을 인자로 받아서 천장을 바라보는 색은 천장 색, 바닥을 바라보는 색은 바닥 색으로 혼합한다.</p>\n<pre><code class=\"language-js\">const light = new THREE.HemisphereLight(천장색, 바닥색, intensity);\n</code></pre>\n<h2>6.3. DirectionalLight</h2>\n<p>직사광이다. 생성자는 빛 색상과 강도를 인자로 받으며 position과 target을 설정해야 한다.</p>\n<pre><code class=\"language-js\">const light = new THREE.DirectionalLight(color, intensity);\nlight.position.set(x, y, z);\nlight.target.position.set(x, y, z);\nscene.add(light);\n</code></pre>\n<p>그런데 조명이 충분히 강하지 않으면 조명이 눈에 잘 안 들어올 수도 있다. 이런 경우를 대비해서 <code>helper</code>를 사용할 수 있다. <code>helper</code>는 조명의 위치를 표시해 준다. <code>DirectionalLightHelper</code>를 사용하자.</p>\n<pre><code class=\"language-js\">// 여기서 light는 DirectionalLight 객체\nconst helper = new THREE.DirectionalLightHelper(light);\nscene.add(helper);\n</code></pre>\n<p>이 직사광은 한 점에서 뻗어나오는 게 아니다. 어떤 방향으로 빛이 비추는 것이다. 한 점에서 뻗어나오는 광원은 다음에 볼 PointLight이다.</p>\n<h2>6.4. PointLight</h2>\n<p>점 광원을 생성한다. 생성자는 빛 색상과 강도를 인자로 받으며 position을 설정해야 한다.</p>\n<pre><code class=\"language-js\">const light = new THREE.PointLight(color, intensity);\nlight.position.set(x, y, z);\n</code></pre>\n<h2>6.5. SpotLight</h2>\n<p>광원에서 원뿔 모양의 빛을 비추는 스포트라이트를 생성한다. 생성자는 빛 색상과 강도를 인자로 받으며 position, target, 각도, 빛의 범위를 설정해야 한다.</p>\n<pre><code class=\"language-js\">const light = new THREE.SpotLight(color, intensity);\n// 빛 경로 시각화 헬퍼\nconst helper = new THREE.SpotLightHelper(light);\nlight.position.set(x, y, z);\nlight.target.position.set(x, y, z);\n// 45도의 내각을 갖는 원뿔 모양 빛을 비춘다.\nlight.angle = Math.PI / 4;\n// 0이면 모든 부분에서 크기 동일. 1이면 외부로 갈수록 빛 희미해짐\nlight.penumbra = 0.05;\n</code></pre>\n<h2>6.6. RectAreaLight</h2>\n<p>사각 형태의 조명이며 <code>MeshStandardMaterial</code>과 <code>MeshPhysicalMaterial</code>에서만 사용할 수 있다. 생성자는 빛 색상과 강도를 인자로 받으며 width, height도 설정해야 한다.</p>\n<pre><code class=\"language-js\">const light = new THREE.RectAreaLight(color, intensity, width, height);\n</code></pre>\n<p><code>renderer.physicallyCorrectLights</code> 속성을 true로 설정해서 켜게 되면 조명을 물리적으로 보정할 수 있다. 일단 넘어가자.</p>\n<p><img src=\"/static/light-types-fda213e9.png\" alt=\"광원 종류\"></p>\n<h1>7. 카메라</h1>\n<p>이런 식으로 <code>PerspectiveCamera</code>를 생성할 수 있다.</p>\n<pre><code class=\"language-js\">const camera = new THREE.PerspectiveCamera( fov, aspect, near, far );\n</code></pre>\n<p>near, far를 설정하는 건 매우 중요하다. 만약 near를 매우 작게 그리고 far를 매우 크게 설정한다면 모든 물체가 다 보일 것이다. 하지만 이는 카메라의 정밀도에 영향을 미친다.</p>\n<p>정밀도는 near, far 사이에 어느 정도씩 퍼져 있는데 카메라에 가까울수록 정밀도가 높고 멀수록 낮아진다. 이럴 경우 z-fighting이라고 하는 현상이 발생해서 물체가 깨져 보이게 된다. <code>WebGLRenderer</code> 생성시 옵션으로 <code>logarithmicDepthBuffer</code>를 true로 설정하면 이 현상을 완화할 수 있다. 하지만 이는 일부 기기에서만 지원된다...</p>\n<p>따라서 near, far를 주의깊게 설정해야 한다.</p>\n<h2>7.1. OrthographicCamera</h2>\n<p>이는 정사영 카메라다. 원근 카메라의 잘린 사각뿔 모양 대신 직육면체 모양의 카메라다. 생성자는 left, right, top, bottom, near, far를 인자로 받는다.</p>\n<pre><code class=\"language-js\">const camera = new THREE.OrthographicCamera( left, right, top, bottom, near, far );\n</code></pre>\n<p>이 카메라는 받은 6개의 인자를 토대로 육면체를 만들고, 이 육면체 내의 물체들을 정사영해서 보여준다. 따라서 개체 크기가 카메라와의 거리에 관계없이 일정하게 유지된다.</p>\n<h1>8. 그림자</h1>\n<p>threeJS는 그림자 맵을 사용해서 그림자를 만든다. 이는 그림자를 만드는 모든 물체를 빛의 시점에서 렌더링함을 말한다. 따라서 그림자를 만드는 모든 물체들의 그림자 각각을 빛 각각이 한번씩 렌더링한다.</p>\n<p>만약 20개의 물체와 5개의 조명이 있고 20개 물체 모두가 그림자를 만든다면 한 장면을 위해서 화면은 6번 렌더링된다(물체를 만드는 1번, 그림자를 만드는 5번).</p>\n<p>따라서 그림자를 지게 하는 조명을 여러 개 만들기보다는 보통 다른 방법을 사용한다. 하나의 조명만 그림자를 지게 하거나 가짜 그림자를 만드는 등이다. 하지만 이는 나중에 알아보고, 그림자는 어떻게 사용하는가? renderer의 <code>shadowMap</code> 옵션을 켜고 조명도 그림자를 드리우도록 옵션을 켠다.</p>\n<pre><code class=\"language-js\">const scene = new THREE.Scene();\nconst renderer = new THREE.WebGLRenderer();\nrenderer.setSize( window.innerWidth, window.innerHeight );\n/* 렌더러가 그림자도 그리도록 함 */\nrenderer.shadowMap.enabled=true;\ndocument.body.appendChild( renderer.domElement );\n\n/* 카메라 세팅 */\nconst fov=45;\nconst aspect=2;\nconst near=0.1;\nconst far=100;\nconst camera = new THREE.PerspectiveCamera( fov, aspect, near, far );\ncamera.position.set(0,10,20);\n\nconst controls=new OrbitControls(camera,renderer.domElement);\ncontrols.target.set(0,5,0);\ncontrols.update();\n\nscene.background=new THREE.Color('black');\n\n/* 바닥 그리기 */\nconst planeSize=40;\nconst texture=new THREE.TextureLoader().load('./witch-new.png');\ntexture.wrapS=THREE.RepeatWrapping;\ntexture.wrapT=THREE.RepeatWrapping;\ntexture.magFilter=THREE.NearestFilter;\nconst repeats=planeSize/2;\ntexture.repeat.set(repeats,repeats);\n\nconst planeGeo=new THREE.PlaneGeometry(planeSize,planeSize);\nconst planeMat=new THREE.MeshPhongMaterial({\n  map:texture,\n  side:THREE.DoubleSide,\n});\n\nconst mesh=new THREE.Mesh(planeGeo,planeMat);\n/* 바닥은 그림자를 그리지는 않고 그림자의 영향만 받도록 한다. */\nmesh.receiveShadow=true;\nmesh.rotation.x=Math.PI*-.5;\nscene.add(mesh);\n/* 정육면체 그리기 */\nconst cubeSize=4;\nconst cubeGeo=new THREE.BoxGeometry(cubeSize,cubeSize,cubeSize);\nconst cubeMat=new THREE.MeshPhongMaterial({color:'#8AC'});\nconst mesh2=new THREE.Mesh(cubeGeo,cubeMat);\n/* 정육면체가 그림자를 만들도록 한다 */\nmesh2.castShadow=true;\n/* 정육면체에 그림자가 드리우도록 한다 */\nmesh2.receiveShadow=true;\nmesh2.position.set(cubeSize+1,cubeSize/2,0);\nscene.add(mesh2);\n\n/* 빛 만들기 */\nconst lightColor=0xFFFFFF;\nconst lightIntensity=1;\nconst light=new THREE.DirectionalLight(lightColor,lightIntensity);\n/* 빛이 그림자를 만들도록 한다 */\nlight.castShadow=true;\nlight.position.set(0,10,0);\nlight.target.position.set(-4,0,-4);\nscene.add(light);\nscene.add(light.target);\n</code></pre>\n<p>이렇게 하면 그림자 일부가 잘려 보이는데 이는 그림자용 카메라 범위 안에 있는 그림자만 렌더링하게 되기 때문이다. 이 그림자용 카메라는 위의 경우 <code>DirectionalLight</code>의 위치에 존재하며 해당 조명의 목표를 바라본다. 그리고 일정 공간 안의 그림자만 렌더링한다. 이 공간에 들어오지 않는 그림자가 잘려 나가는 것이다.</p>\n<h1>기타</h1>\n<p>안개를 그리기 <a href=\"https://threejs.org/manual/#ko/fog%5C\">https://threejs.org/manual/#ko/fog\\</a>\n커스텀 Geometry 만들기 <a href=\"https://threejs.org/manual/#ko/custom-buffergeometry\">https://threejs.org/manual/#ko/custom-buffergeometry</a></p>\n<h1>참고</h1>\n<p><a href=\"https://threejs.org/manual/#en/fundamentals\">https://threejs.org/manual/#en/fundamentals</a></p>\n<p><a href=\"https://threejs.org/manual/#ko/fundamentals\">https://threejs.org/manual/#ko/fundamentals</a></p>",
    "excerpt": "1. 시작\n기본적인 설치법은 공식 문서의 설치 가이드를 참고. 나는 이곳에서 Vite를 사용했다.\n기본 원리는 그래픽스에서 배운 것과 같다. Scene에 있는 물체를 Camera에서 보고, 카메라에 맺힌 영상을 Renderer가 화면에 렌더링한다. 만약에 이 글을 읽는 사람이 있고 내부 원리가 궁금하다면 그래픽스 과목을 들어보길 바란다. 서강대학교 임인성 교수님 연구실에서 좀 오래되긴 했어도 한글로 된 그래픽스 자료를 무료로 볼 수 있다.\nthree.js에서는 ",
    "headingTree": [
      {
        "title": "1. 시작",
        "url": "#1-시작",
        "items": []
      },
      {
        "title": "2. threejs 기본 구조",
        "url": "#2-threejs-기본-구조",
        "items": [
          {
            "title": "2.1. BoxGeometry",
            "url": "#21-boxgeometry",
            "items": []
          },
          {
            "title": "2.2. CircleGeometry",
            "url": "#22-circlegeometry",
            "items": []
          },
          {
            "title": "2.3. ConeGeometry",
            "url": "#23-conegeometry",
            "items": []
          },
          {
            "title": "2.4. CylinderGeometry",
            "url": "#24-cylindergeometry",
            "items": []
          },
          {
            "title": "2.5. DodecahedronGeometry",
            "url": "#25-dodecahedrongeometry",
            "items": []
          },
          {
            "title": "2.6. ExtrudeGeometry",
            "url": "#26-extrudegeometry",
            "items": []
          },
          {
            "title": "2.7. IcosahedronGeometry",
            "url": "#27-icosahedrongeometry",
            "items": []
          },
          {
            "title": "2.8. SphereGeometry",
            "url": "#28-spheregeometry",
            "items": []
          },
          {
            "title": "2.8. 기타 Geometry",
            "url": "#28-기타-geometry",
            "items": []
          }
        ]
      },
      {
        "title": "3. Scene graph",
        "url": "#3-scene-graph",
        "items": []
      },
      {
        "title": "4. Material",
        "url": "#4-material",
        "items": [
          {
            "title": "4.1. 유명한 옵션",
            "url": "#41-유명한-옵션",
            "items": []
          }
        ]
      },
      {
        "title": "5. 텍스처",
        "url": "#5-텍스처",
        "items": []
      },
      {
        "title": "6. 조명",
        "url": "#6-조명",
        "items": [
          {
            "title": "6.1. AmbientLight",
            "url": "#61-ambientlight",
            "items": []
          },
          {
            "title": "6.2. HemisphereLight",
            "url": "#62-hemispherelight",
            "items": []
          },
          {
            "title": "6.3. DirectionalLight",
            "url": "#63-directionallight",
            "items": []
          },
          {
            "title": "6.4. PointLight",
            "url": "#64-pointlight",
            "items": []
          },
          {
            "title": "6.5. SpotLight",
            "url": "#65-spotlight",
            "items": []
          },
          {
            "title": "6.6. RectAreaLight",
            "url": "#66-rectarealight",
            "items": []
          }
        ]
      },
      {
        "title": "7. 카메라",
        "url": "#7-카메라",
        "items": [
          {
            "title": "7.1. OrthographicCamera",
            "url": "#71-orthographiccamera",
            "items": []
          }
        ]
      },
      {
        "title": "8. 그림자",
        "url": "#8-그림자",
        "items": []
      },
      {
        "title": "기타",
        "url": "#기타",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 4,
      "wordCount": 958
    },
    "url": "/posts/threejs-1",
    "thumbnail": {
      "local": "/static/threejs-1cube-no-light-scene-8e10298b.svg",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-threejs-1cube-no-light-scene-8e10298b-svg",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAFCAYAAAB4ka1VAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsElEQVR4nAGlAFr/ANbA72bAstiVxLLYldLI+myPsfWGiqfokIan5o6PtP8/AK+vrwPN3/+mxNn/2qfF+c+81P/QzuL/3crf/zwAAAAAALCw/wPb9f/J2vb//7LR//3L5P/86////9zx/0gAAAAAAO2XlhXRy+SYzsvvsrHI9Z250+2wwNntvLLLy0eUzT8JAPCGhnDlfn208Hp8frbujiCdxYBsjbR5fZS6gnyn15Y8Ym9tAVU2fWEAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "todo",
    "title": "할 일과 유용한 것들",
    "date": "2023-01-01T00:00:00Z",
    "description": "언제 공부하지?",
    "tags": [
      "study"
    ],
    "html": "<p>프론트엔드 개발자 시작하기 <a href=\"https://developer.mozilla.org/ko/docs/Learn/Front-end_web_developer\">https://developer.mozilla.org/ko/docs/Learn/Front-end_web_developer</a></p>\n<h1>써야 할 글</h1>\n<p>aria 접근성 다루기</p>\n<p>aria Patterns 분석\n<a href=\"https://www.w3.org/WAI/ARIA/apg/patterns/\">https://www.w3.org/WAI/ARIA/apg/patterns/</a></p>\n<p><a href=\"https://ant.design/\">https://ant.design/</a> 같은 안 좋은 선례 분석과 함께 다른 디자인 시스템에서는 접근성을 어떻게 소화해냈는지에 대한 분석</p>\n<p><a href=\"https://react-spectrum.adobe.com/react-aria/\">https://react-spectrum.adobe.com/react-aria/</a></p>\n<p>2023년 8월에 시작된 기본기 다지기 계획</p>\n<h1>1. HTML</h1>\n<h2>1.1. HTML 기본</h2>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Learn/Getting_started_with_the_web/HTML_basics\">https://developer.mozilla.org/ko/docs/Learn/Getting_started_with_the_web/HTML_basics</a></p>\n<h2>1.2. HTML 소개 (~8/14)</h2>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Learn/HTML\">https://developer.mozilla.org/ko/docs/Learn/HTML</a> 여기를 참고해서 작성.</p>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Learn/HTML/Introduction_to_HTML\">https://developer.mozilla.org/ko/docs/Learn/HTML/Introduction_to_HTML</a></p>\n<h3>HTML 시작하기</h3>\n<h3>head 안에는 무엇이 있나? HTML 메타 데이터</h3>\n<h3>HTML 텍스트 기본</h3>\n<h3>하이퍼링크 만들기</h3>\n<h3>텍스트 조작 고급기법</h3>\n<h3>문서와 웹사이트 구조</h3>\n<h3>HTML 디버깅</h3>\n<h2>1.3. 멀티미디어와 임베딩 (~8/14)</h2>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Learn/HTML/Multimedia_and_embedding\">https://developer.mozilla.org/ko/docs/Learn/HTML/Multimedia_and_embedding</a></p>\n<h3>HTML 이미지</h3>\n<h3>비디오와 오디오 컨텐츠</h3>\n<h3><object> 로부터 <iframe>까지 — 기타 임베딩 기술</iframe>\n<h3>Vector graphics 웹에 추가하기 (en-US)</h3>\n<h3>반응형 이미지</h3>\n<h2>1.4. HTML 테이블 (~8/14)</h2>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Learn/HTML/Tables\">https://developer.mozilla.org/ko/docs/Learn/HTML/Tables</a></p>\n<h3>HTML 테이블 기본</h3>\n<h3>HTML 테이블 고급 기능 및 접근성</h3>\n<h2>1.5. HTML 폼 가이드 (~8/16)</h2>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Learn/Forms\">https://developer.mozilla.org/en-US/docs/Learn/Forms</a></p>\n<p>HTML의 폼 검증에 대한 글 쓰기</p>\n<h3>첫 HTML 폼</h3>\n<h3>HTML 폼 구조화</h3>\n<h3>Basic native form controls</h3>\n<h3>HTML5 input types</h3>\n<h3>Other form controls</h3>\n<h3>Styling web forms</h3>\n<h3>Advanced form styling</h3>\n<h3>UI pseudo-classes</h3>\n<h3>Client-side form validation</h3>\n<h3>Sending form data</h3>\n<h3>How to build custom form controls</h3>\n<h3>Sending forms through JavaScript</h3>\n<h3>CSS property compatibility table for form controls</h3>\n<h1>3. Javascript</h1>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Learn/JavaScript\">https://developer.mozilla.org/ko/docs/Learn/JavaScript</a></p>\n<h2>3.1. Javascript 첫걸음(~8/17)</h2>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Learn/JavaScript/First_steps\">https://developer.mozilla.org/ko/docs/Learn/JavaScript/First_steps</a></p>\n<h3>JavaScript가 뭔가요?</h3>\n<h3>JavaScript에 발 담그기</h3>\n<h3>뭐가 잘못됐을까요? JavaScript 문제 해결</h3>\n<h3>필요한 정보를 저장하기-변수</h3>\n<h3>JavaScript의 기본적인 연산 - 숫자와 연산자</h3>\n<h3>문자열 다루기 — 문자열</h3>\n<h3>문자열 제대로 다루기</h3>\n<h3>배열(Arrays)</h3>\n<h3>Silly story generator</h3>\n<h2>3.2. Javascript 구성요소(~8/19)</h2>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Learn/JavaScript/Building_blocks\">https://developer.mozilla.org/ko/docs/Learn/JavaScript/Building_blocks</a></p>\n<h3>판단 내리기 - 조건문</h3>\n<h3>반복문</h3>\n<h3>함수 - 코드 재사용</h3>\n<h3>함수 만들기</h3>\n<h3>함수 반환값</h3>\n<h3>이벤트 입문</h3>\n<h2>3.3. Javascript 객체(~8/21)</h2>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Learn/JavaScript/Objects\">https://developer.mozilla.org/ko/docs/Learn/JavaScript/Objects</a></p>\n<h3>JavaScript 객체 기본</h3>\n<h3>Object prototypes</h3>\n<h3>Object-oriented programming</h3>\n<h3>Classes in JavaScript</h3>\n<h3>JSON으로 작업하기</h3>\n<h3>Object building practice</h3>\n<h3>Adding features to our bouncing balls demo</h3>\n<h2>3.4. Javascript 비동기성(~8/26)</h2>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Learn/JavaScript/Asynchronous\">https://developer.mozilla.org/ko/docs/Learn/JavaScript/Asynchronous</a></p>\n<h3>Introducing asynchronous JavaScript</h3>\n<h3>How to use promises</h3>\n<h3>Implementing a promise-based API</h3>\n<p>현재 여기까지 와 있다. 중간에 Nextjs, 리액트 난입</p>\n<h1>Nextjs 13 공식 문서 보기 - 1회독</h1>\n<ul>\n<li>Routing (~9/4)</li>\n<li>Data fetching (~9/4)</li>\n<li>Rendering (~9/4)</li>\n<li>Caching (~9/4)</li>\n<li>Styling (~9/5)</li>\n<li>Optimizing(~9/5)</li>\n<li>Configuring(~9/6)</li>\n<li>Deploying(~9/6)</li>\n<li>Upgrading(~9/7)</li>\n<li>API Reference - Components(~9/7)</li>\n<li>API Reference - File Conventions(~9/8)</li>\n<li>API Reference - Functions(~9/9)</li>\n<li>next.config.js options(~9/11)</li>\n<li>create-next-app, Edge Runtime(~9/12)</li>\n<li>next.js CLI(~9/13)</li>\n</ul>\n<p>추후 2회독 하면서 블로그에 조금씩 정리할 예정</p>\n<p>블로그 마이그레이션 천천히..</p>\n<h1>리액트 공식문서</h1>\n<h2>Describing the UI(~9/15)</h2>\n<h2>Adding interactivity(~9/16)</h2>\n<h2>Managing State(~9/19)</h2>\n<h2>Escape Hatches(~9/21)</h2>\n<h3>Introducing asynchronous Workers</h3>\n<h3>Sequencing asynchronous operations</h3>\n<h2>3.5. 클라이언트 사이드 Web API(~8/30)</h2>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Learn/JavaScript/Client-side_web_APIs\">https://developer.mozilla.org/ko/docs/Learn/JavaScript/Client-side_web_APIs</a></p>\n<h3>Introduction to web APIs (en-US)</h3>\n<h3>Manipulating documents (en-US)</h3>\n<h3>Fetching data from the server (en-US)</h3>\n<h3>Third party APIs (en-US)</h3>\n<h3>Drawing graphics (en-US)</h3>\n<h3>Video and audio APIs (en-US)</h3>\n<h3>Client-side storage</h3>\n<h2>JS 안내서</h2>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Introduction\">https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Introduction</a></p>\n<h2>3.6. Javascript 중고급 주제들(~9/6)</h2>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript\">https://developer.mozilla.org/ko/docs/Web/JavaScript</a></p>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript#%EC%A4%91%EA%B8%89\">https://developer.mozilla.org/ko/docs/Web/JavaScript#%EC%A4%91%EA%B8%89</a></p>\n<p>물론 <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript#%EC%B0%B8%EA%B3%A0%EC%84%9C\">참고서 섹션</a>에도 볼만한 게 많다.</p>\n<h3>JavaScript 데이터 구조</h3>\n<h3>동등성 비교 및 동일성</h3>\n<h3>속성의 열거 가능성과 소유권</h3>\n<h3>클로저</h3>\n<h3>상속과 프로토타입 체인</h3>\n<h3>JavaScript 형식화 배열</h3>\n<h3>메모리 관리</h3>\n<h3>Concurrency model and Event Loop</h3>\n<h2>3.7. AJAX(~9/10)</h2>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/Guide/AJAX\">https://developer.mozilla.org/en-US/docs/Web/Guide/AJAX</a></p>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/Guide/AJAX\">https://developer.mozilla.org/ko/docs/Web/Guide/AJAX</a></p>\n<h1>4. 접근성(~9/20)</h1>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Learn/Accessibility\">https://developer.mozilla.org/ko/docs/Learn/Accessibility</a></p>\n<h2>4.1. 접근성 소개</h2>\n<h3>접근성이란?</h3>\n<h3>HTML : 접근성의 좋은 기반</h3>\n<h3>CSS 와 JavaScript의 접근성 모범 사례 (en-US)</h3>\n<h3>WAI-ARIA 기초 (en-US)</h3>\n<h3>멀티미디어 접근성 (en-US)</h3>\n<h3>모바일 접근성</h3>\n<h3>접근성 트러블슈팅</h3>\n<h1>8. 웹 보안</h1>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/Security\">https://developer.mozilla.org/ko/docs/Web/Security</a></p>\n<h2>8.1. 콘텐츠 보안(~9/29)</h2>\n<h3>콘텐츠 보안 정책(CSP)</h3>\n<h2>8.2. 연결 보안(~10/5)</h2>\n<h3>전송 계층 보안(TLS)</h3>\n<h3>HTTPS</h3>\n<h3>HTTP Strict-Transport-Security</h3>\n<h3>인증서 투명성</h3>\n<h3>혼합 콘텐츠</h3>\n<h3>혼합 콘텐츠가 차단된 웹사이트를 고치는 방법 (en-US)</h3>\n<h3>보안 컨텍스트</h3>\n<h3>보안 컨텍스트로 제한된 기능</h3>\n<h3>Weak signature algorithms (en-US)</h3>\n<h2>8.3. 데이터 보안(~10/10)</h2>\n<h3>HTTP 쿠키 사용</h3>\n<h3>로컬 스토리지</h3>\n<h2>8.4. 정보 유출(~10/13)</h2>\n<h3>리퍼러 헤더 정책: 개인 정보 보호 및 보안 문제 (en-US)</h3>\n<h3>자격 증명 없는 IFrame (en-US)</h3>\n<h2>8.5. 무결성(~10/15)</h2>\n<h3>동일 출처 정책</h3>\n<h3>하위 리소스 무결성 (en-US)</h3>\n<h3>HTTP Access-Control-Allow-Origin</h3>\n<h3>HTTP X-Content-Type-Options (en-US)</h3>\n<h2>8.6. 클릭재킹 보호(~10/18)</h2>\n<h3>HTTP X-Frame-Options</h3>\n<h3>CSP: frame-ancestors (en-US)</h3>\n<h2>8.7. 사용자 정보 보안(~10/21)</h2>\n<h3>안전하지 않은 비밀번호</h3>\n<h3>개인 정보 및 :visited 선택자 (en-US)</h3>\n<h1>9. HTTP</h1>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/HTTP\">https://developer.mozilla.org/ko/docs/Web/HTTP</a></p>\n<h2>9.1. HTTP 기본(~10/25)</h2>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/HTTP/Basics_of_HTTP\">https://developer.mozilla.org/ko/docs/Web/HTTP/Basics_of_HTTP</a></p>\n<h3>HTTP 개요</h3>\n<h3>HTTP의 진화</h3>\n<h3>HTTP 버전 협상</h3>\n<h3>HTTP 메시지</h3>\n<h3>전형적인 HTTP 세션</h3>\n<h3>HTTP/1.x 연결관리</h3>\n<h3>프로토콜 업그레이드 메커니즘</h3>\n<h2>9.2. 리소스와 URIs(~10/27)</h2>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/HTTP/Basics_of_HTTP/Identifying_resources_on_the_Web\">https://developer.mozilla.org/ko/docs/Web/HTTP/Basics_of_HTTP/Identifying_resources_on_the_Web</a></p>\n<h3>웹의 리소스 식별하기</h3>\n<h3>데이터 URL</h3>\n<h3>MIME 타입 소개</h3>\n<h3>www와 non-www URL</h3>\n<h2>9.3. HTTP 보안(~10/30)</h2>\n<h3>콘텐츠 보안 정책(CSP)</h3>\n<h3>HTTP strict transport security</h3>\n<h3>Cookie security</h3>\n<h3>X-Content-Type-Options</h3>\n<h3>X-Frame-Options</h3>\n<h3>X-XSS-Protection</h3>\n<h3>HTTP Public Key Pinning</h3>\n<h3>Mozilla Observatory</h3>\n<p>사이트 보안 등을 체크할 수 있는 듯</p>\n<p><a href=\"https://observatory.mozilla.org/\">https://observatory.mozilla.org/</a></p>\n<h2>9.4. 기타 이슈(~11/2)</h2>\n<h3>HTTP 접근제어(CORS)</h3>\n<h3>HTTP 인증</h3>\n<h3>HTTP 캐싱</h3>\n<h3>HTTP 압축</h3>\n<h3>HTTP 조건부 요청</h3>\n<h3>HTTP 컨텐츠 협상</h3>\n<h3>HTTP 쿠키</h3>\n<h3>HTTP range 요청</h3>\n<h3>HTTP 리다이렉트</h3>\n<h3>HTTP 명세</h3>\n<h3>Permissions policy</h3>\n<h1>5. 웹 퍼포먼스</h1>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Learn/Performance\">https://developer.mozilla.org/en-US/docs/Learn/Performance</a></p>\n<h2>5.1. 웹 퍼포먼스 소개</h2>\n<h3>The \"why\" of web performance</h3>\n<h3>What is web performance?</h3>\n<h3>How do users perceive performance?</h3>\n<h3>Measuring performance</h3>\n<h3>Multimedia: images</h3>\n<h3>Multimedia: video</h3>\n<h3>JavaScript performance optimization</h3>\n<h3>HTML performance optimization</h3>\n<h3>CSS performance optimization</h3>\n<h3>The business case for web performance</h3>\n<h1>참고할 만한 블로그</h1>\n<p>비사이드소프트의 글들 <a href=\"https://www.bsidesoft.com/\">https://www.bsidesoft.com/</a></p>\n<p>김민지 님의 블로그 <a href=\"https://mnxmnz.github.io/\">https://mnxmnz.github.io/</a></p>\n<p>김용찬 님의 블로그 <a href=\"https://yceffort.kr/\">https://yceffort.kr/</a></p>\n<p>안도형 님의 블로그 <a href=\"https://www.rinae.dev/\">https://www.rinae.dev/</a></p>\n<p>여러 번역 글이 있다 <a href=\"https://www.rinae.dev/posts/a-complete-guide-to-useeffect-ko\">https://www.rinae.dev/posts/a-complete-guide-to-useeffect-ko</a></p>\n<p>정인교 님의 블로그 <a href=\"https://ingg.dev/\">https://ingg.dev/</a></p>\n<h1>Javascript</h1>\n<h2>JS 동작 원리</h2>\n<p>참고 <a href=\"https://velog.io/@wish/JavaScript%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%90%A0%EA%B9%8C\">https://velog.io/@wish/JavaScript%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%90%A0%EA%B9%8C</a></p>\n<h2>JS Worker에 관하여</h2>\n<h2>fetch API에 쓰이는 Request, Response 객체</h2>\n<h2>Promise를 받을 때 등에 쓰이는 blob이란 무엇인가?</h2>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Response/blob\">https://developer.mozilla.org/en-US/docs/Web/API/Response/blob</a></p>\n<h2>AJAX 에 대해</h2>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/Guide/AJAX/Getting_Started\">https://developer.mozilla.org/en-US/docs/Web/Guide/AJAX/Getting_Started</a></p>\n<h2>WebGL</h2>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Getting_started_with_WebGL\">https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Getting_started_with_WebGL</a></p>\n<h2>HTTP</h2>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/HTTP\">https://developer.mozilla.org/ko/docs/Web/HTTP</a></p>\n<h2>웹브라우저에 대하여</h2>\n<p>웹브라우저 주소창에 google.com 쓰고 엔터를 누르면 무슨 일이 일어나는지, 각 과정에서 개발자는 어떻게 개입할 수 있는지 5분간 설명해보세요.</p>\n<h2>Intersection Observer API</h2>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/API/Intersection_Observer_API\">https://developer.mozilla.org/ko/docs/Web/API/Intersection_Observer_API</a></p>\n<h2>window, navigator 등 몇몇 전역 객체에 대해</h2>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window\">https://developer.mozilla.org/en-US/docs/Web/API/Window</a></p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Navigator\">https://developer.mozilla.org/en-US/docs/Web/API/Navigator</a></p>\n<h2>call, apply 등으로 this 조작</h2>\n<h2><code>==</code> 등으로 비교하는 로직</h2>\n<h2>호이스팅, 실행 컨텍스트, 클로저 etc.</h2>\n<h2>이터레이션 프로토콜</h2>\n<h2>strict mode</h2>\n<h2>Map, Object diff</h2>\n<h2>DOM</h2>\n<h2>JS 가비지 컬렉터</h2>\n<h2>JS Error 객체</h2>\n<h2>제네릭 T 타입으로 객체 초기화하기</h2>\n<p><a href=\"https://stackoverflow.com/questions/71358061/generic-useform-hook\">https://stackoverflow.com/questions/71358061/generic-useform-hook</a></p>\n<h1>React</h1>\n<h2>useState의 작동 원리</h2>\n<h2>리액트 커스텀 훅</h2>\n<h2>useEffect 원리</h2>\n<h1>기타</h1>\n<h2>rem, px, vw의 차이와 언제 써야 하는지</h2>\n<h2>react-query 탐구 이어쓰기</h2>\n<h2>운영체제 7단원 식사하는 철학자들 문제, 8단원 데드락</h2>\n<h1>6. 도구와 테스팅</h1>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing\">https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing</a></p>\n<h2>6.1. 클라이언트 사이드 웹 개발 도구</h2>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Understanding_client-side_tools\">https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Understanding_client-side_tools</a></p>\n<h3>Client-side tooling overview</h3>\n<h3>Command line crash course</h3>\n<h3>Package management basics</h3>\n<h3>Introducing a complete toolchain</h3>\n<h3>Deploying our app</h3>\n<h2>6.2. 클라이언트 사이드 프레임워크 소개</h2>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Introduction\">https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Introduction</a></p>\n<p>React, Ember, Vue, Svelte 등등. 생략</p>\n<h2>6.3. 크로스 브라우저 테스팅</h2>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Cross_browser_testing\">https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Cross_browser_testing</a></p>\n<h3>Introduction to cross browser testing</h3>\n<h3>Strategies for carrying out testing</h3>\n<h3>Handling common HTML and CSS problems</h3>\n<h3>Handling common JavaScript problems</h3>\n<h3>Handling common accessibility problems</h3>\n<h3>Introduction to automated testing</h3>\n<h3>Setting up your own test automation environment</h3>\n<h1>7. 서버사이드 웹사이트 프로그래밍</h1>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Learn/Server-side\">https://developer.mozilla.org/en-US/docs/Learn/Server-side</a></p>\n<h2>7.1. 첫걸음</h2>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Learn/Server-side/First_steps\">https://developer.mozilla.org/en-US/docs/Learn/Server-side/First_steps</a></p>\n<h3>Introduction to the server side</h3>\n<h3>Client-Server overview</h3>\n<h3>Server-side web frameworks</h3>\n<h3>Website security</h3>\n<h2>7.2. Django</h2>\n<p>생략</p>\n<h2>7.3. Express web framework</h2>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Learn/Server-side/Express_Nodejs\">https://developer.mozilla.org/en-US/docs/Learn/Server-side/Express_Nodejs</a></p>\n<h1>10. 프로그레시브 웹 앱</h1>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps\">https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps</a></p>\n<h1>CSS</h1>\n<p>웹 개발자 안내서의 CSS 부분 구조</p>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/Guide\">https://developer.mozilla.org/ko/docs/Web/Guide</a></p>\n<h2>2.1. CSS 첫번째 단계</h2>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Learn/CSS\">https://developer.mozilla.org/ko/docs/Learn/CSS</a> 에서 발췌</p>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Learn/CSS/First_steps\">https://developer.mozilla.org/ko/docs/Learn/CSS/First_steps</a></p>\n<h3>CSS란 무엇인가?</h3>\n<h3>CSS 시작하기</h3>\n<h3>CSS 구조</h3>\n<h3>CSS 작동 방식</h3>\n<h2>2.2. CSS 구성요소</h2>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Learn/CSS/Building_blocks\">https://developer.mozilla.org/ko/docs/Learn/CSS/Building_blocks</a></p>\n<h3>CSS 선택자</h3>\n<h3>Type, class and ID selectors</h3>\n<h3>Attribute selectors</h3>\n<h3>Pseudo-classes and pseudo-elements</h3>\n<h3>combinators</h3>\n<h3>계단식 및 상속</h3>\n<h3>cascade layers</h3>\n<h3>박스 모델</h3>\n<h3>배경 및 테두리</h3>\n<h3>텍스트 표시 방향 제어하기</h3>\n<h3>콘텐츠 오버플로우</h3>\n<h3>CSS 값과 단위</h3>\n<h3>CSS에서 항목 크기 조정</h3>\n<h3>이미지, 미디어 및 양식 요소</h3>\n<h3>표 스타일링</h3>\n<h3>CSS 디버깅</h3>\n<h3>CSS 구성</h3>\n<h3>기본적인 CSS 이해</h3>\n<h3>편지지 만들기</h3>\n<h3>A cool looking box</h3>\n<h2>2.3. 텍스트 스타일링</h2>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Learn/CSS/Styling_text\">https://developer.mozilla.org/ko/docs/Learn/CSS/Styling_text</a></p>\n<h3>기본적인 텍스트 및 글꼴 스타일</h3>\n<h3>목록 스타일링</h3>\n<h3>링크 스타일링</h3>\n<h3>웹 글꼴</h3>\n<h2>2.4. CSS 레이아웃</h2>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Learn/CSS/CSS_layout\">https://developer.mozilla.org/ko/docs/Learn/CSS/CSS_layout</a></p>\n<h3>CSS 레이아웃 입문서</h3>\n<h3>일반 대열(normal flow)</h3>\n<h3>Flexbox</h3>\n<h3>Grids</h3>\n<h3>Floats(부동체)</h3>\n<h3>Positioning</h3>\n<h3>Multiple-column Layout</h3>\n<h3>Responsive design</h3>\n<h3>미디어 쿼리 안내서</h3>\n<h3>레거시 레이아웃 메서드</h3>\n<h3>이전 브라우저 지원</h3>\n<h2>2.5. CSS 핵심 개념</h2>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/CSS\">https://developer.mozilla.org/ko/docs/Web/CSS</a> 이곳의 <code>참고서</code>에서.</p>\n<h3>언어 구문과 형태</h3>\n<h3>명시도</h3>\n<h3>상속</h3>\n<h3>종속</h3>\n<h3>CSS 값과 단위</h3>\n<h3>CSS 함수 표기법</h3>\n<h3>박스 모델</h3>\n<h3>여백 상쇄</h3>\n<h3>컨테이닝 블록</h3>\n<h3>쌓임 맥락, 블록 서식 맥락</h3>\n<h3>초기값, 계산값, 사용값, 실제값</h3>\n<h3>CSS shortcut</h3>\n<h3>CSS flexbox</h3>\n<h3>CSS grid</h3>\n<h3>CSS 선택자</h3>\n<h3>미디어쿼리</h3>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/CSS/CSS_media_queries\">https://developer.mozilla.org/ko/docs/Web/CSS/CSS_media_queries</a></p>\n<h3>CSS 애니메이션</h3>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/CSS/animation\">https://developer.mozilla.org/ko/docs/Web/CSS/animation</a></p>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/CSS/CSS_animations/Using_CSS_animations\">https://developer.mozilla.org/ko/docs/Web/CSS/CSS_animations/Using_CSS_animations</a></p>\n<h2>2.6. CSS 고급</h2>\n<p>CSS 레이아웃에 관한 글 모음</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/CSS_Layout\">https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/CSS_Layout</a></p>\n<h1>개발자 가이드</h1>\n<p>모질라에선 수많은 가이드를 제공하고 있다.</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/Guide/Audio_and_video_delivery\">https://developer.mozilla.org/en-US/docs/Web/Guide/Audio_and_video_delivery</a></p>\n<p>레퍼런스에 있는 수많은 항목들도 언젠가 봐야지..</p>\n<h1>11. 디자인 패턴</h1>\n<p><a href=\"https://patterns-dev-kr.github.io/\">https://patterns-dev-kr.github.io/</a></p>\n<h1>기타</h1>\n<p>다양한 학습서와 교육 자료가 있는 학습서 <a href=\"https://developer.mozilla.org/ko/docs/Web/Tutorials\">https://developer.mozilla.org/ko/docs/Web/Tutorials</a></p>\n<p>HTTP부터 합시다</p>\n<h2>1.6. 고급 주제 (~8/18)</h2>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/HTML\">https://developer.mozilla.org/ko/docs/Web/HTML</a> 참고</p>\n<h3>HTML 참고서</h3>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/HTML/Reference\">https://developer.mozilla.org/ko/docs/Web/HTML/Reference</a></p>\n<h3>CORS 활성화 이미지</h3>\n<h3>CORS 설정 특성</h3>\n<h3>rel=\"preload\"로 콘텐츠 미리 불러오기</h3>\n<h2>1.7. 기타 (보류)</h2>\n<h3>콘텐츠 카테고리</h3>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/HTML/Content_categories\">https://developer.mozilla.org/ko/docs/Web/HTML/Content_categories</a></p>\n<p>다른 여러 주제들은 왼쪽 사이드바의 <code>안내서</code>참고</p>\n<h3>호환성 모드와 표준 모드</h3></object></h3>",
    "excerpt": "프론트엔드 개발자 시작하기 https://developer.mozilla.org/ko/docs/Learn/Front-end_web_developer\n써야 할 글\naria 접근성 다루기\naria Patterns 분석\nhttps://www.w3.org/WAI/ARIA/apg/patterns/\nhttps://ant.design/ 같은 안 좋은 선례 분석과 함께 다른 디자인 시스템에서는 접근성을 어떻게 소화해냈는지에 대한 분석\nhttps://react-spectrum.",
    "headingTree": [
      {
        "title": "써야 할 글",
        "url": "#써야-할-글",
        "items": []
      },
      {
        "title": "1. HTML",
        "url": "#1-html",
        "items": [
          {
            "title": "1.1. HTML 기본",
            "url": "#11-html-기본",
            "items": []
          },
          {
            "title": "1.2. HTML 소개 (~8/14)",
            "url": "#12-html-소개-814",
            "items": [
              {
                "title": "HTML 시작하기",
                "url": "#html-시작하기",
                "items": []
              },
              {
                "title": "head 안에는 무엇이 있나? HTML 메타 데이터",
                "url": "#head-안에는-무엇이-있나-html-메타-데이터",
                "items": []
              },
              {
                "title": "HTML 텍스트 기본",
                "url": "#html-텍스트-기본",
                "items": []
              },
              {
                "title": "하이퍼링크 만들기",
                "url": "#하이퍼링크-만들기",
                "items": []
              },
              {
                "title": "텍스트 조작 고급기법",
                "url": "#텍스트-조작-고급기법",
                "items": []
              },
              {
                "title": "문서와 웹사이트 구조",
                "url": "#문서와-웹사이트-구조",
                "items": []
              },
              {
                "title": "HTML 디버깅",
                "url": "#html-디버깅",
                "items": []
              }
            ]
          },
          {
            "title": "1.3. 멀티미디어와 임베딩 (~8/14)",
            "url": "#13-멀티미디어와-임베딩-814",
            "items": [
              {
                "title": "HTML 이미지",
                "url": "#html-이미지",
                "items": []
              },
              {
                "title": "비디오와 오디오 컨텐츠",
                "url": "#비디오와-오디오-컨텐츠",
                "items": []
              },
              {
                "title": " 로부터 까지 — 기타 임베딩 기술",
                "url": "#object-로부터-iframe까지--기타-임베딩-기술",
                "items": []
              },
              {
                "title": "Vector graphics 웹에 추가하기 (en-US)",
                "url": "#vector-graphics-웹에-추가하기-en-us",
                "items": []
              },
              {
                "title": "반응형 이미지",
                "url": "#반응형-이미지",
                "items": []
              }
            ]
          },
          {
            "title": "1.4. HTML 테이블 (~8/14)",
            "url": "#14-html-테이블-814",
            "items": [
              {
                "title": "HTML 테이블 기본",
                "url": "#html-테이블-기본",
                "items": []
              },
              {
                "title": "HTML 테이블 고급 기능 및 접근성",
                "url": "#html-테이블-고급-기능-및-접근성",
                "items": []
              }
            ]
          },
          {
            "title": "1.5. HTML 폼 가이드 (~8/16)",
            "url": "#15-html-폼-가이드-816",
            "items": [
              {
                "title": "첫 HTML 폼",
                "url": "#첫-html-폼",
                "items": []
              },
              {
                "title": "HTML 폼 구조화",
                "url": "#html-폼-구조화",
                "items": []
              },
              {
                "title": "Basic native form controls",
                "url": "#basic-native-form-controls",
                "items": []
              },
              {
                "title": "HTML5 input types",
                "url": "#html5-input-types",
                "items": []
              },
              {
                "title": "Other form controls",
                "url": "#other-form-controls",
                "items": []
              },
              {
                "title": "Styling web forms",
                "url": "#styling-web-forms",
                "items": []
              },
              {
                "title": "Advanced form styling",
                "url": "#advanced-form-styling",
                "items": []
              },
              {
                "title": "UI pseudo-classes",
                "url": "#ui-pseudo-classes",
                "items": []
              },
              {
                "title": "Client-side form validation",
                "url": "#client-side-form-validation",
                "items": []
              },
              {
                "title": "Sending form data",
                "url": "#sending-form-data",
                "items": []
              },
              {
                "title": "How to build custom form controls",
                "url": "#how-to-build-custom-form-controls",
                "items": []
              },
              {
                "title": "Sending forms through JavaScript",
                "url": "#sending-forms-through-javascript",
                "items": []
              },
              {
                "title": "CSS property compatibility table for form controls",
                "url": "#css-property-compatibility-table-for-form-controls",
                "items": []
              }
            ]
          }
        ]
      },
      {
        "title": "3. Javascript",
        "url": "#3-javascript",
        "items": [
          {
            "title": "3.1. Javascript 첫걸음(~8/17)",
            "url": "#31-javascript-첫걸음817",
            "items": [
              {
                "title": "JavaScript가 뭔가요?",
                "url": "#javascript가-뭔가요",
                "items": []
              },
              {
                "title": "JavaScript에 발 담그기",
                "url": "#javascript에-발-담그기",
                "items": []
              },
              {
                "title": "뭐가 잘못됐을까요? JavaScript 문제 해결",
                "url": "#뭐가-잘못됐을까요-javascript-문제-해결",
                "items": []
              },
              {
                "title": "필요한 정보를 저장하기-변수",
                "url": "#필요한-정보를-저장하기-변수",
                "items": []
              },
              {
                "title": "JavaScript의 기본적인 연산 - 숫자와 연산자",
                "url": "#javascript의-기본적인-연산---숫자와-연산자",
                "items": []
              },
              {
                "title": "문자열 다루기 — 문자열",
                "url": "#문자열-다루기--문자열",
                "items": []
              },
              {
                "title": "문자열 제대로 다루기",
                "url": "#문자열-제대로-다루기",
                "items": []
              },
              {
                "title": "배열(Arrays)",
                "url": "#배열arrays",
                "items": []
              },
              {
                "title": "Silly story generator",
                "url": "#silly-story-generator",
                "items": []
              }
            ]
          },
          {
            "title": "3.2. Javascript 구성요소(~8/19)",
            "url": "#32-javascript-구성요소819",
            "items": [
              {
                "title": "판단 내리기 - 조건문",
                "url": "#판단-내리기---조건문",
                "items": []
              },
              {
                "title": "반복문",
                "url": "#반복문",
                "items": []
              },
              {
                "title": "함수 - 코드 재사용",
                "url": "#함수---코드-재사용",
                "items": []
              },
              {
                "title": "함수 만들기",
                "url": "#함수-만들기",
                "items": []
              },
              {
                "title": "함수 반환값",
                "url": "#함수-반환값",
                "items": []
              },
              {
                "title": "이벤트 입문",
                "url": "#이벤트-입문",
                "items": []
              }
            ]
          },
          {
            "title": "3.3. Javascript 객체(~8/21)",
            "url": "#33-javascript-객체821",
            "items": [
              {
                "title": "JavaScript 객체 기본",
                "url": "#javascript-객체-기본",
                "items": []
              },
              {
                "title": "Object prototypes",
                "url": "#object-prototypes",
                "items": []
              },
              {
                "title": "Object-oriented programming",
                "url": "#object-oriented-programming",
                "items": []
              },
              {
                "title": "Classes in JavaScript",
                "url": "#classes-in-javascript",
                "items": []
              },
              {
                "title": "JSON으로 작업하기",
                "url": "#json으로-작업하기",
                "items": []
              },
              {
                "title": "Object building practice",
                "url": "#object-building-practice",
                "items": []
              },
              {
                "title": "Adding features to our bouncing balls demo",
                "url": "#adding-features-to-our-bouncing-balls-demo",
                "items": []
              }
            ]
          },
          {
            "title": "3.4. Javascript 비동기성(~8/26)",
            "url": "#34-javascript-비동기성826",
            "items": [
              {
                "title": "Introducing asynchronous JavaScript",
                "url": "#introducing-asynchronous-javascript",
                "items": []
              },
              {
                "title": "How to use promises",
                "url": "#how-to-use-promises",
                "items": []
              },
              {
                "title": "Implementing a promise-based API",
                "url": "#implementing-a-promise-based-api",
                "items": []
              }
            ]
          }
        ]
      },
      {
        "title": "Nextjs 13 공식 문서 보기 - 1회독",
        "url": "#nextjs-13-공식-문서-보기---1회독",
        "items": []
      },
      {
        "title": "리액트 공식문서",
        "url": "#리액트-공식문서",
        "items": [
          {
            "title": "Describing the UI(~9/15)",
            "url": "#describing-the-ui915",
            "items": []
          },
          {
            "title": "Adding interactivity(~9/16)",
            "url": "#adding-interactivity916",
            "items": []
          },
          {
            "title": "Managing State(~9/19)",
            "url": "#managing-state919",
            "items": []
          },
          {
            "title": "Escape Hatches(~9/21)",
            "url": "#escape-hatches921",
            "items": [
              {
                "title": "Introducing asynchronous Workers",
                "url": "#introducing-asynchronous-workers",
                "items": []
              },
              {
                "title": "Sequencing asynchronous operations",
                "url": "#sequencing-asynchronous-operations",
                "items": []
              }
            ]
          },
          {
            "title": "3.5. 클라이언트 사이드 Web API(~8/30)",
            "url": "#35-클라이언트-사이드-web-api830",
            "items": [
              {
                "title": "Introduction to web APIs (en-US)",
                "url": "#introduction-to-web-apis-en-us",
                "items": []
              },
              {
                "title": "Manipulating documents (en-US)",
                "url": "#manipulating-documents-en-us",
                "items": []
              },
              {
                "title": "Fetching data from the server (en-US)",
                "url": "#fetching-data-from-the-server-en-us",
                "items": []
              },
              {
                "title": "Third party APIs (en-US)",
                "url": "#third-party-apis-en-us",
                "items": []
              },
              {
                "title": "Drawing graphics (en-US)",
                "url": "#drawing-graphics-en-us",
                "items": []
              },
              {
                "title": "Video and audio APIs (en-US)",
                "url": "#video-and-audio-apis-en-us",
                "items": []
              },
              {
                "title": "Client-side storage",
                "url": "#client-side-storage",
                "items": []
              }
            ]
          },
          {
            "title": "JS 안내서",
            "url": "#js-안내서",
            "items": []
          },
          {
            "title": "3.6. Javascript 중고급 주제들(~9/6)",
            "url": "#36-javascript-중고급-주제들96",
            "items": [
              {
                "title": "JavaScript 데이터 구조",
                "url": "#javascript-데이터-구조",
                "items": []
              },
              {
                "title": "동등성 비교 및 동일성",
                "url": "#동등성-비교-및-동일성",
                "items": []
              },
              {
                "title": "속성의 열거 가능성과 소유권",
                "url": "#속성의-열거-가능성과-소유권",
                "items": []
              },
              {
                "title": "클로저",
                "url": "#클로저",
                "items": []
              },
              {
                "title": "상속과 프로토타입 체인",
                "url": "#상속과-프로토타입-체인",
                "items": []
              },
              {
                "title": "JavaScript 형식화 배열",
                "url": "#javascript-형식화-배열",
                "items": []
              },
              {
                "title": "메모리 관리",
                "url": "#메모리-관리",
                "items": []
              },
              {
                "title": "Concurrency model and Event Loop",
                "url": "#concurrency-model-and-event-loop",
                "items": []
              }
            ]
          },
          {
            "title": "3.7. AJAX(~9/10)",
            "url": "#37-ajax910",
            "items": []
          }
        ]
      },
      {
        "title": "4. 접근성(~9/20)",
        "url": "#4-접근성920",
        "items": [
          {
            "title": "4.1. 접근성 소개",
            "url": "#41-접근성-소개",
            "items": [
              {
                "title": "접근성이란?",
                "url": "#접근성이란",
                "items": []
              },
              {
                "title": "HTML : 접근성의 좋은 기반",
                "url": "#html--접근성의-좋은-기반",
                "items": []
              },
              {
                "title": "CSS 와 JavaScript의 접근성 모범 사례 (en-US)",
                "url": "#css-와-javascript의-접근성-모범-사례-en-us",
                "items": []
              },
              {
                "title": "WAI-ARIA 기초 (en-US)",
                "url": "#wai-aria-기초-en-us",
                "items": []
              },
              {
                "title": "멀티미디어 접근성 (en-US)",
                "url": "#멀티미디어-접근성-en-us",
                "items": []
              },
              {
                "title": "모바일 접근성",
                "url": "#모바일-접근성",
                "items": []
              },
              {
                "title": "접근성 트러블슈팅",
                "url": "#접근성-트러블슈팅",
                "items": []
              }
            ]
          }
        ]
      },
      {
        "title": "8. 웹 보안",
        "url": "#8-웹-보안",
        "items": [
          {
            "title": "8.1. 콘텐츠 보안(~9/29)",
            "url": "#81-콘텐츠-보안929",
            "items": [
              {
                "title": "콘텐츠 보안 정책(CSP)",
                "url": "#콘텐츠-보안-정책csp",
                "items": []
              }
            ]
          },
          {
            "title": "8.2. 연결 보안(~10/5)",
            "url": "#82-연결-보안105",
            "items": [
              {
                "title": "전송 계층 보안(TLS)",
                "url": "#전송-계층-보안tls",
                "items": []
              },
              {
                "title": "HTTPS",
                "url": "#https",
                "items": []
              },
              {
                "title": "HTTP Strict-Transport-Security",
                "url": "#http-strict-transport-security",
                "items": []
              },
              {
                "title": "인증서 투명성",
                "url": "#인증서-투명성",
                "items": []
              },
              {
                "title": "혼합 콘텐츠",
                "url": "#혼합-콘텐츠",
                "items": []
              },
              {
                "title": "혼합 콘텐츠가 차단된 웹사이트를 고치는 방법 (en-US)",
                "url": "#혼합-콘텐츠가-차단된-웹사이트를-고치는-방법-en-us",
                "items": []
              },
              {
                "title": "보안 컨텍스트",
                "url": "#보안-컨텍스트",
                "items": []
              },
              {
                "title": "보안 컨텍스트로 제한된 기능",
                "url": "#보안-컨텍스트로-제한된-기능",
                "items": []
              },
              {
                "title": "Weak signature algorithms (en-US)",
                "url": "#weak-signature-algorithms-en-us",
                "items": []
              }
            ]
          },
          {
            "title": "8.3. 데이터 보안(~10/10)",
            "url": "#83-데이터-보안1010",
            "items": [
              {
                "title": "HTTP 쿠키 사용",
                "url": "#http-쿠키-사용",
                "items": []
              },
              {
                "title": "로컬 스토리지",
                "url": "#로컬-스토리지",
                "items": []
              }
            ]
          },
          {
            "title": "8.4. 정보 유출(~10/13)",
            "url": "#84-정보-유출1013",
            "items": [
              {
                "title": "리퍼러 헤더 정책: 개인 정보 보호 및 보안 문제 (en-US)",
                "url": "#리퍼러-헤더-정책-개인-정보-보호-및-보안-문제-en-us",
                "items": []
              },
              {
                "title": "자격 증명 없는 IFrame (en-US)",
                "url": "#자격-증명-없는-iframe-en-us",
                "items": []
              }
            ]
          },
          {
            "title": "8.5. 무결성(~10/15)",
            "url": "#85-무결성1015",
            "items": [
              {
                "title": "동일 출처 정책",
                "url": "#동일-출처-정책",
                "items": []
              },
              {
                "title": "하위 리소스 무결성 (en-US)",
                "url": "#하위-리소스-무결성-en-us",
                "items": []
              },
              {
                "title": "HTTP Access-Control-Allow-Origin",
                "url": "#http-access-control-allow-origin",
                "items": []
              },
              {
                "title": "HTTP X-Content-Type-Options (en-US)",
                "url": "#http-x-content-type-options-en-us",
                "items": []
              }
            ]
          },
          {
            "title": "8.6. 클릭재킹 보호(~10/18)",
            "url": "#86-클릭재킹-보호1018",
            "items": [
              {
                "title": "HTTP X-Frame-Options",
                "url": "#http-x-frame-options",
                "items": []
              },
              {
                "title": "CSP: frame-ancestors (en-US)",
                "url": "#csp-frame-ancestors-en-us",
                "items": []
              }
            ]
          },
          {
            "title": "8.7. 사용자 정보 보안(~10/21)",
            "url": "#87-사용자-정보-보안1021",
            "items": [
              {
                "title": "안전하지 않은 비밀번호",
                "url": "#안전하지-않은-비밀번호",
                "items": []
              },
              {
                "title": "개인 정보 및 :visited 선택자 (en-US)",
                "url": "#개인-정보-및-visited-선택자-en-us",
                "items": []
              }
            ]
          }
        ]
      },
      {
        "title": "9. HTTP",
        "url": "#9-http",
        "items": [
          {
            "title": "9.1. HTTP 기본(~10/25)",
            "url": "#91-http-기본1025",
            "items": [
              {
                "title": "HTTP 개요",
                "url": "#http-개요",
                "items": []
              },
              {
                "title": "HTTP의 진화",
                "url": "#http의-진화",
                "items": []
              },
              {
                "title": "HTTP 버전 협상",
                "url": "#http-버전-협상",
                "items": []
              },
              {
                "title": "HTTP 메시지",
                "url": "#http-메시지",
                "items": []
              },
              {
                "title": "전형적인 HTTP 세션",
                "url": "#전형적인-http-세션",
                "items": []
              },
              {
                "title": "HTTP/1.x 연결관리",
                "url": "#http1x-연결관리",
                "items": []
              },
              {
                "title": "프로토콜 업그레이드 메커니즘",
                "url": "#프로토콜-업그레이드-메커니즘",
                "items": []
              }
            ]
          },
          {
            "title": "9.2. 리소스와 URIs(~10/27)",
            "url": "#92-리소스와-uris1027",
            "items": [
              {
                "title": "웹의 리소스 식별하기",
                "url": "#웹의-리소스-식별하기",
                "items": []
              },
              {
                "title": "데이터 URL",
                "url": "#데이터-url",
                "items": []
              },
              {
                "title": "MIME 타입 소개",
                "url": "#mime-타입-소개",
                "items": []
              },
              {
                "title": "www와 non-www URL",
                "url": "#www와-non-www-url",
                "items": []
              }
            ]
          },
          {
            "title": "9.3. HTTP 보안(~10/30)",
            "url": "#93-http-보안1030",
            "items": [
              {
                "title": "콘텐츠 보안 정책(CSP)",
                "url": "#콘텐츠-보안-정책csp-1",
                "items": []
              },
              {
                "title": "HTTP strict transport security",
                "url": "#http-strict-transport-security-1",
                "items": []
              },
              {
                "title": "Cookie security",
                "url": "#cookie-security",
                "items": []
              },
              {
                "title": "X-Content-Type-Options",
                "url": "#x-content-type-options",
                "items": []
              },
              {
                "title": "X-Frame-Options",
                "url": "#x-frame-options",
                "items": []
              },
              {
                "title": "X-XSS-Protection",
                "url": "#x-xss-protection",
                "items": []
              },
              {
                "title": "HTTP Public Key Pinning",
                "url": "#http-public-key-pinning",
                "items": []
              },
              {
                "title": "Mozilla Observatory",
                "url": "#mozilla-observatory",
                "items": []
              }
            ]
          },
          {
            "title": "9.4. 기타 이슈(~11/2)",
            "url": "#94-기타-이슈112",
            "items": [
              {
                "title": "HTTP 접근제어(CORS)",
                "url": "#http-접근제어cors",
                "items": []
              },
              {
                "title": "HTTP 인증",
                "url": "#http-인증",
                "items": []
              },
              {
                "title": "HTTP 캐싱",
                "url": "#http-캐싱",
                "items": []
              },
              {
                "title": "HTTP 압축",
                "url": "#http-압축",
                "items": []
              },
              {
                "title": "HTTP 조건부 요청",
                "url": "#http-조건부-요청",
                "items": []
              },
              {
                "title": "HTTP 컨텐츠 협상",
                "url": "#http-컨텐츠-협상",
                "items": []
              },
              {
                "title": "HTTP 쿠키",
                "url": "#http-쿠키",
                "items": []
              },
              {
                "title": "HTTP range 요청",
                "url": "#http-range-요청",
                "items": []
              },
              {
                "title": "HTTP 리다이렉트",
                "url": "#http-리다이렉트",
                "items": []
              },
              {
                "title": "HTTP 명세",
                "url": "#http-명세",
                "items": []
              },
              {
                "title": "Permissions policy",
                "url": "#permissions-policy",
                "items": []
              }
            ]
          }
        ]
      },
      {
        "title": "5. 웹 퍼포먼스",
        "url": "#5-웹-퍼포먼스",
        "items": [
          {
            "title": "5.1. 웹 퍼포먼스 소개",
            "url": "#51-웹-퍼포먼스-소개",
            "items": [
              {
                "title": "The \"why\" of web performance",
                "url": "#the-why-of-web-performance",
                "items": []
              },
              {
                "title": "What is web performance?",
                "url": "#what-is-web-performance",
                "items": []
              },
              {
                "title": "How do users perceive performance?",
                "url": "#how-do-users-perceive-performance",
                "items": []
              },
              {
                "title": "Measuring performance",
                "url": "#measuring-performance",
                "items": []
              },
              {
                "title": "Multimedia: images",
                "url": "#multimedia-images",
                "items": []
              },
              {
                "title": "Multimedia: video",
                "url": "#multimedia-video",
                "items": []
              },
              {
                "title": "JavaScript performance optimization",
                "url": "#javascript-performance-optimization",
                "items": []
              },
              {
                "title": "HTML performance optimization",
                "url": "#html-performance-optimization",
                "items": []
              },
              {
                "title": "CSS performance optimization",
                "url": "#css-performance-optimization",
                "items": []
              },
              {
                "title": "The business case for web performance",
                "url": "#the-business-case-for-web-performance",
                "items": []
              }
            ]
          }
        ]
      },
      {
        "title": "참고할 만한 블로그",
        "url": "#참고할-만한-블로그",
        "items": []
      },
      {
        "title": "Javascript",
        "url": "#javascript",
        "items": [
          {
            "title": "JS 동작 원리",
            "url": "#js-동작-원리",
            "items": []
          },
          {
            "title": "JS Worker에 관하여",
            "url": "#js-worker에-관하여",
            "items": []
          },
          {
            "title": "fetch API에 쓰이는 Request, Response 객체",
            "url": "#fetch-api에-쓰이는-request-response-객체",
            "items": []
          },
          {
            "title": "Promise를 받을 때 등에 쓰이는 blob이란 무엇인가?",
            "url": "#promise를-받을-때-등에-쓰이는-blob이란-무엇인가",
            "items": []
          },
          {
            "title": "AJAX 에 대해",
            "url": "#ajax-에-대해",
            "items": []
          },
          {
            "title": "WebGL",
            "url": "#webgl",
            "items": []
          },
          {
            "title": "HTTP",
            "url": "#http",
            "items": []
          },
          {
            "title": "웹브라우저에 대하여",
            "url": "#웹브라우저에-대하여",
            "items": []
          },
          {
            "title": "Intersection Observer API",
            "url": "#intersection-observer-api",
            "items": []
          },
          {
            "title": "window, navigator 등 몇몇 전역 객체에 대해",
            "url": "#window-navigator-등-몇몇-전역-객체에-대해",
            "items": []
          },
          {
            "title": "call, apply 등으로 this 조작",
            "url": "#call-apply-등으로-this-조작",
            "items": []
          },
          {
            "title": "== 등으로 비교하는 로직",
            "url": "#-등으로-비교하는-로직",
            "items": []
          },
          {
            "title": "호이스팅, 실행 컨텍스트, 클로저 etc.",
            "url": "#호이스팅-실행-컨텍스트-클로저-etc",
            "items": []
          },
          {
            "title": "이터레이션 프로토콜",
            "url": "#이터레이션-프로토콜",
            "items": []
          },
          {
            "title": "strict mode",
            "url": "#strict-mode",
            "items": []
          },
          {
            "title": "Map, Object diff",
            "url": "#map-object-diff",
            "items": []
          },
          {
            "title": "DOM",
            "url": "#dom",
            "items": []
          },
          {
            "title": "JS 가비지 컬렉터",
            "url": "#js-가비지-컬렉터",
            "items": []
          },
          {
            "title": "JS Error 객체",
            "url": "#js-error-객체",
            "items": []
          },
          {
            "title": "제네릭 T 타입으로 객체 초기화하기",
            "url": "#제네릭-t-타입으로-객체-초기화하기",
            "items": []
          }
        ]
      },
      {
        "title": "React",
        "url": "#react",
        "items": [
          {
            "title": "useState의 작동 원리",
            "url": "#usestate의-작동-원리",
            "items": []
          },
          {
            "title": "리액트 커스텀 훅",
            "url": "#리액트-커스텀-훅",
            "items": []
          },
          {
            "title": "useEffect 원리",
            "url": "#useeffect-원리",
            "items": []
          }
        ]
      },
      {
        "title": "기타",
        "url": "#기타",
        "items": [
          {
            "title": "rem, px, vw의 차이와 언제 써야 하는지",
            "url": "#rem-px-vw의-차이와-언제-써야-하는지",
            "items": []
          },
          {
            "title": "react-query 탐구 이어쓰기",
            "url": "#react-query-탐구-이어쓰기",
            "items": []
          },
          {
            "title": "운영체제 7단원 식사하는 철학자들 문제, 8단원 데드락",
            "url": "#운영체제-7단원-식사하는-철학자들-문제-8단원-데드락",
            "items": []
          }
        ]
      },
      {
        "title": "6. 도구와 테스팅",
        "url": "#6-도구와-테스팅",
        "items": [
          {
            "title": "6.1. 클라이언트 사이드 웹 개발 도구",
            "url": "#61-클라이언트-사이드-웹-개발-도구",
            "items": [
              {
                "title": "Client-side tooling overview",
                "url": "#client-side-tooling-overview",
                "items": []
              },
              {
                "title": "Command line crash course",
                "url": "#command-line-crash-course",
                "items": []
              },
              {
                "title": "Package management basics",
                "url": "#package-management-basics",
                "items": []
              },
              {
                "title": "Introducing a complete toolchain",
                "url": "#introducing-a-complete-toolchain",
                "items": []
              },
              {
                "title": "Deploying our app",
                "url": "#deploying-our-app",
                "items": []
              }
            ]
          },
          {
            "title": "6.2. 클라이언트 사이드 프레임워크 소개",
            "url": "#62-클라이언트-사이드-프레임워크-소개",
            "items": []
          },
          {
            "title": "6.3. 크로스 브라우저 테스팅",
            "url": "#63-크로스-브라우저-테스팅",
            "items": [
              {
                "title": "Introduction to cross browser testing",
                "url": "#introduction-to-cross-browser-testing",
                "items": []
              },
              {
                "title": "Strategies for carrying out testing",
                "url": "#strategies-for-carrying-out-testing",
                "items": []
              },
              {
                "title": "Handling common HTML and CSS problems",
                "url": "#handling-common-html-and-css-problems",
                "items": []
              },
              {
                "title": "Handling common JavaScript problems",
                "url": "#handling-common-javascript-problems",
                "items": []
              },
              {
                "title": "Handling common accessibility problems",
                "url": "#handling-common-accessibility-problems",
                "items": []
              },
              {
                "title": "Introduction to automated testing",
                "url": "#introduction-to-automated-testing",
                "items": []
              },
              {
                "title": "Setting up your own test automation environment",
                "url": "#setting-up-your-own-test-automation-environment",
                "items": []
              }
            ]
          }
        ]
      },
      {
        "title": "7. 서버사이드 웹사이트 프로그래밍",
        "url": "#7-서버사이드-웹사이트-프로그래밍",
        "items": [
          {
            "title": "7.1. 첫걸음",
            "url": "#71-첫걸음",
            "items": [
              {
                "title": "Introduction to the server side",
                "url": "#introduction-to-the-server-side",
                "items": []
              },
              {
                "title": "Client-Server overview",
                "url": "#client-server-overview",
                "items": []
              },
              {
                "title": "Server-side web frameworks",
                "url": "#server-side-web-frameworks",
                "items": []
              },
              {
                "title": "Website security",
                "url": "#website-security",
                "items": []
              }
            ]
          },
          {
            "title": "7.2. Django",
            "url": "#72-django",
            "items": []
          },
          {
            "title": "7.3. Express web framework",
            "url": "#73-express-web-framework",
            "items": []
          }
        ]
      },
      {
        "title": "10. 프로그레시브 웹 앱",
        "url": "#10-프로그레시브-웹-앱",
        "items": []
      },
      {
        "title": "CSS",
        "url": "#css",
        "items": [
          {
            "title": "2.1. CSS 첫번째 단계",
            "url": "#21-css-첫번째-단계",
            "items": [
              {
                "title": "CSS란 무엇인가?",
                "url": "#css란-무엇인가",
                "items": []
              },
              {
                "title": "CSS 시작하기",
                "url": "#css-시작하기",
                "items": []
              },
              {
                "title": "CSS 구조",
                "url": "#css-구조",
                "items": []
              },
              {
                "title": "CSS 작동 방식",
                "url": "#css-작동-방식",
                "items": []
              }
            ]
          },
          {
            "title": "2.2. CSS 구성요소",
            "url": "#22-css-구성요소",
            "items": [
              {
                "title": "CSS 선택자",
                "url": "#css-선택자",
                "items": []
              },
              {
                "title": "Type, class and ID selectors",
                "url": "#type-class-and-id-selectors",
                "items": []
              },
              {
                "title": "Attribute selectors",
                "url": "#attribute-selectors",
                "items": []
              },
              {
                "title": "Pseudo-classes and pseudo-elements",
                "url": "#pseudo-classes-and-pseudo-elements",
                "items": []
              },
              {
                "title": "combinators",
                "url": "#combinators",
                "items": []
              },
              {
                "title": "계단식 및 상속",
                "url": "#계단식-및-상속",
                "items": []
              },
              {
                "title": "cascade layers",
                "url": "#cascade-layers",
                "items": []
              },
              {
                "title": "박스 모델",
                "url": "#박스-모델",
                "items": []
              },
              {
                "title": "배경 및 테두리",
                "url": "#배경-및-테두리",
                "items": []
              },
              {
                "title": "텍스트 표시 방향 제어하기",
                "url": "#텍스트-표시-방향-제어하기",
                "items": []
              },
              {
                "title": "콘텐츠 오버플로우",
                "url": "#콘텐츠-오버플로우",
                "items": []
              },
              {
                "title": "CSS 값과 단위",
                "url": "#css-값과-단위",
                "items": []
              },
              {
                "title": "CSS에서 항목 크기 조정",
                "url": "#css에서-항목-크기-조정",
                "items": []
              },
              {
                "title": "이미지, 미디어 및 양식 요소",
                "url": "#이미지-미디어-및-양식-요소",
                "items": []
              },
              {
                "title": "표 스타일링",
                "url": "#표-스타일링",
                "items": []
              },
              {
                "title": "CSS 디버깅",
                "url": "#css-디버깅",
                "items": []
              },
              {
                "title": "CSS 구성",
                "url": "#css-구성",
                "items": []
              },
              {
                "title": "기본적인 CSS 이해",
                "url": "#기본적인-css-이해",
                "items": []
              },
              {
                "title": "편지지 만들기",
                "url": "#편지지-만들기",
                "items": []
              },
              {
                "title": "A cool looking box",
                "url": "#a-cool-looking-box",
                "items": []
              }
            ]
          },
          {
            "title": "2.3. 텍스트 스타일링",
            "url": "#23-텍스트-스타일링",
            "items": [
              {
                "title": "기본적인 텍스트 및 글꼴 스타일",
                "url": "#기본적인-텍스트-및-글꼴-스타일",
                "items": []
              },
              {
                "title": "목록 스타일링",
                "url": "#목록-스타일링",
                "items": []
              },
              {
                "title": "링크 스타일링",
                "url": "#링크-스타일링",
                "items": []
              },
              {
                "title": "웹 글꼴",
                "url": "#웹-글꼴",
                "items": []
              }
            ]
          },
          {
            "title": "2.4. CSS 레이아웃",
            "url": "#24-css-레이아웃",
            "items": [
              {
                "title": "CSS 레이아웃 입문서",
                "url": "#css-레이아웃-입문서",
                "items": []
              },
              {
                "title": "일반 대열(normal flow)",
                "url": "#일반-대열normal-flow",
                "items": []
              },
              {
                "title": "Flexbox",
                "url": "#flexbox",
                "items": []
              },
              {
                "title": "Grids",
                "url": "#grids",
                "items": []
              },
              {
                "title": "Floats(부동체)",
                "url": "#floats부동체",
                "items": []
              },
              {
                "title": "Positioning",
                "url": "#positioning",
                "items": []
              },
              {
                "title": "Multiple-column Layout",
                "url": "#multiple-column-layout",
                "items": []
              },
              {
                "title": "Responsive design",
                "url": "#responsive-design",
                "items": []
              },
              {
                "title": "미디어 쿼리 안내서",
                "url": "#미디어-쿼리-안내서",
                "items": []
              },
              {
                "title": "레거시 레이아웃 메서드",
                "url": "#레거시-레이아웃-메서드",
                "items": []
              },
              {
                "title": "이전 브라우저 지원",
                "url": "#이전-브라우저-지원",
                "items": []
              }
            ]
          },
          {
            "title": "2.5. CSS 핵심 개념",
            "url": "#25-css-핵심-개념",
            "items": [
              {
                "title": "언어 구문과 형태",
                "url": "#언어-구문과-형태",
                "items": []
              },
              {
                "title": "명시도",
                "url": "#명시도",
                "items": []
              },
              {
                "title": "상속",
                "url": "#상속",
                "items": []
              },
              {
                "title": "종속",
                "url": "#종속",
                "items": []
              },
              {
                "title": "CSS 값과 단위",
                "url": "#css-값과-단위-1",
                "items": []
              },
              {
                "title": "CSS 함수 표기법",
                "url": "#css-함수-표기법",
                "items": []
              },
              {
                "title": "박스 모델",
                "url": "#박스-모델-1",
                "items": []
              },
              {
                "title": "여백 상쇄",
                "url": "#여백-상쇄",
                "items": []
              },
              {
                "title": "컨테이닝 블록",
                "url": "#컨테이닝-블록",
                "items": []
              },
              {
                "title": "쌓임 맥락, 블록 서식 맥락",
                "url": "#쌓임-맥락-블록-서식-맥락",
                "items": []
              },
              {
                "title": "초기값, 계산값, 사용값, 실제값",
                "url": "#초기값-계산값-사용값-실제값",
                "items": []
              },
              {
                "title": "CSS shortcut",
                "url": "#css-shortcut",
                "items": []
              },
              {
                "title": "CSS flexbox",
                "url": "#css-flexbox",
                "items": []
              },
              {
                "title": "CSS grid",
                "url": "#css-grid",
                "items": []
              },
              {
                "title": "CSS 선택자",
                "url": "#css-선택자-1",
                "items": []
              },
              {
                "title": "미디어쿼리",
                "url": "#미디어쿼리",
                "items": []
              },
              {
                "title": "CSS 애니메이션",
                "url": "#css-애니메이션",
                "items": []
              }
            ]
          },
          {
            "title": "2.6. CSS 고급",
            "url": "#26-css-고급",
            "items": []
          }
        ]
      },
      {
        "title": "개발자 가이드",
        "url": "#개발자-가이드",
        "items": []
      },
      {
        "title": "11. 디자인 패턴",
        "url": "#11-디자인-패턴",
        "items": []
      },
      {
        "title": "기타",
        "url": "#기타-1",
        "items": [
          {
            "title": "1.6. 고급 주제 (~8/18)",
            "url": "#16-고급-주제-818",
            "items": [
              {
                "title": "HTML 참고서",
                "url": "#html-참고서",
                "items": []
              },
              {
                "title": "CORS 활성화 이미지",
                "url": "#cors-활성화-이미지",
                "items": []
              },
              {
                "title": "CORS 설정 특성",
                "url": "#cors-설정-특성",
                "items": []
              },
              {
                "title": "rel=\"preload\"로 콘텐츠 미리 불러오기",
                "url": "#relpreload로-콘텐츠-미리-불러오기",
                "items": []
              }
            ]
          },
          {
            "title": "1.7. 기타 (보류)",
            "url": "#17-기타-보류",
            "items": [
              {
                "title": "콘텐츠 카테고리",
                "url": "#콘텐츠-카테고리",
                "items": []
              },
              {
                "title": "호환성 모드와 표준 모드",
                "url": "#호환성-모드와-표준-모드",
                "items": []
              }
            ]
          }
        ]
      }
    ],
    "metadata": {
      "readingTime": 5,
      "wordCount": 1203
    },
    "url": "/posts/todo",
    "thumbnail": {
      "local": "/thumbnails/todo-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-todo-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAb0lEQVR4nGPIzMyUlpY2NTWVl5dnYWHx9fUVEhL6//8/Q0VFhbmFxaFDh3bt2rVq1apDhw6tWrUKJLFr167S0tLPnz//RwUMyJzfMACSuHjpyrlz569du/bq1SsUHRMnT+vs6p43b+65c+cgmiASAGL4bSVOHd/oAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "typescript-basic-function-type",
    "title": "TS 탐구생활 - TS의 bind, call, apply 메서드 타입 탐구",
    "date": "2023-11-20T00:00:00Z",
    "description": "TS의 Function.prototype에 속한 메서드 타입들을 알아보자",
    "tags": [
      "typescript"
    ],
    "html": "<p>타입스크립트 교과서를 읽다가 TS의 <code>lib.es5.d.ts</code>를 직접 열어보게 되었다. 그리고 <code>Function.prototype</code>에 속해 있는 <code>call</code>, <code>apply</code>, <code>bind</code> 메서드의 타입을 보았는데 흥미로운 부분이 있어서 글을 쓰게 되었다. 보충할 수 있는 내용이 많겠지만 일단 지금 할 수 있는 만큼 정리해보았다.</p>\n<h1>1. this 유틸리티 타입</h1>\n<p>글에서 다룰 타입에 쓰이는 this 관련 유틸리티 타입을 먼저 보고 넘어가자. 실제 파일에서는 <code>Function</code>타입 다음에 정의되어 있기는 하지만 처음으로 이걸 적는 게 구성상 더 좋다고 생각했다.</p>\n<h2>1.1. ThisParameterType</h2>\n<p><code>ThisParameterType&#x3C;T></code>는 <code>T</code> 함수의 <code>this</code> 매개변수 타입을 추출한다. <code>T</code>의 <code>this</code> 매개변수 타입 추론이 실패할 시 unknown이 된다.</p>\n<pre><code class=\"language-ts\">type ThisParameterType&#x3C;T> = T extends (this: infer U, ...args: never) => any ? U : unknown;\n</code></pre>\n<p>이때 함수 매개변수 타입은 반공변성을 가지기 때문에 <code>...args</code>가 never가 된다는 건 어떤 매개변수를 가지는 함수라도 매개변수 때문에 해당 타입의 extends 조건으로 걸러지지 않는다는 뜻이다. <a href=\"https://github.com/microsoft/TypeScript/commit/66dba1331ba0a9a27cc35f2901253766ef20d0c5\">실제로 원래 <code>...args</code>타입은 <code>any[]</code>였는데 더 일반적인 타입을 위해서 never로 고친 커밋이 존재한다.</a></p>\n<h2>1.2. OmitThisParameter</h2>\n<p>앞서 본 <code>ThisParameterType</code>을 이용해서 함수의 this 타입을 제거하는 유틸리티 타입이 있다.</p>\n<pre><code class=\"language-ts\">/**\n * Removes the 'this' parameter from a function type.\n */\ntype OmitThisParameter&#x3C;T> = unknown extends ThisParameterType&#x3C;T> ? T : T extends (...args: infer A) => infer R ? (...args: A) => R : T;\n</code></pre>\n<p><code>ThisParameterType&#x3C;T></code>가 unknown이라는 것은 정의상 함수에 this 타입이 존재하지 않는다는 뜻이므로 그대로 T를 반환하면 된다. 반면 함수에 this 타입이 존재한다면 이 정의로 넘어가게 된다.</p>\n<pre><code class=\"language-ts\">T extends (...args: infer A) => infer R ? (...args: A) => R : T;\n</code></pre>\n<p>매개변수들에 타입 추론을 적용할 시 this가 빠진다는 점을 이용해서 infer를 이용해 매개변수들의 타입과 리턴타입을 추론한다. 그리고 그것들을 이용해 다시 함수 타입을 구축하는 방식으로 this가 빠진 타입을 만든다.</p>\n<h1>2. Function</h1>\n<p>TS에서는 3가지 함수 타입을 정의하고 있다. <code>Function</code>, <code>CallableFunction</code>, <code>NewableFunction</code>이다. 이들은 모두 각각의 메서드 타입들을 정의하고 있는데 이들의 구분과 역사, 그리고 각각의 메서드 타입들에 대해서 알아보자.</p>\n<p><code>CallableFunction</code>, <code>NewableFunction</code>같은 경우에는 엄격한 타입 정의를 위해서 상당히 복잡한 타입을 사용하고 있다. 이 또한 다음 섹션에서 설명해 보려 한다. 하지만 그전에 먼저 가장 기본형인 Function 타입부터 보도록 하자.</p>\n<h2>2.1. Function 인터페이스</h2>\n<p><code>Function</code>은 가장 일반적인 함수의 타입을 정의하는 인터페이스이다. 이후 보겠지만 tsconfig.json에서 <code>strictBindCallApply</code> 컴파일러 옵션이 false로 설정되어 있을 경우 함수에 적용하는 bind, call, apply 메서드의 타입이 해당 인터페이스의 것으로 적용된다. 해당 옵션의 기본값은 true이므로 일반적으로는 별로 쓰일 일이 없는 타입이다.</p>\n<pre><code class=\"language-ts\">// \nfunction add(a: number, b: number): number {\n    return a + b;\n}\n\n// strictBindCallApply:false일 경우 Function 인터페이스의 apply 타입이 적용된다\n// strictBindCallApply:true일 경우 CallableFunction 인터페이스의 apply 타입이 적용된다\nconst addTest = add.apply(null, [1, 2]);\n</code></pre>\n<p>해당 인터페이스의 메서드 타입들은 다음과 같이 정의되어 있다. 새로운 this가 될 thisArg 인수와 argArray 인수가 그냥 any로 정의되어 있다. 리턴타입도 any다.</p>\n<pre><code class=\"language-ts\">interface Function {\n    apply(this: Function, thisArg: any, argArray?: any): any;\n    call(this: Function, thisArg: any, ...argArray: any[]): any;\n    bind(this: Function, thisArg: any, ...argArray: any[]): any;\n    toString(): string;\n    prototype: any;\n    readonly length: number;\n\n    // Non-standard extensions\n    arguments: any;\n    caller: Function;\n}\n\ninterface FunctionConstructor {\n    new(...args: string[]): Function;\n    (...args: string[]): Function;\n    readonly prototype: Function;\n}\n\ndeclare var Function: FunctionConstructor;\n</code></pre>\n<p><code>strictBindCallApply:false</code>일 때 bind, call, apply는 여기의 메서드 타입들을 사용하게 된다. 모두 thisArg, 매개변수, 리턴타입 모두 any이므로 원래 함수의 매개변수 타입이 어땠든 상관없이 call, apply 등을 적용할 수 있다.</p>\n<pre><code class=\"language-ts\">// strictBindCallApply:false일 경우\nfunction fn(x: string) {\n  return parseInt(x);\n}\n// fn의 인수는 string이지만 apply의 인수는 boolean이다. 하지만 apply의 argArray가 any이므로 타입 에러가 발생하지 않는다.\nconst n = fn.call(undefined, false);\n\n// 원래 fn의 인자보다 많은 수를 넘겨줘도 타입 에러가 발생하지 않는다\nfn.call(\"hi\",1,2,3,4,5,6,7);\n</code></pre>\n<p>반면 <code>strictBindCallApply</code>옵션이 true라면 일반 함수에는 <code>CallableFunction</code>의 메서드 타입이, 생성자 함수에는 <code>NewableFunction</code>타입이 적용되어 이 인터페이스의 메서드 타입이 쓰이게 되는 일은 잘 없다.</p>\n<h2>2.2. Function 타입의 사용</h2>\n<p>그럼 <code>strictBindCallApply</code> 옵션이 true일 경우 이 타입이 쓰이는 경우는 없을까? <code>FunctionConstructor</code>타입을 통해서 그런 경우가 있다는 것을 추측할 수 있었다. 그리고 실험 결과 실제로 그랬다. <code>new Function()</code>으로 만들어진 함수가 Function 인터페이스 타입을 가진다.</p>\n<p>자주 쓰이는 문법은 아니지만 <code>new Function(...)</code>와 같이 함수 생성자를 통해서도 함수를 만들 수 있다. 자세한 문법은 <a href=\"https://ko.javascript.info/new-function\">new Function 문법</a>을 참고하자. 아무튼 이런 식으로 함수를 생성한 후 bind, call, apply를 적용하면 <code>strictBindCallApply</code> 옵션이 true이더라도 Function 타입의 메서드 타입이 적용된다.</p>\n<pre><code class=\"language-ts\">const sum = new Function(\"a\", \"b\", \"return a + b\");\n\n// sumApply, sumCall, sumBind는 Function 인터페이스 메서드의 리턴타입에 따라 모두 any 타입이 된다\n// 또한 적용된 타입 정의로 이동해 보면 Function 인터페이스의 메서드가 나타난다\nconst sumApply = sum.apply(\"global\", [1, 2]);\nconst sumCall = sum.call(\"global\", 1, 2);\nconst sumBind = sum.bind(\"global\", 1, 2);\n</code></pre>\n<h2>2.3. 이 타입은 왜 이렇게 허술할까?</h2>\n<p>그런데 이 타입으로 할 수 있는 게 별로 없어 보인다. 별로 타입 검사에 사용될 것도 없는 이런 허술한 타입이 왜 존재하는 것일까? 나름 추측을 해보았다.</p>\n<p><a href=\"https://github.com/microsoft/TypeScript/commit/5fe84781592a08b5294e01a2fbf42d1def07111d\">apply, call, bind의 오버로드 타입이 처음 생길 때는 이렇게 허술하지 않았다. 원본 커밋 내역은 아직도 볼 수 있다. 그때는 이런 모습이었다. es5.d.ts도 아니고 core.d.ts에 있었다.</a></p>\n<pre><code class=\"language-ts\">interface Function {\n    apply&#x3C;T,U>(this: (this: T, ...argArray: any[]) => U, thisArg: T, argArray?: any): U;\n    apply(this: Function, thisArg: any, argArray?: any): any;\n    call&#x3C;T,U>(this: (this: T, ...argArray: any[]) => U, thisArg: T, ...argArray: any[]): U;\n    call(this: Function, thisArg: any, ...argArray: any[]): any;\n    bind&#x3C;T, U>(this: (this: T, ...argArray: any[]) => U, thisArg: T, ...argArray: any[]): (...argArray: any[]) => U;\n    bind(this: Function, thisArg: any, ...argArray: any[]): any;\n\n    prototype: any;\n    readonly length: number;\n\n    // Non-standard extensions\n    arguments: any;\n    caller: Function;\n}\n</code></pre>\n<p>제네릭을 이용해서 thisArg 타입과 원래 함수의 리턴타입을 맞춰 주는 것을 볼 수 있다.</p>\n<p>물론 이 역시 허술한 부분들이 있다. 가령 매개변수 타입은 <code>any[]</code>로 허술하게 되어 있는 걸 볼 수 있다. 아마 매개변수의 타입을 엄격하게 검사하기 위한 문법이 아직 없었기 때문이라고 추측한다. <a href=\"https://github.com/microsoft/TypeScript/pull/24897\">나머지 매개변수를 튜플 타입으로 추론해 주는 기능은 2018년 6월에 나왔다.</a> 또한 <a href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-6.html\">공변성 개념도 2017년 TS 2.6 릴리즈 때서야 제대로 도입되었다.</a></p>\n<p>하지만 지금의 Function 인터페이스에 비해서는 훨씬 잘 검사해 주는 편이라는 건 누가 보아도 알 수 있다. 그런데 해당 제네릭을 이용한 Function 타입의 call, apply, bind는 어느 날 소리소문없이 사라졌고 Function 타입은 지금처럼 허술해졌다.</p>\n<p>그리고 <a href=\"https://github.com/microsoft/TypeScript/pull/27028\">2018년 9월에 CallableFunction과 NewableFunction 그리고 더 엄격한 call, apply, bind의 타입 정의가 나왔다.</a></p>\n<p>해당 PR 이후 이 허술한 Function 타입이 쓰이는 경우는 앞서 보았던 new Function을 쓰는 경우 혹은 매우 마이너한 <code>strictBindCallApply</code> 옵션을 끄는 경우밖에 없어졌다. 이 두 경우 모두 잘 발생하지 않기에 특별한 수정이 없었던 게 아닐까 추측한다.</p>\n<h1>3. CallableFunction</h1>\n<p>CallableFunction은 <code>strictBindCallApply</code> 컴파일러 옵션이 true일 경우에 쓰인다. 우리가 일반적으로 사용하는 호출 가능한 함수에 대한 bind, call, apply 메서드 타입을 제네릭 나머지 매개변수 타입을 이용해서 엄격하게 정의한 것이다.</p>\n<p><a href=\"https://github.com/microsoft/TypeScript/pull/24897\">앞서 보았던 제네릭 형태의 나머지 매개변수를 튜플 타입으로 추론해 주는 기능의 릴리즈로 인해 나올 수 있었던 기능이다. 해당 기능의 PR에서도 bind, call, apply에 대한 더 강력한 타입 검사를 가능하게 하는 기능이라고 언급하고 있다.</a></p>\n<pre><code class=\"language-ts\">interface CallableFunction extends Function {\n    apply&#x3C;T, R>(this: (this: T) => R, thisArg: T): R;\n    apply&#x3C;T, A extends any[], R>(this: (this: T, ...args: A) => R, thisArg: T, args: A): R;\n    call&#x3C;T, A extends any[], R>(this: (this: T, ...args: A) => R, thisArg: T, ...args: A): R;\n    bind&#x3C;T>(this: T, thisArg: ThisParameterType&#x3C;T>): OmitThisParameter&#x3C;T>;\n    bind&#x3C;T, A extends any[], B extends any[], R>(this: (this: T, ...args: [...A, ...B]) => R, thisArg: T, ...args: A): (...args: B) => R;\n}\n</code></pre>\n<h2>3.1. apply, call</h2>\n<p>위 인터페이스에서 apply, call 메서드의 타입을 보면 다음과 같이 정의되어 있다.</p>\n<pre><code class=\"language-ts\">apply&#x3C;T, R>(this: (this: T) => R, thisArg: T): R;\napply&#x3C;T, A extends any[], R>(this: (this: T, ...args: A) => R, thisArg: T, args: A): R;\ncall&#x3C;T, A extends any[], R>(this: (this: T, ...args: A) => R, thisArg: T, ...args: A): R;\n</code></pre>\n<p>복잡해 보이지만 apply, call이 실제로 어떻게 호출되는지를 생각해 보고 거기에 대응시켜 보자.</p>\n<pre><code class=\"language-ts\">fn.apply(thisArg, [arg1, arg2, ...]);\nfn.call(thisArg, arg1, arg2, ...);\n</code></pre>\n<p>그러면 this는 apply, call이 적용되는 함수 <code>fn</code>이고 thisArg 타입이 T이고 매개변수들인 arg1, arg2...들을 담은 튜플 타입이 A이다. <a href=\"https://github.com/microsoft/TypeScript/pull/24897\"><code>...</code>을 이용해 형성한 나머지 매개변수는 그것들이 묶인 튜플 타입을 가진다.</a> 마지막으로 R은 리턴타입인데 이들은 각각 원래 this의 this타입, 매개변수 타입, 리턴타입과 같도록 선언되어 있다.</p>\n<p>즉 여기의 call, apply에서는 해당 메서드가 만들어 리턴하는 새로운 함수가 원래 함수의 this, 매개변수, 리턴 타입을 그대로 따르도록 타입을 정의한 것이다. 그렇지 않으면 타입 에러가 발생한다.</p>\n<pre><code class=\"language-ts\">// strictBindCallApply:true일 경우\nfunction add(a: number, b: number): number {\n  return a + b;\n}\n\nconst addTest = add.apply(null, [1, '2']); // string이 number자리에 들어갈 수 없다는 타입 에러\n</code></pre>\n<h2>3.2. bind</h2>\n<p><code>bind</code>타입은 이렇게 정의되어 있다.</p>\n<pre><code class=\"language-ts\">bind&#x3C;T>(this: T, thisArg: ThisParameterType&#x3C;T>): OmitThisParameter&#x3C;T>;\nbind&#x3C;T, A extends any[], B extends any[], R>(this: (this: T, ...args: [...A, ...B]) => R, thisArg: T, ...args: A): (...args: B) => R;\n</code></pre>\n<h3>3.2.1. 첫번째 오버로딩</h3>\n<pre><code class=\"language-ts\">bind&#x3C;T>(this: T, thisArg: ThisParameterType&#x3C;T>): OmitThisParameter&#x3C;T>;\n</code></pre>\n<p>bind 함수는 this로 쓰일 객체를 내부 특수 속성 <code>[[BoundThis]]</code>로 가지고 있는 bound function을 리턴한다. 따라서 해당 함수에는 더 이상 this가 필요 없다. 그러니 <code>OmitThisParameter</code>를 통해 this를 제거한 타입을 리턴 타입에 부여한다.</p>\n<p>만약 this를 생략해 주지 않으면 에러가 발생한다. <code>lib.es5.d.ts</code>의 해당 정의에서 <code>OmitThisParameter&#x3C;T></code>를 그냥 T로 바꿈으로써 실험해 볼 수 있다. 다음과 같은 간단한 코드에서조차 에러가 발생한다.</p>\n<pre><code class=\"language-ts\">function add(this: number, a = 0, b = 0) {\n  return this + a + b;\n}\n\nconst addCustomBind = add.bind(1);\naddCustomBind(2, 3); // the 'this' context of type 'void' is not assignable to method's 'this' of type 'number'\n</code></pre>\n<p><code>addCustomBind</code>의 this 맥락은 이미 1 즉 number 타입으로 정의되었는데 여기에 기본적으로 할당되는 전역 this 맥락이 들어가려고 해서 에러가 발생하는 것이다. <code>OmitThisParameter&#x3C;T></code>를 통해 this를 제거한 타입을 리턴 타입에 부여해야 이런 오류를 해결할 수 있다.</p>\n<h3>3.2.2. 두번째 오버로딩 - 이전 버전</h3>\n<p><a href=\"https://github.com/microsoft/TypeScript/pull/27028\"><code>CallableFunction</code>이 처음 들어왔던 PR</a>로 가면 예전의 <code>bind</code>타입 정의는 다음과 같이 되어 있었다.</p>\n<pre><code class=\"language-ts\">interface CallableFunction extends Function {\n    /* apply, call 타입 정의 생략*/\n\n    bind&#x3C;T, A extends any[], R>(this: (this: T, ...args: A) => R, thisArg: T): (...args: A) => R;\n    bind&#x3C;T, A0, A extends any[], R>(this: (this: T, arg0: A0, ...args: A) => R, thisArg: T, arg0: A0): (...args: A) => R;\n    bind&#x3C;T, A0, A1, A extends any[], R>(this: (this: T, arg0: A0, arg1: A1, ...args: A) => R, thisArg: T, arg0: A0, arg1: A1): (...args: A) => R;\n    bind&#x3C;T, A0, A1, A2, A extends any[], R>(this: (this: T, arg0: A0, arg1: A1, arg2: A2, ...args: A) => R, thisArg: T, arg0: A0, arg1: A1, arg2: A2): (...args: A) => R;\n    bind&#x3C;T, A0, A1, A2, A3, A extends any[], R>(this: (this: T, arg0: A0, arg1: A1, arg2: A2, arg3: A3, ...args: A) => R, thisArg: T, arg0: A0, arg1: A1, arg2: A2, arg3: A3): (...args: A) => R;\n    bind&#x3C;T, AX, R>(this: (this: T, ...args: AX[]) => R, thisArg: T, ...args: AX[]): (...args: AX[]) => R;\n}\n</code></pre>\n<p>여기서 첫번째 오버로딩은 <a href=\"https://github.com/microsoft/TypeScript/commit/9cc997fca76d0befe9ba42803a6be9263f2b24dc\">Improve typing of 'bind' method on function types</a>커밋에서 <code>3.2.1</code>에서 본 형태로 바뀐다. 그 외의 오버로딩은 좀 더 지나서 <a href=\"https://github.com/microsoft/TypeScript/commit/33ab6fd0d5eceb7715000398382b60d64dde1c67\">올해 4월이 되어서야 발전한 형태로 바뀌게 된다.</a> 하지만 예전 형태도 한번쯤 볼 가치가 있다.</p>\n<p>첫번째 오버로딩은 앞서 더 개선된 버전을 보았으니 두번째 오버로딩부터 한번 살펴보자.(사실 첫번째 오버로딩도 여기서는 비슷한 구조다) 잘 보면 마지막 것만 빼고 다 비슷한 구조라는 것을 알 수 있다.</p>\n<pre><code class=\"language-ts\">bind&#x3C;T, A0, A extends any[], R>(this: (this: T, arg0: A0, ...args: A) => R, thisArg: T, arg0: A0): (...args: A) => R;\n</code></pre>\n<p><code>A0</code>은 첫번째 매개변수 타입이고 <code>A</code>는 나머지 매개변수 타입들의 튜플 타입이 된다. 따라서 원래 bind의 this가 받는 매개변수들을 첫번째 매개변수와 나머지로 쪼개서 정의하고 bind는 첫번째 매개변수 타입을 받도록 한 것이다.</p>\n<p>그리고 bind의 this의 나머지 매개변수들과 리턴 타입은 bind가 리턴하는 bounded function의 매개변수와 리턴 타입으로 정의된다. 그리고 <code>T</code>를 이용해서 bind의 this일 함수의 this 타입을 정의한다.</p>\n<p>다음과 같이 쓴다고 하면 bind의 thisArg가 <code>'hi'</code>가 되므로 <code>T</code>는 string이 되고 arg0은 2이므로 <code>A0</code>은 number다. 나머지 매개변수 A와 리턴타입 R은 add의 타입으로부터 추론되어 this는 <code>(this:string, args_0:number, b:number)=>number</code>가 되고 만들어지는 bounded function은 <code>(b:number)=>number</code>가 된다.</p>\n<pre><code class=\"language-ts\">function add(a: number, b: number) {\n  return a + b;\n}\n\nadd.bind('hi', 2);\n</code></pre>\n<p>비슷하게 bind에 매개변수가 4개인 것까지의 오버로딩도 이와 비슷한 느낌이다. 기존 함수의 매개변수 타입에서 n개의 매개변수 타입들을 떼어내고 나머지 매개변수들을 bounded function 매개변수 타입으로 넘겨주는 식으로 되어 있다. 마지막 오버로딩만 조금 다른데 다시 한번 옮기면 bind의 마지막 오버로딩은 이런 타입이다.</p>\n<pre><code class=\"language-ts\">bind&#x3C;T, AX, R>(this: (this: T, ...args: AX[]) => R, thisArg: T, ...args: AX[]): (...args: AX[]) => R;\n</code></pre>\n<p>그렇게 어려운 타입은 아니다. 하지만 앞선 오버로딩들이 원래 매개변수 갯수에서 몇 개를 빼는 방식으로 정의된 것과 달리 이는 원래 함수와 bounded function(bind의 리턴값)의 매개변수 타입이 <code>AX[]</code>로 같다.</p>\n<p>이는 bind에 제공되는 인수 개수에 따른 모든 오버로딩을 만들 수 없기 때문에 현실적으로 bind가 제대로 매개변수 갯수에 대한 타이핑을 할 수 있는 매개변수 갯수를 4개로 제한한 것이다.</p>\n<blockquote>\n<p>Note that the overloads of bind include up to four bound arguments beyond the this argument. (In the real world code we inspected in researching this PR, practically all uses of bind supplied only the this argument, and a few cases supplied one regular argument. No cases with more arguments were observed.)</p>\n</blockquote>\n<p><a href=\"https://github.com/microsoft/TypeScript/pull/27028\">Strict bind, call, and apply methods on functions PR</a>을 보면 조사 결과 bind가 실용적으로 사용된 코드 중 거의 전부가 <code>thisArg</code> 인수만 사용했으며 몇몇 경우에 하나의 bind argument를 사용했다고 한다. 그 이상의 매개변수를 bind에 넘겨주는 경우는 없었다고 한다. 따라서 이렇게 4개의 bind 인수까지만 오버로딩한 것은 괜찮아 보인다. 물론 이조차도 이후 개선된다.</p>\n<h3>3.2.3. 두번째 오버로딩 - 개선된 버전</h3>\n<p>지금 버전의 타입스크립트의 <code>lib.es5.d.ts</code>에 들어가면 bind의 2번째 오버로딩이 이렇게 정의되어 있다.</p>\n<pre><code class=\"language-ts\">bind&#x3C;T, A extends any[], B extends any[], R>(this: (this: T, ...args: [...A, ...B]) => R, thisArg: T, ...args: A): (...args: B) => R;\n</code></pre>\n<p><a href=\"https://github.com/microsoft/TypeScript/pull/50453\">검사기가 여러 개의 제네릭으로 이루어진 튜플을 검사할 수 있게 되어서 개선하게 되었다고 한다.</a></p>\n<p>이는 bind가 받은 thisArg 이후의 매개변수 타입들을 모두 모아서 하나의 튜플 타입 <code>A</code>로 정의하고 원래 bind의 this로 되어 있는 함수의 매개변수에서 앞쪽부터 <code>A</code>튜플 타입들을 뺀 나머지 매개변수 타입들을 <code>B</code>튜플 타입으로 정의한 것이다. this의 함수 타입의 <code>args</code> 가 <code>[...A, ...B]</code>타입인 건 그런 의미이다.</p>\n<p>또한 원래의 this 타입과 thisArg의 타입을 T로, 원래의 리턴타입과 bounded function의 리턴타입을 R 타입으로 정의해서 맞춰준 것도 볼 수 있다.</p>\n<h1>4. NewableFunction</h1>\n<p><code>NewableFunction</code>은 생성자 함수에 적용되는 bind, call, apply메서드 타입을 포함하는 타입이다.</p>\n<pre><code class=\"language-ts\">interface NewableFunction extends Function {\n    apply&#x3C;T>(this: new () => T, thisArg: T): void;\n    apply&#x3C;T, A extends any[]>(this: new (...args: A) => T, thisArg: T, args: A): void;\n    call&#x3C;T, A extends any[]>(this: new (...args: A) => T, thisArg: T, ...args: A): void;\n    bind&#x3C;T>(this: T, thisArg: any): T;\n    bind&#x3C;A extends any[], B extends any[], R>(this: new (...args: [...A, ...B]) => R, thisArg: any, ...args: A): new (...args: B) => R;\n}\n</code></pre>\n<h2>4.1. apply, call</h2>\n<p>전반적으로 <code>CallableFunction</code> 에서와 형태가 비슷하다.</p>\n<pre><code class=\"language-ts\">// CallableFunction의 apply, call\napply&#x3C;T, R>(this: (this: T) => R, thisArg: T): R;\napply&#x3C;T, A extends any[], R>(this: (this: T, ...args: A) => R, thisArg: T, args: A): R;\ncall&#x3C;T, A extends any[], R>(this: (this: T, ...args: A) => R, thisArg: T, ...args: A): R;\n\n// NewableFunction의 apply, call\napply&#x3C;T>(this: new () => T, thisArg: T): void;\napply&#x3C;T, A extends any[]>(this: new (...args: A) => T, thisArg: T, args: A): void;\ncall&#x3C;T, A extends any[]>(this: new (...args: A) => T, thisArg: T, ...args: A): void;\n</code></pre>\n<p>매개변수를 <code>A</code>제네릭으로 처리하는 방식은 거의 똑같아서 특별히 볼 게 없다. 그냥 생성자 함수에 들어가야 할 인수들을 그대로 call, apply에도 넘겨줘야 하도록 한 것이다.</p>\n<p>볼 만한 건 왜 함수 타입에 <code>new</code>가 붙었으며 this의 타입은 this함수의 this 타입에서 this 함수의 리턴타입으로 바뀌었는지 정도다.</p>\n<p>그건 해당 메서드 타입 오버로딩이 어떤 경우에 쓰이는지 보면 쉽게 알 수 있다. <a href=\"https://github.com/microsoft/TypeScript/pull/27028\">해당 타이핑이 도입된 PR</a>의 코드를 약간 변형했다.</p>\n<p>이런 경우 NewableFunction의 apply, call 메서드 타입이 쓰인다.</p>\n<pre><code class=\"language-ts\">class Person {\n  constructor(public name: string, public age: number) {\n    this.name = name;\n    this.age = age;\n  }\n}\n\ndeclare let p: Person;\n\nlet pBind = Person.bind({}, \"Mark\");\nlet pCall = Person.call(p, \"Mark\", 39);\nlet pApply = Person.apply(p, [\"Mark\", 39]);\n</code></pre>\n<p>해당 타입이 <code>new Person()</code>과 같은 방식으로 호출될 때 쓰이는 클래스 생성자 함수에 적용되는 call, apply라는 것을 알 수 있다. 따라서 call, apply의 첫번째 인자로 오는 this가 되는 것은 클래스 생성자 함수이다. 위의 경우 <code>Person</code>이 call의 this이다. 이 생성자 함수는 new와 함께 호출되었을 경우 Person의 인스턴스를 리턴한다.</p>\n<p>그런데 call, apply에서 thisArg로 받아야 하는 것은 클래스의 동작 원리상 Person의 인스턴스와 같은 타입을 가져야 한다. 생성자 함수 실행시 this로 빈 객체가 생성되고 거기에 인스턴스 프로퍼티들이 들어가는 방식으로 작동하기 때문이다. 위에서도 인수로 Person 인스턴스 타입을 갖는 p를 넘겨줬다.</p>\n<p>즉 call, apply의 인수 this는 생성자 함수인데 생성자 함수에 제공해야 할 this는 생성자 함수로 만드는 인스턴스 타입이다. 따라서 제네릭을 이용해서 인수 this가 반환하는 인스턴스 타입을 T로 정의한 후 이를 thisArg로 받은 것이다.</p>\n<h2>4.2. bind</h2>\n<pre><code class=\"language-ts\">bind&#x3C;T>(this: T, thisArg: any): T;\nbind&#x3C;A extends any[], B extends any[], R>(this: new (...args: [...A, ...B]) => R, thisArg: any, ...args: A): new (...args: B) => R;\n</code></pre>\n<p>첫번째 오버로딩에서 <code>ThisParameterType</code>, <code>OmitThisParameter</code>를 쓰지 않은 것을 볼 수 있다. 이는 JS에서 클래스가 this bind를 무시하기 때문에 굳이 this를 인수 타입에서 제거해 줄 필요가 없기 때문이다. 또한 어차피 무시되기 때문에 thisArg도 any로 할 수 있다.</p>\n<p>단 bind된 인수는 정상적으로 작동한다. 예를 들어 <code>pBind</code>의 타입은 <code>new (age: number) => Person</code>이다. bind한 결과물 역시 생성자 함수이기 때문에 <code>new</code>가 붙었다.</p>\n<pre><code class=\"language-ts\">class Person {\n  constructor(public name: string, public age: number) {\n    this.name = name;\n    this.age = age;\n  }\n}\n\n// this로 null을 bind했지만 무시되고 그대로 typeof Person이 된다\nlet p0 = Person.bind(null);\n// bind인수는 잘 작동해서 pBind: new (age: number) => Person 타입이 됨\nlet pBind = Person.bind({}, \"Mark\");\n</code></pre>\n<p>이런 동작을 구현하는 게 바로 NewableFunction의 bind의 두번째 오버로딩이다. 역시 thisArg는 any이다. 하지만 CallableFunction에서와 같은 원리로 bind에서 받은 인수를 제거한 인수들을 bounded function의 매개변수 타입으로 정의한다.</p>\n<h1>5. 제네릭과 오버로딩의 문제</h1>\n<p><a href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-2.html\">TS 3.2 릴리즈 노트</a>에 보면 아직 이 타입에 문제가 남아 있다고 한다. bind, call, apply의 오버로드가 제네릭 함수 타입을 제대로 모델링하지 못한다는 것이다.</p>\n<p><a href=\"https://github.com/Microsoft/TypeScript/pull/27028\">strictBindCallApply가 처음 도입된 PR에 이미 이슈가 올라와 있다.</a> 거기서 제시한 문제의 코드는 다음과 같다.</p>\n<pre><code class=\"language-ts\">function foo&#x3C;T>(name: string, arg: T): T {\n  return arg;\n}\n\n// fooFunction: (arg: unknown) => unknown\nlet fooFunction = foo.bind(undefined, \"Matt\");\n// fooResult: unknown\nlet fooResult = foo.bind(undefined, \"Matt\")(\"TypeScript\");\n\nfunction bar(name: string, arg: number): number;\nfunction bar(name: string, arg: string): string;\nfunction bar(name: string, arg: string | number) {\n  console.log(name);\n  return typeof arg === \"number\" ? arg + 1 : arg + \"1\";\n}\n\n// Error: Argument of type 'number' is not assignable to parameter of type 'string'.\nlet barResult = bar.bind(undefined, \"Matt\")(5);\n</code></pre>\n<p>위 코드에서 <code>fooFunction</code>은 사실 <code>(arg: T) => T</code>타입이 되는 게 맞다. 하지만 타입 인수는 사라지고 <code>unknown</code>타입으로 바뀌어 버린다. 또한 <code>fooResult</code>의 경우 <code>T</code>를 위한 string 타입 매개변수가 바로 들어갔으니 <code>unknown</code>이 아니라 <code>string</code>이 되어야 한다. 하지만 <code>unknown</code>이 된다.</p>\n<p>참고로 이는 TS 3.5 이전까지는 원래 <code>{}</code>타입이었지만 <a href=\"https://github.com/Microsoft/TypeScript/pull/30637\">타입 인수의 기본값이 <code>unknown</code>으로 바뀌면서</a> <code>unknown</code>으로 바뀌었다.</p>\n<p>비슷하게 bar의 경우에도 위처럼 하면 bind가 첫번째 오버로딩에 적용되어야 한다. 하지만 엉뚱한 오버로딩에 적용되어 타입 에러가 발생하는 것을 볼 수 있다.</p>\n<p><a href=\"https://github.com/microsoft/TypeScript/issues/54707\">여기에 대한 이슈가 올해에도 개설되어 있다.</a> <a href=\"https://stackoverflow.com/questions/76924554/why-doesnt-typescript-correctly-infer-this-type\">하지만 스택오버플로우에 TS 컨트리뷰터 중 한 명의 답변에 의하면 당장 개선 예정은 없다고 한다.</a></p>\n<h2>5.1. 임시방편</h2>\n<p>이를 지금 시점에서 어느 정도 해결하는 방법은 함수 타입 제네릭 인자에 직접 타입을 넘겨서 더 이상 제네릭이 아니게 만드는 것이다. fooResult의 경우에는 다음과 같이 하면 된다.</p>\n<pre><code class=\"language-ts\">let fooResult = (foo&#x3C;string>).bind(undefined, \"Matt\")(\"TypeScript\");\n</code></pre>\n<p>이런 식으로 타입 제네릭 인자에 타입을 넘겨주면 <a href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html#instantiation-expressions\">Instantiation Expressions</a>이 되어서 더 이상 함수가 제네릭 타입으로 취급되지 않는다. 따라서 타입 제네릭 인자가 사라지는 문제가 발생할 가능성이 없어진다.</p>\n<p><code>foo&#x3C;string></code>은 <code>(name: string, arg: string) => string</code>타입이 되고 이런 식으로 bind 타입 정의를 따라가 보면 <code>fooResult</code>의 타입은 <code>string</code>이 된다.</p>\n<p>하지만 이렇게 하면 함수를 제네릭으로 선언한 이점이 많이 사라질 수 있어서 완전한 해결책은 물론 아니다. 그래도 임시방편조차 없는 오버로딩 문제에 비하면 나은 듯 하다.</p>\n<h1>참고</h1>\n<p>조현영 - 타입스크립트 교과서</p>\n<p>What is the NewableFunction interface used for? <a href=\"https://stackoverflow.com/questions/74368378/what-is-the-newablefunction-interface-used-for\">https://stackoverflow.com/questions/74368378/what-is-the-newablefunction-interface-used-for</a></p>\n<p>bind(), call(), and apply() are untyped <a href=\"https://github.com/microsoft/TypeScript/issues/212\">https://github.com/microsoft/TypeScript/issues/212</a></p>\n<p>Tuples in rest parameters and spread expressions <a href=\"https://github.com/microsoft/TypeScript/pull/24897\">https://github.com/microsoft/TypeScript/pull/24897</a></p>\n<p>타입스크립트 PR, Strict bind, call, and apply methods on functions <a href=\"https://github.com/microsoft/TypeScript/pull/27028\">https://github.com/microsoft/TypeScript/pull/27028</a></p>\n<p>Proposal: Variadic Kinds -- Give specific types to variadic functions <a href=\"https://github.com/microsoft/TypeScript/issues/5453\">https://github.com/microsoft/TypeScript/issues/5453</a></p>\n<p>lib Fix Part 5/6 – Function.{apply, bind} <a href=\"https://github.com/microsoft/TypeScript/pull/50453\">https://github.com/microsoft/TypeScript/pull/50453</a></p>\n<p>TypeScript 3.2 release note <a href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-2.html\">https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-2.html</a></p>\n<p>Strict Bind Call Apply - strictBindCallApply <a href=\"https://www.typescriptlang.org/tsconfig#strictBindCallApply\">https://www.typescriptlang.org/tsconfig#strictBindCallApply</a></p>\n<p>Generics are lost during Function.prototype.bind() and Function.prototype.call() <a href=\"https://github.com/microsoft/TypeScript/issues/54707\">https://github.com/microsoft/TypeScript/issues/54707</a></p>\n<p>Why doesn't TypeScript correctly infer <code>this</code> type? <a href=\"https://stackoverflow.com/questions/76924554/why-doesnt-typescript-correctly-infer-this-type\">https://stackoverflow.com/questions/76924554/why-doesnt-typescript-correctly-infer-this-type</a></p>\n<p>Change the default type parameter constraints and defaults to unknown from {} <a href=\"https://github.com/Microsoft/TypeScript/pull/30637\">https://github.com/Microsoft/TypeScript/pull/30637</a></p>",
    "excerpt": "타입스크립트 교과서를 읽다가 TS의 lib.es5.d.ts를 직접 열어보게 되었다. 그리고 Function.prototype에 속해 있는 call, apply, bind 메서드의 타입을 보았는데 흥미로운 부분이 있어서 글을 쓰게 되었다. 보충할 수 있는 내용이 많겠지만 일단 지금 할 수 있는 만큼 정리해보았다.\n1. this 유틸리티 타입\n글에서 다룰 타입에 쓰이는 this 관련 유틸리티 타입을 먼저 보고 넘어가자. 실제 파일에서는 Function타입 다음에 정",
    "headingTree": [
      {
        "title": "1. this 유틸리티 타입",
        "url": "#1-this-유틸리티-타입",
        "items": [
          {
            "title": "1.1. ThisParameterType",
            "url": "#11-thisparametertype",
            "items": []
          },
          {
            "title": "1.2. OmitThisParameter",
            "url": "#12-omitthisparameter",
            "items": []
          }
        ]
      },
      {
        "title": "2. Function",
        "url": "#2-function",
        "items": [
          {
            "title": "2.1. Function 인터페이스",
            "url": "#21-function-인터페이스",
            "items": []
          },
          {
            "title": "2.2. Function 타입의 사용",
            "url": "#22-function-타입의-사용",
            "items": []
          },
          {
            "title": "2.3. 이 타입은 왜 이렇게 허술할까?",
            "url": "#23-이-타입은-왜-이렇게-허술할까",
            "items": []
          }
        ]
      },
      {
        "title": "3. CallableFunction",
        "url": "#3-callablefunction",
        "items": [
          {
            "title": "3.1. apply, call",
            "url": "#31-apply-call",
            "items": []
          },
          {
            "title": "3.2. bind",
            "url": "#32-bind",
            "items": [
              {
                "title": "3.2.1. 첫번째 오버로딩",
                "url": "#321-첫번째-오버로딩",
                "items": []
              },
              {
                "title": "3.2.2. 두번째 오버로딩 - 이전 버전",
                "url": "#322-두번째-오버로딩---이전-버전",
                "items": []
              },
              {
                "title": "3.2.3. 두번째 오버로딩 - 개선된 버전",
                "url": "#323-두번째-오버로딩---개선된-버전",
                "items": []
              }
            ]
          }
        ]
      },
      {
        "title": "4. NewableFunction",
        "url": "#4-newablefunction",
        "items": [
          {
            "title": "4.1. apply, call",
            "url": "#41-apply-call",
            "items": []
          },
          {
            "title": "4.2. bind",
            "url": "#42-bind",
            "items": []
          }
        ]
      },
      {
        "title": "5. 제네릭과 오버로딩의 문제",
        "url": "#5-제네릭과-오버로딩의-문제",
        "items": [
          {
            "title": "5.1. 임시방편",
            "url": "#51-임시방편",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 6,
      "wordCount": 1664
    },
    "url": "/posts/typescript-basic-function-type",
    "thumbnail": {
      "local": "/thumbnails/typescript-basic-function-type-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-typescript-basic-function-type-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAk0lEQVR4nE3BIQ7DIBQAUFQPwQUqq7gAAonsBZp8heIAJCjSOm6wLc2WjARHgsLh0BVcgQuQTDC1ZO8h7z1jDACWZRFCaK0ppa01tB/HPM9SSkKIc673XmvtvSNjDMaYUjpNEwBs28YY45yjGOO6rkopa23OuZQSQkgpodv9AQDGmOu6xh/0evvzfIYQaq1jjM/PF6AjVw+K++jnAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "typescript-capital-letter",
    "title": "TS 탐구생활 - Object vs object, Number vs number",
    "date": "2023-09-16T00:00:00Z",
    "description": "number, object는 되고 Number, Object는 쓰면 안 되는 이유",
    "tags": [
      "typescript",
      "javascript"
    ],
    "html": "<h1>1. 왜 object는 되고 Object는 안 되는 걸까?</h1>\n<p>TS를 사용하다 보면 내장 객체들의 타입을 사용하게 될 때가 있다. 가령 다음과 같이 말이다.</p>\n<pre><code class=\"language-ts\">const date:Date = new Date();\n</code></pre>\n<p>또한 <code>[]</code>를 이용한 표기도 있기 때문에 취향 차이긴 하지만 <code>Array</code>라는 내장 객체 타입도 사용할 수 있다.</p>\n<pre><code class=\"language-ts\">const arr:Array&#x3C;number> = [1,2,3];\n</code></pre>\n<p>그러면 비슷하게 <code>Number</code>나 <code>String</code> 같은 타입도 있을 거라는 생각이 든다. 실제로 있다. 하지만 TS를 처음 배우게 되면 알다시피 숫자를 나타내는 원시값 타입은 <code>number</code>이다.</p>\n<p>또한 <code>Object</code>타입도 있는데, <code>Object</code>대신 <code>object</code>를 쓰라고 한다. 우리가 써야 하는 다른 원시값 타입들도 소문자로 쓰여 있기는 마찬가지다. 무슨 차이가 있는 걸까?</p>\n<h1>2. Object</h1>\n<p>JS에서는 모든 것이 객체이다. 모든 객체는 결국 <code>Object</code> 생성자 함수의 <code>Object.prototype</code>를 프로토타입으로 가지며 이것을 이유로 우리는 <code>Object.prototype</code>에 정의된 메서드를 사용할 수 있다. 즉 모든 객체는 <code>Object</code>를 확장한다고 볼 수 있는 것이다.</p>\n<p>그리고 <code>Object</code>타입은 바로 이 <code>Object</code>생성자의 프로토타입 체인에 있는 모든 생성자 함수를 통해 생성된 모든 객체를 의미한다. 그런데 JS의 모든 생성자 함수들은 <code>Object</code>를 상속받는다. 따라서 타입스크립트의 타입 특성상 <code>Object</code>에는 null, undefined 외에 모든 JS 객체가 들어갈 수 있다. 함수도 물론 가능하다.</p>\n<pre><code class=\"language-ts\">const foo:Object=(a:number)=>a+1;\n</code></pre>\n<h2>2.1. Object 타입 정의</h2>\n<p>그럼 <code>Object</code>타입은 어떻게 정의되어 있을까? <code>Object</code>타입은 <code>node_modules/typescript/lib/lib.es5.d.ts</code>에 다음과 같이 정의되어 있다. <code>Object</code>생성자를 통해 만들어진 객체들이 가져야 할 모든 메서드를 담고 있다.</p>\n<pre><code class=\"language-ts\">interface Object {\n    /** The initial value of Object.prototype.constructor is the standard built-in Object constructor. */\n    constructor: Function;\n\n    /** Returns a string representation of an object. */\n    toString(): string;\n\n    /** Returns a date converted to a string using the current locale. */\n    toLocaleString(): string;\n\n    /** Returns the primitive value of the specified object. */\n    valueOf(): Object;\n\n    /**\n     * Determines whether an object has a property with the specified name.\n     * @param v A property name.\n     */\n    hasOwnProperty(v: PropertyKey): boolean;\n\n    /**\n     * Determines whether an object exists in another object's prototype chain.\n     * @param v Another object whose prototype chain is to be checked.\n     */\n    isPrototypeOf(v: Object): boolean;\n\n    /**\n     * Determines whether a specified property is enumerable.\n     * @param v A property name.\n     */\n    propertyIsEnumerable(v: PropertyKey): boolean;\n}\n</code></pre>\n<h2>2.2. Object 생성자 타입</h2>\n<p>그런데 <code>Object.keys()</code>처럼 Object 생성자 함수 자체에 정적으로 정의된 메서드들도 있지 않은가? 이는 생성자 함수를 나타내는 <code>ObjectConstructor</code>라는 인터페이스에 정의되어 있다. <code>new</code>와 함께 호출하면 <code>Object</code>타입 객체를 생성한다.</p>\n<p>생성자 함수답게 <code>Object.prototype</code>으로 <code>Object</code>를 정의하고 있는 부분도 볼 수 있다. 그렇게 해야 해당 생성자로 생성된 객체들이 프로토타입으로 <code>Object</code>를 가지게 되기 때문이다. 이런 프로토타입 상속에 관해서 지식이 필요하다면 <a href=\"https://witch.work/posts/javascript-prototype-grammar\">JS 탐구생활 - 프로토타입 문법</a>에서 다루었다.</p>\n<pre><code class=\"language-ts\">interface ObjectConstructor {\n    new(value?: any): Object;\n    (): any;\n    (value: any): any;\n\n    /** A reference to the prototype for a class of objects. */\n    readonly prototype: Object;\n\n    /* 다른 메서드들은 길이 관계상 생략 */\n\n    /**\n     * Returns the names of the enumerable string properties and methods of an object.\n     * @param o Object that contains the properties and methods. This can be an object that you created or an existing Document Object Model (DOM) object.\n     */\n    keys(o: object): string[];\n}\n</code></pre>\n<h1>3. 래퍼 객체 타입</h1>\n<p>그럼 <code>Number</code>, <code>String</code> 같은 타입들은 뭘까? 비슷하게 해당 생성자로 생성된 모든 객체들(래퍼 객체로 쓰이는)을 대표하는 타입이다. 생성자 함수는 <code>NumberConstructor</code>와 같은 타입으로 정의되어 있다.</p>\n<h2>3.1. 래퍼 객체</h2>\n<p>잠시 JS로 돌아가 보자. JS를 하다 보면 분명 원시값에 없는 메서드나 프로퍼티인데 쓸 수 있는 경우가 있다. <code>\"hello\"</code>같은 문자열의 경우 그냥 문자열 값인데도 <code>length</code>나 <code>indexOf</code>같은 메서드를 사용할 수 있지 않은가? 그러면 이것들은 어디서 온 것일까?</p>\n<p>이를 가능하게 해 주는 것이 바로 래퍼 객체다. 객체나 리터럴에 접근해서 프로퍼티나 메서드를 참조하려고 하면 해당 객체의 생성자를 호출하여 래퍼 객체를 만들어 준다. 이 래퍼 객체는 해당 객체의 프로퍼티나 메서드를 가지고 있기 때문에 사용할 수 있는 것이다.</p>\n<p>예를 들어 다음과 같은 코드가 있다고 하면, <code>str.length</code>에 접근할 때 JS는 <code>new String(str)</code>을 호출하여 래퍼 객체를 만들어 준다. 그리고 이 래퍼 객체를 참조하여 문자열의 길이 5를 가져온다.</p>\n<pre><code class=\"language-js\">const str = \"hello\";\nconsole.log(str.length); // 5\n</code></pre>\n<p>이런 래퍼 객체는 <code>String</code>, <code>Number</code>, <code>BigInt</code>, <code>Boolean</code>, <code>Symbol</code>의 5종류가 있다. 각각이 <code>new String(~~)</code>과 같은 생성자 함수를 통해 만들어지는 객체이다.</p>\n<h2>3.2. 래퍼 객체 타입의 문제</h2>\n<p>앞에서 보았던 <code>Number</code>나 <code>String</code>같은 타입들은 모두 래퍼 객체의 타입이다. 정확히는 해당 생성자로 만들어진 모든 객체의 타입이라고 할 수 있겠다. 예를 들어 <code>Number</code>같은 경우 <code>new Number(숫자)</code>로 만들어진 모든 숫자 래퍼 객체를 대표하는 타입이다. 이에 대해서는 다음 섹션에서 더 자세히 다루겠다.</p>\n<p>그럼 왜 이런 래퍼 객체 타입을 사용하면 안 되는 걸까? 래퍼 객체 타입을 사용하면 다음과 같은 문제가 발생한다.</p>\n<p>그런데 우리가 일반적으로 변수 등을 통해 원시값을 사용할 때는 그 래퍼 객체를 사용하는 것이 아니라 원시값의 데이터를 사용하고 싶은 것이기 때문이다.</p>\n<p>만약 타입을 이런 래퍼 객체 타입으로 지정하면 아주 기본적인 연산조차 할 수가 없어진다. 둘 다 숫자의 래퍼 객체 타입인데 래퍼 객체 간에는 더하기가 있을 수 없기 때문이다.</p>\n<pre><code class=\"language-ts\">// Operator '+' cannot be applied to types 'Number' and 'Number'.\nconst a:Number=3, b:Number=4;\nconsole.log(a+b);\n</code></pre>\n<p>반면 <code>Number</code>의 래퍼 객체에 있는 메서드, <code>toString</code>같은 건 잘 사용할 수 있다.</p>\n<pre><code class=\"language-ts\">const a:Number=3;\nconsole.log(a.toString());\n</code></pre>\n<p>하지만 우리가 원시값을 대입한 변수를 사용할 때 해당 래퍼 객체가 필요한 경우는 거의 없고, 있더라도 원시값 타입으로 지정해 주어도 어차피 래퍼 객체가 필요한 경우 알아서 잘 사용된다. 이런 이유로 제한만 더해지고 필요한 동작은 더 이상 사용할 수 없는 래퍼 객체 타입을 사용하는 것은 좋지 않다.</p>\n<h1>4. 래퍼 객체 보기</h1>\n<p>일반적으로 <code>node_modules</code>에 위치한 타입스크립트의 타입 정의 파일에 가면 이 타입들을 직접 보고 <code>Number</code>와 같은 타입들이 해당 객체 생성자로 만들어진 객체들을 포괄하는 타입임을 확인할 수 있다.</p>\n<h2>4.1. 타입 정의</h2>\n<p>예를 들어 <code>Number</code>타입은 <code>node_modules/typescript/lib/lib.es2020.number.d.ts</code>에 다음과 같이 정의되어 있다.</p>\n<pre><code class=\"language-ts\">interface Number {\n    /**\n     * Converts a number to a string by using the current or specified locale.\n     * @param locales A locale string, array of locale strings, Intl.Locale object, or array of Intl.Locale objects that contain one or more language or locale tags. If you include more than one locale string, list them in descending order of priority so that the first entry is the preferred locale. If you omit this parameter, the default locale of the JavaScript runtime is used.\n     * @param options An object that contains one or more properties that specify comparison options.\n     */\n    toLocaleString(locales?: Intl.LocalesArgument, options?: Intl.NumberFormatOptions): string;\n}\n</code></pre>\n<p>우리가 아는 다른 숫자형의 메서드, <code>toFixed</code>같은 것은 또 같은 위치에 <code>lib.es5.d.ts</code>에 정의되어 있다.</p>\n<p>문자열의 경우 버전에 따른 변경사항도 기능도 많아서 그런지 더 여러 파일에 나누어져 있는데 아까 보았던 <code>lib.es5.d.ts</code>에 보면 우리가 아는 많은 문자열 메서드들이 타입으로 정의되어 있다. 사실 이외에도 꽤 많은데 어쨌건 우리가 아는 문자열 메서드들이 대부분 정의되어 있다.</p>\n<pre><code class=\"language-js\">interface String {\n    /** Returns a string representation of a string. */\n    toString(): string;\n\n    /* (생략) */\n\n    /**\n     * Returns the position of the first occurrence of a substring.\n     * @param searchString The substring to search for in the string\n     * @param position The index at which to begin searching the String object. If omitted, search starts at the beginning of the string.\n     */\n    indexOf(searchString: string, position?: number): number;\n\n    /* 생략 */\n\n    /** Returns the length of a String object. */\n    readonly length: number;\n\n    /* 생략 */\n\n    readonly [index: number]: string;\n}\n</code></pre>\n<p>그리고 es2015 변경사항들이 있는 <code>lib.es2015.core.d.ts</code>, 반복자 타입에 대해 정의된 <code>lib.es2015.iterable.d.ts</code>, 잘 알려진 심볼들이 정의된 <code>lib.es2015.symbol.wellknown.d.ts</code>등에도 문자열 래퍼 객체와 관련된 속성들이 타입으로 정의되어 있다.</p>\n<h2>4.2. 생성자 함수 타입</h2>\n<p>생성자 함수들의 타입도 <code>lib.es5.d.ts</code>에 정의되어 있다. <code>NumberConstructor</code>의 경우 다음과 같다. 위의 <code>ObjectConstructor</code>처럼 new와 함께 호출시 <code>Number</code>를 반환하고, <code>MAX_VALUE</code>와 같이 <code>Number</code>생성자 함수(타입 말고)에 정적으로 정의되어 있는 속성들도 확인할 수 있다.</p>\n<p>개인적으로는 <code>NaN</code>이 여기에 속성으로 정의된 게 신기한 점이다.</p>\n<pre><code class=\"language-ts\">interface NumberConstructor {\n    new(value?: any): Number;\n    (value?: any): number;\n    readonly prototype: Number;\n\n    /** The largest number that can be represented in JavaScript. Equal to approximately 1.79E+308. */\n    readonly MAX_VALUE: number;\n\n    /** The closest number to zero that can be represented in JavaScript. Equal to approximately 5.00E-324. */\n    readonly MIN_VALUE: number;\n\n    /**\n     * A value that is not a number.\n     * In equality comparisons, NaN does not equal any value, including itself. To test whether a value is equivalent to NaN, use the isNaN function.\n     */\n    readonly NaN: number;\n\n    /* 이하 생략 */\n}\n</code></pre>\n<h1>5. 정리</h1>\n<p><code>Number</code>나 <code>Object</code>처럼 대문자로 시작하는 내장 객체들의 이름 타입들은 해당 생성자로 생성된 객체들을 모두 포괄하는 타입이다.</p>\n<p>그런데 <code>Number</code>와 같은 원시값은 래퍼 객체 자체가 목적으로 쓰일 때가 얼마 없고, <code>Object</code>는 모든 객체 생성자가 원래 <code>Object</code> 생성자 함수를 상속받기 때문에 너무 모든 타입을 포괄할 수 있다. 따라서 우리는 목적에 맞게 원시값, 혹은 오직 객체만을 포괄하는 <code>number</code>, <code>object</code>를 사용한다.</p>\n<h2>5.1. 다른 내장 객체 타입</h2>\n<p>위에서 보았던 <code>Array</code>나 <code>Date</code>같은 다른 내장 객체들은 원래 객체이고, 객체를 목적으로 쓰이기 때문에 해당 생성자들이 생성한 객체들을 포괄하는 타입으로 써도 상관없다. 그래서 <code>array</code>같은 타입이 따로 없는 것이다.</p>\n<p><code>lib.es5.d.ts</code>를 찾아봐도 <code>Array</code>는 <code>ArrayConstructor</code>라는 생성자 함수가 생성한 객체들을 포괄하는 타입으로, 또 <code>Date</code>는 <code>DateConstructor</code>라는 생성자 함수가 생성한 객체들을 포괄하는 타입이다. 하지만 여기서는 그게 전혀 문제가 되지 않는다. <code>new Array</code>로 생성한 배열 객체는 어떤 래퍼 같은 게 아니라 그 자체가 목적이 되는 객체이기 때문이다.</p>",
    "excerpt": "1. 왜 object는 되고 Object는 안 되는 걸까?\nTS를 사용하다 보면 내장 객체들의 타입을 사용하게 될 때가 있다. 가령 다음과 같이 말이다.\nconst date:Date = new Date();\n\n또한 []를 이용한 표기도 있기 때문에 취향 차이긴 하지만 Array라는 내장 객체 타입도 사용할 수 있다.\nconst arr:Array<number> = [1,2,3];\n\n그러면 비슷하게 Number나 String 같은 타입도 있을 거라는 생각이 든다. ",
    "headingTree": [
      {
        "title": "1. 왜 object는 되고 Object는 안 되는 걸까?",
        "url": "#1-왜-object는-되고-object는-안-되는-걸까",
        "items": []
      },
      {
        "title": "2. Object",
        "url": "#2-object",
        "items": [
          {
            "title": "2.1. Object 타입 정의",
            "url": "#21-object-타입-정의",
            "items": []
          },
          {
            "title": "2.2. Object 생성자 타입",
            "url": "#22-object-생성자-타입",
            "items": []
          }
        ]
      },
      {
        "title": "3. 래퍼 객체 타입",
        "url": "#3-래퍼-객체-타입",
        "items": [
          {
            "title": "3.1. 래퍼 객체",
            "url": "#31-래퍼-객체",
            "items": []
          },
          {
            "title": "3.2. 래퍼 객체 타입의 문제",
            "url": "#32-래퍼-객체-타입의-문제",
            "items": []
          }
        ]
      },
      {
        "title": "4. 래퍼 객체 보기",
        "url": "#4-래퍼-객체-보기",
        "items": [
          {
            "title": "4.1. 타입 정의",
            "url": "#41-타입-정의",
            "items": []
          },
          {
            "title": "4.2. 생성자 함수 타입",
            "url": "#42-생성자-함수-타입",
            "items": []
          }
        ]
      },
      {
        "title": "5. 정리",
        "url": "#5-정리",
        "items": [
          {
            "title": "5.1. 다른 내장 객체 타입",
            "url": "#51-다른-내장-객체-타입",
            "items": []
          }
        ]
      }
    ],
    "metadata": {
      "readingTime": 2,
      "wordCount": 630
    },
    "url": "/posts/typescript-capital-letter",
    "thumbnail": {
      "local": "/thumbnails/typescript-capital-letter-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-typescript-capital-letter-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAiklEQVR4nGPYsGFDQEBAaWmphYVFTk7O//////z58///f4a2tjZlZeXo6OicnJxjx44hJHp6enh4eHJycjIzM0tLS0NDQ9euXQuSWLF8ua2tra+vr7GxcVVV1bFjx+7fvw+SOH3m7KbNmzds2HDgwIGXL1/+hwGGtes3rVm7bu/evXfu3IFYALEDAKPWYTpR+FUMAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "typescript-covariance-in-real-ts",
    "title": "TS 탐구생활 - 가변성(Variance)과 TS",
    "date": "2023-12-13T00:00:00Z",
    "description": "TS는 가변성을 어떻게 다루고 있을까?",
    "tags": [
      "typescript"
    ],
    "html": "<h1>이 글은 현재 작성 중입니다.</h1>\n<hr>\n<ul>\n<li>이 글은 읽는 사람이 슈퍼타입, 서브타입, 제네릭 등 기본적인 타입 시스템의 개념은 알고 있다는 가정하에 쓰여지는 글이다.</li>\n</ul>\n<p>TS를 더 잘 이해하기 위해 타입 시스템을 공부하다가 가변성(variance)이라는 개념을 만났다. 그래서 이와 관련해서 2개의 글을 썼다. <a href=\"https://witch.work/posts/typescript-covariance-theory\">첫번째 글에서는 가변성이라는 게 무엇인지 알아보았다.</a> 그리고 두 번째 글(이 글)에서는 가변성이라는 개념이 TS에 녹아 있는 부분 몇 가지를 알아볼 것이다.</p>\n<p>이 글에서는 전체적으로 TS에서 가변성을 어떻게 다루고 있는지를 알아보고, TS에서 가변성을 다루는 방식에 대해서 흥미로운 사실들을 알아본다.</p>\n<p>이 글에서 쓰인 언어는 따로 언급이 없을 경우 TS 문법을 따른다.</p>\n<p>그리고 객체가 변경 가능하지 않다는 immutable의 경우 보통 불변으로 번역되는데, 불변(invariance)와의 혼동을 막기 위해 그냥 <code>immutable</code>로 그대로 쓴다. 반대되는 개념인 mutable도 마찬가지로 <code>mutable</code>그대로 쓴다.</p>\n<p>가변성에 관련된 다른 용어인 공변(covariance), 반변(contravariance), 불변(invariance), 양변(bivariance)의 번역은 홍재민 님의 <a href=\"https://product.kyobobook.co.kr/detail/S000210397750\">타입으로 견고하게 다형성으로 유연하게</a>의 번역을 따랐다.</p>\n<p><img src=\"/static/variance-picture-5a939c8f.png\" alt=\"가변성 이미지\"></p>\n<h1>1. TS에서 가변성 다루기</h1>\n<p><a href=\"https://witch.work/posts/typescript-covariance-theory\">TS 탐구생활 - 가변성(Variance)이란 무엇인가</a>에서는 가변성에 어떤 종류가 있는지 그리고 그걸 정하는 방식에는 어떤 방식이 있는지를 알아보았다. 그럼 TS에서는 어떻게 가변성을 다루고 있을까?</p>\n<h2>1.1. 가변성 기본설정</h2>\n<p>TS의 타입 시스템이 가변성을 다루는 방식은 기본적으로 다음과 같다.</p>\n<ul>\n<li>기본적으로 공변(covariant)이다.</li>\n<li>tsconfig.json의 <code>strictFunctionTypes</code>옵션이 true이면 함수 매개변수는 반변(contravariant), false이면 양변(bivariant)이다.</li>\n</ul>\n<p>따라서 <code>Array&#x3C;T></code>와 같은 타입들은 공변이다. <code>number</code>가 <code>string | number</code>의 서브타입이니 <code>Array&#x3C;number></code>가 <code>Array&#x3C;string | number></code>의 서브타입인 식이다.</p>\n<pre><code class=\"language-ts\">const numberArray: Array&#x3C;number> = [1, 2, 3];\n// stringNumberArray은 numberArray와 같은 배열 객체를 참조하고 있다\nconst stringNumberArray: Array&#x3C;string | number> = numberArray;\n</code></pre>\n<p>또한 TS는 구조를 통해서 서브타입을 판단하기 때문에 타입 검사기가 알아서 타입들 간의 서브타입 관계를 결정하고 위의 기본적인 가변성 설정을 적용한다.</p>\n<p>다음 예시 코드를 보면 <code>Person</code>과 <code>Student</code>사이에 아무 서브타입 관계를 지정하지 않았다. 그런데 타입 검사기가 알아서 <code>Student</code>가 <code>Person</code>의 서브타입이라고 판단하고 <code>ReadOnlyList&#x3C;T></code>를 공변으로 판단하는 걸 볼 수 있다.</p>\n<pre><code class=\"language-ts\">interface Person{\n    age:number;\n}\n\ninterface Student{\n    age:number;\n    grade:number;\n}\n\nclass ReadOnlyList&#x3C;T>{\n    arr:Array&#x3C;T>;\n    get:(idx:number)=>T=(idx:number)=>{return this.arr[idx];};\n\n    constructor(arr:Array&#x3C;T>){\n        this.arr=arr;\n    }\n}\n\nlet list:ReadOnlyList&#x3C;Person>=new ReadOnlyList&#x3C;Student>([]);\n// list2 할당은 에러 - ReadOnlyList&#x3C;Person> 타입을 ReadOnlyList&#x3C;Student>에 할당할 수는 없다\nlet list2:ReadOnlyList&#x3C;Student>=new ReadOnlyList&#x3C;Person>([]);\n</code></pre>\n<p>함수 매개변수 타입의 반변에 대해서도 비슷하게 해보면 서브타입 관계가 자동으로 판단되고 잘 작동하는 것을 볼 수 있다.</p>\n<p>물론 <code>extends</code> 키워드를 이용해서 직접 서브타입 관계를 정의하더라도 잘 작동한다.</p>\n<h2>1.2. 직접 가변성 설정하기</h2>\n<p>그럼 우리가 <a href=\"https://witch.work/posts/typescript-covariance-theory\">앞선 글</a>에서 보았던, <code>in</code>, <code>out</code>키워드로 직접 가변성을 설정하는 방식은 TS에서 사용할 수 없을까?</p>\n<p>TS는 TypeScript 4.7에서 제네릭 타입 인자의 가변성을 설정할 수 있는 Variance Annotation을 도입했다. <code>in</code>, <code>out</code>키워드를 이용해서 설정하며, 제네릭을 사용하는 시점이 아니라 처음 정의하는 시점에 명시해야 한다.</p>\n<p><a href=\"https://witch.work/posts/typescript-covariance-theory\">TS 탐구생활 - 가변성(Variance)이란 무엇인가</a>에서 다루었듯이 <code>in</code>을 사용하면 반변, <code>out</code>을 사용하면 공변으로 제네릭 타입 인자의 가변성을 설정할 수 있다. <code>in out</code>처럼 둘 다 쓰면 제네릭 타입 인자는 불변이 된다.</p>\n<pre><code class=\"language-ts\">// T는 공변\ninterface ReadOnlyList&#x3C;out T>{\n    // T가 메서드 리턴 타입으로만 쓰인다\n    get:(idx:number)=>T=(idx:number)=>{return this.arr[idx];};\n\n    // ...\n}\n\n// T는 반변\ninterface Store&#x3C;in T>{\n    // T가 메서드 매개변수 타입으로만 쓰인다\n    set:(idx:number, value:T)=>void=(idx:number, value:T)=>{this.arr[idx]=value;};\n\n    // ...\n}\n</code></pre>\n<p>해당 PR을 보면 이런 Variance Annotation은 매개변수의 용도를 알기 쉽게 하고 타입 검사 속도를 높인다고 한다. 그리고 업데이트 문서에서는 이렇게 말하고 있다.</p>\n<blockquote>\n<p>Variance에 대해 생각할 필요 없이 Type argument가 output으로 사용될 때 <code>out</code>, input으로 사용될 때 <code>in</code>을 사용하는 것으로 이해하면 된다.</p>\n</blockquote>\n<p>TS에는 원래 이런 키워드가 없었지만 앞서 말했듯이 4.7부터 in, out을 도입하였다. 이는 코드의 가독성과 컴파일러 속도, 정확성을 높이기 위해서였다. 단 여전히 TS 진영에서는 이 키워드를 사용할 때 신중히 고려한 후 사용할 것을 권한다.</p>\n<p>여기에 대해서는 <a href=\"https://driip.me/644e7f06-8591-443e-9fca-44b0ab424fda\">Dogdriip님이 쓰신, TS Variance Annotation에 대한 글</a>을 참고할 수 있다.</p>\n<h1>2. TS의 제네릭이 이렇게 되기까지</h1>\n<p>왜 TS에서는 함수 매개변수를 제외한 제네릭을 기본적으로 공변으로 하는 걸까?</p>\n<h2>2.1. 다른 언어에서의 제네릭</h2>\n<p>C#이나 Kotlin, 스칼라와 같은 언어들에서는 제네릭이 기본적으로 불변이다. 그리고 가변성이 필요한 제네릭의 경우 <code>in</code>, <code>out</code>키워드를 이용해서 직접 가변성을 지정하도록 했다.</p>\n<p>예를 들어 Kotlin에서는 <code>in</code>, <code>out</code>키워드를 사용해서 제네릭 타입 인자의 가변성을 지정할 수 있다. <code>in</code>을 사용하면 반변, <code>out</code>을 사용하면 공변이다. 아무것도 쓰지 않으면 불변이다.</p>\n<pre><code class=\"language-kotlin\">// Animal은 불변\nfun foo(arg: Generic&#x3C;Animal>){\n    arg.walk()\n}\n\n// Animal은 공변\nfun foo(arg: Generic&#x3C;out Animal>){\n    arg.walk()\n}\n\n// Animal은 반변\nfun foo(arg: Generic&#x3C;in Animal>){\n    arg.walk()\n}\n</code></pre>\n<p><code>List&#x3C;T></code>, <code>Comparator&#x3C;T></code>등 언어에서 정의한 제네릭들은 따로 가변성이 지정되어 있다.</p>\n<h2>2.2. TS에 가변성을 직접 지정할 수 없었던 이유</h2>\n<p>사실 TS에 가변성 지정 기능을 도입하자는 제안은 아주 오래전부터 있어 왔다. <a href=\"https://github.com/microsoft/TypeScript/issues/1394\">수정해야 할 부분들이 있긴 했지만 가변성에 관한 in, out키워드를 도입하자는 제안이 무려 2014년 12월부터 있었다.</a></p>\n<p>이후에 <a href=\"https://github.com/microsoft/TypeScript/issues/10717\"><code>Array&#x3C;T></code>의 공변성 문제 등을 해결할 수 있는 방식으로 개선된 제안(양변 지정자 포함)</a>과 <a href=\"https://github.com/microsoft/TypeScript/issues/10717#issuecomment-523156331\">제네릭을 기본적으로 불변으로 하고 제네릭 타입을 사용하는 위치에서 가변성을 지정하자는 제안</a>등도 있었다.</p>\n<p>하지만 TS 진영에서는 해당 제안을 여러 이유로 오랜 시간 동안 받아들이지 않았다. 2022년이 되어서야 <a href=\"https://github.com/microsoft/TypeScript/pull/48240\">제네릭 타입 인자의 가변성을 지정할 수 있는 Optional variance annotation을 도입했다.</a></p>\n<p>그럼 TS는 왜 이런 가변성 지정 방식을 받아들이지 않았을까? 다른 언어들처럼 할 수도 있었다. 제네릭을 기본적으로 불변으로 하고 <code>Array&#x3C;T></code> 같이 특정 가변성을 가지는 것이 자연스러운 제네릭은 <code>in</code>, <code>out</code>키워드를 이용해서 직접 가변성을 지정하도록 하는 것이다. 사실 가변성을 다루는 데에 있어서는 TS같은 방식보다 이쪽이 더 일반적이다.</p>\n<p>TBD</p>\n<h2>2.3. TS의 결정</h2>\n<p>이렇게 가변성을 따로 지정할 수 있는 방식이 없는 동안 TS에서는 선택을 해야 했다. <code>Array&#x3C;T></code>와 같은 흔한 제네릭 타입조차 불변으로 만들지, 아니면 제네릭 타입 가변성 기본값을 공변으로 함으로써 타입 시스템에 구멍을 만들더라도 직관적인 제네릭 서브타입 관계를 만들지 사이에서 말이다.</p>\n<p>이런 고민들이 담긴 PR 코멘트들이 있는데 예를 들어서 <a href=\"https://github.com/microsoft/TypeScript/issues/6102#issuecomment-164629334\">TS 이슈#6102의 댓글</a>이 있겠다. 만약 모든 제네릭 타입이 불변이 되면 모든 파생 타입들에 대해서 구조적 타입 검사를 수행해야 하게 되고 이는 컴파일러 성능을 크게 떨어뜨린다. 그리고 <code>Array&#x3C;Derived></code>가 <code>Array&#x3C;Base></code>에 할당 불가능하게 되는 등 매우 비직관적인 동작들을 만들게 된다.</p>\n<p>여담이지만 'We chatted about this for a while in the team room.'이나 팀의 다른 누군가를 멘션하며 '이 사람과 이 이슈에 대해서 이야기를 해보았는데~'와 같은 문장들을 TS 이슈에서 자주 볼 수 있는데, github에 보이는 코멘트 외에 회의 등을 통해서 결정되는 사항들도 많은 모양이다.</p>\n<p>아무튼 TS 진영에서는 타입 시스템에 구멍을 만들더라도 제네릭을 기본적으로 공변 취급하여 직관적인 서브타입 관계를 만드는 것을 택했다. 이후 보겠지만 TS팀은 이런 기본적인 가변성 설정을 그래도 최대한 합리적으로 동작하도록 하는 조치를 취했고, 당시 다른 언어들과 달리 제네릭을 불변에서 벗어나도록 할 수 있는 장치들도 없는 상황에서 이런 선택을 한 것은 합리적이었다고 생각한다.</p>\n<p>그리하여 <code>Array&#x3C;T></code>를 포함한 제네릭(함수 매개변수 제외)은 기본적으로 공변으로 동작하게 되었다.</p>\n<p><a href=\"https://github.com/microsoft/TypeScript/issues/9825#issuecomment-306272034\">또한 TS는 완전히 견고한 타입 시스템을 만드는 것이 목표가 아니고 JS의 동작 방식을 생각하면 그럴 수도 없다</a>는 것을 생각하면 JS를 타입으로 모델링하는 입장에서 합리적인 선택이었다고 할 수도 있겠다.</p>\n<p>다음 섹션들에서는 TS에서 가변성 처리에 있어서 다른 점들을 알아보자.</p>\n<h1>3. TS의 메서드 매개변수 타입의 양변</h1>\n<p>TS는 기본적으로 공변이며 함수 매개변수에 대해서는 반변이라고 하였다. 그런데 <code>strictFunctionTypes</code>옵션이 false일 때는 함수 매개변수가 양변이 된다.</p>\n<blockquote>\n<p>양변은 제네릭 타입이 타입 인자의 서브타입 관계를 양쪽으로 모두 사용하는 것이다. <code>T</code>가 <code>U</code>의 서브타입이면 <code>Array&#x3C;T></code>는 <code>Array&#x3C;U></code>의 서브타입이면서 슈퍼타입인 셈이다.</p>\n</blockquote>\n<p>그리고 <code>strictFunctionTypes</code>옵션이 true이더라도 매개변수가 양변으로 작동하는 때가 있다. 단축 메서드 선언을 할 경우에 그렇다.</p>\n<pre><code class=\"language-ts\">// strictFunctionTypes가 true일 때\n// T는 반변\ninterface Store&#x3C;T> {\n  set: (item: T) => void;\n}\n\n// T는 양변\ninterface Store&#x3C;T> {\n  set(item: T): void;\n}\n</code></pre>\n<p>이건 왜 이렇게 되었을까? 당연히 이유가 있고, 심지어 활용되는 부분들도 있다.</p>\n<h2>3.1. 이렇게 된 이유</h2>\n<p>앞서 본 것과 같은 이유이다. 이는 기본적으로 TS에 가변성을 직접 지정할 수 있는 방법이 없으며 그런 상황에서 타입을 직관적으로 동작하도록 해야 하기 때문에 생기는 문제이다.</p>\n<p>만약 <code>Dog</code>이 <code>Animal</code>의 서브타입이라고 하자. 그러면 <code>Array&#x3C;Dog></code>은 <code>Array&#x3C;Animal></code>의 서브타입인가? 개 객체들이 들어 있는 배열은 동물 객체들이 들어 있는 배열이라고 할 수도 있으므로 당연해 보인다.</p>\n<p>그러면 서브타입 관계에 따라, <code>Array&#x3C;Dog></code>의 모든 멤버가 <code>Array&#x3C;Animal></code>에 할당 가능해야 한다. 그런데 만약 그렇다면 <code>(item:Dog)=>number</code> 타입은 <code>(item:Animal)=>number</code> 타입에 할당 가능해야 한다.</p>\n<p><code>Array.prototype.push</code>가 바로 <code>(item:T)=>number</code>타입이기 때문이다. (<code>Array.prototype.push</code>는 사실 새로 만들어진 배열의 크기를 리턴하기 때문에 리턴타입이 <code>number</code>이다)</p>\n<p>그런데 우리가 지금까지 본 것처럼 함수 매개변수 타입이 반변이라고 하자. 그러면 <code>(item:Dog)=>number</code> 타입이 <code>(item:Animal)=>number</code> 타입에 할당 가능하다는 것은 <code>Animal</code>이 <code>Dog</code>에 할당 가능하다는 것이다. 이는 서브타입 관계에 따라 <code>Array&#x3C;Dog></code>이 <code>Array&#x3C;Animal></code>에 할당될 수 없다는 모순을 낳는다.</p>\n<p>즉 기존처럼 함수 매개변수가 반변으로 강제되는 경우, <code>Array&#x3C;subtype></code>이 <code>Array&#x3C;supertype></code>의 서브타입이기 위해서는 <code>(item:subtype)=>void</code>가 <code>(item:supertype)=>void</code>의 서브타입이어야 한다.</p>\n<p>그리고 이는 <code>supertype</code>이 <code>subtype</code>의 서브타입이어야 한다는 것과 같고 이는 또 <code>Array&#x3C;supertype></code>이 <code>Array&#x3C;subtype></code>의 서브타입이어야 한다는 것과 같다. 이는 일반적으로 허용 가능하지 않다.</p>\n<p>따라서 이런 함수 매개변수 타입의 특수한 경우를 처리하기 위해서 정확성을 약간 희생하여 함수 매개변수 타입이 양변으로 동작하도록 하였다고 한다.</p>\n<p>C#같은 언어에서는 <code>in</code>, <code>out</code>같은 키워드로 가변성을 지정할 수 있어서 이런 부분을 해결하지만 TS에서는 그런 키워드가 없었다. 또한 그런 키워드가 도입된 지금도, 해당 개념이 그렇게 쉬운 개념이 아니라는 이유로 이를 많이 쓰는 것은 피하고 있다고 생각한다. 따라서 이런 매개변수에 대한 양변 처리가 되었다.</p>\n<p>하지만 TS의 설계자의 관점에서는 이런 부분들까지 고려하여 설계해야 하겠지만, 사용자의 입장에서는 함수 매개변수 타입이 양변으로 동작하도록 하는 게 별로 좋은 점은 없다. 그래서 <code>--strictFunctionTypes</code>옵션을 true로 설정하면 함수 매개변수 타입이 반변으로 동작하도록 하였다.</p>\n<p>물론 그렇게 한다고 해도 단축 메서드 형식으로 선언된 메서드 매개변수 타입은 양변으로 동작한다. <code>push</code>같은 메서드들이 이렇게 메서드 형식으로 선언되어 있다. 이렇게 양변으로 동작하는 부분을 남겨둔 이유는 <code>Array&#x3C;T></code>등이 공변인 게 직관적이기 때문에, 그 동작을 보장하기 위해서라고 한다.</p>\n<pre><code class=\"language-ts\">interface Array&#x3C;T> {\n\t// ...\n\tpush(...items: T[]): number;\n\t// ...\n}\n</code></pre>\n<h2>3.2. bivarianceHack</h2>\n<p>그런데 <code>strictFunctionTypes</code>옵션이 true일 때도 함수 매개변수 타입이 양변으로 동작하도록 만드는 방법이 있다.</p>\n<p>바로 <code>bivarianceHack</code>이다. 대표적으로 리액트의 useRef 콜백이나 이벤트 핸들러 타입 등에서 이를 볼 수 있다.</p>\n<pre><code class=\"language-ts\">// @types/react/index.d.ts\n// Bivariance hack for consistent unsoundness with RefObject\ntype RefCallback&#x3C;T> = { bivarianceHack(instance: T | null): void }[\"bivarianceHack\"];\n\ntype EventHandler&#x3C;E extends SyntheticEvent&#x3C;any>> = { bivarianceHack(event: E): void }[\"bivarianceHack\"];\n</code></pre>\n<p>이외에 <a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/backbone/index.d.ts\">backbone등의 타입 정의 파일에서도 이를 볼 수 있다.</a></p>\n<p>활용 TODO</p>\n<h2>3.3. UnionToIntersection</h2>\n<h2>3.4. 모든 함수의 타입</h2>\n<p>다음과 같은 코드를 보자. 인수가 never 타입인 함수에 number 타입 함수를 할당하고 있는데 에러가 나지 않는다.</p>\n<pre><code class=\"language-ts\">type funcType=(a:never)=>number;\nconst foo:funcType=(a:number)=>a+1;\n</code></pre>\n<p>우리가 알고 있는 일반적인 타입스크립트의 동작에서는 말이 안되는 일이다. 예를 들어 <code>never</code> 배열에 <code>number</code> 배열을 할당하려고 하면 에러가 난다.</p>\n<pre><code class=\"language-ts\">type neverArray=never[];\n// 에러 발생\n// Type 'number' is not assignable to type 'never'.\nconst arr:neverArray=[1,2,3];\n</code></pre>\n<h1>4. TS에서 immutable을 다루는 방식</h1>\n<p>위 섹션에서, TS에서 매개변수 타입이 양변이라는 사실과 그렇게 된 이유를 보았다. 결국 타입스크립트에서 명시적으로 제네릭 타입 인자의 가변성을 지정할 수 없다는 사실이 이런 타협을 만들었다. 그런데 애초에 이런 타협을 왜 해야 했는가? 문제를 근본적으로 해결하는 방법은 없는가?</p>\n<h2>4.1. 발상</h2>\n<p>이외에도 자잘한 이유들이 있겠지만 매개변수 타입을 양변으로 만들어야 했던 근본적인 이유는 JS에 배열과 같은 mutable한 객체가 있었기 때문이다. JS에서는 참조하고 있는 객체를 변경하는 것이 너무 쉽다!</p>\n<p>이런 mutable한 객체로 인한 문제는 제네릭 타입 인자의 가변성을 지정할 수 있는 다른 언어에서도 발생한다. 예를 들어 코틀린을 보면 <code>MutableList&#x3C;T></code>와 <code>List&#x3C;T></code>가 따로 존재한다. <code>MutableList&#x3C;T></code>는 <code>List&#x3C;T></code>를 상속받는데 <code>MutableList&#x3C;T></code>는 불변이고 <code>List&#x3C;T></code>는 공변이다. 그리고 사실 mutable한 객체는 가변성으로 인한 문제보다도 더 큰 문제들인 사이드 이펙트나 멀티스레드 환경에서의 문제를 야기한다.</p>\n<p>그럼 이런 문제를 완전히 해결할 수는 없을까? 변수는 언제나 immutable이고, mutable한 객체는 아예 안 다루거나 따로 다루는 방식으로 말이다. 이런 방식은 실제로 여러 곳에서 사용되고 있다. 작게는 React에서 객체를 immutable하게 다루는 방식을 생각해 볼 수 있고 더 크게는 함수형 패러다임이 있다. 이 글의 주제는 아니라서 깊게 다루지는 않겠지만 모든 객체를 immutable하게 다루고 순수 함수로 프로그램을 구성하는 것이다.</p>\n<p>리액트에서 객체를 immutable하게 다루는 것이 주는 이득이 무엇인지, 함수형으로 프로그래밍하는 것이 뭐가 좋은지 등의 주제들은 이 글의 주제를 벗어난다. 하지만 객체를 immutable하게 다루는 것은 제네릭의 가변성과 관련된 몇몇 흥미로운 논의들을 만든다. 따라서 이 부분에 대해서 다루어보자.</p>\n<h2>4.2. concat</h2>\n<p>JS에서는 immutable하게 배열을 다루는 메서드들이 몇 개 있다. React에서도 흔히 쓰이는 <code>concat</code>, <code>filter</code>, <code>map</code>등이 그렇다. 이런 배열 메서드들은 새로운 배열을 만들어서 리턴한다. 그럼 이들의 타입은 어떻게 정의되어 있을까? 가장 흥미로운 concat부터 한번 보자. 2가지로 오버로딩되어 있다.</p>\n<pre><code class=\"language-ts\">interface Array&#x3C;T> {\n    concat(...items: ConcatArray&#x3C;T>[]): T[];\n    concat(...items: (T | ConcatArray&#x3C;T>)[]): T[];\n}\n</code></pre>\n<p>그리고 <code>ConcatArray&#x3C;T></code>는 다음과 같이 정의되어 있다.</p>\n<pre><code class=\"language-ts\">interface ConcatArray&#x3C;T> {\n    readonly length: number;\n    readonly [n: number]: T;\n    join(separator?: string): string;\n    slice(start?: number, end?: number): T[];\n}\n</code></pre>\n<p><code>ConcatArray&#x3C;T></code>는 배열에 필요한 속성들과 <code>join</code>, <code>slice</code>메서드를 가지고 있다. 그리고 완전히 공변이다.</p>\n<p><a href=\"https://witch.work/posts/typescript-concat-type-history\">https://witch.work/posts/typescript-concat-type-history</a></p>\n<h1>참고</h1>\n<p>홍재민, 타입으로 견고하게 다형성으로 유연하게 <a href=\"https://product.kyobobook.co.kr/detail/S000210397750\">https://product.kyobobook.co.kr/detail/S000210397750</a></p>\n<p>공변성과 반공변성은 무엇인가? <a href=\"https://edykim.com/ko/post/what-are-covariance-and-contravariance/\">https://edykim.com/ko/post/what-are-covariance-and-contravariance/</a></p>\n<p>TypeScript 타입 변성(Variance) <a href=\"https://saramkim.github.io/Variance/\">https://saramkim.github.io/Variance/</a></p>\n<p>타입 시스템에서의 변성(Variance) — 공변성(Covariance)과 반공변성(Contravariance) <a href=\"https://driip.me/d875a384-3fb9-471b-a53b-b3ca52f8238e\">https://driip.me/d875a384-3fb9-471b-a53b-b3ca52f8238e</a></p>\n<p>TypeScript 4.7에 추가된 Type Parameters의 Variance Annotations <a href=\"https://driip.me/644e7f06-8591-443e-9fca-44b0ab424fda\">https://driip.me/644e7f06-8591-443e-9fca-44b0ab424fda</a></p>\n<p>TypeScript에서의 변성(Variance): 도대체 왜 이렇게 된 거야?\n<a href=\"https://driip.me/d230be64-df1d-4e9a-a8c2-cba6bbc0ae15\">https://driip.me/d230be64-df1d-4e9a-a8c2-cba6bbc0ae15</a></p>\n<p>공변성이란 무엇인가 <a href=\"https://seob.dev/posts/%EA%B3%B5%EB%B3%80%EC%84%B1%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80/\">https://seob.dev/posts/%EA%B3%B5%EB%B3%80%EC%84%B1%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80/</a></p>\n<p>Variant 제네릭 인터페이스 만들기(C#) <a href=\"https://learn.microsoft.com/ko-kr/dotnet/csharp/programming-guide/concepts/covariance-contravariance/creating-variant-generic-interfaces\">https://learn.microsoft.com/ko-kr/dotnet/csharp/programming-guide/concepts/covariance-contravariance/creating-variant-generic-interfaces</a></p>\n<p>TS 4.7 Release Notes, Optional Variance Annotations for Type Parameters <a href=\"https://devblogs.microsoft.com/typescript/announcing-typescript-4-7/#optional-variance-annotations-for-type-parameters\">https://devblogs.microsoft.com/typescript/announcing-typescript-4-7/#optional-variance-annotations-for-type-parameters</a></p>\n<p>TS FAQ, \"Why are function parameters bivariant?\" <a href=\"https://github.com/Microsoft/TypeScript/wiki/FAQ#why-are-function-parameters-bivariant\">https://github.com/Microsoft/TypeScript/wiki/FAQ#why-are-function-parameters-bivariant</a></p>\n<p>Covariance / Contravariance Annotations를 추가해 달라는 이슈 요청과 거절사유 <a href=\"https://github.com/microsoft/TypeScript/issues/1394\">https://github.com/microsoft/TypeScript/issues/1394</a></p>\n<p>Proposal: covariance and contravariance generic type arguments annotations <a href=\"https://github.com/microsoft/TypeScript/issues/10717\">https://github.com/microsoft/TypeScript/issues/10717</a></p>\n<p>Strict function types PR <a href=\"https://github.com/microsoft/TypeScript/pull/18654\">https://github.com/microsoft/TypeScript/pull/18654</a></p>\n<p>allow a flag that turns off covariant parameters when checking function assignability <a href=\"https://github.com/microsoft/TypeScript/issues/6102\">https://github.com/microsoft/TypeScript/issues/6102</a></p>\n<p>What is the purpose of bivarianceHack in TypeScript types? <a href=\"https://stackoverflow.com/questions/52667959/what-is-the-purpose-of-bivariancehack-in-typescript-types\">https://stackoverflow.com/questions/52667959/what-is-the-purpose-of-bivariancehack-in-typescript-types</a></p>\n<p>Bivariance hack for consistent unsoundness with RefObject <a href=\"https://www.pumpkiinbell.com/blog/react/ref-callback-bivariance-hack\">https://www.pumpkiinbell.com/blog/react/ref-callback-bivariance-hack</a></p>\n<p>Variance in programming languages <a href=\"https://rubber-duck-typing.com/posts/2018-05-01-variance-in-programming-languages.html\">https://rubber-duck-typing.com/posts/2018-05-01-variance-in-programming-languages.html</a></p>\n<p>Why are TypeScript arrays covariant? <a href=\"https://stackoverflow.com/questions/60905518/why-are-typescript-arrays-covariant\">https://stackoverflow.com/questions/60905518/why-are-typescript-arrays-covariant</a></p>\n<p>A fully-sound type system built on top of existing JS syntax is simply a fool's errand. <a href=\"https://github.com/microsoft/TypeScript/issues/9825#issuecomment-306272034\">https://github.com/microsoft/TypeScript/issues/9825#issuecomment-306272034</a></p>\n<p>Docs: function parameter bivariance <a href=\"https://github.com/microsoft/TypeScript/issues/14973\">https://github.com/microsoft/TypeScript/issues/14973</a></p>\n<p>Overloads in Array.concat now handle ReadonlyArray - ConcatArray가 등장한 PR <a href=\"https://github.com/microsoft/TypeScript/pull/21462\">https://github.com/microsoft/TypeScript/pull/21462</a></p>",
    "excerpt": "이 글은 현재 작성 중입니다.\n\n\n이 글은 읽는 사람이 슈퍼타입, 서브타입, 제네릭 등 기본적인 타입 시스템의 개념은 알고 있다는 가정하에 쓰여지는 글이다.\n\nTS를 더 잘 이해하기 위해 타입 시스템을 공부하다가 가변성(variance)이라는 개념을 만났다. 그래서 이와 관련해서 2개의 글을 썼다. 첫번째 글에서는 가변성이라는 게 무엇인지 알아보았다. 그리고 두 번째 글(이 글)에서는 가변성이라는 개념이 TS에 녹아 있는 부분 몇 가지를 알아볼 것이다.\n이 글에",
    "headingTree": [
      {
        "title": "이 글은 현재 작성 중입니다.",
        "url": "#이-글은-현재-작성-중입니다",
        "items": []
      },
      {
        "title": "1. TS에서 가변성 다루기",
        "url": "#1-ts에서-가변성-다루기",
        "items": [
          {
            "title": "1.1. 가변성 기본설정",
            "url": "#11-가변성-기본설정",
            "items": []
          },
          {
            "title": "1.2. 직접 가변성 설정하기",
            "url": "#12-직접-가변성-설정하기",
            "items": []
          }
        ]
      },
      {
        "title": "2. TS의 제네릭이 이렇게 되기까지",
        "url": "#2-ts의-제네릭이-이렇게-되기까지",
        "items": [
          {
            "title": "2.1. 다른 언어에서의 제네릭",
            "url": "#21-다른-언어에서의-제네릭",
            "items": []
          },
          {
            "title": "2.2. TS에 가변성을 직접 지정할 수 없었던 이유",
            "url": "#22-ts에-가변성을-직접-지정할-수-없었던-이유",
            "items": []
          },
          {
            "title": "2.3. TS의 결정",
            "url": "#23-ts의-결정",
            "items": []
          }
        ]
      },
      {
        "title": "3. TS의 메서드 매개변수 타입의 양변",
        "url": "#3-ts의-메서드-매개변수-타입의-양변",
        "items": [
          {
            "title": "3.1. 이렇게 된 이유",
            "url": "#31-이렇게-된-이유",
            "items": []
          },
          {
            "title": "3.2. bivarianceHack",
            "url": "#32-bivariancehack",
            "items": []
          },
          {
            "title": "3.3. UnionToIntersection",
            "url": "#33-uniontointersection",
            "items": []
          },
          {
            "title": "3.4. 모든 함수의 타입",
            "url": "#34-모든-함수의-타입",
            "items": []
          }
        ]
      },
      {
        "title": "4. TS에서 immutable을 다루는 방식",
        "url": "#4-ts에서-immutable을-다루는-방식",
        "items": [
          {
            "title": "4.1. 발상",
            "url": "#41-발상",
            "items": []
          },
          {
            "title": "4.2. concat",
            "url": "#42-concat",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 3,
      "wordCount": 846
    },
    "url": "/posts/typescript-covariance-in-real-ts",
    "thumbnail": {
      "local": "/static/variance-picture-5a939c8f.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-variance-picture-5a939c8f-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAIAAABLbSncAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA00lEQVR4nAHIADf/AFxcW0FBQWpqapWVlScnJlVVVZmZmbe3tgC3u77Q1NTy9PHf3tuHh4ni4uHS0tLDw8MAkX56lY6Lz9HQrKyslpSLwsLA1NPT2NfWAB4DAD84NC4yMCcnJjhAMGxvbRkZGS4sKwC5vb/Q0dLj4+TDw8Ojoqb49/i/v7/Nzs4AxcbGiIF+tK2q4OLiu7u7paefiImEoqGhADw/PnlybJWHhM7R0H59ftja16anpIyLigC5u7nHwLywqaaYmZlfX1/i4uL29vagoJ+eE3Qa1y1orwAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "typescript-concat-type-history",
    "title": "TS 탐구생활 - 배열 concat 메서드 타입 변천사",
    "date": "2023-12-12T00:00:00Z",
    "description": "TS의 Array.prototype.concat 타입은 쉽게 쓰여진 게 아니다",
    "tags": [
      "typescript"
    ],
    "html": "<hr>\n<ul>\n<li>가변성에 대해 조사하다가 뻗어나온 토픽을 깊게 파다가 쓴 글이다. 이런 식으로 언어의 어떤 부분이 이렇게 된 이유와 역사에 대해 깊이 공부하는 건 매우 좋아하는 일이지만, 들이는 시간에 비해서 뭔가 실질적인 효율이 좋지는 않은 것 같아서 자제하고 있다. 그래도 이런 글을 쓰는 건 재밌다!</li>\n</ul>\n<h1>썸네일</h1>\n<p><img src=\"/static/concat-issue-b839b4cd.png\" alt=\"concat 이슈 사진 하나\"></p>\n<h1>1. Array.prototype.concat</h1>\n<p>TS의 기본 타입 파일 중 하나인 <code>lib.es5.d.ts</code>의 <code>Array&#x3C;T></code>를 살펴보고 있었다. 그런데 <code>concat</code>의 타입이 그냥 보기에 특이하게 정의되어 있었다.</p>\n<p>그냥 <code>Array&#x3C;T></code>타입도 있고, 읽기 전용의 <code>ReadonlyArray&#x3C;T></code>타입도 있는데 <code>ConcatArray&#x3C;T></code>라는 새로운 타입을 정의해서 사용하고 있었다. 해당 타입은 다음과 같다.</p>\n<pre><code class=\"language-ts\">interface Array&#x3C;T> {\n  concat(...items: ConcatArray&#x3C;T>[]): T[];\n  concat(...items: (T | ConcatArray&#x3C;T>)[]): T[];\n}\n</code></pre>\n<p>그래서 이 <code>Array.prototype.concat()</code>의 타입이 왜 이런 직관적이지 못한 형태가 되었는지 알아보았다. 그 과정에서 꽤 흥미로운 부분들이 있었기에 여기 적는다.</p>\n<h2>1.1. Array.prototype.concat이란?</h2>\n<p>JS에서 <code>Array.prototype</code>에는 <code>concat()</code>메서드가 정의되어 있다. 이 메서드는 기존 배열에 병합할 새 배열을 매개변수로 받아서 병합한 새 배열을 반환한다. 여러 개의 배열을 매개변수로 받아 병합하는 것도 가능하다. 다음은 MDN에서 가져온 <code>concat()</code>의 예제 구문이다.</p>\n<pre><code class=\"language-js\">const array1 = [\"a\", \"b\", \"c\"];\nconst array2 = [\"d\", \"e\", \"f\"];\nconst array3 = array1.concat(array2);\n// expected array3 : Array [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"]\n\nconcat();\nconcat(value0);\nconcat(value0, value1);\nconcat(value0, value1, /* …, */ valueN);\n</code></pre>\n<p>만약 매개변수가 하나도 없을 경우 <code>concat</code>은 기존 배열의 얕은 복사본을 반환한다.</p>\n<h2>1.2. concat 타입에 관한 생각</h2>\n<p><code>concat</code>의 타입을 보면 <code>ConcatArray&#x3C;T></code>라는 새로운 타입을 정의해서 사용하고 있다. 그런데 그냥 <code>Array&#x3C;T></code>를 매개변수 타입으로 그대로 써도 되지 않을까?</p>\n<p><code>concat</code>은 배열 여러 개를 매개변수로 받을 수 있고 단일 원소도 매개변수로 받을 수 있다는 걸 감안하여 다음과 같은 형태는 어떨까? 이는 실제로 한때 TS에서 도입되었던 타입이다.</p>\n<pre><code class=\"language-ts\">interface Array&#x3C;T> {\n  // ...\n  concat(...items: (T | T[])[]): T[];\n}\n</code></pre>\n<p>하지만 위의 타입은 당연히 문제가 있었다. 그리고 <code>ConcatArray&#x3C;T></code>라는 새로운 타입을 굳이 정의하기까지는 여러 이슈와 PR이 있었다. 당연히 바로 위에서 제시한 직관적인 <code>concat</code> 타입도 문제가 있어서 사라진 방식이다. 약간 스포일러를 하자면 <code>ReadonlyArray&#x3C;T></code>타입을 <code>concat</code>에 넘길 수 없다는 것이 문제였다.</p>\n<p>아무튼 <code>concat</code>의 타입 정의가 현재 모습이 되기까지를 살펴보자.</p>\n<h1>2. union의 등장으로 인한 변경</h1>\n<h2>2.1. 가장 초기의 concat 타입</h2>\n<p>가장 초기의 <code>concat</code>타입은 <a href=\"https://github.com/microsoft/TypeScript/issues/738\">2014년 9월의 이슈</a>에서 확인할 수 있다. 당시 <code>Array.concat</code>메서드의 타입은 이랬다.</p>\n<pre><code class=\"language-ts\">interface Array&#x3C;T> {\n  concat&#x3C;U extends T[]>(...items: U[]): T[];\n  concat(...items: T[]): T[];\n}\n</code></pre>\n<p>첫번째 오버로딩을 보면 <code>U</code>가 <code>T[]</code>를 상속하고 있으므로 <code>U[]</code>매개변수를 받는다는 건 개념상 <code>T[][]</code>를 받는다는 것과 같다. 따라서 병합할 여러 배열들을 매개변수로 받는다는 JS의 <code>concat</code>의 개념과 일치한다.</p>\n<p>그리고 <code>concat</code>은 <code>[1, 2, 3].concat(4, 5, 6)</code>과 같이 배열이 아니라 개별 원소들도 매개변수로 받을 수 있기 때문에 두번째 오버로딩도 합당하다.</p>\n<h2>2.2. 개선</h2>\n<p>JS의 <code>concat</code>은 원래 개별 원소들과 배열을 혼합해서 매개변수로 받는 것이 가능하다.</p>\n<pre><code class=\"language-js\">[1, 2, 3].concat(4, [5, 6], 7, [8]) // [1,2,3,4,5,6,7,8]\n</code></pre>\n<p>하지만 앞에서 본 <code>concat</code> 타입의 경우 위와 같은 동작을 모델링할 수 없다. 이는 <a href=\"https://github.com/microsoft/TypeScript/issues/6594\">2016년 1월의 이슈</a>에서 제시되었다. 그리고 <a href=\"https://github.com/microsoft/TypeScript/pull/6629\">역시 2016년 1월의 PR</a>을 통해 수정되었다.</p>\n<p>해당 이슈의 코멘트를 보면, 앞서 본 concat의 타입 정의는 유니온 타입이 도입되기 전에 작성되었고 몇몇 역사적 이유 때문에 제네릭 제한 타입(<code>U extends T[]</code>)을 사용했다고 한다. 하지만 당시에는 유니온 타입이 도입되어 있었다. 그래서 다음과 같이 <code>concat</code>의 타입이 수정되었다.</p>\n<pre><code class=\"language-ts\">interface Array&#x3C;T> {\n  // ...\n  concat(...items: (T | T[])[]): T[];\n}\n</code></pre>\n<p>사실 <code>concat</code>의 매개변수는 중첩된 배열도 가능하다. 하지만 그런 동작을 타입으로 모델링하려는 시도는 타입 추론에 안 좋은 영향을 미치게 되기 때문에 도입되지 못했다.</p>\n<p>그래도 이제는 개별 원소와 배열을 매개변수로 받을 수 있게 되었으므로 원래보다는 좀 더 유연하고 직관적이기까지 한 타입이 되었다.</p>\n<h1>3. 오버로딩 추가로 타입 추론 로직 변경</h1>\n<h2>3.1. 이슈</h2>\n<p>그리고 2016년 7월 <a href=\"https://github.com/microsoft/TypeScript/issues/9901\">TS 이슈</a>가 제기된다. <code>concat</code>에서 타입 추론이 제대로 이루어지지 않는다는 것이다. 문제의 코드는 이렇다.</p>\n<pre><code class=\"language-ts\">// concat-bug.ts\nvar a: Array&#x3C;[number, number]> = [[1, 2]];\n\n// Typescript detects these first two tuples as arrays of numbers (`number[]`) instead of `[number, number]`\n// error TS2345: Argument of type '[number[], number[], [number, number]]' is not assignable to parameter of type '[number, number] | [number, number][]'.\na.concat([\n  [3, 4],\n  [5, 6],\n  [7, 8],\n]);\n</code></pre>\n<p>에러 메시지를 읽어 보자. <code>concat</code>의 매개변수 타입은 <code>[number, number] | [number, number][]</code>이어야 하는데 <code>concat</code>에 넘어간 매개변수가 다른 타입이라는 에러이다.</p>\n<h2>3.2. 분석</h2>\n<p>요약하자면 매개변수 배열의 첫 두 원소가 튜플이 아니라 <code>number[]</code>로 추론되는 것이 문제였다. 그럼 왜 이런 문제가 발생했을까?</p>\n<p>당시 <code>concat</code>의 타입은 위에서 정의된 그대로였다. 이는 <code>concat</code>이 <code>T[]</code> 혹은 <code>T</code> 둘 다 매개변수로 받을 수 있었다는 뜻이다. 그런데 이렇게 하면 <code>concat</code>의 매개변수 타입을 추론하는데 문제가 생긴다.</p>\n<pre><code class=\"language-ts\">interface Array&#x3C;T> {\n  // ...\n  concat(...items: (T | T[])[]): T[];\n}\n</code></pre>\n<p>이때 만약 <code>#2</code>의 예시처럼 <code>array.concat(1, [2, 3], 4)</code>와 같이 중첩 레벨이 섞여서 들어온다면 <code>1</code>, <code>4</code>는 top-level argument 타입인 <code>T</code>, <code>[2, 3]</code>은 list-wrapped argument 타입 <code>T[]</code>로, 그리고 <code>T</code>는 <code>number</code>로 쉽게 추론될 수 있다.</p>\n<p>하지만 위처럼 <code>[[3, 4], [5, 6], [7, 8]]</code>같은 것이 <code>concat</code>의 매개변수로 들어오면 컴파일러 입장에서는 어떻게 타입 추론을 해야 하는지 모호해진다.</p>\n<p>먼저 <code>[[3, 4], [5, 6], [7, 8]]</code> 자체를 top-level argument 즉 단일 매개변수로 추론할 수 있다. <code>[[3, 4], [5, 6], [7, 8]]</code> 자체가 <code>T</code>타입이라고 보는 것이다. 그럴 경우 매개변수를 통해 추론된 <code>T</code> 타입은 <code>number[][]</code>이거나 <code>[number, number][]</code>이다.</p>\n<p>아니면 컴파일러는 <code>[[3, 4], [5, 6], [7, 8]]</code>이 list-wrapped argument라고 생각할 수 있다. 이 경우 <code>[[3, 4], [5, 6], [7, 8]]</code>은 <code>T[]</code>타입이 되고 거기서 추론된 <code>T</code>타입은 <code>number[]</code> 혹은 <code>[number, number]</code>이다.</p>\n<p>만약 후자로 추론된다면 위의 이슈는 없었겠지만 안타깝게도 TS는 전자로 추론했다. 그래서 <code>concat</code>에서 추론된 <code>T</code> 타입은 <code>number[][]</code>가 되었다. 이는 <code>a</code>의 타입인 <code>Array&#x3C;[number, number]></code>의 <code>T=[number, number]</code>와 호환되지 않았다. 그래서 에러가 뜬 것이다.</p>\n<h2>3.3. 해결</h2>\n<p>#2에서 사라졌던 오버로딩이 있을 때는 이런 문제가 없었다. 그 이유는 <code>concat</code>의 매개변수 타입이 <code>T[][]</code>로, 정확히는 <code>T[]</code>의 서브타입인 <code>U</code>에 대해서 <code>U[]</code>로 우선적으로 추론되었기 때문이다.</p>\n<pre><code class=\"language-ts\">// 당시 사라졌던 concat의 오버로딩\nconcat&#x3C;U extends T[]>(...items: U[]): T[];\n</code></pre>\n<p>해당 오버로딩을 없앨 당시에는 이런 문제가 없었지만 이슈가 제기되고 나서는 다시 도입되었다. 완전히 똑같은 형태는 아니고 <code>T[][]</code>를 받는 오버로딩이 우선적으로 적용되도록 추가함으로써 이를 해결했다.</p>\n<pre><code class=\"language-ts\">interface Array&#x3C;T> {\n  concat(...items: T[][]): T[];\n  concat(...items: (T | T[])[]): T[];\n}\n</code></pre>\n<p>이렇게 하면 매개변수 타입을 <code>T[][]</code>으로 추론하는 오버로딩이 우선적으로 적용되기 때문에 위의 추론 문제가 해결된다.</p>\n<h2>3.4. ReadonlyArray와의 싱크</h2>\n<p><code>ReadonlyArray</code>는 읽기 전용 배열(<code>push</code>, <code>pop</code>등이 빠진)이므로 <code>Array</code>의 슈퍼타입이다. 그런데 <a href=\"https://github.com/microsoft/TypeScript/issues/10368\"><code>Array.concat</code>의 오버로딩 변경사항이 <code>ReadonlyArray</code>에는 적용되지 않아서 <code>ReadonlyArray</code>에 <code>Array</code>를 할당할 수 없게 되어버린 이슈가 있었다.</a></p>\n<p>따라서 <a href=\"https://github.com/microsoft/TypeScript/pull/10374\">2016년 8월의 PR에서 <code>ReadonlyArray</code>에도 <code>Array.concat</code>의 오버로딩 변경사항이 동일하게 적용되도록 수정되었다.</a></p>\n<pre><code class=\"language-ts\">interface ReadonlyArray&#x3C;T> {\n  concat(...items: T[][]): T[];\n  concat(...items: (T | T[])[]): T[];\n}\n</code></pre>\n<h1>4. 매개변수를 ReadonlyArray로 변경</h1>\n<p>원리상 <code>ReadonlyArray</code>도 <code>concat</code>을 할 수 있어야 맞다. 읽기 전용의 배열이 <code>concat</code>에 쓰이지 못할 이유는 없기 때문이다.</p>\n<p><a href=\"https://github.com/microsoft/TypeScript/issues/17076\">그런데 기존의 오버로딩에서는 매개변수를 <code>T[][]</code> 등 어쨌든 배열, 즉 <code>Array</code> 타입으로 추론했다. 때문에 <code>ReadonlyArray</code>끼리는 <code>concat</code>을 제대로 할 수 없다는 이슈가 있었다.</a></p>\n<p>따라서 <a href=\"https://github.com/microsoft/TypeScript/pull/17806\">2017년 8월 <code>concat</code>의 매개변수가 되는 배열을 기본적으로 <code>ReadonlyArray</code>로 추론하도록 수정되었다.</a></p>\n<pre><code class=\"language-ts\">interface ReadonlyArray&#x3C;T> {\n  concat(...items: ReadonlyArray&#x3C;T>[]): T[];\n  concat(...items: (T | ReadonlyArray&#x3C;T>)[]): T[];\n}\n\ninterface Array&#x3C;T> {\n  concat(...items: ReadonlyArray&#x3C;T>[]): T[];\n  concat(...items: (T | ReadonlyArray&#x3C;T>)[]): T[];\n}\n</code></pre>\n<h1>5. <code>ConcatArray</code> 도입 - 배경</h1>\n<p><code>ConcatArray</code> 도입의 배경이 된 이슈에 대해 TS 리드 아키텍트인 <a href=\"https://github.com/ahejlsberg\">Anders Hejlsberg</a>가 남긴 <a href=\"https://github.com/microsoft/TypeScript/issues/20268#issuecomment-362614906\">코멘트가 있다.</a> 이를 해석하고 설명한 내용에 가깝다.</p>\n<p>그리고 여기부터는 가변성(variance)이라는 개념이 깊이 연관되어 있다. 가변성에 대해서는 <a href=\"https://witch.work/posts/typescript-covariance-theory\">이전 글인 TS 탐구생활 - 가변성(Variance)이란 무엇인가</a>를 참고할 수 있다.</p>\n<p>그리고 여기서는 홍재민 님의 <code>타입으로 견고하게 다형성으로 유연하게</code>의 번역어를 따라 공변(covariance)과 반변(contravariance), 불변(invariance), 양변(bivariance)으로 표기한다. 불변이 immutable이 아니라 invariance임에 주의한다.</p>\n<h2>5.1. 이슈 내용</h2>\n<p><a href=\"https://github.com/microsoft/TypeScript/issues/20268\">다음과 같은 이슈가 있었다. 인수에 대한 타입 검증이 안 된다는 것이었다.</a></p>\n<pre><code class=\"language-ts\">// Error:(3, 28) TS2345:Argument of type 'Processor[]' is not assignable to parameter of type 'Processor | ReadonlyArray&#x3C;Processor>'.\ntype Processor&#x3C;T extends object> = &#x3C;T1 extends T>(subj: T1) => T1;\n\nfunction doStuff&#x3C;T extends object, T1 extends T>(\n  parentProcessors: Array&#x3C;Processor&#x3C;T>>,\n  childProcessors: Array&#x3C;Processor&#x3C;T1>>\n) {\n  childProcessors.concat(parentProcessors);\n}\n</code></pre>\n<p>일단 이 코드를 한 번 살펴보자. <code>Processor&#x3C;T></code> 제네릭은 <code>object</code> 즉 객체 타입을 상속하는 타입 <code>T</code>를 사용하는데, <code>T</code>를 상속한 <code>T1</code>타입을 매개변수로 받아 같은 타입을 반환하는 함수 타입이다.</p>\n<p>그리고 <code>doStuff</code>는 <code>childProcessors</code>에 <code>parentProcessors</code>를 병합하는 동작이 들어 있는 함수이다. <code>parentProcessors</code>는 <code>Processor&#x3C;T></code>의 배열이고 <code>childProcessors</code>는 <code>Processor&#x3C;T1></code>의 배열이다. <code>T1</code>은 <code>T</code>의 서브타입이다.</p>\n<p>당시 <code>concat</code>의 타입을 보면 <code>doStuff</code> 내부의 <code>concat</code>은 타입 에러를 일으키면 안 된다. <code>Array&#x3C;Processor&#x3C;T>></code>는 <code>ReadonlyArray&#x3C;Processor&#x3C;T1>></code>의 서브타입이기 때문이다.</p>\n<pre><code class=\"language-ts\">interface Array&#x3C;T> {\n  concat(...items: ReadonlyArray&#x3C;T>[]): T[];\n  concat(...items: (T | ReadonlyArray&#x3C;T>)[]): T[];\n}\n</code></pre>\n<p>이유는 다음과 같다.</p>\n<ol>\n<li><code>Processor&#x3C;T></code>는 반변이다. <code>Processor&#x3C;T></code>타입은 <code>T</code>의 서브타입으로 제한된 <code>T1</code>을 타입 매개변수로 받아서 같은 타입을 리턴하는 함수이다. 그리고 함수 매개변수는 반변이다. 따라서 <code>Processor&#x3C;T></code>는 반변이다.</li>\n<li>따라서 <code>T1</code>이 <code>T</code>의 서브타입일 때 <code>Processor&#x3C;T></code>는 <code>Processor&#x3C;T1></code>의 서브타입이다.</li>\n<li><code>Array&#x3C;T></code>는 <code>ReadonlyArray&#x3C;T></code>의 서브타입이고 공변이므로 <code>T1</code>이 <code>T</code>의 서브타입일 때 <code>Array&#x3C;Processor&#x3C;T>></code>는 <code>ReadonlyArray&#x3C;Processor&#x3C;T1>></code>의 서브타입이다.</li>\n</ol>\n<p>그런데 이 동작은 당시 시점에서 에러가 발생했다. 해당 이슈 코드의 맥락에서 <code>Array</code>가 <code>ReadonlyArray</code>의 서브타입이 될 수 없었기 때문이다.</p>\n<p>왜 그런지는 상당히 복잡한 이유가 있었다. 먼저 배경이 되는 TS의 변경사항부터 살펴보아야 한다.</p>\n<h2>5.2. 이슈의 배경 - 콜백의 매개변수 제네릭</h2>\n<p>위와 같은 문제의 원인을 정확히 파악하려면 먼저 <a href=\"https://github.com/microsoft/TypeScript/pull/15104\">콜백의 매개변수 타입으로 쓰인 제네릭을 공변으로 타입 체킹하도록 변경한 PR</a>을 봐야 한다.</p>\n<p>이 당시에는 함수 매개변수 타입을 반변으로 동작하도록 하는 <code>--strictFunctionTypes</code> 옵션이 없었다. 따라서 함수 매개변수의 타입은 언제나 양변이었다.</p>\n<p>(TODO : 왜 TS에서 제네릭을 기본적으로 공변으로 하는 타협이 있었는지에 대한 내용이 포함된 글은 작성 중이다. 추후 링크 추가예정)</p>\n<p>다음 글에서 더 자세히 다루겠지만 이는 <code>Array&#x3C;T></code>등의 제네릭을 공변으로 동작하도록 만들기 위한 타협이었다. 여담이지만 당연히 함수 매개변수는 반변으로 동작하는 것이 자연스럽고 이는 이후 <a href=\"https://github.com/microsoft/TypeScript/pull/18654\">Strict function types PR</a>를 통해 실현되게 된다.</p>\n<p>그런데 이렇게 함수 매개변수가 늘 양변이던 시점에 콜백 함수의 매개변수 타입은 어땠을까? 콜백 함수도 함수이므로 역시 양변이었다. 그런데 <a href=\"https://github.com/microsoft/TypeScript/issues/14770\">콜백 함수 매개변수 타입의 양변은 <code>Promise&#x3C;T></code>와 같은 기본 제네릭 타입들에서 타입 체크가 제대로 이루어지지 않는 문제를 일으켰다.</a></p>\n<pre><code class=\"language-ts\">// a, b는 Promise의 T타입을 {foo: \"bar\"}로 제한했다.\n// 하지만 실제 a, b에 제공된 T타입은 다른 타입이었다.\n// 그런데 콜백 함수의 매개변수 타입이 양변이었기 때문에 에러가 나지 않았다.\nconst a: Promise&#x3C;{ foo: \"bar\" }> = Promise.resolve({ foo: \"typo\" });\nconst b: Promise&#x3C;{ foo: \"bar\" }> = Promise.resolve({});\n</code></pre>\n<p>이론적으로 생각해 보아도 콜백 함수의 매개변수 타입으로만 쓰이는 제네릭 타입은 공변인 게 자연스럽다. 콜백 함수의 사용을 생각해 보면 콜백 함수의 매개변수는 마치 리턴 타입과 같이 출력에 해당한다고 볼 수 있기 때문이다.</p>\n<p>예시로 보면 더 이해가 쉽다. 이런 제네릭의 대표적인 예시로는 방금 본 <code>Promise&#x3C;T></code>가 있다. <code>T</code>는 <code>Promise&#x3C;T></code>에서 콜백 함수의 매개변수 타입으로밖에 쓰이지 않는다.</p>\n<p>만약 TS에서 <code>Promise&#x3C;T></code> 타입이 어떤 식으로 정의되어 있는지 더 자세히 보고 싶다면 <a href=\"https://witch.work/posts/typescript-promise-type\">TS 탐구생활 - TS의 Promise type 정의</a> 글을 참고할 수 있다.</p>\n<p>아무튼 <code>Promise</code>의 용법만 생각해 보아도 제네릭은 공변인 게 맞다. <code>Dog</code>이 <code>Animal</code>의 서브타입이라면 <code>Promise&#x3C;Dog></code>는 <code>Promise&#x3C;Animal></code>의 서브타입인 게 자연스럽다. <a href=\"https://github.com/microsoft/TypeScript/issues/14770#issuecomment-288666906\">TS보다 더 강한 타입 시스템을 지향하는 flow에서도 promise의 제네릭 타입 인자는 공변이다.</a></p>\n<p>따라서 당시 함수 매개변수는 양변이지만 콜백의 매개변수 타입은 공변으로 타입 검사하도록 변경한 것이 바로 이 PR이다. <code>Promise&#x3C;T></code>외의 예시는 다음과 같은 게 있겠다. <a href=\"https://github.com/microsoft/TypeScript/pull/15104#issuecomment-299425304\">해당 PR의 댓글</a>에서 가져왔다.</p>\n<pre><code class=\"language-ts\">interface Box&#x3C;T> {\n  foo: (cb: (x: T) => void) => void;\n}\n\ndeclare const bA: Box&#x3C;Animal>;\n// 원래는 콜백의 매개변수 타입을 양변으로 검사하여 에러가 나지 않았다.\n// 해당 PR로 인해 콜백의 매개변수 타입은 공변으로 검사되어 다음 문장은 이제 에러가 난다.\nconst bC: Box&#x3C;Cat> = bA;\n</code></pre>\n<p>이는 메서드가 콜백 함수를 받을 때도 마찬가지로 적용되어 메서드의 콜백 함수의 매개변수도 공변이다. <code>Promise.then()</code>등의 메서드의 용법을 생각해 보면 합리적인 선택이다.</p>\n<h2>5.3. 이슈 심층 분석</h2>\n<p>그럼 다시 돌아가보자. 왜 <a href=\"https://github.com/microsoft/TypeScript/issues/20268\">해당 이슈</a>의 코드에서는 <code>Array</code>가 <code>ReadonlyArray</code>의 서브타입이 될 수 없었을까? 이 섹션에서는 그걸 알아본다. 이슈의 코드를 다시 보자.</p>\n<pre><code class=\"language-ts\">// Error:(3, 28) TS2345: Argument of type 'Processor[]' is not assignable to parameter of type 'Processor | ReadonlyArray&#x3C;Processor>'.\ntype Processor&#x3C;T extends object> = &#x3C;T1 extends T>(subj: T1) => T1\n\nfunction doStuff&#x3C;T extends object, T1 extends T>(parentProcessors: Array&#x3C;Processor&#x3C;T>>, childProcessors : Array&#x3C;Processor&#x3C;T1>>) {\n    childProcessors.concat(parentProcessors);\n}\n</code></pre>\n<p>그리고 아까 보았던 당시의 <code>Array.concat</code> 타입이다.</p>\n<pre><code class=\"language-ts\">interface Array&#x3C;T> {\n  concat(...items: ReadonlyArray&#x3C;T>[]): T[];\n  concat(...items: (T | ReadonlyArray&#x3C;T>)[]): T[];\n}\n</code></pre>\n<p>앞서 언급했듯 <code>doStuff</code>의 <code>concat</code>에서 에러가 나지 않으려면 <code>parentProcessors</code>의 타입인 <code>Array&#x3C;Processor&#x3C;T>></code>가 <code>ReadonlyArray&#x3C;Processor&#x3C;T1>></code>의 서브타입이어야 하고 이론상으로 따져보면 그 서브타입 관계는 성립하는 게 맞아 보인다.</p>\n<p>하지만 그럴 수 없었기에 에러가 발생했다. 그 이유는 구조적 타입 검사 과정에서 <code>indexOf</code> 메서드의 타입 검사에서 문제가 발생했기 때문이다.</p>\n<p><code>Array&#x3C;T></code>가 <code>ReadonlyArray&#x3C;T></code>의 서브타입이 되려면 <code>Array&#x3C;T></code>의 모든 멤버가 <code>ReadonlyArray&#x3C;T></code>의 멤버에 대입될 수 있어야 한다. 그런데 <code>Array&#x3C;T></code>의 <code>indexOf</code> 메서드 타입을 보자.</p>\n<pre><code class=\"language-ts\">interface Array&#x3C;T> {\n  indexOf(searchElement: T, fromIndex?: number): number;\n}\n</code></pre>\n<p>그럼 이슈 상황에서, <code>Processor&#x3C;T></code>가 <code>Processor&#x3C;T1></code>의 서브타입인데 이때 <code>ReadonlyArray&#x3C;Processor&#x3C;T1>></code>의 <code>indexOf</code> 메서드에 <code>Processor&#x3C;T></code>의 <code>indexOf</code>를 대입할 수 있을까?</p>\n<p>불가능하다. 그게 가능하기 위해서는 <code>Array</code>의 제네릭이 공변으로 동작해야 한다. 하지만 이 시점에는 함수의 매개변수 타입은 반변으로 타입 체크하도록 하는 <a href=\"https://github.com/microsoft/TypeScript/pull/18654\">Strict function types PR</a>이 도입되어 있었고 따라서 <code>indexOf</code>의 매개변수 <code>searchElement</code>의 타입 <code>T</code>는 반변이 된다.</p>\n<p>그래서 이슈 상황에서는 <code>Array</code>의 제네릭이 공변으로 동작하지 않았고 <code>Array&#x3C;T></code>는 <code>ReadonlyArray&#x3C;T></code>의 서브타입이 되지 못했다.</p>\n<p>생길 수 있는 의문 몇 가지는 다음 섹션에서 다룬다.</p>\n<h2>5.4. 가능한 의문</h2>\n<h3>5.4.1. 메서드 매개변수가 양변으로 동작하지 않은 이유</h3>\n<p><a href=\"https://seob.dev/posts/%EA%B3%B5%EB%B3%80%EC%84%B1%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\">TS에서 이런 일은 이미 <code>push</code>등의 배열 메서드에 의해 예견되어 왔고 TS팀은 메서드 매개변수를 늘 양변으로 취급하는 타협을 통해서 이 문제를 회피해 왔다. 여기에 관해서는 이현섭 님의 '공변성이란 무엇인가'를 참고할 수 있다.</a></p>\n<p>따라서 왜 위의 경우에서 <code>indexOf</code>메서드가 양변으로 동작하지 않았는지에 대한 의문을 가질 수 있다. 나도 그랬다.</p>\n<blockquote>\n<p>That's usually masked by the fact that we always compare methods bivariantly, but in this scenario we don't because of #15104.</p>\n</blockquote>\n<p><a href=\"https://github.com/microsoft/TypeScript/issues/20268#issuecomment-362614906\">이슈의 댓글</a>에서 이 의문을 풀어주고 있다. 보통 메서드 매개변수는 양변으로 동작하지만 이 경우에는 제네릭이 콜백 함수의 매개변수 타입으로 취급되기 때문에 그렇지 않다는 것이다.</p>\n<p>왜냐 하면 이슈 상황에서 구조적 타입 검사는 콜백 함수 매개변수에 대해서도 일어나기 때문이다.</p>\n<pre><code class=\"language-ts\">childProcessors.concat(parentProcessors);\n</code></pre>\n<p>위 코드를 볼 때 <code>childProcessors.concat</code>의 입장에서는 다음과 같은 형태를 생각하고 <code>.indexOf</code>를 콜백 함수로, <code>searchElement</code>를 콜백함수 매개변수로 취급한다고 생각할 수 있다.(당연히 <code>concat</code>의 타입 정의상 실제로 동작하는 코드는 아니고 추론 과정상 그렇다는 것이다)</p>\n<pre><code class=\"language-ts\">childProcessors.concat(parentProcessors.indexOf(searchElement, ...))\n</code></pre>\n<p>고로 <a href=\"https://github.com/microsoft/TypeScript/pull/15104\">앞서 보았던 PR의 변경사항</a>이 적용된다.</p>\n<blockquote>\n<p>where T is used only in callback parameter positions, will be co-variant (as opposed to bi-variant) with respect to T, ...</p>\n</blockquote>\n<p>그래서 <code>Array</code>의 원소 타입 <code>T</code>(<code>indexOf</code>의 <code>searchElement</code>매개변수 타입)는 양변으로 타입 검사되지 않는다.</p>\n<p>그런데 당연히 <code>Array&#x3C;T></code>에는 <code>T</code>를 입력으로 사용하는 <code>indexOf</code>와 같은 메서드뿐 아니라 출력으로 사용하는 메서드, 이를테면 <code>shift</code>같은 메서드도 있다. <code>reduce</code>같은 건 두 방향 모두 사용한다.</p>\n<pre><code class=\"language-ts\">interface Array&#x3C;T> {\n  indexOf(searchElement: T, fromIndex?: number): number;\n  shift(): T | undefined;\n  // reduce의 여러 오버로딩은 여기서 중요한 건 아니라서 생략했다\n  reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T): T;\n}\n</code></pre>\n<p>그러니 <code>Array&#x3C;T></code>(비슷한 이유로 <code>ReadonlyArray&#x3C;T></code>도)는 불변으로 동작하게 된다.</p>\n<h3>5.4.2. 콜백 매개변수에 대한 엄격한 타입 검사가 일어나지 않는 이유</h3>\n<p>해당 이슈의 해결 시점에는 <a href=\"https://github.com/microsoft/TypeScript/pull/18976\">콜백 함수 매개변수를 반변으로 타입 체킹하는 PR</a>이 머지되어 있었다. 그런데 왜 콜백 함수 매개변수에 대한 엄격한 타입 체크가 일어나지 않았을까?</p>\n<p>메서드 매개변수에 대해서는 이 엄격한 타입 체크가 일어나지 않았기 때문이다. 메서드 매개변수의 타입은 여전히 양변인 구멍으로 남아 있었다. <a href=\"https://github.com/microsoft/TypeScript/pull/18976#issuecomment-334623422\">PR의 댓글</a>에도 콜백의 타입이 메서드가 아닐 때만 콜백 함수에 대한 엄격한 타입 체킹이 일어난다고 되어 있다.</p>\n<blockquote>\n<p>I suppose we could say that a callback parameter check occurs only if the callback type isn't declared as method.</p>\n</blockquote>\n<p><a href=\"https://github.com/microsoft/TypeScript/issues/18963#issuecomment-334586832\">메서드의 콜백 함수 타입에 대해 엄격한 타입 체킹이 일어나지 않는 이유는 콜백 함수의 리턴타입에 의존하는 타입이 많았기 때문이다. 예를 들어 <code>reduce</code>같은 메서드가 있었다.</a> 이를 엄격하게 체크할 경우 <code>Array&#x3C;T></code>는 불변이 되어버린다.(위의 이슈 상황에서 발생한 게 바로 그 상황이다)</p>\n<pre><code class=\"language-ts\">// 만약 reduce의 콜백을 엄격하게 타입 체킹했을 경우\n// T는 함수 매개변수 타입이기도 하므로 반변이고 콜백 매개변수이기도 하므로 공변이다.\n// 따라서 이렇게 하면 Array&#x3C;T>의 공변은 불가능해져 버린다\ninterface Array&#x3C;T> {\n  reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue?: T): T;\n}\n</code></pre>\n<p>하지만 메서드의 콜백 함수로 메서드가 쓰이게 된 경우 <a href=\"https://github.com/microsoft/TypeScript/pull/15104\">앞서 보았던 PR의 변경사항</a>은 적용되는 것으로 보인다. 메서드가 메서드의 콜백 함수로 쓰이게 된 경우 해당 콜백의 매개변수 타입이 공변으로 검사되는 것이다.</p>\n<blockquote>\n<p>where T is used only in callback parameter positions, will be co-variant (as opposed to bi-variant) with respect to T, ...</p>\n</blockquote>\n<h2>5.5. 정리</h2>\n<p><img src=\"/static/type-structure-83a42540.png\" alt=\"이슈의 타입 구조\"></p>\n<p>ReadonlyArray<t>, Array<t>가 불변이 되는 것에는 다음과 같은 이슈들이 관련되어 있었다.</t></t></p>\n<ul>\n<li><a href=\"https://github.com/microsoft/TypeScript/pull/15104\">#15104(Covariant checking for callback parameters)</a></li>\n</ul>\n<p>콜백 함수의 매개변수 타입을 공변으로 동작하도록 변경했다. 따라서 <code>Array.concat</code>의 인수로 들어간 <code>Array.indexOf</code>의 인수 타입이 공변으로 취급된다.</p>\n<ul>\n<li><a href=\"https://github.com/microsoft/TypeScript/pull/18654\">#18654(Strict function types)</a></li>\n</ul>\n<p>함수 매개변수 타입을 반변으로 동작하도록 변경했다. 메서드의 매개변수 타입은 여기서 예외가 되어 양변이 되었다. 하지만 이슈 상황에서는 <code>#15104</code>때문에 <code>Array.indexOf</code>의 인수 타입이 <code>concat</code>의 콜백의 매개변수 타입으로 취급되어 양변으로 검사되지 않았다. 따라서 <code>Array.indexOf</code>의 인수 타입은 콜백 매개변수이므로 공변이어야 하면서 함수 매개변수이므로 반변이어야 한다. 따라서 불변이 되고 만다.</p>\n<ul>\n<li><a href=\"https://github.com/microsoft/TypeScript/pull/18976\">#18976(Strictly check callback parameters)</a> 무력화됨</li>\n</ul>\n<p>콜백 함수의 인수를 엄격하게 검사하도록 한 PR이다. 하지만 메서드 매개변수에 적용되지 않아서 위 이슈에서는 의미가 없어진다.</p>\n<p>위와 같은 이유로 <code>Array&#x3C;T></code>는 불변이 되고 <code>ReadonlyArray&#x3C;T></code>도 마찬가지다. 즉 <code>Array&#x3C;T></code>는 <code>T</code>의 서브타입 관계나 구조적 타이핑에 상관없이 <code>ReadonlyArray&#x3C;T></code>의 서브타입이 될 수 없다.</p>\n<p>따라서 이슈의 상황에서 <code>parentProcessors</code>의 타입은 <code>childProcessors</code>의 타입의 서브타입이 아니게 된다. 고로 에러가 발생한다.</p>\n<p>이외에도 <code>--strictFunctionTypes</code> 하에서 <code>ReadonlyArray</code>와 <code>Array</code>를 구조적으로 비교하는 건 둘을 불변으로 만드는 문제가 있다는 건 <a href=\"https://github.com/microsoft/TypeScript/issues/20454#issuecomment-406453517\">다른 이슈 댓글</a>에서도 볼 수 있다.</p>\n<p>참고로 이를 해결하기 위해 <code>indexOf</code>등을 공변으로 동작하게 하는 등의 해결책이 논의되었지만 많은 제한을 두거나 <code>any</code>타입을 사용하게 되는 문제가 있었다고 한다. 따라서 <code>concat</code>의 타입을 그대로 두면 이런 문제가 발생할 수밖에 없었다.</p>\n<h1>6. <code>ConcatArray</code> 도입</h1>\n<h2>6.1. 앞선 이슈의 쉬운 해결책</h2>\n<p>결국 앞에서 본 이슈의 문제는 <code>Array&#x3C;T></code>가 <code>ReadonlyArray&#x3C;T></code>의 서브타입이 아니라는 데에서 발생했다.</p>\n<p>이를 고치기 위해서는 아주 간단한 방법이 있는데, <code>concat</code>의 매개변수 타입을 <code>ReadonlyArray&#x3C;T></code>뿐 아니라 <code>Array&#x3C;T></code>도 포함된 유니언으로 바꾸면 된다. <a href=\"https://github.com/microsoft/TypeScript/pull/20455\">그렇게 한 PR</a>에서는 다음과 같은 오버로딩으로 <code>concat</code>의 타입을 수정하였다.</p>\n<pre><code class=\"language-ts\">interface Array&#x3C;T> {\n  concat(...items: (T[] | ReadonlyArray&#x3C;T>)[]): T[];\n  concat(...items: (T | T[] | ReadonlyArray&#x3C;T>)[]): T[];\n}\n</code></pre>\n<p><a href=\"https://github.com/microsoft/TypeScript/pull/20455#issuecomment-362371634\">당시의 댓글에는 이런 제안도 있었다. 콜백 내에서 배열을 수정하는 건 당연히 좋은 일이 아니므로 <code>Array&#x3C;T></code>의 메서드 내의 모든 콜백 함수 타입이 <code>ReadonlyArray&#x3C;T></code>를 사용하게 하면 깔끔하게 해결된다는 것이다. 하지만 이는 당연히 breaking change가 된다. 따라서 다음 섹션에서 살펴볼 해결책이 등장하였다.</a></p>\n<h2>6.2. 구조적 타이핑 기반의 해결책</h2>\n<p><a href=\"https://github.com/microsoft/TypeScript/pull/21462\">2018년이 되어서 현재와 같은 타입의 PR이 나오게 되는데</a>그 과정은 다음과 같다. 먼저 <code>Array.concat</code>의 기존 타입이 <code>T[]</code>와 <code>ReadonlyArray&#x3C;T></code>와의 유니언을 받는 것이 컴파일 속도를 느리게 만들었다. 따라서 다음과 같이 오버로딩이 수정되었다.</p>\n<pre><code class=\"language-ts\">interface Array&#x3C;T> {\n  concat(...items: T[][]): T[];\n  concat(...items: ReadonlyArray&#x3C;T>[]): T[];\n  concat(...items: (T | T[])[]): T[];\n  concat(...items: (T | ReadonlyArray&#x3C;T>)[]): T[];\n}\n</code></pre>\n<p>하지만 오버로딩이 이렇게 많은 게 좋지 않다고 본 <a href=\"https://github.com/ahejlsberg\">Anders Hejlsberg</a>는 <code>concat</code>의 매개변수 역할을 할 새로운 타입을 도입하자는 제안을 한다.</p>\n<p><code>Array&#x3C;T></code> 혹은 <code>ReadonlyArray&#x3C;T></code> 타입이 매개변수로 들어왔을 때 구조적 타이핑 검사를 통과할 수 있고 또한 구조적 타입 검사에서 <code>Array&#x3C;T></code>나 <code>ReadonlyArray&#x3C;T></code>를 불변으로 취급되게 할 <code>indexOf</code>등의 메서드를 모두 제거한 <code>InputArray&#x3C;T></code>를 제안한 것이다.</p>\n<pre><code class=\"language-ts\">interface InputArray&#x3C;T> {\n  readonly length: number;\n  readonly [n: number]: T;\n  join(separator?: string): string;\n}\n</code></pre>\n<p><code>join</code>은 <code>string</code> 혹은 배열과 비슷하게 보일 수 있는 다른 객체와 겹치는 상황을 피하기 위해 남겨둔 메서드였다. 그리고 <code>concat</code>을 이렇게 바꾸길 제안한다.</p>\n<pre><code class=\"language-ts\">interface Array&#x3C;T> {\n  concat(...items: InputArray&#x3C;T>[]): T[];\n  concat(...items: (T | InputArray&#x3C;T>)[]): T[];\n}\n</code></pre>\n<p>이는 <code>ReadonlyArray&#x3C;T></code>를 사용하는 것에 비해 약간 덜 타입 안전하다고 할 수 있다. <code>InputArray&#x3C;T></code> 조건을 만족하는 배열이 아닌 객체가 <code>concat</code>의 매개변수로 들어올 수 있기 때문이다. 하지만 그렇게까지 위험해지는 건 아니고, 오버로딩도 줄어들고, <code>Array&#x3C;T></code>와 <code>ReadonlyArray&#x3C;T></code>를 구조적으로 비교할 때 불변으로 취급되는 문제도 해결되며 컴파일 속도도 10% 빨라졌다고 한다(이 컴파일 속도 향상에 대해서는 이견이 있는 듯 하지만 어쨌든 느려지지는 않았다고 한다).</p>\n<p>그러나 위의 <code>InputArray&#x3C;T></code>정의는 <code>length</code>프로퍼티와 <code>join(string): string</code>메서드만 있으면 되기에 너무 쉽게 겹칠 수 있다는 이야기가 나왔다. 따라서 <code>slice</code>메서드를 추가하고 이름을 <code>ConcatArray</code>로 바꾼 다음 타입이 등장했다.</p>\n<pre><code class=\"language-ts\">interface ConcatArray&#x3C;T> {\n  readonly length: number;\n  readonly [n: number]: T;\n  join(separator?: string): string;\n  slice(start?: number, end?: number): T[];\n}\n</code></pre>\n<p>그리고 <code>concat</code>의 오버로딩은 다음과 같이 바뀌었다. 이게 현재의 <code>concat</code>의 타입이다.</p>\n<pre><code class=\"language-ts\">interface Array&#x3C;T> {\n  concat(...items: ConcatArray&#x3C;T>[]): T[];\n  concat(...items: (T | ConcatArray&#x3C;T>)[]): T[];\n}\n</code></pre>\n<h1>7. 앞으로</h1>\n<p>지금은 2023년 12월이고, <code>concat</code>에 관한 마지막 PR이 머지된 지 5년이 지났다. 그 사이에 많은 이슈 보고가 있었다. <a href=\"https://github.com/microsoft/TypeScript/issues/26976\">예를 들어서 빈 배열은 <code>concat</code>의 target이 될 수 없는 문제 등이 있다.</a></p>\n<pre><code class=\"language-ts\">// No overload matches this call.\nlet a1 = [].concat([\"a\"]);\n</code></pre>\n<p><a href=\"https://github.com/microsoft/TypeScript/pull/33645\">이를 수정하기 위한 PR</a>도 있었지만 <a href=\"https://github.com/microsoft/TypeScript/pull/33645#issuecomment-1058376819\">배열 타입에 어떤 변화를 만들기 힘든 상황이기 때문에 긴 시간 반영되지 못하고 있다.</a></p>\n<p>새롭게 제시된 <code>concat</code>의 타입도 있다. <code>ConcatArray&#x3C;T></code> 타입은 아까와 같다.</p>\n<pre><code class=\"language-ts\">interface Array&#x3C;T> {\n  concat(...items: ConcatArray&#x3C;T>[]): T[];\n  concat&#x3C;U extends any[]>(...items: U): (T | Flatten&#x3C;U[number]>)[];\n}\n\ntype Flatten&#x3C;T> = T extends undefined ? T : T extends ConcatArray&#x3C;infer U> ? U : T;\n</code></pre>\n<p>이 오버로딩은 빈 배열도 <code>concat</code>의 target이 될 수 있게 하고 서로 다른 타입 간에도 <code>concat</code>이 가능하게 하는 등 여러 이슈를 해결한다.</p>\n<p>따라서 해당 PR을 잘 반영해서 배열 타입을 수정해 보기 위해 <a href=\"https://github.com/microsoft/TypeScript/issues/36554\">TS팀은 배열 메서드가 기대하는 대로 동작하지 않는 예시들을 모으는 PR을 현재 열어 놓은 상태이다.</a> 언젠가 위의 개선안이 받아들여져서 <code>concat</code> 타입의 발전이 있었으면 좋겠다.</p>\n<h1>참고</h1>\n<p><a href=\"https://github.com/ahejlsberg\">Anders Hejlsberg</a>의 얼굴을 이슈에서 너무 많이 보아서 이제 내적 친밀감이 생겨 버렸다. 깃헙 이슈와 PR의 코멘트로나마 많은 도움을 받았다.</p>\n<p>홍재민, 타입으로 견고하게 다형성으로 유연하게 <a href=\"https://product.kyobobook.co.kr/detail/S000210397750\">https://product.kyobobook.co.kr/detail/S000210397750</a></p>\n<p>MDN의 <code>Array.prototype.concat()</code> 문서 <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/concat\">https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/concat</a></p>\n<p>weird Array.concat declaration and associated LanguageService/typeChecker issues <a href=\"https://github.com/microsoft/TypeScript/issues/738\">https://github.com/microsoft/TypeScript/issues/738</a></p>\n<p>Union types and array.concat problem <a href=\"https://github.com/microsoft/TypeScript/issues/4216\">https://github.com/microsoft/TypeScript/issues/4216</a></p>\n<p>Confusing type error message in concat <a href=\"https://github.com/microsoft/TypeScript/issues/6594\">https://github.com/microsoft/TypeScript/issues/6594</a></p>\n<p>Update Array.concat type signature to fix #6594 <a href=\"https://github.com/microsoft/TypeScript/pull/6629\">https://github.com/microsoft/TypeScript/pull/6629</a></p>\n<p>Tuple types get incorrect contextual type <a href=\"https://github.com/microsoft/TypeScript/issues/9901\">https://github.com/microsoft/TypeScript/issues/9901</a></p>\n<p>Re-add strict concat signature <a href=\"https://github.com/microsoft/TypeScript/pull/9997\">https://github.com/microsoft/TypeScript/pull/9997</a></p>\n<p>Array not assignable to ReadonlyArray with subclass items <a href=\"https://github.com/microsoft/TypeScript/issues/10368\">https://github.com/microsoft/TypeScript/issues/10368</a></p>\n<p>Improve <code>ReadonlyArray&#x3C;T>.concat</code> to match <code>Array&#x3C;T></code> <a href=\"https://github.com/microsoft/TypeScript/pull/10374\">https://github.com/microsoft/TypeScript/pull/10374</a></p>\n<p>Can't concat ReadonlyArray <a href=\"https://github.com/microsoft/TypeScript/issues/17076\">https://github.com/microsoft/TypeScript/issues/17076</a></p>\n<p>Array arguments to concat should be ReadonlyArrays <a href=\"https://github.com/microsoft/TypeScript/pull/17806\">https://github.com/microsoft/TypeScript/pull/17806</a></p>\n<p>polymorphic arguments validation error <a href=\"https://github.com/microsoft/TypeScript/issues/20268\">https://github.com/microsoft/TypeScript/issues/20268</a></p>\n<p>Generic parameters not fully type-checked (e.g., Promise) <a href=\"https://github.com/microsoft/TypeScript/issues/14770\">https://github.com/microsoft/TypeScript/issues/14770</a></p>\n<p>Covariant checking for callback parameters <a href=\"https://github.com/microsoft/TypeScript/pull/15104\">https://github.com/microsoft/TypeScript/pull/15104</a></p>\n<p>Array of generic functions not assignable to ReadonlyArray #20454 의 댓글 <a href=\"https://github.com/microsoft/TypeScript/issues/20454#issuecomment-406453517\">https://github.com/microsoft/TypeScript/issues/20454#issuecomment-406453517</a></p>\n<p>Hack to allow concat to work even when an Array isn't assignable to ReadonlyArray <a href=\"https://github.com/microsoft/TypeScript/pull/20455\">https://github.com/microsoft/TypeScript/pull/20455</a></p>\n<p>strictFunctionTypes has different behavior with parameter types and return types #18963 <a href=\"https://github.com/microsoft/TypeScript/issues/18963\">https://github.com/microsoft/TypeScript/issues/18963</a></p>\n<p>Strictly check callback parameters #18976 <a href=\"https://github.com/microsoft/TypeScript/pull/18976\">https://github.com/microsoft/TypeScript/pull/18976</a></p>\n<p>Overloads in Array.concat now handle ReadonlyArray <a href=\"https://github.com/microsoft/TypeScript/pull/21462\">https://github.com/microsoft/TypeScript/pull/21462</a></p>\n<p>Add additional overloads to Array.prototype.concat #26976 <a href=\"https://github.com/microsoft/TypeScript/issues/26976\">https://github.com/microsoft/TypeScript/issues/26976</a></p>\n<p>Better typings for Array.concat(), etc. <a href=\"https://github.com/microsoft/TypeScript/pull/33645\">https://github.com/microsoft/TypeScript/pull/33645</a></p>\n<p>Array method definition revamp: Use case collection <a href=\"https://github.com/microsoft/TypeScript/issues/36554\">https://github.com/microsoft/TypeScript/issues/36554</a></p>\n<p>Strict function types #18654 <a href=\"https://github.com/microsoft/TypeScript/pull/18654\">https://github.com/microsoft/TypeScript/pull/18654</a></p>\n<p>공변성이란 무엇인가 <a href=\"https://seob.dev/posts/%EA%B3%B5%EB%B3%80%EC%84%B1%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\">https://seob.dev/posts/%EA%B3%B5%EB%B3%80%EC%84%B1%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80</a></p>\n<p>Typescript FAQ - Why are function parameters bivariant? <a href=\"https://github.com/Microsoft/TypeScript/wiki/FAQ#why-are-function-parameters-bivariant\">https://github.com/Microsoft/TypeScript/wiki/FAQ#why-are-function-parameters-bivariant</a></p>",
    "excerpt": "\n\n가변성에 대해 조사하다가 뻗어나온 토픽을 깊게 파다가 쓴 글이다. 이런 식으로 언어의 어떤 부분이 이렇게 된 이유와 역사에 대해 깊이 공부하는 건 매우 좋아하는 일이지만, 들이는 시간에 비해서 뭔가 실질적인 효율이 좋지는 않은 것 같아서 자제하고 있다. 그래도 이런 글을 쓰는 건 재밌다!\n\n썸네일\n\n1. Array.prototype.concat\nTS의 기본 타입 파일 중 하나인 lib.es5.d.ts의 Array<T>를 살펴보고 있었다. 그런데 concat의",
    "headingTree": [
      {
        "title": "썸네일",
        "url": "#썸네일",
        "items": []
      },
      {
        "title": "1. Array.prototype.concat",
        "url": "#1-arrayprototypeconcat",
        "items": [
          {
            "title": "1.1. Array.prototype.concat이란?",
            "url": "#11-arrayprototypeconcat이란",
            "items": []
          },
          {
            "title": "1.2. concat 타입에 관한 생각",
            "url": "#12-concat-타입에-관한-생각",
            "items": []
          }
        ]
      },
      {
        "title": "2. union의 등장으로 인한 변경",
        "url": "#2-union의-등장으로-인한-변경",
        "items": [
          {
            "title": "2.1. 가장 초기의 concat 타입",
            "url": "#21-가장-초기의-concat-타입",
            "items": []
          },
          {
            "title": "2.2. 개선",
            "url": "#22-개선",
            "items": []
          }
        ]
      },
      {
        "title": "3. 오버로딩 추가로 타입 추론 로직 변경",
        "url": "#3-오버로딩-추가로-타입-추론-로직-변경",
        "items": [
          {
            "title": "3.1. 이슈",
            "url": "#31-이슈",
            "items": []
          },
          {
            "title": "3.2. 분석",
            "url": "#32-분석",
            "items": []
          },
          {
            "title": "3.3. 해결",
            "url": "#33-해결",
            "items": []
          },
          {
            "title": "3.4. ReadonlyArray와의 싱크",
            "url": "#34-readonlyarray와의-싱크",
            "items": []
          }
        ]
      },
      {
        "title": "4. 매개변수를 ReadonlyArray로 변경",
        "url": "#4-매개변수를-readonlyarray로-변경",
        "items": []
      },
      {
        "title": "5. ConcatArray 도입 - 배경",
        "url": "#5-concatarray-도입---배경",
        "items": [
          {
            "title": "5.1. 이슈 내용",
            "url": "#51-이슈-내용",
            "items": []
          },
          {
            "title": "5.2. 이슈의 배경 - 콜백의 매개변수 제네릭",
            "url": "#52-이슈의-배경---콜백의-매개변수-제네릭",
            "items": []
          },
          {
            "title": "5.3. 이슈 심층 분석",
            "url": "#53-이슈-심층-분석",
            "items": []
          },
          {
            "title": "5.4. 가능한 의문",
            "url": "#54-가능한-의문",
            "items": [
              {
                "title": "5.4.1. 메서드 매개변수가 양변으로 동작하지 않은 이유",
                "url": "#541-메서드-매개변수가-양변으로-동작하지-않은-이유",
                "items": []
              },
              {
                "title": "5.4.2. 콜백 매개변수에 대한 엄격한 타입 검사가 일어나지 않는 이유",
                "url": "#542-콜백-매개변수에-대한-엄격한-타입-검사가-일어나지-않는-이유",
                "items": []
              }
            ]
          },
          {
            "title": "5.5. 정리",
            "url": "#55-정리",
            "items": []
          }
        ]
      },
      {
        "title": "6. ConcatArray 도입",
        "url": "#6-concatarray-도입",
        "items": [
          {
            "title": "6.1. 앞선 이슈의 쉬운 해결책",
            "url": "#61-앞선-이슈의-쉬운-해결책",
            "items": []
          },
          {
            "title": "6.2. 구조적 타이핑 기반의 해결책",
            "url": "#62-구조적-타이핑-기반의-해결책",
            "items": []
          }
        ]
      },
      {
        "title": "7. 앞으로",
        "url": "#7-앞으로",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 5,
      "wordCount": 1457
    },
    "url": "/posts/typescript-concat-type-history",
    "thumbnail": {
      "local": "/static/concat-issue-b839b4cd.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-concat-issue-b839b4cd-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAIAAAA8r+mnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAaElEQVR4nGP4+vXr3bv37ty5c/vOnevXr////9/B0nTmlCkMs+fOs7SxU1XTCAoOXbR48f///wUYGOsqKxnevnn18cOb/////P//7z8SYAhLLgxLLsyp7Cio7SlvnVLVOaOgtqeksRcA5/c/xpMq6vUAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "typescript-enum-type",
    "title": "TS 탐구생활 - TS의 enum 타입",
    "date": "2023-10-16T00:00:00Z",
    "description": "TS의 enum type에 대해 알아보자",
    "tags": [
      "typescript"
    ],
    "html": "<h1>1. enum 타입 기본</h1>\n<h2>1.1. 기본적인 타입 선언</h2>\n<p><code>enum</code> 타입은 ts에는 없지만 ts에서 사용되는 값이다. 몇몇 다른 언어에서의 열거형과 같이 여러 상수를 묶어서 하나의 타입으로 정의할 수 있다. 이렇게 하면 Red는 0, Green은 1, Blue는 2와 같이 자동 매핑되어 사용할 수 있다. 이런 식으로 실제 값이 숫자인 enum을 숫자형 enum이라고 한다.</p>\n<pre><code class=\"language-ts\">enum Color {\n  Red,\n  Green,\n  Blue,\n}\n</code></pre>\n<p>문자열 enum도 있는데 이는 enum의 각 멤버들을 문자열 리터럴 혹은 다른 문자열 enum의 멤버로 상수 초기화해야 한다. 이렇게 하면 디버깅 시 좀 더 확실하고 의미있는 값을 볼 수 있다는 장점이 있다.</p>\n<pre><code class=\"language-ts\">enum Color {\n  Red=\"RED\",\n  Green=\"GREEN\",\n  Blue=\"BLUE\",\n}\n</code></pre>\n<p>다른 상수를 직접 enum 값으로 매핑할 수도 있다. 만약 숫자를 매핑한 경우 뒤따르는 멤버들은 자동으로 1씩 증가된 값을 매핑받는다. 만약 문자열을 매핑한 경우에는 그 다음 멤버부터는 직접 매핑해야 한다.</p>\n<pre><code class=\"language-ts\">enum Color {\n  Red=1,\n  Green, // 2\n  Blue, // 3\n}\n\nenum Direction {\n  Up=\"UP\",\n  Down=\"DOWN\",\n  // 만약 여기서 갑자기 Left, 만 쓰면 \"DOWN\"다음에 자동 매핑이 일어나지 않으므로 에러가 발생한다\n  Left=\"LEFT\",\n  Right=\"RIGHT\",\n}\n</code></pre>\n<p>하지만 이전에 문자열 매핑을 했더라도 이후에 숫자 매핑을 하게 되면 그 이후 멤버는 다시 문자열을 직접 매핑해 줄 때까지 자동으로 숫자 매핑된다. 이런 식으로 문자열과 숫자를 섞어서 쓰는 것을 이종 enum(heterogeneous enum)이라고 하는데 이는 특별히 그렇게 할 이유가 없는 경우 권장되지 않는다.</p>\n<pre><code class=\"language-ts\">// 이종 enum의 예시\nenum Test{\n    T1=1,\n    T2, // 2\n    T3=\"TEMP\",\n    T4=3,\n    T5, // 4\n}\n</code></pre>\n<h2>1.2. 계산된 값 넣기</h2>\n<p>이후 다루겠지만 enum은 결국 JS 객체이다. 때문에 상수뿐 아니라 계산된 값을 넣을 수도 있다.</p>\n<pre><code class=\"language-ts\">enum Color {\n  Red=getRed(),\n  Green=getGreen(),\n  Blue=getBlue(),\n}\n</code></pre>\n<p>그럼 어떤 경우에 계산된 값으로 취급될까? 상수가 아닐 경우 enum은 계산된 값으로 취급되는데 이 상수란 다음과 같은 것들이다.</p>\n<ol>\n<li>리터럴(문자, 숫자)</li>\n<li>다른 상수 enum 멤버의 참조</li>\n<li>괄호로 묶인 상수 표현식</li>\n<li>상수 표현식에 단항 연산자 <code>+</code>, <code>-</code>, <code>~</code>가 붙은 경우</li>\n<li>상수 표현식을 이항 연산자 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>&#x3C;&#x3C;</code>, <code>>></code>, <code>>>></code>, <code>&#x26;</code>, <code>|</code>, <code>^</code>의 피연산자로 쓴 경우</li>\n</ol>\n<p>즉 위와 같은 값들이 아닌 경우 enum의 멤버는 계산된 값으로 취급되고 이후에 볼 const enum에서도 쓸 수 없다.</p>\n<pre><code class=\"language-ts\">enum Example {\n  // 상수 멤버\n  Foo=1 + 2,\n  Bar=Foo * 2,\n  // 계산된 값\n  Calc='123'.length\n}\n</code></pre>\n<h2>1.3. 사용</h2>\n<p>enum 타입은 다음과 같이 값 대신으로 사용할 수 있다.</p>\n<pre><code class=\"language-ts\">enum Color {\n  Red,\n  Green,\n  Blue,\n}\n\nlet c: Color = Color.Green;\n</code></pre>\n<p>혹은 함수 인수로 특정 값만 강제하도록 해야 할 때 사용할 수 있다. 이렇게 하면 <code>changeColor</code> 함수 내부에서 <code>color</code>에는 <code>Color</code> 타입의 값만 들어올 수 있다.</p>\n<pre><code class=\"language-ts\">function changeColor(color: Color) {\n  console.log(color);\n  // ...\n}\n\nchangeColor(Color.Red);\n</code></pre>\n<p><code>Color</code>의 key로 접근해서 실제 enum 멤버의 이름을 얻어낼 수도 있다. 이를 역 매핑이라고 한다.</p>\n<pre><code class=\"language-ts\">function changeColor(color: Color) {\n  console.log(Color[color]);\n  // ...\n}\n</code></pre>\n<p>전반적으로 어떤 값의 범주로 제한해야 할 때 사용할 수 있다.</p>\n<p>그런데 이런 생각이 들 수 있다. 우리는 이미 이런 기능을 유니언 타입으로 구현할 수 있지 않았나? 다음과 같이 말이다.</p>\n<pre><code class=\"language-ts\">type Color = \"Red\" | \"Green\" | \"Blue\";\n</code></pre>\n<p>그렇다면 enum 타입은 어떤 장점이 있을까? 사실 결론부터 말하면 실용적인 엄청난 장점은 없다. 하지만 일단 enum의 원리부터 알아보고 그쪽으로 넘어가 보자.</p>\n<h1>2. enum 타입의 동작</h1>\n<p>일반적으로 타입 선언과 사용들은 모두 JS 코드로 변환되지 않고 사라졌다. 하지만 enum은 다르다. 다음과 같이 enum을 선언하면 JS 코드로 변환되어 남는다.</p>\n<h2>2.1. enum 타입의 JS 변환</h2>\n<pre><code class=\"language-ts\">enum Color {\n  Red,\n  Green,\n  Blue,\n}\n</code></pre>\n<p>위 타입 선언은 다음과 같이 IIFE로 변환되는 것을 볼 수 있다.</p>\n<pre><code class=\"language-js\">\"use strict\";\nvar Color;\n(function (Color) {\n    Color[Color[\"Red\"] = 0] = \"Red\";\n    Color[Color[\"Green\"] = 1] = \"Green\";\n    Color[Color[\"Blue\"] = 2] = \"Blue\";\n})(Color || (Color = {}));\n</code></pre>\n<p>이는 실제로는 다음과 같은 객체를 만들어서 <code>0</code>과 <code>\"Red\"</code>, <code>1</code>과 <code>\"Green\"</code>, <code>2</code>와 <code>\"Blue\"</code>를 매핑해 놓은 것과 같다.</p>\n<pre><code class=\"language-js\">var Color={\n  0: \"Red\",\n  1: \"Green\",\n  2: \"Blue\",\n  Red: 0,\n  Green: 1,\n  Blue: 2,\n}\n</code></pre>\n<p>JS에서는 enum을 원래 지원하지 않는데 런타임에 사용할 수 있는 enum과 같은 객체를 만들기 위해서 이런 트리키한 방법이 사용되었다고 생각한다.</p>\n<p>그럼 이런 객체를 실제로는 만들지 않도록 할 수는 없을까? <code>const enum</code>을 쓰면 가능하다.</p>\n<h2>2.2. const enum</h2>\n<p><code>const enum</code>을 쓸 시 JS 코드로 변환되지 않고 그냥 값으로 쓰이게 된다.</p>\n<pre><code class=\"language-ts\">// js로 변환 시 const enum 선언은 사라진다. 그리고 이를 사용 시 그냥 Red는 0으로, Blue는 1로 치환되어 사용된다.\nconst enum Color {\n  Red,\n  Green,\n  Blue,\n}\n</code></pre>\n<p>숫자 enum의 경우 숫자를 통해서도 해당 enum 멤버를 얻어낼 수 있는 역 매핑이 원래는 가능했다. 하지만 const enum의 경우 이 역 매핑이 불가능하다. 이는 const enum이 컴파일 시점에 사라지기 때문이다.</p>\n<h1>3. enum 타입의 활용</h1>\n<h2>3.1. 유니언 타입처럼 사용하기</h2>\n<p>enum은 값으로 사용할 수도 있지만 일반적으로 타입으로 사용된다. 이는 다음과 같이 사용할 수 있다.</p>\n<pre><code class=\"language-ts\">enum Color {\n  Red,\n  Green,\n  Blue,\n}\n\nfunction changeColor(color: Color) {\n  console.log(color);\n  // ...\n}\n</code></pre>\n<h2>3.2. 브랜딩 속성으로 활용</h2>\n<p>enum은 브랜딩 속성으로 활용할 수 있다. 브랜딩 속성이란 객체의 구분을 위한 속성을 말한다. 이렇게 브랜드 속성으로 enum 멤버를 쓸 수 있다.</p>\n<pre><code class=\"language-ts\">enum Species{\n    PERSON,\n    DOG,\n}\n\ntype Person={\n    type:Species.PERSON;\n    name:string;\n    age:number;\n}\n\ntype Dog={\n    type:Species.DOG;\n    name:string;\n    age:number;\n}\n\nfunction act(param:Person | Dog){\n    if(param.type==Species.PERSON){\n        console.log(\"Hi\");\n    }\n    else{\n        console.log(\"Bark\");\n    }\n}\n</code></pre>\n<p>주의할 점은 같은 enum 멤버를 사용해야 확실히 구분할 수 있다는 점이다. 다음과 같이 <code>PERSON</code>과 <code>DOG</code>가 다른 enum에서 정의되면 둘 다 실제 값은 <code>0</code>으로 취급될 것이라서 구분할 수 없다.</p>\n<pre><code class=\"language-ts\">enum Species{\n    PERSON,\n}\n\nenum Species2{\n    DOG,\n}\n</code></pre>\n<p>물론 직접 값을 정의해 준 경우에는 구분될 것이다.</p>\n<p><code>const enum</code>을 쓸 시 JS 코드로 변환되지 않고 그냥 값으로 쓰이게 된다.</p>\n<pre><code class=\"language-ts\">// js로 변환 시 아무 코드도 없다. 그리고 이를 사용 시 그냥 PERSON은 0으로, DOG는 1로 치환되어 사용된다.\nconst enum Species{\n    PERSON,\n    DOG,\n}\n</code></pre>\n<h1>참고</h1>\n<p>ts handbook - Enums <a href=\"https://www.typescriptlang.org/ko/docs/handbook/enums.html\">https://www.typescriptlang.org/ko/docs/handbook/enums.html</a></p>\n<p>TypeScript enums vs. types: Enhancing code readability\n<a href=\"https://blog.logrocket.com/typescript-enums-vs-types/#using-enums-reverse-mapping\">https://blog.logrocket.com/typescript-enums-vs-types/#using-enums-reverse-mapping</a></p>",
    "excerpt": "1. enum 타입 기본\n1.1. 기본적인 타입 선언\nenum 타입은 ts에는 없지만 ts에서 사용되는 값이다. 몇몇 다른 언어에서의 열거형과 같이 여러 상수를 묶어서 하나의 타입으로 정의할 수 있다. 이렇게 하면 Red는 0, Green은 1, Blue는 2와 같이 자동 매핑되어 사용할 수 있다. 이런 식으로 실제 값이 숫자인 enum을 숫자형 enum이라고 한다.\nenum Color {\n  Red,\n  Green,\n  Blue,\n}\n\n문자열 enum도 있는데",
    "headingTree": [
      {
        "title": "1. enum 타입 기본",
        "url": "#1-enum-타입-기본",
        "items": [
          {
            "title": "1.1. 기본적인 타입 선언",
            "url": "#11-기본적인-타입-선언",
            "items": []
          },
          {
            "title": "1.2. 계산된 값 넣기",
            "url": "#12-계산된-값-넣기",
            "items": []
          },
          {
            "title": "1.3. 사용",
            "url": "#13-사용",
            "items": []
          }
        ]
      },
      {
        "title": "2. enum 타입의 동작",
        "url": "#2-enum-타입의-동작",
        "items": [
          {
            "title": "2.1. enum 타입의 JS 변환",
            "url": "#21-enum-타입의-js-변환",
            "items": []
          },
          {
            "title": "2.2. const enum",
            "url": "#22-const-enum",
            "items": []
          }
        ]
      },
      {
        "title": "3. enum 타입의 활용",
        "url": "#3-enum-타입의-활용",
        "items": [
          {
            "title": "3.1. 유니언 타입처럼 사용하기",
            "url": "#31-유니언-타입처럼-사용하기",
            "items": []
          },
          {
            "title": "3.2. 브랜딩 속성으로 활용",
            "url": "#32-브랜딩-속성으로-활용",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 297
    },
    "url": "/posts/typescript-enum-type",
    "thumbnail": {
      "local": "/thumbnails/typescript-enum-type-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-typescript-enum-type-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAjElEQVR4nE3KIQrDMBSA4Yjep5BrhFykEPtsbSDwdFVHNpiY6IjOCVYXiF1ZXUehLvAg4s1t++33ixCC1toY07YtADjnlFLHcYhxHKWUXdc1TYOIpZSUEhGJGCMA9H1vrd33nZlrrcws5vkxDAMieu+J6AfPZXmt63vbSin8l7hcbyd/vk9Tzvm7M/MHA+tp/+9iLb0AAAAASUVORK5CYII="
    }
  },
  {
    "slug": "typescript-covariance-theory",
    "title": "TS 탐구생활 - 가변성(Variance)이란 무엇인가",
    "date": "2023-12-03T00:00:00Z",
    "description": "가변성, 그 개념에 관해서",
    "tags": [
      "typescript"
    ],
    "html": "<ul>\n<li>이 글은 읽는 사람이 슈퍼타입, 서브타입, 제네릭 등 기본적인 타입 시스템의 개념은 알고 있다는 가정하에 쓰여지는 글이다.</li>\n</ul>\n<h1>시작</h1>\n<p>TS를 더 잘 이해하기 위해 타입 시스템을 공부하다가 가변성(variance)이라는 개념을 만났다. 그래서 앞으로 이와 관련해서 2개의 글을 쓸 예정이다. 첫번째 글(이 글)에서는 가변성이라는 게 무엇인지 알아볼 것이다. 그리고 두 번째 글에서는 가변성이라는 개념이 TS에 녹아 있는 부분 몇 가지를 알아볼 것이다.</p>\n<p>이 글에서는 전체적으로 가변성 개념에 대해서 알아본다. 먼저 가변성이 우리에게 어떤 것을 전해줄 수 있는지를 알아보고 가변성의 종류를 알아볼 것이다. 그리고 가변성을 어떻게 정하는지 알아본다. 본격적으로 TS와 관련된 이야기는 다음 글에서 다룰 예정이다.</p>\n<p>이 글에서 쓰인 언어는 따로 언급이 없을 경우 TS 문법을 따른다. 하지만 이 글의 경우 TS의 타입 시스템보다는 일반적인 타입 이론의 관점에서 서술하려고 노력하였다. 다행히 TS 4.7부터 Variance Annotation을 지원하기 시작했기 때문에 이 글의 내용이 대부분 TS에서도 적용될 수 있었다.</p>\n<h1>1. 가변성의 배경</h1>\n<p>이 섹션에서는 이 가변성이라는 개념을 우리가 왜 구체적으로 정의해야 했는지를 알아본다.</p>\n<h2>1.1. 배열의 서브타입 관계</h2>\n<p>TS에서 <code>number</code>가 <code>string | number</code>의 서브타입인 것은 당연하다. <code>string | number</code>가 <code>number</code>의 모든 원소를 포함하기 때문이다. 그리고 <code>Array&#x3C;T></code>는 <code>T</code>타입의 원소들을 가지는 제네릭 타입이다.</p>\n<p>그러면 <code>Array&#x3C;number></code>는 <code>Array&#x3C;string | number></code>의 서브타입이 될까? 이는 당연한 것처럼 보인다. <code>number</code>타입 원소들이 들어 있는 배열은 <code>string | number</code> 원소들이 들어 있는 배열이라고 할 수도 있지 않은가?</p>\n<p>그러면 <code>Array&#x3C;number></code>가 <code>Array&#x3C;string | number></code>의 서브타입이므로 다음과 같은 할당이 가능해진다. 이렇게 하면 <code>numberArray</code>와 <code>stringNumberArray</code>는 같은 배열 객체를 참조하게 된다. 또한 <code>Array&#x3C;string | number></code>를 매개변수로 받는 함수에 <code>Array&#x3C;number></code>를 매개변수로 넘길 수도 있다.</p>\n<pre><code class=\"language-ts\">const numberArray: Array&#x3C;number> = [1, 2, 3];\n// stringNumberArray은 numberArray와 같은 배열 객체를 참조하고 있다\nconst stringNumberArray: Array&#x3C;string | number> = numberArray;\n</code></pre>\n<h2>1.2. 배열의 서브타입 관계로 인한 문제</h2>\n<p>그런데 이렇게 하면 약간의 문제가 발생한다. JS에서 배열은 mutable이기 때문이다.</p>\n<p>우리는 배열의 타입이 <code>Array&#x3C;T></code>라고 할 때 <code>T</code>타입의 원소들을 배열에 추가하는 <code>push</code>등의 메서드를 사용할 수 있다. 그렇게 되면 <code>Array&#x3C;string | number></code>타입은 <code>Array&#x3C;number></code>에 해당하는 배열 객체를 할당받고도 string 타입 원소를 추가할 수 있다! 다음과 같은 코드를 보자.</p>\n<pre><code class=\"language-ts\">const numberArray: Array&#x3C;number> = [1, 2, 3];\n\nconst stringNumberArray: Array&#x3C;string | number> = numberArray;\n\nstringNumberArray.push(\"foo\");\n// stringNumberArray는 이제 [1,2,3,\"foo\"]를 참조하고 있다\nconsole.log(numberArray);\n</code></pre>\n<p><code>stringNumberArray</code>와 <code>numberArray</code>는 이제 둘 다 <code>[1, 2, 3, \"foo\"]</code>를 참조하고 있다. <code>numberArray</code>는 <code>number</code> 타입 배열을 참조해야 하는데 그 배열에 <code>string</code> 타입 원소가 들어간 것이다!</p>\n<p>이때 들어간 <code>\"foo\"</code>는 <code>numberArray</code>의 원소이기도 하므로 해당 원소를 <code>numberArray</code>를 통해서 number 타입으로 사용해봐도 에러가 나지 않는다. 이는 이상한 일이다. <code>n</code>은 number 타입으로 되어 있지만 실제로는 string이기 때문에 <code>toFixed</code>같은 number 타입 메서드를 사용해보면 JS 에러가 발생한다.</p>\n<pre><code class=\"language-ts\">const n: number = numberArray[3];\nconsole.log(n); // \"foo\"\nn.toFixed(); // n.toFixed is not a function 에러 발생\n</code></pre>\n<h2>1.3. 가변성의 등장</h2>\n<p>그럼 뭐가 문제일까? 어떻게 해야 할까? <code>Array&#x3C;number></code>가 <code>Array&#x3C;string | number></code>의 서브타입인 게 잘못되었나? 아예 <code>Array&#x3C;T></code>가 타입 인자들의 서브타입 관계를 무시하고 <code>Array&#x3C;number></code>와 <code>Array&#x3C;string | number></code> 간에는 서브타입 관계가 없다고 정의하는 게 맞는 걸까? 실제로 C#에서는 <code>List&#x3C;T></code>와 같은 제네릭 타입들이 이렇게 동작한다.</p>\n<p>하지만 어쩐지 시원치 않다. '숫자 배열(<code>Array&#x3C;number></code>)'이 '숫자 혹은 문자열이 들어간 배열(<code>Array&#x3C;string | number></code>)'의 서브타입이라는 건 직관적으로 이상한 일이 아니다. 하지만 이를 허용했을 경우 문제가 생기는 것을 우리는 위에서 보았다.</p>\n<p>이걸 어떻게 처리해야 맞는 걸까? 더 나아가서, 하나의 제네릭 타입에 들어간 두 가지 타입에 서브타입 관계가 존재할 때 그렇게 만들어진 두 가지 제네릭 타입의 서브타입 관계는 어떻게 되어야 할까? 이를 어떻게 처리할지 결정하는 데에 쓰이는 개념이 바로 가변성이다.</p>\n<h1>2. 가변성의 종류</h1>\n<p>가변성은 이렇게 제네릭 타입이 주어진 타입 인자들 간의 서브타입 관계를 어떻게 취급하는지에 대한 개념이다. 먼저 이 관계들을 어떤 종류로 구분할 수 있는지를 알아보자. 이런 관계는 총 4가지가 있다.</p>\n<h2>2.1. 공변</h2>\n<p>공변은 제네릭 타입이 타입 인자의 서브타입 관계를 보존하는 것이다. 즉 <code>T</code>가 <code>U</code>의 서브타입이면 <code>Array&#x3C;T></code>는 <code>Array&#x3C;U></code>의 서브타입이 되면 <code>Array&#x3C;T></code>는 공변이다. 제네릭 타입이 타입 인자와 함께 변한다는 뜻을 담아서 공변(covariance)이라고 한다.</p>\n<p><img src=\"/static/array-covariance-bdb1edbe.png\" alt=\"공변적인 Array\"></p>\n<p>TS에서는 함수 인수를 제외한 제네릭 타입들은 기본적으로 공변이다.</p>\n<h2>2.2. 불변</h2>\n<p>불변은 제네릭 타입이 타입 인자의 서브타입 관계를 무시하는 것이다. <code>T</code>가 <code>U</code>의 서브타입이라도 <code>Array&#x3C;T></code>는 <code>Array&#x3C;U></code>의 서브타입이 되지 않으면 <code>Array&#x3C;T></code>는 불변이다. 제네릭 타입이 타입 인자와 함께 변하지 '않는다'는 뜻을 담아서 불변(invariance)이라고 한다.</p>\n<p><img src=\"/static/array-invariance-468dc59a.png\" alt=\"불변적인 Array\"></p>\n<p>C#이나 코틀린 같은 언어에서는 제네릭 타입들이 기본적으로 불변이다.</p>\n<h2>2.3. 반변</h2>\n<p>반변은 제네릭 타입이 타입 인자의 서브타입 관계를 역전시키는 것이다. <code>T</code>가 <code>U</code>의 서브타입이면 <code>Array&#x3C;U></code>가 <code>Array&#x3C;T></code>의 서브타입이 되면 <code>Array&#x3C;T></code>는 반변이다. 제네릭 타입이 타입 인자의 서브타입 관계와 '반대로 변한다'는 뜻을 담아서 반변(contravariance)이라고 한다.</p>\n<p>우리가 지금까지 보았던 <code>Array</code> 같은 경우 공변인 게 당연하다. 그래서 방금 <code>Array</code>를 통해 설명한 반변은 매우 비직관적으로 보인다. 하지만 반변이 자연스러운 경우도 있다.</p>\n<p>바로 함수의 매개변수 타입이 그렇다. <code>(arg:number | string)=>any</code> 타입은 숫자 혹은 문자열을 받아서 아무거나 리턴하는 함수 타입이다. 이는 해당 함수가 순수 함수라고 했을 때, 숫자를 받아서 아무거나 리턴하는 함수 타입인 <code>(arg:number)=>any</code>타입에 포함된다.</p>\n<p><code>숫자를 받아서 처리하는 함수</code>에 비해서 <code>숫자 혹은 문자열을 받아서 처리하는 함수</code>는 더 구체적인 개념이기 때문이다. 다르게 설명한다면, <code>숫자 혹은 문자열을 처리하는 함수</code>는 <code>숫자를 처리하는 함수</code>라고 할 수도 있기 때문에 <code>숫자 혹은 문자열을 받아서 처리하는 함수</code> 타입은 <code>숫자를 받아서 처리하는 함수</code> 타입에 할당될 수 있다. 따라서 서브타입 관계가 성립한다.</p>\n<p><img src=\"/static/parameter-variance-606fd661.png\" alt=\"매개변수의 반변\"></p>\n<p>TS에서 함수의 매개변수 타입이 반변이다(엄밀하게는 <code>strictFunctionTypes</code>옵션이 true일 경우에 그렇다). 코틀린의 <code>Comparator&#x3C;T></code>나 C#의 <code>Action&#x3C;T></code>같이 함수의 매개변수 타입을 제네릭 타입 인자로 결정하는 타입들도 마찬가지로 반변이다.</p>\n<h2>2.4. 양변</h2>\n<p>양변은 제네릭 타입이 타입 인자의 서브타입 관계를 양쪽으로 모두 사용하는 것이다. <code>T</code>가 <code>U</code>의 서브타입이면 <code>Array&#x3C;T></code>는 <code>Array&#x3C;U></code>의 서브타입이면서 슈퍼타입이면 <code>Array&#x3C;T></code>는 양변이다. 제네릭 타입이 타입 인자의 양쪽으로 변한다는 뜻을 담아서 양변(bivariance)이라고 한다.</p>\n<p>타입 검사의 관점에서 크게 유용한 점은 없다. 하지만 이후 글에서 볼 TS의 메서드 타입이 <code>set(item: T): void;</code>와 같은 형식으로 선언될 경우 메서드의 매개변수 타입이 양변이 된다.</p>\n<h1>3. 타입 가변성 정의하기</h1>\n<p>가변성의 배경과 종류를 알아보았다. 이제 우리가 프로그래밍을 하면서 이 가변성이라는 개념을 어떻게 정의할 수 있고, 어떤 경우에 어떤 종류의 가변성을 지정할 수 있는지 알아보자.</p>\n<p><code>Generic&#x3C;T></code>라는 제네릭 타입이 있다고 하자. 그러면 어떤 경우에 해당 타입을 공변적으로, 어떤 경우에 불변적으로, 어떤 경우에 반변적으로 사용할 수 있을까? 요약하자면 <code>Generic</code>이 <code>T</code>를 출력에만 사용하면 공변, 입력에만 사용하면 반변, 입력과 출력에 모두 사용하면 불변이다.</p>\n<p>그럼 입력에 사용한다, 출력에 사용한다는 말은 무슨 뜻일까?</p>\n<h2>3.1. 입력에 사용</h2>\n<p><code>Generic&#x3C;T></code> 인터페이스에서 <code>T</code>를 입력에 사용한다는 것은 <code>T</code>타입의 인수를 받는 메서드를 가지고 있다는 것을 의미한다. 예를 들어 <code>T</code>타입의 인수를 받아서 <code>void</code>를 리턴하는 <code>set</code>메서드를 가지고 있다면 다음과 같다.</p>\n<pre><code class=\"language-ts\">interface Generic&#x3C;T> {\n  set:(value: T) => void;\n}\n</code></pre>\n<p>이렇게 <code>T</code>가 입력에만 사용될 경우 <code>Generic&#x3C;T></code>는 반변적으로 작동할 수 있다. <code>T</code>를 입력에만 사용한다는 말은 <code>T</code>타입을 리턴하는 메서드는 가지고 있지 않고 <code>T</code>타입의 인수를 받는 메서드만 가지고 있다는 것이다.</p>\n<p>이런 경우 <code>in</code>키워드를 사용하여 나타낼 수 있는데 이럴 경우 <code>Generic&#x3C;T></code>는 반변이 되고 <code>T</code>를 메서드의 매개변수 타입에만 사용할 수 있고 리턴 타입으로는 사용할 수 없다.</p>\n<pre><code class=\"language-ts\">// T를 메서드의 매개변수 타입으로만 사용할 수 있다\ninterface Generic&#x3C;in T> {\n  set: (value: T) => void;\n}\n</code></pre>\n<h2>3.2. 출력에 사용</h2>\n<p><code>Generic&#x3C;T></code> 인터페이스에서 <code>T</code>를 출력에 사용한다는 것은 리턴 타입이 <code>T</code>인 메서드를 가지고 있다는 것을 의미한다. 특정 인덱스 원소를 가져오는 메서드를 예시로 들 수 있겠다.</p>\n<pre><code class=\"language-ts\">// T를 메서드 리턴 타입으로만 사용할 수 있다\ninterface Generic&#x3C;T> {\n  get: (index: number) => T;\n}\n</code></pre>\n<p>이렇게 <code>T</code>가 출력에만 사용될 경우 <code>Generic&#x3C;T></code>는 공변적으로 작동할 수 있다. <code>T</code>를 출력에만 사용한다는 말은 <code>T</code>타입의 인수를 받는 메서드를 가지고 있지 않고 <code>T</code>타입의 값을 리턴하는 메서드만 가지고 있다는 것이다.</p>\n<p>이런 경우 <code>out</code>키워드를 사용하여 나타낼 수 있는데 이럴 경우 <code>Generic&#x3C;T></code>는 공변이 되고 <code>T</code>를 메서드의 리턴 타입에만 사용할 수 있고 인수 타입으로는 사용할 수 없다.</p>\n<pre><code class=\"language-ts\">interface Generic&#x3C;out T> {\n  get: (index: number) => T;\n}\n</code></pre>\n<p>단 예외가 있는데 만약 반변인 제네릭 타입이 메서드의 매개 변수로 있는 경우 <code>T</code>를 반변인 제네릭 타입의 타입 인자로 사용할 수 있다.</p>\n<p>예시로 보는 게 이해가 쉽다. 다음 코드에서 <code>Action&#x3C;P></code>는 반변이고 메서드의 매개변수로 넘어갔다. 2번 반변되어서 공변이 되기 때문에 이런 동작이 허용된다.</p>\n<pre><code class=\"language-ts\">type Action&#x3C;P> = (param: P) => any;\n\ninterface Generic&#x3C;out T> {\n  method: (value: Action&#x3C;T>) => void;\n}\n</code></pre>\n<h2>3.3. 입력과 출력에 모두 사용</h2>\n<p><code>Generic&#x3C;T></code> 인터페이스에서 <code>T</code>를 입력과 출력에 모두 사용한다는 것은 <code>T</code>타입의 인수를 받는 메서드와 <code>T</code>타입의 값을 리턴하는 메서드를 모두 가지고 있다는 것을 의미한다.</p>\n<p>특정 인덱스의 원소를 가져와 리턴하는 메서드와 원소를 추가하는 메서드를 모두 가지고 있다고 하자. 이런 경우 <code>T</code>를 입력과 출력에 모두 사용한다고 할 수 있다.</p>\n<pre><code class=\"language-ts\">interface Generic&#x3C;T> {\n  get: (index: number) => T;\n  append: (value: T) => void;\n}\n</code></pre>\n<p>이런 경우 <code>Generic&#x3C;T></code>는 불변이어야 한다. C#이나 코틀린 등 많은 언어들이 대부분의 제네릭에 대해서 기본적으로 불변이다. TS같은 경우 제네릭이 기본적으로 공변이기 때문에 불변 제네릭을 정의하기 위해서는 <code>in out</code>키워드를 모두 사용해야 한다.</p>\n<pre><code class=\"language-ts\">interface Generic&#x3C;in out T> {\n  get: (index: number) => T;\n  append: (value: T) => void;\n}\n</code></pre>\n<h2>3.4. 입출력 또한 제네릭일 때</h2>\n<p><code>Generic&#x3C;T></code> 제네릭 타입에서 <code>T</code>가 입력으로만 쓰이면 반변, 출력으로만 쓰이면 공변일 수 있고 둘 다라면 불변이어야 한다고 했다. 그리고 이는 <code>T</code>가 메서드의 매개변수 타입으로 있는지 리턴 타입으로 있는지에 따라서 결정된다고 했다. 그런데 다음과 같은 경우는 어떨까? 메서드의 리턴 타입이 또다른 제네릭 타입일 경우이다.</p>\n<pre><code class=\"language-ts\">interface Foo&#x3C;out T> {\n  outMethod: () => Bar&#x3C;T>;\n}\n</code></pre>\n<p>이럴 경우에는 <code>Bar</code>에서 <code>T</code>가 어떻게 쓰이는지에 따라 가능 여부가 갈리게 된다. 먼저 <code>Bar</code>에서 <code>T</code>가 출력으로만 쓰인다고 하자.</p>\n<pre><code class=\"language-ts\">interface Bar&#x3C;out T> {\n  outMethod: () => T;\n}\n\ninterface Foo&#x3C;out T> {\n  outMethod: () => Bar&#x3C;T>;\n}\n</code></pre>\n<p>그러면 <code>T</code>는 출력에만 쓰이게 되고 <code>Foo</code>가 공변적으로 동작하는 데에 아무 문제도 없다. 서브타입 관계도 그냥 <code>Foo</code>, <code>Bar</code>모두 타입 인자의 서브타입 관계를 보존하면 된다.</p>\n<p>그런데 만약 <code>T</code>가 <code>Bar</code>에서 입력으로 쓰인다면? 이런 경우를 보자. 다음 경우에 <code>Bar</code>는 반변이고 <code>Foo</code>는 공변이다.</p>\n<pre><code class=\"language-ts\">interface Bar&#x3C;in T> {\n  inMethod: (t: T) => void;\n}\n\ninterface Foo&#x3C;out T> {\n  outMethod: () => Bar&#x3C;T>;\n}\n</code></pre>\n<p>그러면 다음과 같은 문제 상황을 생각할 수 있다. <code>number</code>는 <code>string | number</code>의 서브타입이다. 따라서 <code>Foo&#x3C;number></code>는 <code>Foo&#x3C;string | number></code>의 서브타입이다. 그래서 다음과 같은 코드가 가능하다.</p>\n<pre><code class=\"language-ts\">const fooN: Foo&#x3C;number> = ...;\nconst fooSN: Foo&#x3C;string | number> = fooN;\n</code></pre>\n<p>그 다음 이런 코드를 실행시킨다고 해보자. 이는 주석에 쓴 대로의 문제가 발생한다.</p>\n<pre><code class=\"language-ts\">/*\nfooSN은 fooN 객체를 가리키고 있다. 따라서 fooSN.outMethod()의 리턴 객체는 사실 Bar&#x3C;number>와 같은 만큼의 기능을 가지고 있다.\n\n그런데 fooSN.outMethod()에서 리턴된 객체는 타입 시스템에서 Bar&#x3C;string | number> 타입으로 추론된다. 따라서 string을 fooSN.outMethod().inMethod에 넘기는 것이 가능하고 이는 문제가 된다.\n*/\nfooSN.outMethod().inMethod(\"foo\");\n</code></pre>\n<p>물론 <code>inMethod</code>가 사실 <code>T</code>를 어떤 문제되는 동작도 없는 데에만 쓸 수도 있다. 예를 들어서 함수 인자로 받은 <code>t</code>를 그대로 출력만 할 수도 있다. 하지만 이런 함수의 내부 동작을 컴파일러가 컴파일 시점에 알고 판단하는 것은 불가능하다. 그래서 컴파일러는 혹시 모를 상황을 대비해 이런 상황에 에러를 발생시킨다.</p>\n<p>제네릭이 연쇄적으로 나타나는 다른 경우들도 비슷하게 생각해서 추론할 수 있다. 타입 인자를 입력에만 계속 쓰는 경우, 출력에만 계속 쓰는 경우에만 이런 연쇄가 허용된다는 것을 알 수 있다.</p>\n<h1>4. 가변성을 정의하는 시점</h1>\n<p>TS에서는 제네릭 타입을 정의할 때만 가변성을 정의할 수 있다. 하지만 다른 몇몇 언어에서는 제네릭 타입의 가변성을 지정할 수 있는 방법이 또 하나 있다. 개발자가 제네릭 타입을 사용할 때 가변성을 지정할 수 있도록 한 언어들이 있다. 이런 2가지의 가변성 지정 시점에 대해 간단히나마 알아보자.</p>\n<h2>4.1. 제네릭 타입 정의와 함께 가변성 정의</h2>\n<p>제네릭 타입의 가변성을 정의하는 첫번째 방법은 제네릭 타입을 정의할 때 가변성을 정의하는 것이다. TS에서 이런 방식을 취하고 있다.</p>\n<p>제네릭 타입 인자 앞에 <code>in</code>을 붙이면 해당 인자는 반변이 되고 <code>out</code>을 붙이면 해당 인자는 공변이 된다. 대신 <code>in</code>을 붙인 인자는 입력에만, <code>out</code>을 붙인 인자는 출력에만 사용할 수 있다. 다른 언어들에서는 <code>+</code>나 <code>-</code>를 사용하는 경우도 있다.</p>\n<pre><code class=\"language-ts\">interface ReadOnlyList&#x3C;out T> {\n  get(index: number): T;\n}\n\ninterface Map&#x3C;in K, V> {\n  get(key: K): V;\n  set(key: K, value: V): void;\n}\n</code></pre>\n<p>그런데 이렇게 하면 제네릭 타입 인자의 가변성이 일관적이고 이해하기 쉬운 대신 제네릭 타입 사용에 큰 제약이 생긴다는 단점이 있다. 예를 들어 위의 <code>ReadOnlyList</code>타입은 오직 출력만 할 수 있다. 만약 <code>T</code>타입 원소를 매개변수로 받아 리스트에 추가하는 메서드를 가지고 싶다면 <code>set</code>메서드의 입력에 <code>T</code>타입을 사용해야 하므로 <code>ReadOnlyList</code>를 불변으로 만들어야 한다.</p>\n<p>자연스러운 가변성을 부여하는 대신 입력 혹은 출력 둘 중 하나만 사용할 수 있는 타입을 만들거나, 불변으로 만들어야 한다.</p>\n<p>물론 immutable(보통 불변으로 번역되는데, invariant의 번역인 불변과 헷갈리지 않기 위해 immutable 그대로 표기하였다)한 자료구조만 사용하는 함수형 프로그래밍에서는 이런 문제가 덜하다. 하지만 함수형에도 <code>concat</code>등 원소를 추가하는 메서드가 있는 자료구조가 있다. 이런 메서드를 만들기 위해서는 결국 T가 불변이 되어야 한다!</p>\n<pre><code class=\"language-ts\">interface ReadOnlyArray&#x3C;in out T> {\n  get(index: number): T;\n  concat(array: ReadOnlyArray&#x3C;T>): ReadOnlyArray&#x3C;T>;\n}\n</code></pre>\n<p>물론 실제 TS에서는 <code>ConcatArray&#x3C;T></code>라는 자료구조를 사용해서 이런 제약을 우회한다. 이는 다음 글에서 살펴볼 것이다. 하지만 그렇게 해도 코드가 복잡해지고, 여전히 mutable한 자료구조에 대한 문제는 남는다. 그래서 코틀린 등 몇몇 언어에서는 가변성을 지정하는 시점을 타입을 사용하는 시점으로 미룬다.</p>\n<h2>4.2. 제네릭 타입 사용과 함께 가변성 정의</h2>\n<p>제네릭 타입의 가변성을 정의하는 두번째 방법은 제네릭 타입을 사용할 때 가변성을 정의하는 것이다. 이 방법은 제네릭 타입을 정의할 때보다는 덜 직관적이지만 제네릭 타입을 사용할 때 더 유연하게 가변성을 정의할 수 있다는 장점이 있다.</p>\n<p>먼저 타입은 아무 제한 없이 사용할 수 있다. 다만 제네릭 타입을 사용할 때 <code>in</code>을 붙이면 해당 인자는 반변이 되고 <code>out</code>을 붙이면 해당 인자는 공변이 된다. 대신 <code>in</code>을 붙인 타입 인자는 입력에만, <code>out</code>을 붙인 타입 인자는 출력에만 사용할 수 있다.</p>\n<p>이때 <code>Generic&#x3C;T></code>는 서브타입 정의상 <code>Generic&#x3C;in T></code>와 <code>Generic&#x3C;out T></code>의 서브타입이 된다. <code>Generic&#x3C;T></code>가 둘 각각보다 더 구체적인 타입이기 때문이다.</p>\n<p>코틀린에서 이런 방식을 사용할 수 있다. 정의할 때 가변성을 공변이나 반변으로 지정한 경우 사용할 때 바꿀 수 없지만 불변으로 정의한 제네릭 클래스의 경우 사용할 때 <code>in</code>이나 <code>out</code>키워드를 통해 가변성을 지정할 수 있다. 다음은 이를 사용하는 간단한 코틀린 코드이다.</p>\n<pre><code class=\"language-kotlin\">class Generic&#x3C;T> {\n  fun get(index: Int): T\n  fun set(value: T): Unit\n}\n\n// get 메서드만 사용가능\nval generic1: Generic&#x3C;out T> = ...\n// set 메서드만 사용가능\nval generic2: Generic&#x3C;in T> = ...\n</code></pre>\n<p>이로써 가변성이 무엇이고 어떻게 정의할 수 있는지 알아보았다. 다음 글에서는 TS에서 가변성을 어떻게 다루는지에 대해 볼 만한 부분들을 알아볼 것이다.</p>\n<h1>참고</h1>\n<p>홍재민, 타입으로 견고하게 다형성으로 유연하게</p>\n<p>TypeScript에서의 변성(Variance): 도대체 왜 이렇게 된 거야?\n<a href=\"https://driip.me/d230be64-df1d-4e9a-a8c2-cba6bbc0ae15\">https://driip.me/d230be64-df1d-4e9a-a8c2-cba6bbc0ae15</a></p>\n<p>C# 공변성과 반공변성이란? <a href=\"https://sticky32.tistory.com/entry/C-%EA%B3%B5%EB%B3%80%EC%84%B1%EA%B3%BC-%EB%B0%98%EA%B3%B5%EB%B3%80%EC%84%B1%EC%9D%B4%EB%9E%80\">https://sticky32.tistory.com/entry/C-%EA%B3%B5%EB%B3%80%EC%84%B1%EA%B3%BC-%EB%B0%98%EA%B3%B5%EB%B3%80%EC%84%B1%EC%9D%B4%EB%9E%80</a></p>\n<p>Variant 제네릭 인터페이스 만들기(C#) <a href=\"https://learn.microsoft.com/ko-kr/dotnet/csharp/programming-guide/concepts/covariance-contravariance/creating-variant-generic-interfaces\">https://learn.microsoft.com/ko-kr/dotnet/csharp/programming-guide/concepts/covariance-contravariance/creating-variant-generic-interfaces</a></p>\n<p>공변성이란 무엇인가 <a href=\"https://seob.dev/posts/%EA%B3%B5%EB%B3%80%EC%84%B1%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80/\">https://seob.dev/posts/%EA%B3%B5%EB%B3%80%EC%84%B1%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80/</a></p>",
    "excerpt": "\n이 글은 읽는 사람이 슈퍼타입, 서브타입, 제네릭 등 기본적인 타입 시스템의 개념은 알고 있다는 가정하에 쓰여지는 글이다.\n\n시작\nTS를 더 잘 이해하기 위해 타입 시스템을 공부하다가 가변성(variance)이라는 개념을 만났다. 그래서 앞으로 이와 관련해서 2개의 글을 쓸 예정이다. 첫번째 글(이 글)에서는 가변성이라는 게 무엇인지 알아볼 것이다. 그리고 두 번째 글에서는 가변성이라는 개념이 TS에 녹아 있는 부분 몇 가지를 알아볼 것이다.\n이 글에서는 전체",
    "headingTree": [
      {
        "title": "시작",
        "url": "#시작",
        "items": []
      },
      {
        "title": "1. 가변성의 배경",
        "url": "#1-가변성의-배경",
        "items": [
          {
            "title": "1.1. 배열의 서브타입 관계",
            "url": "#11-배열의-서브타입-관계",
            "items": []
          },
          {
            "title": "1.2. 배열의 서브타입 관계로 인한 문제",
            "url": "#12-배열의-서브타입-관계로-인한-문제",
            "items": []
          },
          {
            "title": "1.3. 가변성의 등장",
            "url": "#13-가변성의-등장",
            "items": []
          }
        ]
      },
      {
        "title": "2. 가변성의 종류",
        "url": "#2-가변성의-종류",
        "items": [
          {
            "title": "2.1. 공변",
            "url": "#21-공변",
            "items": []
          },
          {
            "title": "2.2. 불변",
            "url": "#22-불변",
            "items": []
          },
          {
            "title": "2.3. 반변",
            "url": "#23-반변",
            "items": []
          },
          {
            "title": "2.4. 양변",
            "url": "#24-양변",
            "items": []
          }
        ]
      },
      {
        "title": "3. 타입 가변성 정의하기",
        "url": "#3-타입-가변성-정의하기",
        "items": [
          {
            "title": "3.1. 입력에 사용",
            "url": "#31-입력에-사용",
            "items": []
          },
          {
            "title": "3.2. 출력에 사용",
            "url": "#32-출력에-사용",
            "items": []
          },
          {
            "title": "3.3. 입력과 출력에 모두 사용",
            "url": "#33-입력과-출력에-모두-사용",
            "items": []
          },
          {
            "title": "3.4. 입출력 또한 제네릭일 때",
            "url": "#34-입출력-또한-제네릭일-때",
            "items": []
          }
        ]
      },
      {
        "title": "4. 가변성을 정의하는 시점",
        "url": "#4-가변성을-정의하는-시점",
        "items": [
          {
            "title": "4.1. 제네릭 타입 정의와 함께 가변성 정의",
            "url": "#41-제네릭-타입-정의와-함께-가변성-정의",
            "items": []
          },
          {
            "title": "4.2. 제네릭 타입 사용과 함께 가변성 정의",
            "url": "#42-제네릭-타입-사용과-함께-가변성-정의",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 2,
      "wordCount": 597
    },
    "url": "/posts/typescript-covariance-theory",
    "thumbnail": {
      "local": "/static/array-covariance-bdb1edbe.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-array-covariance-bdb1edbe-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAIAAAA8r+mnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAVUlEQVR4nD3KoREAIQxE0VSRVpCxWGwaoQc0fptAR28BNEEVYW5u7r59XwDUWkmutUi6u6pGhETEGCO/9t6998wUkgB+OOfMOR9orZkZgPcopZiZu1/LZT+LbIpD2AAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "typescript-module-tmi",
    "title": "TS 탐구생활 - TS의 모듈에 관한 작은 정보들",
    "date": "2024-02-17T00:00:00Z",
    "description": "TS에서 모듈 시스템을 보면서 메모한 내용들",
    "tags": [
      "typescript"
    ],
    "html": "<p>JS에서는 ES2015부터 import/export를 이용하는 모듈 시스템을 정식으로 지원한다. TS에서도 당연히 이를 공유하는데 TS에서 다른 점들을 몇 가지 메모하였다.</p>\n<p>JS에서의 모듈에 대해서는 <a href=\"https://witch.work/posts/import-and-require\">JS 탐구생활 - require와 import 그리고 JS의 모듈 시스템</a>을 참고할 수 있다.</p>\n<h1>1. export</h1>\n<p>JS의 다른 객체들과 같이 타입도 export할 수 있다. 이는 다른 파일에서 import하여 사용할 수 있다.</p>\n<pre><code class=\"language-ts\">// types.ts\nexport type Person = {\n  name: string;\n  age: number;\n};\n</code></pre>\n<pre><code class=\"language-ts\">// index.ts\nimport { Person } from \"./types\";\n</code></pre>\n<p><code>*</code>를 이용하면 모듈 전체를 불러와서 마치 모듈의 내용을 복사한 것처럼 사용할 수 있다. 다음 예시에서는 <code>types.ts</code>를 import해서 <code>types</code>라는 이름으로 사용한다.</p>\n<pre><code class=\"language-ts\">// index.ts\nimport * as types from \"./types\";\n\nconst person: types.Person = {\n  name: \"witch\",\n  age: 20,\n};\n</code></pre>\n<p>이렇게 하면 서로 다른 모듈에 같은 이름의 인터페이스나 네임스페이스가 있어도 병합되지 않고 충돌을 일으키지 않는다는 장점이 있다.</p>\n<h2>1.1. type export</h2>\n<p>그리고 import/export하는 대상이 값이 아닌 타입이라는 것을 type 키워드를 이용해서 명시할 수 있다. 이를 type import/export라고 한다.</p>\n<pre><code class=\"language-ts\">// types.ts\ntype Person = {\n  name: string;\n  age: number;\n};\n\nexport type { Person };\n</code></pre>\n<pre><code class=\"language-ts\">// index.ts\nimport type { Person } from \"./types\";\n</code></pre>\n<p>일반적으로는 TS가 import/export되는 값이 타입인지 여부를 알고 있기 때문에 이를 사용할 필요가 없다. 하지만 몇몇 경우에 필요하고 이점이 있으니 도입된 개념인데 이에 대해서는 따로 글을 작성할 예정이다.</p>\n<h2>1.2. export all</h2>\n<p><code>export *</code>를 이용하면 모듈의 모든 export를 다른 모듈에서 사용할 수 있다.</p>\n<pre><code class=\"language-ts\">export * as types from \"./types\";\n</code></pre>\n<p>이렇게 import해서 사용할 수 있다.</p>\n<pre><code class=\"language-ts\">import { types } from \"./types\";\n</code></pre>\n<h1>2. cjs와 esm의 호환</h1>\n<p>원래 commonJS 방식으로 export된 객체는 es2015 방식으로 import할 수 없다. 그래도 ts에서는 이를 해결하기 위한 몇 가지 방법을 제공한다.</p>\n<h2>2.1. commonjs export</h2>\n<p>commonJS에서는 exports 객체를 이용해서 파일 내에서 export할 수 있는 값들을 정의한다.</p>\n<pre><code class=\"language-js\">// commonJS\n// 여러 객체를 내보낼 때\nexports.a = 1;\nexports.b = 2;\nexports.c = 3;\n\n// 하나의 객체를 내보낼 때\nconst obj = {\n    a: 1,\n    b: 2,\n    c: 3\n};\n\nmodule.exports = obj;\n</code></pre>\n<p>이런 exports 객체와 비슷한 es2015 문법은 default export이다. 그런데 둘이 호환되지는 않는다. cjs 스타일로 export하고 es2015 스타일로 import할 수는 없다.</p>\n<h2>2.2. export = 문법</h2>\n<p>이 부분을 해결하기 위해서 ts에서는 <code>export =</code>라는 문법을 이용해서 모듈에서 export되는 단일 객체를 지정할 수 있도록 한다. 만약 라이브러리의 <code>index.d.ts</code>등에 들어갔는데 <code>export = ...</code>가 써있다면 그 라이브러리는 commonJS 모듈 시스템을 따르지만 모듈을 사용하는 곳에서는 <code>import</code>를 사용하여 ES2015 스타일로 모듈을 가져와 사용할 수 있도록 <code>export =</code>를 써서 export를 해놓은 것이다.</p>\n<pre><code class=\"language-ts\">// types.ts\nclass Person {\n  name: string;\n  age: number;\n}\n\nexport = Person;\n</code></pre>\n<p>그런데 이렇게 export된 모듈을 가져오기 위해서는 <code>import</code>와 <code>require</code>가 묘하게 섞인 문법이 사용된다. 참고로 <code>./types</code> 파일에서 <code>export =</code>로 내보낸 객체는 하나뿐이므로 다른 이름을 사용해서 import해도 된다.</p>\n<pre><code class=\"language-ts\">import Person = require(\"./types\");\n</code></pre>\n<p>이렇게 모듈을 사용한 코드는 컴파일러에 의해 commonjs, AMD, ES6 모듈 문법 등으로 알아서 컴파일된다. 이 모듈은 컴파일 커맨드에서 <code>--module</code>키워드를 사용해 지정할 수 있다.</p>\n<pre><code class=\"language-bash\">tsc --module commonjs index.ts\n</code></pre>\n<h2>2.3. esModuleInterop</h2>\n<p>그런데 위와 같이 모듈을 가져오려면 <code>import</code>와 <code>require</code>를 동시에 써야 해서 어색하다. 이럴 때 <code>tsconfig.json</code>에서 <code>esModuleInterop</code>을 true로 설정하면 commonJS 모듈을 import할 때 es2015 모듈 문법을 자연스럽게 사용할 수 있다.</p>\n<pre><code class=\"language-json\">{\n  \"compilerOptions\": {\n    \"esModuleInterop\": true\n  }\n}\n</code></pre>\n<p>이렇게 설정하면 위에서 <code>import</code>와 <code>require</code>를 동시에 써서 모듈을 가져오던 코드를 다음과 같이 작성할 수 있게 된다. 컴파일러가 알아서 이 코드를 변환하여 두 가지 모듈 시스템을 호환시켜 주기 때문이다.</p>\n<pre><code class=\"language-ts\">import Person from \"./types\";\n</code></pre>\n<p>이렇게 되는 원리에 대해서는 <a href=\"https://simsimjae.medium.com/es%EB%AA%A8%EB%93%88%EB%B0%A9%EC%8B%9D%EA%B3%BC-commonjs-%EB%AA%A8%EB%93%88-%EB%B0%A9%EC%8B%9D%EC%9D%84-%EC%84%9E%EC%96%B4-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-esmoduleinterop-65529471948e\">ES모듈방식과 CommonJS 모듈 방식을 섞어 사용하기(esModuleInterop)</a>를 참고할 수 있다.</p>\n<h1>3. 스크립트 파일과 모듈 파일</h1>\n<p>파일 내부의 최상위 스코프에 <code>import</code>, <code>export</code> 키워드가 없으면 현재 파일의 타입 정의를 전역으로 사용할 수 있게 되는 스크립트 파일로 인식된다. 반면 <code>import</code>, <code>export</code> 키워드가 있을 시 모듈 파일이다.</p>\n<pre><code class=\"language-ts\">// 스크립트 파일\ninterface Person {\n  name: string;\n  age: number;\n}\n</code></pre>\n<p>반면 이런 식으로 <code>export</code>를 하면 모듈 파일이 된다. 주의할 점은 <code>export</code>가 최상위 스코프에 있는 게 아니라 네임스페이스 내에 있는 등 최상위가 아닌 다른 스코프에 있다면 스크립트 파일이라는 점이다.</p>\n<pre><code class=\"language-ts\">// 모듈 파일\nexport interface Person {\n  name: string;\n  age: number;\n}\n</code></pre>\n<p>스크립트 파일에 있는 타입과 같은 이름의 타입이 다른 모듈 파일에 있다면 주의해야 한다. 해당 타입을 그냥 사용할 때와 import해서 사용할 때의 타입 내용이 달라질 수 있기 때문이다.</p>\n<p>예를 들어서 <code>Person</code>이라는 타입이 스크립트 파일에 있다면 이를 import하지 않고도 사용할 수 있다. 그런데 <code>person.ts</code>라는 모듈 파일에서도 <code>Person</code>타입을 export하고 있다면 Person 타입을 그냥 사용할 때와 import해서 사용할 때의 타입 내용이 달라질 수 있다.</p>\n<h1>참고</h1>\n<p><a href=\"https://www.typescriptlang.org/ko/docs/handbook/modules.html\">https://www.typescriptlang.org/ko/docs/handbook/modules.html</a></p>\n<p>조현영 - 타입스크립트 교과서</p>\n<p><a href=\"https://www.typescriptlang.org/tsconfig#esModuleInterop\">https://www.typescriptlang.org/tsconfig#esModuleInterop</a></p>",
    "excerpt": "JS에서는 ES2015부터 import/export를 이용하는 모듈 시스템을 정식으로 지원한다. TS에서도 당연히 이를 공유하는데 TS에서 다른 점들을 몇 가지 메모하였다.\nJS에서의 모듈에 대해서는 JS 탐구생활 - require와 import 그리고 JS의 모듈 시스템을 참고할 수 있다.\n1. export\nJS의 다른 객체들과 같이 타입도 export할 수 있다. 이는 다른 파일에서 import하여 사용할 수 있다.\n// types.ts\nexport type",
    "headingTree": [
      {
        "title": "1. export",
        "url": "#1-export",
        "items": [
          {
            "title": "1.1. type export",
            "url": "#11-type-export",
            "items": []
          },
          {
            "title": "1.2. export all",
            "url": "#12-export-all",
            "items": []
          }
        ]
      },
      {
        "title": "2. cjs와 esm의 호환",
        "url": "#2-cjs와-esm의-호환",
        "items": [
          {
            "title": "2.1. commonjs export",
            "url": "#21-commonjs-export",
            "items": []
          },
          {
            "title": "2.2. export = 문법",
            "url": "#22-export--문법",
            "items": []
          },
          {
            "title": "2.3. esModuleInterop",
            "url": "#23-esmoduleinterop",
            "items": []
          }
        ]
      },
      {
        "title": "3. 스크립트 파일과 모듈 파일",
        "url": "#3-스크립트-파일과-모듈-파일",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 233
    },
    "url": "/posts/typescript-module-tmi",
    "thumbnail": {
      "local": "/thumbnails/typescript-module-tmi-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-typescript-module-tmi-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAiklEQVR4nDXLMQrDIBSA4edJco0sgktmIaPXEJzSYzhlr0OhLnF4RbxA4M0lU9ADeAHBUkK+9ecH7/08z1przvmyPKy1SqlaK1hrGWPjOA7DME2TlFIIwTmHLQRjDCLGGEspRLTvOyICEa3rivhJKbXW+g3OnHP5q7X23tsN3Ov9dC6E7XscV7iOHzKTY0ulNiPuAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "typescript-infer-usage",
    "title": "TS 탐구생활 - TS infer 키워드의 활용",
    "date": "2023-09-30T00:00:00Z",
    "description": "TS infer 키워드의 활용",
    "tags": [
      "typescript"
    ],
    "html": "<h1>1. infer 키워드란?</h1>\n<h2>1.1. 소개</h2>\n<p>TS에서는 몇 가지 유틸리티 타입을 제공한다. <code>Record&#x3C;Keys,Type></code>이나 <code>Omit&#x3C;Type, Keys></code>와 같은 것들은 꽤나 흔히 쓰인다.</p>\n<p>그런데 이중 함수를 받아서 해당 함수의 리턴 타입을 추출하는 <code>ReturnType&#x3C;Type></code>이라는 유틸리티 타입이 있다. 이것은 함수의 리턴 타입을 추출하는 것이다.</p>\n<p><a href=\"https://www.typescriptlang.org/ko/docs/handbook/utility-types.html\">TS 핸드북의 예시를 가져와 보면 이해가 쉽다.</a></p>\n<pre><code class=\"language-ts\">// type T0 = string\ntype T0 = ReturnType&#x3C;() => string>;\n\n// type T1 = number\ntype T1 = ReturnType&#x3C;(s: string) => number>;\n\n// type T2 = unknown\ntype T2 = ReturnType&#x3C;&#x3C;T>() => T>;\n</code></pre>\n<p>이런 마법같은 유틸리티 타입은 어떻게 동작하는 것일까? 이것은 바로 <code>infer</code> 키워드를 사용해서 동작한다. 실제 <code>ReturnType</code>의 정의를 보면 다음과 같다.</p>\n<pre><code class=\"language-ts\">type ReturnType&#x3C;T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : any;\n</code></pre>\n<p>복잡해 보이는 위 선언을 잘 뜯어보면, <code>T</code>는 함수 타입이고 리턴 타입에 <code>infer</code>키워드가 붙어 있다. 이는 <code>T</code>의 리턴 타입을 추론해서 <code>R</code>이라는 타입 변수에 할당하겠다는 의미이다. 그리고 이 <code>R</code>은 <code>ReturnType</code>의 리턴 타입이 된다.</p>\n<p>그런 과정을 거쳐서 <code>ReturnType</code>은 함수의 리턴 타입을 추론해서 리턴하는 유틸리티 타입이 된다.</p>\n<h2>1.2. 사용법</h2>\n<p><code>infer</code> 키워드는 컨디셔널 타입과 함께 사용되어야만 한다. 만약 그냥 쓸 시 다음과 같은 에러 메시지를 마주하게 된다.</p>\n<pre><code>'infer' declarations are only permitted in the 'extends' clause of a conditional type.\n</code></pre>\n<p>컨디셔널 타입에서 타입스크립트에 추론을 맡기고 싶은 부분에 <code>infer</code> 키워드와 타입 변수를 사용하면 된다.</p>\n<blockquote>\n<p>Such inferred type variables may be referenced in the true branch of the conditional type.</p>\n<p>TS 공식 문서의 Conditional Types section</p>\n</blockquote>\n<p>컨디셔널 타입의 참 부분에만 <code>infer</code>된 타입 변수를 사용할 수 있다. 거짓 부분에서 쓰려고 하면 에러가 발생한다.</p>\n<p>왜 그런지는 생각해 보면 당연하다. <code>infer</code>를 통해서 추론할 수 있다면 참으로, 없다면 거짓으로 가게 되는데 <code>infer</code>를 통해서 타입을 추론할 수 없다면 해당 타입을 결정할 수 없다. 따라서 <code>infer</code>를 통해서 타입을 결정할 수 있는 참 부분에서만 <code>infer</code>를 통해 만들어진 타입 변수를 사용할 수 있는 것이다.</p>\n<pre><code class=\"language-ts\">// 잘 작동한다.\ntype Element&#x3C;T>=T extends (infer U)[] ? U : T;\n// Cannot find name 'U'\ntype Element&#x3C;T>=T extends (infer U)[] ? T : U;\n</code></pre>\n<p>나머지는 그냥 추론하려는 부분을 <code>infer</code>로 만들기만 하면 된다.</p>\n<pre><code class=\"language-ts\">// 배열 요소 타입 얻기\ntype Elem&#x3C;T>=T extends (infer U)[] ? U : T;\n\ntype A=Elem&#x3C;string[]>; // string\n\n// 함수 파라미터 타입 얻기\ntype Param&#x3C;T>=T extends (...args: infer P) => any ? P : never;\n\ntype B=Param&#x3C;(a: string, b: number) => void>; // [string, number]\n</code></pre>\n<h2>1.3. 여러 개의 infer</h2>\n<p>하나의 타입 변수에 여러 개의 <code>infer</code>를 사용할 수도 있다.</p>\n<pre><code class=\"language-ts\">// 매개변수 타입과 리턴 타입을 추론해서 튜플에 담아 리턴해 준다.\ntype ParamAndReturn&#x3C;T>=T extends (...args: infer P) => infer R ? [P, R] : never;\n</code></pre>\n<p>반면 같은 <code>infer</code> 타입 변수를 여러 곳에 사용할 수도 있다. 기본적으로는 같은 이름의 타입 변수들은 유니온으로 합쳐진다. 하지만 반공변성을 갖는, 이를테면 매개변수와 같은 것들은 인터섹션이 되어 리턴된다. 이 부분에 대해서는 추후 공변성에 관한 글에서 다루도록 하겠다.</p>\n<pre><code class=\"language-ts\">// a의 타입과 b의 타입이 합쳐져서 리턴된다. \ntype InferUnion&#x3C;T> = T extends { a: infer U; b: infer U } ? U : never;\n// a의 타입과 b의 타입의 intersection이 리턴된다. 매개변수는 반공변성을 가지고 있기 때문이다\ntype InferIntersection&#x3C;T> = T extends { a: (x: infer U) => void; b: (y: infer U) => void } ? U : never;\n</code></pre>\n<p>그럼 이제 이 <code>infer</code>가 어디에 쓰일 수 있는지 알아보자.</p>\n<h1>2. 함수 인자 타입 추론</h1>\n<p>그럼 이런 <code>infer</code>를 어디에 사용할 수 있을까? 위에서 <code>Param&#x3C;T></code>와 같은 타입으로 함수 타입의 인자 타입을 얻어오는 것이 가능하다는 것을 보았다. 이를 이용해 함수 인수 타입을 따로 가져오는 것이 <code>infer</code>의 단순한 활용법 중 하나다.</p>\n<h2>2.1. 함수 인자 타입 추론 방법</h2>\n<p><code>infer</code>를 이용하면 위에서 보았듯이 함수의 인자 타입, 혹은 함수의 특정 인자 타입을 추론할 수 있다.</p>\n<pre><code class=\"language-ts\">type GetArgumentType&#x3C;T> = T extends (...args: infer U) => any ? U : never;\n\ntype GetFirstArgumentType&#x3C;T> = T extends (arg: infer U, ...args:any) => any ? U : never;\n</code></pre>\n<h2>2.2. 서드파티 라이브러리 함수 인자 타입 추론</h2>\n<p>이는 서드파티 라이브러리를 사용할 때 유용하게 쓰일 수 있다. 함수 인자의 타입을 제대로 제공하지 않는 라이브러리가 있을 때, 이를 보완할 수 있는 것이다.</p>\n<p>예를 들어 다음과 같이 정의된 라이브러리 함수가 있다고 하자.</p>\n<pre><code class=\"language-ts\">function introduce(person:{\n    name:string;\n    age:number;\n    hobbies:[string, string];\n}){\n    return `${person.name}은 ${person.age}살이고 ${person.hobbies.join(\" 와 \")}가 취미입니다.`\n}\n</code></pre>\n<p>라이브러리에서 <code>introduce</code>의 인자를 위한 <code>Person</code>타입 같은 걸 제공하지 않는다면 이 함수의 인자를 알맞게 만들어도 타입 검사를 통과하지 못할 수 있다.</p>\n<pre><code class=\"language-ts\">const me={\n    name:\"김타입\",\n    age:26,\n    hobbies:[\"JS\", \"TS\"],\n}\n// me.hobbies의 타입이 string[]으로 추론되어 타입 에러 발생\nintroduce(me);\n</code></pre>\n<p>이때 <code>infer</code>를 사용한 유틸리티 타입을 만들어서 다음과 같이 해결할 수 있다. <code>me</code>의 타입을 제대로 선언해 주는 것이다.</p>\n<pre><code class=\"language-ts\">type GetFirstArgumentType&#x3C;T> = T extends (arg: infer U, ...args:any) => any ? U : never;\n\nconst me:GetFirstArgumentType&#x3C;typeof introduce>={\n    name:\"김타입\",\n    age:26,\n    hobbies:[\"JS\", \"TS\"],\n}\n\nintroduce(me);\n</code></pre>\n<p>그냥 <code>Person</code> 타입을 새로 정의해 주는 방법도 있겠지만 서드파티 라이브러리의 코드를 다 파악해서 타입을 새로 정의하는 것은 쉽지 않다. 이런 경우 <code>infer</code>를 사용한 <code>GetFirstArgumentType&#x3C;T></code>와 같은 타입으로 쉽게 함수 인자 타입을 추론해 줄 수 있다.</p>\n<p>이런 활용은 꼭 함수 인자 타입에만 한정된 것은 아니다. 생성자 매개변수 타입이라든지 인스턴스 타입이라든지 하는 것들을 제대로 제공해 주지 않는 서드파티 라이브러리가 있다면 <code>infer</code>를 사용해서 혼내줄 수 있다.</p>\n<h2>2.3. 리액트 컴포넌트 props 타입 추론</h2>\n<p>이는 리액트 관련 라이브러리에서 컴포넌트의 props 타입을 제대로 제공하지 않을 때도 유용하게 쓰일 수 있다.</p>\n<pre><code class=\"language-ts\">type InferProps&#x3C;T> = T extends React.ComponentType&#x3C;infer P> ? P : never;\n\n// LibComponent의 props 타입을 추론\ntype MyProps = InferProps&#x3C;typeof LibComponent>;\n</code></pre>\n<p>React에서는 이를 좀 더 발전시킨 <code>ComponentProps</code> 유틸리티 타입을 제공하고 있다. 만약 <code>T</code>가 JSX 엘리먼트 생성자라면 즉 리액트 컴포넌트 타입이라면 <code>ComponentProps&#x3C;T></code>는 해당 엘리먼트의 props 타입을 추론한다. 만약 그렇지 않다면 HTML 내장 요소, <code>&#x3C;div></code> 나  <code>&#x3C;button></code>과 같은 <code>IntrinsicElements</code>인지 확인하고 그렇다면 해당 요소의 props 타입을 추론한다.</p>\n<p>만약 JSX 엘리먼트 생성자도 아니고 HTML 내장 요소도 아니라면 null이나 undefined외에 모든 타입을 허용하는 <code>{}</code> 타입을 리턴한다.</p>\n<pre><code class=\"language-ts\">// @types/react/index.d.ts\ntype ComponentProps&#x3C;T extends keyof JSX.IntrinsicElements | JSXElementConstructor&#x3C;any>> =\n    T extends JSXElementConstructor&#x3C;infer P>\n        ? P\n        : T extends keyof JSX.IntrinsicElements\n            ? JSX.IntrinsicElements[T]\n            : {};\n</code></pre>\n<h1>3. 재귀적 타입 추론</h1>\n<p><code>infer</code>는 매우 심화된 타입 작업을 할 때에 많이 사용된다고 한다. 그 대표적인 예시가 재귀적 타입인데, 사용된 타입에서 특정 부분만 뽑아내어서 사용할 수 있게 해주는 <code>infer</code>타입의 특성 덕분이다.</p>\n<p>이 재귀적 타입은 TS 4.1.0 이상 버전에서만 동작한다.</p>\n<p>아무튼 몇 가지 예시를 통해서 이런 활용법을 알아보자.</p>\n<h2>3.1. 예시 - 평탄화 타입</h2>\n<p>다음과 같은 코드를 보자. 다음은 중첩 배열을 평탄화하는 함수에 대한 타이핑을 한 것이다. <code>flatRecurisve</code>에서 재귀적으로 함수를 flatten하는 과정과 비슷하게 타입도 재귀적으로 정의할 수 있다는 사실을 관찰할 수 있는 코드이다.</p>\n<pre><code class=\"language-ts\">// 배열 T를 flat한 배열의 타입을 나타낸다\ntype Flatten&#x3C;T extends readonly unknown[]> = T extends unknown[] ? _Flatten&#x3C;T>[] : readonly _Flatten&#x3C;T>[];\n// T 타입을 flat 하기 위한 보조 타입. T가 배열이 아니라면 T를 리턴하고 배열이면 배열의 요소를 리턴한다.\n// 즉 배열의 요소들을 모두 평탄화해 유니언한 타입을 리턴한다.\ntype _Flatten&#x3C;T> = T extends readonly (infer U)[] ? _Flatten&#x3C;U> : T;\n\n// T를 평탄화한 배열의 타입 Flatten&#x3C;T> 타입을 리턴한다\nfunction flatRecurisve&#x3C;T extends readonly unknown[]>(xs: T): Flatten&#x3C;T> {\n  const result: unknown[] = [];\n\n  function flattenArray(arr: readonly unknown[]) {\n    for (const item of arr) {\n      if (Array.isArray(item)) {\n        flattenArray(item);\n      } else {\n        result.push(item);\n      }\n    }\n  }\n\n  flattenArray(xs);\n\n  return result as Flatten&#x3C;T>;\n}\n\nconst t1 = flatRecurisve(['apple', ['orange', 100], [[4, [true]]]] as const);\n</code></pre>\n<p>여기서 주의깊게 봐야 할 점은 <code>T</code>를 평탄화한 배열의 타입을 리턴하는 <code>Flatten&#x3C;T></code> 타입이다. 이 타입은 <code>_Flatten</code>을 이용해서 만들어지는데 이게 바로 재귀적 타입이다. <code>T</code>가 만약 배열 타입이라면 배열의 요소를 나타내는 <code>U</code>를 재귀적으로 flatten한다. 그리고 배열 타입이 아니라면 그대로 <code>T</code>를 리턴한다.</p>\n<p>이를 이용하면 <code>_Flatten&#x3C;T></code>는 배열 타입 <code>T</code>를 평탄화한 타입이 될 것이다. 가령 <code>_Flatten&#x3C;['apple', ['hi', 100], [[4, [true]]]]></code>는 <code>true | \"hi\" | 100 | 4 | \"apple\"</code>과 같이 배열의 모든 요소가 flatten되어 유니온된 타입이다.</p>\n<h2>3.2. 예시 - Promise return 타입</h2>\n<p><code>infer</code>는 Promise의 리턴타입을 추론하는 데에도 쓰일 수 있다.</p>\n<pre><code class=\"language-ts\">type PromiseReturnType&#x3C;T> = T extends Promise&#x3C;infer Return> ? Return : T\n\ntype t = PromiseReturnType&#x3C;Promise&#x3C;string>> // string \n</code></pre>\n<p>하지만 제대로 된 Promise의 리턴타입을 추론하려면 중첩된 Promise도 제대로 처리할 수 있어야 하겠다. 이런 것을 잘 해주는 유틸리티 타입이 이미 있다. <code>Awaited&#x3C;T></code>가 그것이다.</p>\n<pre><code class=\"language-ts\">let promise = Promise.resolve([1, 2, 3]); // Promise&#x3C;number[]>\n\ntype A=Awaited&#x3C;typeof promise>; // number[]\n</code></pre>\n<p><code>lib.es5.d.ts</code>에 정의된 이 <code>Awaited</code> 타입의 원형을 보면 다음과 같이 재귀적으로 타입이 정의되어 있는 것을 볼 수 있다. 재귀적으로 Promise를 unwrap하여 결과물을 리턴한다. JSdoc에 나와 있듯이 이는 <code>await</code>의 동작을 모방한 것이다.</p>\n<pre><code class=\"language-ts\">// lib.es5.d.ts\n/**\n * Recursively unwraps the \"awaited type\" of a type. Non-promise \"thenables\" should resolve to `never`. This emulates the behavior of `await`.\n */\ntype Awaited&#x3C;T> =\n    // `--strictNullChecks` mode가 아닐 때 T가 null이나 undefined라면 T를 리턴한다\n    T extends null | undefined ? T :\n    // T가 호출 가능한 then 메서드를 가진 thenable이라면 await이 unwrap한다. 아니라면 T를 리턴한다.\n        T extends object &#x26; { then(onfulfilled: infer F, ...args: infer _): any } ?\n        // F는 then 메서드의 첫번째 인자 타입이다. 만약 이게 callable이라면 재귀적으로 unwrap한다. 이는 thenable 내부 값의 awaited type도 unwrap하는 역할을 한다.\n            F extends ((value: infer V, ...args: infer _) => any) ?\n                Awaited&#x3C;V> : // recursively unwrap the value\n                // 만약 then 메서드의 첫 번째 매개변수 F가 호출 가능한 함수가 아니라면\n                // thenable이 제대로 처리되지 않은 것이므로 never 리턴\n                never : \n        T; // T is non-object or non-thenable\n</code></pre>\n<h2>3.3. 예시 - 경로 검증 타입</h2>\n<p>Reddit의 한 스레드에서 찾은 좀 더 복잡한 재귀 타입의 예시로 <code>infer</code>의 활용은 마무리하고자 한다. 이는 객체의 중첩된 경로에서 값을 안전하게 가져오는 데 사용될 수 있는 타입이다.</p>\n<p>객체와 객체에서 접근할 경로(<code>.</code>으로 구분된)을 받아서 해당 경로에 접근하는데 만약 객체 타입 <code>T</code>내부에 <code>K</code>경로에 해당하는 값이 없다면 <code>never</code>타입이 되어 오류를 발생시킨다.</p>\n<p>따라서 <code>get</code>함수를 사용하면 객체의 특정 경로에 안전하게 접근할 수 있게 된다.</p>\n<p>이 구체적인 동작에 대한 자세한 설명이 궁금한 사람은 <a href=\"https://www.typescriptlang.org/play?#code/PQKhCgAIUgZBJAQgJQILIJpRMc5jCQCiAHgC4BOAhgMZkDOkZAFgKaQAmA9mQLQB2PKmQCWXfpAAOw5pABuVADYBXdmQCek1uA1bIABRkA1JaoA8AFQA0kANKRW5Vvw6N6lEfwDmAPkgBeKEhggkgAMS4KJjZIClYAWypPDlYorgAzaPYacQ4RUXElJk1WGwB3VgByOXYqenoRL35WDkgqSHplACN3Ck8vJi5IZC4eYGRWd0hlBu9IAANPdNT5gDogkMILZhFGGioJFmdILtr+JXUALxaT9SzIHPjJEUVU1cgAdXzmLmUyaN25XYZV+ig4-Eq-1ObS6r0GDnI1DowAUihEHGEahiAGtWOp6OtgsF7I4yM5XAsACQAbyWqWGozIAF9VjS6VEJu4mfNIAB+DZEzaQeCZEY8SC7NqQXF3YQAxivGqKSAZe5cLoAK1YdBseQGnjIQyOkGa5EgitYineIpNPBsjnysW1ygoDXEkDK3wWzRqFHmAsFYv+pPJjBlqosfIMxlMrEsAG0gwBdGycsh+ABcJtYvoFoS6dWyhazADkhtwGBLDjFev0JU9FOo6-lKox2obJOac5bpXj3nnCIKh8EAMJsGjYiWZFuMG0zqUylXV9jqrV0NouJhUXH3VGqYKRByKejsefKFysdKeFqEolZgAUJKcLjDeIjUYs8dsScgWfPKSvZoOAASjwUIbWNaQWAlRhUXRGw4jIF1lykGQdBKSATDRDEyQ4QwWEsKwnzJF8Og8bw-H8aMWCw8xrFsPwQ1In16V5bNfV-OwAG4wLAbBIFQGgaEmNsJFXbV-jkER2grAQhAKCRa28bBcHSc86DECQvFYMhLAREiKXEnU7H00MyL6Cj72cUQNCzaxUJYLMsPRTE8JkQiGOArN8OYWi43ovxqQFRDkIc5hVnoSQ0TIe8ACJVli4DVjiDhlGE+971oGgswOdQbGxYCAj8LL42xFMHH4Gz1GAnimV4-iAFUAGUiGQXhYFQEsABEBP0fQEBHVALHgAB5Et+P4wRRGE6I5WNGZ6WYOoIX+ADr1aXLij0A5WklOJGzrd1dFPfhljifhhMJGAy2aFVMmNdIuEURQuE9OYQWUMETnYSQuHqERYWBb5fn+RZTpWK7cDAwgJhoF03QkSQKC4YT6mo3zYzMalHq4LNqROKgKCzfhlHiU4KCZJkbFinHYp8fBCCaslOwARjsgJIGx0Y8YLImTVJ8nKZsewqJp0Z4sgMtOB4RhPAWWx5hseghnobERE7Q0CZPB5iwZ4d9YNw2jeHHNTExLN5mIszw0ySM2M-b9OP-S91p5ModhoWQQoofhGHmfHeeJgX6W5Bm9ecnCWh8rGcYzAPCYzEmyZDqnIDFrg6Y5-3A-55OKZ5bhJhW0zN3mFi-SVoZvYkeZ09i+YeJyX3JNjFnQB5hPc8F6BgCo7SYvx2POYJvmWcgJlx+p2mauh4ZnVdTSpGR1HGB8vyY+54ec6T8nx9T9PVl5w+qEuOmMz1pnWFZ9mqMHzf475neU+FjmD6PgtT5sdkGXFUXaa-8GHJJj-FFu-E+sUbCfmTBzB+Qc87jwvszSAAAmG+W9O5PyiKnA2Is05gM-kOb+QZX68wgVWM6c8pigPATYQUUDGQ-iopgxBV9IAAGY0GYNocbIcuDYofzIQbQQ0tKxy0torDoRoYgdgeLkfIi90hJGPBuVoFQOhqw1kMAs2t9gnnPqEHhhijHGOCKbFQ5t5YlwpDbSAdtbFfh-H+C8gEWj+gMSYjxnjBT8PAdLIukIES7H+O6eYNjMESOVh6dg1dpjOPWusAg4clAuVwtHLmuN0GP2Dlg-eONj4UGPqfSiCxnYuI4AXLg-jgzPlaGXbsFdJESn+NXRgb9CaFPiuAJuUw9ysGQe3Up60cAc37veO+GTYGQDHhPXJox8kdJnnrWG8NF5IxRiJdG690l4xHnA3eQs055PwasFg-R6BnxYdfWxMDIBD0mZgveL8-5zOOac7w5yAEUOIc8jOnz6RphIe0j+JydjvLIfQngjDMl7JDpclBaD7nZMnobPhrzQVeA+YQwBP8QF4MJmQohwDAWXBBWcwRRIIVkChcw0Il9OwcOuUw7J3DjGopPqSsFLKsVfMZMSgl2KAWizeRiiBesvHiolUSMxygLHzGIUxaxb5bZRjXpjSl5U0yZnYisMVkq9UeJ8afPx9Bi4OimCEsJ2SIlDDUTEupvo1hh1CBHVyaS7m7K7s-Q5LygXsuFec4p9qVhWL9uXa1USnRIR9t6epPIdqQH7iqF0VYDI3FSMjApXTxA9NjGw9u5dhl9x0mM2598PXTORW0gpwL-WJS4pAUI2xJQfS+ktGo31jjtAoOeUQ8R2DpsPGo-YEhBBlB1mQT2bR-iPGeHCXtrB1hAA\">playground 링크</a>를 참고해볼 수 있다.</p>\n<pre><code class=\"language-ts\">// 제공된 객체 T에서 문자열 경로 K의 값을 가져올 때 사용하는 타입\ntype PathValue&#x3C;T, K extends string> =\n    // K가 점으로 구분된 문자열이라면 점 앞쪽 문자열을 Root, 점 뒤쪽 문자열을 Rest로 할당한다.\n    K extends `${infer Root}.${infer Rest}` ?\n        // Root가 T의 key 중 하나라면 재귀적으로 타입을 추론한다. 만약 Root가 T의 key 중 하나가 아니라면 never를 리턴하여 재귀 탈출\n        Root extends keyof T ? PathValue&#x3C;T[Root], Rest> : never\n    // K가 더 이상 점으로 구분되지 않는 경우이다. 이때는 top level key라는 것이므로 T의 key 중 하나인지 확인하고 그 값을 가져오기를 시도한다\n    : (K extends keyof T ? T[K] : undefined)\n\n// 이 타입은 경로 K가 유효한지 확인한다. 유효한 경로라면 K를 반환, 그렇지 않다면 never를 반환\ntype ValidatedPath&#x3C;T, K extends string> = PathValue&#x3C;T, K> extends never ? never : K;\n\n/**\n * Access an object via dot-notation string\n */\n// 객체 entity와 점으로 분할된 경로 path를 받아서 해당 경로의 값을 리턴한다.\n// PathValue의 정의상 만약 T에 K경로 값이 존재하지 않는다면 리턴타입이 never가 되어 오류가 발생한다\nfunction get&#x3C;T extends object, K extends string>(entity: T, path: ValidatedPath&#x3C;T, K>): PathValue&#x3C;T, K> {\n  // path를 점으로 분할하여 entity 내의 해당 경로에 접근하여 값을 반환\n    return path.split(\".\").reduce((acc: any, k) => acc[k], entity);\n}\n</code></pre>\n<h1>4. 마치며</h1>\n<p><code>infer</code> 타입은 사실 TS를 하면서 자주 마주할 일은 없는 타입이다. 자주 사용한다면 오히려 뭔가 코드가 이상해지고 있다는 이야기일지도 모른다.</p>\n<p>하지만 외부 함수를 사용할 때 함수의 인자나 리턴 타입 추론, 재귀적인 타입 추론 등 다른 타입에서 어떤 일부 타입을 뽑아서 사용해야 할 때 매우 유용하게 사용할 수 있다. 이런 활용법을 알아두면 나중에 유용하게 쓸 수 있을 것이다.</p>\n<p>(2023.10.20 내용 추가)</p>\n<h1>5. 유니언을 인터섹션으로</h1>\n<p><code>infer</code>를 이용하면 유니언 타입을 인터섹션 타입으로 바꿀 수 있다. 어떻게 하는 걸까? 일단 같은 이름의 타입 변수를 여러 군데 쓰면 공변성을 갖는 타입들에 한해서 유니언으로 합쳐진다는 것을 보자. T의 프로퍼티 value들이 모두 <code>U</code>로 추론되어 유니언된다.</p>\n<pre><code class=\"language-ts\">type InferUnion&#x3C;T>=T extends {[key:string]:infer U}?U:never;\n\n// 1 | 2 | 3 | 'a' | 'b'\ntype R=InferUnion&#x3C;{a:1|2, b:2|3, c:1|'a'|'b'}>\n</code></pre>\n<p>반면 함수 매개변수는 반공변성을 가지고 있기 때문에 이런 경우 인터섹션된다. <code>U</code>로 추론된 함수 매개변수들이 모두 인터섹션되어 결과 타입으로 리턴된다.</p>\n<pre><code class=\"language-ts\">type InferIntersection&#x3C;T>=T extends {[key:string]:(p:infer U)=>void}?U:never;\n\ntype Foo={\n    a(p:1|2|3):void,\n    b(p:2|3|4):void\n}\n// 2|3\ntype R2=InferIntersection&#x3C;Foo>\n</code></pre>\n<p>그럼 유니온 타입을 인터섹션으로 바꾸려면 해당 유니온의 각 요소를 제네릭 분배법칙을 이용해서 각각 함수 매개변수로 만들고 이를 인터섹션시키면 된다.</p>\n<pre><code class=\"language-ts\">type UnionToIntersection&#x3C;U>=\n(U extends any?(param:U)=>void:never) extends (param:infer I)=>void? I : never;\n</code></pre>\n<p>위처럼 쓰면 만약 <code>U</code>가 <code>U1 | U2 | ... | Un</code>이었다면 일단 제네릭 분배법칙에 의해 <code>UnionToIntersection&#x3C;U1> | ... | UnionToIntersection&#x3C;Un></code>이 된다. 그리고 각각은 any를 extends할 테고 그러면 <code>((param:Ui)=>void) extends (param:infer I)=>void? I : never</code>가 되어 <code>I</code>가 <code>Ui</code>로 추론된다.</p>\n<p>그런데 이 <code>I</code>들은 함수 매개변수이므로 인터섹션되고 따라서 <code>UnionToIntersection&#x3C;U></code>는 <code>U1 &#x26; ... &#x26; Un</code>이 된다.</p>\n<p>이를 boolean과 함께 쓸 때는 boolean 타입이 <code>true | false</code>로 해석되는 것에 주의해야 한다. 예를 들어서 <code>UnionToIntersection&#x3C;boolean | true></code>는 <code>true &#x26; false &#x26; true</code>가 되어 <code>never</code>가 된다.</p>\n<h1>참고</h1>\n<p>조현영 님의 <code>타입스크립트 교과서</code></p>\n<p>Understanding infer in TypeScript\n<a href=\"https://blog.logrocket.com/understanding-infer-typescript/\">https://blog.logrocket.com/understanding-infer-typescript/</a></p>\n<p>Infer keyword in TypeScript <a href=\"https://dev.to/0ro/infer-keyword-in-typescript-3nig\">https://dev.to/0ro/infer-keyword-in-typescript-3nig</a></p>\n<p>TypeScript Infer keyword Explained <a href=\"https://javascript.plainenglish.io/typescript-infer-keyword-explained-76f4a7208cb0\">https://javascript.plainenglish.io/typescript-infer-keyword-explained-76f4a7208cb0</a></p>\n<p>Reddit의 Typescript 게시판의 한 스레드, <code>Can someone explain the purpose of infer keyword?</code> <a href=\"https://www.reddit.com/r/typescript/comments/msr4vk/can_someone_explain_the_purpose_of_infer_keyword/\">https://www.reddit.com/r/typescript/comments/msr4vk/can_someone_explain_the_purpose_of_infer_keyword/</a></p>\n<p><a href=\"https://imygnam.tistory.com/114\">https://imygnam.tistory.com/114</a></p>",
    "excerpt": "1. infer 키워드란?\n1.1. 소개\nTS에서는 몇 가지 유틸리티 타입을 제공한다. Record<Keys,Type>이나 Omit<Type, Keys>와 같은 것들은 꽤나 흔히 쓰인다.\n그런데 이중 함수를 받아서 해당 함수의 리턴 타입을 추출하는 ReturnType<Type>이라는 유틸리티 타입이 있다. 이것은 함수의 리턴 타입을 추출하는 것이다.\nTS 핸드북의 예시를 가져와 보면 이해가 쉽다.\n// type T0 = string\ntype T0 = Return",
    "headingTree": [
      {
        "title": "1. infer 키워드란?",
        "url": "#1-infer-키워드란",
        "items": [
          {
            "title": "1.1. 소개",
            "url": "#11-소개",
            "items": []
          },
          {
            "title": "1.2. 사용법",
            "url": "#12-사용법",
            "items": []
          },
          {
            "title": "1.3. 여러 개의 infer",
            "url": "#13-여러-개의-infer",
            "items": []
          }
        ]
      },
      {
        "title": "2. 함수 인자 타입 추론",
        "url": "#2-함수-인자-타입-추론",
        "items": [
          {
            "title": "2.1. 함수 인자 타입 추론 방법",
            "url": "#21-함수-인자-타입-추론-방법",
            "items": []
          },
          {
            "title": "2.2. 서드파티 라이브러리 함수 인자 타입 추론",
            "url": "#22-서드파티-라이브러리-함수-인자-타입-추론",
            "items": []
          },
          {
            "title": "2.3. 리액트 컴포넌트 props 타입 추론",
            "url": "#23-리액트-컴포넌트-props-타입-추론",
            "items": []
          }
        ]
      },
      {
        "title": "3. 재귀적 타입 추론",
        "url": "#3-재귀적-타입-추론",
        "items": [
          {
            "title": "3.1. 예시 - 평탄화 타입",
            "url": "#31-예시---평탄화-타입",
            "items": []
          },
          {
            "title": "3.2. 예시 - Promise return 타입",
            "url": "#32-예시---promise-return-타입",
            "items": []
          },
          {
            "title": "3.3. 예시 - 경로 검증 타입",
            "url": "#33-예시---경로-검증-타입",
            "items": []
          }
        ]
      },
      {
        "title": "4. 마치며",
        "url": "#4-마치며",
        "items": []
      },
      {
        "title": "5. 유니언을 인터섹션으로",
        "url": "#5-유니언을-인터섹션으로",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 3,
      "wordCount": 895
    },
    "url": "/posts/typescript-infer-usage",
    "thumbnail": {
      "local": "/thumbnails/typescript-infer-usage-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-typescript-infer-usage-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAiklEQVR4nGNYu3att7d3RkaGvr5+ZWVld3f3kSNH/v//z9DX16elpZWRkcHKyubh4WFkZKSurv769WuGLVu2FBcX19fXT5ky5fbt28ePH9+9e/ePHz8YDh08OGPGjIVg8OnTp/8wwHDvwaOHDx++ePECIvobDEASi5etmr9w0fp1665cuQKRgOgAAOzzZFRe4/WJAAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "typescript-never-type",
    "title": "TS 탐구생활 - TS의 never 타입",
    "date": "2023-10-14T00:00:00Z",
    "description": "TS의 never 타입은 왜 존재하며 어디에 쓰일까?",
    "tags": [
      "typescript"
    ],
    "html": "<h1>1. TS의 never 타입</h1>\n<p>TS의 never 타입은 어떤 타입도 대입할 수 없으며 집합으로 치면 공집합과 같은 역할을 한다. 이를테면 유니언 타입에서 모든 타입이 배제되었을 때 never 타입이 된다.</p>\n<pre><code class=\"language-ts\">function foo(param:string | number){\n    if(typeof param==='string'){\n        console.log(\"문자열입니다.\");\n    }\n    else if(typeof param==='number'){\n        console.log(\"숫자입니다.\");\n    }\n    else{\n        // 이때 param은 never타입\n        param;\n    }\n}\n</code></pre>\n<p>혹은 에러를 발생시키거나 무한 루프를 도는 함수의 리턴타입으로도 쓰인다. 단 함수 선언문으로 그런 함수가 선언되었을 경우 그 함수의 리턴 타입은 void이고 함수 표현식으로 그런 함수가 선언되었을 때만 리턴타입이 never가 된다.</p>\n<pre><code class=\"language-ts\">const errorFunc=()=>{\n    throw new Error(\"테스트 에러\");\n}\n\nconst infFunc=()=>{\n    while(true){}\n}\n\n// foo1, foo2는 never타입\nconst foo1=errorFunc();\nconst foo2=infFunc();\n</code></pre>\n<p>따라서 함수 선언문으로 선언된 함수가 에러를 발생시키는 함수일 경우 리턴 타입을 never로 명시해주는 것이 좋다.</p>\n<pre><code class=\"language-ts\">function errorFunc():never{\n    throw new Error(\"테스트 에러\");\n}\n</code></pre>\n<p>또한 tsconfig에서 <code>noImplicitAny</code>를 체크 해제시(혹은 false로 설정) 빈 배열이 <code>never[]</code>타입으로 추론된다.</p>\n<p>그럼 이런 타입은 왜 존재하며, 어디에 쓰이는 걸까?</p>\n<h1>2. never 타입의 존재 이유</h1>\n<p>타입은 프로그램에 존재할 수 있는 값들을 그 능력에 따라 분류한 것이다. 예를 들어 정수 타입은 사칙연산에 사용할 수 있을 것이고 문자열 타입은 문자열을 조작하는 메서드를 사용할 수 있을 것이다. 이는 일종의 집합 같은 느낌이라 생각할 수 있다. 어떤 능력을 가진 값들을 모두 묶은 집합이 타입이 되는 것이다.</p>\n<p>그럼 우리는 타입을 다루면서, 각 값들이 어떤 집합에 속해 있는지를 분류하게 된다. Typescript 기준으로 생각한다면 string 타입 집합에 <code>'ab'</code>같은 값들이 속하고 number 타입 집합에 <code>1</code>같은 값들이 속하는 것이다. 이때 never 타입 집합은 아무것도 포함하지 않는다.</p>\n<p>왜 이런 타입이 존재하는 것일까? 이런 경우를 생각해 보자.</p>\n<p>다음과 같은 함수가 있다고 생각해보자. 메시지를 출력하고 바로 에러를 던져서 프로그램을 종료시키는 함수이다. 이 함수의 리턴타입은 무엇이 되어야 할까? <code>???</code>으로 일단 표기하겠다.</p>\n<pre><code class=\"language-ts\">function throwError(string msg): ??? {\n  console.log(msg);\n  throw new Error(msg);\n}\n</code></pre>\n<p>이 함수를 다른 곳에서 사용한다고 생각해 보면 이렇게 생각할 수 있다.</p>\n<pre><code class=\"language-ts\">function divide(x:number, y:number): ??? {\n  if(y===0){\n    throwError(\"0으로 나눌 수 없습니다.\");\n  }\n  return x/y;\n}\n</code></pre>\n<p>그런데 이때 <code>divide</code>에서 <code>y</code>가 0일 시 아예 리턴을 하지 않고 함수가 종료되어 버린다. 에러가 발생하기 때문이다. 그렇지 않을 때는 계산이 무사히 완료되어 <code>x/y</code>가 리턴되므로 <code>divide</code>의 리턴타입은 <code>x/y</code>의 타입 즉 number가 된다.</p>\n<p>그러면 <code>throwError</code>의 리턴타입도 number가 되는 게 합리적으로 보인다. 어차피 <code>throwError</code>는 함수 내용을 제대로 끝내지 못하고 종료되고, 나머지 경우에 <code>divide</code>는 number를 리턴하므로 <code>throwError</code>의 리턴타입도 똑같이 number로 하는 것이다.</p>\n<p>하지만 이럴 경우 <code>throwError</code>가 다른 리턴타입을 가진 함수 내에서 쓰일 경우 문제가 생긴다. 예를 들어 다음과 같은 것이다.</p>\n<pre><code class=\"language-ts\">function concat(x:string, y:string): string {\n  if(x.length+y.length>10){\n    throwError(\"문자열이 너무 길어요!\");\n  }\n  return x+y;\n}\n</code></pre>\n<p>이럴 경우 <code>concat</code>의 리턴타입은 <code>throwError</code>의 리턴타입인 number가 되어야 하는데, 이는 에러가 발생하지 않았을 때 <code>concat</code>이 리턴하는 string타입과는 다르다. 그래서 <code>throwError</code>의 리턴타입을 number로 하는 것은 좋지 않다.</p>\n<p>하지만 핵심은, 여기서 <code>throwError</code>의 리턴타입이 결코 쓰일 일이 없다는 것이다. <code>throwError</code>가 호출되면 에러가 발생해 프로그램이 종료되기 때문이다. 따라서 사실 <code>throwError</code>의 리턴타입은 무엇이 되어도 상관이 없다. 타입 검사를 통과하기만 하면 된다.</p>\n<p>이런 경우를 위해서 <code>never</code>타입이 있다. 어디서든 쓰일 수 있고, 하지만 이 타입을 리턴하는 함수가 아예 끝마쳐지지 못한다는 것을 나타내기에 절대로 쓰일 일이 없는 타입으로 말이다.</p>\n<p>그리고 여기에 가장 적절한 것은 타입을 집합으로 따졌을 때 공집합으로 정의되는 타입이다. 모든 타입의 서브타입이 될 수 있고, 어떤 서술을 해도 공허참이 되기 때문이다.</p>\n<p>따라서 이 경우 <code>throwError</code>의 리턴타입은 never가 된다.</p>\n<pre><code class=\"language-ts\">function throwError(string msg): never {\n  console.log(msg);\n  throw new Error(msg);\n}\n</code></pre>\n<p>마찬가지로 무한 루프를 도는 함수의 리턴 타입도 never가 된다. 이 함수는 영원히 리턴하지 않기 때문이다.</p>\n<pre><code class=\"language-ts\">function infLoop(): never {\n  while(true){}\n}\n</code></pre>\n<p>참고로 never의 동작은 정말 공집합과 비슷하여 어떤 값과 union을 해도 의미가 없고, 어떤 값과 intersection을 해도 결과를 never로 추론한다.</p>\n<h1>3. never의 용도</h1>\n<h2>3.1. 구조적 타이핑 비허용</h2>\n<p>어떤 객체가 a속성 혹은 b속성만 가질 수 있다고 하자. 그러면 다음과 같이 타입을 정의할 수 있다.</p>\n<pre><code class=\"language-ts\">type AorB={\n    a:string;\n} | {\n    b:number;\n}\n</code></pre>\n<p>하지만 이런 타입은 구조적 타이핑을 허용한다. 즉 다음과 같이 정의된 객체는 위 타입을 만족한다. 이 객체는 a속성도 b속성도 가지고 있기 때문이다.</p>\n<pre><code class=\"language-ts\">const obj:AorB={\n    a:\"hello\",\n    b:3,\n}\n</code></pre>\n<p>만약 a속성과 b속성 둘 중 하나만 가지도록 하고 싶다면 never를 사용할 수 있다. 다음과 같이 <code>AorB</code>를 정의하면 위와 같은 객체는 <code>AorB</code>의 타입 검사를 통과하지 못한다.</p>\n<pre><code class=\"language-ts\">type AorB={\n    a:string;\n    b?:never;\n} | {\n    a?:never;\n    b:number;\n}\n</code></pre>\n<h2>3.2. 조건부 분기문에 도달할 수 없음을 표시</h2>\n<p><code>infer</code>를 써서 조건부 타입 내에 다른 타입을 변수로 만들 때, 조건부 타입에서 생기는 모든 분기에 타입을 추가해야 한다. 하지만 이론상 도달할 수 없는 타입을 추가해야 하는 경우가 생길 수 있다. 이럴 때 never를 사용하면 된다.</p>\n<p>예를 들어서 함수 파라미터 타입을 얻기 위해서는 다음과 같은 코드가 사용된다. <code>P</code>를 추론하지 못했을 때 never 타입이 쓰인다.</p>\n<pre><code class=\"language-ts\">type Param&#x3C;T>=T extends (...args: infer P) => any ? P : never;\n</code></pre>\n<h2>3.3. 멤버 필터링</h2>\n<p>뭔가를 필터링할 때 분배법칙과 never타입을 이용한다.</p>\n<p>유니언의 분배 법칙을 이용해서 유니언을 필터링할 수 있다. 이때 원하지 않는 타입에 대해서는 never 타입이 되도록 해서 유니언에서 특정 조건을 만족하는 타입만 남기는 것이다.</p>\n<p>예를 들어서 다음과 같은 유틸리티 타입을 생각해 볼 수 있다. 이 타입은 유니언 타입에서 <code>name</code>이 <code>string</code>인 타입만 추출한다.</p>\n<pre><code class=\"language-ts\">type FilterName&#x3C;T>=T extends {name:string} ? T : never;\n\ntype Person={\n    name:string;\n    age:number;\n}\n\ntype Dog={\n    name:string;\n    bark:()=>string;\n}\n\ntype Account={\n    balance:number;\n    interest:number;\n}\n\n// Person | Dog\ntype Foo=FilterName&#x3C;Person | Dog | Account>;\n/*\ntype Foo=FilterName&#x3C;Person> | FilterName&#x3C;Dog> | FilterName&#x3C;Account>;\n-> Foo=Person | Dog | never;\n-> Foo=Person | Dog;\n*/\n</code></pre>\n<p>위처럼 필터링 시 필터를 통과하지 못하는 속성들에 대해서 never 타입을 사용하여 유니언에서 제외시킬 수 있다.</p>\n<p>또한 이를 발전시켜 객체 타입의 키를 필터링할 수도 있다. 다음과 같이 쓰면 <code>Obj</code>타입에서 <code>ValueType</code>타입의 키만 추출할 수 있다.</p>\n<pre><code class=\"language-ts\">type Filter&#x3C;Obj extends Object, ValueType> = {\n  [Key in keyof Obj as ValueType extends Obj[Key] ? Key : never]: Obj[Key]\n}\n</code></pre>\n<h1>참고</h1>\n<p>홍재민, '프로그래밍 언어 속 타입' 중 2.2 집합론적 타입 - 최소 타입 <a href=\"https://blog.hjaem.info/18\">https://blog.hjaem.info/18</a></p>\n<p>타입스크립트 타입 never 에 대해 자세히 알아보자 <a href=\"https://yceffort.kr/2022/03/understanding-typescript-never\">https://yceffort.kr/2022/03/understanding-typescript-never</a></p>",
    "excerpt": "1. TS의 never 타입\nTS의 never 타입은 어떤 타입도 대입할 수 없으며 집합으로 치면 공집합과 같은 역할을 한다. 이를테면 유니언 타입에서 모든 타입이 배제되었을 때 never 타입이 된다.\nfunction foo(param:string | number){\n    if(typeof param==='string'){\n        console.log(\"문자열입니다.\");\n    }\n    else if(typeof param==='number'){\n",
    "headingTree": [
      {
        "title": "1. TS의 never 타입",
        "url": "#1-ts의-never-타입",
        "items": []
      },
      {
        "title": "2. never 타입의 존재 이유",
        "url": "#2-never-타입의-존재-이유",
        "items": []
      },
      {
        "title": "3. never의 용도",
        "url": "#3-never의-용도",
        "items": [
          {
            "title": "3.1. 구조적 타이핑 비허용",
            "url": "#31-구조적-타이핑-비허용",
            "items": []
          },
          {
            "title": "3.2. 조건부 분기문에 도달할 수 없음을 표시",
            "url": "#32-조건부-분기문에-도달할-수-없음을-표시",
            "items": []
          },
          {
            "title": "3.3. 멤버 필터링",
            "url": "#33-멤버-필터링",
            "items": []
          }
        ]
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 288
    },
    "url": "/posts/typescript-never-type",
    "thumbnail": {
      "local": "/thumbnails/typescript-never-type-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-typescript-never-type-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAj0lEQVR4nE3KIQrDMBSA4Rwg14nMHQq9SWQgKgd4qvBs6CYmJrqoit6hq6gqK62LinsQCLyxibHffr+IMbZta4xRSllrAaBpmpyzCCForY0xUkpEJKJlWUopYhxH5xwAeO+3bWPmWiszi+c8hxAQseu6aZpKKfxNvPb9OM+UEhH99g9cb/e+vzyGYV3Xf3gDWjtqfzN4Z5IAAAAASUVORK5CYII="
    }
  },
  {
    "slug": "typescript-promise-type",
    "title": "TS 탐구생활 - TS의 Promise type 정의",
    "date": "2023-11-01T00:00:00Z",
    "description": "TS에서는 Promise 관련 타입을 어떻게 정의하고 있을까?",
    "tags": [
      "typescript"
    ],
    "html": "<h1>시작</h1>\n<p>JS의 Promise는 말할 것도 없이 매우 중요한 개념이고, 당연히 TS에서도 관련 타입들을 잘 정의해 두었다. 이를 한번 살펴보자. 완벽하게 정리된 글이라기보다는 탐구의 과정을 드러내고자 했다.</p>\n<h1>1. 탐구의 시작</h1>\n<p>Promise는 es2015에 처음 등장했다. 그러니 <code>node_modules</code>에서 typescript를 찾은 후 폴더 내를 찾아보면 <code>lib.es2015</code>로 시작하는 파일들을 찾아보자. 마침 <code>lib.es2015.promise.d.ts</code>라는 파일이 있다.</p>\n<p>이 파일에 들어가면 <code>PromiseConstructor</code>타입이 정의되어 있다.</p>\n<pre><code class=\"language-ts\">interface PromiseConstructor {\n    /**\n     * A reference to the prototype.\n     */\n    readonly prototype: Promise&#x3C;any>;\n    /* 내용은 일단 생략. 이후에 다룬다 */\n}\n\ndeclare var Promise: PromiseConstructor;\n</code></pre>\n<p>Promise는 원래 존재하는 객체이므로 타입만 붙이기 위해서 declare로 앰비언트 타입을 썼다. 그런데 잘 보면 여기 정의되어 있는 PromiseConstructor 는 우리가 잘 알고 있는 Promise 인스턴스의 타입이 아니다. 여기서의 Promise타입은 <code>Promise.all</code>등의 메서드를 가지고 있는, Promise 생성자 그 자체다.</p>\n<p>그럼 우리가 아는 Promise 인스턴스의 타입은 어디에 정의되어 있을까? 이는 <code>lib.es5.d.ts</code>에서 찾을 수 있다. 여기서는 Promise에 얽힌 다른 타입들도 정의하고 있는데 이를 하나씩 살펴보자. 그리고 나서 이 Promise 생성자로 다시 돌아올 것이다.</p>\n<h1>2. lib.es5.d.ts의 Promise 관련 타입</h1>\n<p>가장 다른 타입에 대한 의존성이 없는 타입부터 하나하나 살펴보겠다. 다른 아무 타입에도 의존하지 않고 있는 <code>PromiseLike</code>부터 시작하자.</p>\n<h2>2.1. PromiseLike</h2>\n<p><code>lib.es5.d.ts</code>의 PromiseLike은 다음과 같이 정의되어 있다. <code>then</code>메서드 하나가 정의되어 있는 인터페이스다.</p>\n<pre><code class=\"language-ts\">interface PromiseLike&#x3C;T> {\n  /**\n   * Attaches callbacks for the resolution and/or rejection of the Promise.\n   * @param onfulfilled The callback to execute when the Promise is resolved.\n   * @param onrejected The callback to execute when the Promise is rejected.\n   * @returns A Promise for the completion of which ever callback is executed.\n   */\n  then&#x3C;TResult1 = T, TResult2 = never>(\n    onfulfilled?:\n      | ((value: T) => TResult1 | PromiseLike&#x3C;TResult1>)\n      | undefined\n      | null,\n    onrejected?:\n      | ((reason: any) => TResult2 | PromiseLike&#x3C;TResult2>)\n      | undefined\n      | null\n  ): PromiseLike&#x3C;TResult1 | TResult2>;\n}\n</code></pre>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then\">MDN의 <code>Promise.prototype.then()</code> 문서</a>를 보면 이와 비슷한 형태로 해당 메서드가 정의된 것을 볼 수 있다.</p>\n<pre><code class=\"language-ts\">then(onFulfilled)\nthen(onFulfilled, onRejected)\n</code></pre>\n<p><code>onfulfilled</code>는 Promise가 resolve되었을 때 실행되는 메서드, <code>onrejected</code>는 reject되었을 때 실행되는 메서드다. 둘 다 생략 가능하다.</p>\n<p>위의 PromiseLike 타입으로 돌아가서 제네릭을 해석해 보면, <code>onfulfilled</code>는 인자로 받은 객체와 같은 타입을 리턴하거나 아니면 또다른 <code>PromiseLike</code>을 리턴한다. <code>onrejected</code>는 Promise가 거절되었을 때 실행되는 콜백이므로 또다른 Promise 혹은 명시된 리턴 타입을 리턴한다.</p>\n<p>Promise의 사용 예시를 보면 이런 식으로 then이 중첩되는 것을 쉽게 볼 수 있으므로 Promise와 비슷한 형식의 타입인 <code>PromiseLike</code>도 재귀적으로 정의되는 게 맞다.</p>\n<pre><code class=\"language-ts\">fetch(\"https://jsonplaceholder.typicode.com/todos/1\")\n  .then((response) => response.json())\n  .then((json) => console.log(json));\n</code></pre>\n<p>딸린 타입으로 <code>PromiseConstructorLike</code>도 있다. 말 그대로 Promise 생성자 비슷한 타입이다.</p>\n<pre><code class=\"language-ts\">declare type PromiseConstructorLike = new &#x3C;T>(\n  executor: (\n    resolve: (value: T | PromiseLike&#x3C;T>) => void,\n    reject: (reason?: any) => void\n  ) => void\n) => PromiseLike&#x3C;T>;\n</code></pre>\n<p><code>resolve</code>, <code>reject</code>를 인자로 받는 executor 함수를 받는다. 실제 Promise의 사용예를 생각해 보면 이런 타입이 Promise 생성자와 비슷하다는 게 눈에 보인다.</p>\n<pre><code class=\"language-ts\">// 실제 Promise 생성자 사용 예시\nnew Promise((resolve, reject) => {\n  resolve(1);\n});\n</code></pre>\n<p><code>resolve</code>가 인자로 받은 값의 타입을 <code>PromiseLike</code>으로 감싸서 리턴하는 것까지 비슷하다. 예를 들어 Promise에서 <code>resolve(1)</code>을 하면 Promise가 이행된 값이 1이므로 <code>PromiseLike&#x3C;number></code>를 리턴하는 게 당연할 것이다!</p>\n<pre><code class=\"language-ts\">new Promise((resolve, reject) => {\n  resolve(1);\n});\n</code></pre>\n<h2>2.2. Promise</h2>\n<p>그럼 이걸 기반으로 진짜 Promise 인스턴스의 타입을 한번 파보자.</p>\n<pre><code class=\"language-ts\">// lib.es5.d.ts\n/**\n * Represents the completion of an asynchronous operation\n */\ninterface Promise&#x3C;T> {\n  /**\n   * Attaches callbacks for the resolution and/or rejection of the Promise.\n   * @param onfulfilled The callback to execute when the Promise is resolved.\n   * @param onrejected The callback to execute when the Promise is rejected.\n   * @returns A Promise for the completion of which ever callback is executed.\n   */\n  then&#x3C;TResult1 = T, TResult2 = never>(\n    onfulfilled?:\n      | ((value: T) => TResult1 | PromiseLike&#x3C;TResult1>)\n      | undefined\n      | null,\n    onrejected?:\n      | ((reason: any) => TResult2 | PromiseLike&#x3C;TResult2>)\n      | undefined\n      | null\n  ): Promise&#x3C;TResult1 | TResult2>;\n\n  /**\n   * Attaches a callback for only the rejection of the Promise.\n   * @param onrejected The callback to execute when the Promise is rejected.\n   * @returns A Promise for the completion of the callback.\n   */\n  catch&#x3C;TResult = never>(\n    onrejected?:\n      | ((reason: any) => TResult | PromiseLike&#x3C;TResult>)\n      | undefined\n      | null\n  ): Promise&#x3C;T | TResult>;\n}\n</code></pre>\n<p>then의 경우는 PromiseLike에서와 비슷하다. 다만 리턴 타입이 PromiseLike에서 Promise로 바뀌었다.</p>\n<p>catch 메서드가 추가되었는데 이는 Promise가 거절되었을 때 실행되는 콜백을 등록하는 메서드다. <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch\">이 또한 Promise를 리턴하는데 <code>Promise.prototype.catch()</code>가 다른 Promise 체이닝이 가능하도록 Promise를 리턴하는 걸 볼 때 맞는 리턴 타입이다.</a></p>\n<h2>2.3. Awaited</h2>\n<p>그럼 이제 비동기 타입을 벗겨내는 <code>Awaited&#x3C;T></code>에 대해 알아보자. Promise가 아닐 경우 never가 될 것이고 Promise일 경우 Promise가 resolve된 값의 타입이 될 것이다. JS에서의 <code>await</code>동작을 생각해 보면 된다.</p>\n<pre><code class=\"language-ts\">/**\n * Recursively unwraps the \"awaited type\" of a type. Non-promise \"thenables\" should resolve to `never`. This emulates the behavior of `await`.\n */\ntype Awaited&#x3C;T> = T extends null | undefined\n  ? T // special case for `null | undefined` when not in `--strictNullChecks` mode\n  : T extends object &#x26; { then(onfulfilled: infer F, ...args: infer _): any } // `await` only unwraps object types with a callable `then`. Non-object types are not unwrapped\n  ? F extends (value: infer V, ...args: infer _) => any // if the argument to `then` is callable, extracts the first argument\n    ? Awaited&#x3C;V> // recursively unwrap the value\n    : never // the argument to `then` was not callable\n  : T; // non-object or non-thenable\n</code></pre>\n<p>이 복잡한 삼항 연산자를 그림으로 나타내면 다음과 같다.</p>\n<p><img src=\"/static/awaited-type-0276d208.png\" alt=\"awaited\"></p>\n<p><code>T</code>가 <code>null</code>이나 <code>undefined</code>일 경우 <code>T</code>를 리턴하는 부분은 크게 볼 것이 없다. 중요한 것은 그 다음이다.</p>\n<p>다음 단계에선 <code>T</code>가 객체이며 then 메서드를 가지는지를 검사한다. 즉 thenable인지를 검사하는 것이다. 여기서 통과하지 못하면 그대로 T를 리턴한다. 따라서 <code>Awaited&#x3C;T></code>에서 T가 thenable이 아닐 경우 그대로 T가 된다.</p>\n<pre><code class=\"language-ts\">type A=Awaited&#x3C;string>; // string이 그대로 나옴\ntype B=Awaited&#x3C;'hello' | number>; // 역시 'hello' | number 그대로 나옴\ntype O=Awaited&#x3C;{A:1}> // {A:1} 그대로 나옴\n</code></pre>\n<p>이것까지 통과했다면 <code>T</code>가 thenable 타입인 건 보장된 상태다. 그러면 then 메서드의 첫번째 인자 타입을 F로 추론한 후 해당 인자가 callable한 함수 타입인지 검사한다. 만약 T의 then 메서드 첫번째 인자 타입 F가 callable이 아니라면 <code>never</code>를 리턴한다. 다음과 같이 then메서드의 첫 인자가 callable이 아닌 타입은 Awaited 적용시 never가 리턴되는 걸 볼 수 있다.</p>\n<pre><code class=\"language-ts\">type FooThenable={\n    then:(value:number)=>any;\n}\n\ntype F=Awaited&#x3C;FooThenable>; // never\n</code></pre>\n<p>T의 then메서드 첫번째 인자가 callable이기까지 하다면 해당 인자의 첫번째 인자 타입을 또 V로 추론한 후 재귀적으로 <code>Awaited</code>에 집어넣어 리턴한다. 이는 실제 Promise의 then 메서드 사용을 보면 왜 이런 식으로 추론하는지 알 수 있다.</p>\n<pre><code class=\"language-ts\">// 여기서 Awaited&#x3C;fetch(...)>의 타입은 then메서드 첫번째 인자인 함수의 첫번째 인자인 response의 타입이다.\nfetch(\"https://jsonplaceholder.typicode.com/todos/1\")\n  .then((response) => response.json());\n</code></pre>\n<p><code>fetch</code>는 Promise를 리턴하는데, 여기에 await을 적용했을 때 나와야 하는 값은 <code>response</code>값이다. 이는 then메서드가 첫번째 인자로 받은 콜백의 첫번째 인자다. 이는 위에서 Awaited 타입이 추론한 타입과 같다.</p>\n<p>Promise 타입의 형태에서도 해당 타입이 Awaited에 들어가면 어떻게 될지 한번 생각해 보자. <code>Awaited&#x3C;Promise&#x3C;T>></code>가 있다면 Awaited 타입은 Promise 타입의 then 메서드가 받는 첫번째 콜백, 즉 onfulfilled가 받는 첫번째 인자의 타입을 추론하는데 아래에서 Promise의 onfulfilled 함수 첫번째 인자 타입을 보면 이는 바로 T다.</p>\n<pre><code class=\"language-ts\">interface Promise&#x3C;T> {\n  /**\n   * Attaches callbacks for the resolution and/or rejection of the Promise.\n   * @param onfulfilled The callback to execute when the Promise is resolved.\n   * @param onrejected The callback to execute when the Promise is rejected.\n   * @returns A Promise for the completion of which ever callback is executed.\n   */\n  then&#x3C;TResult1 = T, TResult2 = never>(\n    onfulfilled?:\n      | ((value: T) => TResult1 | PromiseLike&#x3C;TResult1>)\n      | undefined\n      | null,\n    onrejected?:\n      | ((reason: any) => TResult2 | PromiseLike&#x3C;TResult2>)\n      | undefined\n      | null\n  ): Promise&#x3C;TResult1 | TResult2>;\n\n  /* ... */\n}\n</code></pre>\n<p>이렇게 추론된 첫번째 인자 콜백 함수의 첫번째 인자 타입은 그대로 Awaited에 재귀적으로 들어가므로 <code>Awaited&#x3C;Promise&#x3C;T>></code>는 <code>Awaited&#x3C;T></code>가 된다.</p>\n<p>이런 부분을 이용해서 chaining된 Promise의 타입을 추론하는 부분도 있는데 이는 <a href=\"https://search.shopping.naver.com/book/catalog/41736307631?cat_id=50010881&#x26;frm=PBOKPRO&#x26;query=%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8+%EA%B5%90%EA%B3%BC%EC%84%9C&#x26;NaPm=ct%3Dloiqkizs%7Cci%3Da227a8b9f5020f34f7fa025e7249ade5ad19b261%7Ctr%3Dboknx%7Csn%3D95694%7Chk%3D20f6e1c8ee1437ed56121f5ca6fb361bbe23d5c0\">조현영 님의 타입스크립트 교과서(네이버 쇼핑 링크)</a>에 아주 친절하게 설명되어 있다.</p>\n<h3>2.3.1. 약간의 문제</h3>\n<p>이런 식으로의 추론은 무한 루프를 일으킬 수 있다. <code>thenable</code> 구조가 타입에서 무한히 이어질 경우다.</p>\n<pre><code class=\"language-ts\">type RecursiveThenable = {\n  then: (callback: (value: RecursiveThenable) => void) => void;\n};\n\n// Type instantiation is excessively deep and possibly infinite.\ntype Unwrapped = Awaited&#x3C;RecursiveThenable>; \n</code></pre>\n<h1>3. PromiseConstructor</h1>\n<p>다시 <code>lib.es2015.promise.d.ts</code>로 돌아와서 PromiseConstructor를 살펴보자. 이는 Promise 생성자의 타입인데, <code>Promise.all</code>같은 몇몇 메서드가 여기에 정의되어 있기 때문에 한번 보는 게 좋겠다.</p>\n<pre><code class=\"language-ts\">interface PromiseConstructor {\n    /**\n     * A reference to the prototype.\n     */\n    readonly prototype: Promise&#x3C;any>;\n\n    /**\n     * Creates a new Promise.\n     * @param executor A callback used to initialize the promise. This callback is passed two arguments:\n     * a resolve callback used to resolve the promise with a value or the result of another promise,\n     * and a reject callback used to reject the promise with a provided reason or error.\n     */\n    new &#x3C;T>(executor: (resolve: (value: T | PromiseLike&#x3C;T>) => void, reject: (reason?: any) => void) => void): Promise&#x3C;T>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all&#x3C;T extends readonly unknown[] | []>(values: T): Promise&#x3C;{ -readonly [P in keyof T]: Awaited&#x3C;T[P]> }>;\n\n    // see: lib.es2015.iterable.d.ts\n    // all&#x3C;T>(values: Iterable&#x3C;T | PromiseLike&#x3C;T>>): Promise&#x3C;Awaited&#x3C;T>[]>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race&#x3C;T extends readonly unknown[] | []>(values: T): Promise&#x3C;Awaited&#x3C;T[number]>>;\n\n    // see: lib.es2015.iterable.d.ts\n    // race&#x3C;T>(values: Iterable&#x3C;T | PromiseLike&#x3C;T>>): Promise&#x3C;Awaited&#x3C;T>>;\n\n    /**\n     * Creates a new rejected promise for the provided reason.\n     * @param reason The reason the promise was rejected.\n     * @returns A new rejected Promise.\n     */\n    reject&#x3C;T = never>(reason?: any): Promise&#x3C;T>;\n\n    /**\n     * Creates a new resolved promise.\n     * @returns A resolved promise.\n     */\n    resolve(): Promise&#x3C;void>;\n    /**\n     * Creates a new resolved promise for the provided value.\n     * @param value A promise.\n     * @returns A promise whose internal state matches the provided promise.\n     */\n    resolve&#x3C;T>(value: T): Promise&#x3C;Awaited&#x3C;T>>;\n    /**\n     * Creates a new resolved promise for the provided value.\n     * @param value A promise.\n     * @returns A promise whose internal state matches the provided promise.\n     */\n    resolve&#x3C;T>(value: T | PromiseLike&#x3C;T>): Promise&#x3C;Awaited&#x3C;T>>;\n}\n\ndeclare var Promise: PromiseConstructor;\n</code></pre>\n<h2>3.1. Promise.all</h2>\n<pre><code class=\"language-ts\">/**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all&#x3C;T extends readonly unknown[] | []>(values: T): Promise&#x3C;{ -readonly [P in keyof T]: Awaited&#x3C;T[P]> }>;\n</code></pre>\n<p><code>Promise.all</code>은 여러 개의 Promise가 담긴 배열을 받아서 모든 Promise가 resolve되면 resolve된 값들의 배열을 리턴하고, 하나라도 reject되면 reject된 이유를 리턴한다. 따라서 제네릭에서 <code>T</code>를 배열 타입으로 제한하고 있다.</p>\n<p>그리고 리턴 타입은 <code>T</code>의 각 요소를 <code>Awaited</code>에 넣은 배열을 Promise로 감싼 타입이다. <code>Promise.all</code>이 배열에 담긴 Promise들을 모두 이행 후 그 결과를 배열로 리턴하는 것에 맞는 타입이라고 보인다.</p>\n<h2>3.2. Promise.race</h2>\n<pre><code class=\"language-ts\">    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race&#x3C;T extends readonly unknown[] | []>(values: T): Promise&#x3C;Awaited&#x3C;T[number]>>;\n</code></pre>\n<p><code>Promise.race</code>는 Promise.all과 비슷하게 Promise들이 담긴 배열을 받는다. 그런데 모든 Promise의 결과를 담는 all과 달리 race의 경우 가장 먼저 처리되는 Promise의 결과를 이행이건 거부건 그대로 리턴한다.</p>\n<p>따라서 해당 함수의 리턴 타입은 Promise 배열 타입인 <code>T</code>를 숫자 인덱스로 접근했을 때 나올 수 있는 타입 중 하나를 Awaited한 <code>Awaited&#x3C;T[number]></code>를 Promise로 감싼 형태가 된다.</p>\n<h2>3.3. resolve, reject, finally</h2>\n<p>위에는 resolve, reject 타입도 있는데 너무 그대로 보이는 타입이기 때문에 해석은 생략한다. 비슷하게 <code>lib.es2018.promise.d.ts</code>에는 Promise의 메서드인 <code>finally</code>가 정의되어 있는데 이 또한 너무 그대로 보이는 타입이다.</p>\n<pre><code class=\"language-ts\">// lib.es2018.promise.d.ts\ninterface Promise&#x3C;T> {\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): Promise&#x3C;T>\n}\n</code></pre>\n<h2>3.4. Promise 이터러블을 위한 타입</h2>\n<p>그런데 ES2015에서, 반복 가능한 새로운 형태인 이터러블이라는 것이 나왔다. 이에 대한 자세한 설명은 <a href=\"https://witch.work/posts/javascript-symbol-usage#6.4.-Symbol.iterator\">심볼의 쓰임새를 다룬 글</a>에서 볼 수 있다. 반복자의 끝에 다다를 때까지 <code>Symbol.iterator</code>를 호출하면서 반복하는 형태이다. 그리고 이 타입을 TS에서도 정의하고 있다. <code>lib.es2015.iterable.d.ts</code>를 보면 된다.</p>\n<pre><code class=\"language-ts\">// lib.es2015.iterable.d.ts\ninterface Iterator&#x3C;T, TReturn = any, TNext = undefined> {\n    // NOTE: 'next' is defined using a tuple to ensure we report the correct assignability errors in all places.\n    next(...args: [] | [TNext]): IteratorResult&#x3C;T, TReturn>;\n    return?(value?: TReturn): IteratorResult&#x3C;T, TReturn>;\n    throw?(e?: any): IteratorResult&#x3C;T, TReturn>;\n}\n\ninterface Iterable&#x3C;T> {\n    [Symbol.iterator](): Iterator&#x3C;T>;\n}\n</code></pre>\n<p>이 타입에 대한 해석은 반복자 프로토콜에 대한 이해도 필요하고 해서 긴 다른 글이 될 거라고 생각해서 생략한다. 중요한 것은 배열 외에도 반복 가능한 새로운 객체가 나왔다는 것이고 Promise.all과 같이 반복 가능한 객체에 담긴 Promise들을 다루는 메서드들은 이를 지원해야 했다는 것이다.</p>\n<p>따라서 <code>lib.es2015.iterable.d.ts</code>에서는 기존의 <code>PromiseConstructor</code>와 병합될 인터페이스에 또다른 형태의 all, race 메서드를 정의하고 있다.</p>\n<pre><code class=\"language-ts\">interface PromiseConstructor {\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An iterable of Promises.\n     * @returns A new Promise.\n     */\n    all&#x3C;T>(values: Iterable&#x3C;T | PromiseLike&#x3C;T>>): Promise&#x3C;Awaited&#x3C;T>[]>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An iterable of Promises.\n     * @returns A new Promise.\n     */\n    race&#x3C;T>(values: Iterable&#x3C;T | PromiseLike&#x3C;T>>): Promise&#x3C;Awaited&#x3C;T>>;\n}\n</code></pre>\n<p>위에서는 <code>T</code>자체가 배열 타입이었는데 여기서는 인자로 받는 타입이 <code>T</code>의 이터러블이다. 따라서 <code>Promise.all</code>메서드의 리턴 타입이 <code>T</code>를 Awaited로 감싸서 나오는 타입의 배열로 바뀐 것을 볼 수 있다.</p>\n<h2>3.5. any</h2>\n<p>ES2020에서는 이미 이터러블이 도입되어 있었기 때문에 여기부터 나오는 Promise 관련 타입들은 처음부터 이터러블을 위한 타입도 같이 정의되어 있다. <code>lib.es2021.promise.d.ts</code>에는 받은 Promise 배열에서 가장 먼저 fulfilled된 Promise의 결과를 리턴하거나 모두 실패시 Promise 거절 이유들을 담아서 리턴하는 Promise.any가 정의되어 있다.</p>\n<p>일정 시기 이후부터는 타입들에서 처음부터 이터러블을 고려한다는 것을 보여주는 예시로써 다룬 것이기도 하고 위에서 다뤘던 타입들과 거의 비슷하기 때문에 구체적인 설명은 생략한다.</p>\n<pre><code class=\"language-ts\">// lib.es2021.promise.d.ts\ninterface PromiseConstructor {\n    any&#x3C;T extends readonly unknown[] | []>(values: T): Promise&#x3C;Awaited&#x3C;T[number]>>;\n\n    any&#x3C;T>(values: Iterable&#x3C;T | PromiseLike&#x3C;T>>): Promise&#x3C;Awaited&#x3C;T>>\n}\n</code></pre>\n<h2>3.6. allSettled</h2>\n<p><code>lib.es2020.promise.d.ts</code>에는 <code>allSettled</code>라는 메서드가 정의되어 있다. Promise.all이 중간에 거절된 Promise가 있다면 종료되는 것과 달리 allSettled는 모든 Promise가 끝까지 이행될 때까지 기다린다. 더 자세한 설명은 <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled\">Promise.allSettled() - JavaScript | MDN</a>를 참고하자.</p>\n<p>아무튼 여기서는 새로 정의된 타입이 좀 있다. <code>status</code>와 <code>value</code>혹은 거절 이유인 <code>reason</code>을 담은 객체를 리턴해야 하기 때문이다.</p>\n<pre><code class=\"language-ts\">// lib.es2020.promise.d.ts\ninterface PromiseFulfilledResult&#x3C;T> {\n    status: \"fulfilled\";\n    value: T;\n}\n\ninterface PromiseRejectedResult {\n    status: \"rejected\";\n    reason: any;\n}\n\ntype PromiseSettledResult&#x3C;T> = PromiseFulfilledResult&#x3C;T> | PromiseRejectedResult;\n\ninterface PromiseConstructor {\n    /**\n     * Creates a Promise that is resolved with an array of results when all\n     * of the provided Promises resolve or reject.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    allSettled&#x3C;T extends readonly unknown[] | []>(values: T): Promise&#x3C;{ -readonly [P in keyof T]: PromiseSettledResult&#x3C;Awaited&#x3C;T[P]>> }>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all\n     * of the provided Promises resolve or reject.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    allSettled&#x3C;T>(values: Iterable&#x3C;T | PromiseLike&#x3C;T>>): Promise&#x3C;PromiseSettledResult&#x3C;Awaited&#x3C;T>>[]>;\n}\n</code></pre>\n<p><code>PromiseSettledResult</code>타입의 해석은 Promise의 각 상태에 대해서 알고 있다면 쉽다. 그냥 Promise가 이행되었을 때와 거절되었을 때의 타입을 유니언으로 묶은 것이다.</p>\n<p><code>allSettled</code>는 역시 Promise가 들어 있는 배열 혹은 이터러블(물론 Promise가 아니라도 타입은 잘 작동하지만 일반적으로 그렇다는 것이다)을 받는다. 그리고 해당 배열이나 이터러블에 들어 있는 각 Promise에 대해서 <code>Awaited</code>를 가해서 해당 Promise가 이행되었을 때의 결과를 가져온다. 그리고 이를 <code>PromiseSettledResult</code>에 담아서 리턴하는데 이때 <code>PromiseFulfilledResult</code>의 value의 타입이 Promise fulfill시 타입으로 추론된다.</p>\n<pre><code>allSettled에서 인자로 받은 Promise 배열의 타입을 T 타입으로 추론 -> T의 이행 결과의 타입을 `Awaited`에 넣어서 추론 -> PromiseSettledResult의 value 타입이 Awaited&#x3C;T>가 됨\n</code></pre>",
    "excerpt": "시작\nJS의 Promise는 말할 것도 없이 매우 중요한 개념이고, 당연히 TS에서도 관련 타입들을 잘 정의해 두었다. 이를 한번 살펴보자. 완벽하게 정리된 글이라기보다는 탐구의 과정을 드러내고자 했다.\n1. 탐구의 시작\nPromise는 es2015에 처음 등장했다. 그러니 node_modules에서 typescript를 찾은 후 폴더 내를 찾아보면 lib.es2015로 시작하는 파일들을 찾아보자. 마침 lib.es2015.promise.d.ts라는 파일이 있다",
    "headingTree": [
      {
        "title": "시작",
        "url": "#시작",
        "items": []
      },
      {
        "title": "1. 탐구의 시작",
        "url": "#1-탐구의-시작",
        "items": []
      },
      {
        "title": "2. lib.es5.d.ts의 Promise 관련 타입",
        "url": "#2-libes5dts의-promise-관련-타입",
        "items": [
          {
            "title": "2.1. PromiseLike",
            "url": "#21-promiselike",
            "items": []
          },
          {
            "title": "2.2. Promise",
            "url": "#22-promise",
            "items": []
          },
          {
            "title": "2.3. Awaited",
            "url": "#23-awaited",
            "items": [
              {
                "title": "2.3.1. 약간의 문제",
                "url": "#231-약간의-문제",
                "items": []
              }
            ]
          }
        ]
      },
      {
        "title": "3. PromiseConstructor",
        "url": "#3-promiseconstructor",
        "items": [
          {
            "title": "3.1. Promise.all",
            "url": "#31-promiseall",
            "items": []
          },
          {
            "title": "3.2. Promise.race",
            "url": "#32-promiserace",
            "items": []
          },
          {
            "title": "3.3. resolve, reject, finally",
            "url": "#33-resolve-reject-finally",
            "items": []
          },
          {
            "title": "3.4. Promise 이터러블을 위한 타입",
            "url": "#34-promise-이터러블을-위한-타입",
            "items": []
          },
          {
            "title": "3.5. any",
            "url": "#35-any",
            "items": []
          },
          {
            "title": "3.6. allSettled",
            "url": "#36-allsettled",
            "items": []
          }
        ]
      }
    ],
    "metadata": {
      "readingTime": 6,
      "wordCount": 1543
    },
    "url": "/posts/typescript-promise-type",
    "thumbnail": {
      "local": "/static/awaited-type-0276d208.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-awaited-type-0276d208-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAICAIAAABVpBlvAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAaUlEQVR4nEXMOxFFMQiEYWxESNrU0UNPHxf0CIgABCBgBWAAAefO5J7H1+7sTwCYOTOvB0WEiJiZuwPITKoqM8ORB805W2tjjP8QEQRAVd39a621eu8isvf2gzJTVSOiqu5WVTEzgPf4A0ksbgsie9k/AAAAAElFTkSuQmCC"
    }
  },
  {
    "slug": "typescript-void-function-return",
    "title": "TS 탐구생활 - void 함수의 리턴에 대하여",
    "date": "2023-09-22T00:00:00Z",
    "description": "TS는 void 리턴타입 함수에서 리턴하는 것을 막지 않는다. 왜?",
    "tags": [
      "typescript"
    ],
    "html": "<blockquote>\n<p>TypeScript의 타입 시스템은 JavaScript의 런타임 동작을 모델링하는 타입 시스템을 갖고 있다.</p>\n<p>Pozafly님의 블로그 글 <a href=\"https://pozafly.github.io/typescript/why-can-typescript-return-any-value-using-void/\">https://pozafly.github.io/typescript/why-can-typescript-return-any-value-using-void/</a></p>\n</blockquote>\n<p><a href=\"https://pozafly.github.io/typescript/why-can-typescript-return-any-value-using-void/\">pozafly님의 왜 TypeScript는 void 타입을 사용해도 값을 return 할 수 있을까?</a>를 보고 이해한 대로 간단히 요약하였습니다.</p>\n<h1>1. 시작</h1>\n<p>타입스크립트의 묘한 동작은 여러 가지가 있는데 여기서는 그 중 void 리턴 타입에 대한 동작에 대해 알아보려고 한다.</p>\n<p><a href=\"https://search.shopping.naver.com/book/catalog/41736307631?cat_id=50010881&#x26;frm=PBOKMOD&#x26;query=%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8+%EA%B5%90%EA%B3%BC%EC%84%9C&#x26;NaPm=ct%3Dlmuda1cg%7Cci%3Dadc8d2352090d77aaa594ba99a7f726152a4dc12%7Ctr%3Dboknx%7Csn%3D95694%7Chk%3D73d6a40144625374c787e06c0d9d7bdfd7647e8d\">조현영 님의 책인 타입스크립트 교과서</a>에 예시가 있다.</p>\n<p>함수의 리턴 타입을 void로 정의했는데 해당 함수에서 값을 리턴할 시 에러가 발생한다.</p>\n<pre><code class=\"language-ts\">const foo = ():void=>3; // Error : Type 'number' is not assignable to type 'void'\n</code></pre>\n<p>하지만 어떤 함수가 void를 리턴하는 함수 타입으로 정의되었을 경우 해당 함수에서 값을 리턴해도 에러가 발생하지 않는다.</p>\n<pre><code class=\"language-ts\">const foo:()=>void = ()=>3;\n</code></pre>\n<p>이런 동작은 왜 발생하는 걸까? 이 2가지 동작은 결국 TS가 JS의 런타임 동작을 타입으로 모델링하는 것을 목표로 하기 때문에 생기는 예시이다. 더 자세히 한번 알아보자.</p>\n<h1>2. void란?</h1>\n<blockquote>\n<p>void는 값을 반환하지 않는 함수의 반환 값을 의미한다. 함수에 return문이 없거나, 명시적으로 값을 반환하지 않을 때, 추론되는 타입이다.</p>\n<p><a href=\"https://www.typescriptlang.org/ko/docs/handbook/2/functions.html#void\">타입스크립트 공식 문서</a></p>\n</blockquote>\n<p>예를 들어서 다음 함수들의 리턴타입이 void로 추론된다.</p>\n<pre><code class=\"language-ts\">function foo(){\n  return;\n}\n\nfunction foo2(){\n  console.log('foo2');\n}\n</code></pre>\n<p>물론 위 함수들은 JS 문법상 실제로는 undefined를 반환한다. 하지만 위의 TS 공식 문서 정의에 따라 해당 함수들의 타입은 <code>()=>void</code>로 추론되게 된다.</p>\n<p>물론 이것이 <code>()=>void</code>가 <code>()=>undefined</code>와 같다는 뜻은 아니다.</p>\n<p>JS에서 명시적인 리턴이 없는 함수도 무조건 undefined를 리턴하도록 하기 때문에 이를 수용하기 위해서 <code>()=>void</code>타입 함수라도 undefined 리턴을 허용할 뿐이다.</p>\n<pre><code class=\"language-ts\">// ()=>undefined로 추론됨\nfunction foo(){\n  return undefined;\n}\n\nfunction bar():void{\n    return undefined;\n}\n</code></pre>\n<pre><code>tsconfig.json의 strictNullChecks 옵션을 false로 주면 void 리턴타입 함수의 리턴 값으로 undefined 뿐 아니라 null도 허용한다.\n</code></pre>\n<h1>3. void 리턴타입의 리턴 허용</h1>\n<p>그런데 우리가 위에서 보았듯이 void 리턴 함수 타입인 <code>()=>void</code>로 정의된 함수에서 다른 값을 리턴할 수도 있다. 다음과 같은 코드에서 에러가 뜨지 않는 것을 우리는 이미 보았다.</p>\n<pre><code class=\"language-ts\">const foo:()=>void = ()=>3;\n</code></pre>\n<p>사실 void 리턴 타입은 함수가 명시적으로 반환을 하지 않을 것을 강제하는 것이 아니다!</p>\n<blockquote>\n<p><code>void</code> 반환 타입으로의 문맥적 타이핑은 함수를 아무것도 반환하지 않도록 강제하지 않습니다.이를 설명하는 또 다른 방법은, <code>void</code> 반환 타입을 가지는 문맥적 함수 타입(<code>type vf = () => void</code>)가 구현되었을 때, 아무값이나 반환될 수 있지만, 무시됩니다.</p>\n<p><a href=\"https://www.typescriptlang.org/ko/docs/handbook/2/functions.html#%ED%95%A8%EC%88%98%EC%9D%98-%ED%95%A0%EB%8B%B9%EA%B0%80%EB%8A%A5%EC%84%B1\">TS 공식 문서 - 함수의 할당 가능성</a></p>\n</blockquote>\n<p>즉 어떤 값이든 반환될 수 있지만 이는 무시된다는 것이다. 예를 들어 다음과 같은 코드에서 <code>test</code>함수의 반환값은 void로 추론되어 무시되기 때문에 사실상 아무것도 할 수 없게 된다. 물론 타입 단언을 통해 이를 해결할 수는 있지만 권장되지 않는다.</p>\n<pre><code class=\"language-ts\">type VoidReturnFunc=()=>void;\n\nconst test:VoidReturnFunc=()=>3;\nconst n=test()+1; // Operator '+' cannot be applied to types 'void' and 'number'\n\n// 이렇게 타입 단언을 통해 어떻게든 할 수 있기는 하다.\nconst n=(test() as unknown as number)+1; \n</code></pre>\n<p>메서드에서도 이는 마찬가지다. <code>void</code>를 명시적으로 리턴타입으로 지정할 시 메서드에서는 undefined를 제외하고 명시적인 반환을 할 수 없지만 <code>void</code>를 리턴타입으로 추론할 시 명시적인 반환을 할 수 있다.</p>\n<pre><code class=\"language-ts\">type Person={\n  greeting:()=>void;\n}\n\nconst person:Person={\n  // void를 리턴하는 함수 타입의 함수에서는 반환을 할 수 있다.\n  greeting(){\n      return \"Hi\";\n  }\n}\n\nconst person2={\n  // Type 'string' is not assignable to type 'void'.\n  greeting():void{\n      return \"Hi\";\n  }\n}\n</code></pre>\n<p><a href=\"https://pozafly.github.io/typescript/why-can-typescript-return-any-value-using-void/#void%EC%9D%98-2%EA%B0%80%EC%A7%80-%ED%98%95%ED%83%9C\">이를 정리해 보면 다음과 같다.</a></p>\n<ol>\n<li>함수 자체에 리턴 타입으로 붙어 있는 void값(<code>:void</code>와 같은)은 리턴값이 존재하면 안된다.</li>\n<li>함수 타입에 리턴값으로 붙어 있거나(<code>()=>void</code> 타입) 선언과 할당이 따로 나뉘어 있는 void값은 값이 존재할 수 있다. 다만 무시된다.</li>\n</ol>\n<p>즉 <code>void를 리턴하는 함수 타입(()=>void 타입)</code>의 함수는 어떤 값이든 반환해도 되고, <code>함수의 리턴 타입이 void</code>이면 undefind 외에는 명시적 반환이 불가능하다. 그럼 왜 void는 이런 동작을 하게 되었을까?</p>\n<h1>4. 이런 동작의 이유</h1>\n<p>TS가 이런 동작을 허용하는 이유는 앞서 말했듯이 JS의 런타임 동작을 모델링하기 위해서이다.</p>\n<p>JS에서는 콜백 함수를 인수로 받는 메서드들이 몇 개 있다. <code>Array.prototype.forEach</code> 같은 함수들이 그 예시이다.</p>\n<pre><code class=\"language-ts\">const arr=[1,2,3];\n\narr.forEach((v,i)=>{\n  console.log(i,v);\n});\n</code></pre>\n<p>이 메서드들은 콜백으로 받는 함수의 리턴값을 전혀 사용하지 않는다. console.log의 리턴은 undefined이기는 하지만 만약 다른 값을 리턴한다고 해도 전혀 사용되지 않는다. 따라서 이런 메서드들은 콜백 함수의 리턴 타입을 void로 정의해야 하고 실제로도 그렇게 정의되어 있다.</p>\n<pre><code class=\"language-ts\">Array&#x3C;T>.forEach(callbackfn: (value: T, index: number, array: T[]) => void, thisArg?: any): void\n</code></pre>\n<p>그런데 만약 void를 리턴하는 함수 타입이 함수의 반환을 금지한다면 어떨까? 다음 코드를 보자.</p>\n<pre><code class=\"language-ts\">const arr:Array&#x3C;number>=[1,2,3];\nconst res:Array&#x3C;number>=[];\n\n// res.push는 배열의 길이 즉 number 타입을 리턴하지만 전혀 사용되지 않음\narr.forEach(elem=>res.push(elem));\n</code></pre>\n<p>위와 같은 코드는 안티패턴도 아니고 <code>elem=>{ res.push(elem) }</code>와 같이 쓰는 것보다 간결하기 때문에 많이 보이는 방식이다.</p>\n<p>하지만 만약 void를 리턴하는 함수 타입이 함수의 명시적 반환(undefined 제외)을 금지한다면 이 코드는 에러가 발생하게 된다. 왜냐하면 <code>res.push</code>는 number를 리턴하기 때문이다.</p>\n<p>이런 이유로 TS는 void를 반환하는 함수 타입에 대해 반환값을 허용한다.</p>\n<h1>참고</h1>\n<p>왜 TypeScript는 void 타입을 사용해도 값을 return 할 수 있을까? <a href=\"https://pozafly.github.io/typescript/why-can-typescript-return-any-value-using-void/\">https://pozafly.github.io/typescript/why-can-typescript-return-any-value-using-void/</a></p>\n<p>타입스크립트 공식 문서, void <a href=\"https://www.typescriptlang.org/ko/docs/handbook/2/functions.html#void\">https://www.typescriptlang.org/ko/docs/handbook/2/functions.html#void</a></p>\n<p>타입스크립트 공식 문서, 함수의 할당 가능성\n<a href=\"https://www.typescriptlang.org/ko/docs/handbook/2/functions.html#%ED%95%A8%EC%88%98%EC%9D%98-%ED%95%A0%EB%8B%B9%EA%B0%80%EB%8A%A5%EC%84%B1\">https://www.typescriptlang.org/ko/docs/handbook/2/functions.html#%ED%95%A8%EC%88%98%EC%9D%98-%ED%95%A0%EB%8B%B9%EA%B0%80%EB%8A%A5%EC%84%B1</a></p>\n<p>공변성이란 무엇인가 <a href=\"https://seob.dev/posts/%EA%B3%B5%EB%B3%80%EC%84%B1%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\">https://seob.dev/posts/%EA%B3%B5%EB%B3%80%EC%84%B1%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80</a></p>\n<p>우연히 보게 된 공변성에 관한 트위터 스레드 <a href=\"https://twitter.com/_a6g_/status/1678987111893200896\">https://twitter.com/_a6g_/status/1678987111893200896</a></p>",
    "excerpt": "\nTypeScript의 타입 시스템은 JavaScript의 런타임 동작을 모델링하는 타입 시스템을 갖고 있다.\nPozafly님의 블로그 글 https://pozafly.github.io/typescript/why-can-typescript-return-any-value-using-void/\n\npozafly님의 왜 TypeScript는 void 타입을 사용해도 값을 return 할 수 있을까?를 보고 이해한 대로 간단히 요약하였습니다.\n1. 시작\n타입스크립트의 묘",
    "headingTree": [
      {
        "title": "1. 시작",
        "url": "#1-시작",
        "items": []
      },
      {
        "title": "2. void란?",
        "url": "#2-void란",
        "items": []
      },
      {
        "title": "3. void 리턴타입의 리턴 허용",
        "url": "#3-void-리턴타입의-리턴-허용",
        "items": []
      },
      {
        "title": "4. 이런 동작의 이유",
        "url": "#4-이런-동작의-이유",
        "items": []
      },
      {
        "title": "참고",
        "url": "#참고",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 303
    },
    "url": "/posts/typescript-void-function-return",
    "thumbnail": {
      "local": "/thumbnails/typescript-void-function-return-index-md-thumbnail.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-thumbnails-typescript-void-function-return-index-md-thumbnail-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAfElEQVR4nFXJoQlEIRgAYAcQ3ML2d0ewuIbV6ComQTQcgslFDpPhOA+bILiA4IN36X31QyklIYRSijGmtXbOSSnnnEhrDQCcc4wxpRQACCEhBBRjNMb03t+3ehtjoFKKtXbOeZ7Q59ta+7XW1lqPeMXkvc8511rPOXvvf1wPvmZBtp2aFgAAAABJRU5ErkJggg=="
    }
  },
  {
    "slug": "web-basic-study-1",
    "title": "웹 배포 스터디 - 1. git 사용법",
    "date": "2021-11-12T00:00:00Z",
    "description": "스터디를 진행할 도구인 git 설명",
    "tags": [
      "web",
      "study",
      "git"
    ],
    "html": "<h1>1. 스터디에서 git의 사용</h1>\n<p>웹의 첫걸음을 떼기 위해 프론트(React), 백(Express) 작업 그리고 배포까지의 과정을 엉성하게나마 한번 끝까지 해 보기 위한 스터디를 만들었다. 이런 스터디는 각자에게 공부를 강제하는 구속구 역할만 잘 해줘도 중박은 친다고 생각한다.</p>\n<p>그런데 어쨌거나 다른 사람들과 함께 모여서 스터디를 하는 것이므로, 혼자 하는 것보다 좋은 점이 있다면, 더 배우는 점이 있다면 좋을 것이다. 나는 스터디장으로서 그것을 위한 여러 가지 장치를 만들어 보았다. 그 중 하나가 남의 코드를 읽고 남이 코드를 짜면서 한 생각을 배울 기회를 제공하는 것이다.</p>\n<p>그런데 다른 사람과 코드를 어떻게 공유할 것인가? 카톡으로 파일 보내기를 할 수도 있다. 그러나 우리는 개발의 길을 걷는다면 꼭 다뤄봐야 할 툴이며 숙련되면 카톡 보내기보다 더 간편해질(나는 그러리라고 믿고 있다) git을 쓰도록 할 것이다. git에 대한 자료는 인터넷에 아주 많고 나를 포함한 모두가 계속 구글링을 하면서 더 배워야겠지만, 여기서는 일단 스터디에 필요한 부분만 간단하게 다룰 것이다.</p>\n<h1>2. git의 기본</h1>\n<p>git은 코드를 관리할 수 있는 도구이다. 우리가 어떤 부분을 수정했는지도 추적할 수 있고, 코드에 대한 백업도 제공하고 있다. 그 외에도 협업을 위한 기능 등 수많은 편의기능들을 제공한다.</p>\n<p>먼저 이 사이트에 나와 있는 과정을 따라하면서 git 설치를 진행해 보자. 기본적인 기능들에 대한 설명도 있다.</p>\n<p><a href=\"https://goddaehee.tistory.com/216?category=381481\">https://goddaehee.tistory.com/216?category=381481</a></p>\n<p><a href=\"https://goddaehee.tistory.com/217?category=381481\">https://goddaehee.tistory.com/217?category=381481</a></p>\n<p>git을 설치했다면, 이제 스터디에서 진행할 코드 공유 방법을 설명한다. 이 글을 많이 참고했다.</p>\n<p><a href=\"https://gmlwjd9405.github.io/2017/10/28/how-to-collaborate-on-GitHub-2.html\">https://gmlwjd9405.github.io/2017/10/28/how-to-collaborate-on-GitHub-2.html</a></p>\n<p>먼저 my-own-web 조직에 있는 web-basic 레포지토리를 각자의 원격 저장소에 fork한다.</p>\n<p><img src=\"/static/fork-98d37bcd.png\" alt=\"fork\"></p>\n<p>이제 각자의 git 계정의 원격 저장소마다 우리의 스터디 레포지토리의 복제품이 하나씩 들어가 있을 것이다. 그러면 이제 그것을 각자의 로컬 저장소(컴퓨터의 저장공간)에 가져오자.</p>\n<p>먼저 레포지토리를 담을 적당한 폴더를 원하는 위치에 만든다. 가령 <code>web-study</code> 같은 이름의 폴더를 만드는 것이다. 그리고 그 폴더 내부에서 git bash를 열고 다음과 같은 명령을 한다.</p>\n<pre><code>git init\n</code></pre>\n<p>그리고 자신의 계정 저장소에 fork된 레포지토리를 로컬 저장소에 불러올 것이다. 가령 나는 <code>witch-factory/web-basic</code> 이라는 저장소가 있다. 이를 불러오겠다. 각자의 github 계정의 web-basic 저장소에 들어가게 되면 초록색으로 code 라고 쓰인 버튼이 있을 것이다. 그걸 눌러서 ssh 항목을 선택하고 아래 나오는 주소를 복사한다.</p>\n<p><img src=\"/static/ssh-8a5f49c4.png\" alt=\"ssh\"></p>\n<p>그리고 이를 아까 만든 폴더의 원격 저장소에 추가하자. 우리가 <code>git init</code>을 했던 저장소에 다시 들어가 터미널을 열고 다음 명령을 실행한다.</p>\n<pre><code>git remote add origin 아까 복사한 주소\n</code></pre>\n<p>나 같은 경우에는 다음과 같은 명령이었다.</p>\n<pre><code>git remote add origin git@github.com:witch-factory/web-basic.git\n</code></pre>\n<p>그리고 나서 원격 저장소의 내용을 로컬 저장소로 끌어오자(pull)</p>\n<pre><code>git pull origin main\n</code></pre>\n<p><span style=\"color:red\">이때 주의해야 할 점은 우리가 organization에서 만든 web-basic 레포지토리가 아니라 각자의 저장소에 fork한 레포지토리에서 이 작업을 진행해야 한다는 것이다.</span>.</p>\n<p><code>git clone</code>으로도 이 작업을 똑같이 할 수 있지만, 연결된 원격 저장소에 origin이라는 이름을 주는 것을 명시적으로 보여줄 수 있다고 생각해서 이렇게 했다. 만약 원격 저장소가 로컬에 잘 저장되어 있는지 궁금하다면 <code>git remote -v</code> 커맨드로 현재 로컬 저장소에 연결된 원격 저장소들을 볼 수 있다.</p>\n<p>그리고 우리가 이렇게 git으로 연결한 저장소에서 어떤 작업을 진행했다고 하자. 나는 create-react-app을 이용해서 내 이름의 react 작업 폴더를 만들었다.</p>\n<pre><code>npx create-react-app sunghyun\n</code></pre>\n<p>그러면 로컬 저장소에 sunghyun이라는 폴더가 생성된다. 나는 react 작업을 하기 위해서 이렇게 한 것 뿐이고, 중요한 것은 저장소에 어떤 변경 사항이 생겼다는 것이다. 내가 텍스트 파일을 하나 만들었더라도 마찬가지고 기존의 무언가를 삭제했더라도 마찬가지다.</p>\n<p><code>git status</code> 명령으로 저장소의 변경 사항을 확인할 수 있다. 나는 <code>sunghyun</code> 폴더가 새로 생겼으며 git에 의해 추적되지 않고 있는 상태라고 뜬다.</p>\n<p>이를 git에 의해 추적되도록 해주자.</p>\n<pre><code>git add .\n</code></pre>\n<p>위 명령으로 git에 의해 추적되지 않는 파일을 모두 추적되도록 할 수 있다. 그리고 변경 사항을 커밋한다.</p>\n<pre><code>git commit -m \"커밋 메시지\"\n</code></pre>\n<p>그리고 이 변경 사항을 실제 원격 저장소에 반영한다. 커밋 상태까지는 이 변경 사항이 어디에 반영될지 아직 정해지지 않은 상태이기 때문이다.</p>\n<pre><code>git push origin main\n</code></pre>\n<p>만약 뭔가 오류가 뜬다면 <code>git branch</code> 명령어로 현재 저장소가 어떤 브랜치에 의해서 추적되고 있는지를 알 수 있다. 그때 브랜치가 <code>master</code> 같은 이름으로 떠 있을 수 있는데, 그럴 때는</p>\n<pre><code>git branch -m main\n</code></pre>\n<p>이라는 커맨드로, 현재의 변경 사항이 main 브랜치에 따라가도록 할 수 있다. 그렇게 한 이후 <code>git add .</code> 부터 다시 진행하면 된다.</p>\n<p><a href=\"https://velog.io/@kimiszero/github-src-refspec-master-does-not-match-any-%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95\">https://velog.io/@kimiszero/github-src-refspec-master-does-not-match-any-%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95</a></p>\n<p>이런 브랜치를 좀 더 잘 다루고 싶다면, <code>git checkout</code>, <code>git merge</code> 등의 명령들을 사용하여 작업별로 브랜치를 나눠서 작업하는 방법도 있다.</p>\n<p><a href=\"https://backlog.com/git-tutorial/kr/stepup/stepup2_4.html\">https://backlog.com/git-tutorial/kr/stepup/stepup2_4.html</a></p>\n<p>다만 지금 당장은 필요 없다고 생각된다. 어차피 PR만 날리면 되므로.</p>\n<p>이렇게 자신만의 원격 저장소에 자신의 로컬 저장소 내용을 푸시하고 나서 github.com에 들어가 자신의 원격 저장소에 들어간다. 그러면 <code>This branch is 1 commit ahead of my-own-web:main.</code> 과 같은, 무언가 중앙 저장소(우리의 my-own-web 레포지토리)에 비해 나의 원격 저장소에 변경사항이 있다는 것을 알려주는 메시지가 뜬다.</p>\n<p>그럼 그 옆에 contribute라는 항목이 있다. 내가 내 원격 저장소에서 변경한 사안을 중앙 저장소에 기여하겠냐는 뜻이다. 그 옆에 Fetch upstream 항목은 중앙 저장소에서 변경된 내용을 내가 내 원격 저장소로 가져오겠냐는 뜻인데 아직 우리가 할 필요는 없다.</p>\n<p>어쨌든 contribute 항목을 눌러 <code>open pull request</code> 를 선택한다.</p>\n<p><img src=\"/static/pr-c37f5d78.png\" alt=\"pr\"></p>\n<p>그리고 pull request를 할 때 중앙 저장소의 사람들에게 보여줄 메시지를 작성한 후 create pull request를 누른다.</p>\n<p>우리가 한 작업은 다음과 같다.</p>\n<ol>\n<li>\n<p>중앙 저장소를 나의 계정 고유의 레포지토리에 본을 뜬다.</p>\n</li>\n<li>\n<p>나의 계정에 본따진 레포지토리를 내 로컬 저장소에 가져온다.</p>\n</li>\n<li>\n<p>로컬 저장소에서 작업을 한다.</p>\n</li>\n<li>\n<p>로컬 저장소에서 작업한 내용을 내 계정의 레포지토리에 반영한다.</p>\n</li>\n<li>\n<p>내 계정의 레포지토리에 반영된 변경 사항을 중앙 저장소에 반영되기를 요청한다.</p>\n</li>\n</ol>\n<p>그러면 이제 다른 사람들이 그 pull request를 보고 내가 변경한 사항이 무엇인지 등을 확인하고 코멘트를 달아줄 수 있다. 오른쪽에는 작게 reviewers 항목이 있는데 거기서 다른 사람들에게 리뷰를 요청할 수도 있다.</p>\n<p><img src=\"/static/review-c1d6f9df.png\" alt=\"review\"></p>\n<p>이때 각자의 아이디를 누르면 그 사람에게 내 pull request에 대한 리뷰를 요청하는 메일이 간다.</p>\n<p>그리고 내가 변경한 사항이 만약 중앙 저장소와 충돌되는 부분이 없다면 그대로 중앙 저장소에 내 변경 사항을 반영시킬 수 있다. 초록색의 <code>merge pull request</code> 버튼이 그것이다. 우리는 각자의 폴더를 만들어서 작업할 것이기 때문에 작업 내용이 겹칠 일은 웬만해선 없을 것이다. <span style=\"color:red\">하지만 아직 merge를 하지는 말자...혹시 돌발 상황이 발생할 수도 있으므로 merge는 다 모였을 때 한번에 할 것이다.</span></p>\n<p>그리고 스터디에서 각자가 지정된 사람의 작업 내용에 대해 리뷰를 하기로 했는데, 그 리뷰도 위에서 한 것과 같이 PR에 comment를 남기는 방식으로 진행하게 될 것이다.</p>",
    "excerpt": "1. 스터디에서 git의 사용\n웹의 첫걸음을 떼기 위해 프론트(React), 백(Express) 작업 그리고 배포까지의 과정을 엉성하게나마 한번 끝까지 해 보기 위한 스터디를 만들었다. 이런 스터디는 각자에게 공부를 강제하는 구속구 역할만 잘 해줘도 중박은 친다고 생각한다.\n그런데 어쨌거나 다른 사람들과 함께 모여서 스터디를 하는 것이므로, 혼자 하는 것보다 좋은 점이 있다면, 더 배우는 점이 있다면 좋을 것이다. 나는 스터디장으로서 그것을 위한 여러 가지 장치",
    "headingTree": [
      {
        "title": "1. 스터디에서 git의 사용",
        "url": "#1-스터디에서-git의-사용",
        "items": []
      },
      {
        "title": "2. git의 기본",
        "url": "#2-git의-기본",
        "items": []
      }
    ],
    "metadata": {
      "readingTime": 1,
      "wordCount": 197
    },
    "url": "/posts/web-basic-study-1",
    "thumbnail": {
      "local": "/static/fork-98d37bcd.png",
      "cloudinary": "https://res.cloudinary.com/desigzbvj/image/upload/c_scale,w_300,f_auto/blog/thumbnails/-static-fork-98d37bcd-png",
      "blurURL": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAGCAIAAABxZ0isAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAoUlEQVR4nAGWAGn/ABwiJgsSGg4SGBsfIx0gJRMXGwcHDiQdIAD7+/v////+///////r9O/m8un////r6uoA1dnb5eXm3d7f6Onr2d/ezdTR8vLz4uPjAOPn6e7u8OTl6PP09vDw8+bn6fX2+Ozs7QDy8O/29PP////////////7+/v9/f37+/sAtsbPrb7HucjRvs3Wwc7Yo7C8n6eyucDMaKxuPJ+twpkAAAAASUVORK5CYII="
    }
  }
]