---
title: JS 탐구생활 - 세미콜론 자동 삽입
date: "2024-08-22T01:00:00Z"
description: "JS는 코드에 세미콜론을 자동으로 넣어준다. 그 규칙을 알아보자."
tags: ["javascript"]
---

(2022.12.16 첫 작성)

(2024.08.23 업데이트)

# 이 글은 업데이트 중입니다.

# 1. 시작 - 세미콜론을 삽입하자

JS에서는 줄바꿈이 일어나는 부분에 대해 대부분의 경우 세미콜론을 자동으로 삽입해 준다. 하지만 그렇지 않은 경우가 몇 가지 있고 만약 세미콜론을 명시적으로 삽입하지 않았을 경우 원하지 않는 동작이 일어날 수 있다. 따라서 세미콜론을 명시적으로 삽입해 주는 것이 권장된다.

하지만 규칙을 말하기 전에, 세미콜론 자동 삽입이 어떤 규칙에 따라 일어나며 어떻게 문제가 될 수 있는지 알아보자.

[이 글](https://ko.javascript.info/structure)에서는 먼저 다음과 같은 예시를 든다.

```js
alert(3 + 
1
+ 2);
```

직관적으로 3+1+2 가 하나의 표현식으로 해석되는 게 맞기 때문에 이렇게 동작한다는 것을 느낄 수 있다. 그러나 다음과 같은 경우는 어떨까? 이 역시 위 글에서 든 예시이다.

```js
alert("에러가 발생합니다.")

[1, 2].forEach(alert)
```

새롭게 추가한 alert만 잘 실행되고 그 뒤에 에러가 발생한다. 이는 js가 대괄호 앞에는 세미콜론을 자동 삽입하지 않기 때문이다. 그래서 위 코드는 다음과 같이 해석된다.

```js
alert("에러가 발생합니다.")[1, 2].forEach(alert)
```
이렇게 변환해 보니 에러가 발생하는 게 당연한 코드가 되었다.

그럼 대체 세미콜론 자동삽입이라는 게 어떤 규칙을 따르는 것이길래 이런 일이 일어나는지 알아보자.

# 2. 기본 규칙

몇몇 종류의 JS statement들은 세미콜론으로 끝나야 한다. 이들은 다음과 같다.

- 빈 statement
- let, const, var statement
- import, export statement, 모듈 선언
- expression statement
- debugger
- continue, break, throw, return

따라서 위의 종류들은 자동 세미콜론 삽입에 영향을 받게 된다. 이때 좀 낯선 것 2개가 있어서 간단히 설명하였다.

# 3. statement 설명

## 3.1. 빈 statement

말 그대로 아무것도 하지 않는 statement이다. 이는 세미콜론으로 끝나야 한다.

```js
;
```

예를 들어서 for문의 body에 쓸 수 있다. for문이 시행하는 반복 그 자체가 중요한 경우이다.

```js
let arr=[1,2,3,4,5];
for(let i=0;i<arr.length;arr[i]=0,i++);
```

위와 같이 한 경우 for문의 body는 빈 statement가 된다. 단 이를 일부러 사용할 경우 실수를 유발할 수 있으므로 주석을 꼭 달아주자.

```js
if(something);
  func(); //if문이 빈 statement로 해석되었으므로 func는 무조건 실행된다
```

## 3.2. expression statement

단순히 어떤 표현으로 이루어지는 statement이다. 이 표현은 평가되고 그 결과는 버려진다. 간단하게는 다음과 같은 것을 들 수 있다. 

```js
1+2;
```

변수에 값을 할당하는 할당 연산자도 연산자기 때문에 할당문도 하나의 expression이다. 이런 식으로 side effect가 있는 expression이 사용된다.

```js
a=3; //이는 3으로 평가되지만 결과는 버려진다
```

본격적으로 자동 세미콜론 삽입 규칙을 알아보자. ECMAScript 명세 그리고 "이펙티브 자바스크립트"에서 풀어서 쓴 설명을 참고하였다.

# 4. 첫번째 규칙

## 4.1. 첫번째 규칙 내용

> 세미콜론은 다음 입력 토큰을 파싱할 수 없을 때에만 삽입된다.
>
> "이펙티브 자바스크립트" p. 27

코드가 왼쪽에서 오른쪽으로 파싱되는 중에 문법에 의해 허용되지 않는 토큰(이를 offending token이라 한다)이 나올 때가 있다. 이때 다음 조건 중 하나 이상이 만족되면 해당 토큰 앞에 세미콜론을 삽입한다.

- offending token이 이전 토큰과 line terminator(라인 피드, 캐리지 리턴, 줄 구분 기호, 단락 구분 기호, 캐리지리턴+라인피드)로 구분되어 있을 때
- offending token이 }일 때
- 이전 토큰이 )이고 삽입된 세미콜론이 do-while문을 끝내는 세미콜론이 될 때

예를 들어서 `{1 2} 3`에서 `}`이 파싱되면서 문법적으로 맞지 않으므로, offending token인 `}` 이전에 세미콜론을 삽입한다. 따라서 `{1 2;} 3`으로 해석된다.

즉 세미콜론은 문법적으로 맞지 않은 토큰이 나왔을 때 보정해 주는 역할을 한다고 할 수 있다. 예를 들어 이런 코드가 있다고 하자.

```js
a=b
func()
```

이 코드를 만약 `a=b func()`과 같이 파싱한다면 오류가 날 것이다. 따라서 세미콜론이 삽입되어 `a=b; func()`로 해석된다.

## 4.2. 주의점

이렇게 오류를 보정해 주는 첫번째 규칙이지만, 반대로 오류의 원인이 되기도 한다. 예를 들어 함수가 즉시 실행 함수 표현식과 같은 것이라 괄호로 싸여 있었다고 해보자.

```js
a=b
(function(){console.log('hello')})()
```

이 코드는 `a=b(function(){console.log('hello')})()`로 해석될 수 있다. 만약 `b`가 함수라면 제대로 실행될 코드일 수도 있다. 이렇게 하나의 선언으로 잘 실행될 수도 있기에 중간에 세미콜론은 삽입되지 않는다.

따라서 다음 줄의 첫 토큰이 이전 코드의 연장선으로 해석될 수 있다면 세미콜론을 생략해서는 안된다.

"이펙티브 자바스크립트"에 의하면 `(`, `[`, `+`, `-`, `/` 이렇게 5개의 문자를 조심해야 한다. 문맥에 따라 연산자 혹은 접두사로 해석될 수 있기 때문이다.

방금 본 것과 같이 괄호로 시작되는 선언 이외에, `[`의 예시로 배열에 관한 예시도 있다. 이런 코드를 들 수 있다.

```js
func()
['ul', 'ol'].forEach(function(tag){ handleTag(tag) });
```

2행의 대괄호는 `func()`의 결과를 인덱싱하는 걸로, 대괄호 내의 쉼표는 쉼표 연산자로 해석된다. 따라서 다음 코드는 자동 세미콜론 삽입이 일어나지 않고, 의도치 않게 이렇게 해석된다.

```js
func()['ol'].forEach(function(tag){ handleTag(tag) });
```

`+`, `-`, `/`는 선언문 처음에 나타나는 경우는 많지 않지만 `/`같은 경우 정규 표현식 리터럴에 사용되기 때문에 주의해야 한다. 예를 들어 이런 코드를 보자.

```js
a = b
/hi/g.exec('hi');
```

이 코드는 `a=b/hi/g.exec('hi')`로 해석될 수 있다. 정규 표현식의 `/`가 나눗셈 연산자로 파싱되는 것이다. 따라서 세미콜론이 삽입되지 않고 당연히 의도대로 동작하지 않거나 에러가 발생한다.

즉 세미콜론을 생략하기 전에는 다음 줄의 첫 문자를 잘 살펴봐야 한다. 예를 들어 다음의 프로그램은 3개의 세미콜론이 삽입되어 잘 동작한다.

```js
a = b
var x
(f())
```

하지만 이 순서가 바뀌면 세미콜론이 삽입되지 않아 오류가 발생한다.

```js
a = b // 여기에 제대로 세미콜론이 삽입되지 않는다
(f())
var x
```

이런 문제는 간단한 코드에서만 발생하는 것이 아니다. 스크립트 병합에서도 문제를 일으킬 수 있다. 이전에 모듈 시스템이 정식으로 없던 시절에는 스크립트 병합 시 각 파일이 서로에게 영향을 받지 않도록 즉시 실행 함수 표현식으로 각 파일을 감싸는 게 추천되었다. 따라서 이런 코드들이 있을 수 있다.

```js
//file1.js
(function(){
  //code
})();

//file2.js
(function(){
  //code 2
})();
```

이때 파일들이 하나로 병합되어 실행된다면 다음과 같이 처리되어서 문제가 발생할 수 있다.

```js
(function(){
  //code
})()(function(){
  //code 2
})();
```

따라서 세미콜론 생략 시 다음 줄, 그리고 스크립트 병합으로 인해 따라올 수 있는 다른 토큰들도 고려해야 한다. 첫 토큰이 앞서 언급한 `(`, `[`, `+`, `-`, `/` 중 하나라면 모든 파일의 시작에 세미콜론을 삽입하는 것도 방법일 수 있다. 스크립트 병합 도구에서 잘 해주면 좋겠지만 모든 병합 도구가 잘 짜인 것은 아니기 때문이라고 한다.(by "이펙티브 자바스크립트")

```js
// file.js
;(function(){
  //code
})();
```

# 5. 두번째 규칙

## 5.1. 두번째 규칙 내용

> 세미콜론은 한 줄 이상의 새로운 행이나 프로그램 입력의 마지막이나 `}` 토큰 전에만 삽입된다.
>
> "이펙티브 자바스크립트" p. 26

토큰들을 왼쪽에서 오른쪽으로 파싱하다가, 토큰들의 스트림이 끝났고 파서가 토큰 스트림을 하나의 완전한 프로그램으로 파싱할 수 없다면 입력 스트림의 끝에 세미콜론을 삽입한다.

예를 들어서 다음과 같은 프로그램을 보자.

```js
let a=1
++a
```

그러면 파서는 먼저 `let a=1` 뒤에 세미콜론을 삽입한다. `++`와 `1`사이에 줄바꿈 문자, 즉 line terminator가 있기 때문이다. 

그리고 `++a`를 파싱하면서 스트림이 끝나고 이는 완벽한 프로그램이 아니므로 자동으로 끝에 세미콜론을 삽입한다.

즉 자동 세미콜론 삽입의 결과는 다음과 같다.

```js
let a=1;
++a;
```

이 규칙에 따라, 세미콜론을 생략하려면 줄의 마지막 부분, 블록의 마지막 부분, 프로그램의 마지막 부분에만 세미콜론을 생략할 수 있다.

다음과 같은 경우 당연히 자동 세미콜론 삽입이 제대로 되지 않아 오류가 발생한다.

```js
// Uncaught SyntaxError: Unexpected token 'return'
function area(r) {
  r=Number(r) return Math.PI * r * r;
}
```


# 6. 세번째 규칙

## 6.1. 세번째 규칙 내용

> 자바스크립트는 파싱 오류로 판명되지 않더라도 강제적으로 세미콜론을 삽입하는 경우가 있다. 이것들은 소위 자바스크립트 문법의 제한된 생성(restricted production)이라고 부르는데, 두 토큰 사이에 새로운 행이 허용되지 않는다는 의미다.
>
> "이펙티브 자바스크립트" p. 31

이는 특정한 키워드와 부가적인 인자 사이에 새로운 행이 포함되지 않아야 하며, 해당 키워드 뒤에 line terminator가 나오면 자동으로 그 뒤에 세미콜론이 삽입된다는 의미이다. 이에 해당하는 키워드들은 다음과 같다. 이 키워드들 뒤에 줄바꿈이 오면 세미콜론이 삽입된다.

- 명시적인 라벨이 붙은 break, continue
- return
- throw
- yield, yield*
- module
- postfix expression(++, --)

대표적으로 `return`과 부가적인 인자 사이에는 새로운 행이 포함되면 제대로 동작하지 않는다.

```js
return
a+b
```

세번째 규칙에 따라 위 코드는 다음과 같이 변환된다. return 뒤에 줄바꿈이 나오므로 세미콜론이 자동 삽입된 것이다.

```js
return;
a+b;
```

이때 postfix expression에 대해 이 규칙이 붙은 것은 다음과 같은 코드의 불확실성을 해소하려는 것이다. 다음 코드에 세미콜론이 자동 삽입되지 않는다면 `++`가 `a`에 대한 postfix인지 `b`에 대한 prefix인지 알 수 없다.

```js
a
++
b
```

세번째 규칙에 의해 이 코드는 다음과 같이 해석된다.

```js
a;
++b;
```

# 7. 네번째 규칙

> 세미콜론은 for 반복문의 구분자나 빈 선언문으로 절대 삽입되지 않는다.
>
> "이펙티브 자바스크립트" p. 33

for 루프의 구분자로는 반드시 세미콜론이 명시적으로 삽입되어야 한다는 것이다. 달리 말하면 세미콜론이 삽입될 경우 for 루프의 구분자로 간주되게 되면 세미콜론이 삽입되지 않는다.

예를 들어 다음 코드에서는 줄바꿈이 있지만 for문의 헤더에 세미콜론이 절대로 자동 삽입되지 않기에 오류가 발생한다.

```js
for(let i=0, total=1
  i<10
  i++){
  total*=i;
}
```

또한 세미콜론이 삽입되었을 경우 empty statement이 될 경우에도 자동 세미콜론 삽입이 일어나지 않는다. 따라서 본문이 비어 있는 루프도 명시적으로 세미콜론을 넣어 줘야 한다.

```js
function loop() { while (false) } // 파싱 오류
function loop() { while (false); } // 잘 파싱된다
```

// 여기까지 작성함


# 8. 세미콜론을 넣어야 하는 이유

JS에서도 명시적으로 세미콜론을 넣어 주는 것이 일반적으로 권장되고 있다. 그 이유는 위에서 본 것과 같이 자동 세미콜론 삽입의 규칙이 복잡하기 때문이다. 당장 위에서 본 것처럼 행이 `return`으로 끝날 때도 자동으로 세미콜론이 삽입되는데, 이는 코드의 의도와 다르게 해석될 수 있다.

## 8.1. 문제가 되는 경우

다음 코드는 `{a:1}`을 반환하는 함수를 정의한 것이다.

```js
return 
{
  a:1
}
```

그러나 이는 다음과 같이 해석되어 `undefined`를 반환한다.

```js
return;
{
  a:1
};
```

또한 파싱한 토큰이 이전 문의 연속으로 간주될 수 있는 토큰일 때, 그러니까 자동 세미콜론 삽입 없이도 파싱 결과가 문법적으로 말이 되는 경우도 있다. 예를 들어 다음 코드를 보자.

```js
a=b
(func());
```

다음 코드를 파싱하면 `a=b(func())`가 된다. 이는 b가 만약 함수라면 문법적으로 말이 된다. 그리고 js에서는 함수 또한 객체이기 때문에 b가 변수든 함수든 객체로 취급되고, 따라서 컴파일 타임에 파서가 `a=b(func())`의 오류를 잡아낼 수 없다.

비슷한 경우로 이런 코드를 들 수 있다.

```js
func()
['ul', 'ol'].forEach(function(tag){ handleTag(tag) });
```

2행의 대괄호는 `func()`의 결과를 인덱싱하는 걸로, 대괄호 내의 쉼표는 쉼표 연산자로 해석된다. 따라서 다음 코드는 의도치 않게 이렇게 해석된다.

```js
func()['ol'].forEach(function(tag){ handleTag(tag) });
```

## 8.2. 권장 사항

따라서 자동 세미콜론 삽입을 믿으면서 코드를 짠다면 일단 `(, [, +, -, /`의 앞에서는 절대 세미콜론을 생략하면 안 되며, `return, throw, break, continue, ++, --`의 앞에서도 절대 세미콜론을 생략하면 안 된다. for문 헤더의 세미콜론도 그렇다.

세미콜론 넣어주는 게 어려운 일도 아닌데, 굳이 위같은 점을 고려하면서 자동 세미콜론 삽입을 믿고 코드를 짜는 것은 좋지 않다..

자동 세미콜론 삽입은 결국 파서가 에러를 정정할 기회를 주는 것 뿐인데 이를 신뢰하면서 코드를 짜는 건 에러를 일부러 발생시키는 것과 다름없다.

# 참고

https://en.wikibooks.org/wiki/JavaScript/Automatic_semicolon_insertion

https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Lexical_grammar

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/Empty

https://tc39.es/ecma262/#sec-rules-of-automatic-semicolon-insertion

https://www.informit.com/articles/article.aspx?p=1997934&seqNum=6

악셀 라우슈마이어 지음, 한선용 옮김, "자바스크립트를 말하다"

데이비드 허먼 지음, 김준기 옮김, "이펙티브 자바스크립트"