---
title: 이분 탐색 알고리즘 구현 심화
date: "2023-09-26T01:00:00Z"
description: "이분 탐색의 구현을 더 깊이 알아봅니다."
tags: ["algorithm"]
---

# 이 글은 작성 중에 있습니다.

> 뻘글을 쓰고 싶은 기분이다. 이 글을 너무 진지하게 받지는 말기를 바란다.
>
> 내가 들어 보았지만 알지 못하는 알고리즘들(내가 들어보지도 못한 것들은 또 얼마나 많을지)
>
> - 리-차오 세그먼트 트리
> - 세그먼트 트리 비츠
> - `O(n)/O(1)` range max query
> - treap을 제외한 자가 균형 트리
> - 링크 컷 트리
> - 웨이블릿 트리
> - 머지 소트 트리
> - 바이노미얼 힙
> - 피보나치 힙
> - (그 외에 웬만한 건 비교도 안 될 수많은 고인물 알고리즘들 이하생략)
>
> 만약 당신이 이 중 적어도 3개 이상을 알고 있는데 codeforces 레이팅이 red가 아니라면 당신은 뭔가 잘못하고 있는 것이다. 쓸모없는 알고리즘 배우기를 멈추고 가서 문제를 좀 풀고, 이분 탐색을 어떻게 하는지 배워라.
>
> 출처 : 2021년의 [Um_nik이 쓴 글](https://codeforces.com/blog/entry/92248)(Um_nik은 2017년부터 안정적인 Legendary Grandmaster였다)

# 시작

[city](https://solved.ac/profile/city)입니다. 알고리즘을 그럭저럭 오래 해왔는데, 이분 탐색의 원리를 어떻게 이해하는지에 그리고 활용 문제를 접근하는 방식에 대해서 누군가가 물어봐서 써본 [이분 탐색 알고리즘의 활용](https://witch.work/posts/binary-search)의 후속작입니다.

이 글에서는 이분 탐색의 구현 방식과 파고들 수 있는 부분들에 대해서 좀 더 많이 알아보고 그것을 통해서 이분 탐색의 작동 방식을 더 잘 이해하는 것을 목표로 합니다.

글에 사용한 그림들은 [excalidraw](https://excalidraw.com/)를 사용하여 직접 그렸습니다.

# 1. 구간 줄이기의 이해

제가 이분탐색을 처음 제대로 이해할 수 있게 된 건 `while(low<=high)`로 구현했을 때 `low`와 `high`가 어떤 값을 가리키는지를 이해하고 나서였습니다. 이 그림과 비슷한 그림을 [Yun](https://blog.yuni.dev/)님이 보여주셨을 때 이해했습니다. 이분 탐색 짬을 좀 먹으신 분들은 이것만 봐도 뭔가 이해할 것입니다.

![탐색이 끝났을 때](./end-of-search.png)

하지만 이후 `while(low<high)`혹은 `while(low!=high)` 등 여러 다른 방식으로 이분 탐색을 구현하시는 분들도 많다는 걸 알게 되었습니다.

거기서 비롯된 이분탐색에 대한 더 깊은 이해를 하기까지는 좀 더 많은 시간이 걸렸습니다. 그 흔적을 여기 적습니다.

## 1.1. 문제 정의

이 글을 읽을 정도의 분들은 이미 이분 탐색도 파라메트릭 서치도 어느 정도 접해 보셨을 거라 생각하기 때문에 문제는 간단히만 설명하겠습니다.

어떤 구간 내의 자연수에 대하여 특정 동작이 가능한지를 결정하는 등의(예를 들어 길이 i인 구간 내에 어떤 수가 m번 이상 있는 것이 가능한지 등 이 문제는 다양해질 수 있습니다) 결정 문제가 있다고 했을 때 해당 문제가 구간에서 `[T, T, T, ..., T, T, F, F, ..., F]`와 같은 식으로 결정된다고 합시다. 이 결정 문제는 흔히 `check()`함수로 나타납니다.

이는 모든 파라메트릭 서치 문제에서 비슷하게 주어지는 조건입니다(F, T가 반대일 수는 있겠지만). 그리고 결정 문제의 결과가 T인 구간의 최댓값을 구하는 게 문제라고 해봅시다. 이를 구현하기 위한 다양한 방식이 있습니다.

## 1.2. 닫힌 구간 탐색

다음은 

위에서 보았던 코드를 다시 봅시다. 특정 자연수보다 작거나 같은 자연수에 대해서는 모두 가능하고 그보다 큰 자연수에 대해서는 모두 불가능한 A라는 기준이 있다고 할 때 해당 구간의 경계를 찾기 위한 코드입니다.

이 코드는 어떤 구간을 탐색하고, 어떤 구간으로 향할까요? `[low, high]`에 우리가 찾는 값이 있다고 했을 때 `mid`에서 A가 가능하면 `[mid+1, high]`로, 불가능하면 `[low, mid-1]`로 탐색 구간을 줄여나갑니다.

```cpp
while(low<=high){
  int mid = (low+high)/2;
  // A가 mid에서 가능하다
  if(check_A(mid)){
    low = mid+1;
  }else{
    high = mid-1;
  }
}
return high;
```

그리고 처음 탐색을 시작한 자연수 범위가 `[inf, sup]`라고 할 때 탐색 종료시 `[inf, high]`가 A가 가능한 범위가 되고 `[low, sup]`는 A가 불가능한 범위가 됩니다. 여기서 `low==high+1`입니다.

즉 모든 것이 닫힌 구간으로 돌아간다고 볼 수 있겠습니다.

## 1.2. 다른 방식 - 반열린 구간 탐색

다른 구현방식은 다음과 같습니다. 이 코드는 어떤 구간을 탐색하고, 어떤 구간으로 향할까요? `[low, high)`에 우리가 찾는 값이 있다고 했을 때 `mid`에서 A가 가능하면 `[mid+1, high)`로, 불가능하면 `[low, mid)`로 탐색 구간을 줄여나갑니다. 위와 달리 반열린 구간으로 따지는 것을 볼 수 있습니다.

```cpp
while(low<high){
  int mid = (low+high)/2;
  // A가 mid에서 가능하다
  if(check_A(mid)){
    low = mid+1;
  }else{
    high = mid;
  }
}
```

그리고 처음 탐색을 시작한 자연수 범위가 `[inf, sup)`라고 할 때 탐색 종료시 `[inf, high)`가 A가 가능한 범위가 되고 `[low, sup)`는 A가 불가능한 범위가 됩니다. 여기서 `low==high`입니다.

즉 탐색 종료 시 `low`, `high`가 모두 A의 가능/불가능을 가르는 경계에 위치하게 됩니다. `high`는 A가 가능한 반열린 구간의 상한을, `low`는 A가 불가능한 반열린 구간의 하한을 가리키는 것입니다.

즉 닫힌 구간으로 탐색할 시에는 `low`혹은 `high` 둘 중 하나가 정답이 되었다면, 이렇게 반열린 구간으로 탐색할 시 탐색 종료 시점에서 `low==high`이므로 문제 조건에 따라 `low` 혹은 `low-1`(물론 `high`나 `high-1`도 상관없다)를 출력해 줘야 합니다.

이런 반열린 구간 방식을 `while(low!=high)`와 같이 구현하는 분들도 있는데, 원리가 반열린 구간 탐색인 건 똑같으므로 더 설명하지는 않겠습니다.

## 1.3. 우열?

어떤 방식을 쓰는 게 더 좋을까? 딱히 정해진 건 없습니다. 각자가 처음 이해한 방식대로 쭉 간다고 봅니다. 통계적으로 따졌을 때 어느 방식이 좀 더 많이 쓰이고 있을 수는 있겠지만, 두 구현 모두 많은 고인물들이 각각 애용하고 있습니다.

이후에 다른 구현도 몇 가지 보겠지만 이들 또한 애용하고 있는 고수들이 다 있습니다. 고인물들이니까 다른 방식의 구현을 이해하지 못할 리는 없지만 뉴비 때부터 손과 머리에 익은 방식을 두고 굳이 바꿀 건 없으니 그냥 계속 쓰고 있는 것입니다. 이 글을 보시는 분들도 그렇게 한번 이해한 구현으로 쭉 가시면 됩니다.

저는 개인적으로 닫힌 구간으로 뭔가를 따지는 게 대부분의 경우 더 직관적이라고 생각하지만, 가령 n 길이의 배열에서 뭔가를 찾는다면 탐색 구간의 인덱스를 `[0, n-1]`로 잡는 것보다는 `[0, n)`으로 잡는 게 더 직관적이라고 생각합니다. 장단이 있는 거죠.

결국 이런 걸로 아무도 싸우지 않기 때문에 그냥 스스로가 더 편한 방식으로 쓰면 됩니다. 가령 세그먼트 트리 같은 자료구조는 닫힌 구간으로 구현하는 사람이 더 많은 게 명백하다고 보이는데, 아무도 반열린 구간으로 구현하는 사람에게 뭐라 하는 것을 보지 못했습니다.

따라서 이 글을 읽어 보고, 많은 참고자료도 보고 많은 문제를 풀어 보면서 스스로가 가장 잘 이해할 수 있는 방식대로 짜면 되겠습니다.

# 2. 다른 구현 몇 가지

## 2.1. 다른 구현 1

[jinhan814님](https://www.acmicpc.net/user/jinhan814)의 구현입니다. 이것도 상당히 유명한 편인 구현인데 기억하지 못하고 있다가 어떤 분이 피드백을 주셔서 추가합니다. 개인적으로 익숙한 구현은 아니지만, 구간을 줄여 나간다는 관점에서는 가장 충실한 구현이 아닌가 생각합니다(물론 사소한 차이지만요).

지금까지 계속 보았던 어떤 경계값 이하 구간에서는 A가 가능하고, 경계값 초과 구간에서는 A가 불가능할 때 A가 가능한 구간의 상한을 찾는 문제(가능한 숫자 범위는 `start`~`end`라고 할 때)를 생각해 봅시다.

닫힌 구간을 이용해서 이 문제에 대한 이분 탐색을 한다고 할 때 사실 경계값이라는 표현은 그렇게 적절하지 않다고 생각합니다.

결론적으로 이는 `[start, sep]`에서 A가 가능하고 `[sep+1, end]`에서 A가 불가능할 때 `sep`을 찾는 문제인데 `sep`도, `sep+1`도 딱 경계라고 하기는 좀 애매하기 때문입니다. 따라서 진짜 경계라고 할 만한 건 `sep`와 `sep+1` 둘 모두라고 할 수 있겠습니다. 그리고 이 구현은 그 둘을 각각 `low`, `high`의 최종값으로 구하는 구현입니다.

이를 구현한 코드를 먼저 보면 다음과 같습니다.

```cpp
while (low + 1 < high) {
  int mid = (low+high)/2;
  if(check(mid)){
    low=mid;
  }
  else{
    high=mid;
  }
}
```

이 코드를 이해하기 위해서는 먼저 우리가 찾고자 하는 것이 결국은 `check(i)`의 값이 바뀌는 지점을 찾는 것이라는 것을 생각해야 합니다.

문제 구조상 이분 탐색을 시작하는 시점에 `check(low)`는 true이고 `check(high)`는 false인데 그러면 그게 바뀌는 지점은 중간에 단 하나 있고 우린 그 지점을 찾으면 되는 것입니다. 이를 위한 로직은 이렇습니다.

`check(low)==check(mid)`이면 `low=mid`를 취해줍니다. 여기서는 `check(low)==true`이므로 그냥 참인지만 체크해 주면 됩니다. 반대로 `check(mid)==check(high)`이면 `high=mid`를 취해줍니다.

그러면 `while`이 지속되는 한 `low+1<high`이기 때문에 `low`, `high` 사이에는 최소 하나의 수가 있고 `low<mid<high`는 항상 참입니다.

그러면 반복문 종료 시점에 `low+1==high`입니다. 반복문을 탈출했다는 건 `low+1>=high`라는 것인데 늘 `low<mid<high`이므로 `low<high`이기 때문에 이 두 조건을 모두 만족하려면 `low+1==high`밖에 없기 때문입니다.

그럼 최종적으로 `[start, low]`에서는 `check`의 결과가 true, `[high, end]`에서는 `check`의 결과가 false이게 되고 우리는 문제에서 요구하는 조건에 따라 `low` 혹은 `high`를 출력하면 됩니다. 만약 가능한 구간의 최댓값을 구하라 했다면 `low`를 출력하는 것입니다.

### 2.1.1. 주의할 부분

이 구현을 개인적으로 쓰지는 않기 때문에 체감해 보지는 못했지만, `low`와 `high`가 항상 정답 범위를 나타낼 수 있도록 하는 것에 주의해야 한다고 합니다.

예를 들어서 구조상 `low`를 출력해야 하는 문제의 답이 최대 `n`이라면 `high=n`으로 선언하면 안됩니다. `low`가 `n`이 될 수도 있다는 것인데 그러면 그때 `high`는 `n+1`이 되어야 할 텐데 처음에 `high=n`으로 선언한다면 이런 경우를 찾을 수 없기 때문입니다. 이럴 땐 `high=n+1`로 선언해야 합니다.

마찬가지로 `high`를 출력하는 문제 답이 최소 0일 때는 `low=-1`로 선언해야 합니다.

## 2.2. 다른 구현 2 - binary jumping

[jinhan814님이 BOJ에 쓰신 글에 달린 dohoon님의 댓글](https://www.acmicpc.net/blog/view/109#comment-588)에 적힌 구현이다. 지인들에 의하면 앳코더에 있는 의문의 인도인들(최강의 프로그래머)의 코드에서 가끔 볼 수 있는 방식이라고 한다.

```cpp
int cur = low - 1;
for (int step = high - low + 1; step >= 1; step /= 2) {
  while (cur + step <= high && check(cur + step)) {
    cur += step;
  }
}
```

for문으로 구현되었고 이전과 구간을 줄여 나가는 방식이 약간 다르기 때문에 뭔가 많이 달라 보일 수도 있지만 본질적으로는 똑같은 구현이다.



                                                     



처음에 `step` 한 번을 가면 `high`가 되도록 만들기 위해 `step`의 초기값을 `high-low+1`로 잡았지만 어차피 `step`이 줄어들고 그때마다 가능한 만큼 나아가는 방식이기 때문에 `step`초기값은 `high`로 잡아도 상관없다. 다음과 같이 말이다.

```cpp
int cur = low - 1;
for (int step = high; step >= 1; step /= 2) {
  while (cur + step <= high && check(cur + step)) {
    cur += step;
  }
}
```


# 미세팁

## `mid=low+(high-low)/2`

많은 구현에서 대부분 `mid`는 다음과 같은 식으로 정의됩니다.

```c
int mid = (low+high)/2;
```

하지만 이렇게 `mid`를 정의할 수도 있습니다. [Topcoder의 이분 탐색 튜토리얼](https://www.topcoder.com/thrive/articles/Binary+Search)등에서 이렇게 쓰고 있습니다.

```c
int mid = low + (high - low) / 2;
```

이는 `low+high`가 음수일 경우를 대비한 것입니다. 이분 탐색에서 우리가 `/2`를 취할 때는 보통 round down되기를 원합니다. `5 / 2`는 2가 되는 식으로 말이죠. 이는 정수 나눗셈이 있는 일반적인 언어들에서 양수에 대해 잘 지원됩니다.

하지만 음수에 대해서는 어떨까요? `-5 / 2`는 round down되면 `-3`이 되어야 합니다. 하지만 `-5 / 2`는 C++등 많은 언어들에서 `-2`가 되죠.

따라서 `mid`의 정의를 `low + (high - low) / 2` 로 바꿔서 `/2`가 늘 round down되도록 만들어 준 것이 바로 위의 변경점입니다.

[C++에서는 `std::midpoint`라는 라이브러리 함수를 제공하기도 합니다. 여기의 구현이 바로 위에서 본 `low + (high - low) / 2`와 사실상 같습니다.](https://en.cppreference.com/w/cpp/numeric/midpoint)

# 추가 정보

이분 탐색과 관련된 몇 가지 추가적인 알고리즘들을 소개합니다. 저도 개념적인 이해 정도만 하고 있는 부분이기도 하고 그냥 이분 탐색을 깊이 이해하는 목적과는 멀리 떨어져 있다고 생각되어 정말 간단한 소개만 합니다.

## 삼분 탐색(Ternary Search)

볼록 함수에서 극값 혹은 최대, 최솟값을 찾을 때 사용할 수 있는 알고리즘입니다.

이분 탐색 같은 경우 `[T, T, T,..., T, F, ..., F]`로 결정되는 구간에서 T로 결정되는 구간의 최댓값을 결정하는 느낌이었는데요. 이를 다음과 같은 단조 증가(단조 감소도 상관없습니다)함수와 x축의 교점 좌표를 찾는 문제로 생각해 보면 어떨까요?

![증가하는 그래프의 예시](./inc-graph-ex.png)

그러면 `f(low)`와 `f(high)`의 부호가 다르다면 `[low, high]`내에 근이 있다는 것이 보장될 것이고 이분 탐색으로 해당 근을 찾을 수 있습니다. `f(x) < 0`인가? 라는 결정 문제로 환원하면 파라메트릭 서치로 생각할 수도 있겠습니다.

비슷한 일을 볼록 함수(정확히는 유니모달 함수)에 적용한 것이 삼분 탐색입니다. 다음과 같은 볼록 함수에서 극값을 찾는 것이죠.

![볼록 그래프 예시](./convex-graph.png)

극값이 있는 특정 구간을 알고 있다고 하면 해당 구간의 양 끝점과 삼분점 2개의 대소비교를 통해서 극값이 있을 가능성이 있는 구간을 2/3으로 줄일 수 있다는 아이디어입니다. 구간을 2개로만 나누지 않아도 쓸모가 있다는 예시 정도로 생각하면 좋을 것 같습니다.

삼분 탐색이 더 궁금하신 분들은 kks227님의 글을 참고하시면 좋겠습니다.
https://blog.naver.com/kks227/221432986308

## 병렬 이분 탐색

일반적인 이분 탐색을 확장하여, 이분 탐색으로 풀 수 있는 쿼리를 한번에 여러 개 진행하는 병렬 이분 탐색이라는 기법도 있습니다.

하지만 그냥 이분 탐색과는 상당한 간극이 있고 저에게도 익숙한 기법이 아니기 때문에 관심이 있으신 분들은 [kks227님의 글](https://blog.naver.com/kks227/221410398513)이나 [나정휘 님의 글](https://justicehui.github.io/hard-algorithm/2020/02/24/pbs/)을 참고하시면 될 것 같습니다.


# 참고

이분탐색 실수없이 짜기
https://blog.fiene.dev/2023/01/16/binary-search.html

jinhan814님의 이분 탐색(Binary Search) 헷갈리지 않게 구현하기 https://www.acmicpc.net/blog/view/109

jinhan814님의 이분탐색 블로그 글 https://blog.naver.com/jinhan814/222607789392

`[Tutorial]` Binary search and other "halving" methods https://codeforces.com/blog/entry/96699

topcoder의 binary search 글 https://www.topcoder.com/thrive/articles/Binary+Search