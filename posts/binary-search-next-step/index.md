---
title: 이분 탐색 알고리즘 구현 심화
date: "2023-09-26T01:00:00Z"
description: "이분 탐색의 구현을 더 깊이 알아봅니다."
tags: ["algorithm"]
---

# 이 글은 작성 중에 있습니다.

# 시작

[city](https://solved.ac/profile/city)입니다. 알고리즘을 그럭저럭 오래 해왔는데, 이분 탐색의 원리를 어떻게 이해하는지에 그리고 활용 문제를 접근하는 방식에 대해서 누군가가 물어봐서 써본 [이분 탐색 알고리즘의 활용](https://witch.work/posts/binary-search)의 후속작입니다.

이 글에서는 이분 탐색의 구현 방식에 대해서 좀 더 많이 알아보고 그것을 통해서 이분 탐색의 작동 방식을 더 잘 이해하는 것을 목표로 합니다.

글에 사용한 그림들은 [excalidraw](https://excalidraw.com/)를 사용하여 직접 그렸습니다.

# 1. 구간의 이해

제가 이분탐색을 처음 제대로 이해할 수 있게 된 건 `while(low<=high)`로 구현했을 때 `low`와 `high`가 어떤 값을 가리키는지를 이해하고 나서였습니다. 이 그림과 비슷한 그림을 [Yun](https://blog.yuni.dev/)님이 보여주셨을 때 이해했습니다.

![탐색이 끝났을 때](./end-of-search.png)

하지만 이후 `while(low<high)`혹은 `while(low!=high)` 등 여러 다른 방식으로 이분 탐색을 구현하시는 분들도 많다는 걸 알게 되었고 이 부분에 대한 이해는 좀 더 많은 시간이 지나서야 할 수 있게 되었습니다. 그래서 이 부분도 설명하고자 합니다.

## 4.1. 기존 방식 - 닫힌 구간 탐색

위에서 보았던 코드를 다시 봅시다. 특정 자연수보다 작거나 같은 자연수에 대해서는 모두 가능하고 그보다 큰 자연수에 대해서는 모두 불가능한 A라는 기준이 있다고 할 때 해당 구간의 경계를 찾기 위한 코드입니다.

이 코드는 어떤 구간을 탐색하고, 어떤 구간으로 향할까요? `[low, high]`에 우리가 찾는 값이 있다고 했을 때 `mid`에서 A가 가능하면 `[mid+1, high]`로, 불가능하면 `[low, mid-1]`로 탐색 구간을 줄여나갑니다.

```cpp
while(low<=high){
  int mid = (low+high)/2;
  // A가 mid에서 가능하다
  if(check_A(mid)){
    low = mid+1;
  }else{
    high = mid-1;
  }
}
return high;
```

그리고 처음 탐색을 시작한 자연수 범위가 `[inf, sup]`라고 할 때 탐색 종료시 `[inf, high]`가 A가 가능한 범위가 되고 `[low, sup]`는 A가 불가능한 범위가 됩니다. 여기서 `low==high+1`입니다.

즉 모든 것이 닫힌 구간으로 돌아간다고 볼 수 있겠습니다.

## 4.2. 다른 방식 - 반열린 구간 탐색

다른 구현방식은 다음과 같습니다. 이 코드는 어떤 구간을 탐색하고, 어떤 구간으로 향할까요? `[low, high)`에 우리가 찾는 값이 있다고 했을 때 `mid`에서 A가 가능하면 `[mid+1, high)`로, 불가능하면 `[low, mid)`로 탐색 구간을 줄여나갑니다. 위와 달리 반열린 구간으로 따지는 것을 볼 수 있습니다.

```cpp
while(low<high){
  int mid = (low+high)/2;
  // A가 mid에서 가능하다
  if(check_A(mid)){
    low = mid+1;
  }else{
    high = mid;
  }
}
```

그리고 처음 탐색을 시작한 자연수 범위가 `[inf, sup)`라고 할 때 탐색 종료시 `[inf, high)`가 A가 가능한 범위가 되고 `[low, sup)`는 A가 불가능한 범위가 됩니다. 여기서 `low==high`입니다.

즉 탐색 종료 시 `low`, `high`가 모두 A의 가능/불가능을 가르는 경계에 위치하게 됩니다. `high`는 A가 가능한 반열린 구간의 상한을, `low`는 A가 불가능한 반열린 구간의 하한을 가리키는 것입니다.

즉 닫힌 구간으로 탐색할 시에는 `low`혹은 `high` 둘 중 하나가 정답이 되었다면, 이렇게 반열린 구간으로 탐색할 시 탐색 종료 시점에서 `low==high`이므로 문제 조건에 따라 `low` 혹은 `low-1`(물론 `high`나 `high-1`도 상관없다)를 출력해 줘야 합니다.

이런 반열린 구간 방식을 `while(low!=high)`와 같이 구현하는 분들도 있는데, 원리가 반열린 구간 탐색인 건 똑같으므로 더 설명하지는 않겠습니다.

## 4.3. 우열?

어떤 방식을 쓰는 게 더 좋을까? 딱히 정해진 건 없습니다. 각자가 처음 이해한 방식대로 쭉 간다고 봅니다. 통계적으로 따졌을 때 어느 방식이 좀 더 많이 쓰이고 있을 수는 있겠지만, 두 구현 모두 많은 고인물들이 각각 애용하고 있습니다.

이후에 다른 구현도 몇 가지 보겠지만 이들 또한 애용하고 있는 고수들이 다 있습니다. 고인물들이니까 다른 방식의 구현을 이해하지 못할 리는 없지만 뉴비 때부터 손과 머리에 익은 방식을 두고 굳이 바꿀 건 없으니 그냥 계속 쓰고 있는 것입니다. 이 글을 보시는 분들도 그렇게 한번 이해한 구현으로 쭉 가시면 됩니다.

저는 개인적으로 닫힌 구간으로 뭔가를 따지는 게 대부분의 경우 더 직관적이라고 생각하지만, 가령 n 길이의 배열에서 뭔가를 찾는다면 탐색 구간의 인덱스를 `[0, n-1]`로 잡는 것보다는 `[0, n)`으로 잡는 게 더 직관적이라고 생각합니다. 장단이 있는 거죠.

결국 이런 걸로 아무도 싸우지 않기 때문에 그냥 스스로가 더 편한 방식으로 쓰면 됩니다. 가령 세그먼트 트리 같은 자료구조는 닫힌 구간으로 구현하는 사람이 더 많은 게 명백하다고 보이는데, 아무도 반열린 구간으로 구현하는 사람에게 뭐라 하는 것을 보지 못했습니다.

따라서 이 글을 읽어 보고, 많은 참고자료도 보고 많은 문제를 풀어 보면서 스스로가 가장 잘 이해할 수 있는 방식대로 짜면 되겠습니다.

# 5. 다른 구현 몇 가지


## 5.2. 다른 구현 1

[jinhan814님](https://www.acmicpc.net/user/jinhan814)의 구현입니다. 이것도 상당히 유명한 편인 구현인데 기억하지 못하고 있다가 어떤 분이 피드백을 주셔서 추가합니다. 개인적으로 익숙한 구현은 아니지만, 구간을 줄여 나간다는 관점에서는 가장 충실한 구현이 아닌가 생각합니다(물론 사소한 차이지만요).

지금까지 계속 보았던 어떤 경계값 이하 구간에서는 A가 가능하고, 경계값 초과 구간에서는 A가 불가능할 때 A가 가능한 구간의 상한을 찾는 문제(가능한 숫자 범위는 `start`~`end`라고 할 때)를 생각해 봅시다.

닫힌 구간을 이용해서 이 문제에 대한 이분 탐색을 한다고 할 때 사실 경계값이라는 표현은 그렇게 적절하지 않다고 생각합니다.

결론적으로 이는 `[start, sep]`에서 A가 가능하고 `[sep+1, end]`에서 A가 불가능할 때 `sep`을 찾는 문제인데 `sep`도, `sep+1`도 딱 경계라고 하기는 좀 애매하기 때문입니다. 따라서 진짜 경계라고 할 만한 건 `sep`와 `sep+1` 둘 모두라고 할 수 있겠습니다. 그리고 이 구현은 그 둘을 각각 `low`, `high`의 최종값으로 구하는 구현입니다.

이를 구현한 코드를 먼저 보면 다음과 같습니다.

```cpp
while (low + 1 < high) {
  int mid = (low+high)/2;
  if(check(mid)){
    low=mid;
  }
  else{
    high=mid;
  }
}
```

이 코드를 이해하기 위해서는 먼저 우리가 찾고자 하는 것이 결국은 `check(i)`의 값이 바뀌는 지점을 찾는 것이라는 것을 생각해야 합니다.

문제 구조상 이분 탐색을 시작하는 시점에 `check(low)`는 true이고 `check(high)`는 false인데 그러면 그게 바뀌는 지점은 중간에 단 하나 있고 우린 그 지점을 찾으면 되는 것입니다. 이를 위한 로직은 이렇습니다.

`check(low)==check(mid)`이면 `low=mid`를 취해줍니다. 여기서는 `check(low)==true`이므로 그냥 참인지만 체크해 주면 됩니다. 반대로 `check(mid)==check(high)`이면 `high=mid`를 취해줍니다.

그러면 `while`이 지속되는 한 `low+1<high`이기 때문에 `low`, `high` 사이에는 최소 하나의 수가 있고 `low<mid<high`는 항상 참입니다.

그러면 반복문 종료 시점에 `low+1==high`입니다. 반복문을 탈출했다는 건 `low+1>=high`라는 것인데 늘 `low<mid<high`이므로 `low<high`이기 때문에 이 두 조건을 모두 만족하려면 `low+1==high`밖에 없기 때문입니다.

그럼 최종적으로 `[start, low]`에서는 `check`의 결과가 true, `[high, end]`에서는 `check`의 결과가 false이게 되고 우리는 문제에서 요구하는 조건에 따라 `low` 혹은 `high`를 출력하면 됩니다. 만약 가능한 구간의 최댓값을 구하라 했다면 `low`를 출력하는 것입니다.

### 5.2.1. 주의할 부분

이 구현을 개인적으로 쓰지는 않기 때문에 체감해 보지는 못했지만, `low`와 `high`가 항상 정답 범위를 나타낼 수 있도록 하는 것에 주의해야 한다고 합니다.

예를 들어서 구조상 `low`를 출력해야 하는 문제의 답이 최대 `n`이라면 `high=n`으로 선언하면 안됩니다. `low`가 `n`이 될 수도 있다는 것인데 그러면 그때 `high`는 `n+1`이 되어야 할 텐데 처음에 `high=n`으로 선언한다면 이런 경우를 찾을 수 없기 때문입니다. 이럴 땐 `high=n+1`로 선언해야 합니다.

마찬가지로 `high`를 출력하는 문제 답이 최소 0일 때는 `low=-1`로 선언해야 합니다.

## 5.3. 다른 구현 2 - binary jumping

[jinhan814님이 BOJ에 쓰신 글에 달린 dohoon님의 댓글](https://www.acmicpc.net/blog/view/109#comment-588)에 적힌 구현이다. 지인들에 의하면 앳코더에 있는 의문의 인도인들(최강의 프로그래머)의 코드에서 가끔 볼 수 있는 방식이라고 한다.

```cpp
int cur = low - 1;
for (int step = high - low + 1; step >= 1; step /= 2) {
  while (cur + step <= high && check(cur + step)) {
    cur += step;
  }
}
```

for문으로 구현되었고 이전과 구간을 줄여 나가는 방식이 약간 다르기 때문에 뭔가 많이 달라 보일 수도 있지만 본질적으로는 똑같은 구현이다.







처음에 `step` 한 번을 가면 `high`가 되도록 만들기 위해 `step`의 초기값을 `high-low+1`로 잡았지만 어차피 `step`이 줄어들고 그때마다 가능한 만큼 나아가는 방식이기 때문에 `step`초기값은 `high`로 잡아도 상관없다. 다음과 같이 말이다.

```cpp
int cur = low - 1;
for (int step = high; step >= 1; step /= 2) {
  while (cur + step <= high && check(cur + step)) {
    cur += step;
  }
}
```




# 참고

이분탐색 실수없이 짜기
https://blog.fiene.dev/2023/01/16/binary-search.html

jinhan814님의 이분 탐색(Binary Search) 헷갈리지 않게 구현하기 https://www.acmicpc.net/blog/view/109

jinhan814님의 이분탐색 블로그 글 https://blog.naver.com/jinhan814/222607789392

`[Tutorial]` Binary search and other "halving" methods https://codeforces.com/blog/entry/96699