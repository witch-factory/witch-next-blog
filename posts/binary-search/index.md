---
title: 이분 탐색 알고리즘의 활용
date: "2023-09-25T01:00:00Z"
description: "이분 탐색의 활용에 대해 알아봅니다."
tags: ["algorithm"]
---

[city](https://solved.ac/profile/city)입니다. 알고리즘을 그럭저럭 오래 해왔는데, 이분 탐색의 원리를 어떻게 이해하는지에 그리고 활용 문제를 접근하는 방식에 대해서 누군가가 물어봐서 간단히 써봅니다.

기초적인 부분에 대해서는 생략된 부분도 많기 때문에 [kks227님의 블로그 글](https://blog.naver.com/kks227/220777333252)과 같은 좋은 참고자료들이 많으니 같이 보면 좋을 것 같습니다.

글에 사용한 그림들은 [excalidraw](https://excalidraw.com/)를 사용하여 직접 그렸습니다.

# 1. 이분 탐색의 기초

기본적인 이분 탐색은 정렬된 원소들 사이에서 특정 원소를 찾는 알고리즘입니다.

## 1.1. 코드

정렬된 `arr`배열에서 `target`값을 찾는 코드라면 대략 다음과 같은 코드로 짤 수 있습니다. C++ 기준입니다. 물론 다른 언어라도 논리는 똑같습니다.

```cpp
while(low<=high) {
  int mid = (low+high)/2;
  if(arr[mid]==target) {
    return mid;
  } else if(arr[mid]>target) {
    high = mid-1;
  } else {
    low = mid+1;
  }
}
```

## 1.2. 원리

이것의 핵심 아이디어는 우리가 찾는 값이 존재할 수 있는 탐색 구간을 반씩 줄여 나간다는 것입니다. 물론 값이 배열 내에 없을 수도 있지만, 값이 정렬되어 있기 때문에 

처음 탐색을 시작할 때를 생각해 봅시다. `arr`의 크기가 n이라면 우리가 찾는 값이 있을 수 있는 구간은 `arr[0]`부터 `arr[n-1]`까지입니다. 그리고 위의 알고리즘대로라면 `arr[(n-1)/2]`와 `target`을 비교하게 될 것입니다.

그런데 배열이 정렬되어 있다는 것을 생각해 볼 때, 배열의 모든 값은 `arr[mid]`와의 비교를 통해 다음과 같은 두 구간으로 나눌 수 있습니다.

(그럼 `mid`인덱스는 어느 쪽 구간에 속하는지 의문이 들 수 있습니다. 일단 넘어가도 되는 부분이긴 한데 위와 같은 닫힌 구간 구현에서는 둘 중 어디에도 속하지 않고, 이후에 볼 반열림 구간 `[s,e)`로 구현할 시에는 오른쪽 부분에 속하게 됩니다.)

![search-start](search-start.png)

그럼 우리는 찾는 값 `target`이 `arr[mid]`보다 작은지 큰지만 비교하면 `target`이 존재할 수 있는 구간을 반으로 줄일 수 있습니다. `target`이 `arr[mid]`보다 작다면 `mid`인덱스보다 작은 인덱스에 존재할 것이고 크다면 `mid`인덱스보다 큰 인덱스에 존재할 것이기 때문입니다.

만약 `target==arr[mid]`라면 우리는 `target`을 찾은 것이므로 바로 `mid`를 리턴하면 되고요.

정렬된 배열에서는 이런 식으로 `target`이 존재할 수 있는 구간을 반씩 줄여 나가면서 탐색할 수 있기 때문에 시간복잡도 `O(logN)`만에 배열에서 값을 찾을 수 있다는 게 이분 탐색의 핵심 아이디어입니다.

즉 늘 다음과 같은 상황에서 탐색을 진행하게 됩니다.

![이분탐색 과정의 묘사](./searching.png)

그럼 탐색 구간을 구체적으로 어떻게 좁히느냐? 위의 이분탐색 코드는 설명한 두 가지 경우에 따라 low를 조절하거나 high를 조절해서 탐색 구간을 좁혀 나갑니다.

만약 `target`이 `arr[mid]`보다 작다면 `target`을 찾기 위해 `arr[mid]`의 왼쪽 구간을 탐색해야 하므로 탐색 구간의 상한인 `high`를 줄이고, `target`이 `arr[mid]`보다 크다면 `arr[mid]`의 오른쪽 구간을 탐색해야 하므로 탐색 구간의 하한인 `low`를 늘려줍니다.

이를 반복하다 보면 언젠가는 `target`을 찾게 되거나 탐색 구간이 더 이상 없어서 `target`을 찾지 못하게 됩니다.

# 2. 원리의 확장

## 2.1. 파라메트릭 서치의 아이디어

여기서 주목해야 할 것은 어떻게 우리가 탐색 구간을 반씩 좁혀 나가면서, `mid`인덱스를 기준으로 한쪽에는 `target`이 있고, 한쪽에는 `target`이 없다'라는 것을 알 수 있었는지입니다.

당연히, 배열의 원소들이 정렬되어 있었기 때문입니다. 배열이 정렬되어 있다는 사실 덕에 우리는 `arr[mid]`와 `target`의 대소비교만 하면 `target`이 어느 쪽에 있는지 찾을 수 있었습니다.

이 말을 반대로 말하면 정렬된 구간을 어떤 기준으로 반씩 줄여 가며 무언가를 찾을 수 있는 작업이라면 이분 탐색을 생각해 볼 수 있다는 이야기입니다. 여기서 파라메트릭 서치의 아이디어가 나옵니다.

자연수는 당연히 정렬되어 있습니다(Well Ordering Principle과 선택 공리 어쩌구 하는 건 넘어갑시다...).

그럼 어떤 특정 자연수를 경계로 그보다 작거나 같은 자연수들에서는 가능하고, 그보다 큰 자연수들에서는 불가능한 무엇인가가 있다고 해봅시다. 이 무언가를 A라고 한다면 자연수는 다음과 같이 두 구간으로 나눠질 것입니다.

![possible-line](./possible-line.png)

우리가 따져야 하는 자연수의 상한과 하한을 알고 있다고 할 때, 이 A의 가능과 불가능을 가르는 경계를 찾는 문제를 생각해 봅시다. 'A가 가능한 값 중 최댓값을 찾아보자'와 같은 문제 말입니다.

그럼 우리가 어떤 특정 값에 대해 A가 가능한지 불가능한지 판정할 수 있다면, 우리가 찾아야 할 경계가 해당 값을 기준으로 왼쪽에 있는지 오른쪽에 있는지 판단할 수 있습니다. 이를 이용하면 우리는 경계를 찾아야 하는 탐색 구간을 반씩 줄여 나갈 수 있고 따라서 이분탐색의 아이디어로 문제를 풀 수 있습니다.

```
이렇게 문제를 푸는 방식을 파라메트릭 서치, 즉 매개 변수 탐색이라고도 합니다. 최적화 문제를 결정 문제로 바꿔 푸는 거라고 멋지게 말할 수도 있지만 그 말이 원리만큼 중요하다고 생각하지는 않습니다.
```

이 섹션에서 이야기한 것이 잘 이해되지 않아도 상관없습니다. 이 섹션의 나머지 부분에서 파라메트릭 서치를 좀더 자세히 설명할 것입니다.

## 2.2. 파라메트릭 서치의 원리

위에서 말했던, 어떤 특정 자연수를 경계로 그보다 작거나 같은 자연수들에서는 가능하고, 그보다 큰 자연수들에서는 불가능한 A라는 무언가 있고 그 A가 가능한 구간의 최댓값을 구한다고 해봅시다. 즉 A가 가능한 구간과 불가능한 구간을 가르는 경계를 구하는 겁니다.

그러면 따져 봐야 할 자연수의 하한을 `low`, 상한을 `high`라고 했을 때 우리는 `mid=(low+high)/2`에서 A가 가능한지를 기반으로 우리가 구해야 할 값이 `mid`보다 작은지 큰지를 판단할 수 있습니다.

만약 `mid`에서 A가 불가능하다고 해봅시다. 그러면 다음과 같은 상황일 것입니다.

![mid에서 불가능](./impossible-in-mid.png)

그럼 그림만 보아도, 우리는 A의 가능과 불가능을 가르는 경계가 `mid`보다 작은 쪽에 있다는 것을 알 수 있습니다. 만약 반대로 `mid`에서 A가 가능하다면 경계는 `mid`보다 큰 쪽에 있을 것입니다. 이를 이용해 탐색 구간을 업데이트해 나갑니다. 다음 섹션에서 더 자세히 보겠습니다.

## 2.3. 코드와 함께 자세히 보기

코드와 함께 보면 다음과 같습니다. 나올 수 있는 자연수의 하한을 low, 상한을 high라고 하면, 경계선을 찾는 코드는 대강 이럴 것입니다. 다음 코드는 A가 가능한 구간의 상한을 찾는 코드입니다.

```cpp
while(low<=high){
  int mid = (low+high)/2;
  // A가 mid에서 가능하다
  if(check_A(mid)){
    low = mid+1;
  }else{
    high = mid-1;
  }
}
return high;
```

A가 `mid`에서 가능하다면 즉 `check_A(mid)`가 true라면 경계선은 `mid`의 오른쪽에 있을 것입니다. 다음과 같은 상황인 거죠.

![update-low](./update-low.png)

따라서 오른쪽 구간의 탐색을 위해 low를 mid+1로 업데이트해주는 것입니다. 그러고 나면 다음 탐색 구간은 다음과 같이 반으로 줄도록 업데이트됩니다.

![low가 업데이트된 이후](./after-low-update.png)

반대로 A가 `mid`에서 불가능하다면 경계선은 A의 왼쪽에 있을 수밖에 없습니다. 다음과 같은 상황에서만 `mid`에서 A가 불가능할 수 있기 때문입니다.

![update-high](./update-high.png)

따라서 왼쪽 구간의 탐색을 위해 high를 mid-1로 업데이트해주는 것입니다.

![high가 업데이트된 이후](./after-high-update.png)

이를 반복하다 보면 가능/불가능의 경계가 있는 구간을 확실히 찾을 수 있습니다!

# 3. 더 깊이 이해하기

이분탐색에 대한 자료는 워낙 많기 때문에 이 정도 이해는 사실 꽤 많은 분들이 하고 계십니다. 하지만 가장 헷갈리는 부분은 이런 거라고 생각합니다.

```
while(low<=high) vs while(low<high)
low 출력 vs high 출력
(lower와 upper, l과 r, s와 e등의 다른 변수명을 쓰는 분들도 있지만 가리키는 건 어차피 똑같으니 low, high로 하겠습니다)
```

저는 많은 분들이 그렇듯이 알고리즘을 처음 시작한 지 몇 달 안 되어 이분 탐색을 배웠지만 이런 것들을 잘 이해하기까지는 1년도 넘게 걸린 것 같습니다.

따라서 먼저 제가 사용하는 방식에서 저런 부분들을 어떻게 다루는지 설명하도록 하겠습니다. 그리고 다음 섹션에서는 다른 방식도 소개하도록 하겠습니다.

## 3.1. 구현 이해하기

문제 조건에 따라 조금씩 달라지지만 어떤 A가 가능한 구간의 최댓값 혹은 최솟값을 찾는 파라메트릭 서치에 제가 흔히 쓰는 코드는 다음과 같습니다. 위에 쓴 것과 같습니다.

```cpp
while(low<=high){
  int mid=(low+high)/2;
  if(check_A(mid)){
    low=mid+1;
  }
  else{
    high=mid-1;
  }
}
```

그럼 이 `while`문은 어느 시점에 종료될까요? `while`은 `low<=high`일 때 body를 실행하니까 `while`이 종료되었다는 것은 `low>high`가 되었다는 뜻일 겁니다. 그리고 탐색 구간의 길이는 계속 작아져서 결국 1이 되었을 테니 `low>high`일 때 둘의 차이는 1이 될 것입니다.

문제가 A가 경계선을 나타내는 자연수보다 작거나 같으면 가능, 크면 불가능이며 A가 가능한 구간의 최댓값을 찾는 문제였다면 `high`는 A가 가능한 구간의 상한을, `low`는 불가능한 구간의 하한을 나타내게 되는 것입니다. 다음 그림의 상황은 `low==high+1`이 되어 `while`이 종료된 상황입니다.

![end-of-search](./end-of-search.png)

만약 반대로 문제 조건이 경계선을 나타내는 자연수보다 크면 가능, 작으면 불가능인 문제였다면 `low`는 가능한 구간의 하한을, `high`는 불가능한 구간의 상한을 나타내게 됩니다.

## 3.2. 문제로 생각해보기

유명한 파라메트릭 서치 문제인 [1654번 랜선 자르기](https://www.acmicpc.net/problem/1654)를 봅시다.

특정 경계 수보다 작거나 같으면 문제의 조건을 만족시킬 수 있고 크면 문제 조건을 만족시킬 수 없습니다. K개의 랜선들을 같은 길이로 잘라서 N개의 랜선을 만들어야 하고 그럴 수 있는 최대 랜선 길이를 구해야 한다는 문제 조건을 생각해 보면 당연합니다.

만약 K개의 랜선을 각각 X 길이로 잘라서 N개의 랜선을 만드는 것이 `가능`하다면 X보다 작은 길이로도 그것이 가능하고, K개의 랜선을 Y 길이로 잘라서 N개의 랜선을 만드는 것이 `불가능`하다면 Y보다 큰 길이로도 그것이 불가능하기 때문입니다.

만약 어떤 길이 L이 있어서 우리가 길이 L의 랜선을 N개 만들어서 문제 조건을 만족시킬 수 있다고 합시다. 그러면 L보다 작은 길이의 랜선을 N개 만드는 건 굳이 수학적 증명이 없이도 가능하다는 걸 쉽게 깨달을 수 있습니다. N개보다 많이 만드는 것도 N개를 만드는 것에 포함된다는 문제 조건이 있기 때문에~

그러므로 이 문제는 경계선을 나타내는 자연수보다 작거나 같으면 가능, 크면 불가능인 상황이고 그 '가능한 구간'의 최댓값을 찾는 문제입니다.

즉 이 문제와 같은 경우 가능한 구간의 상한인 `high`를 출력하면 되는 문제입니다(심지어 문제 설명에도 '최댓값을 구하라'고 친절하게 말해 줍니다).

![end-of-search](./end-of-search.png)

즉 입력을 제외한 랜선 자르기 문제에서 이분 탐색 부분만 따로 떼어서 적어보면 다음과 같습니다. `high`를 출력하면 됩니다.

```cpp
while(low<=high){
    ll mid=(low+high)/2;
    if(check(mid)){
        low=mid+1;
    }
    else{
        high=mid-1;
    }
}
cout<<high<<"\n";
```

반면 [1072번 게임](https://www.acmicpc.net/problem/1072)과 같은 문제에서는 `게임을 최소 몇 번 더 해야 Z가 변하는지` 즉 가능한 구간의 최솟값을 찾는 문제이므로 `low`를 출력해야 합니다.

## 3.3. 여담

이렇게 구간을 줄여나가는 아이디어를 통해서 할 수 있는 게 정말 많습니다. 구간합의 홀짝성이 달라지는 것을 이용해서 이분탐색을 한다든지, 아예 구간을 3개로 나눠서 극점을 찾는 삼분 탐색을 한다든지 아니면 자연수 대신 실수도 어쨌든 정렬되어 있다고 생각할 수 있으므로 이를 이분탐색한다든지 등등...

또한 가능 여부를 따지는 부분도 중요하지만 위에서는 그냥 check함수로 퉁쳤습니다. 이것도 사실 문제를 풀 때 엄청 어려운 포인트가 될 수도 있습니다. [1637번 날카로운 눈](https://www.acmicpc.net/problem/1637)같은 문제를 보면서 이분탐색을 바로 떠올리기는 쉽지 않고 판정 방식을 떠올리기도 쉽지 않습니다. 이런 부분들도 나중에 기회가 되면 쓰도록 하겠습니다.

# 4. 구간의 이해

제가 이분탐색을 처음 제대로 쓸 수 있게 된 건 `while(low<=high)`로 구현했을 때 `low`와 `high`가 어떤 값을 가리키는지를 이해하고 나서였습니다. 위에서 질리도록 본 이 그림과 비슷한 그림을 [Yun](https://blog.yuni.dev/)님이 보여주셨을 때 이해했습니다.

![탐색 끝났을 때](./end-of-search.png)

하지만 이후 `while(low<high)`혹은 `while(low!=high)`로 탐색을 구현하시는 분들도 많다는 걸 알게 되었고 이 부분에 대한 이해는 좀 더 많은 시간이 지나서야 할 수 있게 되었습니다. 그래서 이 부분도 설명하고자 합니다.

## 4.1. 기존 방식 - 닫힌 구간 탐색

위에서 보았던 코드를 다시 봅시다. 특정 자연수보다 작거나 같은 자연수에 대해서는 모두 가능하고 그보다 큰 자연수에 대해서는 모두 불가능한 A라는 기준이 있다고 할 때 해당 구간의 경계를 찾기 위한 코드입니다.

이 코드는 어떤 구간을 탐색하고, 어떤 구간으로 향할까요? `[low, high]`에 우리가 찾는 값이 있다고 했을 때 `mid`에서 A가 가능하면 `[mid+1, high]`로, 불가능하면 `[low, mid-1]`로 탐색 구간을 줄여나갑니다.

```cpp
while(low<=high){
  int mid = (low+high)/2;
  // A가 mid에서 가능하다
  if(check_A(mid)){
    low = mid+1;
  }else{
    high = mid-1;
  }
}
return high;
```

그리고 처음 탐색을 시작한 자연수 범위가 `[inf, sup]`라고 할 때 탐색 종료시 `[inf, high]`가 A가 가능한 범위가 되고 `[low, sup]`는 A가 불가능한 범위가 됩니다. 여기서 `low==high+1`입니다.

즉 모든 것이 닫힌 구간으로 돌아간다고 볼 수 있겠습니다.

## 4.2. 다른 방식 - 반열린 구간 탐색

다른 구현방식은 다음과 같습니다. 이 코드는 어떤 구간을 탐색하고, 어떤 구간으로 향할까요? `[low, high)`에 우리가 찾는 값이 있다고 했을 때 `mid`에서 A가 가능하면 `[mid+1, high)`로, 불가능하면 `[low, mid)`로 탐색 구간을 줄여나갑니다. 위와 달리 반열린 구간으로 따지는 것을 볼 수 있습니다.

```cpp
while(low<high){
  int mid = (low+high)/2;
  // A가 mid에서 가능하다
  if(check_A(mid)){
    low = mid+1;
  }else{
    high = mid;
  }
}
```

그리고 처음 탐색을 시작한 자연수 범위가 `[inf, sup)`라고 할 때 탐색 종료시 `[inf, high)`가 A가 가능한 범위가 되고 `[low, sup)`는 A가 불가능한 범위가 됩니다. 여기서 `low==high`입니다.

즉 탐색 종료 시 `low`, `high`가 모두 A의 가능/불가능을 가르는 경계에 위치하게 됩니다. `high`는 A가 가능한 반열린 구간의 상한을, `low`는 A가 불가능한 반열린 구간의 하한을 가리키는 것입니다.

즉 닫힌 구간으로 탐색할 시에는 `low`혹은 `high` 둘 중 하나가 정답이 되었다면, 이렇게 반열린 구간으로 탐색할 시 탐색 종료 시점에서 `low==high`이므로 문제 조건에 따라 `low` 혹은 `low-1`(물론 `high`나 `high-1`도 상관없다)를 출력해 줘야 합니다.

이런 반열린 구간 방식을 `while(low!=high)`와 같이 구현하는 분들도 있는데, 원리가 반열린 구간 탐색인 건 똑같으므로 더 설명하지는 않겠습니다.

## 4.3. 우열?

어떤 방식을 쓰는 게 더 좋을까? 딱히 정해진 건 없습니다. 각자가 처음 이해한 방식대로 쭉 간다고 봅니다. 통계적으로 따졌을 때 어느 방식이 좀 더 많이 쓰이고 있을 수는 있겠지만, 두 구현 모두 많은 고인물들이 각각 애용하고 있습니다. 고인물들이니까 다른 방식의 구현을 이해하지 못할 리는 없지만 뉴비 때부터 손과 머리에 익은 방식을 두고 굳이 바꿀 건 없으니까요.

저는 개인적으로 닫힌 구간으로 뭔가를 따지는 게 대부분의 경우 더 직관적이라고 생각하지만, 가령 n 길이의 배열에서 뭔가를 찾는다면 탐색 구간의 인덱스를 `[0, n-1]`로 잡는 것보다는 `[0, n)`으로 잡는 게 더 직관적이라고 생각합니다. 장단이 있는 거죠.

결국 이런 걸로 아무도 싸우지 않기 때문에 그냥 스스로가 더 편한 방식으로 쓰면 됩니다. 가령 세그먼트 트리 같은 자료구조는 닫힌 구간으로 구현하는 사람이 더 많은 게 명백하다고 보이는데, 아무도 반열린 구간으로 구현하는 사람에게 뭐라 하는 것을 보지 못했습니다.

따라서 이 글을 읽어 보고, 많은 참고자료도 보고 많은 문제를 풀어 보면서 스스로가 가장 잘 이해할 수 있는 방식대로 짜면 되겠습니다.

## 4.4. 계속 업데이트하기

혹은 아래와 같이 할 수도 있습니다.

```cpp
while(low<=high){
    ll mid=(low+high)/2;
    if(check(mid)){
        low=mid+1;
        ans=max(ans, mid);
    }
    else{
        high=mid-1;
    }
}
cout<<ans<<"\n";
```

이렇게 하면 무조건 가능 구간의 상한이 ans에 들어갑니다. 이분탐색 하는 동안 가능 구간의 상한 값이 ans에 한 번은 들어갈 수밖에 없기 때문입니다.

구간의 가능성이 반대라면 적당히 `ans=min(ans, mid)`으로 바꾸고 위치도 변경하면 됩니다. 원리를 생각하면 쉽게 할 수 있습니다. 이렇게 이분탐색을 다루는 분들도 몇 분 봐서 소개해 보았습니다.

## 4.5. 다른 구현 2

https://www.acmicpc.net/blog/view/109

# 5. 정리

이분 탐색의 핵심은 '한쪽 구간은 뭔가가 되고, 한쪽 구간은 안 된다. 따라서 어떤 한 값의 가능 여부를 알면 그 값을 기준으로 어떤 구간을 탐색할지 결정할 수 있다.'라는 것입니다.

그렇게 탐색 구간을 줄여가다 보면 결국 경계선을 찾을 수 있는데요. 이때 경계선을 찾는 while문이 언제 종료되는지를 따져 보면 우리는 high와 low중 어떤 값이 필요한지를 알 수 있습니다. 닫힌 구간으로 구현하건 반열린 구간으로 구현하건 마찬가지입니다.

우리가 어떤 가능성을 따지고 있는지, 그리고 while문이 어떤 조건일 때 종료될지를 생각하며 이분 탐색에 접근합시다.

그리고 반대로, 어떤 값을 경계로 어떤 기준의 가능/불가능 여부가 바뀐다면(x보다 작거나 같은 값에 대해서는 문제 조건이 가능한데, x보다 크면 안 되고 이때의 x값을 찾아라~하는 식, 혹은 문제를 잘 생각해 보면 그런 문제로 환원시킬 수 있는 문제)이분 탐색을 한번 생각해 봅시다.

![final](./final-description.png)

# 참고

이분탐색 실수없이 짜기
https://blog.fiene.dev/2023/01/16/binary-search.html