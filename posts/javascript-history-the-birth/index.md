---
title: JS 탐구생활 - JS는 왜 그 모양일까? 그 첫걸음
date: "2024-01-10T00:00:00Z"
description: "자바스크립트는 어떤 길을 걸어왔을까. 그 첫걸음에 대하여"
tags: ["javascript"]
---

# 이 글은 현재 작성 중입니다.

# 썸네일

![자바스크립트는 못말려](./js-weird.png)

# 서론

> 최고의 시절이자 최악의 시절, 지혜의 시대이자 어리석음의 시대였다. 믿음의 세기이자 의심의 세기였으며, 빛의 계절이자 어둠의 계절이었다. 희망의 봄이면서 곧 절망의 겨울이었다.
> 우리 앞에는 모든 것이 있었지만 한편으로 아무것도 없었다. 우리는 모두 천국으로 향해 가고자 했지만 우리는 엉뚱한 방향으로 걸었다.
> 말하자면, 지금과 너무 흡사하게, 그 시절 목청 큰 권위자들 역시 좋든 나쁘든 간에 오직 극단적인 비교로만 그 시대를 규정하려고 했다.
>
> 찰스 디킨스 저, 이은정 옮김, '두 도시 이야기', 펭귄클래식코리아, 13쪽

누가 뭐래도 자바스크립트는 웹을 지배하고 있다. 자바스크립트를 싫어하는 사람이라도 자바스크립트 그리고 거기서 파생된 수많은 것들이 웹에 끼치고 있는 영향력을 무시할 수는 없다. 하지만 그런 것 치고 자바스크립트에는 이상한 부분들이 많다.

자동 형변환 규칙이라든지 `==`연산자 등 자잘한 이상한 동작부터 프로토타입 상속이나 클로저 같은 언어 설계에 해당하는 부분들까지, 자바스크립트에는 온통 낯설고 이상한 것 투성이다.

글에서 다룰 내용은 아니지만 [이상한 나라의 JS](https://zerolog.vercel.app/posts/weird-js)나 [What is the oddest javascript behavior?](https://dev.to/ben/what-is-the-oddest-javascript-behavior-4dh2)같은 글을 참고하면 수많은 자바스크립트의 이상한 동작들을 볼 수도 있다.

그럼 자바스크립트는 어쩌다 이렇게 만들어졌을까? Python이나 Java 같은 다른 주류 언어들도 각자 수많은 비판을 받고 있다. 하지만 이 정도로 우리에게 낯설고 이상해 보이지는 않는다. 왜 그럴까? 바보들이 만들었나?

하지만 자바스크립트의 창시자 브랜든 아이크는 당연히 바보가 아니었다. 그에게도 이렇게 언어를 만들게 된 이유 그리고 이렇게 만들 수밖에 없었던 이유들이 있다. 지금 시점에서 모든 것을 알 수는 없지만, 역사와 함께 몇 가지 선택의 이유들 정도는 알아볼 수 있다.

이런 것들을 궁금해하는 사람들은 많은 데에 비해 자료는 별로 없다고 느꼈다. 그래서 되는 대로 끌어모아 글을 써본다. 다음에는 누군가 나보다 더 뛰어난 사람이 더 좋은 글을 쓰는 데에 조금이라도 기반이 되었으면 좋겠다.

후속 글도 언젠가 쓰겠지만(빨리 쓰고 싶은 마음은 굴뚝같지만 쉽지 않다), 지금 이 글에서는 다음과 같은 것들을 다루고자 한다.

1. 자바스크립트가 만들어질 당시의 상황
2. 자바스크립트의 초기 설계시 중요하게 여겨진 부분들
3. 자바스크립트가 만들어질 때 영향을 받은 언어들
4. 자바스크립트 초기의 자잘한 이야기와 실수들

# 1. 자바스크립트 제작 이전의 상황

> 넷스케이프는 웹이 더 동적이어야 함을 빨리 깨달았습니다.
>
> 악셀 라우슈마이어 저, 한선용 옮김, '자바스크립트를 말하다' 97쪽, '자바스크립트는 어떻게 만들어졌는가?

## 1.1. 브라우저의 등장

1989년에서 1991년 사이에 팀 버너스-리가 개발자라면 한번쯤 들어보았을 HTML을 만들었다. 그리고 이 HTML로 만들어진 페이지를 볼 수 있는 브라우저 WorldWideWeb도 제작하여 배포했다.

하지만 당시에는 별로 큰 주목을 받지 못했다. 이것이 주목받기 시작한 건 1993년 1월 마크 앤드리슨과 에릭 비나가 만든 웹브라우저 모자이크가 출시되면서였다.

모자이크 브라우저는 기술적인 지식이 없는 사람들도 쉽게 사용할 수 있었고 윈도우즈를 지원했다. 그리고 사진 등의 멀티미디어를 페이지 내에서 볼 수 있었다. 기존 브라우저에서는 이미지 등의 멀티미디어를 보기 위해서 링크를 클릭하여 새 창에 이미지를 띄워야만 했다.

이런 여러 장점을 갖췄던 모자이크는 초기 웹이 널리 퍼져나가는 데에 큰 역할을 했다. 이 모자이크 브라우저를 개발한 리드 개발자들은 곧 인터넷의 역사에서 꽤나 자주 등장하는 넷스케이프를 설립한다.

넷스케이프는 1994년 12월 더 세련된 브라우저인 넷스케이프 네비게이터 1.0을 출시했다. 이는 빠르게 모자이크를 대체하고 주류가 되었다.

## 1.2. 브라우저에 멀티미디어 넣기

이제 웹 브라우저에서 HTML로 만들어진 문서를 보고 공유할 수 있게 되었다. 이는 엄청난 혁신이었다. 그러나 넷스케이프는 영리 기업이었기에 초기의 웹에 가치를 더하여 뭔가 돈을 벌 방법을 찾아야 했다.

그렇게 하기 위해서는 웹의 콘텐츠가 풍부해져야 했다. 그리고 그걸 위해서는 당연하게도 웹에서 멀티미디어를 잘 볼 수 있도록 해야 했다.

이는 1993년 이미 마크 앤드리슨이 모자이크를 만들 때부터 고려되었다. 그는 그때부터 이미지를 페이지에 삽입하여 보여주는 `<img>` 태그를 HTML 표준으로 제안하기도 했다. 그리고 1993년 마크 앤드리슨은 HTML 표준에 `<img>`가 들어가지 않았음에도 모자이크에 해당 기능을 포함시켰다. 모자이크는 그렇게 멀티미디어를 인라인으로 삽입할 수 있다는 장점과 함께 널리 퍼졌다.

그 다음에는 무엇을 해야 했을까? 당시에는 웹 페이지가 정적인 문서로만 존재했다. 이를 사용자와 상호작용할 수 있도록 하는 게 문제였다. 이 문제는 우리가 모두 아는 자바스크립트가 등장함으로써 해결된다.

하지만 당시에 넷스케이프는 그 문제에 당장 착수할 수 없었다. 당시에는 웹의 속도가 끔찍하게 느렸기에, 이런 환경 하에서 브라우저가 기본적인 멀티미디어를 더 잘 다룰 수 있게 하는 데에 집중해야 했기 때문이다. 당시 넷스케이프 1.0 브라우저에서는 사용자가 보려는 이미지를 로딩하는 동안 텍스트를 먼저 보여주는 최적화 등의 작업이 진행되었다.

## 1.3. 동적인 웹을 향해서

1995년 즈음에는 웹에서 멀티미디어를 다루는 작업이 어느 정도 안정되었다. 그래서 이제 넷스케이프는 웹에서 멀티미디어를 다루는 걸 넘어 웹 페이지와 사용자의 상호작용이 가능하도록 만들고자 했다. 넷스케이프의 창립자 마크 앤드리슨 또한 웹이 더 동적으로 동작해야 한다고 꾸준히 생각했다.

이 시기의 웹페이지들은 페이지가 로드되고 나면 서버와의 상호작용 없이는 동적으로 뭔가를 할 수 없었다. 당시에는 사용자가 폼에 입력한 값을 검증할 때조차도 서버에 데이터를 보내고 피드백을 받아야 했다!

당시의 HTML만으로는 페이지가 동적으로 움직이고 사용자와 제대로 상호작용하는 게 불가능했다. 웹 페이지에 동적인 무언가를 넣을 수 있게 해줄 언어가 필요했다. HTML에 프로그래밍 언어를 삽입할 수 있도록 해야 했다. 

이제야 새로운 언어, 우리가 아는 자바스크립트의 이야기가 나온다.

# 2. 자바스크립트가 나오기까지

> 이미 잘 알려져 있겠지만 1995년 5월, 나는 '자바와 비슷해야 하고', '초보자에게도 쉬워야 하며', '넷스케이프 브라우저 내의 거의 모든 것을 제어할 수 있어야 한다'는 강압적이고도 강제적인 관리 명령하에 열흘 만에 자바스크립트를 만들었다.
>
> 데이비드 허먼 저, 김준기 옮김, '이펙티브 자바스크립트'에 실린 브랜든 아이크의 추천사

## 2.1. 아이크의 등장

넷스케이프는 네비게이터 브라우저에 동적인 기능을 추가할 수 있는 언어를 구현하기로 했다. HTML에 프로그래밍 언어 소스를 임베딩할 수 있게 하려고 한 것이다.

그리고 1995년 4월 브랜든 아이크를 고용했다. 그가 Silicon Graphics Inc.와 MicroUnity라는 회사에서 "커널과 네트워크 작업을 할 수 있는 작은 특수목적 언어"를 만들어 본 경험이 있기 때문이었다.

하지만 아이크가 처음부터 새로운 언어를 만들고자 한 건 아니었다. 그는 기존 언어인 Scheme을 브라우저에 구현하겠다고 생각하고 있었다. 넷스케이프에서도 그렇게 하라는 이야기를 했다.

왜 Scheme이었는가 하면, 아이크가 Silicon Graphics Inc. 소속일 때 닉 톰슨이라는 사람이 아이크에게 SICP를 추천하여 읽게 했다고 한다. 그게 매우 감명깊었던 아이크는 리스프의 방언 중 하나인 Scheme을 사용할 언어로 택했다. SICP는 표지의 마법사 그림을 따서 "마법사책"이라고도 불리는 프로그래밍 계의 고전인데 리스프로 쓰여 있다.

리스프의 방언이었던 Scheme은 매우 문법이 가벼웠고 동적이었으며 강력했고, 함수를 일급 객체로 다루는 함수형 패러다임을 받아들이고 있었다.

## 2.2. 상황의 전개

> "Netscape plus Java kills Windows."
>
> Marc Andreessen, 1995, 넷스케이프 회의

아이크는 1995년 4월 3일 넷스케이프의 클라이언트 팀으로 고용되었다. 하지만 고용되자마자 웹 서버와 프록시 제품들을 만드는 서버 그룹으로 옮겨져서 차세대 HTTP 관련 설계를 만드는 일을 한 달 정도 했다. 그래서 바로 웹에 필요한 스크립트 언어를 만드는 데 착수할 수 없었다.

그렇게 아이크가 자바스크립트를 만드는 작업을 시작하지 못하고 있는 동안 당시의 소프트웨어 회사들 간의 경쟁은 상황을 약간 다른 구도로 끌고 간다.

넷스케이프는 1994년 말 마이크로소프트의 저가 인수 제안을 거절했다. 이후 넷스케이프 경영진은 마이크로소프트에게 직접적으로 공격받을 것으로 예상했고 따라서 먼저 웹 시장을 선점하려고 했다. 이를 위해서 썬 마이크로시스템즈와 손을 잡는다.

1995년 5월 23일 썬 마이크로시스템즈는 그 유명한 Java를 발표했다. 그리고 넷스케이프는 이 Java를 네비게이터 브라우저에서 사용할 수 있도록 하겠다는 발표를 했다. 이는 당시 마이크로소프트에 대항하기 위한 공동 전선이었다. 넷스케이프 창립자 마크 앤드리슨은 회의에서 "넷스케이프와 자바가 합쳐지면 윈도우를 이깁니다"라고 외쳤다.

여담이지만 지금 상황을 보면 알 수 있듯이 이런 시도들은 자바스크립트만 빼고 모두 실패하였다. 넷스케이프는 IE에 졌고 Java Applet은 실패했다. 자바스크립트만 남아서 지금의 웹을 이끌고 있다.

그래서 브라우저에 넣을 언어에 대한 계획은 변경되었다. 사업 계획이나 출시 기간을 고려하면 Scheme, Python, Perl, Tcl같은 기존의 언어를 브라우저에 넣는 것은 불가능했다. 따라서 넷스케이프의 마크 앤드리슨과 썬의 빌 조이 등 "높으신 분들"은 Java를 보완하는 작은 스크립트 언어를 설계하고 구현하기로 했다.

## 2.3. 초기의 토론

당시 넷스케이프 내부에서는 열띤 토론이 있었다. Java를 브라우저에 넣을 것인데 다른 언어가 왜 필요하냐는 것이었다. 이런 주장을 하는 사람들은 썬과 넷스케이프의 주류였는데 그들의 의문은 이랬다.

1. Java는 브라우저에서 쓰일 스크립트 언어로 부적합한가?
2. 왜 2개의 언어가 굳이 필요한가?
3. 넷스케이프가 새로운 언어를 만들 만큼의 전문성이 있는가?

첫번째 의문은 쉽게 반박되었다. Java는 물론 지금도 주류를 차지하고 있을 만큼 좋은 언어다. 하지만 2024년 현재까지도 상대적으로 '쉬운 언어'의 포지션은 아니다. 하지만 브라우저에서는 누구나 간단하게 쓸 수 있는 스크립트 언어가 필요하다는 공감대가 있었다. 하지만 Java는 대부분의 웹 구성원들이 간단하게 사용하기에는 너무 복잡했다.

Java를 쓰려면 클래스와 메서드를 알아야 했고 타입과 변수, 리턴값에 대한 개념 등등이 모두 필요했다. 다음 코드는 Java로 Hello World를 출력하는 코드인데, 이 간단한 작업을 하는 코드조차 제대로 읽기 위해서는 클래스, 메서드, 패키지, 타입과 변수 등의 개념을 모두 알아야 한다.

```java
// Java로 Hello World 출력하기
import java.util.*;

public class Main{
	public static void main(String args[]) {
    System.out.println("Hello World!");
	}
}
```

따라서 넷스케이프는 더 가볍고, 배우기 쉬운 스크립트 언어가 필요하다고 판단했다. 지금도 Python등의 언어가 스크립트 언어라는 이유로 배우기 쉽다고 여겨지는데, 당시에도 가볍고 쉬운 언어를 위해서는 스크립트 언어가 트렌드였다고 한다.

두번째 의문은 경쟁자였던 마이크로소프트의 제품 전략을 인용하는 것으로 해결되었다. 당시 마이크로소프트는 전문 프로그래머들에게는 C++을, 아마추어나 디자이너 등 비전문가들에게는 Visual Basic을 제공하고 있었다. 즉 C++로 작성된 웹 컴포넌트들을 조립해 사용하기 위한 접착제 언어(원문은 `glue language`)로써 Visual Basic이 존재했던 것이다.

새로 만들어질 스크립트 언어 또한 Visual Basic과 비슷한 포지션이 될 것으로 보였다. 즉 새로 만들어질 스크립트 언어는 이미지나 플러그인, Java Applet 등으로 작성된 컴포넌트를 사용해서 컨텐츠를 만들 디자이너나 파트타임 프로그래머들을 위한 "초보자용" 언어였다.

Java와 자바스크립트를 마이크로소프트의 C++(전문 프로그래머를 위한 어려운 언어)과 Visual Basic(비전문가를 위한 쉬운 언어)에 대응되는 존재로 만들고자 한 것이다. 빌 조이(썬의 공동 창립자) 또한 그 아이디어에 동의했다.

이때 넷스케이프의 경영진들은 새로운 스크립트 언어는 Java의 보완재 같은 역할이므로 Java와 비슷한 문법을 가져야 한다고 결정했다. 이는 Perl, Python, TCL, Scheme과 같은 기존 언어들을 도입하는 선택지를 배제하도록 했다.

결국 이 토론은 Java와 새롭게 브라우저에 들어갈 언어가 서로 다른 목적을 가지고 있었기 때문으로 결론이 났다.

브라우저의 Java는 C++이나 Java를 기존에 사용했던 웹 컴포넌트 제작자들을 위한 언어였고, 브라우저에 들어갈 새로운 언어는 웹 디자이너와 같은 비전문가들을 위한 언어였던 것이다.

하지만 아직 세번째 의문이 남았다. 넷스케이프가 새로운 언어를 만들 만큼의 전문성이 있는가? 1995년 9월 출시될 넷스케이프 네비게이터 2.0에 새로운 언어가 들어갈 수 있겠는가?

이건 브랜든 아이크가 Mocha(당시 마크 앤드리슨이 지은 이름)를 만듦으로써 직접 증명해내야 했다.

## 2.4. 새로운 언어의 개발

아이크가 개발할 언어는 이제 Scheme과 비슷하면 안 되었다. 새로운 언어의 중요한 요구사항은 바로 '자바와 비슷해야 한다'는 거였다. Java의 보완재 역할을 해야 했기 때문이다.

하지만 그건 Java처럼 클래스 기반이 아니라 객체 기반이어야 했고 너무 고평가되면 안 되었다. 홍보를 위해서 Java와 비슷하면서도 약간 모자라 보여야 했다.(원문: `it needed to be a silly little brother language.`)

그런데 아이크에게는 시간이 없었다. 넷스케이프 네비게이터 2.0은 1995년 9월에 출시되어야 했고 새로운 스크립트 언어는 그 브라우저에 들어가야 했다. 즉 1995년 9월 전에 완성되어야 했다.

또한 이 새로운 스크립트 언어는 브라우저 개발에서 그렇게 우선순위가 높은 작업도 아니었기 때문에 시간도 많이 주어지지 않았다. 그래서 아이크는 1995년 5월, 단 10일만에 새로운 스크립트 언어의 프로토타입을 만들었고 이는 네비게이터 2.0의 프리알파 버전에 데모로 들어갔다.

해당 언어의 처음 이름은 Marc Andreessen이 지은 "Mocha"였다. 그리고 넷스케이프의 홍보팀은 잠재적인 상표권 충돌의 가능성을 보고 이후에 "LiveScript"로 이름을 바꾸었다. 당시 넷스케이프에서 내놓은 다른 제품들의 이름도 "Live"로 시작하기도 했다.

그 뒤 9월까지 아이크는 새로운 언어를 개선하고 네비게이터 2.0에 들어갈 수 있도록 준비했다. 그리고 1995년 9월 넷스케이프 네비게이터 2.0이 출시되었다. 여기에는 아이크의 새로운 언어가 LiveScript라는 이름으로 들어갔고 12월 초에 LiveScript는 자바스크립트로 이름이 바뀌었다.

참고로 새로운 언어의 이름이 결국 자바스크립트가 된 건 잘 알려진 대로 Java의 인기를 빌려서 인기를 얻기 위해서였다. 1995년 Java는 새로나온 핫한 언어였고 넷스케이프와 썬 마이크로시스템즈는 그 유명세를 이용하기로 한 것이다.

1995년 12월의 넷스케이프와 썬의 보도자료에서도 자바스크립트를 "객체 스크립트 언어"이면서 "Java 객체의 프로퍼티와 동작을 동적으로 수정할 수 있고" "쉬운 온라인 어플리케이션 개발을 위한 Java의 보완재"라고 소개하는 등 Java와의 연관성을 강조했다.

# 3. 자바스크립트 초기 설계의 핵심 고려사항들

> 아주 자랑스럽지는 않지만 Scheme과 같은 일급 함수와 Self와 같은 프로토타입(하나뿐이긴 하지만)을 자바스크립트의 주요 요소로 선택한 것에 만족한다. Java의 영향, 특히 y2k 버그, 원시값과 객체의 구분(예를 들어 string과 String)과 같은 부분은 아쉬운 부분이다.
>
> [Brendan Eich, Popularity](https://brendaneich.com/2008/04/popularity/)

앞서 언급했듯 아이크는 1995년 5월, 단 10일만에 자바스크립트의 프로토타입(당시 이름은 Mocha)을 만들었다. 그리고 이후 9월까지 브라우저에 Mocha를 통합하고 프로토타입을 다듬어야 했다. 매우 촉박한 시간이었다.

그래서 아이크는 본인이 생각하는 중요한 사항을 빼면 나머지는 매우 유연하게 만들었다. 아이크는 자신이 자바스크립트를 이렇게 유연하게 만들어 놓으면 내장 라이브러리 등은 날림으로 해두어도 다른 개발자들이 수정하리라고 생각했다. 실제로 자바스크립트의 내장 라이브러리는 초기에 날림으로 만들어진 게 많다.

여담이지만 이런 이유로 자바스크립트는 빌트인 객체를 포함해서 모든 객체들의 수정을 거의 허용한다. `Object.prototype`과 같은 객체들을 수정할 수 있는 것도 이런 설계 때문이다. 이는 폴리필을 만들 수 있는 기반이 되기도 한다.

그런데, 그럼 아이크가 언어를 만들 때 생각했다는 그 '중요한 사항'들은 무엇인가? 열흘간의 촉박한 프로토타이핑 기간 속에서도 양보할 수 없었던 건 무엇이었을까? 그 중요한 사항 2가지는 Self의 프로토타입 기반의 객체지향 시스템과 Scheme에서 온 일급 객체 함수의 개념이었다. 

이 두 가지는 자바스크립트 창시자 브랜든 아이크의 여러 인터뷰와 발표에서도 '자바스크립트에서 잘 만든 부분'으로 자주 언급된다(물론 급하게 만드는 과정의 실수는 있었다고 인정하지만). 그래서 그 두 가지가 어떤 의미와 과정을 통해서 도입되었는지 알아보고자 한다.

이외에도 자바스크립트는 여러 언어들에서 영향을 받았지만 그 부분에 대해서는 다음 섹션 `#4`에서 다룬다.

## 3.1. 프로토타입

> 표현은 삶의 흐름 속에서만 의미를 갖는다 — 비트겐슈타인

프로토타입은 자바스크립트에서 객체지향을 구현하는 방식이다. 클래스 언어를 사용해본 사람들에게 이는 매우 낯선 부분이다. 그래서 이후 ES6에서 클래스가 추가되기도 했다.

하지만 프로토타입은 분명 그 당시로서는 자바스크립트에 들어갈 만한 기능이었다. 프로그래밍 초보자를 위한 언어였던 자바스크립트의 목적성에 비해 클래스 기반의 객체지향은 너무 복잡했기 때문이다.

프로토타입의 철학적 배경에 관해서는 [자바스크립트는 왜 프로토타입을 선택했을까](https://medium.com/@limsungmook/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%99%9C-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%84-%EC%84%A0%ED%83%9D%ED%96%88%EC%9D%84%EA%B9%8C-997f985adb42)라는 아주 유명한 글이 있다.

다 맞는 이야기는 아니지만, 철학적 배경에 대해서는 앞의 글을 참고할 수 있다. 여기서는 좀더 실질적인 이야기를 해보려고 한다.

### 3.1.1. 클래스 모델링의 어려움

클래스는 Simula라는 언어에서 객체지향을 모델링하는 방식으로 처음 도입되었다. 그리고 이후 Smalltalk, C++, Java 등의 언어에서도 사용되었다.

하지만 문제는 클래스를 사용하는 게 본래부터 어렵다는 것이었다. 지금도 클래스 모델링이 얼마나 많은 사람들의 머리를 아프게 하고 있을지 상상도 가지 않는다. 왜냐 하면 클래스를 모델링한다는 것은 `이 객체의 본질이 무엇인가?`라는 질문을 던지도록 하기 때문이다.

예를 들어서 '동물'을 클래스로 모델링한다고 해보자. 확장 가능하고 동물의 본질적인 요소들을 갖춘 클래스는 어떻게 짤 것인가? 예를 들어서 다음과 같이 짜볼 수 있다. Java 코드이다.

```java
public class Animal {
    // 멤버 변수 (속성)
    private String name;

    // 생성자
    public Animal(String name) {
        this.name = name;
    }

    // 이름을 가져오는 메소드
    public String getName() {
        return name;
    }

    // 이름을 설정하는 메소드
    public void setName(String name) {
        this.name = name;
    }

    // 동물이 걷는 행동을 시뮬레이션하는 메소드
    public void walk() {
        System.out.println(name + " is walking.");
    }
}
```

이 코드에는 문제가 있다. 물고기와 같이 걷지 못하는 동물도 있는데 `Animal` 클래스는 `walk` 메서드를 가지고 있기 때문이다.

물론 이런 문제를 해결하는 법은 여러 가지 있다. 걷기 메서드가 있는 `LandAnimal`로 클래스를 바꿀 수도 있고 `walk` 메서드를 삭제할 수도 있다. 하지만 만약 이 상태로 많은 인스턴스가 만들어져 있다면 이런 문제를 해결하기가 매우 어려울 것이다.

문제는 결국 '클래스를 잘 모델링할 수 있어야 한다'는 것이다. 어떤 객체의 본질이라는 걸 찾아서 클래스를 모델링하기가 쉽지 않음에도 말이다. 프로토타입을 사용하면 이런 문제를 해결하거나 최소한 쉽게 가릴 수 있다.

### 3.1.2. 프로토타입

프로토타입은 상위 클래스를 상속하는 것이 아니라 상위 객체에 동작을 '위임'하는 방식으로 동작한다. 따라서 객체를 런타임에 수정함으로써 프로토타입이 새 객체에 적합하지 않다면 다른 모든 하위 인스턴스와 먼저 사용된 코드에 영향을 주지 않고도 수정할 수 있다.

위의 `Animal` 클래스도 프로토타입에 기반한 객체 모델을 사용하면 다음과 같이 만들 수 있다.

```js
var animal = {
  // getName 메서드, setName 메서드 생략

  walk: function() {
      console.log(this.name + ' is walking.');
  }
};

// animal 객체를 프로토타입으로 사용하는 새로운 객체를 만든다.
var cat = Object.create(animal);
cat.name = 'Nabi';
cat.meow = function() {
  console.log(this.name + ' says Meow!');
};
cat.walk();
cat.meow();
```

그런데 여기서는, 위의 `Animal` 클래스가 겪는 문제를 좀더 쉽게 해결할 수 있다. `Animal` 클래스를 프로토타입으로 하는 `fish` 객체를 만들 때 `walk` 메서드를 삭제하면 된다.

```js
// animal 객체의 walk 메서드를 수정하여 fish 객체 사용시에는 walk 메서드가 없도록 한다
// Object.assign등으로 animal 객체를 복제함으로써 더 안전하게 작성하는 것도 가능
delete animal.walk;
var fish = Object.create(animal);
fish.name = 'Goldfish';
console.log(fish);
```

예시를 통해서 길게 이야기했지만, 프로토타입 기반의 객체지향이 클래스 기반의 객체지향보다 상대적으로 '바로 사용하기' 쉽다는 것을 알 수 있다. 무언가를 잘 모델링하기 위한 추상적인 생각을 하지 않아도 되기 때문이다.

자바스크립트는 역사적으로 아마추어를 위한 언어로 만들어졌기 때문에 이렇게 쉽게 사용할 수 있어야 했다. 따라서 상대적으로 쉽게 사용할 수 있는 프로토타입 기반 객체 모델을 선택했다.

### 3.1.3. Self의 영향

이런 프로토타입 기반의 객체 모델은 프로토타입 기반의 객체지향을 구현한 Self라는 언어의 영향을 받았다.

Self도 자바스크립트의 프로토타입 체인과 같은 방식으로 동작한다. Self에서도 각 객체가 프로토타입 객체의 참조를 가지고 있었고 그 참조를 통해 프로토타입 객체의 기능을 사용할 수 있었다. 이걸 자바스크립트에서는 약간 변형해서 구현했다.

지금은 정말 Self와 자바스크립트의 프로토타입 체인이 비슷한 방식으로 동작하지만, 당시에 프로토타입 객체는 객체를 생성한 생성자 함수의 `prototype` 프로퍼티를 통해서 간접적으로 접근되었다. 이는 Self에서 프로토타입 객체를 참조하는 링크와 비슷하다.

물론 자바스크립트는 Java를 보조하는 언어로 포지셔닝되었었기 때문에 자바스크립트의 초기 문서에는 이런 프로토타입 기반의 객체지향 이야기가 나오지 않는다. 하지만 생성자 함수의 `prototype` 프로퍼티의 작명 등에서 Self와 프로토타입 기반 객체 모델의 영향을 엿볼 수 있다.

### 3.1.4. 프로토타입 선택의 다른 이유

아이크는 Self언어에서 도입된 프로토타입 개념을 매우 선호했다. 그리고 비전문가들이 Java 등으로 만들어진 웹 컴포넌트들을 사용하는 데에 쓰일 언어로 계획된 자바스크립트에서 객체지향에 대한 훈련이 필요한 클래스 기반의 구현은 적합하지 않았다. 

그래서 프로토타입 기반의 객체지향을 선택했다. 하지만 그 이외에 다른 이유도 있었다.

먼저 자바스크립트가 도와야 할 언어였던 Java가 이미 클래스 기반이었다. 때문에 자바스크립트도 클래스 기반의 객체지향을 사용한다면 Java와 경쟁하게 되었을 것이다. 프로토타입 기반의 객체지향을 사용하면 Java와 경쟁하지 않고도 Java의 보완재 역할을 할 수 있었다.

또 계속 언급되었듯이 아이크에게는 시간이 얼마 없었는데, 프로토타입은 클래스보다 구현하기가 쉬웠다. [또한 수많은 내장 라이브러리와 빌트인 메서드들을 사용자가 직접 prototype을 통해 수정할 수 있게 함으로써 자바스크립트 언어를 최소화할 수도 있었다.](https://brendaneich.com/2005/06/javascript-1-2-and-in-between/)

그래서 자바스크립트는 단일 프로토타입을 기반으로 하는 동적 객체 모델로 시작한다.

## 3.2. 일급 객체 함수와 클로저

> A closure is a procedure that records what environment it was created in.
>
> An Introduction to Scheme and its Implementation, The University of Texas at Austin


> 자바스크립트의 함수는 어휘적 유효범위를 가진 일급 객체입니다. 또한 주류가 된 첫번째 람다 언어며, 좀더 깊이 들어가면, 이름처럼 자바에 가깝기보다는 Lisp 언어 그리고 Scheme 언어와 더 많은 공통점이 있습니다. 자바스크립트는 C의 옷을 입은 Lisp이라고 할 수 있습니다.
>
> 더글러스 크록포드 저, 김명신 옮김, '자바스크립트 핵심 가이드', 14쪽

자바스크립트에서는 함수를 프로그램의 다른 객체와 똑같이 취급한다. 이 개념을 일급 객체 함수라고 하는데 이는 앞서 언급한 프로토타입과 함께 브랜든 아이크가 자바스크립트에서 잘 만들었다고 자부하는 기능이다.

그런데 지금은 Python, Ruby, Kotlin 등의 언어에서도 일급 객체 함수와 클로저를 지원하고 일급 객체 함수 개념도 유명해졌다. 하지만 당시에 이런 개념은 그렇게 대중적이지 않았다. 그럼 왜 자바스크립트는 이 개념을 도입했을까?

### 3.2.1. 일급 객체 함수와 Scheme

이 일급 객체 함수 개념은 Scheme에서 왔다. 브랜든 아이크의 원래 목표는 앞서 언급했듯 Scheme을 브라우저에 구현하는 것이었다. 상황상 그럴 수 없었지만 아이크는 Scheme에서 제시한 일급 객체 함수 개념이 좋다고 생각했고 자바스크립트에 도입했다. 그리고 Scheme은 그때 일급 객체 함수를 핵심적으로 도입한 얼마 안 되는 언어였다.

일급 객체 함수 도입은 Scheme에 있는 다른 개념들도 자바스크립트에 같이 가져왔다. 일급 객체 함수가 도입됨으로써 함수가 일반적인 다른 객체들과 같이 다루어지는 것이 가능해졌고 클로저, 함수를 인수로 넘기는 것, 객체 메서드, 이벤트 핸들러 등이 가능해진 것이다. 함수 표현식 또한 일급 객체 함수 덕분에 가능해졌다.

클로저 또한 일급 객체 함수를 통해서 가능해졌다. 일급 객체 함수 개념을 통해 함수가 함수의 반환값이 되는 게 가능해졌고 따라서 함수가 자신이 생성된 환경을 기억할 수 있게 된 것이다. 다음의 `makeCounter` 함수에서 반환하는 함수는 클로저에 들어간 `count` 변수를 기억하고 증가시키는 기능을 한다.

```js
function makeCounter() {
    var count = 0;
    return function() {
        return count++;
    };
}
```

--- 이 부분 작성 중 ---





# 4. 자바스크립트에 영향을 준 다른 언어들

또 자바스크립트는 여러 언어들에서 영향을 받았다. 이는 "Java와 비슷해야 한다"는 요구사항을 제외하면 아이크에게 다른 언어적 세부사항들을 정할 수 있는 권한이 있었고 자바스크립트의 고유한 무언가를 제대로 만들 시간도 없었기 때문이다. 따라서 자바스크립트는 Scheme, Self, Java, HyperTalk, Perl, Awk, Python등 여러 언어의 영향을 받았다. 각 언어의 영향은 바로 다음 섹션부터 다룬다.

## 4.1. Scheme

브랜든 아이크는 원래 Scheme을 브라우저에 구현하려고 했으나 상황상 Scheme을 브라우저에 구현할 수는 없었다. 하지만 아이크는 여전히 일급 객체로서의 함수 개념을 매력적으로 생각했다.

메서드를 포함하는 클래스 문법이 없는 상태에서 자바스크립트에 도입한 일급 함수 개념은 Scheme에서 영향을 받은 여러 도구들을 제공했다.

top-level 프로시저, 함수를 인수로 넘기기, 객체 메서드, 이벤트 핸들러 등이다. 함수 표현식은 시간 관계상 극초기 구현에서는 미루어졌지만 예정 사항으로 들어가 있었다.

즉 Scheme은 자바스크립트가 함수를 일급 객체로 다루는 것과 클로저에 영향을 주었다. 하지만 구문상의 영향은 거의 없었다. [딱 '일급 객체로서의 함수'와 거기서 파생된 클로저 등 몇몇 개념에만 영향을 주었다.](https://www.quora.com/Is-자바스크립트-like-Scheme-If-so-are-there-some-use-cases-that-show-자바스크립트-being-used-for-similar-problems-and-with-similar-style-as-Scheme)

## 4.2. Self

프로토타입은 Self의 영향이다. 당시 Mocha는 객체 기반의 언어가 되어야 한다고 모두 생각했다. 하지만 그것이 클래스 모델을 통해서 이루어지면 안됐다. 클래스가 있으면 구현도 오래 걸리고 같은 클래스 모델을 사용하는 Java와 경쟁해야 했을 것이기 때문이다.

따라서 아이크는 프로토타입 기반의 객체지향 시스템을 만들기로 했고 이는 Self에서 영향을 받았다. 그렇게 자바스크립트는 단일 프로토타입을 기반으로 하며 프로토타입 체인을 통한 위임을 사용하는 언어로 시작한다.

## 4.3. Java

자바스크립트의 전신인 Mocha가 만들어질 때 마크 앤드리슨은 Mocha가 누구나 HTML 문서에 몇 줄쯤 직접 작성할 수 있을 정도로 쉬워야 한다고 했지만 또 Java와 비슷해 보여야 한다고 계속 강조했다. 그러면서 BASIC같은 언어의 영향은 명시적으로 배제했다.

이런 Java와 비슷해 보여야 하는 외형적인 요구사항은 자바스크립트에 Java의 동작 또한 녹아들게 했다. 예를 들어서 boolean, int, double, string과 같은 원시 타입의 의미는 Java의 영향이다. 또한 자바스크립트에서 원시값과 객체를 나누는 것도 Java에서 왔다.

자바스크립트의 Date 생성자는 Java의 `java.util.Date`가 자바스크립트에 거의 그대로 들어온 것이다. 이때 급하게 만드느라 거기의 Y2K 버그도 같이 들어왔다.

그리고 함수가 어떤 객체에서 메서드로 호출되었는지에 대한 문맥을 나타내기 위해서 사용되는 `this`키워드도 Java에서 빌려왔다. 물론 자바스크립트에는 클래스가 없었으므로 용법은 달랐고 키워드만 빌려온 것이다. 이벤트 핸들러와 객체 메서드는 Java에서 이렇게 `this`키워드를 빌려옴으로써 통합되었다.

## 4.4. HyperTalk

자바스크립트가 브라우저에 결합되는 방식에는 애플의 HyperCard라는 제품에 들어가 있던 HyperTalk라는 언어가 영향을 줬다.

HyperTalk는 제품 내에서 컴포넌트에 접근하거나 컴포넌트를 제어할 수 있도록 하는 언어였다. 현재 HTML 태그가 `onclick`같은 이벤트 핸들러 속성을 갖는 건 이 HyperTalk의 영향이다.

## 4.5. Perl

Perl은 자바스크립트의 문자열과 배열, 정규 표현식 처리에 영향을 주었다. 예를 들어서 배열의 `push`, `pop`, `shift`, `unshift`, `splice`메서드는 Perl의 배열 메서드에서 이름을 가져온 것이다. 문자열의 `match`, `replace`, `substr`도 Perl에서 왔다.

정규식과 문자열 매칭 관련 문법도 Perl에서 가져왔다. `&&`과 `||`와 같은 논리 연산자가 true, false가 아니라 피연산자의 실제 값을 반환하는 것도 Perl의 스타일이다.

## 4.6. awk

자바스크립트의 함수는 awk의 영향을 받았다. `function`키워드가 바로 awk에서 가져온 것이다.



# 5. 시간이 없어서 만들어진 실수들

> "저에게 시간과 예산이 조금만 더 있었더라면..."
>
> 니트로 박사

브랜든 아이크에게는 시간이 없었고 일손도 없었다. 자바스크립트는 언제나 바쁜 일정으로 만들어졌고 초기 자바스크립트 제작의 대부분 기간 동안 아이크는 거의 혼자 작업했다. 자바스크립트의 역사를 다룬 글들을 읽어 보면 'xx가 이런 부분을 도와주었다'나 'xx가 이런 부분을 만들어 주었다'라는 문구는 있어도 'xx와 같이 일했다'는 말은 찾아볼 수가 없다. 사람이 없었던 것이다...

## 5.1. var 호이스팅

> 끌어올림이란 '스코프 맨 앞으로 이동'이라는 뜻입니다. 함수 선언은 완벽히 끌어올려지며, 변수 선언은 부분적으로 끌어올려집니다.
>
> 악셀 라우슈마이어 저, 한선용 옮김, '자바스크립트를 말하다' 263쪽

변수 선언과 함수가 스코프의 최상단으로 끌어올려지는 현상인 호이스팅은 자바스크립트의 특이한 동작으로 많이 언급된다. 호이스팅이 무엇인지 그리고 그게 실행 컨텍스트와 관련해서 어떤 의미가 있는지 등등은 이 글의 주제를 벗어난다. 여기서는 그게 왜 만들어졌는지를 다룬다.

[자바스크립트 창시자 브랜든 아이크의 호이스팅 의도 설명](https://twitter.com/BrendanEich/status/522394590301933568)이 담긴 트윗을 참고하였다.

호이스팅은 기술적 이유 때문에 탄생했다. 함수의 호이스팅은 함수를 어디서든 사용할 수 있게 함으로써 스코프 내의 탑다운식 프로그램 분해를 가능하게 했다. 그리고 `let rec`(Scheme에서의 재귀 함수에 대한 개념으로 보인다)을 추가적인 비용 없이 가능하게 했으며 선언 이전의 호출을 가능하게 했다.

`var`로 선언된 변수의 호이스팅은 자바스크립트가 급하게 만들어지면서 생긴(원문은 rush job), 함수 호이스팅의 의도되지 않은 부작용이다.

## 5.2. typeof

자바스크립트에서는 비슷하게 동작하는 객체의 타입(`typeof`의 결과)이 다르다. 예를 들어 문자열 리터럴과 `String` 생성자로 만들어진 문자열 객체의 타입이 다르다고 나온다. 

```js
typeof "hello world" // "string"
typeof new String("hello world") // "object"
```

또한 null에 대해서도 `typeof`의 결과가 `object`라고 나온다.

```js
typeof null // "object"
```

이는 역사적 이유 때문인데 따로 글을 작성하였다(TODO). 아무튼 이런 것은 자바스크립트가 빠르게 만들어지면서 생긴 실수다.

## 5.3. Date 클래스

자바스크립트 1.0의 Date는 Java의 `java.util.Date`를 거의 그대로 가져온 것이다. 그런데 급하게 옮기느라 버그나 이상한 특성까지 옮겨왔다. 예를 들어서 1970년 1월 1일을 0으로 표현하는 것도 그렇고 month만 0에서 11까지로 표현하는 것, 그리고 Y2K 버그가 옮겨왔다.

`java.util.Date`를 옮겨올 때 빠진 것은 `equals`, `before`, `after` 메서드뿐이었다. 이들은 Javascript의 자동 형변환으로 인해 숫자 관계 연산자를 Date 객체에 직접 사용할 수 있었기 때문에 필요없어서 제외되었다.

## 5.4. 자동 형변환과 == 연산자

자동 형변환은 자바스크립트가 간단한 스크립트 언어로 만들어지던 시절 진입 장벽을 낮추기 위해 만들어졌다. 그러나 자바스크립트가 점점 범용 언어로 발전하면서 이 자동 형변환은 혼란과 많은 버그의 원인이 되었다. 이는 특히 `==` 연산자에 대해서 그렇다.

몇몇 형변환은 자바스크립트(당시에는 Mocha)가 10일만에 프로토타이핑된 후 알파 유저들의 요청에 대응하여 만들어진 것이다.

예를 들어 넷스케이프의 내부 사용자들은 문자열 `"404"` HTTP 코드를 숫자 `404`와 `==` 연산자로 비교했을 때 결과가 참이길 바랐다. 그리고 HTML 폼의 빈 필드에 대해서 기본값을 제공하기 위해 빈 문자열은 숫자 맥락에서 `0`으로 해석되길 바랐다. 이런 요구사항들은 자바스크립트와 HTTP/HTML의 용이한 통합을 위해서였다. 지금은 골칫덩이지만.

## 5.5. this

자바스크립트에서 this는 함수가 메서드로 호출되었을 때 해당 메서드에 접근하기 위해 쓰인 객체로 설정된다. 이는 다른 객체지향 언어들에서도 비슷하다. 하지만 자바스크립트에서 this를 객체의 메서드와 개별 함수(메서드로 정의된 게 아닌 함수)에서 같은 형태로 정의하는 바람에 많은 프로그래머들이 혼란을 겪었다.

만약 함수가 생성자나 어떤 객체를 통해서 메서드로 호출된 게 아니라 그냥 함수로 호출되었다면 this는 전역 객체를 가리킨다. 전역 객체는 프로그램의 모든 전역 변수를 포함하고 있기 때문에 그냥 호출된 함수에서 `this`의 프로퍼티에 접근하는 건 전역 변수에 접근하는 것과 같다.

this의 취급이 함수가 어떤 방식으로 호출되었는지에 따라 달라지기 때문에 조심해야 한다.

```js
var obj = {
    name: 'Nabi',
};

function setName(newName) {
    this.name = newName;
}

obj.setName = setName;
obj.setName("objName"); // obj.name은 'objName'가 된다

console.log(obj.name); // 'objName'

setName("globalName"); // this는 전역 객체를 가리키므로 전역 객체의 name 프로퍼티가 'globalName'가 된다
console.log(name); // 'globalName'
```

HTML에서도 자바스크립트 코드를 메서드 형식으로 호출된 함수처럼 변환해 주는 경우가 있기 때문에 이런 혼란이 더 커진다. 예를 들어서 다음과 같은 코드가 있다고 하자.

```html
<button name="B" onclick="alert(this.name + " clicked")>Click me</button>
```

이 버튼을 클릭했을 시 버튼의 `onclick`메서드가 호출되는데 이때 `this`는 버튼 객체를 가리킨다. 그래서 `this.name`은 버튼의 `name` 프로퍼티가 된다.

> 표준을 제정하는 위원회가 언어의 나쁜 점들을 제거하기는 어렵습니다. 왜냐하면 위원회가 나쁜 점을 제거하게 되는 경우 기존에 그 나쁜 점을 사용하여 개발된 프로그램들에 영향을 미치기 때문입니다. 그러므로 위원회는 보통 기존의 불완전함 위에 더 많은 기능을 추가하는 것 외에는 힘이 없습니다. 설상가상으로 새로 추가한 기능들이 기존 기능들과 조화를 이루지 못하는 경우도 있기 때문에, 언어의 나쁜 점이 가중되는 결과를 낳기도 합니다.
>
> 더글러스 크록포드 저, 김명신 옮김, '자바스크립트 핵심 가이드', 12쪽

# 우리는 언제나 시간이 없다

> var hoisting was thus unintended consequence of function hoisting, no block scope, 자바스크립트 as a 1995 rush job. 
>
> 브랜든 아이크, 자바스크립트의 제작자

자바스크립트의 기이해 보이는 면들은 대부분 초기 설계에 기반한다. 자바스크립트는 아주 촉박한 시간 내에 만들어졌고 모든 것을 신경쓸 여유가 없었다. 거의 실수에 의해 만들어진 것도 많다.

요즘 자바스크립트의 새로운 기능들이나 프로포절을 보면 매우 많은 것이 고려된다. 브랜든 아이크 또한 자바스크립트Conf 발표에서 `eval`, 전역 객체, `with`와 같은 자바스크립트의 '악'(원문은 evil)들을 이기는 데에 이런 새로운 흐름이 도움이 될 거라고 직접 언급할 정도이다.

하지만 지금의 낯선 부분들은 초기 설계와 이후 한동안 자바스크립트가 장난감같은 언어로 쓰이던 시절 있었던 수많은 것들과의 호환성을 위해서 남아 있는 것들이 많다. 물론 꼭 그런 것만은 아니고, 프로토타입과 같이 당시에는 상황상 최선의 선택이라고 생각될 만한 것도 있었다.

이 글에서는 그때의 상황을 좀더 자세히 알아보고, 거기에 기반해서 몇 가지 기능들이 왜 생겼는지 알아본다. 모든 걸 알 수는 없지만 지금 시점에서 파헤쳐 볼 수 있는 것들도 있으니까.

# 자바스크립트의 탄생, 그 이후

이렇게 자바스크립트는 여러 상황과 결정 끝에 탄생했다. 그러나 넷스케이프의 자바스크립트와 마이크로소프트가 리버스 엔지니어링을 통해 만든 구현체 간의 차이로 인해 호환성 문제가 많았다. 그래서 1996년 Ecma의 지원을 받아서 표준화 작업이 진행되었고 1997년 `ECMAScript`가 세상에 나왔다.

# 이름 색인

* 팀 버너스-리 : Tim Berners-Lee
* 브랜든 아이크 : Brendan Eich
* 마크 앤드리슨 : Marc Andreessen
* 에릭 비나 : Eric Bina
* 닉 톰슨 : Nick Thompson
* 빌 조이 : Bill Joy

* 썬 마이크로시스템즈 : Sun Microsystems
* 모카(자바스크립트의 초기 코드네임) : Mocha

# 참고 문헌

[참고 문헌이 많아져서 따로 문서를 만들었다.](https://witch.work/posts/자바스크립트-history-references)

https://stackoverflow.com/questions/541167/what-is-the-rationale-for-the-behavior-of-the-this-keyword-in-javascript

https://kimsereylam.com/racket/2019/02/06/lambda-calculus-and-closure.html